# 1 "/home/nvidia/checkerboard-detection/src/checkerboard/cuda/getCheckerBoardLines.cu"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
# 1
#pragma GCC diagnostic push
# 1
#pragma GCC diagnostic ignored "-Wunused-variable"
# 1
#pragma GCC diagnostic ignored "-Wunused-function"
# 1
static char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}
# 1
#pragma GCC diagnostic pop
# 1
#pragma GCC diagnostic ignored "-Wunused-variable"

# 1
#define __nv_is_extended_device_lambda_closure_type(X) false
#define __nv_is_extended_host_device_lambda_closure_type(X) false

# 1
# 56 "/usr/local/cuda-9.0/include/cuda_runtime.h"
#pragma GCC diagnostic push
# 59
#pragma GCC diagnostic ignored "-Wunused-function"
# 61 "/usr/local/cuda-9.0/include/device_types.h"
#if 0
# 61
enum cudaRoundMode { 
# 63
cudaRoundNearest, 
# 64
cudaRoundZero, 
# 65
cudaRoundPosInf, 
# 66
cudaRoundMinInf
# 67
}; 
#endif
# 93 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 93
struct char1 { 
# 95
signed char x; 
# 96
}; 
#endif
# 98 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 98
struct uchar1 { 
# 100
unsigned char x; 
# 101
}; 
#endif
# 104 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 104
struct __attribute((aligned(2))) char2 { 
# 106
signed char x, y; 
# 107
}; 
#endif
# 109 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 109
struct __attribute((aligned(2))) uchar2 { 
# 111
unsigned char x, y; 
# 112
}; 
#endif
# 114 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 114
struct char3 { 
# 116
signed char x, y, z; 
# 117
}; 
#endif
# 119 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 119
struct uchar3 { 
# 121
unsigned char x, y, z; 
# 122
}; 
#endif
# 124 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 124
struct __attribute((aligned(4))) char4 { 
# 126
signed char x, y, z, w; 
# 127
}; 
#endif
# 129 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 129
struct __attribute((aligned(4))) uchar4 { 
# 131
unsigned char x, y, z, w; 
# 132
}; 
#endif
# 134 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 134
struct short1 { 
# 136
short x; 
# 137
}; 
#endif
# 139 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 139
struct ushort1 { 
# 141
unsigned short x; 
# 142
}; 
#endif
# 144 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 144
struct __attribute((aligned(4))) short2 { 
# 146
short x, y; 
# 147
}; 
#endif
# 149 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 149
struct __attribute((aligned(4))) ushort2 { 
# 151
unsigned short x, y; 
# 152
}; 
#endif
# 154 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 154
struct short3 { 
# 156
short x, y, z; 
# 157
}; 
#endif
# 159 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 159
struct ushort3 { 
# 161
unsigned short x, y, z; 
# 162
}; 
#endif
# 164 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 164
struct __attribute((aligned(8))) short4 { short x; short y; short z; short w; }; 
#endif
# 165 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 165
struct __attribute((aligned(8))) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
# 167 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 167
struct int1 { 
# 169
int x; 
# 170
}; 
#endif
# 172 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 172
struct uint1 { 
# 174
unsigned x; 
# 175
}; 
#endif
# 177 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 177
struct __attribute((aligned(8))) int2 { int x; int y; }; 
#endif
# 178 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 178
struct __attribute((aligned(8))) uint2 { unsigned x; unsigned y; }; 
#endif
# 180 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 180
struct int3 { 
# 182
int x, y, z; 
# 183
}; 
#endif
# 185 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 185
struct uint3 { 
# 187
unsigned x, y, z; 
# 188
}; 
#endif
# 190 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 190
struct __attribute((aligned(16))) int4 { 
# 192
int x, y, z, w; 
# 193
}; 
#endif
# 195 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 195
struct __attribute((aligned(16))) uint4 { 
# 197
unsigned x, y, z, w; 
# 198
}; 
#endif
# 200 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 200
struct long1 { 
# 202
long x; 
# 203
}; 
#endif
# 205 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 205
struct ulong1 { 
# 207
unsigned long x; 
# 208
}; 
#endif
# 215 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 215
struct __attribute((aligned((2) * sizeof(long)))) long2 { 
# 217
long x, y; 
# 218
}; 
#endif
# 220 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 220
struct __attribute((aligned((2) * sizeof(unsigned long)))) ulong2 { 
# 222
unsigned long x, y; 
# 223
}; 
#endif
# 227 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 227
struct long3 { 
# 229
long x, y, z; 
# 230
}; 
#endif
# 232 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 232
struct ulong3 { 
# 234
unsigned long x, y, z; 
# 235
}; 
#endif
# 237 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 237
struct __attribute((aligned(16))) long4 { 
# 239
long x, y, z, w; 
# 240
}; 
#endif
# 242 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 242
struct __attribute((aligned(16))) ulong4 { 
# 244
unsigned long x, y, z, w; 
# 245
}; 
#endif
# 247 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 247
struct float1 { 
# 249
float x; 
# 250
}; 
#endif
# 269 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 269
struct __attribute((aligned(8))) float2 { float x; float y; }; 
#endif
# 274 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 274
struct float3 { 
# 276
float x, y, z; 
# 277
}; 
#endif
# 279 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 279
struct __attribute((aligned(16))) float4 { 
# 281
float x, y, z, w; 
# 282
}; 
#endif
# 284 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 284
struct longlong1 { 
# 286
long long x; 
# 287
}; 
#endif
# 289 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 289
struct ulonglong1 { 
# 291
unsigned long long x; 
# 292
}; 
#endif
# 294 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 294
struct __attribute((aligned(16))) longlong2 { 
# 296
long long x, y; 
# 297
}; 
#endif
# 299 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 299
struct __attribute((aligned(16))) ulonglong2 { 
# 301
unsigned long long x, y; 
# 302
}; 
#endif
# 304 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 304
struct longlong3 { 
# 306
long long x, y, z; 
# 307
}; 
#endif
# 309 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 309
struct ulonglong3 { 
# 311
unsigned long long x, y, z; 
# 312
}; 
#endif
# 314 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 314
struct __attribute((aligned(16))) longlong4 { 
# 316
long long x, y, z, w; 
# 317
}; 
#endif
# 319 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 319
struct __attribute((aligned(16))) ulonglong4 { 
# 321
unsigned long long x, y, z, w; 
# 322
}; 
#endif
# 324 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 324
struct double1 { 
# 326
double x; 
# 327
}; 
#endif
# 329 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 329
struct __attribute((aligned(16))) double2 { 
# 331
double x, y; 
# 332
}; 
#endif
# 334 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 334
struct double3 { 
# 336
double x, y, z; 
# 337
}; 
#endif
# 339 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 339
struct __attribute((aligned(16))) double4 { 
# 341
double x, y, z, w; 
# 342
}; 
#endif
# 356 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef char1 
# 356
char1; 
#endif
# 357 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef uchar1 
# 357
uchar1; 
#endif
# 358 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef char2 
# 358
char2; 
#endif
# 359 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef uchar2 
# 359
uchar2; 
#endif
# 360 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef char3 
# 360
char3; 
#endif
# 361 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef uchar3 
# 361
uchar3; 
#endif
# 362 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef char4 
# 362
char4; 
#endif
# 363 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef uchar4 
# 363
uchar4; 
#endif
# 364 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef short1 
# 364
short1; 
#endif
# 365 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ushort1 
# 365
ushort1; 
#endif
# 366 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef short2 
# 366
short2; 
#endif
# 367 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ushort2 
# 367
ushort2; 
#endif
# 368 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef short3 
# 368
short3; 
#endif
# 369 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ushort3 
# 369
ushort3; 
#endif
# 370 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef short4 
# 370
short4; 
#endif
# 371 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ushort4 
# 371
ushort4; 
#endif
# 372 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef int1 
# 372
int1; 
#endif
# 373 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef uint1 
# 373
uint1; 
#endif
# 374 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef int2 
# 374
int2; 
#endif
# 375 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef uint2 
# 375
uint2; 
#endif
# 376 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef int3 
# 376
int3; 
#endif
# 377 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef uint3 
# 377
uint3; 
#endif
# 378 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef int4 
# 378
int4; 
#endif
# 379 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef uint4 
# 379
uint4; 
#endif
# 380 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef long1 
# 380
long1; 
#endif
# 381 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ulong1 
# 381
ulong1; 
#endif
# 382 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef long2 
# 382
long2; 
#endif
# 383 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ulong2 
# 383
ulong2; 
#endif
# 384 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef long3 
# 384
long3; 
#endif
# 385 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ulong3 
# 385
ulong3; 
#endif
# 386 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef long4 
# 386
long4; 
#endif
# 387 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ulong4 
# 387
ulong4; 
#endif
# 388 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef float1 
# 388
float1; 
#endif
# 389 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef float2 
# 389
float2; 
#endif
# 390 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef float3 
# 390
float3; 
#endif
# 391 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef float4 
# 391
float4; 
#endif
# 392 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef longlong1 
# 392
longlong1; 
#endif
# 393 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ulonglong1 
# 393
ulonglong1; 
#endif
# 394 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef longlong2 
# 394
longlong2; 
#endif
# 395 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ulonglong2 
# 395
ulonglong2; 
#endif
# 396 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef longlong3 
# 396
longlong3; 
#endif
# 397 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ulonglong3 
# 397
ulonglong3; 
#endif
# 398 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef longlong4 
# 398
longlong4; 
#endif
# 399 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef ulonglong4 
# 399
ulonglong4; 
#endif
# 400 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef double1 
# 400
double1; 
#endif
# 401 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef double2 
# 401
double2; 
#endif
# 402 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef double3 
# 402
double3; 
#endif
# 403 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef double4 
# 403
double4; 
#endif
# 411 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
# 411
struct dim3 { 
# 413
unsigned x, y, z; 
# 419
}; 
#endif
# 421 "/usr/local/cuda-9.0/include/vector_types.h"
#if 0
typedef dim3 
# 421
dim3; 
#endif
# 149 "/usr/lib/gcc/aarch64-linux-gnu/5/include/stddef.h" 3
typedef long ptrdiff_t; 
# 216 "/usr/lib/gcc/aarch64-linux-gnu/5/include/stddef.h" 3
typedef unsigned long size_t; 
#include "crt/host_runtime.h"
# 429 "/usr/lib/gcc/aarch64-linux-gnu/5/include/stddef.h" 3
typedef 
# 426
struct { 
# 427
long long __max_align_ll __attribute((__aligned__(__alignof__(long long)))); 
# 428
long double __max_align_ld __attribute((__aligned__(__alignof__(long double)))); 
# 429
} max_align_t; 
# 436
typedef __decltype((nullptr)) nullptr_t; 
# 171 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 171
enum cudaError { 
# 178
cudaSuccess, 
# 184
cudaErrorMissingConfiguration, 
# 190
cudaErrorMemoryAllocation, 
# 196
cudaErrorInitializationError, 
# 206 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorLaunchFailure, 
# 215 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorPriorLaunchFailure, 
# 226 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorLaunchTimeout, 
# 235 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorLaunchOutOfResources, 
# 241
cudaErrorInvalidDeviceFunction, 
# 250 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorInvalidConfiguration, 
# 256
cudaErrorInvalidDevice, 
# 262
cudaErrorInvalidValue, 
# 268
cudaErrorInvalidPitchValue, 
# 274
cudaErrorInvalidSymbol, 
# 279
cudaErrorMapBufferObjectFailed, 
# 284
cudaErrorUnmapBufferObjectFailed, 
# 290
cudaErrorInvalidHostPointer, 
# 296
cudaErrorInvalidDevicePointer, 
# 302
cudaErrorInvalidTexture, 
# 308
cudaErrorInvalidTextureBinding, 
# 315
cudaErrorInvalidChannelDescriptor, 
# 321
cudaErrorInvalidMemcpyDirection, 
# 331 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorAddressOfConstant, 
# 340 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorTextureFetchFailed, 
# 349 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorTextureNotBound, 
# 358 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorSynchronizationError, 
# 364
cudaErrorInvalidFilterSetting, 
# 370
cudaErrorInvalidNormSetting, 
# 378
cudaErrorMixedDeviceExecution, 
# 385
cudaErrorCudartUnloading, 
# 390
cudaErrorUnknown, 
# 398
cudaErrorNotYetImplemented, 
# 407 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorMemoryValueTooLarge, 
# 414
cudaErrorInvalidResourceHandle, 
# 422
cudaErrorNotReady, 
# 429
cudaErrorInsufficientDriver, 
# 442 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorSetOnActiveProcess, 
# 448
cudaErrorInvalidSurface, 
# 454
cudaErrorNoDevice, 
# 460
cudaErrorECCUncorrectable, 
# 465
cudaErrorSharedObjectSymbolNotFound, 
# 470
cudaErrorSharedObjectInitFailed, 
# 476
cudaErrorUnsupportedLimit, 
# 482
cudaErrorDuplicateVariableName, 
# 488
cudaErrorDuplicateTextureName, 
# 494
cudaErrorDuplicateSurfaceName, 
# 504 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorDevicesUnavailable, 
# 509
cudaErrorInvalidKernelImage, 
# 517
cudaErrorNoKernelImageForDevice, 
# 530 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorIncompatibleDriverContext, 
# 537
cudaErrorPeerAccessAlreadyEnabled, 
# 544
cudaErrorPeerAccessNotEnabled, 
# 550
cudaErrorDeviceAlreadyInUse = 54, 
# 557
cudaErrorProfilerDisabled, 
# 565
cudaErrorProfilerNotInitialized, 
# 572
cudaErrorProfilerAlreadyStarted, 
# 579
cudaErrorProfilerAlreadyStopped, 
# 587
cudaErrorAssert, 
# 594
cudaErrorTooManyPeers, 
# 600
cudaErrorHostMemoryAlreadyRegistered, 
# 606
cudaErrorHostMemoryNotRegistered, 
# 611
cudaErrorOperatingSystem, 
# 617
cudaErrorPeerAccessUnsupported, 
# 624
cudaErrorLaunchMaxDepthExceeded, 
# 632
cudaErrorLaunchFileScopedTex, 
# 640
cudaErrorLaunchFileScopedSurf, 
# 655 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorSyncDepthExceeded, 
# 667 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorLaunchPendingCountExceeded, 
# 672
cudaErrorNotPermitted, 
# 678
cudaErrorNotSupported, 
# 687 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorHardwareStackError, 
# 695
cudaErrorIllegalInstruction, 
# 704 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorMisalignedAddress, 
# 715 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorInvalidAddressSpace, 
# 723
cudaErrorInvalidPc, 
# 731
cudaErrorIllegalAddress, 
# 737
cudaErrorInvalidPtx, 
# 742
cudaErrorInvalidGraphicsContext, 
# 748
cudaErrorNvlinkUncorrectable, 
# 755
cudaErrorJitCompilerNotFound, 
# 764 "/usr/local/cuda-9.0/include/driver_types.h"
cudaErrorCooperativeLaunchTooLarge, 
# 769
cudaErrorStartupFailure = 127, 
# 777
cudaErrorApiFailureBase = 10000
# 778
}; 
#endif
# 783 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 783
enum cudaChannelFormatKind { 
# 785
cudaChannelFormatKindSigned, 
# 786
cudaChannelFormatKindUnsigned, 
# 787
cudaChannelFormatKindFloat, 
# 788
cudaChannelFormatKindNone
# 789
}; 
#endif
# 794 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 794
struct cudaChannelFormatDesc { 
# 796
int x; 
# 797
int y; 
# 798
int z; 
# 799
int w; 
# 800
cudaChannelFormatKind f; 
# 801
}; 
#endif
# 806 "/usr/local/cuda-9.0/include/driver_types.h"
typedef struct cudaArray *cudaArray_t; 
# 811
typedef const cudaArray *cudaArray_const_t; 
# 813
struct cudaArray; 
# 818
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
# 823
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
# 825
struct cudaMipmappedArray; 
# 830
#if 0
# 830
enum cudaMemoryType { 
# 832
cudaMemoryTypeHost = 1, 
# 833
cudaMemoryTypeDevice
# 834
}; 
#endif
# 839 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 839
enum cudaMemcpyKind { 
# 841
cudaMemcpyHostToHost, 
# 842
cudaMemcpyHostToDevice, 
# 843
cudaMemcpyDeviceToHost, 
# 844
cudaMemcpyDeviceToDevice, 
# 845
cudaMemcpyDefault
# 846
}; 
#endif
# 853 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 853
struct cudaPitchedPtr { 
# 855
void *ptr; 
# 856
size_t pitch; 
# 857
size_t xsize; 
# 858
size_t ysize; 
# 859
}; 
#endif
# 866 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 866
struct cudaExtent { 
# 868
size_t width; 
# 869
size_t height; 
# 870
size_t depth; 
# 871
}; 
#endif
# 878 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 878
struct cudaPos { 
# 880
size_t x; 
# 881
size_t y; 
# 882
size_t z; 
# 883
}; 
#endif
# 888 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 888
struct cudaMemcpy3DParms { 
# 890
cudaArray_t srcArray; 
# 891
cudaPos srcPos; 
# 892
cudaPitchedPtr srcPtr; 
# 894
cudaArray_t dstArray; 
# 895
cudaPos dstPos; 
# 896
cudaPitchedPtr dstPtr; 
# 898
cudaExtent extent; 
# 899
cudaMemcpyKind kind; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 900
}; 
#endif
# 905 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 905
struct cudaMemcpy3DPeerParms { 
# 907
cudaArray_t srcArray; 
# 908
cudaPos srcPos; 
# 909
cudaPitchedPtr srcPtr; 
# 910
int srcDevice; 
# 912
cudaArray_t dstArray; 
# 913
cudaPos dstPos; 
# 914
cudaPitchedPtr dstPtr; 
# 915
int dstDevice; 
# 917
cudaExtent extent; 
# 918
}; 
#endif
# 923 "/usr/local/cuda-9.0/include/driver_types.h"
struct cudaGraphicsResource; 
# 928
#if 0
# 928
enum cudaGraphicsRegisterFlags { 
# 930
cudaGraphicsRegisterFlagsNone, 
# 931
cudaGraphicsRegisterFlagsReadOnly, 
# 932
cudaGraphicsRegisterFlagsWriteDiscard, 
# 933
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
# 934
cudaGraphicsRegisterFlagsTextureGather = 8
# 935
}; 
#endif
# 940 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 940
enum cudaGraphicsMapFlags { 
# 942
cudaGraphicsMapFlagsNone, 
# 943
cudaGraphicsMapFlagsReadOnly, 
# 944
cudaGraphicsMapFlagsWriteDiscard
# 945
}; 
#endif
# 950 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 950
enum cudaGraphicsCubeFace { 
# 952
cudaGraphicsCubeFacePositiveX, 
# 953
cudaGraphicsCubeFaceNegativeX, 
# 954
cudaGraphicsCubeFacePositiveY, 
# 955
cudaGraphicsCubeFaceNegativeY, 
# 956
cudaGraphicsCubeFacePositiveZ, 
# 957
cudaGraphicsCubeFaceNegativeZ
# 958
}; 
#endif
# 963 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 963
enum cudaResourceType { 
# 965
cudaResourceTypeArray, 
# 966
cudaResourceTypeMipmappedArray, 
# 967
cudaResourceTypeLinear, 
# 968
cudaResourceTypePitch2D
# 969
}; 
#endif
# 974 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 974
enum cudaResourceViewFormat { 
# 976
cudaResViewFormatNone, 
# 977
cudaResViewFormatUnsignedChar1, 
# 978
cudaResViewFormatUnsignedChar2, 
# 979
cudaResViewFormatUnsignedChar4, 
# 980
cudaResViewFormatSignedChar1, 
# 981
cudaResViewFormatSignedChar2, 
# 982
cudaResViewFormatSignedChar4, 
# 983
cudaResViewFormatUnsignedShort1, 
# 984
cudaResViewFormatUnsignedShort2, 
# 985
cudaResViewFormatUnsignedShort4, 
# 986
cudaResViewFormatSignedShort1, 
# 987
cudaResViewFormatSignedShort2, 
# 988
cudaResViewFormatSignedShort4, 
# 989
cudaResViewFormatUnsignedInt1, 
# 990
cudaResViewFormatUnsignedInt2, 
# 991
cudaResViewFormatUnsignedInt4, 
# 992
cudaResViewFormatSignedInt1, 
# 993
cudaResViewFormatSignedInt2, 
# 994
cudaResViewFormatSignedInt4, 
# 995
cudaResViewFormatHalf1, 
# 996
cudaResViewFormatHalf2, 
# 997
cudaResViewFormatHalf4, 
# 998
cudaResViewFormatFloat1, 
# 999
cudaResViewFormatFloat2, 
# 1000
cudaResViewFormatFloat4, 
# 1001
cudaResViewFormatUnsignedBlockCompressed1, 
# 1002
cudaResViewFormatUnsignedBlockCompressed2, 
# 1003
cudaResViewFormatUnsignedBlockCompressed3, 
# 1004
cudaResViewFormatUnsignedBlockCompressed4, 
# 1005
cudaResViewFormatSignedBlockCompressed4, 
# 1006
cudaResViewFormatUnsignedBlockCompressed5, 
# 1007
cudaResViewFormatSignedBlockCompressed5, 
# 1008
cudaResViewFormatUnsignedBlockCompressed6H, 
# 1009
cudaResViewFormatSignedBlockCompressed6H, 
# 1010
cudaResViewFormatUnsignedBlockCompressed7
# 1011
}; 
#endif
# 1016 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1016
struct cudaResourceDesc { 
# 1017
cudaResourceType resType; 
# 1019
union { 
# 1020
struct { 
# 1021
cudaArray_t array; 
# 1022
} array; 
# 1023
struct { 
# 1024
cudaMipmappedArray_t mipmap; 
# 1025
} mipmap; 
# 1026
struct { 
# 1027
void *devPtr; 
# 1028
cudaChannelFormatDesc desc; 
# 1029
size_t sizeInBytes; 
# 1030
} linear; 
# 1031
struct { 
# 1032
void *devPtr; 
# 1033
cudaChannelFormatDesc desc; 
# 1034
size_t width; 
# 1035
size_t height; 
# 1036
size_t pitchInBytes; 
# 1037
} pitch2D; 
# 1038
} res; 
# 1039
}; 
#endif
# 1044 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1044
struct cudaResourceViewDesc { 
# 1046
cudaResourceViewFormat format; 
# 1047
size_t width; 
# 1048
size_t height; 
# 1049
size_t depth; 
# 1050
unsigned firstMipmapLevel; 
# 1051
unsigned lastMipmapLevel; 
# 1052
unsigned firstLayer; 
# 1053
unsigned lastLayer; 
# 1054
}; 
#endif
# 1059 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1059
struct cudaPointerAttributes { 
# 1065
cudaMemoryType memoryType; 
# 1076 "/usr/local/cuda-9.0/include/driver_types.h"
int device; 
# 1082
void *devicePointer; 
# 1088
void *hostPointer; 
# 1093
int isManaged; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 1094
}; 
#endif
# 1099 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1099
struct cudaFuncAttributes { 
# 1106
size_t sharedSizeBytes; 
# 1112
size_t constSizeBytes; 
# 1117
size_t localSizeBytes; 
# 1124
int maxThreadsPerBlock; 
# 1129
int numRegs; 
# 1136
int ptxVersion; 
# 1143
int binaryVersion; 
# 1149
int cacheModeCA; 
# 1156
int maxDynamicSharedSizeBytes; 
# 1163
int preferredShmemCarveout; 
# 1164
}; 
#endif
# 1169 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1169
enum cudaFuncAttribute { 
# 1171
cudaFuncAttributeMaxDynamicSharedMemorySize = 8, 
# 1172
cudaFuncAttributePreferredSharedMemoryCarveout, 
# 1173
cudaFuncAttributeMax
# 1174
}; 
#endif
# 1179 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1179
enum cudaFuncCache { 
# 1181
cudaFuncCachePreferNone, 
# 1182
cudaFuncCachePreferShared, 
# 1183
cudaFuncCachePreferL1, 
# 1184
cudaFuncCachePreferEqual
# 1185
}; 
#endif
# 1191 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1191
enum cudaSharedMemConfig { 
# 1193
cudaSharedMemBankSizeDefault, 
# 1194
cudaSharedMemBankSizeFourByte, 
# 1195
cudaSharedMemBankSizeEightByte
# 1196
}; 
#endif
# 1201 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1201
enum cudaSharedCarveout { 
# 1202
cudaSharedmemCarveoutDefault = (-1), 
# 1203
cudaSharedmemCarveoutMaxShared = 100, 
# 1204
cudaSharedmemCarveoutMaxL1 = 0
# 1205
}; 
#endif
# 1210 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1210
enum cudaComputeMode { 
# 1212
cudaComputeModeDefault, 
# 1213
cudaComputeModeExclusive, 
# 1214
cudaComputeModeProhibited, 
# 1215
cudaComputeModeExclusiveProcess
# 1216
}; 
#endif
# 1221 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1221
enum cudaLimit { 
# 1223
cudaLimitStackSize, 
# 1224
cudaLimitPrintfFifoSize, 
# 1225
cudaLimitMallocHeapSize, 
# 1226
cudaLimitDevRuntimeSyncDepth, 
# 1227
cudaLimitDevRuntimePendingLaunchCount
# 1228
}; 
#endif
# 1233 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1233
enum cudaMemoryAdvise { 
# 1235
cudaMemAdviseSetReadMostly = 1, 
# 1236
cudaMemAdviseUnsetReadMostly, 
# 1237
cudaMemAdviseSetPreferredLocation, 
# 1238
cudaMemAdviseUnsetPreferredLocation, 
# 1239
cudaMemAdviseSetAccessedBy, 
# 1240
cudaMemAdviseUnsetAccessedBy
# 1241
}; 
#endif
# 1246 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1246
enum cudaMemRangeAttribute { 
# 1248
cudaMemRangeAttributeReadMostly = 1, 
# 1249
cudaMemRangeAttributePreferredLocation, 
# 1250
cudaMemRangeAttributeAccessedBy, 
# 1251
cudaMemRangeAttributeLastPrefetchLocation
# 1252
}; 
#endif
# 1257 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1257
enum cudaOutputMode { 
# 1259
cudaKeyValuePair, 
# 1260
cudaCSV
# 1261
}; 
#endif
# 1266 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1266
enum cudaDeviceAttr { 
# 1268
cudaDevAttrMaxThreadsPerBlock = 1, 
# 1269
cudaDevAttrMaxBlockDimX, 
# 1270
cudaDevAttrMaxBlockDimY, 
# 1271
cudaDevAttrMaxBlockDimZ, 
# 1272
cudaDevAttrMaxGridDimX, 
# 1273
cudaDevAttrMaxGridDimY, 
# 1274
cudaDevAttrMaxGridDimZ, 
# 1275
cudaDevAttrMaxSharedMemoryPerBlock, 
# 1276
cudaDevAttrTotalConstantMemory, 
# 1277
cudaDevAttrWarpSize, 
# 1278
cudaDevAttrMaxPitch, 
# 1279
cudaDevAttrMaxRegistersPerBlock, 
# 1280
cudaDevAttrClockRate, 
# 1281
cudaDevAttrTextureAlignment, 
# 1282
cudaDevAttrGpuOverlap, 
# 1283
cudaDevAttrMultiProcessorCount, 
# 1284
cudaDevAttrKernelExecTimeout, 
# 1285
cudaDevAttrIntegrated, 
# 1286
cudaDevAttrCanMapHostMemory, 
# 1287
cudaDevAttrComputeMode, 
# 1288
cudaDevAttrMaxTexture1DWidth, 
# 1289
cudaDevAttrMaxTexture2DWidth, 
# 1290
cudaDevAttrMaxTexture2DHeight, 
# 1291
cudaDevAttrMaxTexture3DWidth, 
# 1292
cudaDevAttrMaxTexture3DHeight, 
# 1293
cudaDevAttrMaxTexture3DDepth, 
# 1294
cudaDevAttrMaxTexture2DLayeredWidth, 
# 1295
cudaDevAttrMaxTexture2DLayeredHeight, 
# 1296
cudaDevAttrMaxTexture2DLayeredLayers, 
# 1297
cudaDevAttrSurfaceAlignment, 
# 1298
cudaDevAttrConcurrentKernels, 
# 1299
cudaDevAttrEccEnabled, 
# 1300
cudaDevAttrPciBusId, 
# 1301
cudaDevAttrPciDeviceId, 
# 1302
cudaDevAttrTccDriver, 
# 1303
cudaDevAttrMemoryClockRate, 
# 1304
cudaDevAttrGlobalMemoryBusWidth, 
# 1305
cudaDevAttrL2CacheSize, 
# 1306
cudaDevAttrMaxThreadsPerMultiProcessor, 
# 1307
cudaDevAttrAsyncEngineCount, 
# 1308
cudaDevAttrUnifiedAddressing, 
# 1309
cudaDevAttrMaxTexture1DLayeredWidth, 
# 1310
cudaDevAttrMaxTexture1DLayeredLayers, 
# 1311
cudaDevAttrMaxTexture2DGatherWidth = 45, 
# 1312
cudaDevAttrMaxTexture2DGatherHeight, 
# 1313
cudaDevAttrMaxTexture3DWidthAlt, 
# 1314
cudaDevAttrMaxTexture3DHeightAlt, 
# 1315
cudaDevAttrMaxTexture3DDepthAlt, 
# 1316
cudaDevAttrPciDomainId, 
# 1317
cudaDevAttrTexturePitchAlignment, 
# 1318
cudaDevAttrMaxTextureCubemapWidth, 
# 1319
cudaDevAttrMaxTextureCubemapLayeredWidth, 
# 1320
cudaDevAttrMaxTextureCubemapLayeredLayers, 
# 1321
cudaDevAttrMaxSurface1DWidth, 
# 1322
cudaDevAttrMaxSurface2DWidth, 
# 1323
cudaDevAttrMaxSurface2DHeight, 
# 1324
cudaDevAttrMaxSurface3DWidth, 
# 1325
cudaDevAttrMaxSurface3DHeight, 
# 1326
cudaDevAttrMaxSurface3DDepth, 
# 1327
cudaDevAttrMaxSurface1DLayeredWidth, 
# 1328
cudaDevAttrMaxSurface1DLayeredLayers, 
# 1329
cudaDevAttrMaxSurface2DLayeredWidth, 
# 1330
cudaDevAttrMaxSurface2DLayeredHeight, 
# 1331
cudaDevAttrMaxSurface2DLayeredLayers, 
# 1332
cudaDevAttrMaxSurfaceCubemapWidth, 
# 1333
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
# 1334
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
# 1335
cudaDevAttrMaxTexture1DLinearWidth, 
# 1336
cudaDevAttrMaxTexture2DLinearWidth, 
# 1337
cudaDevAttrMaxTexture2DLinearHeight, 
# 1338
cudaDevAttrMaxTexture2DLinearPitch, 
# 1339
cudaDevAttrMaxTexture2DMipmappedWidth, 
# 1340
cudaDevAttrMaxTexture2DMipmappedHeight, 
# 1341
cudaDevAttrComputeCapabilityMajor, 
# 1342
cudaDevAttrComputeCapabilityMinor, 
# 1343
cudaDevAttrMaxTexture1DMipmappedWidth, 
# 1344
cudaDevAttrStreamPrioritiesSupported, 
# 1345
cudaDevAttrGlobalL1CacheSupported, 
# 1346
cudaDevAttrLocalL1CacheSupported, 
# 1347
cudaDevAttrMaxSharedMemoryPerMultiprocessor, 
# 1348
cudaDevAttrMaxRegistersPerMultiprocessor, 
# 1349
cudaDevAttrManagedMemory, 
# 1350
cudaDevAttrIsMultiGpuBoard, 
# 1351
cudaDevAttrMultiGpuBoardGroupID, 
# 1352
cudaDevAttrHostNativeAtomicSupported, 
# 1353
cudaDevAttrSingleToDoublePrecisionPerfRatio, 
# 1354
cudaDevAttrPageableMemoryAccess, 
# 1355
cudaDevAttrConcurrentManagedAccess, 
# 1356
cudaDevAttrComputePreemptionSupported, 
# 1357
cudaDevAttrCanUseHostPointerForRegisteredMem, 
# 1358
cudaDevAttrReserved92, 
# 1359
cudaDevAttrReserved93, 
# 1360
cudaDevAttrReserved94, 
# 1361
cudaDevAttrCooperativeLaunch, 
# 1362
cudaDevAttrCooperativeMultiDeviceLaunch, 
# 1363
cudaDevAttrMaxSharedMemoryPerBlockOptin
# 1364
}; 
#endif
# 1370 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1370
enum cudaDeviceP2PAttr { 
# 1371
cudaDevP2PAttrPerformanceRank = 1, 
# 1372
cudaDevP2PAttrAccessSupported, 
# 1373
cudaDevP2PAttrNativeAtomicSupported
# 1374
}; 
#endif
# 1378 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1378
struct cudaDeviceProp { 
# 1380
char name[256]; 
# 1381
size_t totalGlobalMem; 
# 1382
size_t sharedMemPerBlock; 
# 1383
int regsPerBlock; 
# 1384
int warpSize; 
# 1385
size_t memPitch; 
# 1386
int maxThreadsPerBlock; 
# 1387
int maxThreadsDim[3]; 
# 1388
int maxGridSize[3]; 
# 1389
int clockRate; 
# 1390
size_t totalConstMem; 
# 1391
int major; 
# 1392
int minor; 
# 1393
size_t textureAlignment; 
# 1394
size_t texturePitchAlignment; 
# 1395
int deviceOverlap; 
# 1396
int multiProcessorCount; 
# 1397
int kernelExecTimeoutEnabled; 
# 1398
int integrated; 
# 1399
int canMapHostMemory; 
# 1400
int computeMode; 
# 1401
int maxTexture1D; 
# 1402
int maxTexture1DMipmap; 
# 1403
int maxTexture1DLinear; 
# 1404
int maxTexture2D[2]; 
# 1405
int maxTexture2DMipmap[2]; 
# 1406
int maxTexture2DLinear[3]; 
# 1407
int maxTexture2DGather[2]; 
# 1408
int maxTexture3D[3]; 
# 1409
int maxTexture3DAlt[3]; 
# 1410
int maxTextureCubemap; 
# 1411
int maxTexture1DLayered[2]; 
# 1412
int maxTexture2DLayered[3]; 
# 1413
int maxTextureCubemapLayered[2]; 
# 1414
int maxSurface1D; 
# 1415
int maxSurface2D[2]; 
# 1416
int maxSurface3D[3]; 
# 1417
int maxSurface1DLayered[2]; 
# 1418
int maxSurface2DLayered[3]; 
# 1419
int maxSurfaceCubemap; 
# 1420
int maxSurfaceCubemapLayered[2]; 
# 1421
size_t surfaceAlignment; 
# 1422
int concurrentKernels; 
# 1423
int ECCEnabled; 
# 1424
int pciBusID; 
# 1425
int pciDeviceID; 
# 1426
int pciDomainID; 
# 1427
int tccDriver; 
# 1428
int asyncEngineCount; 
# 1429
int unifiedAddressing; 
# 1430
int memoryClockRate; 
# 1431
int memoryBusWidth; 
# 1432
int l2CacheSize; 
# 1433
int maxThreadsPerMultiProcessor; 
# 1434
int streamPrioritiesSupported; 
# 1435
int globalL1CacheSupported; 
# 1436
int localL1CacheSupported; 
# 1437
size_t sharedMemPerMultiprocessor; 
# 1438
int regsPerMultiprocessor; 
# 1439
int managedMemory; 
# 1440
int isMultiGpuBoard; 
# 1441
int multiGpuBoardGroupID; 
# 1442
int hostNativeAtomicSupported; 
# 1443
int singleToDoublePrecisionPerfRatio; 
# 1444
int pageableMemoryAccess; 
# 1445
int concurrentManagedAccess; 
# 1446
int computePreemptionSupported; 
# 1447
int canUseHostPointerForRegisteredMem; 
# 1448
int cooperativeLaunch; 
# 1449
int cooperativeMultiDeviceLaunch; 
# 1450
size_t sharedMemPerBlockOptin; 
# 1451
}; 
#endif
# 1539 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
typedef 
# 1536
struct cudaIpcEventHandle_st { 
# 1538
char reserved[64]; 
# 1539
} cudaIpcEventHandle_t; 
#endif
# 1547 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
typedef 
# 1544
struct cudaIpcMemHandle_st { 
# 1546
char reserved[64]; 
# 1547
} cudaIpcMemHandle_t; 
#endif
# 1558 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
typedef cudaError 
# 1558
cudaError_t; 
#endif
# 1563 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
typedef struct CUstream_st *
# 1563
cudaStream_t; 
#endif
# 1568 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
typedef struct CUevent_st *
# 1568
cudaEvent_t; 
#endif
# 1573 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
typedef cudaGraphicsResource *
# 1573
cudaGraphicsResource_t; 
#endif
# 1578 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
typedef struct CUuuid_st 
# 1578
cudaUUID_t; 
#endif
# 1583 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
typedef cudaOutputMode 
# 1583
cudaOutputMode_t; 
#endif
# 1588 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1588
enum cudaCGScope { 
# 1589
cudaCGScopeInvalid, 
# 1590
cudaCGScopeGrid, 
# 1591
cudaCGScopeMultiGrid
# 1592
}; 
#endif
# 1597 "/usr/local/cuda-9.0/include/driver_types.h"
#if 0
# 1597
struct cudaLaunchParams { 
# 1599
void *func; 
# 1600
dim3 gridDim; 
# 1601
dim3 blockDim; 
# 1602
void **args; 
# 1603
size_t sharedMem; 
# 1604
cudaStream_t stream; 
# 1605
}; 
#endif
# 84 "/usr/local/cuda-9.0/include/surface_types.h"
#if 0
# 84
enum cudaSurfaceBoundaryMode { 
# 86
cudaBoundaryModeZero, 
# 87
cudaBoundaryModeClamp, 
# 88
cudaBoundaryModeTrap
# 89
}; 
#endif
# 94 "/usr/local/cuda-9.0/include/surface_types.h"
#if 0
# 94
enum cudaSurfaceFormatMode { 
# 96
cudaFormatModeForced, 
# 97
cudaFormatModeAuto
# 98
}; 
#endif
# 103 "/usr/local/cuda-9.0/include/surface_types.h"
#if 0
# 103
struct surfaceReference { 
# 108
cudaChannelFormatDesc channelDesc; 
# 109
}; 
#endif
# 114 "/usr/local/cuda-9.0/include/surface_types.h"
#if 0
typedef unsigned long long 
# 114
cudaSurfaceObject_t; 
#endif
# 84 "/usr/local/cuda-9.0/include/texture_types.h"
#if 0
# 84
enum cudaTextureAddressMode { 
# 86
cudaAddressModeWrap, 
# 87
cudaAddressModeClamp, 
# 88
cudaAddressModeMirror, 
# 89
cudaAddressModeBorder
# 90
}; 
#endif
# 95 "/usr/local/cuda-9.0/include/texture_types.h"
#if 0
# 95
enum cudaTextureFilterMode { 
# 97
cudaFilterModePoint, 
# 98
cudaFilterModeLinear
# 99
}; 
#endif
# 104 "/usr/local/cuda-9.0/include/texture_types.h"
#if 0
# 104
enum cudaTextureReadMode { 
# 106
cudaReadModeElementType, 
# 107
cudaReadModeNormalizedFloat
# 108
}; 
#endif
# 113 "/usr/local/cuda-9.0/include/texture_types.h"
#if 0
# 113
struct textureReference { 
# 118
int normalized; 
# 122
cudaTextureFilterMode filterMode; 
# 126
cudaTextureAddressMode addressMode[3]; 
# 130
cudaChannelFormatDesc channelDesc; 
# 134
int sRGB; 
# 138
unsigned maxAnisotropy; 
# 142
cudaTextureFilterMode mipmapFilterMode; 
# 146
float mipmapLevelBias; 
# 150
float minMipmapLevelClamp; 
# 154
float maxMipmapLevelClamp; 
# 155
int __cudaReserved[15]; 
# 156
}; 
#endif
# 161 "/usr/local/cuda-9.0/include/texture_types.h"
#if 0
# 161
struct cudaTextureDesc { 
# 166
cudaTextureAddressMode addressMode[3]; 
# 170
cudaTextureFilterMode filterMode; 
# 174
cudaTextureReadMode readMode; 
# 178
int sRGB; 
# 182
float borderColor[4]; 
# 186
int normalizedCoords; 
# 190
unsigned maxAnisotropy; 
# 194
cudaTextureFilterMode mipmapFilterMode; 
# 198
float mipmapLevelBias; 
# 202
float minMipmapLevelClamp; 
# 206
float maxMipmapLevelClamp; 
# 207
}; 
#endif
# 212 "/usr/local/cuda-9.0/include/texture_types.h"
#if 0
typedef unsigned long long 
# 212
cudaTextureObject_t; 
#endif
# 70 "/usr/local/cuda-9.0/include/library_types.h"
typedef 
# 54
enum cudaDataType_t { 
# 56
CUDA_R_16F = 2, 
# 57
CUDA_C_16F = 6, 
# 58
CUDA_R_32F = 0, 
# 59
CUDA_C_32F = 4, 
# 60
CUDA_R_64F = 1, 
# 61
CUDA_C_64F = 5, 
# 62
CUDA_R_8I = 3, 
# 63
CUDA_C_8I = 7, 
# 64
CUDA_R_8U, 
# 65
CUDA_C_8U, 
# 66
CUDA_R_32I, 
# 67
CUDA_C_32I, 
# 68
CUDA_R_32U, 
# 69
CUDA_C_32U
# 70
} cudaDataType; 
# 78
typedef 
# 73
enum libraryPropertyType_t { 
# 75
MAJOR_VERSION, 
# 76
MINOR_VERSION, 
# 77
PATCH_LEVEL
# 78
} libraryPropertyType; 
# 121 "/usr/local/cuda-9.0/include/cuda_device_runtime_api.h"
extern "C" {
# 123
extern cudaError_t cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
# 124
extern cudaError_t cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
# 125
extern cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 126
extern cudaError_t cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
# 127
extern cudaError_t cudaDeviceSynchronize(); 
# 128
extern cudaError_t cudaGetLastError(); 
# 129
extern cudaError_t cudaPeekAtLastError(); 
# 130
extern const char *cudaGetErrorString(cudaError_t error); 
# 131
extern const char *cudaGetErrorName(cudaError_t error); 
# 132
extern cudaError_t cudaGetDeviceCount(int * count); 
# 133
extern cudaError_t cudaGetDevice(int * device); 
# 134
extern cudaError_t cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
# 135
extern cudaError_t cudaStreamDestroy(cudaStream_t stream); 
# 136
__attribute__((unused)) extern cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
# 137
extern cudaError_t cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
# 138
extern cudaError_t cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
# 139
__attribute__((unused)) extern cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream); 
# 140
extern cudaError_t cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream); 
# 141
extern cudaError_t cudaEventDestroy(cudaEvent_t event); 
# 142
extern cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
# 143
extern cudaError_t cudaFree(void * devPtr); 
# 144
extern cudaError_t cudaMalloc(void ** devPtr, size_t size); 
# 145
__attribute__((unused)) extern cudaError_t cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
# 146
extern cudaError_t cudaMemcpyAsync_ptsz(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
# 147
__attribute__((unused)) extern cudaError_t cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
# 148
extern cudaError_t cudaMemcpy2DAsync_ptsz(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
# 149
__attribute__((unused)) extern cudaError_t cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream); 
# 150
extern cudaError_t cudaMemcpy3DAsync_ptsz(const cudaMemcpy3DParms * p, cudaStream_t stream); 
# 151
__attribute__((unused)) extern cudaError_t cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream); 
# 152
extern cudaError_t cudaMemsetAsync_ptsz(void * devPtr, int value, size_t count, cudaStream_t stream); 
# 153
__attribute__((unused)) extern cudaError_t cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
# 154
extern cudaError_t cudaMemset2DAsync_ptsz(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
# 155
__attribute__((unused)) extern cudaError_t cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
# 156
extern cudaError_t cudaMemset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
# 157
extern cudaError_t cudaRuntimeGetVersion(int * runtimeVersion); 
# 178 "/usr/local/cuda-9.0/include/cuda_device_runtime_api.h"
__attribute__((unused)) extern void *cudaGetParameterBuffer(size_t alignment, size_t size); 
# 206 "/usr/local/cuda-9.0/include/cuda_device_runtime_api.h"
__attribute__((unused)) extern void *cudaGetParameterBufferV2(void * func, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize); 
# 207
__attribute__((unused)) extern cudaError_t cudaLaunchDevice_ptsz(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
# 208
__attribute__((unused)) extern cudaError_t cudaLaunchDeviceV2_ptsz(void * parameterBuffer, cudaStream_t stream); 
# 226 "/usr/local/cuda-9.0/include/cuda_device_runtime_api.h"
__attribute__((unused)) extern cudaError_t cudaLaunchDevice(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
# 227
__attribute__((unused)) extern cudaError_t cudaLaunchDeviceV2(void * parameterBuffer, cudaStream_t stream); 
# 230
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize); 
# 231
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
# 233
__attribute__((unused)) extern unsigned long long cudaCGGetIntrinsicHandle(cudaCGScope scope); 
# 234
__attribute__((unused)) extern cudaError_t cudaCGSynchronize(unsigned long long handle, unsigned flags); 
# 235
__attribute__((unused)) extern cudaError_t cudaCGGetSize(unsigned * numThreads, unsigned * numGrids, unsigned long long handle); 
# 236
__attribute__((unused)) extern cudaError_t cudaCGGetRank(unsigned * threadRank, unsigned * gridRank, unsigned long long handle); 
# 237
}
# 239
template< class T> static inline cudaError_t cudaMalloc(T ** devPtr, size_t size); 
# 240
template< class T> static inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, T * entry); 
# 241
template< class T> static inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize); 
# 242
template< class T> static inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
# 218 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern "C" {
# 251 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceReset(); 
# 270 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceSynchronize(); 
# 347 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceSetLimit(cudaLimit limit, size_t value); 
# 378 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
# 410 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 446 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
# 489 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig); 
# 519 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
# 562 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config); 
# 587 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetByPCIBusId(int * device, const char * pciBusId); 
# 615 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetPCIBusId(char * pciBusId, int len, int device); 
# 660 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaIpcGetEventHandle(cudaIpcEventHandle_t * handle, cudaEvent_t event); 
# 698 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaIpcOpenEventHandle(cudaEvent_t * event, cudaIpcEventHandle_t handle); 
# 739 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaIpcGetMemHandle(cudaIpcMemHandle_t * handle, void * devPtr); 
# 792 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaIpcOpenMemHandle(void ** devPtr, cudaIpcMemHandle_t handle, unsigned flags); 
# 825 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaIpcCloseMemHandle(void * devPtr); 
# 865 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaThreadExit(); 
# 889 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaThreadSynchronize(); 
# 936 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaThreadSetLimit(cudaLimit limit, size_t value); 
# 967 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaThreadGetLimit(size_t * pValue, cudaLimit limit); 
# 1002 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaThreadGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 1048 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaThreadSetCacheConfig(cudaFuncCache cacheConfig); 
# 1104 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetLastError(); 
# 1147 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaPeekAtLastError(); 
# 1163 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern const char *cudaGetErrorName(cudaError_t error); 
# 1179 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern const char *cudaGetErrorString(cudaError_t error); 
# 1210 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetDeviceCount(int * count); 
# 1470 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetDeviceProperties(cudaDeviceProp * prop, int device); 
# 1647 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
# 1683 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetP2PAttribute(int * value, cudaDeviceP2PAttr attr, int srcDevice, int dstDevice); 
# 1702 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaChooseDevice(int * device, const cudaDeviceProp * prop); 
# 1737 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaSetDevice(int device); 
# 1755 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetDevice(int * device); 
# 1784 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaSetValidDevices(int * device_arr, int len); 
# 1847 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaSetDeviceFlags(unsigned flags); 
# 1890 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetDeviceFlags(unsigned * flags); 
# 1928 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamCreate(cudaStream_t * pStream); 
# 1958 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
# 2002 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamCreateWithPriority(cudaStream_t * pStream, unsigned flags, int priority); 
# 2027 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamGetPriority_ptsz(cudaStream_t hStream, int * priority); 
# 2050 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamGetFlags_ptsz(cudaStream_t hStream, unsigned * flags); 
# 2079 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamDestroy(cudaStream_t stream); 
# 2113 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
# 2127 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
typedef void (*cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void * userData); 
# 2185 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamAddCallback_ptsz(cudaStream_t stream, cudaStreamCallback_t callback, void * userData, unsigned flags); 
# 2207 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamSynchronize_ptsz(cudaStream_t stream); 
# 2230 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamQuery_ptsz(cudaStream_t stream); 
# 2302 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamAttachMemAsync_ptsz(cudaStream_t stream, void * devPtr, size_t length = 0, unsigned flags = 4); 
# 2339 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaEventCreate(cudaEvent_t * event); 
# 2374 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
# 2406 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream = 0); 
# 2439 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaEventQuery(cudaEvent_t event); 
# 2472 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaEventSynchronize(cudaEvent_t event); 
# 2498 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaEventDestroy(cudaEvent_t event); 
# 2540 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaEventElapsedTime(float * ms, cudaEvent_t start, cudaEvent_t end); 
# 2603 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaLaunchKernel_ptsz(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
# 2658 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaLaunchCooperativeKernel_ptsz(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
# 2755 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaLaunchCooperativeKernelMultiDevice(cudaLaunchParams * launchParamsList, unsigned numDevices, unsigned flags = 0); 
# 2804 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaFuncSetCacheConfig(const void * func, cudaFuncCache cacheConfig); 
# 2859 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaFuncSetSharedMemConfig(const void * func, cudaSharedMemConfig config); 
# 2894 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
# 2930 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaFuncSetAttribute(const void * func, cudaFuncAttribute attr, int value); 
# 2954 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaSetDoubleForDevice(double * d); 
# 2978 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaSetDoubleForHost(double * d); 
# 3033 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize); 
# 3077 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
# 3127 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, cudaStream_t stream = 0); 
# 3156 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaSetupArgument(const void * arg, size_t size, size_t offset); 
# 3197 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaLaunch_ptsz(const void * func); 
# 3316 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocManaged(void ** devPtr, size_t size, unsigned flags = 1); 
# 3344 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMalloc(void ** devPtr, size_t size); 
# 3375 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocHost(void ** ptr, size_t size); 
# 3416 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocPitch(void ** devPtr, size_t * pitch, size_t width, size_t height); 
# 3460 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, size_t width, size_t height = 0, unsigned flags = 0); 
# 3488 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaFree(void * devPtr); 
# 3510 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaFreeHost(void * ptr); 
# 3533 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaFreeArray(cudaArray_t array); 
# 3556 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray); 
# 3617 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaHostAlloc(void ** pHost, size_t size, unsigned flags); 
# 3698 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaHostRegister(void * ptr, size_t size, unsigned flags); 
# 3719 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaHostUnregister(void * ptr); 
# 3762 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaHostGetDevicePointer(void ** pDevice, void * pHost, unsigned flags); 
# 3782 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaHostGetFlags(unsigned * pFlags, void * pHost); 
# 3819 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMalloc3D(cudaPitchedPtr * pitchedDevPtr, cudaExtent extent); 
# 3956 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMalloc3DArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned flags = 0); 
# 4093 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocMipmappedArray(cudaMipmappedArray_t * mipmappedArray, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned numLevels, unsigned flags = 0); 
# 4120 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetMipmappedArrayLevel(cudaArray_t * levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned level); 
# 4223 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy3D_ptds(const cudaMemcpy3DParms * p); 
# 4252 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy3DPeer_ptds(const cudaMemcpy3DPeerParms * p); 
# 4368 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy3DAsync_ptsz(const cudaMemcpy3DParms * p, cudaStream_t stream = 0); 
# 4392 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy3DPeerAsync_ptsz(const cudaMemcpy3DPeerParms * p, cudaStream_t stream = 0); 
# 4413 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemGetInfo(size_t * free, size_t * total); 
# 4437 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaArrayGetInfo(cudaChannelFormatDesc * desc, cudaExtent * extent, unsigned * flags, cudaArray_t array); 
# 4478 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy_ptds(void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
# 4511 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyPeer(void * dst, int dstDevice, const void * src, int srcDevice, size_t count); 
# 4550 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyToArray_ptds(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind); 
# 4588 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyFromArray_ptds(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind); 
# 4627 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyArrayToArray_ptds(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
# 4673 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2D_ptds(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
# 4720 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DToArray_ptds(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
# 4767 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DFromArray_ptds(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind); 
# 4812 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DArrayToArray_ptds(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
# 4853 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyToSymbol_ptds(const void * symbol, const void * src, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyHostToDevice); 
# 4894 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyFromSymbol_ptds(void * dst, const void * symbol, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyDeviceToHost); 
# 4948 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyAsync_ptsz(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4981 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyPeerAsync(void * dst, int dstDevice, const void * src, int srcDevice, size_t count, cudaStream_t stream = 0); 
# 5028 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyToArrayAsync_ptsz(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 5074 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyFromArrayAsync_ptsz(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 5134 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DAsync_ptsz(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 5189 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DToArrayAsync_ptsz(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 5243 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DFromArrayAsync_ptsz(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 5292 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyToSymbolAsync_ptsz(const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 5341 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyFromSymbolAsync_ptsz(void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 5368 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemset_ptds(void * devPtr, int value, size_t count); 
# 5400 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemset2D_ptds(void * devPtr, size_t pitch, int value, size_t width, size_t height); 
# 5442 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemset3D_ptds(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent); 
# 5476 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemsetAsync_ptsz(void * devPtr, int value, size_t count, cudaStream_t stream = 0); 
# 5515 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemset2DAsync_ptsz(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0); 
# 5564 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream = 0); 
# 5590 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetSymbolAddress(void ** devPtr, const void * symbol); 
# 5615 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetSymbolSize(size_t * size, const void * symbol); 
# 5683 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPrefetchAsync_ptsz(const void * devPtr, size_t count, int dstDevice, cudaStream_t stream = 0); 
# 5770 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemAdvise(const void * devPtr, size_t count, cudaMemoryAdvise advice, int device); 
# 5827 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemRangeGetAttribute(void * data, size_t dataSize, cudaMemRangeAttribute attribute, const void * devPtr, size_t count); 
# 5864 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaMemRangeGetAttributes(void ** data, size_t * dataSizes, cudaMemRangeAttribute * attributes, size_t numAttributes, const void * devPtr, size_t count); 
# 6018 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaPointerGetAttributes(cudaPointerAttributes * attributes, const void * ptr); 
# 6057 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceCanAccessPeer(int * canAccessPeer, int device, int peerDevice); 
# 6097 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceEnablePeerAccess(int peerDevice, unsigned flags); 
# 6117 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceDisablePeerAccess(int peerDevice); 
# 6178 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource); 
# 6211 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned flags); 
# 6248 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsMapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
# 6281 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
# 6311 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsResourceGetMappedPointer(void ** devPtr, size_t * size, cudaGraphicsResource_t resource); 
# 6347 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsSubResourceGetMappedArray(cudaArray_t * array, cudaGraphicsResource_t resource, unsigned arrayIndex, unsigned mipLevel); 
# 6374 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * mipmappedArray, cudaGraphicsResource_t resource); 
# 6414 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetChannelDesc(cudaChannelFormatDesc * desc, cudaArray_const_t array); 
# 6450 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaChannelFormatDesc cudaCreateChannelDesc(int x, int y, int z, int w, cudaChannelFormatKind f); 
# 6501 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaBindTexture(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t size = ((2147483647) * 2U) + 1U); 
# 6556 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaBindTexture2D(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t width, size_t height, size_t pitch); 
# 6590 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaBindTextureToArray(const textureReference * texref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
# 6626 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaBindTextureToMipmappedArray(const textureReference * texref, cudaMipmappedArray_const_t mipmappedArray, const cudaChannelFormatDesc * desc); 
# 6647 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaUnbindTexture(const textureReference * texref); 
# 6672 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetTextureAlignmentOffset(size_t * offset, const textureReference * texref); 
# 6698 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetTextureReference(const textureReference ** texref, const void * symbol); 
# 6739 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaBindSurfaceToArray(const surfaceReference * surfref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
# 6760 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetSurfaceReference(const surfaceReference ** surfref, const void * symbol); 
# 6988 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaCreateTextureObject(cudaTextureObject_t * pTexObject, const cudaResourceDesc * pResDesc, const cudaTextureDesc * pTexDesc, const cudaResourceViewDesc * pResViewDesc); 
# 7005 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDestroyTextureObject(cudaTextureObject_t texObject); 
# 7023 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetTextureObjectResourceDesc(cudaResourceDesc * pResDesc, cudaTextureObject_t texObject); 
# 7041 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetTextureObjectTextureDesc(cudaTextureDesc * pTexDesc, cudaTextureObject_t texObject); 
# 7060 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * pResViewDesc, cudaTextureObject_t texObject); 
# 7101 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaCreateSurfaceObject(cudaSurfaceObject_t * pSurfObject, const cudaResourceDesc * pResDesc); 
# 7118 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject); 
# 7135 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * pResDesc, cudaSurfaceObject_t surfObject); 
# 7164 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaDriverGetVersion(int * driverVersion); 
# 7183 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
extern cudaError_t cudaRuntimeGetVersion(int * runtimeVersion); 
# 7188
extern cudaError_t cudaGetExportTable(const void ** ppExportTable, const cudaUUID_t * pExportTableId); 
# 7408 "/usr/local/cuda-9.0/include/cuda_runtime_api.h"
static inline cudaError_t cudaLaunch(const void *func) 
# 7409
{ 
# 7410
return cudaLaunch_ptsz(func); 
# 7411
} 
# 7416
}
# 107 "/usr/local/cuda-9.0/include/channel_descriptor.h"
template< class T> inline cudaChannelFormatDesc cudaCreateChannelDesc() 
# 108
{ 
# 109
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
# 110
} 
# 112
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
# 113
{ 
# 114
int e = (((int)sizeof(unsigned short)) * 8); 
# 116
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 117
} 
# 119
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
# 120
{ 
# 121
int e = (((int)sizeof(unsigned short)) * 8); 
# 123
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 124
} 
# 126
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
# 127
{ 
# 128
int e = (((int)sizeof(unsigned short)) * 8); 
# 130
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
# 131
} 
# 133
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
# 134
{ 
# 135
int e = (((int)sizeof(unsigned short)) * 8); 
# 137
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
# 138
} 
# 140
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
# 141
{ 
# 142
int e = (((int)sizeof(char)) * 8); 
# 145
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 149
} 
# 151
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
# 152
{ 
# 153
int e = (((int)sizeof(signed char)) * 8); 
# 155
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 156
} 
# 158
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
# 159
{ 
# 160
int e = (((int)sizeof(unsigned char)) * 8); 
# 162
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 163
} 
# 165
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
# 166
{ 
# 167
int e = (((int)sizeof(signed char)) * 8); 
# 169
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 170
} 
# 172
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
# 173
{ 
# 174
int e = (((int)sizeof(unsigned char)) * 8); 
# 176
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 177
} 
# 179
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
# 180
{ 
# 181
int e = (((int)sizeof(signed char)) * 8); 
# 183
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 184
} 
# 186
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
# 187
{ 
# 188
int e = (((int)sizeof(unsigned char)) * 8); 
# 190
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 191
} 
# 193
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
# 194
{ 
# 195
int e = (((int)sizeof(signed char)) * 8); 
# 197
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 198
} 
# 200
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
# 201
{ 
# 202
int e = (((int)sizeof(unsigned char)) * 8); 
# 204
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 205
} 
# 207
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
# 208
{ 
# 209
int e = (((int)sizeof(short)) * 8); 
# 211
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 212
} 
# 214
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
# 215
{ 
# 216
int e = (((int)sizeof(unsigned short)) * 8); 
# 218
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 219
} 
# 221
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
# 222
{ 
# 223
int e = (((int)sizeof(short)) * 8); 
# 225
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 226
} 
# 228
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
# 229
{ 
# 230
int e = (((int)sizeof(unsigned short)) * 8); 
# 232
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 233
} 
# 235
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
# 236
{ 
# 237
int e = (((int)sizeof(short)) * 8); 
# 239
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 240
} 
# 242
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
# 243
{ 
# 244
int e = (((int)sizeof(unsigned short)) * 8); 
# 246
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 247
} 
# 249
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
# 250
{ 
# 251
int e = (((int)sizeof(short)) * 8); 
# 253
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 254
} 
# 256
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
# 257
{ 
# 258
int e = (((int)sizeof(unsigned short)) * 8); 
# 260
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 261
} 
# 263
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
# 264
{ 
# 265
int e = (((int)sizeof(int)) * 8); 
# 267
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 268
} 
# 270
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
# 271
{ 
# 272
int e = (((int)sizeof(unsigned)) * 8); 
# 274
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 275
} 
# 277
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
# 278
{ 
# 279
int e = (((int)sizeof(int)) * 8); 
# 281
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 282
} 
# 284
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
# 285
{ 
# 286
int e = (((int)sizeof(unsigned)) * 8); 
# 288
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 289
} 
# 291
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
# 292
{ 
# 293
int e = (((int)sizeof(int)) * 8); 
# 295
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 296
} 
# 298
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
# 299
{ 
# 300
int e = (((int)sizeof(unsigned)) * 8); 
# 302
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 303
} 
# 305
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
# 306
{ 
# 307
int e = (((int)sizeof(int)) * 8); 
# 309
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 310
} 
# 312
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
# 313
{ 
# 314
int e = (((int)sizeof(unsigned)) * 8); 
# 316
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 317
} 
# 379 "/usr/local/cuda-9.0/include/channel_descriptor.h"
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
# 380
{ 
# 381
int e = (((int)sizeof(float)) * 8); 
# 383
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 384
} 
# 386
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
# 387
{ 
# 388
int e = (((int)sizeof(float)) * 8); 
# 390
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 391
} 
# 393
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
# 394
{ 
# 395
int e = (((int)sizeof(float)) * 8); 
# 397
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
# 398
} 
# 400
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
# 401
{ 
# 402
int e = (((int)sizeof(float)) * 8); 
# 404
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
# 405
} 
# 79 "/usr/local/cuda-9.0/include/driver_functions.h"
static inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
# 80
{ 
# 81
cudaPitchedPtr s; 
# 83
(s.ptr) = d; 
# 84
(s.pitch) = p; 
# 85
(s.xsize) = xsz; 
# 86
(s.ysize) = ysz; 
# 88
return s; 
# 89
} 
# 106 "/usr/local/cuda-9.0/include/driver_functions.h"
static inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
# 107
{ 
# 108
cudaPos p; 
# 110
(p.x) = x; 
# 111
(p.y) = y; 
# 112
(p.z) = z; 
# 114
return p; 
# 115
} 
# 132 "/usr/local/cuda-9.0/include/driver_functions.h"
static inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
# 133
{ 
# 134
cudaExtent e; 
# 136
(e.width) = w; 
# 137
(e.height) = h; 
# 138
(e.depth) = d; 
# 140
return e; 
# 141
} 
# 75 "/usr/local/cuda-9.0/include/vector_functions.h"
static inline char1 make_char1(signed char x); 
# 77
static inline uchar1 make_uchar1(unsigned char x); 
# 79
static inline char2 make_char2(signed char x, signed char y); 
# 81
static inline uchar2 make_uchar2(unsigned char x, unsigned char y); 
# 83
static inline char3 make_char3(signed char x, signed char y, signed char z); 
# 85
static inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z); 
# 87
static inline char4 make_char4(signed char x, signed char y, signed char z, signed char w); 
# 89
static inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w); 
# 91
static inline short1 make_short1(short x); 
# 93
static inline ushort1 make_ushort1(unsigned short x); 
# 95
static inline short2 make_short2(short x, short y); 
# 97
static inline ushort2 make_ushort2(unsigned short x, unsigned short y); 
# 99
static inline short3 make_short3(short x, short y, short z); 
# 101
static inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z); 
# 103
static inline short4 make_short4(short x, short y, short z, short w); 
# 105
static inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w); 
# 107
static inline int1 make_int1(int x); 
# 109
static inline uint1 make_uint1(unsigned x); 
# 111
static inline int2 make_int2(int x, int y); 
# 113
static inline uint2 make_uint2(unsigned x, unsigned y); 
# 115
static inline int3 make_int3(int x, int y, int z); 
# 117
static inline uint3 make_uint3(unsigned x, unsigned y, unsigned z); 
# 119
static inline int4 make_int4(int x, int y, int z, int w); 
# 121
static inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w); 
# 123
static inline long1 make_long1(long x); 
# 125
static inline ulong1 make_ulong1(unsigned long x); 
# 127
static inline long2 make_long2(long x, long y); 
# 129
static inline ulong2 make_ulong2(unsigned long x, unsigned long y); 
# 131
static inline long3 make_long3(long x, long y, long z); 
# 133
static inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z); 
# 135
static inline long4 make_long4(long x, long y, long z, long w); 
# 137
static inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w); 
# 139
static inline float1 make_float1(float x); 
# 141
static inline float2 make_float2(float x, float y); 
# 143
static inline float3 make_float3(float x, float y, float z); 
# 145
static inline float4 make_float4(float x, float y, float z, float w); 
# 147
static inline longlong1 make_longlong1(long long x); 
# 149
static inline ulonglong1 make_ulonglong1(unsigned long long x); 
# 151
static inline longlong2 make_longlong2(long long x, long long y); 
# 153
static inline ulonglong2 make_ulonglong2(unsigned long long x, unsigned long long y); 
# 155
static inline longlong3 make_longlong3(long long x, long long y, long long z); 
# 157
static inline ulonglong3 make_ulonglong3(unsigned long long x, unsigned long long y, unsigned long long z); 
# 159
static inline longlong4 make_longlong4(long long x, long long y, long long z, long long w); 
# 161
static inline ulonglong4 make_ulonglong4(unsigned long long x, unsigned long long y, unsigned long long z, unsigned long long w); 
# 163
static inline double1 make_double1(double x); 
# 165
static inline double2 make_double2(double x, double y); 
# 167
static inline double3 make_double3(double x, double y, double z); 
# 169
static inline double4 make_double4(double x, double y, double z, double w); 
# 75 "/usr/local/cuda-9.0/include/vector_functions.hpp"
static inline char1 make_char1(signed char x) 
# 76
{ 
# 77
char1 t; (t.x) = x; return t; 
# 78
} 
# 80
static inline uchar1 make_uchar1(unsigned char x) 
# 81
{ 
# 82
uchar1 t; (t.x) = x; return t; 
# 83
} 
# 85
static inline char2 make_char2(signed char x, signed char y) 
# 86
{ 
# 87
char2 t; (t.x) = x; (t.y) = y; return t; 
# 88
} 
# 90
static inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
# 91
{ 
# 92
uchar2 t; (t.x) = x; (t.y) = y; return t; 
# 93
} 
# 95
static inline char3 make_char3(signed char x, signed char y, signed char z) 
# 96
{ 
# 97
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 98
} 
# 100
static inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
# 101
{ 
# 102
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 103
} 
# 105
static inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
# 106
{ 
# 107
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 108
} 
# 110
static inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
# 111
{ 
# 112
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 113
} 
# 115
static inline short1 make_short1(short x) 
# 116
{ 
# 117
short1 t; (t.x) = x; return t; 
# 118
} 
# 120
static inline ushort1 make_ushort1(unsigned short x) 
# 121
{ 
# 122
ushort1 t; (t.x) = x; return t; 
# 123
} 
# 125
static inline short2 make_short2(short x, short y) 
# 126
{ 
# 127
short2 t; (t.x) = x; (t.y) = y; return t; 
# 128
} 
# 130
static inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
# 131
{ 
# 132
ushort2 t; (t.x) = x; (t.y) = y; return t; 
# 133
} 
# 135
static inline short3 make_short3(short x, short y, short z) 
# 136
{ 
# 137
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 138
} 
# 140
static inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
# 141
{ 
# 142
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 143
} 
# 145
static inline short4 make_short4(short x, short y, short z, short w) 
# 146
{ 
# 147
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 148
} 
# 150
static inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
# 151
{ 
# 152
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 153
} 
# 155
static inline int1 make_int1(int x) 
# 156
{ 
# 157
int1 t; (t.x) = x; return t; 
# 158
} 
# 160
static inline uint1 make_uint1(unsigned x) 
# 161
{ 
# 162
uint1 t; (t.x) = x; return t; 
# 163
} 
# 165
static inline int2 make_int2(int x, int y) 
# 166
{ 
# 167
int2 t; (t.x) = x; (t.y) = y; return t; 
# 168
} 
# 170
static inline uint2 make_uint2(unsigned x, unsigned y) 
# 171
{ 
# 172
uint2 t; (t.x) = x; (t.y) = y; return t; 
# 173
} 
# 175
static inline int3 make_int3(int x, int y, int z) 
# 176
{ 
# 177
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 178
} 
# 180
static inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
# 181
{ 
# 182
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 183
} 
# 185
static inline int4 make_int4(int x, int y, int z, int w) 
# 186
{ 
# 187
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 188
} 
# 190
static inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
# 191
{ 
# 192
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 193
} 
# 195
static inline long1 make_long1(long x) 
# 196
{ 
# 197
long1 t; (t.x) = x; return t; 
# 198
} 
# 200
static inline ulong1 make_ulong1(unsigned long x) 
# 201
{ 
# 202
ulong1 t; (t.x) = x; return t; 
# 203
} 
# 205
static inline long2 make_long2(long x, long y) 
# 206
{ 
# 207
long2 t; (t.x) = x; (t.y) = y; return t; 
# 208
} 
# 210
static inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
# 211
{ 
# 212
ulong2 t; (t.x) = x; (t.y) = y; return t; 
# 213
} 
# 215
static inline long3 make_long3(long x, long y, long z) 
# 216
{ 
# 217
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 218
} 
# 220
static inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
# 221
{ 
# 222
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 223
} 
# 225
static inline long4 make_long4(long x, long y, long z, long w) 
# 226
{ 
# 227
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 228
} 
# 230
static inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
# 231
{ 
# 232
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 233
} 
# 235
static inline float1 make_float1(float x) 
# 236
{ 
# 237
float1 t; (t.x) = x; return t; 
# 238
} 
# 240
static inline float2 make_float2(float x, float y) 
# 241
{ 
# 242
float2 t; (t.x) = x; (t.y) = y; return t; 
# 243
} 
# 245
static inline float3 make_float3(float x, float y, float z) 
# 246
{ 
# 247
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 248
} 
# 250
static inline float4 make_float4(float x, float y, float z, float w) 
# 251
{ 
# 252
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 253
} 
# 255
static inline longlong1 make_longlong1(long long x) 
# 256
{ 
# 257
longlong1 t; (t.x) = x; return t; 
# 258
} 
# 260
static inline ulonglong1 make_ulonglong1(unsigned long long x) 
# 261
{ 
# 262
ulonglong1 t; (t.x) = x; return t; 
# 263
} 
# 265
static inline longlong2 make_longlong2(long long x, long long y) 
# 266
{ 
# 267
longlong2 t; (t.x) = x; (t.y) = y; return t; 
# 268
} 
# 270
static inline ulonglong2 make_ulonglong2(unsigned long long x, unsigned long long y) 
# 271
{ 
# 272
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
# 273
} 
# 275
static inline longlong3 make_longlong3(long long x, long long y, long long z) 
# 276
{ 
# 277
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 278
} 
# 280
static inline ulonglong3 make_ulonglong3(unsigned long long x, unsigned long long y, unsigned long long z) 
# 281
{ 
# 282
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 283
} 
# 285
static inline longlong4 make_longlong4(long long x, long long y, long long z, long long w) 
# 286
{ 
# 287
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 288
} 
# 290
static inline ulonglong4 make_ulonglong4(unsigned long long x, unsigned long long y, unsigned long long z, unsigned long long w) 
# 291
{ 
# 292
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 293
} 
# 295
static inline double1 make_double1(double x) 
# 296
{ 
# 297
double1 t; (t.x) = x; return t; 
# 298
} 
# 300
static inline double2 make_double2(double x, double y) 
# 301
{ 
# 302
double2 t; (t.x) = x; (t.y) = y; return t; 
# 303
} 
# 305
static inline double3 make_double3(double x, double y, double z) 
# 306
{ 
# 307
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 308
} 
# 310
static inline double4 make_double4(double x, double y, double z, double w) 
# 311
{ 
# 312
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 313
} 
# 27 "/usr/include/string.h" 3
extern "C" {
# 42 "/usr/include/string.h" 3
extern void *memcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 43
 __attribute((__nonnull__(1, 2))); 
# 46
extern void *memmove(void * __dest, const void * __src, size_t __n) throw()
# 47
 __attribute((__nonnull__(1, 2))); 
# 54
extern void *memccpy(void *__restrict__ __dest, const void *__restrict__ __src, int __c, size_t __n) throw()
# 56
 __attribute((__nonnull__(1, 2))); 
# 62
extern void *memset(void * __s, int __c, size_t __n) throw() __attribute((__nonnull__(1))); 
# 65
extern int memcmp(const void * __s1, const void * __s2, size_t __n) throw()
# 66
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 70
extern "C++" {
# 72
extern void *memchr(void * __s, int __c, size_t __n) throw() __asm__("memchr")
# 73
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 74
extern const void *memchr(const void * __s, int __c, size_t __n) throw() __asm__("memchr")
# 75
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 90 "/usr/include/string.h" 3
}
# 101
extern "C++" void *rawmemchr(void * __s, int __c) throw() __asm__("rawmemchr")
# 102
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 103
extern "C++" const void *rawmemchr(const void * __s, int __c) throw() __asm__("rawmemchr")
# 104
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 112
extern "C++" void *memrchr(void * __s, int __c, size_t __n) throw() __asm__("memrchr")
# 113
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 114
extern "C++" const void *memrchr(const void * __s, int __c, size_t __n) throw() __asm__("memrchr")
# 115
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 125
extern char *strcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 126
 __attribute((__nonnull__(1, 2))); 
# 128
extern char *strncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 130
 __attribute((__nonnull__(1, 2))); 
# 133
extern char *strcat(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 134
 __attribute((__nonnull__(1, 2))); 
# 136
extern char *strncat(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 137
 __attribute((__nonnull__(1, 2))); 
# 140
extern int strcmp(const char * __s1, const char * __s2) throw()
# 141
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 143
extern int strncmp(const char * __s1, const char * __s2, size_t __n) throw()
# 144
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 147
extern int strcoll(const char * __s1, const char * __s2) throw()
# 148
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 150
extern size_t strxfrm(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 152
 __attribute((__nonnull__(2))); 
# 39 "/usr/include/xlocale.h" 3
typedef 
# 27
struct __locale_struct { 
# 30
struct __locale_data *__locales[13]; 
# 33
const unsigned short *__ctype_b; 
# 34
const int *__ctype_tolower; 
# 35
const int *__ctype_toupper; 
# 38
const char *__names[13]; 
# 39
} *__locale_t; 
# 42
typedef __locale_t locale_t; 
# 162 "/usr/include/string.h" 3
extern int strcoll_l(const char * __s1, const char * __s2, __locale_t __l) throw()
# 163
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 3))); 
# 165
extern size_t strxfrm_l(char * __dest, const char * __src, size_t __n, __locale_t __l) throw()
# 166
 __attribute((__nonnull__(2, 4))); 
# 171
extern char *strdup(const char * __s) throw()
# 172
 __attribute((__malloc__)) __attribute((__nonnull__(1))); 
# 179
extern char *strndup(const char * __string, size_t __n) throw()
# 180
 __attribute((__malloc__)) __attribute((__nonnull__(1))); 
# 209 "/usr/include/string.h" 3
extern "C++" {
# 211
extern char *strchr(char * __s, int __c) throw() __asm__("strchr")
# 212
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 213
extern const char *strchr(const char * __s, int __c) throw() __asm__("strchr")
# 214
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 229 "/usr/include/string.h" 3
}
# 236
extern "C++" {
# 238
extern char *strrchr(char * __s, int __c) throw() __asm__("strrchr")
# 239
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 240
extern const char *strrchr(const char * __s, int __c) throw() __asm__("strrchr")
# 241
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 256 "/usr/include/string.h" 3
}
# 267
extern "C++" char *strchrnul(char * __s, int __c) throw() __asm__("strchrnul")
# 268
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 269
extern "C++" const char *strchrnul(const char * __s, int __c) throw() __asm__("strchrnul")
# 270
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 280
extern size_t strcspn(const char * __s, const char * __reject) throw()
# 281
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 284
extern size_t strspn(const char * __s, const char * __accept) throw()
# 285
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 288
extern "C++" {
# 290
extern char *strpbrk(char * __s, const char * __accept) throw() __asm__("strpbrk")
# 291
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 292
extern const char *strpbrk(const char * __s, const char * __accept) throw() __asm__("strpbrk")
# 293
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 308 "/usr/include/string.h" 3
}
# 315
extern "C++" {
# 317
extern char *strstr(char * __haystack, const char * __needle) throw() __asm__("strstr")
# 318
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 319
extern const char *strstr(const char * __haystack, const char * __needle) throw() __asm__("strstr")
# 320
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 335 "/usr/include/string.h" 3
}
# 343
extern char *strtok(char *__restrict__ __s, const char *__restrict__ __delim) throw()
# 344
 __attribute((__nonnull__(2))); 
# 349
extern char *__strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char **__restrict__ __save_ptr) throw()
# 352
 __attribute((__nonnull__(2, 3))); 
# 354
extern char *strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char **__restrict__ __save_ptr) throw()
# 356
 __attribute((__nonnull__(2, 3))); 
# 362
extern "C++" char *strcasestr(char * __haystack, const char * __needle) throw() __asm__("strcasestr")
# 363
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 364
extern "C++" const char *strcasestr(const char * __haystack, const char * __needle) throw() __asm__("strcasestr")
# 366
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 377 "/usr/include/string.h" 3
extern void *memmem(const void * __haystack, size_t __haystacklen, const void * __needle, size_t __needlelen) throw()
# 379
 __attribute((__pure__)) __attribute((__nonnull__(1, 3))); 
# 383
extern void *__mempcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 385
 __attribute((__nonnull__(1, 2))); 
# 386
extern void *mempcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 388
 __attribute((__nonnull__(1, 2))); 
# 394
extern size_t strlen(const char * __s) throw()
# 395
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 401
extern size_t strnlen(const char * __string, size_t __maxlen) throw()
# 402
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 408
extern char *strerror(int __errnum) throw(); 
# 433 "/usr/include/string.h" 3
extern char *strerror_r(int __errnum, char * __buf, size_t __buflen) throw()
# 434
 __attribute((__nonnull__(2))); 
# 440
extern char *strerror_l(int __errnum, __locale_t __l) throw(); 
# 446
extern void __bzero(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 450
extern void bcopy(const void * __src, void * __dest, size_t __n) throw()
# 451
 __attribute((__nonnull__(1, 2))); 
# 454
extern void bzero(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 457
extern int bcmp(const void * __s1, const void * __s2, size_t __n) throw()
# 458
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 462
extern "C++" {
# 464
extern char *index(char * __s, int __c) throw() __asm__("index")
# 465
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 466
extern const char *index(const char * __s, int __c) throw() __asm__("index")
# 467
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 482 "/usr/include/string.h" 3
}
# 490
extern "C++" {
# 492
extern char *rindex(char * __s, int __c) throw() __asm__("rindex")
# 493
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 494
extern const char *rindex(const char * __s, int __c) throw() __asm__("rindex")
# 495
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 510 "/usr/include/string.h" 3
}
# 518
extern int ffs(int __i) throw() __attribute((const)); 
# 523
extern int ffsl(long __l) throw() __attribute((const)); 
# 524
__extension__ extern int ffsll(long long __ll) throw()
# 525
 __attribute((const)); 
# 529
extern int strcasecmp(const char * __s1, const char * __s2) throw()
# 530
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 533
extern int strncasecmp(const char * __s1, const char * __s2, size_t __n) throw()
# 534
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 540
extern int strcasecmp_l(const char * __s1, const char * __s2, __locale_t __loc) throw()
# 542
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 3))); 
# 544
extern int strncasecmp_l(const char * __s1, const char * __s2, size_t __n, __locale_t __loc) throw()
# 546
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 4))); 
# 552
extern char *strsep(char **__restrict__ __stringp, const char *__restrict__ __delim) throw()
# 554
 __attribute((__nonnull__(1, 2))); 
# 559
extern char *strsignal(int __sig) throw(); 
# 562
extern char *__stpcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 563
 __attribute((__nonnull__(1, 2))); 
# 564
extern char *stpcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 565
 __attribute((__nonnull__(1, 2))); 
# 569
extern char *__stpncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 571
 __attribute((__nonnull__(1, 2))); 
# 572
extern char *stpncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 574
 __attribute((__nonnull__(1, 2))); 
# 579
extern int strverscmp(const char * __s1, const char * __s2) throw()
# 580
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 583
extern char *strfry(char * __string) throw() __attribute((__nonnull__(1))); 
# 586
extern void *memfrob(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 594
extern "C++" char *basename(char * __filename) throw() __asm__("basename")
# 595
 __attribute((__nonnull__(1))); 
# 596
extern "C++" const char *basename(const char * __filename) throw() __asm__("basename")
# 597
 __attribute((__nonnull__(1))); 
# 658 "/usr/include/string.h" 3
}
# 29 "/usr/include/time.h" 3
extern "C" {
# 30 "/usr/include/aarch64-linux-gnu/bits/types.h" 3
typedef unsigned char __u_char; 
# 31
typedef unsigned short __u_short; 
# 32
typedef unsigned __u_int; 
# 33
typedef unsigned long __u_long; 
# 36
typedef signed char __int8_t; 
# 37
typedef unsigned char __uint8_t; 
# 38
typedef signed short __int16_t; 
# 39
typedef unsigned short __uint16_t; 
# 40
typedef signed int __int32_t; 
# 41
typedef unsigned __uint32_t; 
# 43
typedef signed long __int64_t; 
# 44
typedef unsigned long __uint64_t; 
# 52
typedef long __quad_t; 
# 53
typedef unsigned long __u_quad_t; 
# 124 "/usr/include/aarch64-linux-gnu/bits/types.h" 3
typedef unsigned long __dev_t; 
# 125
typedef unsigned __uid_t; 
# 126
typedef unsigned __gid_t; 
# 127
typedef unsigned long __ino_t; 
# 128
typedef unsigned long __ino64_t; 
# 129
typedef unsigned __mode_t; 
# 130
typedef unsigned __nlink_t; 
# 131
typedef long __off_t; 
# 132
typedef long __off64_t; 
# 133
typedef int __pid_t; 
# 134
typedef struct { int __val[2]; } __fsid_t; 
# 135
typedef long __clock_t; 
# 136
typedef unsigned long __rlim_t; 
# 137
typedef unsigned long __rlim64_t; 
# 138
typedef unsigned __id_t; 
# 139
typedef long __time_t; 
# 140
typedef unsigned __useconds_t; 
# 141
typedef long __suseconds_t; 
# 143
typedef int __daddr_t; 
# 144
typedef int __key_t; 
# 147
typedef int __clockid_t; 
# 150
typedef void *__timer_t; 
# 153
typedef int __blksize_t; 
# 158
typedef long __blkcnt_t; 
# 159
typedef long __blkcnt64_t; 
# 162
typedef unsigned long __fsblkcnt_t; 
# 163
typedef unsigned long __fsblkcnt64_t; 
# 166
typedef unsigned long __fsfilcnt_t; 
# 167
typedef unsigned long __fsfilcnt64_t; 
# 170
typedef long __fsword_t; 
# 172
typedef long __ssize_t; 
# 175
typedef long __syscall_slong_t; 
# 177
typedef unsigned long __syscall_ulong_t; 
# 181
typedef __off64_t __loff_t; 
# 182
typedef __quad_t *__qaddr_t; 
# 183
typedef char *__caddr_t; 
# 186
typedef long __intptr_t; 
# 189
typedef unsigned __socklen_t; 
# 30 "/usr/include/aarch64-linux-gnu/bits/time.h" 3
struct timeval { 
# 32
__time_t tv_sec; 
# 33
__suseconds_t tv_usec; 
# 34
}; 
# 25 "/usr/include/aarch64-linux-gnu/bits/timex.h" 3
struct timex { 
# 27
unsigned modes; 
# 28
__syscall_slong_t offset; 
# 29
__syscall_slong_t freq; 
# 30
__syscall_slong_t maxerror; 
# 31
__syscall_slong_t esterror; 
# 32
int status; 
# 33
__syscall_slong_t constant; 
# 34
__syscall_slong_t precision; 
# 35
__syscall_slong_t tolerance; 
# 36
timeval time; 
# 37
__syscall_slong_t tick; 
# 38
__syscall_slong_t ppsfreq; 
# 39
__syscall_slong_t jitter; 
# 40
int shift; 
# 41
__syscall_slong_t stabil; 
# 42
__syscall_slong_t jitcnt; 
# 43
__syscall_slong_t calcnt; 
# 44
__syscall_slong_t errcnt; 
# 45
__syscall_slong_t stbcnt; 
# 47
int tai; 
# 50
int:32; int:32; int:32; int:32; 
# 51
int:32; int:32; int:32; int:32; 
# 52
int:32; int:32; int:32; 
# 53
}; 
# 90 "/usr/include/aarch64-linux-gnu/bits/time.h" 3
extern "C" {
# 93
extern int clock_adjtime(__clockid_t __clock_id, timex * __utx) throw(); 
# 95
}
# 59 "/usr/include/time.h" 3
typedef __clock_t clock_t; 
# 75 "/usr/include/time.h" 3
typedef __time_t time_t; 
# 91 "/usr/include/time.h" 3
typedef __clockid_t clockid_t; 
# 103 "/usr/include/time.h" 3
typedef __timer_t timer_t; 
# 120 "/usr/include/time.h" 3
struct timespec { 
# 122
__time_t tv_sec; 
# 123
__syscall_slong_t tv_nsec; 
# 124
}; 
# 133
struct tm { 
# 135
int tm_sec; 
# 136
int tm_min; 
# 137
int tm_hour; 
# 138
int tm_mday; 
# 139
int tm_mon; 
# 140
int tm_year; 
# 141
int tm_wday; 
# 142
int tm_yday; 
# 143
int tm_isdst; 
# 146
long tm_gmtoff; 
# 147
const char *tm_zone; 
# 152
}; 
# 161
struct itimerspec { 
# 163
timespec it_interval; 
# 164
timespec it_value; 
# 165
}; 
# 168
struct sigevent; 
# 174
typedef __pid_t pid_t; 
# 189 "/usr/include/time.h" 3
extern clock_t clock() throw(); 
# 192
extern time_t time(time_t * __timer) throw(); 
# 195
extern double difftime(time_t __time1, time_t __time0) throw()
# 196
 __attribute((const)); 
# 199
extern time_t mktime(tm * __tp) throw(); 
# 205
extern size_t strftime(char *__restrict__ __s, size_t __maxsize, const char *__restrict__ __format, const tm *__restrict__ __tp) throw(); 
# 213
extern char *strptime(const char *__restrict__ __s, const char *__restrict__ __fmt, tm * __tp) throw(); 
# 223
extern size_t strftime_l(char *__restrict__ __s, size_t __maxsize, const char *__restrict__ __format, const tm *__restrict__ __tp, __locale_t __loc) throw(); 
# 230
extern char *strptime_l(const char *__restrict__ __s, const char *__restrict__ __fmt, tm * __tp, __locale_t __loc) throw(); 
# 239
extern tm *gmtime(const time_t * __timer) throw(); 
# 243
extern tm *localtime(const time_t * __timer) throw(); 
# 249
extern tm *gmtime_r(const time_t *__restrict__ __timer, tm *__restrict__ __tp) throw(); 
# 254
extern tm *localtime_r(const time_t *__restrict__ __timer, tm *__restrict__ __tp) throw(); 
# 261
extern char *asctime(const tm * __tp) throw(); 
# 264
extern char *ctime(const time_t * __timer) throw(); 
# 272
extern char *asctime_r(const tm *__restrict__ __tp, char *__restrict__ __buf) throw(); 
# 276
extern char *ctime_r(const time_t *__restrict__ __timer, char *__restrict__ __buf) throw(); 
# 282
extern char *__tzname[2]; 
# 283
extern int __daylight; 
# 284
extern long __timezone; 
# 289
extern char *tzname[2]; 
# 293
extern void tzset() throw(); 
# 297
extern int daylight; 
# 298
extern long timezone; 
# 304
extern int stime(const time_t * __when) throw(); 
# 319 "/usr/include/time.h" 3
extern time_t timegm(tm * __tp) throw(); 
# 322
extern time_t timelocal(tm * __tp) throw(); 
# 325
extern int dysize(int __year) throw() __attribute((const)); 
# 334 "/usr/include/time.h" 3
extern int nanosleep(const timespec * __requested_time, timespec * __remaining); 
# 339
extern int clock_getres(clockid_t __clock_id, timespec * __res) throw(); 
# 342
extern int clock_gettime(clockid_t __clock_id, timespec * __tp) throw(); 
# 345
extern int clock_settime(clockid_t __clock_id, const timespec * __tp) throw(); 
# 353
extern int clock_nanosleep(clockid_t __clock_id, int __flags, const timespec * __req, timespec * __rem); 
# 358
extern int clock_getcpuclockid(pid_t __pid, clockid_t * __clock_id) throw(); 
# 363
extern int timer_create(clockid_t __clock_id, sigevent *__restrict__ __evp, timer_t *__restrict__ __timerid) throw(); 
# 368
extern int timer_delete(timer_t __timerid) throw(); 
# 371
extern int timer_settime(timer_t __timerid, int __flags, const itimerspec *__restrict__ __value, itimerspec *__restrict__ __ovalue) throw(); 
# 376
extern int timer_gettime(timer_t __timerid, itimerspec * __value) throw(); 
# 380
extern int timer_getoverrun(timer_t __timerid) throw(); 
# 386
extern int timespec_get(timespec * __ts, int __base) throw()
# 387
 __attribute((__nonnull__(1))); 
# 403 "/usr/include/time.h" 3
extern int getdate_err; 
# 412 "/usr/include/time.h" 3
extern tm *getdate(const char * __string); 
# 426 "/usr/include/time.h" 3
extern int getdate_r(const char *__restrict__ __string, tm *__restrict__ __resbufp); 
# 430
}
# 70 "/usr/local/cuda-9.0/include/crt/common_functions.h"
extern "C" {
# 73
extern clock_t clock() throw(); 
# 78 "/usr/local/cuda-9.0/include/crt/common_functions.h"
extern void *memset(void *, int, size_t) throw(); 
# 79 "/usr/local/cuda-9.0/include/crt/common_functions.h"
extern void *memcpy(void *, const void *, size_t) throw(); 
# 81 "/usr/local/cuda-9.0/include/crt/common_functions.h"
}
# 98 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern "C" {
# 168 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int abs(int) throw(); 
# 169 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern long labs(long) throw(); 
# 170 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern long long llabs(long long) throw(); 
# 220 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double fabs(double x) throw(); 
# 261 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float fabsf(float x) throw(); 
# 265 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern inline int min(int, int); 
# 267
extern inline unsigned umin(unsigned, unsigned); 
# 268
extern inline long long llmin(long long, long long); 
# 269
extern inline unsigned long long ullmin(unsigned long long, unsigned long long); 
# 290 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float fminf(float x, float y) throw(); 
# 310 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double fmin(double x, double y) throw(); 
# 317 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern inline int max(int, int); 
# 319
extern inline unsigned umax(unsigned, unsigned); 
# 320
extern inline long long llmax(long long, long long); 
# 321
extern inline unsigned long long ullmax(unsigned long long, unsigned long long); 
# 342 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float fmaxf(float x, float y) throw(); 
# 362 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double fmax(double, double) throw(); 
# 406 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double sin(double x) throw(); 
# 439 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double cos(double x) throw(); 
# 458 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern void sincos(double x, double * sptr, double * cptr) throw(); 
# 474 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern void sincosf(float x, float * sptr, float * cptr) throw(); 
# 519 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double tan(double x) throw(); 
# 588 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double sqrt(double x) throw(); 
# 660 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double rsqrt(double x); 
# 730 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float rsqrtf(float x); 
# 786 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double log2(double x) throw(); 
# 811 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double exp2(double x) throw(); 
# 836 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float exp2f(float x) throw(); 
# 863 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double exp10(double x) throw(); 
# 886 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float exp10f(float x) throw(); 
# 932 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double expm1(double x) throw(); 
# 977 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float expm1f(float x) throw(); 
# 1032 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float log2f(float x) throw(); 
# 1086 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double log10(double x) throw(); 
# 1157 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double log(double x) throw(); 
# 1251 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double log1p(double x) throw(); 
# 1348 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float log1pf(float x) throw(); 
# 1423 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double floor(double x) throw(); 
# 1462 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double exp(double x) throw(); 
# 1493 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double cosh(double x) throw(); 
# 1523 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double sinh(double x) throw(); 
# 1553 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double tanh(double x) throw(); 
# 1588 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double acosh(double x) throw(); 
# 1626 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float acoshf(float x) throw(); 
# 1642 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double asinh(double x) throw(); 
# 1658 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float asinhf(float x) throw(); 
# 1712 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double atanh(double x) throw(); 
# 1766 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float atanhf(float x) throw(); 
# 1825 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double ldexp(double x, int exp) throw(); 
# 1881 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float ldexpf(float x, int exp) throw(); 
# 1933 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double logb(double x) throw(); 
# 1988 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float logbf(float x) throw(); 
# 2018 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int ilogb(double x) throw(); 
# 2048 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int ilogbf(float x) throw(); 
# 2124 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double scalbn(double x, int n) throw(); 
# 2200 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float scalbnf(float x, int n) throw(); 
# 2276 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double scalbln(double x, long n) throw(); 
# 2352 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float scalblnf(float x, long n) throw(); 
# 2430 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double frexp(double x, int * nptr) throw(); 
# 2505 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float frexpf(float x, int * nptr) throw(); 
# 2519 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double round(double x) throw(); 
# 2536 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float roundf(float x) throw(); 
# 2554 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern long lround(double x) throw(); 
# 2572 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern long lroundf(float x) throw(); 
# 2590 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern long long llround(double x) throw(); 
# 2608 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern long long llroundf(float x) throw(); 
# 2660 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float rintf(float x) throw(); 
# 2676 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern long lrint(double x) throw(); 
# 2692 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern long lrintf(float x) throw(); 
# 2708 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern long long llrint(double x) throw(); 
# 2724 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern long long llrintf(float x) throw(); 
# 2777 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double nearbyint(double x) throw(); 
# 2830 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float nearbyintf(float x) throw(); 
# 2892 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double ceil(double x) throw(); 
# 2904 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double trunc(double x) throw(); 
# 2919 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float truncf(float x) throw(); 
# 2945 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double fdim(double x, double y) throw(); 
# 2971 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float fdimf(float x, float y) throw(); 
# 3007 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double atan2(double y, double x) throw(); 
# 3038 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double atan(double x) throw(); 
# 3061 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double acos(double x) throw(); 
# 3093 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double asin(double x) throw(); 
# 3139 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double hypot(double x, double y) throw(); 
# 3191 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double rhypot(double x, double y) throw(); 
# 3237 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float hypotf(float x, float y) throw(); 
# 3289 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float rhypotf(float x, float y) throw(); 
# 3333 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double norm3d(double a, double b, double c) throw(); 
# 3384 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double rnorm3d(double a, double b, double c) throw(); 
# 3433 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double norm4d(double a, double b, double c, double d) throw(); 
# 3489 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double rnorm4d(double a, double b, double c, double d) throw(); 
# 3534 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double norm(int dim, const double * t) throw(); 
# 3585 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double rnorm(int dim, const double * t) throw(); 
# 3637 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float rnormf(int dim, const float * a) throw(); 
# 3681 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float normf(int dim, const float * a) throw(); 
# 3726 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float norm3df(float a, float b, float c) throw(); 
# 3777 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float rnorm3df(float a, float b, float c) throw(); 
# 3826 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float norm4df(float a, float b, float c, float d) throw(); 
# 3882 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float rnorm4df(float a, float b, float c, float d) throw(); 
# 3969 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double cbrt(double x) throw(); 
# 4055 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float cbrtf(float x) throw(); 
# 4110 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double rcbrt(double x); 
# 4160 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float rcbrtf(float x); 
# 4220 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double sinpi(double x); 
# 4280 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float sinpif(float x); 
# 4332 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double cospi(double x); 
# 4384 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float cospif(float x); 
# 4414 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern void sincospi(double x, double * sptr, double * cptr); 
# 4444 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern void sincospif(float x, float * sptr, float * cptr); 
# 4756 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double pow(double x, double y) throw(); 
# 4812 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double modf(double x, double * iptr) throw(); 
# 4871 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double fmod(double x, double y) throw(); 
# 4957 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double remainder(double x, double y) throw(); 
# 5047 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float remainderf(float x, float y) throw(); 
# 5101 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double remquo(double x, double y, int * quo) throw(); 
# 5155 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float remquof(float x, float y, int * quo) throw(); 
# 5196 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double j0(double x) throw(); 
# 5238 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float j0f(float x) throw(); 
# 5299 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double j1(double x) throw(); 
# 5360 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float j1f(float x) throw(); 
# 5403 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double jn(int n, double x) throw(); 
# 5446 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float jnf(int n, float x) throw(); 
# 5498 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double y0(double x) throw(); 
# 5550 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float y0f(float x) throw(); 
# 5602 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double y1(double x) throw(); 
# 5654 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float y1f(float x) throw(); 
# 5707 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double yn(int n, double x) throw(); 
# 5760 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float ynf(int n, float x) throw(); 
# 5787 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double cyl_bessel_i0(double x) throw(); 
# 5813 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float cyl_bessel_i0f(float x) throw(); 
# 5840 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double cyl_bessel_i1(double x) throw(); 
# 5866 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float cyl_bessel_i1f(float x) throw(); 
# 5949 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double erf(double x) throw(); 
# 6031 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float erff(float x) throw(); 
# 6095 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double erfinv(double y); 
# 6152 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float erfinvf(float y); 
# 6191 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double erfc(double x) throw(); 
# 6229 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float erfcf(float x) throw(); 
# 6357 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double lgamma(double x) throw(); 
# 6420 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double erfcinv(double y); 
# 6476 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float erfcinvf(float y); 
# 6534 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double normcdfinv(double y); 
# 6592 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float normcdfinvf(float y); 
# 6635 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double normcdf(double y); 
# 6678 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float normcdff(float y); 
# 6753 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double erfcx(double x); 
# 6828 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float erfcxf(float x); 
# 6962 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float lgammaf(float x) throw(); 
# 7071 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double tgamma(double x) throw(); 
# 7180 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float tgammaf(float x) throw(); 
# 7193 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double copysign(double x, double y) throw(); 
# 7206 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float copysignf(float x, float y) throw(); 
# 7243 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double nextafter(double x, double y) throw(); 
# 7280 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float nextafterf(float x, float y) throw(); 
# 7296 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double nan(const char * tagp) throw(); 
# 7312 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float nanf(const char * tagp) throw(); 
# 7319 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __isinff(float) throw(); 
# 7320 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __isnanf(float) throw(); 
# 7330 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __finite(double) throw(); 
# 7331 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __finitef(float) throw(); 
# 7332 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __signbit(double) throw(); 
# 7333 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __isnan(double) throw(); 
# 7334 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __isinf(double) throw(); 
# 7337 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __signbitf(float) throw(); 
# 7496 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern double fma(double x, double y, double z) throw(); 
# 7654 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float fmaf(float x, float y, float z) throw(); 
# 7665 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __signbitl(long double) throw(); 
# 7671 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __finitel(long double) throw(); 
# 7672 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __isinfl(long double) throw(); 
# 7673 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern int __isnanl(long double) throw(); 
# 7723 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float acosf(float x) throw(); 
# 7763 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float asinf(float x) throw(); 
# 7803 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float atanf(float x) throw(); 
# 7836 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float atan2f(float y, float x) throw(); 
# 7860 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float cosf(float x) throw(); 
# 7902 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float sinf(float x) throw(); 
# 7944 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float tanf(float x) throw(); 
# 7968 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float coshf(float x) throw(); 
# 8009 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float sinhf(float x) throw(); 
# 8039 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float tanhf(float x) throw(); 
# 8090 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float logf(float x) throw(); 
# 8140 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float expf(float x) throw(); 
# 8191 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float log10f(float x) throw(); 
# 8246 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float modff(float x, float * iptr) throw(); 
# 8554 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float powf(float x, float y) throw(); 
# 8623 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float sqrtf(float x) throw(); 
# 8682 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float ceilf(float x) throw(); 
# 8754 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float floorf(float x) throw(); 
# 8813 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern float fmodf(float x, float y) throw(); 
# 8828 "/usr/local/cuda-9.0/include/crt/math_functions.h"
}
# 28 "/usr/include/math.h" 3
extern "C" {
# 27 "/usr/include/aarch64-linux-gnu/bits/mathdef.h" 3
typedef float float_t; 
# 29
typedef double double_t; 
# 54 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3
extern double acos(double __x) throw(); extern double __acos(double __x) throw(); 
# 56
extern double asin(double __x) throw(); extern double __asin(double __x) throw(); 
# 58
extern double atan(double __x) throw(); extern double __atan(double __x) throw(); 
# 60
extern double atan2(double __y, double __x) throw(); extern double __atan2(double __y, double __x) throw(); 
# 63
extern double cos(double __x) throw(); extern double __cos(double __x) throw(); 
# 65
extern double sin(double __x) throw(); extern double __sin(double __x) throw(); 
# 67
extern double tan(double __x) throw(); extern double __tan(double __x) throw(); 
# 72
extern double cosh(double __x) throw(); extern double __cosh(double __x) throw(); 
# 74
extern double sinh(double __x) throw(); extern double __sinh(double __x) throw(); 
# 76
extern double tanh(double __x) throw(); extern double __tanh(double __x) throw(); 
# 81
extern void sincos(double __x, double * __sinx, double * __cosx) throw(); extern void __sincos(double __x, double * __sinx, double * __cosx) throw(); 
# 88
extern double acosh(double __x) throw(); extern double __acosh(double __x) throw(); 
# 90
extern double asinh(double __x) throw(); extern double __asinh(double __x) throw(); 
# 92
extern double atanh(double __x) throw(); extern double __atanh(double __x) throw(); 
# 100
extern double exp(double __x) throw(); extern double __exp(double __x) throw(); 
# 103
extern double frexp(double __x, int * __exponent) throw(); extern double __frexp(double __x, int * __exponent) throw(); 
# 106
extern double ldexp(double __x, int __exponent) throw(); extern double __ldexp(double __x, int __exponent) throw(); 
# 109
extern double log(double __x) throw(); extern double __log(double __x) throw(); 
# 112
extern double log10(double __x) throw(); extern double __log10(double __x) throw(); 
# 115
extern double modf(double __x, double * __iptr) throw(); extern double __modf(double __x, double * __iptr) throw() __attribute((__nonnull__(2))); 
# 120
extern double exp10(double __x) throw(); extern double __exp10(double __x) throw(); 
# 122
extern double pow10(double __x) throw(); extern double __pow10(double __x) throw(); 
# 128
extern double expm1(double __x) throw(); extern double __expm1(double __x) throw(); 
# 131
extern double log1p(double __x) throw(); extern double __log1p(double __x) throw(); 
# 134
extern double logb(double __x) throw(); extern double __logb(double __x) throw(); 
# 141
extern double exp2(double __x) throw(); extern double __exp2(double __x) throw(); 
# 144
extern double log2(double __x) throw(); extern double __log2(double __x) throw(); 
# 153
extern double pow(double __x, double __y) throw(); extern double __pow(double __x, double __y) throw(); 
# 156
extern double sqrt(double __x) throw(); extern double __sqrt(double __x) throw(); 
# 162
extern double hypot(double __x, double __y) throw(); extern double __hypot(double __x, double __y) throw(); 
# 169
extern double cbrt(double __x) throw(); extern double __cbrt(double __x) throw(); 
# 178
extern double ceil(double __x) throw() __attribute((const)); extern double __ceil(double __x) throw() __attribute((const)); 
# 181
extern double fabs(double __x) throw() __attribute((const)); extern double __fabs(double __x) throw() __attribute((const)); 
# 184
extern double floor(double __x) throw() __attribute((const)); extern double __floor(double __x) throw() __attribute((const)); 
# 187
extern double fmod(double __x, double __y) throw(); extern double __fmod(double __x, double __y) throw(); 
# 192
extern int __isinf(double __value) throw() __attribute((const)); 
# 195
extern int __finite(double __value) throw() __attribute((const)); 
# 208 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3
extern int finite(double __value) throw() __attribute((const)); 
# 211
extern double drem(double __x, double __y) throw(); extern double __drem(double __x, double __y) throw(); 
# 215
extern double significand(double __x) throw(); extern double __significand(double __x) throw(); 
# 221
extern double copysign(double __x, double __y) throw() __attribute((const)); extern double __copysign(double __x, double __y) throw() __attribute((const)); 
# 228
extern double nan(const char * __tagb) throw() __attribute((const)); extern double __nan(const char * __tagb) throw() __attribute((const)); 
# 234
extern int __isnan(double __value) throw() __attribute((const)); 
# 247 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3
extern double j0(double) throw(); extern double __j0(double) throw(); 
# 248
extern double j1(double) throw(); extern double __j1(double) throw(); 
# 249
extern double jn(int, double) throw(); extern double __jn(int, double) throw(); 
# 250
extern double y0(double) throw(); extern double __y0(double) throw(); 
# 251
extern double y1(double) throw(); extern double __y1(double) throw(); 
# 252
extern double yn(int, double) throw(); extern double __yn(int, double) throw(); 
# 259
extern double erf(double) throw(); extern double __erf(double) throw(); 
# 260
extern double erfc(double) throw(); extern double __erfc(double) throw(); 
# 261
extern double lgamma(double) throw(); extern double __lgamma(double) throw(); 
# 268
extern double tgamma(double) throw(); extern double __tgamma(double) throw(); 
# 274
extern double gamma(double) throw(); extern double __gamma(double) throw(); 
# 281
extern double lgamma_r(double, int * __signgamp) throw(); extern double __lgamma_r(double, int * __signgamp) throw(); 
# 289
extern double rint(double __x) throw(); extern double __rint(double __x) throw(); 
# 292
extern double nextafter(double __x, double __y) throw() __attribute((const)); extern double __nextafter(double __x, double __y) throw() __attribute((const)); 
# 294
extern double nexttoward(double __x, long double __y) throw() __attribute((const)); extern double __nexttoward(double __x, long double __y) throw() __attribute((const)); 
# 298
extern double remainder(double __x, double __y) throw(); extern double __remainder(double __x, double __y) throw(); 
# 302
extern double scalbn(double __x, int __n) throw(); extern double __scalbn(double __x, int __n) throw(); 
# 306
extern int ilogb(double __x) throw(); extern int __ilogb(double __x) throw(); 
# 311
extern double scalbln(double __x, long __n) throw(); extern double __scalbln(double __x, long __n) throw(); 
# 315
extern double nearbyint(double __x) throw(); extern double __nearbyint(double __x) throw(); 
# 319
extern double round(double __x) throw() __attribute((const)); extern double __round(double __x) throw() __attribute((const)); 
# 323
extern double trunc(double __x) throw() __attribute((const)); extern double __trunc(double __x) throw() __attribute((const)); 
# 328
extern double remquo(double __x, double __y, int * __quo) throw(); extern double __remquo(double __x, double __y, int * __quo) throw(); 
# 335
extern long lrint(double __x) throw(); extern long __lrint(double __x) throw(); 
# 337
__extension__ extern long long llrint(double __x) throw(); extern long long __llrint(double __x) throw(); 
# 341
extern long lround(double __x) throw(); extern long __lround(double __x) throw(); 
# 343
__extension__ extern long long llround(double __x) throw(); extern long long __llround(double __x) throw(); 
# 347
extern double fdim(double __x, double __y) throw(); extern double __fdim(double __x, double __y) throw(); 
# 350
extern double fmax(double __x, double __y) throw() __attribute((const)); extern double __fmax(double __x, double __y) throw() __attribute((const)); 
# 353
extern double fmin(double __x, double __y) throw() __attribute((const)); extern double __fmin(double __x, double __y) throw() __attribute((const)); 
# 357
extern int __fpclassify(double __value) throw()
# 358
 __attribute((const)); 
# 361
extern int __signbit(double __value) throw()
# 362
 __attribute((const)); 
# 366
extern double fma(double __x, double __y, double __z) throw(); extern double __fma(double __x, double __y, double __z) throw(); 
# 375
extern int __issignaling(double __value) throw()
# 376
 __attribute((const)); 
# 383
extern double scalb(double __x, double __n) throw(); extern double __scalb(double __x, double __n) throw(); 
# 54 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3
extern float acosf(float __x) throw(); extern float __acosf(float __x) throw(); 
# 56
extern float asinf(float __x) throw(); extern float __asinf(float __x) throw(); 
# 58
extern float atanf(float __x) throw(); extern float __atanf(float __x) throw(); 
# 60
extern float atan2f(float __y, float __x) throw(); extern float __atan2f(float __y, float __x) throw(); 
# 63
extern float cosf(float __x) throw(); 
# 65
extern float sinf(float __x) throw(); 
# 67
extern float tanf(float __x) throw(); 
# 72
extern float coshf(float __x) throw(); extern float __coshf(float __x) throw(); 
# 74
extern float sinhf(float __x) throw(); extern float __sinhf(float __x) throw(); 
# 76
extern float tanhf(float __x) throw(); extern float __tanhf(float __x) throw(); 
# 81
extern void sincosf(float __x, float * __sinx, float * __cosx) throw(); 
# 88
extern float acoshf(float __x) throw(); extern float __acoshf(float __x) throw(); 
# 90
extern float asinhf(float __x) throw(); extern float __asinhf(float __x) throw(); 
# 92
extern float atanhf(float __x) throw(); extern float __atanhf(float __x) throw(); 
# 100
extern float expf(float __x) throw(); 
# 103
extern float frexpf(float __x, int * __exponent) throw(); extern float __frexpf(float __x, int * __exponent) throw(); 
# 106
extern float ldexpf(float __x, int __exponent) throw(); extern float __ldexpf(float __x, int __exponent) throw(); 
# 109
extern float logf(float __x) throw(); 
# 112
extern float log10f(float __x) throw(); 
# 115
extern float modff(float __x, float * __iptr) throw(); extern float __modff(float __x, float * __iptr) throw() __attribute((__nonnull__(2))); 
# 120
extern float exp10f(float __x) throw(); 
# 122
extern float pow10f(float __x) throw(); extern float __pow10f(float __x) throw(); 
# 128
extern float expm1f(float __x) throw(); extern float __expm1f(float __x) throw(); 
# 131
extern float log1pf(float __x) throw(); extern float __log1pf(float __x) throw(); 
# 134
extern float logbf(float __x) throw(); extern float __logbf(float __x) throw(); 
# 141
extern float exp2f(float __x) throw(); extern float __exp2f(float __x) throw(); 
# 144
extern float log2f(float __x) throw(); 
# 153
extern float powf(float __x, float __y) throw(); 
# 156
extern float sqrtf(float __x) throw(); extern float __sqrtf(float __x) throw(); 
# 162
extern float hypotf(float __x, float __y) throw(); extern float __hypotf(float __x, float __y) throw(); 
# 169
extern float cbrtf(float __x) throw(); extern float __cbrtf(float __x) throw(); 
# 178
extern float ceilf(float __x) throw() __attribute((const)); extern float __ceilf(float __x) throw() __attribute((const)); 
# 181
extern float fabsf(float __x) throw() __attribute((const)); extern float __fabsf(float __x) throw() __attribute((const)); 
# 184
extern float floorf(float __x) throw() __attribute((const)); extern float __floorf(float __x) throw() __attribute((const)); 
# 187
extern float fmodf(float __x, float __y) throw(); extern float __fmodf(float __x, float __y) throw(); 
# 192
extern int __isinff(float __value) throw() __attribute((const)); 
# 195
extern int __finitef(float __value) throw() __attribute((const)); 
# 204
extern int isinff(float __value) throw() __attribute((const)); 
# 208
extern int finitef(float __value) throw() __attribute((const)); 
# 211
extern float dremf(float __x, float __y) throw(); extern float __dremf(float __x, float __y) throw(); 
# 215
extern float significandf(float __x) throw(); extern float __significandf(float __x) throw(); 
# 221
extern float copysignf(float __x, float __y) throw() __attribute((const)); extern float __copysignf(float __x, float __y) throw() __attribute((const)); 
# 228
extern float nanf(const char * __tagb) throw() __attribute((const)); extern float __nanf(const char * __tagb) throw() __attribute((const)); 
# 234
extern int __isnanf(float __value) throw() __attribute((const)); 
# 241
extern int isnanf(float __value) throw() __attribute((const)); 
# 247
extern float j0f(float) throw(); extern float __j0f(float) throw(); 
# 248
extern float j1f(float) throw(); extern float __j1f(float) throw(); 
# 249
extern float jnf(int, float) throw(); extern float __jnf(int, float) throw(); 
# 250
extern float y0f(float) throw(); extern float __y0f(float) throw(); 
# 251
extern float y1f(float) throw(); extern float __y1f(float) throw(); 
# 252
extern float ynf(int, float) throw(); extern float __ynf(int, float) throw(); 
# 259
extern float erff(float) throw(); extern float __erff(float) throw(); 
# 260
extern float erfcf(float) throw(); extern float __erfcf(float) throw(); 
# 261
extern float lgammaf(float) throw(); extern float __lgammaf(float) throw(); 
# 268
extern float tgammaf(float) throw(); extern float __tgammaf(float) throw(); 
# 274
extern float gammaf(float) throw(); extern float __gammaf(float) throw(); 
# 281
extern float lgammaf_r(float, int * __signgamp) throw(); extern float __lgammaf_r(float, int * __signgamp) throw(); 
# 289
extern float rintf(float __x) throw(); extern float __rintf(float __x) throw(); 
# 292
extern float nextafterf(float __x, float __y) throw() __attribute((const)); extern float __nextafterf(float __x, float __y) throw() __attribute((const)); 
# 294
extern float nexttowardf(float __x, long double __y) throw() __attribute((const)); extern float __nexttowardf(float __x, long double __y) throw() __attribute((const)); 
# 298
extern float remainderf(float __x, float __y) throw(); extern float __remainderf(float __x, float __y) throw(); 
# 302
extern float scalbnf(float __x, int __n) throw(); extern float __scalbnf(float __x, int __n) throw(); 
# 306
extern int ilogbf(float __x) throw(); extern int __ilogbf(float __x) throw(); 
# 311
extern float scalblnf(float __x, long __n) throw(); extern float __scalblnf(float __x, long __n) throw(); 
# 315
extern float nearbyintf(float __x) throw(); extern float __nearbyintf(float __x) throw(); 
# 319
extern float roundf(float __x) throw() __attribute((const)); extern float __roundf(float __x) throw() __attribute((const)); 
# 323
extern float truncf(float __x) throw() __attribute((const)); extern float __truncf(float __x) throw() __attribute((const)); 
# 328
extern float remquof(float __x, float __y, int * __quo) throw(); extern float __remquof(float __x, float __y, int * __quo) throw(); 
# 335
extern long lrintf(float __x) throw(); extern long __lrintf(float __x) throw(); 
# 337
__extension__ extern long long llrintf(float __x) throw(); extern long long __llrintf(float __x) throw(); 
# 341
extern long lroundf(float __x) throw(); extern long __lroundf(float __x) throw(); 
# 343
__extension__ extern long long llroundf(float __x) throw(); extern long long __llroundf(float __x) throw(); 
# 347
extern float fdimf(float __x, float __y) throw(); extern float __fdimf(float __x, float __y) throw(); 
# 350
extern float fmaxf(float __x, float __y) throw() __attribute((const)); extern float __fmaxf(float __x, float __y) throw() __attribute((const)); 
# 353
extern float fminf(float __x, float __y) throw() __attribute((const)); extern float __fminf(float __x, float __y) throw() __attribute((const)); 
# 357
extern int __fpclassifyf(float __value) throw()
# 358
 __attribute((const)); 
# 361
extern int __signbitf(float __value) throw()
# 362
 __attribute((const)); 
# 366
extern float fmaf(float __x, float __y, float __z) throw(); extern float __fmaf(float __x, float __y, float __z) throw(); 
# 375
extern int __issignalingf(float __value) throw()
# 376
 __attribute((const)); 
# 383
extern float scalbf(float __x, float __n) throw(); extern float __scalbf(float __x, float __n) throw(); 
# 54 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3
extern long double acosl(long double __x) throw(); extern long double __acosl(long double __x) throw(); 
# 56
extern long double asinl(long double __x) throw(); extern long double __asinl(long double __x) throw(); 
# 58
extern long double atanl(long double __x) throw(); extern long double __atanl(long double __x) throw(); 
# 60
extern long double atan2l(long double __y, long double __x) throw(); extern long double __atan2l(long double __y, long double __x) throw(); 
# 63
extern long double cosl(long double __x) throw(); extern long double __cosl(long double __x) throw(); 
# 65
extern long double sinl(long double __x) throw(); extern long double __sinl(long double __x) throw(); 
# 67
extern long double tanl(long double __x) throw(); extern long double __tanl(long double __x) throw(); 
# 72
extern long double coshl(long double __x) throw(); extern long double __coshl(long double __x) throw(); 
# 74
extern long double sinhl(long double __x) throw(); extern long double __sinhl(long double __x) throw(); 
# 76
extern long double tanhl(long double __x) throw(); extern long double __tanhl(long double __x) throw(); 
# 81
extern void sincosl(long double __x, long double * __sinx, long double * __cosx) throw(); extern void __sincosl(long double __x, long double * __sinx, long double * __cosx) throw(); 
# 88
extern long double acoshl(long double __x) throw(); extern long double __acoshl(long double __x) throw(); 
# 90
extern long double asinhl(long double __x) throw(); extern long double __asinhl(long double __x) throw(); 
# 92
extern long double atanhl(long double __x) throw(); extern long double __atanhl(long double __x) throw(); 
# 100
extern long double expl(long double __x) throw(); extern long double __expl(long double __x) throw(); 
# 103
extern long double frexpl(long double __x, int * __exponent) throw(); extern long double __frexpl(long double __x, int * __exponent) throw(); 
# 106
extern long double ldexpl(long double __x, int __exponent) throw(); extern long double __ldexpl(long double __x, int __exponent) throw(); 
# 109
extern long double logl(long double __x) throw(); extern long double __logl(long double __x) throw(); 
# 112
extern long double log10l(long double __x) throw(); extern long double __log10l(long double __x) throw(); 
# 115
extern long double modfl(long double __x, long double * __iptr) throw(); extern long double __modfl(long double __x, long double * __iptr) throw() __attribute((__nonnull__(2))); 
# 120
extern long double exp10l(long double __x) throw(); extern long double __exp10l(long double __x) throw(); 
# 122
extern long double pow10l(long double __x) throw(); extern long double __pow10l(long double __x) throw(); 
# 128
extern long double expm1l(long double __x) throw(); extern long double __expm1l(long double __x) throw(); 
# 131
extern long double log1pl(long double __x) throw(); extern long double __log1pl(long double __x) throw(); 
# 134
extern long double logbl(long double __x) throw(); extern long double __logbl(long double __x) throw(); 
# 141
extern long double exp2l(long double __x) throw(); extern long double __exp2l(long double __x) throw(); 
# 144
extern long double log2l(long double __x) throw(); extern long double __log2l(long double __x) throw(); 
# 153
extern long double powl(long double __x, long double __y) throw(); extern long double __powl(long double __x, long double __y) throw(); 
# 156
extern long double sqrtl(long double __x) throw(); extern long double __sqrtl(long double __x) throw(); 
# 162
extern long double hypotl(long double __x, long double __y) throw(); extern long double __hypotl(long double __x, long double __y) throw(); 
# 169
extern long double cbrtl(long double __x) throw(); extern long double __cbrtl(long double __x) throw(); 
# 178
extern long double ceill(long double __x) throw() __attribute((const)); extern long double __ceill(long double __x) throw() __attribute((const)); 
# 181
extern long double fabsl(long double __x) throw() __attribute((const)); extern long double __fabsl(long double __x) throw() __attribute((const)); 
# 184
extern long double floorl(long double __x) throw() __attribute((const)); extern long double __floorl(long double __x) throw() __attribute((const)); 
# 187
extern long double fmodl(long double __x, long double __y) throw(); extern long double __fmodl(long double __x, long double __y) throw(); 
# 192
extern int __isinfl(long double __value) throw() __attribute((const)); 
# 195
extern int __finitel(long double __value) throw() __attribute((const)); 
# 204
extern int isinfl(long double __value) throw() __attribute((const)); 
# 208
extern int finitel(long double __value) throw() __attribute((const)); 
# 211
extern long double dreml(long double __x, long double __y) throw(); extern long double __dreml(long double __x, long double __y) throw(); 
# 215
extern long double significandl(long double __x) throw(); extern long double __significandl(long double __x) throw(); 
# 221
extern long double copysignl(long double __x, long double __y) throw() __attribute((const)); extern long double __copysignl(long double __x, long double __y) throw() __attribute((const)); 
# 228
extern long double nanl(const char * __tagb) throw() __attribute((const)); extern long double __nanl(const char * __tagb) throw() __attribute((const)); 
# 234
extern int __isnanl(long double __value) throw() __attribute((const)); 
# 241
extern int isnanl(long double __value) throw() __attribute((const)); 
# 247
extern long double j0l(long double) throw(); extern long double __j0l(long double) throw(); 
# 248
extern long double j1l(long double) throw(); extern long double __j1l(long double) throw(); 
# 249
extern long double jnl(int, long double) throw(); extern long double __jnl(int, long double) throw(); 
# 250
extern long double y0l(long double) throw(); extern long double __y0l(long double) throw(); 
# 251
extern long double y1l(long double) throw(); extern long double __y1l(long double) throw(); 
# 252
extern long double ynl(int, long double) throw(); extern long double __ynl(int, long double) throw(); 
# 259
extern long double erfl(long double) throw(); extern long double __erfl(long double) throw(); 
# 260
extern long double erfcl(long double) throw(); extern long double __erfcl(long double) throw(); 
# 261
extern long double lgammal(long double) throw(); extern long double __lgammal(long double) throw(); 
# 268
extern long double tgammal(long double) throw(); extern long double __tgammal(long double) throw(); 
# 274
extern long double gammal(long double) throw(); extern long double __gammal(long double) throw(); 
# 281
extern long double lgammal_r(long double, int * __signgamp) throw(); extern long double __lgammal_r(long double, int * __signgamp) throw(); 
# 289
extern long double rintl(long double __x) throw(); extern long double __rintl(long double __x) throw(); 
# 292
extern long double nextafterl(long double __x, long double __y) throw() __attribute((const)); extern long double __nextafterl(long double __x, long double __y) throw() __attribute((const)); 
# 294
extern long double nexttowardl(long double __x, long double __y) throw() __attribute((const)); extern long double __nexttowardl(long double __x, long double __y) throw() __attribute((const)); 
# 298
extern long double remainderl(long double __x, long double __y) throw(); extern long double __remainderl(long double __x, long double __y) throw(); 
# 302
extern long double scalbnl(long double __x, int __n) throw(); extern long double __scalbnl(long double __x, int __n) throw(); 
# 306
extern int ilogbl(long double __x) throw(); extern int __ilogbl(long double __x) throw(); 
# 311
extern long double scalblnl(long double __x, long __n) throw(); extern long double __scalblnl(long double __x, long __n) throw(); 
# 315
extern long double nearbyintl(long double __x) throw(); extern long double __nearbyintl(long double __x) throw(); 
# 319
extern long double roundl(long double __x) throw() __attribute((const)); extern long double __roundl(long double __x) throw() __attribute((const)); 
# 323
extern long double truncl(long double __x) throw() __attribute((const)); extern long double __truncl(long double __x) throw() __attribute((const)); 
# 328
extern long double remquol(long double __x, long double __y, int * __quo) throw(); extern long double __remquol(long double __x, long double __y, int * __quo) throw(); 
# 335
extern long lrintl(long double __x) throw(); extern long __lrintl(long double __x) throw(); 
# 337
__extension__ extern long long llrintl(long double __x) throw(); extern long long __llrintl(long double __x) throw(); 
# 341
extern long lroundl(long double __x) throw(); extern long __lroundl(long double __x) throw(); 
# 343
__extension__ extern long long llroundl(long double __x) throw(); extern long long __llroundl(long double __x) throw(); 
# 347
extern long double fdiml(long double __x, long double __y) throw(); extern long double __fdiml(long double __x, long double __y) throw(); 
# 350
extern long double fmaxl(long double __x, long double __y) throw() __attribute((const)); extern long double __fmaxl(long double __x, long double __y) throw() __attribute((const)); 
# 353
extern long double fminl(long double __x, long double __y) throw() __attribute((const)); extern long double __fminl(long double __x, long double __y) throw() __attribute((const)); 
# 357
extern int __fpclassifyl(long double __value) throw()
# 358
 __attribute((const)); 
# 361
extern int __signbitl(long double __value) throw()
# 362
 __attribute((const)); 
# 366
extern long double fmal(long double __x, long double __y, long double __z) throw(); extern long double __fmal(long double __x, long double __y, long double __z) throw(); 
# 375
extern int __issignalingl(long double __value) throw()
# 376
 __attribute((const)); 
# 383
extern long double scalbl(long double __x, long double __n) throw(); extern long double __scalbl(long double __x, long double __n) throw(); 
# 168 "/usr/include/math.h" 3
extern int signgam; 
# 210 "/usr/include/math.h" 3
enum { 
# 211
FP_NAN, 
# 214
FP_INFINITE, 
# 217
FP_ZERO, 
# 220
FP_SUBNORMAL, 
# 223
FP_NORMAL
# 226
}; 
# 354 "/usr/include/math.h" 3
typedef 
# 348
enum { 
# 349
_IEEE_ = (-1), 
# 350
_SVID_ = 0, 
# 351
_XOPEN_, 
# 352
_POSIX_, 
# 353
_ISOC_
# 354
} _LIB_VERSION_TYPE; 
# 359
extern _LIB_VERSION_TYPE _LIB_VERSION; 
# 370 "/usr/include/math.h" 3
struct __exception { 
# 375
int type; 
# 376
char *name; 
# 377
double arg1; 
# 378
double arg2; 
# 379
double retval; 
# 380
}; 
# 383
extern int matherr(__exception * __exc) throw(); 
# 534 "/usr/include/math.h" 3
}
# 34 "/usr/include/stdlib.h" 3
extern "C" {
# 55 "/usr/include/aarch64-linux-gnu/bits/waitflags.h" 3
typedef 
# 51
enum { 
# 52
P_ALL, 
# 53
P_PID, 
# 54
P_PGID
# 55
} idtype_t; 
# 44 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 3
static inline unsigned __bswap_32(unsigned __bsx) 
# 45
{ 
# 46
return __builtin_bswap32(__bsx); 
# 47
} 
# 75 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 3
static inline __uint64_t __bswap_64(__uint64_t __bsx) 
# 76
{ 
# 77
return __builtin_bswap64(__bsx); 
# 78
} 
# 66 "/usr/include/aarch64-linux-gnu/bits/waitstatus.h" 3
union wait { 
# 68
int w_status; 
# 70
struct { 
# 72
unsigned __w_termsig:7; 
# 73
unsigned __w_coredump:1; 
# 74
unsigned __w_retcode:8; 
# 75
unsigned:16; 
# 83
} __wait_terminated; 
# 85
struct { 
# 87
unsigned __w_stopval:8; 
# 88
unsigned __w_stopsig:8; 
# 89
unsigned:16; 
# 96
} __wait_stopped; 
# 97
}; 
# 101 "/usr/include/stdlib.h" 3
typedef 
# 98
struct { 
# 99
int quot; 
# 100
int rem; 
# 101
} div_t; 
# 109
typedef 
# 106
struct { 
# 107
long quot; 
# 108
long rem; 
# 109
} ldiv_t; 
# 121
__extension__ typedef 
# 118
struct { 
# 119
long long quot; 
# 120
long long rem; 
# 121
} lldiv_t; 
# 139 "/usr/include/stdlib.h" 3
extern size_t __ctype_get_mb_cur_max() throw(); 
# 144
extern double atof(const char * __nptr) throw()
# 145
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 147
extern int atoi(const char * __nptr) throw()
# 148
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 150
extern long atol(const char * __nptr) throw()
# 151
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 157
__extension__ extern long long atoll(const char * __nptr) throw()
# 158
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 164
extern double strtod(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 166
 __attribute((__nonnull__(1))); 
# 172
extern float strtof(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 173
 __attribute((__nonnull__(1))); 
# 175
extern long double strtold(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 177
 __attribute((__nonnull__(1))); 
# 183
extern long strtol(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 185
 __attribute((__nonnull__(1))); 
# 187
extern unsigned long strtoul(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 189
 __attribute((__nonnull__(1))); 
# 195
__extension__ extern long long strtoq(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 197
 __attribute((__nonnull__(1))); 
# 200
__extension__ extern unsigned long long strtouq(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 202
 __attribute((__nonnull__(1))); 
# 209
__extension__ extern long long strtoll(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 211
 __attribute((__nonnull__(1))); 
# 214
__extension__ extern unsigned long long strtoull(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 216
 __attribute((__nonnull__(1))); 
# 239 "/usr/include/stdlib.h" 3
extern long strtol_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 241
 __attribute((__nonnull__(1, 4))); 
# 243
extern unsigned long strtoul_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 246
 __attribute((__nonnull__(1, 4))); 
# 249
__extension__ extern long long strtoll_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 252
 __attribute((__nonnull__(1, 4))); 
# 255
__extension__ extern unsigned long long strtoull_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 258
 __attribute((__nonnull__(1, 4))); 
# 260
extern double strtod_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, __locale_t __loc) throw()
# 262
 __attribute((__nonnull__(1, 3))); 
# 264
extern float strtof_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, __locale_t __loc) throw()
# 266
 __attribute((__nonnull__(1, 3))); 
# 268
extern long double strtold_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, __locale_t __loc) throw()
# 271
 __attribute((__nonnull__(1, 3))); 
# 305 "/usr/include/stdlib.h" 3
extern char *l64a(long __n) throw(); 
# 308
extern long a64l(const char * __s) throw()
# 309
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 27 "/usr/include/aarch64-linux-gnu/sys/types.h" 3
extern "C" {
# 33
typedef __u_char u_char; 
# 34
typedef __u_short u_short; 
# 35
typedef __u_int u_int; 
# 36
typedef __u_long u_long; 
# 37
typedef __quad_t quad_t; 
# 38
typedef __u_quad_t u_quad_t; 
# 39
typedef __fsid_t fsid_t; 
# 44
typedef __loff_t loff_t; 
# 48
typedef __ino_t ino_t; 
# 55
typedef __ino64_t ino64_t; 
# 60
typedef __dev_t dev_t; 
# 65
typedef __gid_t gid_t; 
# 70
typedef __mode_t mode_t; 
# 75
typedef __nlink_t nlink_t; 
# 80
typedef __uid_t uid_t; 
# 86
typedef __off_t off_t; 
# 93
typedef __off64_t off64_t; 
# 104 "/usr/include/aarch64-linux-gnu/sys/types.h" 3
typedef __id_t id_t; 
# 109
typedef __ssize_t ssize_t; 
# 115
typedef __daddr_t daddr_t; 
# 116
typedef __caddr_t caddr_t; 
# 122
typedef __key_t key_t; 
# 136 "/usr/include/aarch64-linux-gnu/sys/types.h" 3
typedef __useconds_t useconds_t; 
# 140
typedef __suseconds_t suseconds_t; 
# 150 "/usr/include/aarch64-linux-gnu/sys/types.h" 3
typedef unsigned long ulong; 
# 151
typedef unsigned short ushort; 
# 152
typedef unsigned uint; 
# 194 "/usr/include/aarch64-linux-gnu/sys/types.h" 3
typedef signed char int8_t __attribute((__mode__(__QI__))); 
# 195
typedef short int16_t __attribute((__mode__(__HI__))); 
# 196
typedef int int32_t __attribute((__mode__(__SI__))); 
# 197
typedef long int64_t __attribute((__mode__(__DI__))); 
# 200
typedef unsigned char u_int8_t __attribute((__mode__(__QI__))); 
# 201
typedef unsigned short u_int16_t __attribute((__mode__(__HI__))); 
# 202
typedef unsigned u_int32_t __attribute((__mode__(__SI__))); 
# 203
typedef unsigned long u_int64_t __attribute((__mode__(__DI__))); 
# 205
typedef long register_t __attribute((__mode__(__word__))); 
# 22 "/usr/include/aarch64-linux-gnu/bits/sigset.h" 3
typedef int __sig_atomic_t; 
# 30
typedef 
# 28
struct { 
# 29
unsigned long __val[(1024) / ((8) * sizeof(unsigned long))]; 
# 30
} __sigset_t; 
# 37 "/usr/include/aarch64-linux-gnu/sys/select.h" 3
typedef __sigset_t sigset_t; 
# 54 "/usr/include/aarch64-linux-gnu/sys/select.h" 3
typedef long __fd_mask; 
# 75 "/usr/include/aarch64-linux-gnu/sys/select.h" 3
typedef 
# 65
struct { 
# 69
__fd_mask fds_bits[1024 / (8 * ((int)sizeof(__fd_mask)))]; 
# 75
} fd_set; 
# 82
typedef __fd_mask fd_mask; 
# 96 "/usr/include/aarch64-linux-gnu/sys/select.h" 3
extern "C" {
# 106 "/usr/include/aarch64-linux-gnu/sys/select.h" 3
extern int select(int __nfds, fd_set *__restrict__ __readfds, fd_set *__restrict__ __writefds, fd_set *__restrict__ __exceptfds, timeval *__restrict__ __timeout); 
# 118 "/usr/include/aarch64-linux-gnu/sys/select.h" 3
extern int pselect(int __nfds, fd_set *__restrict__ __readfds, fd_set *__restrict__ __writefds, fd_set *__restrict__ __exceptfds, const timespec *__restrict__ __timeout, const __sigset_t *__restrict__ __sigmask); 
# 131 "/usr/include/aarch64-linux-gnu/sys/select.h" 3
}
# 24 "/usr/include/aarch64-linux-gnu/sys/sysmacros.h" 3
extern "C" {
# 27
__extension__ extern unsigned gnu_dev_major(unsigned long long __dev) throw()
# 28
 __attribute((const)); 
# 30
__extension__ extern unsigned gnu_dev_minor(unsigned long long __dev) throw()
# 31
 __attribute((const)); 
# 33
__extension__ extern unsigned long long gnu_dev_makedev(unsigned __major, unsigned __minor) throw()
# 35
 __attribute((const)); 
# 58 "/usr/include/aarch64-linux-gnu/sys/sysmacros.h" 3
}
# 228 "/usr/include/aarch64-linux-gnu/sys/types.h" 3
typedef __blksize_t blksize_t; 
# 235
typedef __blkcnt_t blkcnt_t; 
# 239
typedef __fsblkcnt_t fsblkcnt_t; 
# 243
typedef __fsfilcnt_t fsfilcnt_t; 
# 262 "/usr/include/aarch64-linux-gnu/sys/types.h" 3
typedef __blkcnt64_t blkcnt64_t; 
# 263
typedef __fsblkcnt64_t fsblkcnt64_t; 
# 264
typedef __fsfilcnt64_t fsfilcnt64_t; 
# 38 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes.h" 3
typedef unsigned long pthread_t; 
# 41
union pthread_attr_t { 
# 43
char __size[64]; 
# 44
long __align; 
# 45
}; 
# 47
typedef pthread_attr_t pthread_attr_t; 
# 55
typedef 
# 51
struct __pthread_internal_list { 
# 53
__pthread_internal_list *__prev; 
# 54
__pthread_internal_list *__next; 
# 55
} __pthread_list_t; 
# 75
typedef 
# 61
union { 
# 62
struct __pthread_mutex_s { 
# 64
int __lock; 
# 65
unsigned __count; 
# 66
int __owner; 
# 67
unsigned __nusers; 
# 68
int __kind; 
# 69
int __spins; 
# 70
__pthread_list_t __list; 
# 72
} __data; 
# 73
char __size[48]; 
# 74
long __align; 
# 75
} pthread_mutex_t; 
# 84
typedef 
# 81
union { 
# 82
char __size[8]; 
# 83
long __align; 
# 84
} pthread_mutexattr_t; 
# 104
typedef 
# 90
union { 
# 92
struct { 
# 93
int __lock; 
# 94
unsigned __futex; 
# 95
__extension__ unsigned long long __total_seq; 
# 96
__extension__ unsigned long long __wakeup_seq; 
# 97
__extension__ unsigned long long __woken_seq; 
# 98
void *__mutex; 
# 99
unsigned __nwaiters; 
# 100
unsigned __broadcast_seq; 
# 101
} __data; 
# 102
char __size[48]; 
# 103
long __align; 
# 104
} pthread_cond_t; 
# 110
typedef 
# 107
union { 
# 108
char __size[8]; 
# 109
int __align; 
# 110
} pthread_condattr_t; 
# 114
typedef unsigned pthread_key_t; 
# 118
typedef int pthread_once_t; 
# 142
typedef 
# 125
union { 
# 127
struct { 
# 128
int __lock; 
# 129
unsigned __nr_readers; 
# 130
unsigned __readers_wakeup; 
# 131
unsigned __writer_wakeup; 
# 132
unsigned __nr_readers_queued; 
# 133
unsigned __nr_writers_queued; 
# 134
int __writer; 
# 135
int __shared; 
# 136
unsigned long __pad1; 
# 137
unsigned long __pad2; 
# 138
unsigned __flags; 
# 139
} __data; 
# 140
char __size[56]; 
# 141
long __align; 
# 142
} pthread_rwlock_t; 
# 150
typedef 
# 147
union { 
# 148
char __size[8]; 
# 149
long __align; 
# 150
} pthread_rwlockattr_t; 
# 156
typedef volatile int pthread_spinlock_t; 
# 165
typedef 
# 162
union { 
# 163
char __size[32]; 
# 164
long __align; 
# 165
} pthread_barrier_t; 
# 171
typedef 
# 168
union { 
# 169
char __size[8]; 
# 170
int __align; 
# 171
} pthread_barrierattr_t; 
# 273 "/usr/include/aarch64-linux-gnu/sys/types.h" 3
}
# 321 "/usr/include/stdlib.h" 3
extern long random() throw(); 
# 324
extern void srandom(unsigned __seed) throw(); 
# 330
extern char *initstate(unsigned __seed, char * __statebuf, size_t __statelen) throw()
# 331
 __attribute((__nonnull__(2))); 
# 335
extern char *setstate(char * __statebuf) throw() __attribute((__nonnull__(1))); 
# 343
struct random_data { 
# 345
int32_t *fptr; 
# 346
int32_t *rptr; 
# 347
int32_t *state; 
# 348
int rand_type; 
# 349
int rand_deg; 
# 350
int rand_sep; 
# 351
int32_t *end_ptr; 
# 352
}; 
# 354
extern int random_r(random_data *__restrict__ __buf, int32_t *__restrict__ __result) throw()
# 355
 __attribute((__nonnull__(1, 2))); 
# 357
extern int srandom_r(unsigned __seed, random_data * __buf) throw()
# 358
 __attribute((__nonnull__(2))); 
# 360
extern int initstate_r(unsigned __seed, char *__restrict__ __statebuf, size_t __statelen, random_data *__restrict__ __buf) throw()
# 363
 __attribute((__nonnull__(2, 4))); 
# 365
extern int setstate_r(char *__restrict__ __statebuf, random_data *__restrict__ __buf) throw()
# 367
 __attribute((__nonnull__(1, 2))); 
# 374
extern int rand() throw(); 
# 376
extern void srand(unsigned __seed) throw(); 
# 381
extern int rand_r(unsigned * __seed) throw(); 
# 389
extern double drand48() throw(); 
# 390
extern double erand48(unsigned short  __xsubi[3]) throw() __attribute((__nonnull__(1))); 
# 393
extern long lrand48() throw(); 
# 394
extern long nrand48(unsigned short  __xsubi[3]) throw()
# 395
 __attribute((__nonnull__(1))); 
# 398
extern long mrand48() throw(); 
# 399
extern long jrand48(unsigned short  __xsubi[3]) throw()
# 400
 __attribute((__nonnull__(1))); 
# 403
extern void srand48(long __seedval) throw(); 
# 404
extern unsigned short *seed48(unsigned short  __seed16v[3]) throw()
# 405
 __attribute((__nonnull__(1))); 
# 406
extern void lcong48(unsigned short  __param[7]) throw() __attribute((__nonnull__(1))); 
# 412
struct drand48_data { 
# 414
unsigned short __x[3]; 
# 415
unsigned short __old_x[3]; 
# 416
unsigned short __c; 
# 417
unsigned short __init; 
# 418
__extension__ unsigned long long __a; 
# 420
}; 
# 423
extern int drand48_r(drand48_data *__restrict__ __buffer, double *__restrict__ __result) throw()
# 424
 __attribute((__nonnull__(1, 2))); 
# 425
extern int erand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, double *__restrict__ __result) throw()
# 427
 __attribute((__nonnull__(1, 2))); 
# 430
extern int lrand48_r(drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 432
 __attribute((__nonnull__(1, 2))); 
# 433
extern int nrand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 436
 __attribute((__nonnull__(1, 2))); 
# 439
extern int mrand48_r(drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 441
 __attribute((__nonnull__(1, 2))); 
# 442
extern int jrand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 445
 __attribute((__nonnull__(1, 2))); 
# 448
extern int srand48_r(long __seedval, drand48_data * __buffer) throw()
# 449
 __attribute((__nonnull__(2))); 
# 451
extern int seed48_r(unsigned short  __seed16v[3], drand48_data * __buffer) throw()
# 452
 __attribute((__nonnull__(1, 2))); 
# 454
extern int lcong48_r(unsigned short  __param[7], drand48_data * __buffer) throw()
# 456
 __attribute((__nonnull__(1, 2))); 
# 466
extern void *malloc(size_t __size) throw() __attribute((__malloc__)); 
# 468
extern void *calloc(size_t __nmemb, size_t __size) throw()
# 469
 __attribute((__malloc__)); 
# 480
extern void *realloc(void * __ptr, size_t __size) throw()
# 481
 __attribute((__warn_unused_result__)); 
# 483
extern void free(void * __ptr) throw(); 
# 488
extern void cfree(void * __ptr) throw(); 
# 26 "/usr/include/alloca.h" 3
extern "C" {
# 32
extern void *alloca(size_t __size) throw(); 
# 38
}
# 498 "/usr/include/stdlib.h" 3
extern void *valloc(size_t __size) throw() __attribute((__malloc__)); 
# 503
extern int posix_memalign(void ** __memptr, size_t __alignment, size_t __size) throw()
# 504
 __attribute((__nonnull__(1))); 
# 509
extern void *aligned_alloc(size_t __alignment, size_t __size) throw()
# 510
 __attribute((__malloc__)) __attribute((__alloc_size__(2))); 
# 515
extern void abort() throw() __attribute((__noreturn__)); 
# 519
extern int atexit(void (* __func)(void)) throw() __attribute((__nonnull__(1))); 
# 524
extern "C++" int at_quick_exit(void (* __func)(void)) throw() __asm__("at_quick_exit")
# 525
 __attribute((__nonnull__(1))); 
# 535
extern int on_exit(void (* __func)(int __status, void * __arg), void * __arg) throw()
# 536
 __attribute((__nonnull__(1))); 
# 543
extern void exit(int __status) throw() __attribute((__noreturn__)); 
# 549
extern void quick_exit(int __status) throw() __attribute((__noreturn__)); 
# 557
extern void _Exit(int __status) throw() __attribute((__noreturn__)); 
# 564
extern char *getenv(const char * __name) throw() __attribute((__nonnull__(1))); 
# 570
extern char *secure_getenv(const char * __name) throw()
# 571
 __attribute((__nonnull__(1))); 
# 578
extern int putenv(char * __string) throw() __attribute((__nonnull__(1))); 
# 584
extern int setenv(const char * __name, const char * __value, int __replace) throw()
# 585
 __attribute((__nonnull__(2))); 
# 588
extern int unsetenv(const char * __name) throw() __attribute((__nonnull__(1))); 
# 595
extern int clearenv() throw(); 
# 606 "/usr/include/stdlib.h" 3
extern char *mktemp(char * __template) throw() __attribute((__nonnull__(1))); 
# 619 "/usr/include/stdlib.h" 3
extern int mkstemp(char * __template) __attribute((__nonnull__(1))); 
# 629 "/usr/include/stdlib.h" 3
extern int mkstemp64(char * __template) __attribute((__nonnull__(1))); 
# 641 "/usr/include/stdlib.h" 3
extern int mkstemps(char * __template, int __suffixlen) __attribute((__nonnull__(1))); 
# 651 "/usr/include/stdlib.h" 3
extern int mkstemps64(char * __template, int __suffixlen)
# 652
 __attribute((__nonnull__(1))); 
# 662 "/usr/include/stdlib.h" 3
extern char *mkdtemp(char * __template) throw() __attribute((__nonnull__(1))); 
# 673 "/usr/include/stdlib.h" 3
extern int mkostemp(char * __template, int __flags) __attribute((__nonnull__(1))); 
# 683 "/usr/include/stdlib.h" 3
extern int mkostemp64(char * __template, int __flags) __attribute((__nonnull__(1))); 
# 693 "/usr/include/stdlib.h" 3
extern int mkostemps(char * __template, int __suffixlen, int __flags)
# 694
 __attribute((__nonnull__(1))); 
# 705 "/usr/include/stdlib.h" 3
extern int mkostemps64(char * __template, int __suffixlen, int __flags)
# 706
 __attribute((__nonnull__(1))); 
# 716
extern int system(const char * __command); 
# 723
extern char *canonicalize_file_name(const char * __name) throw()
# 724
 __attribute((__nonnull__(1))); 
# 733 "/usr/include/stdlib.h" 3
extern char *realpath(const char *__restrict__ __name, char *__restrict__ __resolved) throw(); 
# 741
typedef int (*__compar_fn_t)(const void *, const void *); 
# 744
typedef __compar_fn_t comparison_fn_t; 
# 748
typedef int (*__compar_d_fn_t)(const void *, const void *, void *); 
# 754
extern void *bsearch(const void * __key, const void * __base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
# 756
 __attribute((__nonnull__(1, 2, 5))); 
# 764
extern void qsort(void * __base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
# 765
 __attribute((__nonnull__(1, 4))); 
# 767
extern void qsort_r(void * __base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void * __arg)
# 769
 __attribute((__nonnull__(1, 4))); 
# 774
extern int abs(int __x) throw() __attribute((const)); 
# 775
extern long labs(long __x) throw() __attribute((const)); 
# 779
__extension__ extern long long llabs(long long __x) throw()
# 780
 __attribute((const)); 
# 788
extern div_t div(int __numer, int __denom) throw()
# 789
 __attribute((const)); 
# 790
extern ldiv_t ldiv(long __numer, long __denom) throw()
# 791
 __attribute((const)); 
# 796
__extension__ extern lldiv_t lldiv(long long __numer, long long __denom) throw()
# 798
 __attribute((const)); 
# 811 "/usr/include/stdlib.h" 3
extern char *ecvt(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 812
 __attribute((__nonnull__(3, 4))); 
# 817
extern char *fcvt(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 818
 __attribute((__nonnull__(3, 4))); 
# 823
extern char *gcvt(double __value, int __ndigit, char * __buf) throw()
# 824
 __attribute((__nonnull__(3))); 
# 829
extern char *qecvt(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 831
 __attribute((__nonnull__(3, 4))); 
# 832
extern char *qfcvt(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 834
 __attribute((__nonnull__(3, 4))); 
# 835
extern char *qgcvt(long double __value, int __ndigit, char * __buf) throw()
# 836
 __attribute((__nonnull__(3))); 
# 841
extern int ecvt_r(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 843
 __attribute((__nonnull__(3, 4, 5))); 
# 844
extern int fcvt_r(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 846
 __attribute((__nonnull__(3, 4, 5))); 
# 848
extern int qecvt_r(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 851
 __attribute((__nonnull__(3, 4, 5))); 
# 852
extern int qfcvt_r(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 855
 __attribute((__nonnull__(3, 4, 5))); 
# 862
extern int mblen(const char * __s, size_t __n) throw(); 
# 865
extern int mbtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s, size_t __n) throw(); 
# 869
extern int wctomb(char * __s, wchar_t __wchar) throw(); 
# 873
extern size_t mbstowcs(wchar_t *__restrict__ __pwcs, const char *__restrict__ __s, size_t __n) throw(); 
# 876
extern size_t wcstombs(char *__restrict__ __s, const wchar_t *__restrict__ __pwcs, size_t __n) throw(); 
# 887
extern int rpmatch(const char * __response) throw() __attribute((__nonnull__(1))); 
# 898 "/usr/include/stdlib.h" 3
extern int getsubopt(char **__restrict__ __optionp, char *const *__restrict__ __tokens, char **__restrict__ __valuep) throw()
# 901
 __attribute((__nonnull__(1, 2, 3))); 
# 907
extern void setkey(const char * __key) throw() __attribute((__nonnull__(1))); 
# 915
extern int posix_openpt(int __oflag); 
# 923
extern int grantpt(int __fd) throw(); 
# 927
extern int unlockpt(int __fd) throw(); 
# 932
extern char *ptsname(int __fd) throw(); 
# 939
extern int ptsname_r(int __fd, char * __buf, size_t __buflen) throw()
# 940
 __attribute((__nonnull__(2))); 
# 943
extern int getpt(); 
# 950
extern int getloadavg(double  __loadavg[], int __nelem) throw()
# 951
 __attribute((__nonnull__(1))); 
# 967 "/usr/include/stdlib.h" 3
}
# 194 "/usr/include/aarch64-linux-gnu/c++/5/bits/c++config.h" 3
namespace std { 
# 196
typedef unsigned long size_t; 
# 197
typedef long ptrdiff_t; 
# 200
typedef __decltype((nullptr)) nullptr_t; 
# 202
}
# 216 "/usr/include/aarch64-linux-gnu/c++/5/bits/c++config.h" 3
namespace std { 
# 218
inline namespace __cxx11 __attribute((__abi_tag__("cxx11"))) { }
# 219
}
# 220
namespace __gnu_cxx { 
# 222
inline namespace __cxx11 __attribute((__abi_tag__("cxx11"))) { }
# 223
}
# 68 "/usr/include/c++/5/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 72
template< class _Iterator, class _Container> class __normal_iterator; 
# 76
}
# 78
namespace std __attribute((__visibility__("default"))) { 
# 82
struct __true_type { }; 
# 83
struct __false_type { }; 
# 85
template< bool > 
# 86
struct __truth_type { 
# 87
typedef __false_type __type; }; 
# 90
template<> struct __truth_type< true>  { 
# 91
typedef __true_type __type; }; 
# 95
template< class _Sp, class _Tp> 
# 96
struct __traitor { 
# 98
enum { __value = ((bool)_Sp::__value) || ((bool)_Tp::__value)}; 
# 99
typedef typename __truth_type< __value> ::__type __type; 
# 100
}; 
# 103
template< class , class > 
# 104
struct __are_same { 
# 106
enum { __value}; 
# 107
typedef __false_type __type; 
# 108
}; 
# 110
template< class _Tp> 
# 111
struct __are_same< _Tp, _Tp>  { 
# 113
enum { __value = 1}; 
# 114
typedef __true_type __type; 
# 115
}; 
# 118
template< class _Tp> 
# 119
struct __is_void { 
# 121
enum { __value}; 
# 122
typedef __false_type __type; 
# 123
}; 
# 126
template<> struct __is_void< void>  { 
# 128
enum { __value = 1}; 
# 129
typedef __true_type __type; 
# 130
}; 
# 135
template< class _Tp> 
# 136
struct __is_integer { 
# 138
enum { __value}; 
# 139
typedef __false_type __type; 
# 140
}; 
# 147
template<> struct __is_integer< bool>  { 
# 149
enum { __value = 1}; 
# 150
typedef __true_type __type; 
# 151
}; 
# 154
template<> struct __is_integer< char>  { 
# 156
enum { __value = 1}; 
# 157
typedef __true_type __type; 
# 158
}; 
# 161
template<> struct __is_integer< signed char>  { 
# 163
enum { __value = 1}; 
# 164
typedef __true_type __type; 
# 165
}; 
# 168
template<> struct __is_integer< unsigned char>  { 
# 170
enum { __value = 1}; 
# 171
typedef __true_type __type; 
# 172
}; 
# 176
template<> struct __is_integer< wchar_t>  { 
# 178
enum { __value = 1}; 
# 179
typedef __true_type __type; 
# 180
}; 
# 185
template<> struct __is_integer< char16_t>  { 
# 187
enum { __value = 1}; 
# 188
typedef __true_type __type; 
# 189
}; 
# 192
template<> struct __is_integer< char32_t>  { 
# 194
enum { __value = 1}; 
# 195
typedef __true_type __type; 
# 196
}; 
# 200
template<> struct __is_integer< short>  { 
# 202
enum { __value = 1}; 
# 203
typedef __true_type __type; 
# 204
}; 
# 207
template<> struct __is_integer< unsigned short>  { 
# 209
enum { __value = 1}; 
# 210
typedef __true_type __type; 
# 211
}; 
# 214
template<> struct __is_integer< int>  { 
# 216
enum { __value = 1}; 
# 217
typedef __true_type __type; 
# 218
}; 
# 221
template<> struct __is_integer< unsigned>  { 
# 223
enum { __value = 1}; 
# 224
typedef __true_type __type; 
# 225
}; 
# 228
template<> struct __is_integer< long>  { 
# 230
enum { __value = 1}; 
# 231
typedef __true_type __type; 
# 232
}; 
# 235
template<> struct __is_integer< unsigned long>  { 
# 237
enum { __value = 1}; 
# 238
typedef __true_type __type; 
# 239
}; 
# 242
template<> struct __is_integer< long long>  { 
# 244
enum { __value = 1}; 
# 245
typedef __true_type __type; 
# 246
}; 
# 249
template<> struct __is_integer< unsigned long long>  { 
# 251
enum { __value = 1}; 
# 252
typedef __true_type __type; 
# 253
}; 
# 287 "/usr/include/c++/5/bits/cpp_type_traits.h" 3
template< class _Tp> 
# 288
struct __is_floating { 
# 290
enum { __value}; 
# 291
typedef __false_type __type; 
# 292
}; 
# 296
template<> struct __is_floating< float>  { 
# 298
enum { __value = 1}; 
# 299
typedef __true_type __type; 
# 300
}; 
# 303
template<> struct __is_floating< double>  { 
# 305
enum { __value = 1}; 
# 306
typedef __true_type __type; 
# 307
}; 
# 310
template<> struct __is_floating< long double>  { 
# 312
enum { __value = 1}; 
# 313
typedef __true_type __type; 
# 314
}; 
# 319
template< class _Tp> 
# 320
struct __is_pointer { 
# 322
enum { __value}; 
# 323
typedef __false_type __type; 
# 324
}; 
# 326
template< class _Tp> 
# 327
struct __is_pointer< _Tp *>  { 
# 329
enum { __value = 1}; 
# 330
typedef __true_type __type; 
# 331
}; 
# 336
template< class _Tp> 
# 337
struct __is_normal_iterator { 
# 339
enum { __value}; 
# 340
typedef __false_type __type; 
# 341
}; 
# 343
template< class _Iterator, class _Container> 
# 344
struct __is_normal_iterator< __gnu_cxx::__normal_iterator< _Iterator, _Container> >  { 
# 347
enum { __value = 1}; 
# 348
typedef __true_type __type; 
# 349
}; 
# 354
template< class _Tp> 
# 355
struct __is_arithmetic : public __traitor< __is_integer< _Tp> , __is_floating< _Tp> >  { 
# 357
}; 
# 362
template< class _Tp> 
# 363
struct __is_scalar : public __traitor< __is_arithmetic< _Tp> , __is_pointer< _Tp> >  { 
# 365
}; 
# 370
template< class _Tp> 
# 371
struct __is_char { 
# 373
enum { __value}; 
# 374
typedef __false_type __type; 
# 375
}; 
# 378
template<> struct __is_char< char>  { 
# 380
enum { __value = 1}; 
# 381
typedef __true_type __type; 
# 382
}; 
# 386
template<> struct __is_char< wchar_t>  { 
# 388
enum { __value = 1}; 
# 389
typedef __true_type __type; 
# 390
}; 
# 393
template< class _Tp> 
# 394
struct __is_byte { 
# 396
enum { __value}; 
# 397
typedef __false_type __type; 
# 398
}; 
# 401
template<> struct __is_byte< char>  { 
# 403
enum { __value = 1}; 
# 404
typedef __true_type __type; 
# 405
}; 
# 408
template<> struct __is_byte< signed char>  { 
# 410
enum { __value = 1}; 
# 411
typedef __true_type __type; 
# 412
}; 
# 415
template<> struct __is_byte< unsigned char>  { 
# 417
enum { __value = 1}; 
# 418
typedef __true_type __type; 
# 419
}; 
# 424
template< class _Tp> 
# 425
struct __is_move_iterator { 
# 427
enum { __value}; 
# 428
typedef __false_type __type; 
# 429
}; 
# 432
template< class _Iterator> class move_iterator; 
# 435
template< class _Iterator> 
# 436
struct __is_move_iterator< move_iterator< _Iterator> >  { 
# 438
enum { __value = 1}; 
# 439
typedef __true_type __type; 
# 440
}; 
# 444
}
# 37 "/usr/include/c++/5/ext/type_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 42
template< bool , class > 
# 43
struct __enable_if { 
# 44
}; 
# 46
template< class _Tp> 
# 47
struct __enable_if< true, _Tp>  { 
# 48
typedef _Tp __type; }; 
# 52
template< bool _Cond, class _Iftrue, class _Iffalse> 
# 53
struct __conditional_type { 
# 54
typedef _Iftrue __type; }; 
# 56
template< class _Iftrue, class _Iffalse> 
# 57
struct __conditional_type< false, _Iftrue, _Iffalse>  { 
# 58
typedef _Iffalse __type; }; 
# 62
template< class _Tp> 
# 63
struct __add_unsigned { 
# 66
private: typedef __enable_if< std::__is_integer< _Tp> ::__value, _Tp>  __if_type; 
# 69
public: typedef typename __enable_if< std::__is_integer< _Tp> ::__value, _Tp> ::__type __type; 
# 70
}; 
# 73
template<> struct __add_unsigned< char>  { 
# 74
typedef unsigned char __type; }; 
# 77
template<> struct __add_unsigned< signed char>  { 
# 78
typedef unsigned char __type; }; 
# 81
template<> struct __add_unsigned< short>  { 
# 82
typedef unsigned short __type; }; 
# 85
template<> struct __add_unsigned< int>  { 
# 86
typedef unsigned __type; }; 
# 89
template<> struct __add_unsigned< long>  { 
# 90
typedef unsigned long __type; }; 
# 93
template<> struct __add_unsigned< long long>  { 
# 94
typedef unsigned long long __type; }; 
# 98
template<> struct __add_unsigned< bool> ; 
# 101
template<> struct __add_unsigned< wchar_t> ; 
# 105
template< class _Tp> 
# 106
struct __remove_unsigned { 
# 109
private: typedef __enable_if< std::__is_integer< _Tp> ::__value, _Tp>  __if_type; 
# 112
public: typedef typename __enable_if< std::__is_integer< _Tp> ::__value, _Tp> ::__type __type; 
# 113
}; 
# 116
template<> struct __remove_unsigned< char>  { 
# 117
typedef signed char __type; }; 
# 120
template<> struct __remove_unsigned< unsigned char>  { 
# 121
typedef signed char __type; }; 
# 124
template<> struct __remove_unsigned< unsigned short>  { 
# 125
typedef short __type; }; 
# 128
template<> struct __remove_unsigned< unsigned>  { 
# 129
typedef int __type; }; 
# 132
template<> struct __remove_unsigned< unsigned long>  { 
# 133
typedef long __type; }; 
# 136
template<> struct __remove_unsigned< unsigned long long>  { 
# 137
typedef long long __type; }; 
# 141
template<> struct __remove_unsigned< bool> ; 
# 144
template<> struct __remove_unsigned< wchar_t> ; 
# 148
template< class _Type> inline bool 
# 150
__is_null_pointer(_Type *__ptr) 
# 151
{ return __ptr == 0; } 
# 153
template< class _Type> inline bool 
# 155
__is_null_pointer(_Type) 
# 156
{ return false; } 
# 160
inline bool __is_null_pointer(std::nullptr_t) 
# 161
{ return true; } 
# 165
template< class _Tp, bool  = std::__is_integer< _Tp> ::__value> 
# 166
struct __promote { 
# 167
typedef double __type; }; 
# 172
template< class _Tp> 
# 173
struct __promote< _Tp, false>  { 
# 174
}; 
# 177
template<> struct __promote< long double>  { 
# 178
typedef long double __type; }; 
# 181
template<> struct __promote< double>  { 
# 182
typedef double __type; }; 
# 185
template<> struct __promote< float>  { 
# 186
typedef float __type; }; 
# 188
template< class _Tp, class _Up, class 
# 189
_Tp2 = typename __promote< _Tp> ::__type, class 
# 190
_Up2 = typename __promote< _Up> ::__type> 
# 191
struct __promote_2 { 
# 193
typedef __typeof__(_Tp2() + _Up2()) __type; 
# 194
}; 
# 196
template< class _Tp, class _Up, class _Vp, class 
# 197
_Tp2 = typename __promote< _Tp> ::__type, class 
# 198
_Up2 = typename __promote< _Up> ::__type, class 
# 199
_Vp2 = typename __promote< _Vp> ::__type> 
# 200
struct __promote_3 { 
# 202
typedef __typeof__((_Tp2() + _Up2()) + _Vp2()) __type; 
# 203
}; 
# 205
template< class _Tp, class _Up, class _Vp, class _Wp, class 
# 206
_Tp2 = typename __promote< _Tp> ::__type, class 
# 207
_Up2 = typename __promote< _Up> ::__type, class 
# 208
_Vp2 = typename __promote< _Vp> ::__type, class 
# 209
_Wp2 = typename __promote< _Wp> ::__type> 
# 210
struct __promote_4 { 
# 212
typedef __typeof__(((_Tp2() + _Up2()) + _Vp2()) + _Wp2()) __type; 
# 213
}; 
# 216
}
# 75 "/usr/include/c++/5/cmath" 3
namespace std __attribute((__visibility__("default"))) { 
# 81
constexpr double abs(double __x) 
# 82
{ return __builtin_fabs(__x); } 
# 87
constexpr float abs(float __x) 
# 88
{ return __builtin_fabsf(__x); } 
# 91
constexpr long double abs(long double __x) 
# 92
{ return __builtin_fabsl(__x); } 
# 95
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 99
abs(_Tp __x) 
# 100
{ return __builtin_fabs(__x); } 
# 102
using ::acos;
# 106
constexpr float acos(float __x) 
# 107
{ return __builtin_acosf(__x); } 
# 110
constexpr long double acos(long double __x) 
# 111
{ return __builtin_acosl(__x); } 
# 114
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 118
acos(_Tp __x) 
# 119
{ return __builtin_acos(__x); } 
# 121
using ::asin;
# 125
constexpr float asin(float __x) 
# 126
{ return __builtin_asinf(__x); } 
# 129
constexpr long double asin(long double __x) 
# 130
{ return __builtin_asinl(__x); } 
# 133
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 137
asin(_Tp __x) 
# 138
{ return __builtin_asin(__x); } 
# 140
using ::atan;
# 144
constexpr float atan(float __x) 
# 145
{ return __builtin_atanf(__x); } 
# 148
constexpr long double atan(long double __x) 
# 149
{ return __builtin_atanl(__x); } 
# 152
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 156
atan(_Tp __x) 
# 157
{ return __builtin_atan(__x); } 
# 159
using ::atan2;
# 163
constexpr float atan2(float __y, float __x) 
# 164
{ return __builtin_atan2f(__y, __x); } 
# 167
constexpr long double atan2(long double __y, long double __x) 
# 168
{ return __builtin_atan2l(__y, __x); } 
# 171
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 174
atan2(_Tp __y, _Up __x) 
# 175
{ 
# 176
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 177
return atan2((__type)__y, (__type)__x); 
# 178
} 
# 180
using ::ceil;
# 184
constexpr float ceil(float __x) 
# 185
{ return __builtin_ceilf(__x); } 
# 188
constexpr long double ceil(long double __x) 
# 189
{ return __builtin_ceill(__x); } 
# 192
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 196
ceil(_Tp __x) 
# 197
{ return __builtin_ceil(__x); } 
# 199
using ::cos;
# 203
constexpr float cos(float __x) 
# 204
{ return __builtin_cosf(__x); } 
# 207
constexpr long double cos(long double __x) 
# 208
{ return __builtin_cosl(__x); } 
# 211
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 215
cos(_Tp __x) 
# 216
{ return __builtin_cos(__x); } 
# 218
using ::cosh;
# 222
constexpr float cosh(float __x) 
# 223
{ return __builtin_coshf(__x); } 
# 226
constexpr long double cosh(long double __x) 
# 227
{ return __builtin_coshl(__x); } 
# 230
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 234
cosh(_Tp __x) 
# 235
{ return __builtin_cosh(__x); } 
# 237
using ::exp;
# 241
constexpr float exp(float __x) 
# 242
{ return __builtin_expf(__x); } 
# 245
constexpr long double exp(long double __x) 
# 246
{ return __builtin_expl(__x); } 
# 249
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 253
exp(_Tp __x) 
# 254
{ return __builtin_exp(__x); } 
# 256
using ::fabs;
# 260
constexpr float fabs(float __x) 
# 261
{ return __builtin_fabsf(__x); } 
# 264
constexpr long double fabs(long double __x) 
# 265
{ return __builtin_fabsl(__x); } 
# 268
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 272
fabs(_Tp __x) 
# 273
{ return __builtin_fabs(__x); } 
# 275
using ::floor;
# 279
constexpr float floor(float __x) 
# 280
{ return __builtin_floorf(__x); } 
# 283
constexpr long double floor(long double __x) 
# 284
{ return __builtin_floorl(__x); } 
# 287
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 291
floor(_Tp __x) 
# 292
{ return __builtin_floor(__x); } 
# 294
using ::fmod;
# 298
constexpr float fmod(float __x, float __y) 
# 299
{ return __builtin_fmodf(__x, __y); } 
# 302
constexpr long double fmod(long double __x, long double __y) 
# 303
{ return __builtin_fmodl(__x, __y); } 
# 306
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 309
fmod(_Tp __x, _Up __y) 
# 310
{ 
# 311
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 312
return fmod((__type)__x, (__type)__y); 
# 313
} 
# 315
using ::frexp;
# 319
inline float frexp(float __x, int *__exp) 
# 320
{ return __builtin_frexpf(__x, __exp); } 
# 323
inline long double frexp(long double __x, int *__exp) 
# 324
{ return __builtin_frexpl(__x, __exp); } 
# 327
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 331
frexp(_Tp __x, int *__exp) 
# 332
{ return __builtin_frexp(__x, __exp); } 
# 334
using ::ldexp;
# 338
constexpr float ldexp(float __x, int __exp) 
# 339
{ return __builtin_ldexpf(__x, __exp); } 
# 342
constexpr long double ldexp(long double __x, int __exp) 
# 343
{ return __builtin_ldexpl(__x, __exp); } 
# 346
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 350
ldexp(_Tp __x, int __exp) 
# 351
{ return __builtin_ldexp(__x, __exp); } 
# 353
using ::log;
# 357
constexpr float log(float __x) 
# 358
{ return __builtin_logf(__x); } 
# 361
constexpr long double log(long double __x) 
# 362
{ return __builtin_logl(__x); } 
# 365
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 369
log(_Tp __x) 
# 370
{ return __builtin_log(__x); } 
# 372
using ::log10;
# 376
constexpr float log10(float __x) 
# 377
{ return __builtin_log10f(__x); } 
# 380
constexpr long double log10(long double __x) 
# 381
{ return __builtin_log10l(__x); } 
# 384
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 388
log10(_Tp __x) 
# 389
{ return __builtin_log10(__x); } 
# 391
using ::modf;
# 395
inline float modf(float __x, float *__iptr) 
# 396
{ return __builtin_modff(__x, __iptr); } 
# 399
inline long double modf(long double __x, long double *__iptr) 
# 400
{ return __builtin_modfl(__x, __iptr); } 
# 403
using ::pow;
# 407
constexpr float pow(float __x, float __y) 
# 408
{ return __builtin_powf(__x, __y); } 
# 411
constexpr long double pow(long double __x, long double __y) 
# 412
{ return __builtin_powl(__x, __y); } 
# 431 "/usr/include/c++/5/cmath" 3
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 434
pow(_Tp __x, _Up __y) 
# 435
{ 
# 436
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 437
return pow((__type)__x, (__type)__y); 
# 438
} 
# 440
using ::sin;
# 444
constexpr float sin(float __x) 
# 445
{ return __builtin_sinf(__x); } 
# 448
constexpr long double sin(long double __x) 
# 449
{ return __builtin_sinl(__x); } 
# 452
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 456
sin(_Tp __x) 
# 457
{ return __builtin_sin(__x); } 
# 459
using ::sinh;
# 463
constexpr float sinh(float __x) 
# 464
{ return __builtin_sinhf(__x); } 
# 467
constexpr long double sinh(long double __x) 
# 468
{ return __builtin_sinhl(__x); } 
# 471
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 475
sinh(_Tp __x) 
# 476
{ return __builtin_sinh(__x); } 
# 478
using ::sqrt;
# 482
constexpr float sqrt(float __x) 
# 483
{ return __builtin_sqrtf(__x); } 
# 486
constexpr long double sqrt(long double __x) 
# 487
{ return __builtin_sqrtl(__x); } 
# 490
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 494
sqrt(_Tp __x) 
# 495
{ return __builtin_sqrt(__x); } 
# 497
using ::tan;
# 501
constexpr float tan(float __x) 
# 502
{ return __builtin_tanf(__x); } 
# 505
constexpr long double tan(long double __x) 
# 506
{ return __builtin_tanl(__x); } 
# 509
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 513
tan(_Tp __x) 
# 514
{ return __builtin_tan(__x); } 
# 516
using ::tanh;
# 520
constexpr float tanh(float __x) 
# 521
{ return __builtin_tanhf(__x); } 
# 524
constexpr long double tanh(long double __x) 
# 525
{ return __builtin_tanhl(__x); } 
# 528
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 532
tanh(_Tp __x) 
# 533
{ return __builtin_tanh(__x); } 
# 536
}
# 555 "/usr/include/c++/5/cmath" 3
namespace std __attribute((__visibility__("default"))) { 
# 563
constexpr int fpclassify(float __x) 
# 564
{ return __builtin_fpclassify(0, 1, 4, 3, 2, __x); 
# 565
} 
# 568
constexpr int fpclassify(double __x) 
# 569
{ return __builtin_fpclassify(0, 1, 4, 3, 2, __x); 
# 570
} 
# 573
constexpr int fpclassify(long double __x) 
# 574
{ return __builtin_fpclassify(0, 1, 4, 3, 2, __x); 
# 575
} 
# 578
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, int> ::__type 
# 581
fpclassify(_Tp __x) 
# 582
{ return (__x != 0) ? 4 : 2; } 
# 586
constexpr bool isfinite(float __x) 
# 587
{ return __builtin_isfinite(__x); } 
# 590
constexpr bool isfinite(double __x) 
# 591
{ return __builtin_isfinite(__x); } 
# 594
constexpr bool isfinite(long double __x) 
# 595
{ return __builtin_isfinite(__x); } 
# 598
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, bool> ::__type 
# 601
isfinite(_Tp __x) 
# 602
{ return true; } 
# 606
constexpr bool isinf(float __x) 
# 607
{ return __builtin_isinf(__x); } 
# 610
constexpr bool isinf(double __x) 
# 611
{ return __builtin_isinf(__x); } 
# 614
constexpr bool isinf(long double __x) 
# 615
{ return __builtin_isinf(__x); } 
# 618
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, bool> ::__type 
# 621
isinf(_Tp __x) 
# 622
{ return false; } 
# 626
constexpr bool isnan(float __x) 
# 627
{ return __builtin_isnan(__x); } 
# 630
constexpr bool isnan(double __x) 
# 631
{ return __builtin_isnan(__x); } 
# 634
constexpr bool isnan(long double __x) 
# 635
{ return __builtin_isnan(__x); } 
# 638
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, bool> ::__type 
# 641
isnan(_Tp __x) 
# 642
{ return false; } 
# 646
constexpr bool isnormal(float __x) 
# 647
{ return __builtin_isnormal(__x); } 
# 650
constexpr bool isnormal(double __x) 
# 651
{ return __builtin_isnormal(__x); } 
# 654
constexpr bool isnormal(long double __x) 
# 655
{ return __builtin_isnormal(__x); } 
# 658
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, bool> ::__type 
# 661
isnormal(_Tp __x) 
# 662
{ return (__x != 0) ? true : false; } 
# 667
constexpr bool signbit(float __x) 
# 668
{ return __builtin_signbitf(__x); } 
# 671
constexpr bool signbit(double __x) 
# 672
{ return __builtin_signbit(__x); } 
# 675
constexpr bool signbit(long double __x) 
# 676
{ return __builtin_signbitl(__x); } 
# 679
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, bool> ::__type 
# 682
signbit(_Tp __x) 
# 683
{ return (__x < 0) ? true : false; } 
# 687
constexpr bool isgreater(float __x, float __y) 
# 688
{ return __builtin_isgreater(__x, __y); } 
# 691
constexpr bool isgreater(double __x, double __y) 
# 692
{ return __builtin_isgreater(__x, __y); } 
# 695
constexpr bool isgreater(long double __x, long double __y) 
# 696
{ return __builtin_isgreater(__x, __y); } 
# 699
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 703
isgreater(_Tp __x, _Up __y) 
# 704
{ 
# 705
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 706
return __builtin_isgreater((__type)__x, (__type)__y); 
# 707
} 
# 711
constexpr bool isgreaterequal(float __x, float __y) 
# 712
{ return __builtin_isgreaterequal(__x, __y); } 
# 715
constexpr bool isgreaterequal(double __x, double __y) 
# 716
{ return __builtin_isgreaterequal(__x, __y); } 
# 719
constexpr bool isgreaterequal(long double __x, long double __y) 
# 720
{ return __builtin_isgreaterequal(__x, __y); } 
# 723
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 727
isgreaterequal(_Tp __x, _Up __y) 
# 728
{ 
# 729
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 730
return __builtin_isgreaterequal((__type)__x, (__type)__y); 
# 731
} 
# 735
constexpr bool isless(float __x, float __y) 
# 736
{ return __builtin_isless(__x, __y); } 
# 739
constexpr bool isless(double __x, double __y) 
# 740
{ return __builtin_isless(__x, __y); } 
# 743
constexpr bool isless(long double __x, long double __y) 
# 744
{ return __builtin_isless(__x, __y); } 
# 747
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 751
isless(_Tp __x, _Up __y) 
# 752
{ 
# 753
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 754
return __builtin_isless((__type)__x, (__type)__y); 
# 755
} 
# 759
constexpr bool islessequal(float __x, float __y) 
# 760
{ return __builtin_islessequal(__x, __y); } 
# 763
constexpr bool islessequal(double __x, double __y) 
# 764
{ return __builtin_islessequal(__x, __y); } 
# 767
constexpr bool islessequal(long double __x, long double __y) 
# 768
{ return __builtin_islessequal(__x, __y); } 
# 771
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 775
islessequal(_Tp __x, _Up __y) 
# 776
{ 
# 777
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 778
return __builtin_islessequal((__type)__x, (__type)__y); 
# 779
} 
# 783
constexpr bool islessgreater(float __x, float __y) 
# 784
{ return __builtin_islessgreater(__x, __y); } 
# 787
constexpr bool islessgreater(double __x, double __y) 
# 788
{ return __builtin_islessgreater(__x, __y); } 
# 791
constexpr bool islessgreater(long double __x, long double __y) 
# 792
{ return __builtin_islessgreater(__x, __y); } 
# 795
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 799
islessgreater(_Tp __x, _Up __y) 
# 800
{ 
# 801
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 802
return __builtin_islessgreater((__type)__x, (__type)__y); 
# 803
} 
# 807
constexpr bool isunordered(float __x, float __y) 
# 808
{ return __builtin_isunordered(__x, __y); } 
# 811
constexpr bool isunordered(double __x, double __y) 
# 812
{ return __builtin_isunordered(__x, __y); } 
# 815
constexpr bool isunordered(long double __x, long double __y) 
# 816
{ return __builtin_isunordered(__x, __y); } 
# 819
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 823
isunordered(_Tp __x, _Up __y) 
# 824
{ 
# 825
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 826
return __builtin_isunordered((__type)__x, (__type)__y); 
# 827
} 
# 947 "/usr/include/c++/5/cmath" 3
}
# 1062 "/usr/include/c++/5/cmath" 3
namespace std __attribute((__visibility__("default"))) { 
# 1067
using ::double_t;
# 1068
using ::float_t;
# 1071
using ::acosh;
# 1072
using ::acoshf;
# 1073
using ::acoshl;
# 1075
using ::asinh;
# 1076
using ::asinhf;
# 1077
using ::asinhl;
# 1079
using ::atanh;
# 1080
using ::atanhf;
# 1081
using ::atanhl;
# 1083
using ::cbrt;
# 1084
using ::cbrtf;
# 1085
using ::cbrtl;
# 1087
using ::copysign;
# 1088
using ::copysignf;
# 1089
using ::copysignl;
# 1091
using ::erf;
# 1092
using ::erff;
# 1093
using ::erfl;
# 1095
using ::erfc;
# 1096
using ::erfcf;
# 1097
using ::erfcl;
# 1099
using ::exp2;
# 1100
using ::exp2f;
# 1101
using ::exp2l;
# 1103
using ::expm1;
# 1104
using ::expm1f;
# 1105
using ::expm1l;
# 1107
using ::fdim;
# 1108
using ::fdimf;
# 1109
using ::fdiml;
# 1111
using ::fma;
# 1112
using ::fmaf;
# 1113
using ::fmal;
# 1115
using ::fmax;
# 1116
using ::fmaxf;
# 1117
using ::fmaxl;
# 1119
using ::fmin;
# 1120
using ::fminf;
# 1121
using ::fminl;
# 1123
using ::hypot;
# 1124
using ::hypotf;
# 1125
using ::hypotl;
# 1127
using ::ilogb;
# 1128
using ::ilogbf;
# 1129
using ::ilogbl;
# 1131
using ::lgamma;
# 1132
using ::lgammaf;
# 1133
using ::lgammal;
# 1135
using ::llrint;
# 1136
using ::llrintf;
# 1137
using ::llrintl;
# 1139
using ::llround;
# 1140
using ::llroundf;
# 1141
using ::llroundl;
# 1143
using ::log1p;
# 1144
using ::log1pf;
# 1145
using ::log1pl;
# 1147
using ::log2;
# 1148
using ::log2f;
# 1149
using ::log2l;
# 1151
using ::logb;
# 1152
using ::logbf;
# 1153
using ::logbl;
# 1155
using ::lrint;
# 1156
using ::lrintf;
# 1157
using ::lrintl;
# 1159
using ::lround;
# 1160
using ::lroundf;
# 1161
using ::lroundl;
# 1163
using ::nan;
# 1164
using ::nanf;
# 1165
using ::nanl;
# 1167
using ::nearbyint;
# 1168
using ::nearbyintf;
# 1169
using ::nearbyintl;
# 1171
using ::nextafter;
# 1172
using ::nextafterf;
# 1173
using ::nextafterl;
# 1175
using ::nexttoward;
# 1176
using ::nexttowardf;
# 1177
using ::nexttowardl;
# 1179
using ::remainder;
# 1180
using ::remainderf;
# 1181
using ::remainderl;
# 1183
using ::remquo;
# 1184
using ::remquof;
# 1185
using ::remquol;
# 1187
using ::rint;
# 1188
using ::rintf;
# 1189
using ::rintl;
# 1191
using ::round;
# 1192
using ::roundf;
# 1193
using ::roundl;
# 1195
using ::scalbln;
# 1196
using ::scalblnf;
# 1197
using ::scalblnl;
# 1199
using ::scalbn;
# 1200
using ::scalbnf;
# 1201
using ::scalbnl;
# 1203
using ::tgamma;
# 1204
using ::tgammaf;
# 1205
using ::tgammal;
# 1207
using ::trunc;
# 1208
using ::truncf;
# 1209
using ::truncl;
# 1214
constexpr float acosh(float __x) 
# 1215
{ return __builtin_acoshf(__x); } 
# 1218
constexpr long double acosh(long double __x) 
# 1219
{ return __builtin_acoshl(__x); } 
# 1222
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1225
acosh(_Tp __x) 
# 1226
{ return __builtin_acosh(__x); } 
# 1230
constexpr float asinh(float __x) 
# 1231
{ return __builtin_asinhf(__x); } 
# 1234
constexpr long double asinh(long double __x) 
# 1235
{ return __builtin_asinhl(__x); } 
# 1238
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1241
asinh(_Tp __x) 
# 1242
{ return __builtin_asinh(__x); } 
# 1246
constexpr float atanh(float __x) 
# 1247
{ return __builtin_atanhf(__x); } 
# 1250
constexpr long double atanh(long double __x) 
# 1251
{ return __builtin_atanhl(__x); } 
# 1254
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1257
atanh(_Tp __x) 
# 1258
{ return __builtin_atanh(__x); } 
# 1262
constexpr float cbrt(float __x) 
# 1263
{ return __builtin_cbrtf(__x); } 
# 1266
constexpr long double cbrt(long double __x) 
# 1267
{ return __builtin_cbrtl(__x); } 
# 1270
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1273
cbrt(_Tp __x) 
# 1274
{ return __builtin_cbrt(__x); } 
# 1278
constexpr float copysign(float __x, float __y) 
# 1279
{ return __builtin_copysignf(__x, __y); } 
# 1282
constexpr long double copysign(long double __x, long double __y) 
# 1283
{ return __builtin_copysignl(__x, __y); } 
# 1286
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1288
copysign(_Tp __x, _Up __y) 
# 1289
{ 
# 1290
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1291
return copysign((__type)__x, (__type)__y); 
# 1292
} 
# 1296
constexpr float erf(float __x) 
# 1297
{ return __builtin_erff(__x); } 
# 1300
constexpr long double erf(long double __x) 
# 1301
{ return __builtin_erfl(__x); } 
# 1304
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1307
erf(_Tp __x) 
# 1308
{ return __builtin_erf(__x); } 
# 1312
constexpr float erfc(float __x) 
# 1313
{ return __builtin_erfcf(__x); } 
# 1316
constexpr long double erfc(long double __x) 
# 1317
{ return __builtin_erfcl(__x); } 
# 1320
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1323
erfc(_Tp __x) 
# 1324
{ return __builtin_erfc(__x); } 
# 1328
constexpr float exp2(float __x) 
# 1329
{ return __builtin_exp2f(__x); } 
# 1332
constexpr long double exp2(long double __x) 
# 1333
{ return __builtin_exp2l(__x); } 
# 1336
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1339
exp2(_Tp __x) 
# 1340
{ return __builtin_exp2(__x); } 
# 1344
constexpr float expm1(float __x) 
# 1345
{ return __builtin_expm1f(__x); } 
# 1348
constexpr long double expm1(long double __x) 
# 1349
{ return __builtin_expm1l(__x); } 
# 1352
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1355
expm1(_Tp __x) 
# 1356
{ return __builtin_expm1(__x); } 
# 1360
constexpr float fdim(float __x, float __y) 
# 1361
{ return __builtin_fdimf(__x, __y); } 
# 1364
constexpr long double fdim(long double __x, long double __y) 
# 1365
{ return __builtin_fdiml(__x, __y); } 
# 1368
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1370
fdim(_Tp __x, _Up __y) 
# 1371
{ 
# 1372
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1373
return fdim((__type)__x, (__type)__y); 
# 1374
} 
# 1378
constexpr float fma(float __x, float __y, float __z) 
# 1379
{ return __builtin_fmaf(__x, __y, __z); } 
# 1382
constexpr long double fma(long double __x, long double __y, long double __z) 
# 1383
{ return __builtin_fmal(__x, __y, __z); } 
# 1386
template< class _Tp, class _Up, class _Vp> constexpr typename __gnu_cxx::__promote_3< _Tp, _Up, _Vp> ::__type 
# 1388
fma(_Tp __x, _Up __y, _Vp __z) 
# 1389
{ 
# 1390
typedef typename __gnu_cxx::__promote_3< _Tp, _Up, _Vp> ::__type __type; 
# 1391
return fma((__type)__x, (__type)__y, (__type)__z); 
# 1392
} 
# 1396
constexpr float fmax(float __x, float __y) 
# 1397
{ return __builtin_fmaxf(__x, __y); } 
# 1400
constexpr long double fmax(long double __x, long double __y) 
# 1401
{ return __builtin_fmaxl(__x, __y); } 
# 1404
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1406
fmax(_Tp __x, _Up __y) 
# 1407
{ 
# 1408
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1409
return fmax((__type)__x, (__type)__y); 
# 1410
} 
# 1414
constexpr float fmin(float __x, float __y) 
# 1415
{ return __builtin_fminf(__x, __y); } 
# 1418
constexpr long double fmin(long double __x, long double __y) 
# 1419
{ return __builtin_fminl(__x, __y); } 
# 1422
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1424
fmin(_Tp __x, _Up __y) 
# 1425
{ 
# 1426
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1427
return fmin((__type)__x, (__type)__y); 
# 1428
} 
# 1432
constexpr float hypot(float __x, float __y) 
# 1433
{ return __builtin_hypotf(__x, __y); } 
# 1436
constexpr long double hypot(long double __x, long double __y) 
# 1437
{ return __builtin_hypotl(__x, __y); } 
# 1440
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1442
hypot(_Tp __x, _Up __y) 
# 1443
{ 
# 1444
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1445
return hypot((__type)__x, (__type)__y); 
# 1446
} 
# 1450
constexpr int ilogb(float __x) 
# 1451
{ return __builtin_ilogbf(__x); } 
# 1454
constexpr int ilogb(long double __x) 
# 1455
{ return __builtin_ilogbl(__x); } 
# 1458
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, int> ::__type 
# 1462
ilogb(_Tp __x) 
# 1463
{ return __builtin_ilogb(__x); } 
# 1467
constexpr float lgamma(float __x) 
# 1468
{ return __builtin_lgammaf(__x); } 
# 1471
constexpr long double lgamma(long double __x) 
# 1472
{ return __builtin_lgammal(__x); } 
# 1475
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1478
lgamma(_Tp __x) 
# 1479
{ return __builtin_lgamma(__x); } 
# 1483
constexpr long long llrint(float __x) 
# 1484
{ return __builtin_llrintf(__x); } 
# 1487
constexpr long long llrint(long double __x) 
# 1488
{ return __builtin_llrintl(__x); } 
# 1491
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, long long> ::__type 
# 1494
llrint(_Tp __x) 
# 1495
{ return __builtin_llrint(__x); } 
# 1499
constexpr long long llround(float __x) 
# 1500
{ return __builtin_llroundf(__x); } 
# 1503
constexpr long long llround(long double __x) 
# 1504
{ return __builtin_llroundl(__x); } 
# 1507
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, long long> ::__type 
# 1510
llround(_Tp __x) 
# 1511
{ return __builtin_llround(__x); } 
# 1515
constexpr float log1p(float __x) 
# 1516
{ return __builtin_log1pf(__x); } 
# 1519
constexpr long double log1p(long double __x) 
# 1520
{ return __builtin_log1pl(__x); } 
# 1523
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1526
log1p(_Tp __x) 
# 1527
{ return __builtin_log1p(__x); } 
# 1532
constexpr float log2(float __x) 
# 1533
{ return __builtin_log2f(__x); } 
# 1536
constexpr long double log2(long double __x) 
# 1537
{ return __builtin_log2l(__x); } 
# 1540
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1543
log2(_Tp __x) 
# 1544
{ return __builtin_log2(__x); } 
# 1548
constexpr float logb(float __x) 
# 1549
{ return __builtin_logbf(__x); } 
# 1552
constexpr long double logb(long double __x) 
# 1553
{ return __builtin_logbl(__x); } 
# 1556
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1559
logb(_Tp __x) 
# 1560
{ return __builtin_logb(__x); } 
# 1564
constexpr long lrint(float __x) 
# 1565
{ return __builtin_lrintf(__x); } 
# 1568
constexpr long lrint(long double __x) 
# 1569
{ return __builtin_lrintl(__x); } 
# 1572
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, long> ::__type 
# 1575
lrint(_Tp __x) 
# 1576
{ return __builtin_lrint(__x); } 
# 1580
constexpr long lround(float __x) 
# 1581
{ return __builtin_lroundf(__x); } 
# 1584
constexpr long lround(long double __x) 
# 1585
{ return __builtin_lroundl(__x); } 
# 1588
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, long> ::__type 
# 1591
lround(_Tp __x) 
# 1592
{ return __builtin_lround(__x); } 
# 1596
constexpr float nearbyint(float __x) 
# 1597
{ return __builtin_nearbyintf(__x); } 
# 1600
constexpr long double nearbyint(long double __x) 
# 1601
{ return __builtin_nearbyintl(__x); } 
# 1604
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1607
nearbyint(_Tp __x) 
# 1608
{ return __builtin_nearbyint(__x); } 
# 1612
constexpr float nextafter(float __x, float __y) 
# 1613
{ return __builtin_nextafterf(__x, __y); } 
# 1616
constexpr long double nextafter(long double __x, long double __y) 
# 1617
{ return __builtin_nextafterl(__x, __y); } 
# 1620
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1622
nextafter(_Tp __x, _Up __y) 
# 1623
{ 
# 1624
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1625
return nextafter((__type)__x, (__type)__y); 
# 1626
} 
# 1630
constexpr float nexttoward(float __x, long double __y) 
# 1631
{ return __builtin_nexttowardf(__x, __y); } 
# 1634
constexpr long double nexttoward(long double __x, long double __y) 
# 1635
{ return __builtin_nexttowardl(__x, __y); } 
# 1638
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1641
nexttoward(_Tp __x, long double __y) 
# 1642
{ return __builtin_nexttoward(__x, __y); } 
# 1646
constexpr float remainder(float __x, float __y) 
# 1647
{ return __builtin_remainderf(__x, __y); } 
# 1650
constexpr long double remainder(long double __x, long double __y) 
# 1651
{ return __builtin_remainderl(__x, __y); } 
# 1654
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1656
remainder(_Tp __x, _Up __y) 
# 1657
{ 
# 1658
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1659
return remainder((__type)__x, (__type)__y); 
# 1660
} 
# 1664
inline float remquo(float __x, float __y, int *__pquo) 
# 1665
{ return __builtin_remquof(__x, __y, __pquo); } 
# 1668
inline long double remquo(long double __x, long double __y, int *__pquo) 
# 1669
{ return __builtin_remquol(__x, __y, __pquo); } 
# 1672
template< class _Tp, class _Up> inline typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1674
remquo(_Tp __x, _Up __y, int *__pquo) 
# 1675
{ 
# 1676
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1677
return remquo((__type)__x, (__type)__y, __pquo); 
# 1678
} 
# 1682
constexpr float rint(float __x) 
# 1683
{ return __builtin_rintf(__x); } 
# 1686
constexpr long double rint(long double __x) 
# 1687
{ return __builtin_rintl(__x); } 
# 1690
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1693
rint(_Tp __x) 
# 1694
{ return __builtin_rint(__x); } 
# 1698
constexpr float round(float __x) 
# 1699
{ return __builtin_roundf(__x); } 
# 1702
constexpr long double round(long double __x) 
# 1703
{ return __builtin_roundl(__x); } 
# 1706
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1709
round(_Tp __x) 
# 1710
{ return __builtin_round(__x); } 
# 1714
constexpr float scalbln(float __x, long __ex) 
# 1715
{ return __builtin_scalblnf(__x, __ex); } 
# 1718
constexpr long double scalbln(long double __x, long __ex) 
# 1719
{ return __builtin_scalblnl(__x, __ex); } 
# 1722
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1725
scalbln(_Tp __x, long __ex) 
# 1726
{ return __builtin_scalbln(__x, __ex); } 
# 1730
constexpr float scalbn(float __x, int __ex) 
# 1731
{ return __builtin_scalbnf(__x, __ex); } 
# 1734
constexpr long double scalbn(long double __x, int __ex) 
# 1735
{ return __builtin_scalbnl(__x, __ex); } 
# 1738
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1741
scalbn(_Tp __x, int __ex) 
# 1742
{ return __builtin_scalbn(__x, __ex); } 
# 1746
constexpr float tgamma(float __x) 
# 1747
{ return __builtin_tgammaf(__x); } 
# 1750
constexpr long double tgamma(long double __x) 
# 1751
{ return __builtin_tgammal(__x); } 
# 1754
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1757
tgamma(_Tp __x) 
# 1758
{ return __builtin_tgamma(__x); } 
# 1762
constexpr float trunc(float __x) 
# 1763
{ return __builtin_truncf(__x); } 
# 1766
constexpr long double trunc(long double __x) 
# 1767
{ return __builtin_truncl(__x); } 
# 1770
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1773
trunc(_Tp __x) 
# 1774
{ return __builtin_trunc(__x); } 
# 1777
}
# 114 "/usr/include/c++/5/cstdlib" 3
namespace std __attribute((__visibility__("default"))) { 
# 118
using ::div_t;
# 119
using ::ldiv_t;
# 121
using ::abort;
# 122
using ::abs;
# 123
using ::atexit;
# 126
using ::at_quick_exit;
# 129
using ::atof;
# 130
using ::atoi;
# 131
using ::atol;
# 132
using ::bsearch;
# 133
using ::calloc;
# 134
using ::div;
# 135
using ::exit;
# 136
using ::free;
# 137
using ::getenv;
# 138
using ::labs;
# 139
using ::ldiv;
# 140
using ::malloc;
# 142
using ::mblen;
# 143
using ::mbstowcs;
# 144
using ::mbtowc;
# 146
using ::qsort;
# 149
using ::quick_exit;
# 152
using ::rand;
# 153
using ::realloc;
# 154
using ::srand;
# 155
using ::strtod;
# 156
using ::strtol;
# 157
using ::strtoul;
# 158
using ::system;
# 160
using ::wcstombs;
# 161
using ::wctomb;
# 166
inline long abs(long __i) { return __builtin_labs(__i); } 
# 169
inline ldiv_t div(long __i, long __j) { return ldiv(__i, __j); } 
# 174
inline long long abs(long long __x) { return __builtin_llabs(__x); } 
# 196 "/usr/include/c++/5/cstdlib" 3
}
# 209 "/usr/include/c++/5/cstdlib" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 214
using ::lldiv_t;
# 220
using ::_Exit;
# 224
using ::llabs;
# 227
inline lldiv_t div(long long __n, long long __d) 
# 228
{ lldiv_t __q; (__q.quot) = (__n / __d); (__q.rem) = (__n % __d); return __q; } 
# 230
using ::lldiv;
# 241 "/usr/include/c++/5/cstdlib" 3
using ::atoll;
# 242
using ::strtoll;
# 243
using ::strtoull;
# 245
using ::strtof;
# 246
using ::strtold;
# 249
}
# 251
namespace std { 
# 254
using __gnu_cxx::lldiv_t;
# 256
using __gnu_cxx::_Exit;
# 258
using __gnu_cxx::llabs;
# 259
using __gnu_cxx::div;
# 260
using __gnu_cxx::lldiv;
# 262
using __gnu_cxx::atoll;
# 263
using __gnu_cxx::strtof;
# 264
using __gnu_cxx::strtoll;
# 265
using __gnu_cxx::strtoull;
# 266
using __gnu_cxx::strtold;
# 267
}
# 8942 "/usr/local/cuda-9.0/include/crt/math_functions.h"
__attribute((always_inline)) inline int signbit(float x); 
# 8946
__attribute((always_inline)) inline int signbit(double x); 
# 8948
__attribute((always_inline)) inline int signbit(long double x); 
# 8950
__attribute((always_inline)) inline int isfinite(float x); 
# 8954
__attribute((always_inline)) inline int isfinite(double x); 
# 8956
__attribute((always_inline)) inline int isfinite(long double x); 
# 8958
__attribute((always_inline)) inline int isnan(float x); 
# 8962
__attribute((always_inline)) inline int isnan(double x) throw(); 
# 8964
__attribute((always_inline)) inline int isnan(long double x); 
# 8966
__attribute((always_inline)) inline int isinf(float x); 
# 8970
__attribute((always_inline)) inline int isinf(double x) throw(); 
# 8972
__attribute((always_inline)) inline int isinf(long double x); 
# 9029 "/usr/local/cuda-9.0/include/crt/math_functions.h"
namespace std { 
# 9031
template< class T> extern T __pow_helper(T, int); 
# 9032
template< class T> extern T __cmath_power(T, unsigned); 
# 9033
}
# 9035
using std::abs;
# 9036
using std::fabs;
# 9037
using std::ceil;
# 9038
using std::floor;
# 9039
using std::sqrt;
# 9041
using std::pow;
# 9043
using std::log;
# 9044
using std::log10;
# 9045
using std::fmod;
# 9046
using std::modf;
# 9047
using std::exp;
# 9048
using std::frexp;
# 9049
using std::ldexp;
# 9050
using std::asin;
# 9051
using std::sin;
# 9052
using std::sinh;
# 9053
using std::acos;
# 9054
using std::cos;
# 9055
using std::cosh;
# 9056
using std::atan;
# 9057
using std::atan2;
# 9058
using std::tan;
# 9059
using std::tanh;
# 9424 "/usr/local/cuda-9.0/include/crt/math_functions.h"
namespace std { 
# 9433 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern inline long long abs(long long); 
# 9443 "/usr/local/cuda-9.0/include/crt/math_functions.h"
extern inline long abs(long); 
# 9444
extern constexpr float abs(float); 
# 9445
extern constexpr double abs(double); 
# 9446
extern constexpr float fabs(float); 
# 9447
extern constexpr float ceil(float); 
# 9448
extern constexpr float floor(float); 
# 9449
extern constexpr float sqrt(float); 
# 9450
extern constexpr float pow(float, float); 
# 9455
template< class _Tp, class _Up> extern constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type pow(_Tp, _Up); 
# 9465
extern constexpr float log(float); 
# 9466
extern constexpr float log10(float); 
# 9467
extern constexpr float fmod(float, float); 
# 9468
extern inline float modf(float, float *); 
# 9469
extern constexpr float exp(float); 
# 9470
extern inline float frexp(float, int *); 
# 9471
extern constexpr float ldexp(float, int); 
# 9472
extern constexpr float asin(float); 
# 9473
extern constexpr float sin(float); 
# 9474
extern constexpr float sinh(float); 
# 9475
extern constexpr float acos(float); 
# 9476
extern constexpr float cos(float); 
# 9477
extern constexpr float cosh(float); 
# 9478
extern constexpr float atan(float); 
# 9479
extern constexpr float atan2(float, float); 
# 9480
extern constexpr float tan(float); 
# 9481
extern constexpr float tanh(float); 
# 9555 "/usr/local/cuda-9.0/include/crt/math_functions.h"
}
# 9698 "/usr/local/cuda-9.0/include/crt/math_functions.h"
static inline float logb(float a); 
# 9700
static inline int ilogb(float a); 
# 9702
static inline float scalbn(float a, int b); 
# 9704
static inline float scalbln(float a, long b); 
# 9706
static inline float exp2(float a); 
# 9708
static inline float expm1(float a); 
# 9710
static inline float log2(float a); 
# 9712
static inline float log1p(float a); 
# 9714
static inline float acosh(float a); 
# 9716
static inline float asinh(float a); 
# 9718
static inline float atanh(float a); 
# 9720
static inline float hypot(float a, float b); 
# 9722
static inline float norm3d(float a, float b, float c); 
# 9724
static inline float norm4d(float a, float b, float c, float d); 
# 9726
static inline float cbrt(float a); 
# 9728
static inline float erf(float a); 
# 9730
static inline float erfc(float a); 
# 9732
static inline float lgamma(float a); 
# 9734
static inline float tgamma(float a); 
# 9736
static inline float copysign(float a, float b); 
# 9738
static inline float nextafter(float a, float b); 
# 9740
static inline float remainder(float a, float b); 
# 9742
static inline float remquo(float a, float b, int * quo); 
# 9744
static inline float round(float a); 
# 9746
static inline long lround(float a); 
# 9748
static inline long long llround(float a); 
# 9750
static inline float trunc(float a); 
# 9752
static inline float rint(float a); 
# 9754
static inline long lrint(float a); 
# 9756
static inline long long llrint(float a); 
# 9758
static inline float nearbyint(float a); 
# 9760
static inline float fdim(float a, float b); 
# 9762
static inline float fma(float a, float b, float c); 
# 9764
static inline float fmax(float a, float b); 
# 9766
static inline float fmin(float a, float b); 
# 9807 "/usr/local/cuda-9.0/include/crt/math_functions.h"
static inline float exp10(float a); 
# 9809
static inline float rsqrt(float a); 
# 9811
static inline float rcbrt(float a); 
# 9813
static inline float sinpi(float a); 
# 9815
static inline float cospi(float a); 
# 9817
static inline void sincospi(float a, float * sptr, float * cptr); 
# 9819
static inline void sincos(float a, float * sptr, float * cptr); 
# 9821
static inline float j0(float a); 
# 9823
static inline float j1(float a); 
# 9825
static inline float jn(int n, float a); 
# 9827
static inline float y0(float a); 
# 9829
static inline float y1(float a); 
# 9831
static inline float yn(int n, float a); 
# 9833
static inline float cyl_bessel_i0(float a); 
# 9835
static inline float cyl_bessel_i1(float a); 
# 9837
static inline float erfinv(float a); 
# 9839
static inline float erfcinv(float a); 
# 9841
static inline float normcdfinv(float a); 
# 9843
static inline float normcdf(float a); 
# 9845
static inline float erfcx(float a); 
# 9847
static inline double copysign(double a, float b); 
# 9849
static inline double copysign(float a, double b); 
# 9851
static inline unsigned min(unsigned a, unsigned b); 
# 9853
static inline unsigned min(int a, unsigned b); 
# 9855
static inline unsigned min(unsigned a, int b); 
# 9857
static inline long min(long a, long b); 
# 9859
static inline unsigned long min(unsigned long a, unsigned long b); 
# 9861
static inline unsigned long min(long a, unsigned long b); 
# 9863
static inline unsigned long min(unsigned long a, long b); 
# 9865
static inline long long min(long long a, long long b); 
# 9867
static inline unsigned long long min(unsigned long long a, unsigned long long b); 
# 9869
static inline unsigned long long min(long long a, unsigned long long b); 
# 9871
static inline unsigned long long min(unsigned long long a, long long b); 
# 9873
static inline float min(float a, float b); 
# 9875
static inline double min(double a, double b); 
# 9877
static inline double min(float a, double b); 
# 9879
static inline double min(double a, float b); 
# 9881
static inline unsigned max(unsigned a, unsigned b); 
# 9883
static inline unsigned max(int a, unsigned b); 
# 9885
static inline unsigned max(unsigned a, int b); 
# 9887
static inline long max(long a, long b); 
# 9889
static inline unsigned long max(unsigned long a, unsigned long b); 
# 9891
static inline unsigned long max(long a, unsigned long b); 
# 9893
static inline unsigned long max(unsigned long a, long b); 
# 9895
static inline long long max(long long a, long long b); 
# 9897
static inline unsigned long long max(unsigned long long a, unsigned long long b); 
# 9899
static inline unsigned long long max(long long a, unsigned long long b); 
# 9901
static inline unsigned long long max(unsigned long long a, long long b); 
# 9903
static inline float max(float a, float b); 
# 9905
static inline double max(double a, double b); 
# 9907
static inline double max(float a, double b); 
# 9909
static inline double max(double a, float b); 
# 281 "/usr/local/cuda-9.0/include/crt/math_functions.hpp"
__attribute((always_inline)) inline int signbit(float x) { return __signbitf(x); } 
# 285
__attribute((always_inline)) inline int signbit(double x) { return __signbit(x); } 
# 287
__attribute((always_inline)) inline int signbit(long double x) { return __signbitl(x); } 
# 298 "/usr/local/cuda-9.0/include/crt/math_functions.hpp"
__attribute((always_inline)) inline int isfinite(float x) { return __finitef(x); } 
# 313 "/usr/local/cuda-9.0/include/crt/math_functions.hpp"
__attribute((always_inline)) inline int isfinite(double x) { return __finite(x); } 
# 326 "/usr/local/cuda-9.0/include/crt/math_functions.hpp"
__attribute((always_inline)) inline int isfinite(long double x) { return __finitel(x); } 
# 329
__attribute((always_inline)) inline int isnan(float x) { return __isnanf(x); } 
# 333
__attribute((always_inline)) inline int isnan(double x) throw() { return __isnan(x); } 
# 335
__attribute((always_inline)) inline int isnan(long double x) { return __isnanl(x); } 
# 337
__attribute((always_inline)) inline int isinf(float x) { return __isinff(x); } 
# 341
__attribute((always_inline)) inline int isinf(double x) throw() { return __isinf(x); } 
# 343
__attribute((always_inline)) inline int isinf(long double x) { return __isinfl(x); } 
# 549 "/usr/local/cuda-9.0/include/crt/math_functions.hpp"
static inline float logb(float a) 
# 550
{ 
# 551
return logbf(a); 
# 552
} 
# 554
static inline int ilogb(float a) 
# 555
{ 
# 556
return ilogbf(a); 
# 557
} 
# 559
static inline float scalbn(float a, int b) 
# 560
{ 
# 561
return scalbnf(a, b); 
# 562
} 
# 564
static inline float scalbln(float a, long b) 
# 565
{ 
# 566
return scalblnf(a, b); 
# 567
} 
# 569
static inline float exp2(float a) 
# 570
{ 
# 571
return exp2f(a); 
# 572
} 
# 574
static inline float expm1(float a) 
# 575
{ 
# 576
return expm1f(a); 
# 577
} 
# 579
static inline float log2(float a) 
# 580
{ 
# 581
return log2f(a); 
# 582
} 
# 584
static inline float log1p(float a) 
# 585
{ 
# 586
return log1pf(a); 
# 587
} 
# 589
static inline float acosh(float a) 
# 590
{ 
# 591
return acoshf(a); 
# 592
} 
# 594
static inline float asinh(float a) 
# 595
{ 
# 596
return asinhf(a); 
# 597
} 
# 599
static inline float atanh(float a) 
# 600
{ 
# 601
return atanhf(a); 
# 602
} 
# 604
static inline float hypot(float a, float b) 
# 605
{ 
# 606
return hypotf(a, b); 
# 607
} 
# 609
static inline float norm3d(float a, float b, float c) 
# 610
{ 
# 611
return norm3df(a, b, c); 
# 612
} 
# 614
static inline float norm4d(float a, float b, float c, float d) 
# 615
{ 
# 616
return norm4df(a, b, c, d); 
# 617
} 
# 619
static inline float cbrt(float a) 
# 620
{ 
# 621
return cbrtf(a); 
# 622
} 
# 624
static inline float erf(float a) 
# 625
{ 
# 626
return erff(a); 
# 627
} 
# 629
static inline float erfc(float a) 
# 630
{ 
# 631
return erfcf(a); 
# 632
} 
# 634
static inline float lgamma(float a) 
# 635
{ 
# 636
return lgammaf(a); 
# 637
} 
# 639
static inline float tgamma(float a) 
# 640
{ 
# 641
return tgammaf(a); 
# 642
} 
# 644
static inline float copysign(float a, float b) 
# 645
{ 
# 646
return copysignf(a, b); 
# 647
} 
# 649
static inline float nextafter(float a, float b) 
# 650
{ 
# 651
return nextafterf(a, b); 
# 652
} 
# 654
static inline float remainder(float a, float b) 
# 655
{ 
# 656
return remainderf(a, b); 
# 657
} 
# 659
static inline float remquo(float a, float b, int *quo) 
# 660
{ 
# 661
return remquof(a, b, quo); 
# 662
} 
# 664
static inline float round(float a) 
# 665
{ 
# 666
return roundf(a); 
# 667
} 
# 669
static inline long lround(float a) 
# 670
{ 
# 671
return lroundf(a); 
# 672
} 
# 674
static inline long long llround(float a) 
# 675
{ 
# 676
return llroundf(a); 
# 677
} 
# 679
static inline float trunc(float a) 
# 680
{ 
# 681
return truncf(a); 
# 682
} 
# 684
static inline float rint(float a) 
# 685
{ 
# 686
return rintf(a); 
# 687
} 
# 689
static inline long lrint(float a) 
# 690
{ 
# 691
return lrintf(a); 
# 692
} 
# 694
static inline long long llrint(float a) 
# 695
{ 
# 696
return llrintf(a); 
# 697
} 
# 699
static inline float nearbyint(float a) 
# 700
{ 
# 701
return nearbyintf(a); 
# 702
} 
# 704
static inline float fdim(float a, float b) 
# 705
{ 
# 706
return fdimf(a, b); 
# 707
} 
# 709
static inline float fma(float a, float b, float c) 
# 710
{ 
# 711
return fmaf(a, b, c); 
# 712
} 
# 714
static inline float fmax(float a, float b) 
# 715
{ 
# 716
return fmaxf(a, b); 
# 717
} 
# 719
static inline float fmin(float a, float b) 
# 720
{ 
# 721
return fminf(a, b); 
# 722
} 
# 730
static inline float exp10(float a) 
# 731
{ 
# 732
return exp10f(a); 
# 733
} 
# 735
static inline float rsqrt(float a) 
# 736
{ 
# 737
return rsqrtf(a); 
# 738
} 
# 740
static inline float rcbrt(float a) 
# 741
{ 
# 742
return rcbrtf(a); 
# 743
} 
# 745
static inline float sinpi(float a) 
# 746
{ 
# 747
return sinpif(a); 
# 748
} 
# 750
static inline float cospi(float a) 
# 751
{ 
# 752
return cospif(a); 
# 753
} 
# 755
static inline void sincospi(float a, float *sptr, float *cptr) 
# 756
{ 
# 757
sincospif(a, sptr, cptr); 
# 758
} 
# 760
static inline void sincos(float a, float *sptr, float *cptr) 
# 761
{ 
# 762
sincosf(a, sptr, cptr); 
# 763
} 
# 765
static inline float j0(float a) 
# 766
{ 
# 767
return j0f(a); 
# 768
} 
# 770
static inline float j1(float a) 
# 771
{ 
# 772
return j1f(a); 
# 773
} 
# 775
static inline float jn(int n, float a) 
# 776
{ 
# 777
return jnf(n, a); 
# 778
} 
# 780
static inline float y0(float a) 
# 781
{ 
# 782
return y0f(a); 
# 783
} 
# 785
static inline float y1(float a) 
# 786
{ 
# 787
return y1f(a); 
# 788
} 
# 790
static inline float yn(int n, float a) 
# 791
{ 
# 792
return ynf(n, a); 
# 793
} 
# 795
static inline float cyl_bessel_i0(float a) 
# 796
{ 
# 797
return cyl_bessel_i0f(a); 
# 798
} 
# 800
static inline float cyl_bessel_i1(float a) 
# 801
{ 
# 802
return cyl_bessel_i1f(a); 
# 803
} 
# 805
static inline float erfinv(float a) 
# 806
{ 
# 807
return erfinvf(a); 
# 808
} 
# 810
static inline float erfcinv(float a) 
# 811
{ 
# 812
return erfcinvf(a); 
# 813
} 
# 815
static inline float normcdfinv(float a) 
# 816
{ 
# 817
return normcdfinvf(a); 
# 818
} 
# 820
static inline float normcdf(float a) 
# 821
{ 
# 822
return normcdff(a); 
# 823
} 
# 825
static inline float erfcx(float a) 
# 826
{ 
# 827
return erfcxf(a); 
# 828
} 
# 830
static inline double copysign(double a, float b) 
# 831
{ 
# 832
return copysign(a, (double)b); 
# 833
} 
# 835
static inline double copysign(float a, double b) 
# 836
{ 
# 837
return copysign((double)a, b); 
# 838
} 
# 840
static inline unsigned min(unsigned a, unsigned b) 
# 841
{ 
# 842
return umin(a, b); 
# 843
} 
# 845
static inline unsigned min(int a, unsigned b) 
# 846
{ 
# 847
return umin((unsigned)a, b); 
# 848
} 
# 850
static inline unsigned min(unsigned a, int b) 
# 851
{ 
# 852
return umin(a, (unsigned)b); 
# 853
} 
# 855
static inline long min(long a, long b) 
# 856
{ 
# 862
if (sizeof(long) == sizeof(int)) { 
# 866
return (long)min((int)a, (int)b); 
# 867
} else { 
# 868
return (long)llmin((long long)a, (long long)b); 
# 869
}  
# 870
} 
# 872
static inline unsigned long min(unsigned long a, unsigned long b) 
# 873
{ 
# 877
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 881
return (unsigned long)umin((unsigned)a, (unsigned)b); 
# 882
} else { 
# 883
return (unsigned long)ullmin((unsigned long long)a, (unsigned long long)b); 
# 884
}  
# 885
} 
# 887
static inline unsigned long min(long a, unsigned long b) 
# 888
{ 
# 892
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 896
return (unsigned long)umin((unsigned)a, (unsigned)b); 
# 897
} else { 
# 898
return (unsigned long)ullmin((unsigned long long)a, (unsigned long long)b); 
# 899
}  
# 900
} 
# 902
static inline unsigned long min(unsigned long a, long b) 
# 903
{ 
# 907
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 911
return (unsigned long)umin((unsigned)a, (unsigned)b); 
# 912
} else { 
# 913
return (unsigned long)ullmin((unsigned long long)a, (unsigned long long)b); 
# 914
}  
# 915
} 
# 917
static inline long long min(long long a, long long b) 
# 918
{ 
# 919
return llmin(a, b); 
# 920
} 
# 922
static inline unsigned long long min(unsigned long long a, unsigned long long b) 
# 923
{ 
# 924
return ullmin(a, b); 
# 925
} 
# 927
static inline unsigned long long min(long long a, unsigned long long b) 
# 928
{ 
# 929
return ullmin((unsigned long long)a, b); 
# 930
} 
# 932
static inline unsigned long long min(unsigned long long a, long long b) 
# 933
{ 
# 934
return ullmin(a, (unsigned long long)b); 
# 935
} 
# 937
static inline float min(float a, float b) 
# 938
{ 
# 939
return fminf(a, b); 
# 940
} 
# 942
static inline double min(double a, double b) 
# 943
{ 
# 944
return fmin(a, b); 
# 945
} 
# 947
static inline double min(float a, double b) 
# 948
{ 
# 949
return fmin((double)a, b); 
# 950
} 
# 952
static inline double min(double a, float b) 
# 953
{ 
# 954
return fmin(a, (double)b); 
# 955
} 
# 957
static inline unsigned max(unsigned a, unsigned b) 
# 958
{ 
# 959
return umax(a, b); 
# 960
} 
# 962
static inline unsigned max(int a, unsigned b) 
# 963
{ 
# 964
return umax((unsigned)a, b); 
# 965
} 
# 967
static inline unsigned max(unsigned a, int b) 
# 968
{ 
# 969
return umax(a, (unsigned)b); 
# 970
} 
# 972
static inline long max(long a, long b) 
# 973
{ 
# 978
if (sizeof(long) == sizeof(int)) { 
# 982
return (long)max((int)a, (int)b); 
# 983
} else { 
# 984
return (long)llmax((long long)a, (long long)b); 
# 985
}  
# 986
} 
# 988
static inline unsigned long max(unsigned long a, unsigned long b) 
# 989
{ 
# 993
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 997
return (unsigned long)umax((unsigned)a, (unsigned)b); 
# 998
} else { 
# 999
return (unsigned long)ullmax((unsigned long long)a, (unsigned long long)b); 
# 1000
}  
# 1001
} 
# 1003
static inline unsigned long max(long a, unsigned long b) 
# 1004
{ 
# 1008
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 1012
return (unsigned long)umax((unsigned)a, (unsigned)b); 
# 1013
} else { 
# 1014
return (unsigned long)ullmax((unsigned long long)a, (unsigned long long)b); 
# 1015
}  
# 1016
} 
# 1018
static inline unsigned long max(unsigned long a, long b) 
# 1019
{ 
# 1023
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 1027
return (unsigned long)umax((unsigned)a, (unsigned)b); 
# 1028
} else { 
# 1029
return (unsigned long)ullmax((unsigned long long)a, (unsigned long long)b); 
# 1030
}  
# 1031
} 
# 1033
static inline long long max(long long a, long long b) 
# 1034
{ 
# 1035
return llmax(a, b); 
# 1036
} 
# 1038
static inline unsigned long long max(unsigned long long a, unsigned long long b) 
# 1039
{ 
# 1040
return ullmax(a, b); 
# 1041
} 
# 1043
static inline unsigned long long max(long long a, unsigned long long b) 
# 1044
{ 
# 1045
return ullmax((unsigned long long)a, b); 
# 1046
} 
# 1048
static inline unsigned long long max(unsigned long long a, long long b) 
# 1049
{ 
# 1050
return ullmax(a, (unsigned long long)b); 
# 1051
} 
# 1053
static inline float max(float a, float b) 
# 1054
{ 
# 1055
return fmaxf(a, b); 
# 1056
} 
# 1058
static inline double max(double a, double b) 
# 1059
{ 
# 1060
return fmax(a, b); 
# 1061
} 
# 1063
static inline double max(float a, double b) 
# 1064
{ 
# 1065
return fmax((double)a, b); 
# 1066
} 
# 1068
static inline double max(double a, float b) 
# 1069
{ 
# 1070
return fmax(a, (double)b); 
# 1071
} 
# 1082 "/usr/local/cuda-9.0/include/crt/math_functions.hpp"
extern "C" inline int min(int a, int b) 
# 1083
{ 
# 1084
return (a < b) ? a : b; 
# 1085
} 
# 1087
extern "C" inline unsigned umin(unsigned a, unsigned b) 
# 1088
{ 
# 1089
return (a < b) ? a : b; 
# 1090
} 
# 1092
extern "C" inline long long llmin(long long a, long long b) 
# 1093
{ 
# 1094
return (a < b) ? a : b; 
# 1095
} 
# 1097
extern "C" inline unsigned long long ullmin(unsigned long long a, unsigned long long 
# 1098
b) 
# 1099
{ 
# 1100
return (a < b) ? a : b; 
# 1101
} 
# 1103
extern "C" inline int max(int a, int b) 
# 1104
{ 
# 1105
return (a > b) ? a : b; 
# 1106
} 
# 1108
extern "C" inline unsigned umax(unsigned a, unsigned b) 
# 1109
{ 
# 1110
return (a > b) ? a : b; 
# 1111
} 
# 1113
extern "C" inline long long llmax(long long a, long long b) 
# 1114
{ 
# 1115
return (a > b) ? a : b; 
# 1116
} 
# 1118
extern "C" inline unsigned long long ullmax(unsigned long long a, unsigned long long 
# 1119
b) 
# 1120
{ 
# 1121
return (a > b) ? a : b; 
# 1122
} 
# 77 "/usr/local/cuda-9.0/include/cuda_surface_types.h"
template< class T, int dim = 1> 
# 78
struct surface : public surfaceReference { 
# 81
surface() 
# 82
{ 
# 83
(channelDesc) = cudaCreateChannelDesc< T> (); 
# 84
} 
# 86
surface(cudaChannelFormatDesc desc) 
# 87
{ 
# 88
(channelDesc) = desc; 
# 89
} 
# 91
}; 
# 93
template< int dim> 
# 94
struct surface< void, dim>  : public surfaceReference { 
# 97
surface() 
# 98
{ 
# 99
(channelDesc) = cudaCreateChannelDesc< void> (); 
# 100
} 
# 102
}; 
# 77 "/usr/local/cuda-9.0/include/cuda_texture_types.h"
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
# 78
struct texture : public textureReference { 
# 81
texture(int norm = 0, cudaTextureFilterMode 
# 82
fMode = cudaFilterModePoint, cudaTextureAddressMode 
# 83
aMode = cudaAddressModeClamp) 
# 84
{ 
# 85
(normalized) = norm; 
# 86
(filterMode) = fMode; 
# 87
((addressMode)[0]) = aMode; 
# 88
((addressMode)[1]) = aMode; 
# 89
((addressMode)[2]) = aMode; 
# 90
(channelDesc) = cudaCreateChannelDesc< T> (); 
# 91
(sRGB) = 0; 
# 92
} 
# 94
texture(int norm, cudaTextureFilterMode 
# 95
fMode, cudaTextureAddressMode 
# 96
aMode, cudaChannelFormatDesc 
# 97
desc) 
# 98
{ 
# 99
(normalized) = norm; 
# 100
(filterMode) = fMode; 
# 101
((addressMode)[0]) = aMode; 
# 102
((addressMode)[1]) = aMode; 
# 103
((addressMode)[2]) = aMode; 
# 104
(channelDesc) = desc; 
# 105
(sRGB) = 0; 
# 106
} 
# 108
}; 
# 79 "/usr/local/cuda-9.0/include/crt/device_functions.h"
extern "C" {
# 3201 "/usr/local/cuda-9.0/include/crt/device_functions.h"
}
# 3209
__attribute__((unused)) static inline int mulhi(int a, int b); 
# 3211
__attribute__((unused)) static inline unsigned mulhi(unsigned a, unsigned b); 
# 3213
__attribute__((unused)) static inline unsigned mulhi(int a, unsigned b); 
# 3215
__attribute__((unused)) static inline unsigned mulhi(unsigned a, int b); 
# 3217
__attribute__((unused)) static inline long long mul64hi(long long a, long long b); 
# 3219
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, unsigned long long b); 
# 3221
__attribute__((unused)) static inline unsigned long long mul64hi(long long a, unsigned long long b); 
# 3223
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, long long b); 
# 3225
__attribute__((unused)) static inline int float_as_int(float a); 
# 3227
__attribute__((unused)) static inline float int_as_float(int a); 
# 3229
__attribute__((unused)) static inline unsigned float_as_uint(float a); 
# 3231
__attribute__((unused)) static inline float uint_as_float(unsigned a); 
# 3233
__attribute__((unused)) static inline float saturate(float a); 
# 3235
__attribute__((unused)) static inline int mul24(int a, int b); 
# 3237
__attribute__((unused)) static inline unsigned umul24(unsigned a, unsigned b); 
# 3239
__attribute__((unused)) static inline int float2int(float a, cudaRoundMode mode = cudaRoundZero); 
# 3241
__attribute__((unused)) static inline unsigned float2uint(float a, cudaRoundMode mode = cudaRoundZero); 
# 3243
__attribute__((unused)) static inline float int2float(int a, cudaRoundMode mode = cudaRoundNearest); 
# 3245
__attribute__((unused)) static inline float uint2float(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
# 80 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline int mulhi(int a, int b) 
# 81
{int volatile ___ = 1;(void)a;(void)b;
# 83
::exit(___);}
#if 0
# 81
{ 
# 82
return __mulhi(a, b); 
# 83
} 
#endif
# 85 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned mulhi(unsigned a, unsigned b) 
# 86
{int volatile ___ = 1;(void)a;(void)b;
# 88
::exit(___);}
#if 0
# 86
{ 
# 87
return __umulhi(a, b); 
# 88
} 
#endif
# 90 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned mulhi(int a, unsigned b) 
# 91
{int volatile ___ = 1;(void)a;(void)b;
# 93
::exit(___);}
#if 0
# 91
{ 
# 92
return __umulhi((unsigned)a, b); 
# 93
} 
#endif
# 95 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned mulhi(unsigned a, int b) 
# 96
{int volatile ___ = 1;(void)a;(void)b;
# 98
::exit(___);}
#if 0
# 96
{ 
# 97
return __umulhi(a, (unsigned)b); 
# 98
} 
#endif
# 100 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline long long mul64hi(long long a, long long b) 
# 101
{int volatile ___ = 1;(void)a;(void)b;
# 103
::exit(___);}
#if 0
# 101
{ 
# 102
return __mul64hi(a, b); 
# 103
} 
#endif
# 105 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, unsigned long long b) 
# 106
{int volatile ___ = 1;(void)a;(void)b;
# 108
::exit(___);}
#if 0
# 106
{ 
# 107
return __umul64hi(a, b); 
# 108
} 
#endif
# 110 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned long long mul64hi(long long a, unsigned long long b) 
# 111
{int volatile ___ = 1;(void)a;(void)b;
# 113
::exit(___);}
#if 0
# 111
{ 
# 112
return __umul64hi((unsigned long long)a, b); 
# 113
} 
#endif
# 115 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, long long b) 
# 116
{int volatile ___ = 1;(void)a;(void)b;
# 118
::exit(___);}
#if 0
# 116
{ 
# 117
return __umul64hi(a, (unsigned long long)b); 
# 118
} 
#endif
# 120 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline int float_as_int(float a) 
# 121
{int volatile ___ = 1;(void)a;
# 123
::exit(___);}
#if 0
# 121
{ 
# 122
return __float_as_int(a); 
# 123
} 
#endif
# 125 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline float int_as_float(int a) 
# 126
{int volatile ___ = 1;(void)a;
# 128
::exit(___);}
#if 0
# 126
{ 
# 127
return __int_as_float(a); 
# 128
} 
#endif
# 130 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned float_as_uint(float a) 
# 131
{int volatile ___ = 1;(void)a;
# 133
::exit(___);}
#if 0
# 131
{ 
# 132
return __float_as_uint(a); 
# 133
} 
#endif
# 135 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline float uint_as_float(unsigned a) 
# 136
{int volatile ___ = 1;(void)a;
# 138
::exit(___);}
#if 0
# 136
{ 
# 137
return __uint_as_float(a); 
# 138
} 
#endif
# 139 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline float saturate(float a) 
# 140
{int volatile ___ = 1;(void)a;
# 142
::exit(___);}
#if 0
# 140
{ 
# 141
return __saturatef(a); 
# 142
} 
#endif
# 144 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline int mul24(int a, int b) 
# 145
{int volatile ___ = 1;(void)a;(void)b;
# 147
::exit(___);}
#if 0
# 145
{ 
# 146
return __mul24(a, b); 
# 147
} 
#endif
# 149 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned umul24(unsigned a, unsigned b) 
# 150
{int volatile ___ = 1;(void)a;(void)b;
# 152
::exit(___);}
#if 0
# 150
{ 
# 151
return __umul24(a, b); 
# 152
} 
#endif
# 154 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline int float2int(float a, cudaRoundMode mode) 
# 155
{int volatile ___ = 1;(void)a;(void)mode;
# 160
::exit(___);}
#if 0
# 155
{ 
# 156
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
# 160
} 
#endif
# 162 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned float2uint(float a, cudaRoundMode mode) 
# 163
{int volatile ___ = 1;(void)a;(void)mode;
# 168
::exit(___);}
#if 0
# 163
{ 
# 164
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
# 168
} 
#endif
# 170 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline float int2float(int a, cudaRoundMode mode) 
# 171
{int volatile ___ = 1;(void)a;(void)mode;
# 176
::exit(___);}
#if 0
# 171
{ 
# 172
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
# 176
} 
#endif
# 178 "/usr/local/cuda-9.0/include/crt/device_functions.hpp"
__attribute__((unused)) static inline float uint2float(unsigned a, cudaRoundMode mode) 
# 179
{int volatile ___ = 1;(void)a;(void)mode;
# 184
::exit(___);}
#if 0
# 179
{ 
# 180
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
# 184
} 
#endif
# 107 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicAdd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 107
{ } 
#endif
# 109 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAdd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 109
{ } 
#endif
# 111 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicSub(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 111
{ } 
#endif
# 113 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicSub(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 113
{ } 
#endif
# 115 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicExch(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 115
{ } 
#endif
# 117 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicExch(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 117
{ } 
#endif
# 119 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline float atomicExch(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 119
{ } 
#endif
# 121 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicMin(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 121
{ } 
#endif
# 123 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMin(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 123
{ } 
#endif
# 125 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicMax(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 125
{ } 
#endif
# 127 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMax(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 127
{ } 
#endif
# 129 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicInc(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 129
{ } 
#endif
# 131 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicDec(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 131
{ } 
#endif
# 133 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicAnd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 133
{ } 
#endif
# 135 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAnd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 135
{ } 
#endif
# 137 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicOr(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 137
{ } 
#endif
# 139 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicOr(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 139
{ } 
#endif
# 141 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicXor(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 141
{ } 
#endif
# 143 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicXor(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 143
{ } 
#endif
# 145 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicCAS(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 145
{ } 
#endif
# 147 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 147
{ } 
#endif
# 173 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
extern "C" {
# 182
}
# 191 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAdd(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 191
{ } 
#endif
# 193 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicExch(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 193
{ } 
#endif
# 195 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicCAS(unsigned long long *address, unsigned long long compare, unsigned long long val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 195
{ } 
#endif
# 197 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute((deprecated("__any() is deprecated in favor of __any_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning)."))) __attribute__((unused)) static inline bool any(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
# 197
{ } 
#endif
# 199 "/usr/local/cuda-9.0/include/device_atomic_functions.h"
__attribute((deprecated("__all() is deprecated in favor of __all_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning)."))) __attribute__((unused)) static inline bool all(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
# 199
{ } 
#endif
# 77 "/usr/local/cuda-9.0/include/crt/device_double_functions.h"
extern "C" {
# 1129 "/usr/local/cuda-9.0/include/crt/device_double_functions.h"
}
# 1137
__attribute__((unused)) static inline double fma(double a, double b, double c, cudaRoundMode mode); 
# 1139
__attribute__((unused)) static inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1141
__attribute__((unused)) static inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1143
__attribute__((unused)) static inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1145
__attribute__((unused)) static inline int double2int(double a, cudaRoundMode mode = cudaRoundZero); 
# 1147
__attribute__((unused)) static inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero); 
# 1149
__attribute__((unused)) static inline long long double2ll(double a, cudaRoundMode mode = cudaRoundZero); 
# 1151
__attribute__((unused)) static inline unsigned long long double2ull(double a, cudaRoundMode mode = cudaRoundZero); 
# 1153
__attribute__((unused)) static inline double ll2double(long long a, cudaRoundMode mode = cudaRoundNearest); 
# 1155
__attribute__((unused)) static inline double ull2double(unsigned long long a, cudaRoundMode mode = cudaRoundNearest); 
# 1157
__attribute__((unused)) static inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest); 
# 1159
__attribute__((unused)) static inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
# 1161
__attribute__((unused)) static inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest); 
# 83 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double fma(double a, double b, double c, cudaRoundMode mode) 
# 84
{int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;
# 89
::exit(___);}
#if 0
# 84
{ 
# 85
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
# 89
} 
#endif
# 91 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double dmul(double a, double b, cudaRoundMode mode) 
# 92
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 97
::exit(___);}
#if 0
# 92
{ 
# 93
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
# 97
} 
#endif
# 99 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double dadd(double a, double b, cudaRoundMode mode) 
# 100
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 105
::exit(___);}
#if 0
# 100
{ 
# 101
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
# 105
} 
#endif
# 107 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double dsub(double a, double b, cudaRoundMode mode) 
# 108
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 113
::exit(___);}
#if 0
# 108
{ 
# 109
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
# 113
} 
#endif
# 115 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline int double2int(double a, cudaRoundMode mode) 
# 116
{int volatile ___ = 1;(void)a;(void)mode;
# 121
::exit(___);}
#if 0
# 116
{ 
# 117
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
# 121
} 
#endif
# 123 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline unsigned double2uint(double a, cudaRoundMode mode) 
# 124
{int volatile ___ = 1;(void)a;(void)mode;
# 129
::exit(___);}
#if 0
# 124
{ 
# 125
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
# 129
} 
#endif
# 131 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline long long double2ll(double a, cudaRoundMode mode) 
# 132
{int volatile ___ = 1;(void)a;(void)mode;
# 137
::exit(___);}
#if 0
# 132
{ 
# 133
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
# 137
} 
#endif
# 139 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline unsigned long long double2ull(double a, cudaRoundMode mode) 
# 140
{int volatile ___ = 1;(void)a;(void)mode;
# 145
::exit(___);}
#if 0
# 140
{ 
# 141
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
# 145
} 
#endif
# 147 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double ll2double(long long a, cudaRoundMode mode) 
# 148
{int volatile ___ = 1;(void)a;(void)mode;
# 153
::exit(___);}
#if 0
# 148
{ 
# 149
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
# 153
} 
#endif
# 155 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double ull2double(unsigned long long a, cudaRoundMode mode) 
# 156
{int volatile ___ = 1;(void)a;(void)mode;
# 161
::exit(___);}
#if 0
# 156
{ 
# 157
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
# 161
} 
#endif
# 163 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double int2double(int a, cudaRoundMode mode) 
# 164
{int volatile ___ = 1;(void)a;(void)mode;
# 166
::exit(___);}
#if 0
# 164
{ 
# 165
return (double)a; 
# 166
} 
#endif
# 168 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double uint2double(unsigned a, cudaRoundMode mode) 
# 169
{int volatile ___ = 1;(void)a;(void)mode;
# 171
::exit(___);}
#if 0
# 169
{ 
# 170
return (double)a; 
# 171
} 
#endif
# 173 "/usr/local/cuda-9.0/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double float2double(float a, cudaRoundMode mode) 
# 174
{int volatile ___ = 1;(void)a;(void)mode;
# 176
::exit(___);}
#if 0
# 174
{ 
# 175
return (double)a; 
# 176
} 
#endif
# 90 "/usr/local/cuda-9.0/include/sm_20_atomic_functions.h"
__attribute__((unused)) static inline float atomicAdd(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 90
{ } 
#endif
# 101 "/usr/local/cuda-9.0/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMin(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 101
{ } 
#endif
# 103 "/usr/local/cuda-9.0/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMax(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 103
{ } 
#endif
# 105 "/usr/local/cuda-9.0/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicAnd(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 105
{ } 
#endif
# 107 "/usr/local/cuda-9.0/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicOr(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 107
{ } 
#endif
# 109 "/usr/local/cuda-9.0/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicXor(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 109
{ } 
#endif
# 111 "/usr/local/cuda-9.0/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMin(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 111
{ } 
#endif
# 113 "/usr/local/cuda-9.0/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMax(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 113
{ } 
#endif
# 115 "/usr/local/cuda-9.0/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAnd(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 115
{ } 
#endif
# 117 "/usr/local/cuda-9.0/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicOr(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 117
{ } 
#endif
# 119 "/usr/local/cuda-9.0/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicXor(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 119
{ } 
#endif
# 304 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline double atomicAdd(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 304
{ } 
#endif
# 307 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAdd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 307
{ } 
#endif
# 310 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAdd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 310
{ } 
#endif
# 313 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAdd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 313
{ } 
#endif
# 316 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAdd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 316
{ } 
#endif
# 319 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAdd_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 319
{ } 
#endif
# 322 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAdd_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 322
{ } 
#endif
# 325 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicAdd_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 325
{ } 
#endif
# 328 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicAdd_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 328
{ } 
#endif
# 331 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline double atomicAdd_block(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 331
{ } 
#endif
# 334 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline double atomicAdd_system(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 334
{ } 
#endif
# 337 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicSub_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 337
{ } 
#endif
# 340 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicSub_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 340
{ } 
#endif
# 343 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicSub_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 343
{ } 
#endif
# 346 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicSub_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 346
{ } 
#endif
# 349 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicExch_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 349
{ } 
#endif
# 352 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicExch_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 352
{ } 
#endif
# 355 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicExch_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 355
{ } 
#endif
# 358 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicExch_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 358
{ } 
#endif
# 361 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicExch_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 361
{ } 
#endif
# 364 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicExch_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 364
{ } 
#endif
# 367 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicExch_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 367
{ } 
#endif
# 370 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicExch_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 370
{ } 
#endif
# 373 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMin_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 373
{ } 
#endif
# 376 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMin_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 376
{ } 
#endif
# 379 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMin_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 379
{ } 
#endif
# 382 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMin_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 382
{ } 
#endif
# 385 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMin_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 385
{ } 
#endif
# 388 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMin_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 388
{ } 
#endif
# 391 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMin_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 391
{ } 
#endif
# 394 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMin_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 394
{ } 
#endif
# 397 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMax_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 397
{ } 
#endif
# 400 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMax_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 400
{ } 
#endif
# 403 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMax_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 403
{ } 
#endif
# 406 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMax_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 406
{ } 
#endif
# 409 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMax_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 409
{ } 
#endif
# 412 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMax_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 412
{ } 
#endif
# 415 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMax_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 415
{ } 
#endif
# 418 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMax_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 418
{ } 
#endif
# 421 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicInc_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 421
{ } 
#endif
# 424 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicInc_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 424
{ } 
#endif
# 427 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicDec_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 427
{ } 
#endif
# 430 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicDec_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 430
{ } 
#endif
# 433 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicCAS_block(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 433
{ } 
#endif
# 436 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicCAS_system(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 436
{ } 
#endif
# 439 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicCAS_block(unsigned *address, unsigned compare, unsigned 
# 440
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 440
{ } 
#endif
# 443 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicCAS_system(unsigned *address, unsigned compare, unsigned 
# 444
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 444
{ } 
#endif
# 447 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicCAS_block(unsigned long long *address, unsigned long long 
# 448
compare, unsigned long long 
# 449
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 449
{ } 
#endif
# 452 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicCAS_system(unsigned long long *address, unsigned long long 
# 453
compare, unsigned long long 
# 454
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 454
{ } 
#endif
# 457 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAnd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 457
{ } 
#endif
# 460 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAnd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 460
{ } 
#endif
# 463 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicAnd_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 463
{ } 
#endif
# 466 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicAnd_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 466
{ } 
#endif
# 469 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAnd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 469
{ } 
#endif
# 472 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAnd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 472
{ } 
#endif
# 475 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAnd_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 475
{ } 
#endif
# 478 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAnd_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 478
{ } 
#endif
# 481 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicOr_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 481
{ } 
#endif
# 484 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicOr_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 484
{ } 
#endif
# 487 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicOr_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 487
{ } 
#endif
# 490 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicOr_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 490
{ } 
#endif
# 493 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicOr_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 493
{ } 
#endif
# 496 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicOr_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 496
{ } 
#endif
# 499 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicOr_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 499
{ } 
#endif
# 502 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicOr_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 502
{ } 
#endif
# 505 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicXor_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 505
{ } 
#endif
# 508 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicXor_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 508
{ } 
#endif
# 511 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicXor_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 511
{ } 
#endif
# 514 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicXor_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 514
{ } 
#endif
# 517 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicXor_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 517
{ } 
#endif
# 520 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicXor_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 520
{ } 
#endif
# 523 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicXor_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 523
{ } 
#endif
# 526 "/usr/local/cuda-9.0/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicXor_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 526
{ } 
#endif
# 92 "/usr/local/cuda-9.0/include/sm_20_intrinsics.h"
extern "C" {
# 1477 "/usr/local/cuda-9.0/include/sm_20_intrinsics.h"
}
# 1484
__attribute((deprecated("__ballot() is deprecated in favor of __ballot_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to" " suppress this warning)."))) __attribute__((unused)) static inline unsigned ballot(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1484
{ } 
#endif
# 1486 "/usr/local/cuda-9.0/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline int syncthreads_count(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1486
{ } 
#endif
# 1488 "/usr/local/cuda-9.0/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline bool syncthreads_and(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1488
{ } 
#endif
# 1490 "/usr/local/cuda-9.0/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline bool syncthreads_or(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1490
{ } 
#endif
# 1497 "/usr/local/cuda-9.0/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline unsigned __isGlobal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 1497
{ } 
#endif
# 107 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __fns(unsigned mask, unsigned base, int offset) {int volatile ___ = 1;(void)mask;(void)base;(void)offset;::exit(___);}
#if 0
# 107
{ } 
#endif
# 108 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline void __barrier_sync(unsigned id) {int volatile ___ = 1;(void)id;::exit(___);}
#if 0
# 108
{ } 
#endif
# 109 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline void __barrier_sync_count(unsigned id, unsigned cnt) {int volatile ___ = 1;(void)id;(void)cnt;::exit(___);}
#if 0
# 109
{ } 
#endif
# 110 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline void __syncwarp(unsigned mask = 4294967295U) {int volatile ___ = 1;(void)mask;::exit(___);}
#if 0
# 110
{ } 
#endif
# 111 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __all_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
# 111
{ } 
#endif
# 112 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __any_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
# 112
{ } 
#endif
# 113 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __uni_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
# 113
{ } 
#endif
# 114 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __ballot_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
# 114
{ } 
#endif
# 115 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __activemask() {int volatile ___ = 1;::exit(___);}
#if 0
# 115
{ } 
#endif
# 123 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline int __shfl(int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 123
{ } 
#endif
# 124 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_sync(unsigned mask, int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 124
{ } 
#endif
# 126 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline unsigned __shfl(unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 126
{ } 
#endif
# 127 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_sync(unsigned mask, unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 127
{ } 
#endif
# 129 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline int __shfl_up(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 129
{ } 
#endif
# 130 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_up_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 130
{ } 
#endif
# 132 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline unsigned __shfl_up(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 132
{ } 
#endif
# 133 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_up_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 133
{ } 
#endif
# 135 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline int __shfl_down(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 135
{ } 
#endif
# 136 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_down_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 136
{ } 
#endif
# 138 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline unsigned __shfl_down(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 138
{ } 
#endif
# 139 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_down_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 139
{ } 
#endif
# 141 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline int __shfl_xor(int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 141
{ } 
#endif
# 142 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_xor_sync(unsigned mask, int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 142
{ } 
#endif
# 144 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline unsigned __shfl_xor(unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 144
{ } 
#endif
# 145 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_xor_sync(unsigned mask, unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 145
{ } 
#endif
# 147 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline float __shfl(float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 147
{ } 
#endif
# 148 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_sync(unsigned mask, float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 148
{ } 
#endif
# 150 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline float __shfl_up(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 150
{ } 
#endif
# 151 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_up_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 151
{ } 
#endif
# 153 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline float __shfl_down(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 153
{ } 
#endif
# 154 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_down_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 154
{ } 
#endif
# 156 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline float __shfl_xor(float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 156
{ } 
#endif
# 157 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_xor_sync(unsigned mask, float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 157
{ } 
#endif
# 160 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline long long __shfl(long long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 160
{ } 
#endif
# 161 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_sync(unsigned mask, long long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 161
{ } 
#endif
# 163 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline unsigned long long __shfl(unsigned long long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 163
{ } 
#endif
# 164 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_sync(unsigned mask, unsigned long long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 164
{ } 
#endif
# 166 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline long long __shfl_up(long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 166
{ } 
#endif
# 167 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_up_sync(unsigned mask, long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 167
{ } 
#endif
# 169 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline unsigned long long __shfl_up(unsigned long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 169
{ } 
#endif
# 170 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_up_sync(unsigned mask, unsigned long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 170
{ } 
#endif
# 172 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline long long __shfl_down(long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 172
{ } 
#endif
# 173 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_down_sync(unsigned mask, long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 173
{ } 
#endif
# 175 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline unsigned long long __shfl_down(unsigned long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 175
{ } 
#endif
# 176 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_down_sync(unsigned mask, unsigned long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 176
{ } 
#endif
# 178 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline long long __shfl_xor(long long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 178
{ } 
#endif
# 179 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_xor_sync(unsigned mask, long long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 179
{ } 
#endif
# 181 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline unsigned long long __shfl_xor(unsigned long long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 181
{ } 
#endif
# 182 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_xor_sync(unsigned mask, unsigned long long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 182
{ } 
#endif
# 184 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline double __shfl(double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 184
{ } 
#endif
# 185 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_sync(unsigned mask, double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 185
{ } 
#endif
# 187 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline double __shfl_up(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 187
{ } 
#endif
# 188 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_up_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 188
{ } 
#endif
# 190 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline double __shfl_down(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 190
{ } 
#endif
# 191 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_down_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 191
{ } 
#endif
# 193 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline double __shfl_xor(double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 193
{ } 
#endif
# 194 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_xor_sync(unsigned mask, double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 194
{ } 
#endif
# 198 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline long __shfl(long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 198
{ } 
#endif
# 199 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_sync(unsigned mask, long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 199
{ } 
#endif
# 201 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline unsigned long __shfl(unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 201
{ } 
#endif
# 202 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_sync(unsigned mask, unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 202
{ } 
#endif
# 204 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline long __shfl_up(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 204
{ } 
#endif
# 205 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_up_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 205
{ } 
#endif
# 207 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 207
{ } 
#endif
# 208 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_up_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 208
{ } 
#endif
# 210 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline long __shfl_down(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 210
{ } 
#endif
# 211 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_down_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 211
{ } 
#endif
# 213 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 213
{ } 
#endif
# 214 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_down_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 214
{ } 
#endif
# 216 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline long __shfl_xor(long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 216
{ } 
#endif
# 217 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_xor_sync(unsigned mask, long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 217
{ } 
#endif
# 219 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 219
{ } 
#endif
# 220 "/usr/local/cuda-9.0/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 220
{ } 
#endif
# 89 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 89
{ } 
#endif
# 90 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 90
{ } 
#endif
# 92 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 92
{ } 
#endif
# 93 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 93
{ } 
#endif
# 94 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 94
{ } 
#endif
# 95 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 95
{ } 
#endif
# 96 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldg(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 96
{ } 
#endif
# 97 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 97
{ } 
#endif
# 98 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 98
{ } 
#endif
# 99 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 99
{ } 
#endif
# 100 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 100
{ } 
#endif
# 101 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 101
{ } 
#endif
# 102 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 102
{ } 
#endif
# 103 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 103
{ } 
#endif
# 105 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 105
{ } 
#endif
# 106 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 106
{ } 
#endif
# 107 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 107
{ } 
#endif
# 108 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldg(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 108
{ } 
#endif
# 109 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 109
{ } 
#endif
# 110 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 110
{ } 
#endif
# 111 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 111
{ } 
#endif
# 112 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 112
{ } 
#endif
# 113 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 113
{ } 
#endif
# 114 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 114
{ } 
#endif
# 115 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 115
{ } 
#endif
# 117 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 117
{ } 
#endif
# 118 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 118
{ } 
#endif
# 119 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 119
{ } 
#endif
# 120 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 120
{ } 
#endif
# 121 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 121
{ } 
#endif
# 125 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldcg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 125
{ } 
#endif
# 126 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldcg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 126
{ } 
#endif
# 128 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldcg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 128
{ } 
#endif
# 129 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldcg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 129
{ } 
#endif
# 130 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldcg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 130
{ } 
#endif
# 131 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldcg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 131
{ } 
#endif
# 132 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldcg(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 132
{ } 
#endif
# 133 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldcg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 133
{ } 
#endif
# 134 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldcg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 134
{ } 
#endif
# 135 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldcg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 135
{ } 
#endif
# 136 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldcg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 136
{ } 
#endif
# 137 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldcg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 137
{ } 
#endif
# 138 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldcg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 138
{ } 
#endif
# 139 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldcg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 139
{ } 
#endif
# 141 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldcg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 141
{ } 
#endif
# 142 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldcg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 142
{ } 
#endif
# 143 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldcg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 143
{ } 
#endif
# 144 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldcg(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 144
{ } 
#endif
# 145 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldcg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 145
{ } 
#endif
# 146 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldcg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 146
{ } 
#endif
# 147 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldcg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 147
{ } 
#endif
# 148 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldcg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 148
{ } 
#endif
# 149 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldcg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 149
{ } 
#endif
# 150 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldcg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 150
{ } 
#endif
# 151 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldcg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 151
{ } 
#endif
# 153 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldcg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 153
{ } 
#endif
# 154 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldcg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 154
{ } 
#endif
# 155 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldcg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 155
{ } 
#endif
# 156 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldcg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 156
{ } 
#endif
# 157 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldcg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 157
{ } 
#endif
# 161 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldca(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 161
{ } 
#endif
# 162 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldca(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 162
{ } 
#endif
# 164 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldca(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 164
{ } 
#endif
# 165 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldca(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 165
{ } 
#endif
# 166 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldca(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 166
{ } 
#endif
# 167 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldca(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 167
{ } 
#endif
# 168 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldca(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 168
{ } 
#endif
# 169 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldca(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 169
{ } 
#endif
# 170 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldca(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 170
{ } 
#endif
# 171 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldca(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 171
{ } 
#endif
# 172 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldca(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 172
{ } 
#endif
# 173 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldca(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 173
{ } 
#endif
# 174 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldca(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 174
{ } 
#endif
# 175 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldca(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 175
{ } 
#endif
# 177 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldca(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 177
{ } 
#endif
# 178 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldca(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 178
{ } 
#endif
# 179 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldca(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 179
{ } 
#endif
# 180 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldca(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 180
{ } 
#endif
# 181 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldca(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 181
{ } 
#endif
# 182 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldca(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 182
{ } 
#endif
# 183 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldca(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 183
{ } 
#endif
# 184 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldca(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 184
{ } 
#endif
# 185 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldca(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 185
{ } 
#endif
# 186 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldca(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 186
{ } 
#endif
# 187 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldca(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 187
{ } 
#endif
# 189 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldca(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 189
{ } 
#endif
# 190 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldca(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 190
{ } 
#endif
# 191 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldca(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 191
{ } 
#endif
# 192 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldca(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 192
{ } 
#endif
# 193 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldca(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 193
{ } 
#endif
# 197 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldcs(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 197
{ } 
#endif
# 198 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldcs(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 198
{ } 
#endif
# 200 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldcs(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 200
{ } 
#endif
# 201 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldcs(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 201
{ } 
#endif
# 202 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldcs(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 202
{ } 
#endif
# 203 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldcs(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 203
{ } 
#endif
# 204 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldcs(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 204
{ } 
#endif
# 205 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldcs(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 205
{ } 
#endif
# 206 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldcs(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 206
{ } 
#endif
# 207 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldcs(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 207
{ } 
#endif
# 208 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldcs(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 208
{ } 
#endif
# 209 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldcs(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 209
{ } 
#endif
# 210 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldcs(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 210
{ } 
#endif
# 211 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldcs(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 211
{ } 
#endif
# 213 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldcs(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 213
{ } 
#endif
# 214 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldcs(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 214
{ } 
#endif
# 215 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldcs(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 215
{ } 
#endif
# 216 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldcs(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 216
{ } 
#endif
# 217 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldcs(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 217
{ } 
#endif
# 218 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldcs(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 218
{ } 
#endif
# 219 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldcs(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 219
{ } 
#endif
# 220 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldcs(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 220
{ } 
#endif
# 221 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldcs(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 221
{ } 
#endif
# 222 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldcs(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 222
{ } 
#endif
# 223 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldcs(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 223
{ } 
#endif
# 225 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldcs(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 225
{ } 
#endif
# 226 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldcs(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 226
{ } 
#endif
# 227 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldcs(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 227
{ } 
#endif
# 228 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldcs(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 228
{ } 
#endif
# 229 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldcs(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 229
{ } 
#endif
# 236 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 236
{ } 
#endif
# 237 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 237
{ } 
#endif
# 240 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 240
{ } 
#endif
# 241 "/usr/local/cuda-9.0/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 241
{ } 
#endif
# 91 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_lo(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 91
{ } 
#endif
# 92 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_lo(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 92
{ } 
#endif
# 94 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_lo(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 94
{ } 
#endif
# 95 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 95
{ } 
#endif
# 97 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_hi(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 97
{ } 
#endif
# 98 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_hi(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 98
{ } 
#endif
# 100 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_hi(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 100
{ } 
#endif
# 101 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 101
{ } 
#endif
# 108 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp4a(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 108
{ } 
#endif
# 109 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp4a(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 109
{ } 
#endif
# 111 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp4a(char4 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 111
{ } 
#endif
# 112 "/usr/local/cuda-9.0/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp4a(uchar4 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 112
{ } 
#endif
# 83 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 83
{ } 
#endif
# 84 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 84
{ } 
#endif
# 85 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, unsigned long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 85
{ } 
#endif
# 86 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 86
{ } 
#endif
# 87 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, unsigned long long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 87
{ } 
#endif
# 88 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, long long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 88
{ } 
#endif
# 89 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, float value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 89
{ } 
#endif
# 90 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, double value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 90
{ } 
#endif
# 92 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, unsigned value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 92
{ } 
#endif
# 93 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, int value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 93
{ } 
#endif
# 94 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, unsigned long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 94
{ } 
#endif
# 95 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 95
{ } 
#endif
# 96 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, unsigned long long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 96
{ } 
#endif
# 97 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, long long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 97
{ } 
#endif
# 98 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, float value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 98
{ } 
#endif
# 99 "/usr/local/cuda-9.0/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, double value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 99
{ } 
#endif
# 116 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 117
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(T *res, surface< void, 1>  surf, int x, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 118
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;
# 122
::exit(___);}
#if 0
# 118
{ 
# 122
} 
#endif
# 124 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 125
__attribute((always_inline)) __attribute__((unused)) static inline T surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 126
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 132
::exit(___);}
#if 0
# 126
{ 
# 132
} 
#endif
# 134 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 135
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(T *res, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 136
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;
# 140
::exit(___);}
#if 0
# 136
{ 
# 140
} 
#endif
# 143 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 144
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(T *res, surface< void, 2>  surf, int x, int y, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 145
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;
# 149
::exit(___);}
#if 0
# 145
{ 
# 149
} 
#endif
# 151 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 152
__attribute((always_inline)) __attribute__((unused)) static inline T surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 153
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 159
::exit(___);}
#if 0
# 153
{ 
# 159
} 
#endif
# 161 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 162
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(T *res, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 163
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;
# 167
::exit(___);}
#if 0
# 163
{ 
# 167
} 
#endif
# 170 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 171
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(T *res, surface< void, 3>  surf, int x, int y, int z, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 172
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
# 176
::exit(___);}
#if 0
# 172
{ 
# 176
} 
#endif
# 178 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 179
__attribute((always_inline)) __attribute__((unused)) static inline T surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 180
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 186
::exit(___);}
#if 0
# 180
{ 
# 186
} 
#endif
# 188 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 189
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(T *res, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 190
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 194
::exit(___);}
#if 0
# 190
{ 
# 194
} 
#endif
# 198 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 199
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(T *res, surface< void, 241>  surf, int x, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 200
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
# 204
::exit(___);}
#if 0
# 200
{ 
# 204
} 
#endif
# 206 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 207
__attribute((always_inline)) __attribute__((unused)) static inline T surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 208
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 214
::exit(___);}
#if 0
# 208
{ 
# 214
} 
#endif
# 217 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 218
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(T *res, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 219
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;
# 223
::exit(___);}
#if 0
# 219
{ 
# 223
} 
#endif
# 226 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 227
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(T *res, surface< void, 242>  surf, int x, int y, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 228
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
# 232
::exit(___);}
#if 0
# 228
{ 
# 232
} 
#endif
# 234 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 235
__attribute((always_inline)) __attribute__((unused)) static inline T surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 236
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 242
::exit(___);}
#if 0
# 236
{ 
# 242
} 
#endif
# 245 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 246
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(T *res, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 247
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 251
::exit(___);}
#if 0
# 247
{ 
# 251
} 
#endif
# 254 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 255
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(T *res, surface< void, 12>  surf, int x, int y, int face, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 256
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
# 260
::exit(___);}
#if 0
# 256
{ 
# 260
} 
#endif
# 262 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 263
__attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 264
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 271
::exit(___);}
#if 0
# 264
{ 
# 271
} 
#endif
# 273 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 274
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(T *res, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 275
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 279
::exit(___);}
#if 0
# 275
{ 
# 279
} 
#endif
# 282 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 283
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(T *res, surface< void, 252>  surf, int x, int y, int layerFace, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 284
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
# 288
::exit(___);}
#if 0
# 284
{ 
# 288
} 
#endif
# 290 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 291
__attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 292
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 298
::exit(___);}
#if 0
# 292
{ 
# 298
} 
#endif
# 300 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 301
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(T *res, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 302
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 306
::exit(___);}
#if 0
# 302
{ 
# 306
} 
#endif
# 309 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 310
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(T val, surface< void, 1>  surf, int x, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 311
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;
# 315
::exit(___);}
#if 0
# 311
{ 
# 315
} 
#endif
# 317 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 318
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(T val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 319
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 323
::exit(___);}
#if 0
# 319
{ 
# 323
} 
#endif
# 327 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 328
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(T val, surface< void, 2>  surf, int x, int y, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 329
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;
# 333
::exit(___);}
#if 0
# 329
{ 
# 333
} 
#endif
# 335 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 336
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(T val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 337
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 341
::exit(___);}
#if 0
# 337
{ 
# 341
} 
#endif
# 344 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 345
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(T val, surface< void, 3>  surf, int x, int y, int z, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 346
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
# 350
::exit(___);}
#if 0
# 346
{ 
# 350
} 
#endif
# 352 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 353
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(T val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 354
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 358
::exit(___);}
#if 0
# 354
{ 
# 358
} 
#endif
# 361 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 362
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(T val, surface< void, 241>  surf, int x, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 363
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
# 367
::exit(___);}
#if 0
# 363
{ 
# 367
} 
#endif
# 369 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 370
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(T val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 371
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 375
::exit(___);}
#if 0
# 371
{ 
# 375
} 
#endif
# 378 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 379
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(T val, surface< void, 242>  surf, int x, int y, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 380
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
# 384
::exit(___);}
#if 0
# 380
{ 
# 384
} 
#endif
# 386 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 387
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(T val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 388
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 392
::exit(___);}
#if 0
# 388
{ 
# 392
} 
#endif
# 395 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 396
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(T val, surface< void, 12>  surf, int x, int y, int face, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 397
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
# 401
::exit(___);}
#if 0
# 397
{ 
# 401
} 
#endif
# 403 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 404
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(T val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 405
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 409
::exit(___);}
#if 0
# 405
{ 
# 409
} 
#endif
# 413 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 414
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(T val, surface< void, 252>  surf, int x, int y, int layerFace, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 415
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
# 419
::exit(___);}
#if 0
# 415
{ 
# 419
} 
#endif
# 421 "/usr/local/cuda-9.0/include/surface_functions.h"
template< class T> 
# 422
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(T val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 423
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 427
::exit(___);}
#if 0
# 423
{ 
# 427
} 
#endif
# 68 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 69
struct __nv_tex_rmet_ret { }; 
# 71
template<> struct __nv_tex_rmet_ret< char>  { typedef char type; }; 
# 72
template<> struct __nv_tex_rmet_ret< signed char>  { typedef signed char type; }; 
# 73
template<> struct __nv_tex_rmet_ret< unsigned char>  { typedef unsigned char type; }; 
# 74
template<> struct __nv_tex_rmet_ret< char1>  { typedef char1 type; }; 
# 75
template<> struct __nv_tex_rmet_ret< uchar1>  { typedef uchar1 type; }; 
# 76
template<> struct __nv_tex_rmet_ret< char2>  { typedef char2 type; }; 
# 77
template<> struct __nv_tex_rmet_ret< uchar2>  { typedef uchar2 type; }; 
# 78
template<> struct __nv_tex_rmet_ret< char4>  { typedef char4 type; }; 
# 79
template<> struct __nv_tex_rmet_ret< uchar4>  { typedef uchar4 type; }; 
# 81
template<> struct __nv_tex_rmet_ret< short>  { typedef short type; }; 
# 82
template<> struct __nv_tex_rmet_ret< unsigned short>  { typedef unsigned short type; }; 
# 83
template<> struct __nv_tex_rmet_ret< short1>  { typedef short1 type; }; 
# 84
template<> struct __nv_tex_rmet_ret< ushort1>  { typedef ushort1 type; }; 
# 85
template<> struct __nv_tex_rmet_ret< short2>  { typedef short2 type; }; 
# 86
template<> struct __nv_tex_rmet_ret< ushort2>  { typedef ushort2 type; }; 
# 87
template<> struct __nv_tex_rmet_ret< short4>  { typedef short4 type; }; 
# 88
template<> struct __nv_tex_rmet_ret< ushort4>  { typedef ushort4 type; }; 
# 90
template<> struct __nv_tex_rmet_ret< int>  { typedef int type; }; 
# 91
template<> struct __nv_tex_rmet_ret< unsigned>  { typedef unsigned type; }; 
# 92
template<> struct __nv_tex_rmet_ret< int1>  { typedef int1 type; }; 
# 93
template<> struct __nv_tex_rmet_ret< uint1>  { typedef uint1 type; }; 
# 94
template<> struct __nv_tex_rmet_ret< int2>  { typedef int2 type; }; 
# 95
template<> struct __nv_tex_rmet_ret< uint2>  { typedef uint2 type; }; 
# 96
template<> struct __nv_tex_rmet_ret< int4>  { typedef int4 type; }; 
# 97
template<> struct __nv_tex_rmet_ret< uint4>  { typedef uint4 type; }; 
# 109 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template<> struct __nv_tex_rmet_ret< float>  { typedef float type; }; 
# 110
template<> struct __nv_tex_rmet_ret< float1>  { typedef float1 type; }; 
# 111
template<> struct __nv_tex_rmet_ret< float2>  { typedef float2 type; }; 
# 112
template<> struct __nv_tex_rmet_ret< float4>  { typedef float4 type; }; 
# 115
template< class T> struct __nv_tex_rmet_cast { typedef T *type; }; 
# 127 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 128
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1Dfetch(texture< T, 1, cudaReadModeElementType>  t, int x) 
# 129
{int volatile ___ = 1;(void)t;(void)x;
# 135
::exit(___);}
#if 0
# 129
{ 
# 135
} 
#endif
# 137 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 138
struct __nv_tex_rmnf_ret { }; 
# 140
template<> struct __nv_tex_rmnf_ret< char>  { typedef float type; }; 
# 141
template<> struct __nv_tex_rmnf_ret< signed char>  { typedef float type; }; 
# 142
template<> struct __nv_tex_rmnf_ret< unsigned char>  { typedef float type; }; 
# 143
template<> struct __nv_tex_rmnf_ret< short>  { typedef float type; }; 
# 144
template<> struct __nv_tex_rmnf_ret< unsigned short>  { typedef float type; }; 
# 145
template<> struct __nv_tex_rmnf_ret< char1>  { typedef float1 type; }; 
# 146
template<> struct __nv_tex_rmnf_ret< uchar1>  { typedef float1 type; }; 
# 147
template<> struct __nv_tex_rmnf_ret< short1>  { typedef float1 type; }; 
# 148
template<> struct __nv_tex_rmnf_ret< ushort1>  { typedef float1 type; }; 
# 149
template<> struct __nv_tex_rmnf_ret< char2>  { typedef float2 type; }; 
# 150
template<> struct __nv_tex_rmnf_ret< uchar2>  { typedef float2 type; }; 
# 151
template<> struct __nv_tex_rmnf_ret< short2>  { typedef float2 type; }; 
# 152
template<> struct __nv_tex_rmnf_ret< ushort2>  { typedef float2 type; }; 
# 153
template<> struct __nv_tex_rmnf_ret< char4>  { typedef float4 type; }; 
# 154
template<> struct __nv_tex_rmnf_ret< uchar4>  { typedef float4 type; }; 
# 155
template<> struct __nv_tex_rmnf_ret< short4>  { typedef float4 type; }; 
# 156
template<> struct __nv_tex_rmnf_ret< ushort4>  { typedef float4 type; }; 
# 158
template< class T> 
# 159
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1Dfetch(texture< T, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 160
{int volatile ___ = 1;(void)t;(void)x;
# 167
::exit(___);}
#if 0
# 160
{ 
# 167
} 
#endif
# 170 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 171
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1D(texture< T, 1, cudaReadModeElementType>  t, float x) 
# 172
{int volatile ___ = 1;(void)t;(void)x;
# 178
::exit(___);}
#if 0
# 172
{ 
# 178
} 
#endif
# 180 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 181
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1D(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 182
{int volatile ___ = 1;(void)t;(void)x;
# 189
::exit(___);}
#if 0
# 182
{ 
# 189
} 
#endif
# 193 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 194
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2D(texture< T, 2, cudaReadModeElementType>  t, float x, float y) 
# 195
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 202
::exit(___);}
#if 0
# 195
{ 
# 202
} 
#endif
# 204 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 205
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2D(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 206
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 213
::exit(___);}
#if 0
# 206
{ 
# 213
} 
#endif
# 217 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 218
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1DLayered(texture< T, 241, cudaReadModeElementType>  t, float x, int layer) 
# 219
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 225
::exit(___);}
#if 0
# 219
{ 
# 225
} 
#endif
# 227 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 228
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1DLayered(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 229
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 236
::exit(___);}
#if 0
# 229
{ 
# 236
} 
#endif
# 240 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 241
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2DLayered(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 242
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 248
::exit(___);}
#if 0
# 242
{ 
# 248
} 
#endif
# 250 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 251
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2DLayered(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 252
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 259
::exit(___);}
#if 0
# 252
{ 
# 259
} 
#endif
# 262 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 263
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex3D(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 264
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 270
::exit(___);}
#if 0
# 264
{ 
# 270
} 
#endif
# 272 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 273
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex3D(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 274
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 281
::exit(___);}
#if 0
# 274
{ 
# 281
} 
#endif
# 284 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 285
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemap(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 286
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 292
::exit(___);}
#if 0
# 286
{ 
# 292
} 
#endif
# 294 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 295
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemap(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 296
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 303
::exit(___);}
#if 0
# 296
{ 
# 303
} 
#endif
# 306 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 307
struct __nv_tex2dgather_ret { }; 
# 308
template<> struct __nv_tex2dgather_ret< char>  { typedef char4 type; }; 
# 309
template<> struct __nv_tex2dgather_ret< signed char>  { typedef char4 type; }; 
# 310
template<> struct __nv_tex2dgather_ret< char1>  { typedef char4 type; }; 
# 311
template<> struct __nv_tex2dgather_ret< char2>  { typedef char4 type; }; 
# 312
template<> struct __nv_tex2dgather_ret< char3>  { typedef char4 type; }; 
# 313
template<> struct __nv_tex2dgather_ret< char4>  { typedef char4 type; }; 
# 314
template<> struct __nv_tex2dgather_ret< unsigned char>  { typedef uchar4 type; }; 
# 315
template<> struct __nv_tex2dgather_ret< uchar1>  { typedef uchar4 type; }; 
# 316
template<> struct __nv_tex2dgather_ret< uchar2>  { typedef uchar4 type; }; 
# 317
template<> struct __nv_tex2dgather_ret< uchar3>  { typedef uchar4 type; }; 
# 318
template<> struct __nv_tex2dgather_ret< uchar4>  { typedef uchar4 type; }; 
# 320
template<> struct __nv_tex2dgather_ret< short>  { typedef short4 type; }; 
# 321
template<> struct __nv_tex2dgather_ret< short1>  { typedef short4 type; }; 
# 322
template<> struct __nv_tex2dgather_ret< short2>  { typedef short4 type; }; 
# 323
template<> struct __nv_tex2dgather_ret< short3>  { typedef short4 type; }; 
# 324
template<> struct __nv_tex2dgather_ret< short4>  { typedef short4 type; }; 
# 325
template<> struct __nv_tex2dgather_ret< unsigned short>  { typedef ushort4 type; }; 
# 326
template<> struct __nv_tex2dgather_ret< ushort1>  { typedef ushort4 type; }; 
# 327
template<> struct __nv_tex2dgather_ret< ushort2>  { typedef ushort4 type; }; 
# 328
template<> struct __nv_tex2dgather_ret< ushort3>  { typedef ushort4 type; }; 
# 329
template<> struct __nv_tex2dgather_ret< ushort4>  { typedef ushort4 type; }; 
# 331
template<> struct __nv_tex2dgather_ret< int>  { typedef int4 type; }; 
# 332
template<> struct __nv_tex2dgather_ret< int1>  { typedef int4 type; }; 
# 333
template<> struct __nv_tex2dgather_ret< int2>  { typedef int4 type; }; 
# 334
template<> struct __nv_tex2dgather_ret< int3>  { typedef int4 type; }; 
# 335
template<> struct __nv_tex2dgather_ret< int4>  { typedef int4 type; }; 
# 336
template<> struct __nv_tex2dgather_ret< unsigned>  { typedef uint4 type; }; 
# 337
template<> struct __nv_tex2dgather_ret< uint1>  { typedef uint4 type; }; 
# 338
template<> struct __nv_tex2dgather_ret< uint2>  { typedef uint4 type; }; 
# 339
template<> struct __nv_tex2dgather_ret< uint3>  { typedef uint4 type; }; 
# 340
template<> struct __nv_tex2dgather_ret< uint4>  { typedef uint4 type; }; 
# 342
template<> struct __nv_tex2dgather_ret< float>  { typedef float4 type; }; 
# 343
template<> struct __nv_tex2dgather_ret< float1>  { typedef float4 type; }; 
# 344
template<> struct __nv_tex2dgather_ret< float2>  { typedef float4 type; }; 
# 345
template<> struct __nv_tex2dgather_ret< float3>  { typedef float4 type; }; 
# 346
template<> struct __nv_tex2dgather_ret< float4>  { typedef float4 type; }; 
# 348
template< class T> 
# 349
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex2dgather_ret< T> ::type tex2Dgather(texture< T, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 350
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 357
::exit(___);}
#if 0
# 350
{ 
# 357
} 
#endif
# 360 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> struct __nv_tex2dgather_rmnf_ret { }; 
# 361
template<> struct __nv_tex2dgather_rmnf_ret< char>  { typedef float4 type; }; 
# 362
template<> struct __nv_tex2dgather_rmnf_ret< signed char>  { typedef float4 type; }; 
# 363
template<> struct __nv_tex2dgather_rmnf_ret< unsigned char>  { typedef float4 type; }; 
# 364
template<> struct __nv_tex2dgather_rmnf_ret< char1>  { typedef float4 type; }; 
# 365
template<> struct __nv_tex2dgather_rmnf_ret< uchar1>  { typedef float4 type; }; 
# 366
template<> struct __nv_tex2dgather_rmnf_ret< char2>  { typedef float4 type; }; 
# 367
template<> struct __nv_tex2dgather_rmnf_ret< uchar2>  { typedef float4 type; }; 
# 368
template<> struct __nv_tex2dgather_rmnf_ret< char3>  { typedef float4 type; }; 
# 369
template<> struct __nv_tex2dgather_rmnf_ret< uchar3>  { typedef float4 type; }; 
# 370
template<> struct __nv_tex2dgather_rmnf_ret< char4>  { typedef float4 type; }; 
# 371
template<> struct __nv_tex2dgather_rmnf_ret< uchar4>  { typedef float4 type; }; 
# 372
template<> struct __nv_tex2dgather_rmnf_ret< signed short>  { typedef float4 type; }; 
# 373
template<> struct __nv_tex2dgather_rmnf_ret< unsigned short>  { typedef float4 type; }; 
# 374
template<> struct __nv_tex2dgather_rmnf_ret< short1>  { typedef float4 type; }; 
# 375
template<> struct __nv_tex2dgather_rmnf_ret< ushort1>  { typedef float4 type; }; 
# 376
template<> struct __nv_tex2dgather_rmnf_ret< short2>  { typedef float4 type; }; 
# 377
template<> struct __nv_tex2dgather_rmnf_ret< ushort2>  { typedef float4 type; }; 
# 378
template<> struct __nv_tex2dgather_rmnf_ret< short3>  { typedef float4 type; }; 
# 379
template<> struct __nv_tex2dgather_rmnf_ret< ushort3>  { typedef float4 type; }; 
# 380
template<> struct __nv_tex2dgather_rmnf_ret< short4>  { typedef float4 type; }; 
# 381
template<> struct __nv_tex2dgather_rmnf_ret< ushort4>  { typedef float4 type; }; 
# 383
template< class T> 
# 384
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex2dgather_rmnf_ret< T> ::type tex2Dgather(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 385
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 392
::exit(___);}
#if 0
# 385
{ 
# 392
} 
#endif
# 396 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 397
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1DLod(texture< T, 1, cudaReadModeElementType>  t, float x, float level) 
# 398
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 404
::exit(___);}
#if 0
# 398
{ 
# 404
} 
#endif
# 406 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 407
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1DLod(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 408
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 415
::exit(___);}
#if 0
# 408
{ 
# 415
} 
#endif
# 418 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 419
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2DLod(texture< T, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 420
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 426
::exit(___);}
#if 0
# 420
{ 
# 426
} 
#endif
# 428 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 429
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2DLod(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 430
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 437
::exit(___);}
#if 0
# 430
{ 
# 437
} 
#endif
# 440 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 441
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1DLayeredLod(texture< T, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 442
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 448
::exit(___);}
#if 0
# 442
{ 
# 448
} 
#endif
# 450 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 451
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1DLayeredLod(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 452
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 459
::exit(___);}
#if 0
# 452
{ 
# 459
} 
#endif
# 462 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 463
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2DLayeredLod(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 464
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 470
::exit(___);}
#if 0
# 464
{ 
# 470
} 
#endif
# 472 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 473
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2DLayeredLod(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 474
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 481
::exit(___);}
#if 0
# 474
{ 
# 481
} 
#endif
# 484 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 485
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex3DLod(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 486
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 492
::exit(___);}
#if 0
# 486
{ 
# 492
} 
#endif
# 494 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 495
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex3DLod(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 496
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 503
::exit(___);}
#if 0
# 496
{ 
# 503
} 
#endif
# 506 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 507
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemapLod(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 508
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 514
::exit(___);}
#if 0
# 508
{ 
# 514
} 
#endif
# 516 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 517
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemapLod(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 518
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 525
::exit(___);}
#if 0
# 518
{ 
# 525
} 
#endif
# 529 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 530
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemapLayered(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 531
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 537
::exit(___);}
#if 0
# 531
{ 
# 537
} 
#endif
# 539 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 540
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemapLayered(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 541
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 548
::exit(___);}
#if 0
# 541
{ 
# 548
} 
#endif
# 552 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 553
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemapLayeredLod(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 554
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 560
::exit(___);}
#if 0
# 554
{ 
# 560
} 
#endif
# 562 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 563
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemapLayeredLod(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 564
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 571
::exit(___);}
#if 0
# 564
{ 
# 571
} 
#endif
# 575 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 576
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemapGrad(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 577
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 583
::exit(___);}
#if 0
# 577
{ 
# 583
} 
#endif
# 585 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 586
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemapGrad(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 587
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 594
::exit(___);}
#if 0
# 587
{ 
# 594
} 
#endif
# 598 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 599
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemapLayeredGrad(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float4 dPdx, float4 dPdy) 
# 600
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
# 606
::exit(___);}
#if 0
# 600
{ 
# 606
} 
#endif
# 608 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 609
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemapLayeredGrad(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float4 dPdx, float4 dPdy) 
# 610
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
# 617
::exit(___);}
#if 0
# 610
{ 
# 617
} 
#endif
# 621 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 622
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1DGrad(texture< T, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 623
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 629
::exit(___);}
#if 0
# 623
{ 
# 629
} 
#endif
# 631 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 632
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1DGrad(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 633
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 640
::exit(___);}
#if 0
# 633
{ 
# 640
} 
#endif
# 644 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 645
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2DGrad(texture< T, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 652
::exit(___);}
#if 0
# 646
{ 
# 652
} 
#endif
# 654 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 655
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2DGrad(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 656
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 663
::exit(___);}
#if 0
# 656
{ 
# 663
} 
#endif
# 666 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 667
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1DLayeredGrad(texture< T, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 668
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 674
::exit(___);}
#if 0
# 668
{ 
# 674
} 
#endif
# 676 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 677
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1DLayeredGrad(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 678
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 685
::exit(___);}
#if 0
# 678
{ 
# 685
} 
#endif
# 688 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 689
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2DLayeredGrad(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 690
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 696
::exit(___);}
#if 0
# 690
{ 
# 696
} 
#endif
# 698 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 699
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2DLayeredGrad(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 700
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 707
::exit(___);}
#if 0
# 700
{ 
# 707
} 
#endif
# 710 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 711
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex3DGrad(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 712
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 718
::exit(___);}
#if 0
# 712
{ 
# 718
} 
#endif
# 720 "/usr/local/cuda-9.0/include/texture_fetch_functions.h"
template< class T> 
# 721
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex3DGrad(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 722
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 729
::exit(___);}
#if 0
# 722
{ 
# 729
} 
#endif
# 61 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> struct __nv_itex_trait { }; 
# 62
template<> struct __nv_itex_trait< char>  { typedef void type; }; 
# 63
template<> struct __nv_itex_trait< signed char>  { typedef void type; }; 
# 64
template<> struct __nv_itex_trait< char1>  { typedef void type; }; 
# 65
template<> struct __nv_itex_trait< char2>  { typedef void type; }; 
# 66
template<> struct __nv_itex_trait< char4>  { typedef void type; }; 
# 67
template<> struct __nv_itex_trait< unsigned char>  { typedef void type; }; 
# 68
template<> struct __nv_itex_trait< uchar1>  { typedef void type; }; 
# 69
template<> struct __nv_itex_trait< uchar2>  { typedef void type; }; 
# 70
template<> struct __nv_itex_trait< uchar4>  { typedef void type; }; 
# 71
template<> struct __nv_itex_trait< short>  { typedef void type; }; 
# 72
template<> struct __nv_itex_trait< short1>  { typedef void type; }; 
# 73
template<> struct __nv_itex_trait< short2>  { typedef void type; }; 
# 74
template<> struct __nv_itex_trait< short4>  { typedef void type; }; 
# 75
template<> struct __nv_itex_trait< unsigned short>  { typedef void type; }; 
# 76
template<> struct __nv_itex_trait< ushort1>  { typedef void type; }; 
# 77
template<> struct __nv_itex_trait< ushort2>  { typedef void type; }; 
# 78
template<> struct __nv_itex_trait< ushort4>  { typedef void type; }; 
# 79
template<> struct __nv_itex_trait< int>  { typedef void type; }; 
# 80
template<> struct __nv_itex_trait< int1>  { typedef void type; }; 
# 81
template<> struct __nv_itex_trait< int2>  { typedef void type; }; 
# 82
template<> struct __nv_itex_trait< int4>  { typedef void type; }; 
# 83
template<> struct __nv_itex_trait< unsigned>  { typedef void type; }; 
# 84
template<> struct __nv_itex_trait< uint1>  { typedef void type; }; 
# 85
template<> struct __nv_itex_trait< uint2>  { typedef void type; }; 
# 86
template<> struct __nv_itex_trait< uint4>  { typedef void type; }; 
# 97 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template<> struct __nv_itex_trait< float>  { typedef void type; }; 
# 98
template<> struct __nv_itex_trait< float1>  { typedef void type; }; 
# 99
template<> struct __nv_itex_trait< float2>  { typedef void type; }; 
# 100
template<> struct __nv_itex_trait< float4>  { typedef void type; }; 
# 104
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 105
tex1Dfetch(T *ptr, cudaTextureObject_t obj, int x) 
# 106
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;
# 110
::exit(___);}
#if 0
# 106
{ 
# 110
} 
#endif
# 112 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 113
tex1Dfetch(cudaTextureObject_t texObject, int x) 
# 114
{int volatile ___ = 1;(void)texObject;(void)x;
# 120
::exit(___);}
#if 0
# 114
{ 
# 120
} 
#endif
# 122 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 123
tex1D(T *ptr, cudaTextureObject_t obj, float x) 
# 124
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;
# 128
::exit(___);}
#if 0
# 124
{ 
# 128
} 
#endif
# 131 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 132
tex1D(cudaTextureObject_t texObject, float x) 
# 133
{int volatile ___ = 1;(void)texObject;(void)x;
# 139
::exit(___);}
#if 0
# 133
{ 
# 139
} 
#endif
# 142 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 143
tex2D(T *ptr, cudaTextureObject_t obj, float x, float y) 
# 144
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;
# 148
::exit(___);}
#if 0
# 144
{ 
# 148
} 
#endif
# 150 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 151
tex2D(cudaTextureObject_t texObject, float x, float y) 
# 152
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;
# 158
::exit(___);}
#if 0
# 152
{ 
# 158
} 
#endif
# 160 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 161
tex3D(T *ptr, cudaTextureObject_t obj, float x, float y, float z) 
# 162
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;
# 166
::exit(___);}
#if 0
# 162
{ 
# 166
} 
#endif
# 168 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 169
tex3D(cudaTextureObject_t texObject, float x, float y, float z) 
# 170
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
# 176
::exit(___);}
#if 0
# 170
{ 
# 176
} 
#endif
# 178 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 179
tex1DLayered(T *ptr, cudaTextureObject_t obj, float x, int layer) 
# 180
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;
# 184
::exit(___);}
#if 0
# 180
{ 
# 184
} 
#endif
# 186 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 187
tex1DLayered(cudaTextureObject_t texObject, float x, int layer) 
# 188
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;
# 194
::exit(___);}
#if 0
# 188
{ 
# 194
} 
#endif
# 196 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 197
tex2DLayered(T *ptr, cudaTextureObject_t obj, float x, float y, int layer) 
# 198
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;
# 202
::exit(___);}
#if 0
# 198
{ 
# 202
} 
#endif
# 204 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 205
tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer) 
# 206
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;
# 212
::exit(___);}
#if 0
# 206
{ 
# 212
} 
#endif
# 215 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 216
texCubemap(T *ptr, cudaTextureObject_t obj, float x, float y, float z) 
# 217
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;
# 221
::exit(___);}
#if 0
# 217
{ 
# 221
} 
#endif
# 224 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 225
texCubemap(cudaTextureObject_t texObject, float x, float y, float z) 
# 226
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
# 232
::exit(___);}
#if 0
# 226
{ 
# 232
} 
#endif
# 235 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 236
texCubemapLayered(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer) 
# 237
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;
# 241
::exit(___);}
#if 0
# 237
{ 
# 241
} 
#endif
# 243 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 244
texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 245
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 251
::exit(___);}
#if 0
# 245
{ 
# 251
} 
#endif
# 253 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 254
tex2Dgather(T *ptr, cudaTextureObject_t obj, float x, float y, int comp = 0) 
# 255
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)comp;
# 259
::exit(___);}
#if 0
# 255
{ 
# 259
} 
#endif
# 261 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 262
tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0) 
# 263
{int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;
# 269
::exit(___);}
#if 0
# 263
{ 
# 269
} 
#endif
# 273 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 274
tex1DLod(T *ptr, cudaTextureObject_t obj, float x, float level) 
# 275
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)level;
# 279
::exit(___);}
#if 0
# 275
{ 
# 279
} 
#endif
# 281 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 282
tex1DLod(cudaTextureObject_t texObject, float x, float level) 
# 283
{int volatile ___ = 1;(void)texObject;(void)x;(void)level;
# 289
::exit(___);}
#if 0
# 283
{ 
# 289
} 
#endif
# 292 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 293
tex2DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float level) 
# 294
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)level;
# 298
::exit(___);}
#if 0
# 294
{ 
# 298
} 
#endif
# 300 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 301
tex2DLod(cudaTextureObject_t texObject, float x, float y, float level) 
# 302
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;
# 308
::exit(___);}
#if 0
# 302
{ 
# 308
} 
#endif
# 311 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 312
tex3DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float level) 
# 313
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;
# 317
::exit(___);}
#if 0
# 313
{ 
# 317
} 
#endif
# 319 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 320
tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 321
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 327
::exit(___);}
#if 0
# 321
{ 
# 327
} 
#endif
# 330 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 331
tex1DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, int layer, float level) 
# 332
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)level;
# 336
::exit(___);}
#if 0
# 332
{ 
# 336
} 
#endif
# 338 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 339
tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level) 
# 340
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;
# 346
::exit(___);}
#if 0
# 340
{ 
# 346
} 
#endif
# 349 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 350
tex2DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, float level) 
# 351
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)level;
# 355
::exit(___);}
#if 0
# 351
{ 
# 355
} 
#endif
# 357 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 358
tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 359
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 365
::exit(___);}
#if 0
# 359
{ 
# 365
} 
#endif
# 368 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 369
texCubemapLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float level) 
# 370
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;
# 374
::exit(___);}
#if 0
# 370
{ 
# 374
} 
#endif
# 376 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 377
texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 378
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 384
::exit(___);}
#if 0
# 378
{ 
# 384
} 
#endif
# 387 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 388
texCubemapGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 389
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 393
::exit(___);}
#if 0
# 389
{ 
# 393
} 
#endif
# 395 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 396
texCubemapGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 397
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 403
::exit(___);}
#if 0
# 397
{ 
# 403
} 
#endif
# 405 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 406
texCubemapLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer, float level) 
# 407
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 411
::exit(___);}
#if 0
# 407
{ 
# 411
} 
#endif
# 413 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 414
texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 415
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 421
::exit(___);}
#if 0
# 415
{ 
# 421
} 
#endif
# 423 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 424
tex1DGrad(T *ptr, cudaTextureObject_t obj, float x, float dPdx, float dPdy) 
# 425
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)dPdx;(void)dPdy;
# 429
::exit(___);}
#if 0
# 425
{ 
# 429
} 
#endif
# 431 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 432
tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 433
{int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 439
::exit(___);}
#if 0
# 433
{ 
# 439
} 
#endif
# 442 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 443
tex2DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float2 dPdx, float2 dPdy) 
# 444
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 449
::exit(___);}
#if 0
# 444
{ 
# 449
} 
#endif
# 451 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 452
tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 453
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 459
::exit(___);}
#if 0
# 453
{ 
# 459
} 
#endif
# 462 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 463
tex3DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 464
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 468
::exit(___);}
#if 0
# 464
{ 
# 468
} 
#endif
# 470 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 471
tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 472
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 478
::exit(___);}
#if 0
# 472
{ 
# 478
} 
#endif
# 481 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 482
tex1DLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, int layer, float dPdx, float dPdy) 
# 483
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 487
::exit(___);}
#if 0
# 483
{ 
# 487
} 
#endif
# 489 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 490
tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 491
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 497
::exit(___);}
#if 0
# 491
{ 
# 497
} 
#endif
# 500 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 501
tex2DLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 502
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 506
::exit(___);}
#if 0
# 502
{ 
# 506
} 
#endif
# 508 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 509
tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 510
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 516
::exit(___);}
#if 0
# 510
{ 
# 516
} 
#endif
# 519 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 520
texCubemapLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer, float4 dPdx, float4 dPdy) 
# 521
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
# 525
::exit(___);}
#if 0
# 521
{ 
# 525
} 
#endif
# 527 "/usr/local/cuda-9.0/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 528
texCubemapLayeredGrad(cudaTextureObject_t texObject, float x, float y, float z, int layer, float4 dPdx, float4 dPdy) 
# 529
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
# 535
::exit(___);}
#if 0
# 529
{ 
# 535
} 
#endif
# 60 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> struct __nv_isurf_trait { }; 
# 61
template<> struct __nv_isurf_trait< char>  { typedef void type; }; 
# 62
template<> struct __nv_isurf_trait< signed char>  { typedef void type; }; 
# 63
template<> struct __nv_isurf_trait< char1>  { typedef void type; }; 
# 64
template<> struct __nv_isurf_trait< unsigned char>  { typedef void type; }; 
# 65
template<> struct __nv_isurf_trait< uchar1>  { typedef void type; }; 
# 66
template<> struct __nv_isurf_trait< short>  { typedef void type; }; 
# 67
template<> struct __nv_isurf_trait< short1>  { typedef void type; }; 
# 68
template<> struct __nv_isurf_trait< unsigned short>  { typedef void type; }; 
# 69
template<> struct __nv_isurf_trait< ushort1>  { typedef void type; }; 
# 70
template<> struct __nv_isurf_trait< int>  { typedef void type; }; 
# 71
template<> struct __nv_isurf_trait< int1>  { typedef void type; }; 
# 72
template<> struct __nv_isurf_trait< unsigned>  { typedef void type; }; 
# 73
template<> struct __nv_isurf_trait< uint1>  { typedef void type; }; 
# 74
template<> struct __nv_isurf_trait< long long>  { typedef void type; }; 
# 75
template<> struct __nv_isurf_trait< longlong1>  { typedef void type; }; 
# 76
template<> struct __nv_isurf_trait< unsigned long long>  { typedef void type; }; 
# 77
template<> struct __nv_isurf_trait< ulonglong1>  { typedef void type; }; 
# 78
template<> struct __nv_isurf_trait< float>  { typedef void type; }; 
# 79
template<> struct __nv_isurf_trait< float1>  { typedef void type; }; 
# 81
template<> struct __nv_isurf_trait< char2>  { typedef void type; }; 
# 82
template<> struct __nv_isurf_trait< uchar2>  { typedef void type; }; 
# 83
template<> struct __nv_isurf_trait< short2>  { typedef void type; }; 
# 84
template<> struct __nv_isurf_trait< ushort2>  { typedef void type; }; 
# 85
template<> struct __nv_isurf_trait< int2>  { typedef void type; }; 
# 86
template<> struct __nv_isurf_trait< uint2>  { typedef void type; }; 
# 87
template<> struct __nv_isurf_trait< longlong2>  { typedef void type; }; 
# 88
template<> struct __nv_isurf_trait< ulonglong2>  { typedef void type; }; 
# 89
template<> struct __nv_isurf_trait< float2>  { typedef void type; }; 
# 91
template<> struct __nv_isurf_trait< char4>  { typedef void type; }; 
# 92
template<> struct __nv_isurf_trait< uchar4>  { typedef void type; }; 
# 93
template<> struct __nv_isurf_trait< short4>  { typedef void type; }; 
# 94
template<> struct __nv_isurf_trait< ushort4>  { typedef void type; }; 
# 95
template<> struct __nv_isurf_trait< int4>  { typedef void type; }; 
# 96
template<> struct __nv_isurf_trait< uint4>  { typedef void type; }; 
# 97
template<> struct __nv_isurf_trait< float4>  { typedef void type; }; 
# 100
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 101
surf1Dread(T *ptr, cudaSurfaceObject_t obj, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 102
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)mode;
# 106
::exit(___);}
#if 0
# 102
{ 
# 106
} 
#endif
# 108 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 109
surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 110
{int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;
# 116
::exit(___);}
#if 0
# 110
{ 
# 116
} 
#endif
# 118 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 119
surf2Dread(T *ptr, cudaSurfaceObject_t obj, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 120
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)mode;
# 124
::exit(___);}
#if 0
# 120
{ 
# 124
} 
#endif
# 126 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 127
surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 128
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 134
::exit(___);}
#if 0
# 128
{ 
# 134
} 
#endif
# 137 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 138
surf3Dread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 139
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)mode;
# 143
::exit(___);}
#if 0
# 139
{ 
# 143
} 
#endif
# 145 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 146
surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 147
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 153
::exit(___);}
#if 0
# 147
{ 
# 153
} 
#endif
# 155 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 156
surf1DLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 157
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)mode;
# 161
::exit(___);}
#if 0
# 157
{ 
# 161
} 
#endif
# 163 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 164
surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 165
{int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 171
::exit(___);}
#if 0
# 165
{ 
# 171
} 
#endif
# 173 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 174
surf2DLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 175
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)mode;
# 179
::exit(___);}
#if 0
# 175
{ 
# 179
} 
#endif
# 181 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 182
surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 183
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 189
::exit(___);}
#if 0
# 183
{ 
# 189
} 
#endif
# 191 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 192
surfCubemapread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 193
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)face;(void)mode;
# 197
::exit(___);}
#if 0
# 193
{ 
# 197
} 
#endif
# 199 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 200
surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 201
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 207
::exit(___);}
#if 0
# 201
{ 
# 207
} 
#endif
# 209 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 210
surfCubemapLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int layerface, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 211
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;
# 215
::exit(___);}
#if 0
# 211
{ 
# 215
} 
#endif
# 217 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 218
surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 219
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 225
::exit(___);}
#if 0
# 219
{ 
# 225
} 
#endif
# 227 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 228
surf1Dwrite(T val, cudaSurfaceObject_t obj, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 229
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)mode;
# 233
::exit(___);}
#if 0
# 229
{ 
# 233
} 
#endif
# 235 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 236
surf2Dwrite(T val, cudaSurfaceObject_t obj, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 237
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)mode;
# 241
::exit(___);}
#if 0
# 237
{ 
# 241
} 
#endif
# 243 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 244
surf3Dwrite(T val, cudaSurfaceObject_t obj, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 245
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)z;(void)mode;
# 249
::exit(___);}
#if 0
# 245
{ 
# 249
} 
#endif
# 251 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 252
surf1DLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 253
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)layer;(void)mode;
# 257
::exit(___);}
#if 0
# 253
{ 
# 257
} 
#endif
# 259 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 260
surf2DLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 261
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layer;(void)mode;
# 265
::exit(___);}
#if 0
# 261
{ 
# 265
} 
#endif
# 267 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 268
surfCubemapwrite(T val, cudaSurfaceObject_t obj, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 269
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)face;(void)mode;
# 273
::exit(___);}
#if 0
# 269
{ 
# 273
} 
#endif
# 275 "/usr/local/cuda-9.0/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 276
surfCubemapLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int y, int layerface, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 277
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;
# 281
::exit(___);}
#if 0
# 277
{ 
# 281
} 
#endif
# 68 "/usr/local/cuda-9.0/include/device_launch_parameters.h"
extern "C" {
# 71
extern const uint3 __device_builtin_variable_threadIdx; 
# 72
extern const uint3 __device_builtin_variable_blockIdx; 
# 73
extern const dim3 __device_builtin_variable_blockDim; 
# 74
extern const dim3 __device_builtin_variable_gridDim; 
# 75
extern const int __device_builtin_variable_warpSize; 
# 80
}
# 185 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 186
cudaLaunchKernel_ptsz(const T *
# 187
func, dim3 
# 188
gridDim, dim3 
# 189
blockDim, void **
# 190
args, size_t 
# 191
sharedMem = 0, cudaStream_t 
# 192
stream = 0) 
# 194
{ 
# 195
return ::cudaLaunchKernel_ptsz((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
# 196
} 
# 245 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 246
cudaLaunchCooperativeKernel_ptsz(const T *
# 247
func, dim3 
# 248
gridDim, dim3 
# 249
blockDim, void **
# 250
args, size_t 
# 251
sharedMem = 0, cudaStream_t 
# 252
stream = 0) 
# 254
{ 
# 255
return ::cudaLaunchCooperativeKernel_ptsz((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
# 256
} 
# 283 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 284
cudaSetupArgument(T 
# 285
arg, size_t 
# 286
offset) 
# 288
{ 
# 289
return ::cudaSetupArgument((const void *)(&arg), sizeof(T), offset); 
# 290
} 
# 322 "/usr/local/cuda-9.0/include/cuda_runtime.h"
static inline cudaError_t cudaEventCreate(cudaEvent_t *
# 323
event, unsigned 
# 324
flags) 
# 326
{ 
# 327
return ::cudaEventCreateWithFlags(event, flags); 
# 328
} 
# 385 "/usr/local/cuda-9.0/include/cuda_runtime.h"
static inline cudaError_t cudaMallocHost(void **
# 386
ptr, size_t 
# 387
size, unsigned 
# 388
flags) 
# 390
{ 
# 391
return ::cudaHostAlloc(ptr, size, flags); 
# 392
} 
# 394
template< class T> static inline cudaError_t 
# 395
cudaHostAlloc(T **
# 396
ptr, size_t 
# 397
size, unsigned 
# 398
flags) 
# 400
{ 
# 401
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
# 402
} 
# 404
template< class T> static inline cudaError_t 
# 405
cudaHostGetDevicePointer(T **
# 406
pDevice, void *
# 407
pHost, unsigned 
# 408
flags) 
# 410
{ 
# 411
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
# 412
} 
# 512 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 513
cudaMallocManaged(T **
# 514
devPtr, size_t 
# 515
size, unsigned 
# 516
flags = 1) 
# 518
{ 
# 519
return ::cudaMallocManaged((void **)((void *)devPtr), size, flags); 
# 520
} 
# 591 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 592
cudaStreamAttachMemAsync_ptsz(cudaStream_t 
# 593
stream, T *
# 594
devPtr, size_t 
# 595
length = 0, unsigned 
# 596
flags = 4) 
# 598
{ 
# 599
return ::cudaStreamAttachMemAsync_ptsz(stream, (void *)devPtr, length, flags); 
# 600
} 
# 602
template< class T> inline cudaError_t 
# 603
cudaMalloc(T **
# 604
devPtr, size_t 
# 605
size) 
# 607
{ 
# 608
return ::cudaMalloc((void **)((void *)devPtr), size); 
# 609
} 
# 611
template< class T> static inline cudaError_t 
# 612
cudaMallocHost(T **
# 613
ptr, size_t 
# 614
size, unsigned 
# 615
flags = 0) 
# 617
{ 
# 618
return cudaMallocHost((void **)((void *)ptr), size, flags); 
# 619
} 
# 621
template< class T> static inline cudaError_t 
# 622
cudaMallocPitch(T **
# 623
devPtr, size_t *
# 624
pitch, size_t 
# 625
width, size_t 
# 626
height) 
# 628
{ 
# 629
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
# 630
} 
# 667 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 668
cudaMemcpyToSymbol_ptds(const T &
# 669
symbol, const void *
# 670
src, size_t 
# 671
count, size_t 
# 672
offset = 0, cudaMemcpyKind 
# 673
kind = cudaMemcpyHostToDevice) 
# 675
{ 
# 676
return ::cudaMemcpyToSymbol_ptds((const void *)(&symbol), src, count, offset, kind); 
# 677
} 
# 719 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 720
cudaMemcpyToSymbolAsync_ptsz(const T &
# 721
symbol, const void *
# 722
src, size_t 
# 723
count, size_t 
# 724
offset = 0, cudaMemcpyKind 
# 725
kind = cudaMemcpyHostToDevice, cudaStream_t 
# 726
stream = 0) 
# 728
{ 
# 729
return ::cudaMemcpyToSymbolAsync_ptsz((const void *)(&symbol), src, count, offset, kind, stream); 
# 730
} 
# 765 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 766
cudaMemcpyFromSymbol_ptds(void *
# 767
dst, const T &
# 768
symbol, size_t 
# 769
count, size_t 
# 770
offset = 0, cudaMemcpyKind 
# 771
kind = cudaMemcpyDeviceToHost) 
# 773
{ 
# 774
return ::cudaMemcpyFromSymbol_ptds(dst, (const void *)(&symbol), count, offset, kind); 
# 775
} 
# 817 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 818
cudaMemcpyFromSymbolAsync_ptsz(void *
# 819
dst, const T &
# 820
symbol, size_t 
# 821
count, size_t 
# 822
offset = 0, cudaMemcpyKind 
# 823
kind = cudaMemcpyDeviceToHost, cudaStream_t 
# 824
stream = 0) 
# 826
{ 
# 827
return ::cudaMemcpyFromSymbolAsync_ptsz(dst, (const void *)(&symbol), count, offset, kind, stream); 
# 828
} 
# 851 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 852
cudaGetSymbolAddress(void **
# 853
devPtr, const T &
# 854
symbol) 
# 856
{ 
# 857
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
# 858
} 
# 881 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 882
cudaGetSymbolSize(size_t *
# 883
size, const T &
# 884
symbol) 
# 886
{ 
# 887
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
# 888
} 
# 923 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 924
cudaBindTexture(size_t *
# 925
offset, const texture< T, dim, readMode>  &
# 926
tex, const void *
# 927
devPtr, const cudaChannelFormatDesc &
# 928
desc, size_t 
# 929
size = ((2147483647) * 2U) + 1U) 
# 931 "/usr/local/cuda-9.0/include/cuda_runtime.h"
{ 
# 932
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
# 933
} 
# 967 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 968
cudaBindTexture(size_t *
# 969
offset, const texture< T, dim, readMode>  &
# 970
tex, const void *
# 971
devPtr, size_t 
# 972
size = ((2147483647) * 2U) + 1U) 
# 974 "/usr/local/cuda-9.0/include/cuda_runtime.h"
{ 
# 975
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
# 976
} 
# 1022 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1023
cudaBindTexture2D(size_t *
# 1024
offset, const texture< T, dim, readMode>  &
# 1025
tex, const void *
# 1026
devPtr, const cudaChannelFormatDesc &
# 1027
desc, size_t 
# 1028
width, size_t 
# 1029
height, size_t 
# 1030
pitch) 
# 1032
{ 
# 1033
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
# 1034
} 
# 1079 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1080
cudaBindTexture2D(size_t *
# 1081
offset, const texture< T, dim, readMode>  &
# 1082
tex, const void *
# 1083
devPtr, size_t 
# 1084
width, size_t 
# 1085
height, size_t 
# 1086
pitch) 
# 1088
{ 
# 1089
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
# 1090
} 
# 1120 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1121
cudaBindTextureToArray(const texture< T, dim, readMode>  &
# 1122
tex, cudaArray_const_t 
# 1123
array, const cudaChannelFormatDesc &
# 1124
desc) 
# 1126
{ 
# 1127
return ::cudaBindTextureToArray(&tex, array, &desc); 
# 1128
} 
# 1157 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1158
cudaBindTextureToArray(const texture< T, dim, readMode>  &
# 1159
tex, cudaArray_const_t 
# 1160
array) 
# 1162
{ 
# 1163
cudaChannelFormatDesc desc; 
# 1164
cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
# 1166
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
# 1167
} 
# 1197 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1198
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
# 1199
tex, cudaMipmappedArray_const_t 
# 1200
mipmappedArray, const cudaChannelFormatDesc &
# 1201
desc) 
# 1203
{ 
# 1204
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
# 1205
} 
# 1234 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1235
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
# 1236
tex, cudaMipmappedArray_const_t 
# 1237
mipmappedArray) 
# 1239
{ 
# 1240
cudaChannelFormatDesc desc; 
# 1241
cudaArray_t levelArray; 
# 1242
cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
# 1244
if (err != (cudaSuccess)) { 
# 1245
return err; 
# 1246
}  
# 1247
err = ::cudaGetChannelDesc(&desc, levelArray); 
# 1249
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
# 1250
} 
# 1273 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1274
cudaUnbindTexture(const texture< T, dim, readMode>  &
# 1275
tex) 
# 1277
{ 
# 1278
return ::cudaUnbindTexture(&tex); 
# 1279
} 
# 1307 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1308
cudaGetTextureAlignmentOffset(size_t *
# 1309
offset, const texture< T, dim, readMode>  &
# 1310
tex) 
# 1312
{ 
# 1313
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
# 1314
} 
# 1359 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1360
cudaFuncSetCacheConfig(T *
# 1361
func, cudaFuncCache 
# 1362
cacheConfig) 
# 1364
{ 
# 1365
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
# 1366
} 
# 1368
template< class T> static inline cudaError_t 
# 1369
cudaFuncSetSharedMemConfig(T *
# 1370
func, cudaSharedMemConfig 
# 1371
config) 
# 1373
{ 
# 1374
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
# 1375
} 
# 1404 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 1405
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *
# 1406
numBlocks, T 
# 1407
func, int 
# 1408
blockSize, size_t 
# 1409
dynamicSMemSize) 
# 1410
{ 
# 1411
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, 0); 
# 1412
} 
# 1455 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 1456
cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *
# 1457
numBlocks, T 
# 1458
func, int 
# 1459
blockSize, size_t 
# 1460
dynamicSMemSize, unsigned 
# 1461
flags) 
# 1462
{ 
# 1463
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, flags); 
# 1464
} 
# 1469
class __cudaOccupancyB2DHelper { 
# 1470
size_t n; 
# 1472
public: __cudaOccupancyB2DHelper(size_t n_) : n(n_) { } 
# 1473
size_t operator()(int) 
# 1474
{ 
# 1475
return n; 
# 1476
} 
# 1477
}; 
# 1524 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class UnaryFunction, class T> static inline cudaError_t 
# 1525
cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int *
# 1526
minGridSize, int *
# 1527
blockSize, T 
# 1528
func, UnaryFunction 
# 1529
blockSizeToDynamicSMemSize, int 
# 1530
blockSizeLimit = 0, unsigned 
# 1531
flags = 0) 
# 1532
{ 
# 1533
cudaError_t status; 
# 1536
int device; 
# 1537
cudaFuncAttributes attr; 
# 1540
int maxThreadsPerMultiProcessor; 
# 1541
int warpSize; 
# 1542
int devMaxThreadsPerBlock; 
# 1543
int multiProcessorCount; 
# 1544
int funcMaxThreadsPerBlock; 
# 1545
int occupancyLimit; 
# 1546
int granularity; 
# 1549
int maxBlockSize = 0; 
# 1550
int numBlocks = 0; 
# 1551
int maxOccupancy = 0; 
# 1554
int blockSizeToTryAligned; 
# 1555
int blockSizeToTry; 
# 1556
int blockSizeLimitAligned; 
# 1557
int occupancyInBlocks; 
# 1558
int occupancyInThreads; 
# 1559
size_t dynamicSMemSize; 
# 1565
if (((!minGridSize) || (!blockSize)) || (!func)) { 
# 1566
return cudaErrorInvalidValue; 
# 1567
}  
# 1573
status = ::cudaGetDevice(&device); 
# 1574
if (status != (cudaSuccess)) { 
# 1575
return status; 
# 1576
}  
# 1578
status = cudaDeviceGetAttribute(&maxThreadsPerMultiProcessor, cudaDevAttrMaxThreadsPerMultiProcessor, device); 
# 1582
if (status != (cudaSuccess)) { 
# 1583
return status; 
# 1584
}  
# 1586
status = cudaDeviceGetAttribute(&warpSize, cudaDevAttrWarpSize, device); 
# 1590
if (status != (cudaSuccess)) { 
# 1591
return status; 
# 1592
}  
# 1594
status = cudaDeviceGetAttribute(&devMaxThreadsPerBlock, cudaDevAttrMaxThreadsPerBlock, device); 
# 1598
if (status != (cudaSuccess)) { 
# 1599
return status; 
# 1600
}  
# 1602
status = cudaDeviceGetAttribute(&multiProcessorCount, cudaDevAttrMultiProcessorCount, device); 
# 1606
if (status != (cudaSuccess)) { 
# 1607
return status; 
# 1608
}  
# 1610
status = cudaFuncGetAttributes(&attr, func); 
# 1611
if (status != (cudaSuccess)) { 
# 1612
return status; 
# 1613
}  
# 1615
funcMaxThreadsPerBlock = (attr.maxThreadsPerBlock); 
# 1621
occupancyLimit = maxThreadsPerMultiProcessor; 
# 1622
granularity = warpSize; 
# 1624
if (blockSizeLimit == 0) { 
# 1625
blockSizeLimit = devMaxThreadsPerBlock; 
# 1626
}  
# 1628
if (devMaxThreadsPerBlock < blockSizeLimit) { 
# 1629
blockSizeLimit = devMaxThreadsPerBlock; 
# 1630
}  
# 1632
if (funcMaxThreadsPerBlock < blockSizeLimit) { 
# 1633
blockSizeLimit = funcMaxThreadsPerBlock; 
# 1634
}  
# 1636
blockSizeLimitAligned = (((blockSizeLimit + (granularity - 1)) / granularity) * granularity); 
# 1638
for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) { 
# 1642
if (blockSizeLimit < blockSizeToTryAligned) { 
# 1643
blockSizeToTry = blockSizeLimit; 
# 1644
} else { 
# 1645
blockSizeToTry = blockSizeToTryAligned; 
# 1646
}  
# 1648
dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry); 
# 1650
status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&occupancyInBlocks, func, blockSizeToTry, dynamicSMemSize, flags); 
# 1657
if (status != (cudaSuccess)) { 
# 1658
return status; 
# 1659
}  
# 1661
occupancyInThreads = (blockSizeToTry * occupancyInBlocks); 
# 1663
if (occupancyInThreads > maxOccupancy) { 
# 1664
maxBlockSize = blockSizeToTry; 
# 1665
numBlocks = occupancyInBlocks; 
# 1666
maxOccupancy = occupancyInThreads; 
# 1667
}  
# 1671
if (occupancyLimit == maxOccupancy) { 
# 1672
break; 
# 1673
}  
# 1674
}  
# 1682
(*minGridSize) = (numBlocks * multiProcessorCount); 
# 1683
(*blockSize) = maxBlockSize; 
# 1685
return status; 
# 1686
} 
# 1719 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class UnaryFunction, class T> static inline cudaError_t 
# 1720
cudaOccupancyMaxPotentialBlockSizeVariableSMem(int *
# 1721
minGridSize, int *
# 1722
blockSize, T 
# 1723
func, UnaryFunction 
# 1724
blockSizeToDynamicSMemSize, int 
# 1725
blockSizeLimit = 0) 
# 1726
{ 
# 1727
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0); 
# 1728
} 
# 1764 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1765
cudaOccupancyMaxPotentialBlockSize(int *
# 1766
minGridSize, int *
# 1767
blockSize, T 
# 1768
func, size_t 
# 1769
dynamicSMemSize = 0, int 
# 1770
blockSizeLimit = 0) 
# 1771
{ 
# 1772
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, 0); 
# 1773
} 
# 1823 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1824
cudaOccupancyMaxPotentialBlockSizeWithFlags(int *
# 1825
minGridSize, int *
# 1826
blockSize, T 
# 1827
func, size_t 
# 1828
dynamicSMemSize = 0, int 
# 1829
blockSizeLimit = 0, unsigned 
# 1830
flags = 0) 
# 1831
{ 
# 1832
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, flags); 
# 1833
} 
# 1874 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1875
cudaLaunch_ptsz(T *
# 1876
func) 
# 1878
{ 
# 1879
return ::cudaLaunch_ptsz((const void *)func); 
# 1880
} 
# 1911 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 1912
cudaFuncGetAttributes(cudaFuncAttributes *
# 1913
attr, T *
# 1914
entry) 
# 1916
{ 
# 1917
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
# 1918
} 
# 1953 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1954
cudaFuncSetAttribute(T *
# 1955
entry, cudaFuncAttribute 
# 1956
attr, int 
# 1957
value) 
# 1959
{ 
# 1960
return ::cudaFuncSetAttribute((const void *)entry, attr, value); 
# 1961
} 
# 1983 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim> static inline cudaError_t 
# 1984
cudaBindSurfaceToArray(const surface< T, dim>  &
# 1985
surf, cudaArray_const_t 
# 1986
array, const cudaChannelFormatDesc &
# 1987
desc) 
# 1989
{ 
# 1990
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
# 1991
} 
# 2012 "/usr/local/cuda-9.0/include/cuda_runtime.h"
template< class T, int dim> static inline cudaError_t 
# 2013
cudaBindSurfaceToArray(const surface< T, dim>  &
# 2014
surf, cudaArray_const_t 
# 2015
array) 
# 2017
{ 
# 2018
cudaChannelFormatDesc desc; 
# 2019
cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
# 2021
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
# 2022
} 
# 2033 "/usr/local/cuda-9.0/include/cuda_runtime.h"
#pragma GCC diagnostic pop
# 48 "/usr/include/stdint.h" 3
typedef unsigned char uint8_t; 
# 49
typedef unsigned short uint16_t; 
# 51
typedef unsigned uint32_t; 
# 55
typedef unsigned long uint64_t; 
# 65 "/usr/include/stdint.h" 3
typedef signed char int_least8_t; 
# 66
typedef short int_least16_t; 
# 67
typedef int int_least32_t; 
# 69
typedef long int_least64_t; 
# 76
typedef unsigned char uint_least8_t; 
# 77
typedef unsigned short uint_least16_t; 
# 78
typedef unsigned uint_least32_t; 
# 80
typedef unsigned long uint_least64_t; 
# 90 "/usr/include/stdint.h" 3
typedef signed char int_fast8_t; 
# 92
typedef long int_fast16_t; 
# 93
typedef long int_fast32_t; 
# 94
typedef long int_fast64_t; 
# 103 "/usr/include/stdint.h" 3
typedef unsigned char uint_fast8_t; 
# 105
typedef unsigned long uint_fast16_t; 
# 106
typedef unsigned long uint_fast32_t; 
# 107
typedef unsigned long uint_fast64_t; 
# 119 "/usr/include/stdint.h" 3
typedef long intptr_t; 
# 122
typedef unsigned long uintptr_t; 
# 134 "/usr/include/stdint.h" 3
typedef long intmax_t; 
# 135
typedef unsigned long uintmax_t; 
# 59 "/usr/local/cuda-9.0/include/cuda.h"
typedef uint32_t cuuint32_t; 
# 60
typedef uint64_t cuuint64_t; 
# 216 "/usr/local/cuda-9.0/include/cuda.h"
extern "C" {
# 226 "/usr/local/cuda-9.0/include/cuda.h"
typedef unsigned long long CUdeviceptr; 
# 233
typedef int CUdevice; 
# 234
typedef struct CUctx_st *CUcontext; 
# 235
typedef struct CUmod_st *CUmodule; 
# 236
typedef struct CUfunc_st *CUfunction; 
# 237
typedef struct CUarray_st *CUarray; 
# 238
typedef struct CUmipmappedArray_st *CUmipmappedArray; 
# 239
typedef struct CUtexref_st *CUtexref; 
# 240
typedef struct CUsurfref_st *CUsurfref; 
# 241
typedef CUevent_st *CUevent; 
# 242
typedef CUstream_st *CUstream; 
# 243
typedef struct CUgraphicsResource_st *CUgraphicsResource; 
# 244
typedef unsigned long long CUtexObject; 
# 245
typedef unsigned long long CUsurfObject; 
# 249
typedef 
# 247
struct CUuuid_st { 
# 248
char bytes[16]; 
# 249
} CUuuid; 
# 264 "/usr/local/cuda-9.0/include/cuda.h"
typedef 
# 262
struct CUipcEventHandle_st { 
# 263
char reserved[64]; 
# 264
} CUipcEventHandle; 
# 271
typedef 
# 269
struct CUipcMemHandle_st { 
# 270
char reserved[64]; 
# 271
} CUipcMemHandle; 
# 278
typedef 
# 276
enum CUipcMem_flags_enum { 
# 277
CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 1
# 278
} CUipcMem_flags; 
# 289
typedef 
# 285
enum CUmemAttach_flags_enum { 
# 286
CU_MEM_ATTACH_GLOBAL = 1, 
# 287
CU_MEM_ATTACH_HOST, 
# 288
CU_MEM_ATTACH_SINGLE = 4
# 289
} CUmemAttach_flags; 
# 306
typedef 
# 294
enum CUctx_flags_enum { 
# 295
CU_CTX_SCHED_AUTO, 
# 296
CU_CTX_SCHED_SPIN, 
# 297
CU_CTX_SCHED_YIELD, 
# 298
CU_CTX_SCHED_BLOCKING_SYNC = 4, 
# 299
CU_CTX_BLOCKING_SYNC = 4, 
# 302
CU_CTX_SCHED_MASK = 7, 
# 303
CU_CTX_MAP_HOST, 
# 304
CU_CTX_LMEM_RESIZE_TO_MAX = 16, 
# 305
CU_CTX_FLAGS_MASK = 31
# 306
} CUctx_flags; 
# 314
typedef 
# 311
enum CUstream_flags_enum { 
# 312
CU_STREAM_DEFAULT, 
# 313
CU_STREAM_NON_BLOCKING
# 314
} CUstream_flags; 
# 344 "/usr/local/cuda-9.0/include/cuda.h"
typedef 
# 339
enum CUevent_flags_enum { 
# 340
CU_EVENT_DEFAULT, 
# 341
CU_EVENT_BLOCKING_SYNC, 
# 342
CU_EVENT_DISABLE_TIMING, 
# 343
CU_EVENT_INTERPROCESS = 4
# 344
} CUevent_flags; 
# 367
typedef 
# 350
enum CUstreamWaitValue_flags_enum { 
# 351
CU_STREAM_WAIT_VALUE_GEQ, 
# 354
CU_STREAM_WAIT_VALUE_EQ, 
# 355
CU_STREAM_WAIT_VALUE_AND, 
# 356
CU_STREAM_WAIT_VALUE_NOR, 
# 360
CU_STREAM_WAIT_VALUE_FLUSH = 1073741824
# 367
} CUstreamWaitValue_flags; 
# 380
typedef 
# 372
enum CUstreamWriteValue_flags_enum { 
# 373
CU_STREAM_WRITE_VALUE_DEFAULT, 
# 374
CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER
# 380
} CUstreamWriteValue_flags; 
# 392
typedef 
# 385
enum CUstreamBatchMemOpType_enum { 
# 386
CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1, 
# 387
CU_STREAM_MEM_OP_WRITE_VALUE_32, 
# 388
CU_STREAM_MEM_OP_WAIT_VALUE_64 = 4, 
# 389
CU_STREAM_MEM_OP_WRITE_VALUE_64, 
# 390
CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3
# 392
} CUstreamBatchMemOpType; 
# 424
typedef 
# 397
union CUstreamBatchMemOpParams_union { 
# 398
CUstreamBatchMemOpType operation; 
# 399
struct CUstreamMemOpWaitValueParams_st { 
# 400
CUstreamBatchMemOpType operation; 
# 401
CUdeviceptr address; 
# 402
union { 
# 403
cuuint32_t value; 
# 404
cuuint64_t value64; 
# 405
}; 
# 406
unsigned flags; 
# 407
CUdeviceptr alias; 
# 408
} waitValue; 
# 409
struct CUstreamMemOpWriteValueParams_st { 
# 410
CUstreamBatchMemOpType operation; 
# 411
CUdeviceptr address; 
# 412
union { 
# 413
cuuint32_t value; 
# 414
cuuint64_t value64; 
# 415
}; 
# 416
unsigned flags; 
# 417
CUdeviceptr alias; 
# 418
} writeValue; 
# 419
struct CUstreamMemOpFlushRemoteWritesParams_st { 
# 420
CUstreamBatchMemOpType operation; 
# 421
unsigned flags; 
# 422
} flushRemoteWrites; 
# 423
cuuint64_t pad[6]; 
# 424
} CUstreamBatchMemOpParams; 
# 433
typedef 
# 430
enum CUoccupancy_flags_enum { 
# 431
CU_OCCUPANCY_DEFAULT, 
# 432
CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE
# 433
} CUoccupancy_flags; 
# 447
typedef 
# 438
enum CUarray_format_enum { 
# 439
CU_AD_FORMAT_UNSIGNED_INT8 = 1, 
# 440
CU_AD_FORMAT_UNSIGNED_INT16, 
# 441
CU_AD_FORMAT_UNSIGNED_INT32, 
# 442
CU_AD_FORMAT_SIGNED_INT8 = 8, 
# 443
CU_AD_FORMAT_SIGNED_INT16, 
# 444
CU_AD_FORMAT_SIGNED_INT32, 
# 445
CU_AD_FORMAT_HALF = 16, 
# 446
CU_AD_FORMAT_FLOAT = 32
# 447
} CUarray_format; 
# 457
typedef 
# 452
enum CUaddress_mode_enum { 
# 453
CU_TR_ADDRESS_MODE_WRAP, 
# 454
CU_TR_ADDRESS_MODE_CLAMP, 
# 455
CU_TR_ADDRESS_MODE_MIRROR, 
# 456
CU_TR_ADDRESS_MODE_BORDER
# 457
} CUaddress_mode; 
# 465
typedef 
# 462
enum CUfilter_mode_enum { 
# 463
CU_TR_FILTER_MODE_POINT, 
# 464
CU_TR_FILTER_MODE_LINEAR
# 465
} CUfilter_mode; 
# 574
typedef 
# 470
enum CUdevice_attribute_enum { 
# 471
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1, 
# 472
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X, 
# 473
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y, 
# 474
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z, 
# 475
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X, 
# 476
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y, 
# 477
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z, 
# 478
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK, 
# 479
CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8, 
# 480
CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY, 
# 481
CU_DEVICE_ATTRIBUTE_WARP_SIZE, 
# 482
CU_DEVICE_ATTRIBUTE_MAX_PITCH, 
# 483
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK, 
# 484
CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12, 
# 485
CU_DEVICE_ATTRIBUTE_CLOCK_RATE, 
# 486
CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT, 
# 487
CU_DEVICE_ATTRIBUTE_GPU_OVERLAP, 
# 488
CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, 
# 489
CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT, 
# 490
CU_DEVICE_ATTRIBUTE_INTEGRATED, 
# 491
CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY, 
# 492
CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, 
# 493
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH, 
# 494
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH, 
# 495
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT, 
# 496
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH, 
# 497
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT, 
# 498
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH, 
# 499
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH, 
# 500
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT, 
# 501
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS, 
# 502
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27, 
# 503
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT, 
# 504
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES, 
# 505
CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT, 
# 506
CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS, 
# 507
CU_DEVICE_ATTRIBUTE_ECC_ENABLED, 
# 508
CU_DEVICE_ATTRIBUTE_PCI_BUS_ID, 
# 509
CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID, 
# 510
CU_DEVICE_ATTRIBUTE_TCC_DRIVER, 
# 511
CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE, 
# 512
CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH, 
# 513
CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE, 
# 514
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR, 
# 515
CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT, 
# 516
CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING, 
# 517
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH, 
# 518
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS, 
# 519
CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER, 
# 520
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH, 
# 521
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT, 
# 522
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE, 
# 523
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE, 
# 524
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE, 
# 525
CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID, 
# 526
CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT, 
# 527
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH, 
# 528
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH, 
# 529
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS, 
# 530
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH, 
# 531
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH, 
# 532
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT, 
# 533
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH, 
# 534
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT, 
# 535
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH, 
# 536
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH, 
# 537
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS, 
# 538
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH, 
# 539
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT, 
# 540
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS, 
# 541
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH, 
# 542
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH, 
# 543
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS, 
# 544
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH, 
# 545
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH, 
# 546
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT, 
# 547
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH, 
# 548
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH, 
# 549
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT, 
# 550
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, 
# 551
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, 
# 552
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH, 
# 553
CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED, 
# 554
CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED, 
# 555
CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED, 
# 556
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR, 
# 557
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR, 
# 558
CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY, 
# 559
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD, 
# 560
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID, 
# 561
CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED, 
# 562
CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO, 
# 563
CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS, 
# 564
CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS, 
# 565
CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED, 
# 566
CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM, 
# 567
CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS, 
# 568
CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS, 
# 569
CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR, 
# 570
CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH, 
# 571
CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH, 
# 572
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN, 
# 573
CU_DEVICE_ATTRIBUTE_MAX
# 574
} CUdevice_attribute; 
# 590
typedef 
# 579
struct CUdevprop_st { 
# 580
int maxThreadsPerBlock; 
# 581
int maxThreadsDim[3]; 
# 582
int maxGridSize[3]; 
# 583
int sharedMemPerBlock; 
# 584
int totalConstantMemory; 
# 585
int SIMDWidth; 
# 586
int memPitch; 
# 587
int regsPerBlock; 
# 588
int clockRate; 
# 589
int textureAlign; 
# 590
} CUdevprop; 
# 604
typedef 
# 595
enum CUpointer_attribute_enum { 
# 596
CU_POINTER_ATTRIBUTE_CONTEXT = 1, 
# 597
CU_POINTER_ATTRIBUTE_MEMORY_TYPE, 
# 598
CU_POINTER_ATTRIBUTE_DEVICE_POINTER, 
# 599
CU_POINTER_ATTRIBUTE_HOST_POINTER, 
# 600
CU_POINTER_ATTRIBUTE_P2P_TOKENS, 
# 601
CU_POINTER_ATTRIBUTE_SYNC_MEMOPS, 
# 602
CU_POINTER_ATTRIBUTE_BUFFER_ID, 
# 603
CU_POINTER_ATTRIBUTE_IS_MANAGED
# 604
} CUpointer_attribute; 
# 679 "/usr/local/cuda-9.0/include/cuda.h"
typedef 
# 609 "/usr/local/cuda-9.0/include/cuda.h"
enum CUfunction_attribute_enum { 
# 615
CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, 
# 622
CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES, 
# 628
CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES, 
# 633
CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES, 
# 638
CU_FUNC_ATTRIBUTE_NUM_REGS, 
# 647 "/usr/local/cuda-9.0/include/cuda.h"
CU_FUNC_ATTRIBUTE_PTX_VERSION, 
# 656 "/usr/local/cuda-9.0/include/cuda.h"
CU_FUNC_ATTRIBUTE_BINARY_VERSION, 
# 662
CU_FUNC_ATTRIBUTE_CACHE_MODE_CA, 
# 669
CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES, 
# 676
CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT, 
# 678
CU_FUNC_ATTRIBUTE_MAX
# 679
} CUfunction_attribute; 
# 689
typedef 
# 684
enum CUfunc_cache_enum { 
# 685
CU_FUNC_CACHE_PREFER_NONE, 
# 686
CU_FUNC_CACHE_PREFER_SHARED, 
# 687
CU_FUNC_CACHE_PREFER_L1, 
# 688
CU_FUNC_CACHE_PREFER_EQUAL
# 689
} CUfunc_cache; 
# 698
typedef 
# 694
enum CUsharedconfig_enum { 
# 695
CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE, 
# 696
CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE, 
# 697
CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE
# 698
} CUsharedconfig; 
# 707
typedef 
# 703
enum CUshared_carveout_enum { 
# 704
CU_SHAREDMEM_CARVEOUT_DEFAULT = (-1), 
# 705
CU_SHAREDMEM_CARVEOUT_MAX_SHARED = 100, 
# 706
CU_SHAREDMEM_CARVEOUT_MAX_L1 = 0
# 707
} CUshared_carveout; 
# 717
typedef 
# 712
enum CUmemorytype_enum { 
# 713
CU_MEMORYTYPE_HOST = 1, 
# 714
CU_MEMORYTYPE_DEVICE, 
# 715
CU_MEMORYTYPE_ARRAY, 
# 716
CU_MEMORYTYPE_UNIFIED
# 717
} CUmemorytype; 
# 726
typedef 
# 722
enum CUcomputemode_enum { 
# 723
CU_COMPUTEMODE_DEFAULT, 
# 724
CU_COMPUTEMODE_PROHIBITED = 2, 
# 725
CU_COMPUTEMODE_EXCLUSIVE_PROCESS
# 726
} CUcomputemode; 
# 738
typedef 
# 731
enum CUmem_advise_enum { 
# 732
CU_MEM_ADVISE_SET_READ_MOSTLY = 1, 
# 733
CU_MEM_ADVISE_UNSET_READ_MOSTLY, 
# 734
CU_MEM_ADVISE_SET_PREFERRED_LOCATION, 
# 735
CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION, 
# 736
CU_MEM_ADVISE_SET_ACCESSED_BY, 
# 737
CU_MEM_ADVISE_UNSET_ACCESSED_BY
# 738
} CUmem_advise; 
# 745
typedef 
# 740
enum CUmem_range_attribute_enum { 
# 741
CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = 1, 
# 742
CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION, 
# 743
CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY, 
# 744
CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION
# 745
} CUmem_range_attribute; 
# 889 "/usr/local/cuda-9.0/include/cuda.h"
typedef 
# 750 "/usr/local/cuda-9.0/include/cuda.h"
enum CUjit_option_enum { 
# 757
CU_JIT_MAX_REGISTERS, 
# 772 "/usr/local/cuda-9.0/include/cuda.h"
CU_JIT_THREADS_PER_BLOCK, 
# 780
CU_JIT_WALL_TIME, 
# 789 "/usr/local/cuda-9.0/include/cuda.h"
CU_JIT_INFO_LOG_BUFFER, 
# 798 "/usr/local/cuda-9.0/include/cuda.h"
CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES, 
# 807 "/usr/local/cuda-9.0/include/cuda.h"
CU_JIT_ERROR_LOG_BUFFER, 
# 816 "/usr/local/cuda-9.0/include/cuda.h"
CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES, 
# 824
CU_JIT_OPTIMIZATION_LEVEL, 
# 832
CU_JIT_TARGET_FROM_CUCONTEXT, 
# 840
CU_JIT_TARGET, 
# 849 "/usr/local/cuda-9.0/include/cuda.h"
CU_JIT_FALLBACK_STRATEGY, 
# 857
CU_JIT_GENERATE_DEBUG_INFO, 
# 864
CU_JIT_LOG_VERBOSE, 
# 871
CU_JIT_GENERATE_LINE_INFO, 
# 879
CU_JIT_CACHE_MODE, 
# 884
CU_JIT_NEW_SM3X_OPT, 
# 885
CU_JIT_FAST_COMPILE, 
# 887
CU_JIT_NUM_OPTIONS
# 889
} CUjit_option; 
# 909
typedef 
# 894
enum CUjit_target_enum { 
# 896
CU_TARGET_COMPUTE_20 = 20, 
# 897
CU_TARGET_COMPUTE_21, 
# 898
CU_TARGET_COMPUTE_30 = 30, 
# 899
CU_TARGET_COMPUTE_32 = 32, 
# 900
CU_TARGET_COMPUTE_35 = 35, 
# 901
CU_TARGET_COMPUTE_37 = 37, 
# 902
CU_TARGET_COMPUTE_50 = 50, 
# 903
CU_TARGET_COMPUTE_52 = 52, 
# 904
CU_TARGET_COMPUTE_53, 
# 905
CU_TARGET_COMPUTE_60 = 60, 
# 906
CU_TARGET_COMPUTE_61, 
# 907
CU_TARGET_COMPUTE_62, 
# 908
CU_TARGET_COMPUTE_70 = 70
# 909
} CUjit_target; 
# 920
typedef 
# 914
enum CUjit_fallback_enum { 
# 916
CU_PREFER_PTX, 
# 918
CU_PREFER_BINARY
# 920
} CUjit_fallback; 
# 930
typedef 
# 925
enum CUjit_cacheMode_enum { 
# 927
CU_JIT_CACHE_OPTION_NONE, 
# 928
CU_JIT_CACHE_OPTION_CG, 
# 929
CU_JIT_CACHE_OPTION_CA
# 930
} CUjit_cacheMode; 
# 968
typedef 
# 935
enum CUjitInputType_enum { 
# 941
CU_JIT_INPUT_CUBIN, 
# 947
CU_JIT_INPUT_PTX, 
# 953
CU_JIT_INPUT_FATBINARY, 
# 959
CU_JIT_INPUT_OBJECT, 
# 965
CU_JIT_INPUT_LIBRARY, 
# 967
CU_JIT_NUM_INPUT_TYPES
# 968
} CUjitInputType; 
# 971
typedef struct CUlinkState_st *CUlinkState; 
# 983
typedef 
# 977
enum CUgraphicsRegisterFlags_enum { 
# 978
CU_GRAPHICS_REGISTER_FLAGS_NONE, 
# 979
CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY, 
# 980
CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD, 
# 981
CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4, 
# 982
CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8
# 983
} CUgraphicsRegisterFlags; 
# 992
typedef 
# 988
enum CUgraphicsMapResourceFlags_enum { 
# 989
CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE, 
# 990
CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY, 
# 991
CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD
# 992
} CUgraphicsMapResourceFlags; 
# 1004
typedef 
# 997
enum CUarray_cubemap_face_enum { 
# 998
CU_CUBEMAP_FACE_POSITIVE_X, 
# 999
CU_CUBEMAP_FACE_NEGATIVE_X, 
# 1000
CU_CUBEMAP_FACE_POSITIVE_Y, 
# 1001
CU_CUBEMAP_FACE_NEGATIVE_Y, 
# 1002
CU_CUBEMAP_FACE_POSITIVE_Z, 
# 1003
CU_CUBEMAP_FACE_NEGATIVE_Z
# 1004
} CUarray_cubemap_face; 
# 1016
typedef 
# 1009
enum CUlimit_enum { 
# 1010
CU_LIMIT_STACK_SIZE, 
# 1011
CU_LIMIT_PRINTF_FIFO_SIZE, 
# 1012
CU_LIMIT_MALLOC_HEAP_SIZE, 
# 1013
CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH, 
# 1014
CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT, 
# 1015
CU_LIMIT_MAX
# 1016
} CUlimit; 
# 1026
typedef 
# 1021
enum CUresourcetype_enum { 
# 1022
CU_RESOURCE_TYPE_ARRAY, 
# 1023
CU_RESOURCE_TYPE_MIPMAPPED_ARRAY, 
# 1024
CU_RESOURCE_TYPE_LINEAR, 
# 1025
CU_RESOURCE_TYPE_PITCH2D
# 1026
} CUresourcetype; 
# 1440 "/usr/local/cuda-9.0/include/cuda.h"
typedef 
# 1031 "/usr/local/cuda-9.0/include/cuda.h"
enum cudaError_enum { 
# 1037
CUDA_SUCCESS, 
# 1043
CUDA_ERROR_INVALID_VALUE, 
# 1049
CUDA_ERROR_OUT_OF_MEMORY, 
# 1055
CUDA_ERROR_NOT_INITIALIZED, 
# 1060
CUDA_ERROR_DEINITIALIZED, 
# 1067
CUDA_ERROR_PROFILER_DISABLED, 
# 1075
CUDA_ERROR_PROFILER_NOT_INITIALIZED, 
# 1082
CUDA_ERROR_PROFILER_ALREADY_STARTED, 
# 1089
CUDA_ERROR_PROFILER_ALREADY_STOPPED, 
# 1095
CUDA_ERROR_NO_DEVICE = 100, 
# 1101
CUDA_ERROR_INVALID_DEVICE, 
# 1108
CUDA_ERROR_INVALID_IMAGE = 200, 
# 1118 "/usr/local/cuda-9.0/include/cuda.h"
CUDA_ERROR_INVALID_CONTEXT, 
# 1127 "/usr/local/cuda-9.0/include/cuda.h"
CUDA_ERROR_CONTEXT_ALREADY_CURRENT, 
# 1132
CUDA_ERROR_MAP_FAILED = 205, 
# 1137
CUDA_ERROR_UNMAP_FAILED, 
# 1143
CUDA_ERROR_ARRAY_IS_MAPPED, 
# 1148
CUDA_ERROR_ALREADY_MAPPED, 
# 1156
CUDA_ERROR_NO_BINARY_FOR_GPU, 
# 1161
CUDA_ERROR_ALREADY_ACQUIRED, 
# 1166
CUDA_ERROR_NOT_MAPPED, 
# 1172
CUDA_ERROR_NOT_MAPPED_AS_ARRAY, 
# 1178
CUDA_ERROR_NOT_MAPPED_AS_POINTER, 
# 1184
CUDA_ERROR_ECC_UNCORRECTABLE, 
# 1190
CUDA_ERROR_UNSUPPORTED_LIMIT, 
# 1197
CUDA_ERROR_CONTEXT_ALREADY_IN_USE, 
# 1203
CUDA_ERROR_PEER_ACCESS_UNSUPPORTED, 
# 1208
CUDA_ERROR_INVALID_PTX, 
# 1213
CUDA_ERROR_INVALID_GRAPHICS_CONTEXT, 
# 1219
CUDA_ERROR_NVLINK_UNCORRECTABLE, 
# 1224
CUDA_ERROR_JIT_COMPILER_NOT_FOUND, 
# 1229
CUDA_ERROR_INVALID_SOURCE = 300, 
# 1234
CUDA_ERROR_FILE_NOT_FOUND, 
# 1239
CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND, 
# 1244
CUDA_ERROR_SHARED_OBJECT_INIT_FAILED, 
# 1249
CUDA_ERROR_OPERATING_SYSTEM, 
# 1255
CUDA_ERROR_INVALID_HANDLE = 400, 
# 1261
CUDA_ERROR_NOT_FOUND = 500, 
# 1269
CUDA_ERROR_NOT_READY = 600, 
# 1278 "/usr/local/cuda-9.0/include/cuda.h"
CUDA_ERROR_ILLEGAL_ADDRESS = 700, 
# 1289 "/usr/local/cuda-9.0/include/cuda.h"
CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES, 
# 1299 "/usr/local/cuda-9.0/include/cuda.h"
CUDA_ERROR_LAUNCH_TIMEOUT, 
# 1305
CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING, 
# 1312
CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED, 
# 1319
CUDA_ERROR_PEER_ACCESS_NOT_ENABLED, 
# 1325
CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708, 
# 1332
CUDA_ERROR_CONTEXT_IS_DESTROYED, 
# 1340
CUDA_ERROR_ASSERT, 
# 1347
CUDA_ERROR_TOO_MANY_PEERS, 
# 1353
CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED, 
# 1359
CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED, 
# 1368 "/usr/local/cuda-9.0/include/cuda.h"
CUDA_ERROR_HARDWARE_STACK_ERROR, 
# 1376
CUDA_ERROR_ILLEGAL_INSTRUCTION, 
# 1385 "/usr/local/cuda-9.0/include/cuda.h"
CUDA_ERROR_MISALIGNED_ADDRESS, 
# 1396 "/usr/local/cuda-9.0/include/cuda.h"
CUDA_ERROR_INVALID_ADDRESS_SPACE, 
# 1404
CUDA_ERROR_INVALID_PC, 
# 1414 "/usr/local/cuda-9.0/include/cuda.h"
CUDA_ERROR_LAUNCH_FAILED, 
# 1423 "/usr/local/cuda-9.0/include/cuda.h"
CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE, 
# 1428
CUDA_ERROR_NOT_PERMITTED = 800, 
# 1434
CUDA_ERROR_NOT_SUPPORTED, 
# 1439
CUDA_ERROR_UNKNOWN = 999
# 1440
} CUresult; 
# 1449
typedef 
# 1445
enum CUdevice_P2PAttribute_enum { 
# 1446
CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 1, 
# 1447
CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED, 
# 1448
CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED
# 1449
} CUdevice_P2PAttribute; 
# 1463 "/usr/local/cuda-9.0/include/cuda.h"
typedef void (*CUstreamCallback)(CUstream hStream, CUresult status, void * userData); 
# 1471
typedef size_t (*CUoccupancyB2DSize)(int blockSize); 
# 1547 "/usr/local/cuda-9.0/include/cuda.h"
typedef 
# 1526
struct CUDA_MEMCPY2D_st { 
# 1527
size_t srcXInBytes; 
# 1528
size_t srcY; 
# 1530
CUmemorytype srcMemoryType; 
# 1531
const void *srcHost; 
# 1532
CUdeviceptr srcDevice; 
# 1533
CUarray srcArray; 
# 1534
size_t srcPitch; 
# 1536
size_t dstXInBytes; 
# 1537
size_t dstY; 
# 1539
CUmemorytype dstMemoryType; 
# 1540
void *dstHost; 
# 1541
CUdeviceptr dstDevice; 
# 1542
CUarray dstArray; 
# 1543
size_t dstPitch; 
# 1545
size_t WidthInBytes; 
# 1546
size_t Height; 
# 1547
} CUDA_MEMCPY2D; 
# 1580
typedef 
# 1552
struct CUDA_MEMCPY3D_st { 
# 1553
size_t srcXInBytes; 
# 1554
size_t srcY; 
# 1555
size_t srcZ; 
# 1556
size_t srcLOD; 
# 1557
CUmemorytype srcMemoryType; 
# 1558
const void *srcHost; 
# 1559
CUdeviceptr srcDevice; 
# 1560
CUarray srcArray; 
# 1561
void *reserved0; 
# 1562
size_t srcPitch; 
# 1563
size_t srcHeight; 
# 1565
size_t dstXInBytes; 
# 1566
size_t dstY; 
# 1567
size_t dstZ; 
# 1568
size_t dstLOD; 
# 1569
CUmemorytype dstMemoryType; 
# 1570
void *dstHost; 
# 1571
CUdeviceptr dstDevice; 
# 1572
CUarray dstArray; 
# 1573
void *reserved1; 
# 1574
size_t dstPitch; 
# 1575
size_t dstHeight; 
# 1577
size_t WidthInBytes; 
# 1578
size_t Height; 
# 1579
size_t Depth; 
# 1580
} CUDA_MEMCPY3D; 
# 1613
typedef 
# 1585
struct CUDA_MEMCPY3D_PEER_st { 
# 1586
size_t srcXInBytes; 
# 1587
size_t srcY; 
# 1588
size_t srcZ; 
# 1589
size_t srcLOD; 
# 1590
CUmemorytype srcMemoryType; 
# 1591
const void *srcHost; 
# 1592
CUdeviceptr srcDevice; 
# 1593
CUarray srcArray; 
# 1594
CUcontext srcContext; 
# 1595
size_t srcPitch; 
# 1596
size_t srcHeight; 
# 1598
size_t dstXInBytes; 
# 1599
size_t dstY; 
# 1600
size_t dstZ; 
# 1601
size_t dstLOD; 
# 1602
CUmemorytype dstMemoryType; 
# 1603
void *dstHost; 
# 1604
CUdeviceptr dstDevice; 
# 1605
CUarray dstArray; 
# 1606
CUcontext dstContext; 
# 1607
size_t dstPitch; 
# 1608
size_t dstHeight; 
# 1610
size_t WidthInBytes; 
# 1611
size_t Height; 
# 1612
size_t Depth; 
# 1613
} CUDA_MEMCPY3D_PEER; 
# 1625
typedef 
# 1618
struct CUDA_ARRAY_DESCRIPTOR_st { 
# 1620
size_t Width; 
# 1621
size_t Height; 
# 1623
CUarray_format Format; 
# 1624
unsigned NumChannels; 
# 1625
} CUDA_ARRAY_DESCRIPTOR; 
# 1639
typedef 
# 1630
struct CUDA_ARRAY3D_DESCRIPTOR_st { 
# 1632
size_t Width; 
# 1633
size_t Height; 
# 1634
size_t Depth; 
# 1636
CUarray_format Format; 
# 1637
unsigned NumChannels; 
# 1638
unsigned Flags; 
# 1639
} CUDA_ARRAY3D_DESCRIPTOR; 
# 1679 "/usr/local/cuda-9.0/include/cuda.h"
typedef 
# 1648
struct CUDA_RESOURCE_DESC_st { 
# 1650
CUresourcetype resType; 
# 1652
union { 
# 1653
struct { 
# 1654
CUarray hArray; 
# 1655
} array; 
# 1656
struct { 
# 1657
CUmipmappedArray hMipmappedArray; 
# 1658
} mipmap; 
# 1659
struct { 
# 1660
CUdeviceptr devPtr; 
# 1661
CUarray_format format; 
# 1662
unsigned numChannels; 
# 1663
size_t sizeInBytes; 
# 1664
} linear; 
# 1665
struct { 
# 1666
CUdeviceptr devPtr; 
# 1667
CUarray_format format; 
# 1668
unsigned numChannels; 
# 1669
size_t width; 
# 1670
size_t height; 
# 1671
size_t pitchInBytes; 
# 1672
} pitch2D; 
# 1673
struct { 
# 1674
int reserved[32]; 
# 1675
} reserved; 
# 1676
} res; 
# 1678
unsigned flags; 
# 1679
} CUDA_RESOURCE_DESC; 
# 1695
typedef 
# 1684
struct CUDA_TEXTURE_DESC_st { 
# 1685
CUaddress_mode addressMode[3]; 
# 1686
CUfilter_mode filterMode; 
# 1687
unsigned flags; 
# 1688
unsigned maxAnisotropy; 
# 1689
CUfilter_mode mipmapFilterMode; 
# 1690
float mipmapLevelBias; 
# 1691
float minMipmapLevelClamp; 
# 1692
float maxMipmapLevelClamp; 
# 1693
float borderColor[4]; 
# 1694
int reserved[12]; 
# 1695
} CUDA_TEXTURE_DESC; 
# 1737
typedef 
# 1700
enum CUresourceViewFormat_enum { 
# 1702
CU_RES_VIEW_FORMAT_NONE, 
# 1703
CU_RES_VIEW_FORMAT_UINT_1X8, 
# 1704
CU_RES_VIEW_FORMAT_UINT_2X8, 
# 1705
CU_RES_VIEW_FORMAT_UINT_4X8, 
# 1706
CU_RES_VIEW_FORMAT_SINT_1X8, 
# 1707
CU_RES_VIEW_FORMAT_SINT_2X8, 
# 1708
CU_RES_VIEW_FORMAT_SINT_4X8, 
# 1709
CU_RES_VIEW_FORMAT_UINT_1X16, 
# 1710
CU_RES_VIEW_FORMAT_UINT_2X16, 
# 1711
CU_RES_VIEW_FORMAT_UINT_4X16, 
# 1712
CU_RES_VIEW_FORMAT_SINT_1X16, 
# 1713
CU_RES_VIEW_FORMAT_SINT_2X16, 
# 1714
CU_RES_VIEW_FORMAT_SINT_4X16, 
# 1715
CU_RES_VIEW_FORMAT_UINT_1X32, 
# 1716
CU_RES_VIEW_FORMAT_UINT_2X32, 
# 1717
CU_RES_VIEW_FORMAT_UINT_4X32, 
# 1718
CU_RES_VIEW_FORMAT_SINT_1X32, 
# 1719
CU_RES_VIEW_FORMAT_SINT_2X32, 
# 1720
CU_RES_VIEW_FORMAT_SINT_4X32, 
# 1721
CU_RES_VIEW_FORMAT_FLOAT_1X16, 
# 1722
CU_RES_VIEW_FORMAT_FLOAT_2X16, 
# 1723
CU_RES_VIEW_FORMAT_FLOAT_4X16, 
# 1724
CU_RES_VIEW_FORMAT_FLOAT_1X32, 
# 1725
CU_RES_VIEW_FORMAT_FLOAT_2X32, 
# 1726
CU_RES_VIEW_FORMAT_FLOAT_4X32, 
# 1727
CU_RES_VIEW_FORMAT_UNSIGNED_BC1, 
# 1728
CU_RES_VIEW_FORMAT_UNSIGNED_BC2, 
# 1729
CU_RES_VIEW_FORMAT_UNSIGNED_BC3, 
# 1730
CU_RES_VIEW_FORMAT_UNSIGNED_BC4, 
# 1731
CU_RES_VIEW_FORMAT_SIGNED_BC4, 
# 1732
CU_RES_VIEW_FORMAT_UNSIGNED_BC5, 
# 1733
CU_RES_VIEW_FORMAT_SIGNED_BC5, 
# 1734
CU_RES_VIEW_FORMAT_UNSIGNED_BC6H, 
# 1735
CU_RES_VIEW_FORMAT_SIGNED_BC6H, 
# 1736
CU_RES_VIEW_FORMAT_UNSIGNED_BC7
# 1737
} CUresourceViewFormat; 
# 1753
typedef 
# 1742
struct CUDA_RESOURCE_VIEW_DESC_st { 
# 1744
CUresourceViewFormat format; 
# 1745
size_t width; 
# 1746
size_t height; 
# 1747
size_t depth; 
# 1748
unsigned firstMipmapLevel; 
# 1749
unsigned lastMipmapLevel; 
# 1750
unsigned firstLayer; 
# 1751
unsigned lastLayer; 
# 1752
unsigned reserved[16]; 
# 1753
} CUDA_RESOURCE_VIEW_DESC; 
# 1761
typedef 
# 1758
struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st { 
# 1759
unsigned long long p2pToken; 
# 1760
unsigned vaSpaceToken; 
# 1761
} CUDA_POINTER_ATTRIBUTE_P2P_TOKENS; 
# 1781 "/usr/local/cuda-9.0/include/cuda.h"
typedef 
# 1770
struct CUDA_LAUNCH_PARAMS_st { 
# 1771
CUfunction function; 
# 1772
unsigned gridDimX; 
# 1773
unsigned gridDimY; 
# 1774
unsigned gridDimZ; 
# 1775
unsigned blockDimX; 
# 1776
unsigned blockDimY; 
# 1777
unsigned blockDimZ; 
# 1778
unsigned sharedMemBytes; 
# 1779
CUstream hStream; 
# 1780
void **kernelParams; 
# 1781
} CUDA_LAUNCH_PARAMS; 
# 1944 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuGetErrorString(CUresult error, const char ** pStr); 
# 1965 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuGetErrorName(CUresult error, const char ** pStr); 
# 1997 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuInit(unsigned Flags); 
# 2031 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDriverGetVersion(int * driverVersion); 
# 2071 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceGet(CUdevice * device, int ordinal); 
# 2097 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceGetCount(int * count); 
# 2126 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceGetName(char * name, int len, CUdevice dev); 
# 2154 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceTotalMem_v2(size_t * bytes, CUdevice dev); 
# 2355 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceGetAttribute(int * pi, CUdevice_attribute attrib, CUdevice dev); 
# 2432 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceGetProperties(CUdevprop * prop, CUdevice dev); 
# 2465 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceComputeCapability(int * major, int * minor, CUdevice dev); 
# 2533 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDevicePrimaryCtxRetain(CUcontext * pctx, CUdevice dev); 
# 2567 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDevicePrimaryCtxRelease(CUdevice dev); 
# 2631 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDevicePrimaryCtxSetFlags(CUdevice dev, unsigned flags); 
# 2657 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDevicePrimaryCtxGetState(CUdevice dev, unsigned * flags, int * active); 
# 2695 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDevicePrimaryCtxReset(CUdevice dev); 
# 2801 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxCreate_v2(CUcontext * pctx, unsigned flags, CUdevice dev); 
# 2841 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxDestroy_v2(CUcontext ctx); 
# 2877 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxPushCurrent_v2(CUcontext ctx); 
# 2911 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxPopCurrent_v2(CUcontext * pctx); 
# 2941 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxSetCurrent(CUcontext ctx); 
# 2964 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxGetCurrent(CUcontext * pctx); 
# 2995 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxGetDevice(CUdevice * device); 
# 3024 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxGetFlags(unsigned * flags); 
# 3055 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxSynchronize(); 
# 3140 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxSetLimit(CUlimit limit, size_t value); 
# 3180 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxGetLimit(size_t * pvalue, CUlimit limit); 
# 3224 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxGetCacheConfig(CUfunc_cache * pconfig); 
# 3275 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxSetCacheConfig(CUfunc_cache config); 
# 3318 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxGetSharedMemConfig(CUsharedconfig * pConfig); 
# 3371 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxSetSharedMemConfig(CUsharedconfig config); 
# 3409 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxGetApiVersion(CUcontext ctx, unsigned * version); 
# 3449 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
# 3504 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxAttach(CUcontext * pctx, unsigned flags); 
# 3540 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxDetach(CUcontext ctx); 
# 3595 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuModuleLoad(CUmodule * module, const char * fname); 
# 3632 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuModuleLoadData(CUmodule * module, const void * image); 
# 3675 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuModuleLoadDataEx(CUmodule * module, const void * image, unsigned numOptions, CUjit_option * options, void ** optionValues); 
# 3717 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuModuleLoadFatBinary(CUmodule * module, const void * fatCubin); 
# 3742 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuModuleUnload(CUmodule hmod); 
# 3772 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuModuleGetFunction(CUfunction * hfunc, CUmodule hmod, const char * name); 
# 3808 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuModuleGetGlobal_v2(CUdeviceptr * dptr, size_t * bytes, CUmodule hmod, const char * name); 
# 3843 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuModuleGetTexRef(CUtexref * pTexRef, CUmodule hmod, const char * name); 
# 3875 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuModuleGetSurfRef(CUsurfref * pSurfRef, CUmodule hmod, const char * name); 
# 3918 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLinkCreate_v2(unsigned numOptions, CUjit_option * options, void ** optionValues, CUlinkState * stateOut); 
# 3955 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLinkAddData_v2(CUlinkState state, CUjitInputType type, void * data, size_t size, const char * name, unsigned numOptions, CUjit_option * options, void ** optionValues); 
# 3994 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLinkAddFile_v2(CUlinkState state, CUjitInputType type, const char * path, unsigned numOptions, CUjit_option * options, void ** optionValues); 
# 4021 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLinkComplete(CUlinkState state, void ** cubinOut, size_t * sizeOut); 
# 4035 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLinkDestroy(CUlinkState state); 
# 4084 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemGetInfo_v2(size_t * free, size_t * total); 
# 4118 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemAlloc_v2(CUdeviceptr * dptr, size_t bytesize); 
# 4180 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemAllocPitch_v2(CUdeviceptr * dptr, size_t * pPitch, size_t WidthInBytes, size_t Height, unsigned ElementSizeBytes); 
# 4210 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemFree_v2(CUdeviceptr dptr); 
# 4244 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemGetAddressRange_v2(CUdeviceptr * pbase, size_t * psize, CUdeviceptr dptr); 
# 4291 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemAllocHost_v2(void ** pp, size_t bytesize); 
# 4322 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemFreeHost(void * p); 
# 4404 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemHostAlloc(void ** pp, size_t bytesize, unsigned Flags); 
# 4458 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemHostGetDevicePointer_v2(CUdeviceptr * pdptr, void * p, unsigned Flags); 
# 4486 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemHostGetFlags(unsigned * pFlags, void * p); 
# 4598 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemAllocManaged(CUdeviceptr * dptr, size_t bytesize, unsigned flags); 
# 4631 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceGetByPCIBusId(CUdevice * dev, const char * pciBusId); 
# 4663 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceGetPCIBusId(char * pciBusId, int len, CUdevice dev); 
# 4706 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuIpcGetEventHandle(CUipcEventHandle * pHandle, CUevent event); 
# 4744 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuIpcOpenEventHandle(CUevent * phEvent, CUipcEventHandle handle); 
# 4782 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuIpcGetMemHandle(CUipcMemHandle * pHandle, CUdeviceptr dptr); 
# 4834 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuIpcOpenMemHandle(CUdeviceptr * pdptr, CUipcMemHandle handle, unsigned Flags); 
# 4866 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuIpcCloseMemHandle(CUdeviceptr dptr); 
# 4952 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemHostRegister_v2(void * p, size_t bytesize, unsigned Flags); 
# 4978 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemHostUnregister(void * p); 
# 5017 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpy_ptds(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount); 
# 5047 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyPeer_ptds(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount); 
# 5085 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyHtoD_v2_ptds(CUdeviceptr dstDevice, const void * srcHost, size_t ByteCount); 
# 5120 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyDtoH_v2_ptds(void * dstHost, CUdeviceptr srcDevice, size_t ByteCount); 
# 5156 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyDtoD_v2_ptds(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount); 
# 5192 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyDtoA_v2_ptds(CUarray dstArray, size_t dstOffset, CUdeviceptr srcDevice, size_t ByteCount); 
# 5230 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyAtoD_v2_ptds(CUdeviceptr dstDevice, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
# 5266 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyHtoA_v2_ptds(CUarray dstArray, size_t dstOffset, const void * srcHost, size_t ByteCount); 
# 5302 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyAtoH_v2_ptds(void * dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
# 5342 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyAtoA_v2_ptds(CUarray dstArray, size_t dstOffset, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
# 5506 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpy2D_v2_ptds(const CUDA_MEMCPY2D * pCopy); 
# 5668 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpy2DUnaligned_v2_ptds(const CUDA_MEMCPY2D * pCopy); 
# 5837 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpy3D_v2_ptds(const CUDA_MEMCPY3D * pCopy); 
# 5863 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpy3DPeer_ptds(const CUDA_MEMCPY3D_PEER * pCopy); 
# 5906 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyAsync_ptsz(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount, CUstream hStream); 
# 5938 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyPeerAsync_ptsz(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount, CUstream hStream); 
# 5979 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyHtoDAsync_v2_ptsz(CUdeviceptr dstDevice, const void * srcHost, size_t ByteCount, CUstream hStream); 
# 6018 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyDtoHAsync_v2_ptsz(void * dstHost, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream); 
# 6058 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyDtoDAsync_v2_ptsz(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream); 
# 6098 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyHtoAAsync_v2_ptsz(CUarray dstArray, size_t dstOffset, const void * srcHost, size_t ByteCount, CUstream hStream); 
# 6138 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpyAtoHAsync_v2_ptsz(void * dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount, CUstream hStream); 
# 6306 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpy2DAsync_v2_ptsz(const CUDA_MEMCPY2D * pCopy, CUstream hStream); 
# 6479 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpy3DAsync_v2_ptsz(const CUDA_MEMCPY3D * pCopy, CUstream hStream); 
# 6507 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemcpy3DPeerAsync_ptsz(const CUDA_MEMCPY3D_PEER * pCopy, CUstream hStream); 
# 6544 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD8_v2_ptds(CUdeviceptr dstDevice, unsigned char uc, size_t N); 
# 6579 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD16_v2_ptds(CUdeviceptr dstDevice, unsigned short us, size_t N); 
# 6614 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD32_v2_ptds(CUdeviceptr dstDevice, unsigned ui, size_t N); 
# 6654 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD2D8_v2_ptds(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height); 
# 6695 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD2D16_v2_ptds(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height); 
# 6736 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD2D32_v2_ptds(CUdeviceptr dstDevice, size_t dstPitch, unsigned ui, size_t Width, size_t Height); 
# 6773 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD8Async_ptsz(CUdeviceptr dstDevice, unsigned char uc, size_t N, CUstream hStream); 
# 6810 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD16Async_ptsz(CUdeviceptr dstDevice, unsigned short us, size_t N, CUstream hStream); 
# 6846 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD32Async_ptsz(CUdeviceptr dstDevice, unsigned ui, size_t N, CUstream hStream); 
# 6888 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD2D8Async_ptsz(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, CUstream hStream); 
# 6931 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD2D16Async_ptsz(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, CUstream hStream); 
# 6974 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemsetD2D32Async_ptsz(CUdeviceptr dstDevice, size_t dstPitch, unsigned ui, size_t Width, size_t Height, CUstream hStream); 
# 7078 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuArrayCreate_v2(CUarray * pHandle, const CUDA_ARRAY_DESCRIPTOR * pAllocateArray); 
# 7112 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuArrayGetDescriptor_v2(CUDA_ARRAY_DESCRIPTOR * pArrayDescriptor, CUarray hArray); 
# 7144 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuArrayDestroy(CUarray hArray); 
# 7325 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuArray3DCreate_v2(CUarray * pHandle, const CUDA_ARRAY3D_DESCRIPTOR * pAllocateArray); 
# 7362 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuArray3DGetDescriptor_v2(CUDA_ARRAY3D_DESCRIPTOR * pArrayDescriptor, CUarray hArray); 
# 7507 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMipmappedArrayCreate(CUmipmappedArray * pHandle, const CUDA_ARRAY3D_DESCRIPTOR * pMipmappedArrayDesc, unsigned numMipmapLevels); 
# 7537 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMipmappedArrayGetLevel(CUarray * pLevelArray, CUmipmappedArray hMipmappedArray, unsigned level); 
# 7561 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMipmappedArrayDestroy(CUmipmappedArray hMipmappedArray); 
# 7808 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuPointerGetAttribute(void * data, CUpointer_attribute attribute, CUdeviceptr ptr); 
# 7878 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemPrefetchAsync_ptsz(CUdeviceptr devPtr, size_t count, CUdevice dstDevice, CUstream hStream); 
# 7965 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemAdvise(CUdeviceptr devPtr, size_t count, CUmem_advise advice, CUdevice device); 
# 8023 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemRangeGetAttribute(void * data, size_t dataSize, CUmem_range_attribute attribute, CUdeviceptr devPtr, size_t count); 
# 8063 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuMemRangeGetAttributes(void ** data, size_t * dataSizes, CUmem_range_attribute * attributes, size_t numAttributes, CUdeviceptr devPtr, size_t count); 
# 8107 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuPointerSetAttribute(const void * value, CUpointer_attribute attribute, CUdeviceptr ptr); 
# 8151 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuPointerGetAttributes(unsigned numAttributes, CUpointer_attribute * attributes, void ** data, CUdeviceptr ptr); 
# 8201 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamCreate(CUstream * phStream, unsigned Flags); 
# 8250 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamCreateWithPriority(CUstream * phStream, unsigned flags, int priority); 
# 8281 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamGetPriority_ptsz(CUstream hStream, int * priority); 
# 8309 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamGetFlags_ptsz(CUstream hStream, unsigned * flags); 
# 8351 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamWaitEvent_ptsz(CUstream hStream, CUevent hEvent, unsigned Flags); 
# 8418 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamAddCallback_ptsz(CUstream hStream, CUstreamCallback callback, void * userData, unsigned flags); 
# 8498 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamAttachMemAsync_ptsz(CUstream hStream, CUdeviceptr dptr, size_t length, unsigned flags); 
# 8530 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamQuery_ptsz(CUstream hStream); 
# 8558 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamSynchronize_ptsz(CUstream hStream); 
# 8588 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamDestroy_v2(CUstream hStream); 
# 8645 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuEventCreate(CUevent * phEvent, unsigned Flags); 
# 8682 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuEventRecord_ptsz(CUevent hEvent, CUstream hStream); 
# 8717 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuEventQuery(CUevent hEvent); 
# 8752 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuEventSynchronize(CUevent hEvent); 
# 8782 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuEventDestroy_v2(CUevent hEvent); 
# 8827 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuEventElapsedTime(float * pMilliseconds, CUevent hStart, CUevent hEnd); 
# 8865 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamWaitValue32_ptsz(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned flags); 
# 8902 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamWaitValue64_ptsz(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned flags); 
# 8938 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamWriteValue32_ptsz(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned flags); 
# 8974 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamWriteValue64_ptsz(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned flags); 
# 9009 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuStreamBatchMemOp_ptsz(CUstream stream, unsigned count, CUstreamBatchMemOpParams * paramArray, unsigned flags); 
# 9083 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuFuncGetAttribute(int * pi, CUfunction_attribute attrib, CUfunction hfunc); 
# 9130 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuFuncSetAttribute(CUfunction hfunc, CUfunction_attribute attrib, int value); 
# 9175 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuFuncSetCacheConfig(CUfunction hfunc, CUfunc_cache config); 
# 9228 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuFuncSetSharedMemConfig(CUfunction hfunc, CUsharedconfig config); 
# 9343 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLaunchKernel_ptsz(CUfunction f, unsigned gridDimX, unsigned gridDimY, unsigned gridDimZ, unsigned blockDimX, unsigned blockDimY, unsigned blockDimZ, unsigned sharedMemBytes, CUstream hStream, void ** kernelParams, void ** extra); 
# 9432 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLaunchCooperativeKernel_ptsz(CUfunction f, unsigned gridDimX, unsigned gridDimY, unsigned gridDimZ, unsigned blockDimX, unsigned blockDimY, unsigned blockDimZ, unsigned sharedMemBytes, CUstream hStream, void ** kernelParams); 
# 9576 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLaunchCooperativeKernelMultiDevice(CUDA_LAUNCH_PARAMS * launchParamsList, unsigned numDevices, unsigned flags); 
# 9628 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuFuncSetBlockShape(CUfunction hfunc, int x, int y, int z); 
# 9662 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuFuncSetSharedSize(CUfunction hfunc, unsigned bytes); 
# 9694 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuParamSetSize(CUfunction hfunc, unsigned numbytes); 
# 9727 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuParamSeti(CUfunction hfunc, int offset, unsigned value); 
# 9760 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuParamSetf(CUfunction hfunc, int offset, float value); 
# 9795 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuParamSetv(CUfunction hfunc, int offset, void * ptr, unsigned numbytes); 
# 9832 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLaunch(CUfunction f); 
# 9871 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLaunchGrid(CUfunction f, int grid_width, int grid_height); 
# 9918 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuLaunchGridAsync(CUfunction f, int grid_width, int grid_height, CUstream hStream); 
# 9943 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuParamSetTexRef(CUfunction hfunc, int texunit, CUtexref hTexRef); 
# 9983 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize); 
# 10025 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
# 10077 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuOccupancyMaxPotentialBlockSize(int * minGridSize, int * blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit); 
# 10123 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuOccupancyMaxPotentialBlockSizeWithFlags(int * minGridSize, int * blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned flags); 
# 10167 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetArray(CUtexref hTexRef, CUarray hArray, unsigned Flags); 
# 10195 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetMipmappedArray(CUtexref hTexRef, CUmipmappedArray hMipmappedArray, unsigned Flags); 
# 10240 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetAddress_v2(size_t * ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, size_t bytes); 
# 10293 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetAddress2D_v3(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR * desc, CUdeviceptr dptr, size_t Pitch); 
# 10327 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetFormat(CUtexref hTexRef, CUarray_format fmt, int NumPackedComponents); 
# 10371 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetAddressMode(CUtexref hTexRef, int dim, CUaddress_mode am); 
# 10405 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetFilterMode(CUtexref hTexRef, CUfilter_mode fm); 
# 10439 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetMipmapFilterMode(CUtexref hTexRef, CUfilter_mode fm); 
# 10466 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetMipmapLevelBias(CUtexref hTexRef, float bias); 
# 10495 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetMipmapLevelClamp(CUtexref hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp); 
# 10523 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetMaxAnisotropy(CUtexref hTexRef, unsigned maxAniso); 
# 10557 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetBorderColor(CUtexref hTexRef, float * pBorderColor); 
# 10596 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefSetFlags(CUtexref hTexRef, unsigned Flags); 
# 10622 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetAddress_v2(CUdeviceptr * pdptr, CUtexref hTexRef); 
# 10648 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetArray(CUarray * phArray, CUtexref hTexRef); 
# 10673 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetMipmappedArray(CUmipmappedArray * phMipmappedArray, CUtexref hTexRef); 
# 10699 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetAddressMode(CUaddress_mode * pam, CUtexref hTexRef, int dim); 
# 10723 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetFilterMode(CUfilter_mode * pfm, CUtexref hTexRef); 
# 10749 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetFormat(CUarray_format * pFormat, int * pNumChannels, CUtexref hTexRef); 
# 10773 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetMipmapFilterMode(CUfilter_mode * pfm, CUtexref hTexRef); 
# 10797 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetMipmapLevelBias(float * pbias, CUtexref hTexRef); 
# 10822 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetMipmapLevelClamp(float * pminMipmapLevelClamp, float * pmaxMipmapLevelClamp, CUtexref hTexRef); 
# 10846 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetMaxAnisotropy(int * pmaxAniso, CUtexref hTexRef); 
# 10873 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetBorderColor(float * pBorderColor, CUtexref hTexRef); 
# 10896 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefGetFlags(unsigned * pFlags, CUtexref hTexRef); 
# 10935 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefCreate(CUtexref * pTexRef); 
# 10955 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexRefDestroy(CUtexref hTexRef); 
# 10997 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuSurfRefSetArray(CUsurfref hSurfRef, CUarray hArray, unsigned Flags); 
# 11018 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuSurfRefGetArray(CUarray * phArray, CUsurfref hSurfRef); 
# 11242 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexObjectCreate(CUtexObject * pTexObject, const CUDA_RESOURCE_DESC * pResDesc, const CUDA_TEXTURE_DESC * pTexDesc, const CUDA_RESOURCE_VIEW_DESC * pResViewDesc); 
# 11262 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexObjectDestroy(CUtexObject texObject); 
# 11283 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexObjectGetResourceDesc(CUDA_RESOURCE_DESC * pResDesc, CUtexObject texObject); 
# 11304 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexObjectGetTextureDesc(CUDA_TEXTURE_DESC * pTexDesc, CUtexObject texObject); 
# 11326 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuTexObjectGetResourceViewDesc(CUDA_RESOURCE_VIEW_DESC * pResViewDesc, CUtexObject texObject); 
# 11369 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuSurfObjectCreate(CUsurfObject * pSurfObject, const CUDA_RESOURCE_DESC * pResDesc); 
# 11389 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuSurfObjectDestroy(CUsurfObject surfObject); 
# 11410 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuSurfObjectGetResourceDesc(CUDA_RESOURCE_DESC * pResDesc, CUsurfObject surfObject); 
# 11455 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceCanAccessPeer(int * canAccessPeer, CUdevice dev, CUdevice peerDev); 
# 11506 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxEnablePeerAccess(CUcontext peerContext, unsigned Flags); 
# 11533 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuCtxDisablePeerAccess(CUcontext peerContext); 
# 11575 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuDeviceGetP2PAttribute(int * value, CUdevice_P2PAttribute attrib, CUdevice srcDevice, CUdevice dstDevice); 
# 11621 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuGraphicsUnregisterResource(CUgraphicsResource resource); 
# 11661 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuGraphicsSubResourceGetMappedArray(CUarray * pArray, CUgraphicsResource resource, unsigned arrayIndex, unsigned mipLevel); 
# 11694 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuGraphicsResourceGetMappedMipmappedArray(CUmipmappedArray * pMipmappedArray, CUgraphicsResource resource); 
# 11731 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuGraphicsResourceGetMappedPointer_v2(CUdeviceptr * pDevPtr, size_t * pSize, CUgraphicsResource resource); 
# 11773 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuGraphicsResourceSetMapFlags_v2(CUgraphicsResource resource, unsigned flags); 
# 11813 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuGraphicsMapResources_ptsz(unsigned count, CUgraphicsResource * resources, CUstream hStream); 
# 11850 "/usr/local/cuda-9.0/include/cuda.h"
CUresult cuGraphicsUnmapResources_ptsz(unsigned count, CUgraphicsResource * resources, CUstream hStream); 
# 11854
CUresult cuGetExportTable(const void ** ppExportTable, const CUuuid * pExportTableId); 
# 12179 "/usr/local/cuda-9.0/include/cuda.h"
}
# 29 "/usr/include/stdio.h" 3
extern "C" {
# 44 "/usr/include/stdio.h" 3
struct _IO_FILE; 
# 48
typedef _IO_FILE FILE; 
# 64 "/usr/include/stdio.h" 3
typedef _IO_FILE __FILE; 
# 94 "/usr/include/wchar.h" 3
typedef 
# 83
struct { 
# 84
int __count; 
# 86
union { 
# 88
unsigned __wch; 
# 92
char __wchb[4]; 
# 93
} __value; 
# 94
} __mbstate_t; 
# 25 "/usr/include/_G_config.h" 3
typedef 
# 22
struct { 
# 23
__off_t __pos; 
# 24
__mbstate_t __state; 
# 25
} _G_fpos_t; 
# 30
typedef 
# 27
struct { 
# 28
__off64_t __pos; 
# 29
__mbstate_t __state; 
# 30
} _G_fpos64_t; 
# 40 "/usr/lib/gcc/aarch64-linux-gnu/5/include/stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list; 
# 144 "/usr/include/libio.h" 3
struct _IO_jump_t; struct _IO_FILE; 
# 150
typedef void _IO_lock_t; 
# 156
struct _IO_marker { 
# 157
_IO_marker *_next; 
# 158
_IO_FILE *_sbuf; 
# 162
int _pos; 
# 173 "/usr/include/libio.h" 3
}; 
# 176
enum __codecvt_result { 
# 178
__codecvt_ok, 
# 179
__codecvt_partial, 
# 180
__codecvt_error, 
# 181
__codecvt_noconv
# 182
}; 
# 241 "/usr/include/libio.h" 3
struct _IO_FILE { 
# 242
int _flags; 
# 247
char *_IO_read_ptr; 
# 248
char *_IO_read_end; 
# 249
char *_IO_read_base; 
# 250
char *_IO_write_base; 
# 251
char *_IO_write_ptr; 
# 252
char *_IO_write_end; 
# 253
char *_IO_buf_base; 
# 254
char *_IO_buf_end; 
# 256
char *_IO_save_base; 
# 257
char *_IO_backup_base; 
# 258
char *_IO_save_end; 
# 260
_IO_marker *_markers; 
# 262
_IO_FILE *_chain; 
# 264
int _fileno; 
# 268
int _flags2; 
# 270
__off_t _old_offset; 
# 274
unsigned short _cur_column; 
# 275
signed char _vtable_offset; 
# 276
char _shortbuf[1]; 
# 280
_IO_lock_t *_lock; 
# 289 "/usr/include/libio.h" 3
__off64_t _offset; 
# 297
void *__pad1; 
# 298
void *__pad2; 
# 299
void *__pad3; 
# 300
void *__pad4; 
# 302
size_t __pad5; 
# 303
int _mode; 
# 305
char _unused2[(((15) * sizeof(int)) - ((4) * sizeof(void *))) - sizeof(size_t)]; 
# 307
}; 
# 313
struct _IO_FILE_plus; 
# 315
extern _IO_FILE_plus _IO_2_1_stdin_; 
# 316
extern _IO_FILE_plus _IO_2_1_stdout_; 
# 317
extern _IO_FILE_plus _IO_2_1_stderr_; 
# 333 "/usr/include/libio.h" 3
typedef __ssize_t __io_read_fn(void * __cookie, char * __buf, size_t __nbytes); 
# 341
typedef __ssize_t __io_write_fn(void * __cookie, const char * __buf, size_t __n); 
# 350
typedef int __io_seek_fn(void * __cookie, __off64_t * __pos, int __w); 
# 353
typedef int __io_close_fn(void * __cookie); 
# 358
typedef __io_read_fn cookie_read_function_t; 
# 359
typedef __io_write_fn cookie_write_function_t; 
# 360
typedef __io_seek_fn cookie_seek_function_t; 
# 361
typedef __io_close_fn cookie_close_function_t; 
# 370
typedef 
# 365
struct { 
# 366
__io_read_fn *read; 
# 367
__io_write_fn *write; 
# 368
__io_seek_fn *seek; 
# 369
__io_close_fn *close; 
# 370
} _IO_cookie_io_functions_t; 
# 371
typedef _IO_cookie_io_functions_t cookie_io_functions_t; 
# 373
struct _IO_cookie_file; 
# 376
extern void _IO_cookie_init(_IO_cookie_file * __cfile, int __read_write, void * __cookie, _IO_cookie_io_functions_t __fns); 
# 382
extern "C" {
# 385
extern int __underflow(_IO_FILE *); 
# 386
extern int __uflow(_IO_FILE *); 
# 387
extern int __overflow(_IO_FILE *, int); 
# 429 "/usr/include/libio.h" 3
extern int _IO_getc(_IO_FILE * __fp); 
# 430
extern int _IO_putc(int __c, _IO_FILE * __fp); 
# 431
extern int _IO_feof(_IO_FILE * __fp) throw(); 
# 432
extern int _IO_ferror(_IO_FILE * __fp) throw(); 
# 434
extern int _IO_peekc_locked(_IO_FILE * __fp); 
# 440
extern void _IO_flockfile(_IO_FILE *) throw(); 
# 441
extern void _IO_funlockfile(_IO_FILE *) throw(); 
# 442
extern int _IO_ftrylockfile(_IO_FILE *) throw(); 
# 459 "/usr/include/libio.h" 3
extern int _IO_vfscanf(_IO_FILE *__restrict__, const char *__restrict__, __gnuc_va_list, int *__restrict__); 
# 461
extern int _IO_vfprintf(_IO_FILE *__restrict__, const char *__restrict__, __gnuc_va_list); 
# 463
extern __ssize_t _IO_padn(_IO_FILE *, int, __ssize_t); 
# 464
extern size_t _IO_sgetn(_IO_FILE *, void *, size_t); 
# 466
extern __off64_t _IO_seekoff(_IO_FILE *, __off64_t, int, int); 
# 467
extern __off64_t _IO_seekpos(_IO_FILE *, __off64_t, int); 
# 469
extern void _IO_free_backup_area(_IO_FILE *) throw(); 
# 521 "/usr/include/libio.h" 3
}
# 79 "/usr/include/stdio.h" 3
typedef __gnuc_va_list va_list; 
# 110 "/usr/include/stdio.h" 3
typedef _G_fpos_t fpos_t; 
# 116
typedef _G_fpos64_t fpos64_t; 
# 168 "/usr/include/stdio.h" 3
extern _IO_FILE *stdin; 
# 169
extern _IO_FILE *stdout; 
# 170
extern _IO_FILE *stderr; 
# 178
extern int remove(const char * __filename) throw(); 
# 180
extern int rename(const char * __old, const char * __new) throw(); 
# 185
extern int renameat(int __oldfd, const char * __old, int __newfd, const char * __new) throw(); 
# 195
extern FILE *tmpfile(); 
# 205 "/usr/include/stdio.h" 3
extern FILE *tmpfile64(); 
# 209
extern char *tmpnam(char * __s) throw(); 
# 215
extern char *tmpnam_r(char * __s) throw(); 
# 227 "/usr/include/stdio.h" 3
extern char *tempnam(const char * __dir, const char * __pfx) throw()
# 228
 __attribute((__malloc__)); 
# 237
extern int fclose(FILE * __stream); 
# 242
extern int fflush(FILE * __stream); 
# 252 "/usr/include/stdio.h" 3
extern int fflush_unlocked(FILE * __stream); 
# 262 "/usr/include/stdio.h" 3
extern int fcloseall(); 
# 272
extern FILE *fopen(const char *__restrict__ __filename, const char *__restrict__ __modes); 
# 278
extern FILE *freopen(const char *__restrict__ __filename, const char *__restrict__ __modes, FILE *__restrict__ __stream); 
# 297 "/usr/include/stdio.h" 3
extern FILE *fopen64(const char *__restrict__ __filename, const char *__restrict__ __modes); 
# 299
extern FILE *freopen64(const char *__restrict__ __filename, const char *__restrict__ __modes, FILE *__restrict__ __stream); 
# 306
extern FILE *fdopen(int __fd, const char * __modes) throw(); 
# 312
extern FILE *fopencookie(void *__restrict__ __magic_cookie, const char *__restrict__ __modes, _IO_cookie_io_functions_t __io_funcs) throw(); 
# 319
extern FILE *fmemopen(void * __s, size_t __len, const char * __modes) throw(); 
# 325
extern FILE *open_memstream(char ** __bufloc, size_t * __sizeloc) throw(); 
# 332
extern void setbuf(FILE *__restrict__ __stream, char *__restrict__ __buf) throw(); 
# 336
extern int setvbuf(FILE *__restrict__ __stream, char *__restrict__ __buf, int __modes, size_t __n) throw(); 
# 343
extern void setbuffer(FILE *__restrict__ __stream, char *__restrict__ __buf, size_t __size) throw(); 
# 347
extern void setlinebuf(FILE * __stream) throw(); 
# 356
extern int fprintf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...); 
# 362
extern int printf(const char *__restrict__ __format, ...); 
# 364
extern int sprintf(char *__restrict__ __s, const char *__restrict__ __format, ...) throw(); 
# 371
extern int vfprintf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg); 
# 377
extern int vprintf(const char *__restrict__ __format, __gnuc_va_list __arg); 
# 379
extern int vsprintf(char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg) throw(); 
# 386
extern int snprintf(char *__restrict__ __s, size_t __maxlen, const char *__restrict__ __format, ...) throw()
# 388
 __attribute((__format__(__printf__, 3, 4))); 
# 390
extern int vsnprintf(char *__restrict__ __s, size_t __maxlen, const char *__restrict__ __format, __gnuc_va_list __arg) throw()
# 392
 __attribute((__format__(__printf__, 3, 0))); 
# 399
extern int vasprintf(char **__restrict__ __ptr, const char *__restrict__ __f, __gnuc_va_list __arg) throw()
# 401
 __attribute((__format__(__printf__, 2, 0))); 
# 402
extern int __asprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt, ...) throw()
# 404
 __attribute((__format__(__printf__, 2, 3))); 
# 405
extern int asprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt, ...) throw()
# 407
 __attribute((__format__(__printf__, 2, 3))); 
# 412
extern int vdprintf(int __fd, const char *__restrict__ __fmt, __gnuc_va_list __arg)
# 414
 __attribute((__format__(__printf__, 2, 0))); 
# 415
extern int dprintf(int __fd, const char *__restrict__ __fmt, ...)
# 416
 __attribute((__format__(__printf__, 2, 3))); 
# 425
extern int fscanf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...); 
# 431
extern int scanf(const char *__restrict__ __format, ...); 
# 433
extern int sscanf(const char *__restrict__ __s, const char *__restrict__ __format, ...) throw(); 
# 471 "/usr/include/stdio.h" 3
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg)
# 473
 __attribute((__format__(__scanf__, 2, 0))); 
# 479
extern int vscanf(const char *__restrict__ __format, __gnuc_va_list __arg)
# 480
 __attribute((__format__(__scanf__, 1, 0))); 
# 483
extern int vsscanf(const char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg) throw()
# 485
 __attribute((__format__(__scanf__, 2, 0))); 
# 531 "/usr/include/stdio.h" 3
extern int fgetc(FILE * __stream); 
# 532
extern int getc(FILE * __stream); 
# 538
extern int getchar(); 
# 550 "/usr/include/stdio.h" 3
extern int getc_unlocked(FILE * __stream); 
# 551
extern int getchar_unlocked(); 
# 561 "/usr/include/stdio.h" 3
extern int fgetc_unlocked(FILE * __stream); 
# 573
extern int fputc(int __c, FILE * __stream); 
# 574
extern int putc(int __c, FILE * __stream); 
# 580
extern int putchar(int __c); 
# 594 "/usr/include/stdio.h" 3
extern int fputc_unlocked(int __c, FILE * __stream); 
# 602
extern int putc_unlocked(int __c, FILE * __stream); 
# 603
extern int putchar_unlocked(int __c); 
# 610
extern int getw(FILE * __stream); 
# 613
extern int putw(int __w, FILE * __stream); 
# 622
extern char *fgets(char *__restrict__ __s, int __n, FILE *__restrict__ __stream); 
# 638 "/usr/include/stdio.h" 3
extern char *gets(char * __s) __attribute((__deprecated__)); 
# 649 "/usr/include/stdio.h" 3
extern char *fgets_unlocked(char *__restrict__ __s, int __n, FILE *__restrict__ __stream); 
# 665 "/usr/include/stdio.h" 3
extern __ssize_t __getdelim(char **__restrict__ __lineptr, size_t *__restrict__ __n, int __delimiter, FILE *__restrict__ __stream); 
# 668
extern __ssize_t getdelim(char **__restrict__ __lineptr, size_t *__restrict__ __n, int __delimiter, FILE *__restrict__ __stream); 
# 678
extern __ssize_t getline(char **__restrict__ __lineptr, size_t *__restrict__ __n, FILE *__restrict__ __stream); 
# 689
extern int fputs(const char *__restrict__ __s, FILE *__restrict__ __stream); 
# 695
extern int puts(const char * __s); 
# 702
extern int ungetc(int __c, FILE * __stream); 
# 709
extern size_t fread(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream); 
# 715
extern size_t fwrite(const void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __s); 
# 726 "/usr/include/stdio.h" 3
extern int fputs_unlocked(const char *__restrict__ __s, FILE *__restrict__ __stream); 
# 737 "/usr/include/stdio.h" 3
extern size_t fread_unlocked(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream); 
# 739
extern size_t fwrite_unlocked(const void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream); 
# 749
extern int fseek(FILE * __stream, long __off, int __whence); 
# 754
extern long ftell(FILE * __stream); 
# 759
extern void rewind(FILE * __stream); 
# 773 "/usr/include/stdio.h" 3
extern int fseeko(FILE * __stream, __off_t __off, int __whence); 
# 778
extern __off_t ftello(FILE * __stream); 
# 798 "/usr/include/stdio.h" 3
extern int fgetpos(FILE *__restrict__ __stream, fpos_t *__restrict__ __pos); 
# 803
extern int fsetpos(FILE * __stream, const fpos_t * __pos); 
# 818 "/usr/include/stdio.h" 3
extern int fseeko64(FILE * __stream, __off64_t __off, int __whence); 
# 819
extern __off64_t ftello64(FILE * __stream); 
# 820
extern int fgetpos64(FILE *__restrict__ __stream, fpos64_t *__restrict__ __pos); 
# 821
extern int fsetpos64(FILE * __stream, const fpos64_t * __pos); 
# 826
extern void clearerr(FILE * __stream) throw(); 
# 828
extern int feof(FILE * __stream) throw(); 
# 830
extern int ferror(FILE * __stream) throw(); 
# 835
extern void clearerr_unlocked(FILE * __stream) throw(); 
# 836
extern int feof_unlocked(FILE * __stream) throw(); 
# 837
extern int ferror_unlocked(FILE * __stream) throw(); 
# 846
extern void perror(const char * __s); 
# 26 "/usr/include/aarch64-linux-gnu/bits/sys_errlist.h" 3
extern int sys_nerr; 
# 27
extern const char *const sys_errlist[]; 
# 30
extern int _sys_nerr; 
# 31
extern const char *const _sys_errlist[]; 
# 858 "/usr/include/stdio.h" 3
extern int fileno(FILE * __stream) throw(); 
# 863
extern int fileno_unlocked(FILE * __stream) throw(); 
# 872 "/usr/include/stdio.h" 3
extern FILE *popen(const char * __command, const char * __modes); 
# 878
extern int pclose(FILE * __stream); 
# 884
extern char *ctermid(char * __s) throw(); 
# 890
extern char *cuserid(char * __s); 
# 895
struct obstack; 
# 898
extern int obstack_printf(obstack *__restrict__ __obstack, const char *__restrict__ __format, ...) throw()
# 900
 __attribute((__format__(__printf__, 2, 3))); 
# 901
extern int obstack_vprintf(obstack *__restrict__ __obstack, const char *__restrict__ __format, __gnuc_va_list __args) throw()
# 904
 __attribute((__format__(__printf__, 2, 0))); 
# 912
extern void flockfile(FILE * __stream) throw(); 
# 916
extern int ftrylockfile(FILE * __stream) throw(); 
# 919
extern void funlockfile(FILE * __stream) throw(); 
# 942 "/usr/include/stdio.h" 3
}
# 14 "/home/nvidia/checkerboard-detection/include/checkerboard/cuda/cuda_error_check.h"
inline void cudaGetError(const char *kernelName) 
# 15
{ 
# 17
cudaError err = cudaGetLastError(); 
# 18
if ((cudaSuccess) != err) 
# 19
{ 
# 20
fprintf(stderr, "<<<CUDA>>> Error: %s  at kernel %s \n", cudaGetErrorString(err), kernelName); 
# 22 "/home/nvidia/checkerboard-detection/include/checkerboard/cuda/cuda_error_check.h"
exit(-1); 
# 23
}  
# 24
} 
# 46 "/usr/include/c++/5/cstdint" 3
namespace std { 
# 48
using ::int8_t;
# 49
using ::int16_t;
# 50
using ::int32_t;
# 51
using ::int64_t;
# 53
using ::int_fast8_t;
# 54
using ::int_fast16_t;
# 55
using ::int_fast32_t;
# 56
using ::int_fast64_t;
# 58
using ::int_least8_t;
# 59
using ::int_least16_t;
# 60
using ::int_least32_t;
# 61
using ::int_least64_t;
# 63
using ::intmax_t;
# 64
using ::intptr_t;
# 66
using ::uint8_t;
# 67
using ::uint16_t;
# 68
using ::uint32_t;
# 69
using ::uint64_t;
# 71
using ::uint_fast8_t;
# 72
using ::uint_fast16_t;
# 73
using ::uint_fast32_t;
# 74
using ::uint_fast64_t;
# 76
using ::uint_least8_t;
# 77
using ::uint_least16_t;
# 78
using ::uint_least32_t;
# 79
using ::uint_least64_t;
# 81
using ::uintmax_t;
# 82
using ::uintptr_t;
# 83
}
# 50 "/usr/include/c++/5/bits/memoryfwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 63 "/usr/include/c++/5/bits/memoryfwd.h" 3
template< class > class allocator; 
# 67
template<> class allocator< void> ; 
# 70
template< class , class > struct uses_allocator; 
# 76
}
# 42 "/usr/include/c++/5/bits/stringfwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 52
template< class _CharT> struct char_traits; 
# 55
template<> struct char_traits< char> ; 
# 58
template<> struct char_traits< wchar_t> ; 
# 63
template<> struct char_traits< char16_t> ; 
# 64
template<> struct char_traits< char32_t> ; 
# 67
inline namespace __cxx11 { 
# 69
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 70
_Alloc = allocator< _CharT> > class basic_string; 
# 74
typedef basic_string< char>  string; 
# 78
typedef basic_string< wchar_t>  wstring; 
# 84
typedef basic_string< char16_t>  u16string; 
# 87
typedef basic_string< char32_t>  u32string; 
# 90
}
# 95
}
# 357 "/usr/lib/gcc/aarch64-linux-gnu/5/include/stddef.h" 3
typedef unsigned wint_t; 
# 106 "/usr/include/wchar.h" 3
typedef __mbstate_t mbstate_t; 
# 132 "/usr/include/wchar.h" 3
extern "C" {
# 137
struct tm; 
# 147
extern wchar_t *wcscpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw()
# 149
 __attribute((__nonnull__(1, 2))); 
# 152
extern wchar_t *wcsncpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw()
# 154
 __attribute((__nonnull__(1, 2))); 
# 157
extern wchar_t *wcscat(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw()
# 159
 __attribute((__nonnull__(1, 2))); 
# 161
extern wchar_t *wcsncat(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw()
# 163
 __attribute((__nonnull__(1, 2))); 
# 166
extern int wcscmp(const wchar_t * __s1, const wchar_t * __s2) throw()
# 167
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 169
extern int wcsncmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n) throw()
# 170
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 175
extern int wcscasecmp(const wchar_t * __s1, const wchar_t * __s2) throw(); 
# 178
extern int wcsncasecmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n) throw(); 
# 185
extern int wcscasecmp_l(const wchar_t * __s1, const wchar_t * __s2, __locale_t __loc) throw(); 
# 188
extern int wcsncasecmp_l(const wchar_t * __s1, const wchar_t * __s2, size_t __n, __locale_t __loc) throw(); 
# 195
extern int wcscoll(const wchar_t * __s1, const wchar_t * __s2) throw(); 
# 199
extern size_t wcsxfrm(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw(); 
# 209
extern int wcscoll_l(const wchar_t * __s1, const wchar_t * __s2, __locale_t __loc) throw(); 
# 215
extern size_t wcsxfrm_l(wchar_t * __s1, const wchar_t * __s2, size_t __n, __locale_t __loc) throw(); 
# 219
extern wchar_t *wcsdup(const wchar_t * __s) throw() __attribute((__malloc__)); 
# 225
extern "C++" wchar_t *wcschr(wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcschr")
# 226
 __attribute((__pure__)); 
# 227
extern "C++" const wchar_t *wcschr(const wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcschr")
# 228
 __attribute((__pure__)); 
# 235
extern "C++" wchar_t *wcsrchr(wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcsrchr")
# 236
 __attribute((__pure__)); 
# 237
extern "C++" const wchar_t *wcsrchr(const wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcsrchr")
# 238
 __attribute((__pure__)); 
# 248
extern wchar_t *wcschrnul(const wchar_t * __s, wchar_t __wc) throw()
# 249
 __attribute((__pure__)); 
# 255
extern size_t wcscspn(const wchar_t * __wcs, const wchar_t * __reject) throw()
# 256
 __attribute((__pure__)); 
# 259
extern size_t wcsspn(const wchar_t * __wcs, const wchar_t * __accept) throw()
# 260
 __attribute((__pure__)); 
# 263
extern "C++" wchar_t *wcspbrk(wchar_t * __wcs, const wchar_t * __accept) throw() __asm__("wcspbrk")
# 264
 __attribute((__pure__)); 
# 265
extern "C++" const wchar_t *wcspbrk(const wchar_t * __wcs, const wchar_t * __accept) throw() __asm__("wcspbrk")
# 267
 __attribute((__pure__)); 
# 274
extern "C++" wchar_t *wcsstr(wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcsstr")
# 275
 __attribute((__pure__)); 
# 276
extern "C++" const wchar_t *wcsstr(const wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcsstr")
# 278
 __attribute((__pure__)); 
# 285
extern wchar_t *wcstok(wchar_t *__restrict__ __s, const wchar_t *__restrict__ __delim, wchar_t **__restrict__ __ptr) throw(); 
# 290
extern size_t wcslen(const wchar_t * __s) throw() __attribute((__pure__)); 
# 296
extern "C++" wchar_t *wcswcs(wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcswcs")
# 297
 __attribute((__pure__)); 
# 298
extern "C++" const wchar_t *wcswcs(const wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcswcs")
# 300
 __attribute((__pure__)); 
# 309 "/usr/include/wchar.h" 3
extern size_t wcsnlen(const wchar_t * __s, size_t __maxlen) throw()
# 310
 __attribute((__pure__)); 
# 317
extern "C++" wchar_t *wmemchr(wchar_t * __s, wchar_t __c, size_t __n) throw() __asm__("wmemchr")
# 318
 __attribute((__pure__)); 
# 319
extern "C++" const wchar_t *wmemchr(const wchar_t * __s, wchar_t __c, size_t __n) throw() __asm__("wmemchr")
# 321
 __attribute((__pure__)); 
# 328
extern int wmemcmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n) throw()
# 329
 __attribute((__pure__)); 
# 332
extern wchar_t *wmemcpy(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw(); 
# 337
extern wchar_t *wmemmove(wchar_t * __s1, const wchar_t * __s2, size_t __n) throw(); 
# 341
extern wchar_t *wmemset(wchar_t * __s, wchar_t __c, size_t __n) throw(); 
# 347
extern wchar_t *wmempcpy(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw(); 
# 356
extern wint_t btowc(int __c) throw(); 
# 360
extern int wctob(wint_t __c) throw(); 
# 364
extern int mbsinit(const mbstate_t * __ps) throw() __attribute((__pure__)); 
# 368
extern size_t mbrtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s, size_t __n, mbstate_t *__restrict__ __p) throw(); 
# 373
extern size_t wcrtomb(char *__restrict__ __s, wchar_t __wc, mbstate_t *__restrict__ __ps) throw(); 
# 377
extern size_t __mbrlen(const char *__restrict__ __s, size_t __n, mbstate_t *__restrict__ __ps) throw(); 
# 379
extern size_t mbrlen(const char *__restrict__ __s, size_t __n, mbstate_t *__restrict__ __ps) throw(); 
# 411 "/usr/include/wchar.h" 3
extern size_t mbsrtowcs(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 417
extern size_t wcsrtombs(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 426
extern size_t mbsnrtowcs(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __nmc, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 432
extern size_t wcsnrtombs(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __nwc, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 442
extern int wcwidth(wchar_t __c) throw(); 
# 446
extern int wcswidth(const wchar_t * __s, size_t __n) throw(); 
# 453
extern double wcstod(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 460
extern float wcstof(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 462
extern long double wcstold(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 471
extern long wcstol(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 476
extern unsigned long wcstoul(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 486
__extension__ extern long long wcstoll(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 493
__extension__ extern unsigned long long wcstoull(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 503
__extension__ extern long long wcstoq(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 510
__extension__ extern unsigned long long wcstouq(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 533 "/usr/include/wchar.h" 3
extern long wcstol_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, __locale_t __loc) throw(); 
# 537
extern unsigned long wcstoul_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, __locale_t __loc) throw(); 
# 542
__extension__ extern long long wcstoll_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, __locale_t __loc) throw(); 
# 547
__extension__ extern unsigned long long wcstoull_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, __locale_t __loc) throw(); 
# 552
extern double wcstod_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, __locale_t __loc) throw(); 
# 556
extern float wcstof_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, __locale_t __loc) throw(); 
# 560
extern long double wcstold_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, __locale_t __loc) throw(); 
# 569
extern wchar_t *wcpcpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw(); 
# 574
extern wchar_t *wcpncpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw(); 
# 583
extern __FILE *open_wmemstream(wchar_t ** __bufloc, size_t * __sizeloc) throw(); 
# 590
extern int fwide(__FILE * __fp, int __mode) throw(); 
# 597
extern int fwprintf(__FILE *__restrict__ __stream, const wchar_t *__restrict__ __format, ...); 
# 604
extern int wprintf(const wchar_t *__restrict__ __format, ...); 
# 607
extern int swprintf(wchar_t *__restrict__ __s, size_t __n, const wchar_t *__restrict__ __format, ...) throw(); 
# 615
extern int vfwprintf(__FILE *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg); 
# 623
extern int vwprintf(const wchar_t *__restrict__ __format, __gnuc_va_list __arg); 
# 628
extern int vswprintf(wchar_t *__restrict__ __s, size_t __n, const wchar_t *__restrict__ __format, __gnuc_va_list __arg) throw(); 
# 638
extern int fwscanf(__FILE *__restrict__ __stream, const wchar_t *__restrict__ __format, ...); 
# 645
extern int wscanf(const wchar_t *__restrict__ __format, ...); 
# 648
extern int swscanf(const wchar_t *__restrict__ __s, const wchar_t *__restrict__ __format, ...) throw(); 
# 692 "/usr/include/wchar.h" 3
extern int vfwscanf(__FILE *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg); 
# 700
extern int vwscanf(const wchar_t *__restrict__ __format, __gnuc_va_list __arg); 
# 704
extern int vswscanf(const wchar_t *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg) throw(); 
# 748 "/usr/include/wchar.h" 3
extern wint_t fgetwc(__FILE * __stream); 
# 749
extern wint_t getwc(__FILE * __stream); 
# 755
extern wint_t getwchar(); 
# 762
extern wint_t fputwc(wchar_t __wc, __FILE * __stream); 
# 763
extern wint_t putwc(wchar_t __wc, __FILE * __stream); 
# 769
extern wint_t putwchar(wchar_t __wc); 
# 777
extern wchar_t *fgetws(wchar_t *__restrict__ __ws, int __n, __FILE *__restrict__ __stream); 
# 784
extern int fputws(const wchar_t *__restrict__ __ws, __FILE *__restrict__ __stream); 
# 792
extern wint_t ungetwc(wint_t __wc, __FILE * __stream); 
# 804 "/usr/include/wchar.h" 3
extern wint_t getwc_unlocked(__FILE * __stream); 
# 805
extern wint_t getwchar_unlocked(); 
# 813
extern wint_t fgetwc_unlocked(__FILE * __stream); 
# 821
extern wint_t fputwc_unlocked(wchar_t __wc, __FILE * __stream); 
# 830 "/usr/include/wchar.h" 3
extern wint_t putwc_unlocked(wchar_t __wc, __FILE * __stream); 
# 831
extern wint_t putwchar_unlocked(wchar_t __wc); 
# 840 "/usr/include/wchar.h" 3
extern wchar_t *fgetws_unlocked(wchar_t *__restrict__ __ws, int __n, __FILE *__restrict__ __stream); 
# 849
extern int fputws_unlocked(const wchar_t *__restrict__ __ws, __FILE *__restrict__ __stream); 
# 858
extern size_t wcsftime(wchar_t *__restrict__ __s, size_t __maxsize, const wchar_t *__restrict__ __format, const tm *__restrict__ __tp) throw(); 
# 868
extern size_t wcsftime_l(wchar_t *__restrict__ __s, size_t __maxsize, const wchar_t *__restrict__ __format, const tm *__restrict__ __tp, __locale_t __loc) throw(); 
# 894 "/usr/include/wchar.h" 3
}
# 62 "/usr/include/c++/5/cwchar" 3
namespace std { 
# 64
using ::mbstate_t;
# 65
}
# 135 "/usr/include/c++/5/cwchar" 3
namespace std __attribute((__visibility__("default"))) { 
# 139
using ::wint_t;
# 141
using ::btowc;
# 142
using ::fgetwc;
# 143
using ::fgetws;
# 144
using ::fputwc;
# 145
using ::fputws;
# 146
using ::fwide;
# 147
using ::fwprintf;
# 148
using ::fwscanf;
# 149
using ::getwc;
# 150
using ::getwchar;
# 151
using ::mbrlen;
# 152
using ::mbrtowc;
# 153
using ::mbsinit;
# 154
using ::mbsrtowcs;
# 155
using ::putwc;
# 156
using ::putwchar;
# 158
using ::swprintf;
# 160
using ::swscanf;
# 161
using ::ungetwc;
# 162
using ::vfwprintf;
# 164
using ::vfwscanf;
# 167
using ::vswprintf;
# 170
using ::vswscanf;
# 172
using ::vwprintf;
# 174
using ::vwscanf;
# 176
using ::wcrtomb;
# 177
using ::wcscat;
# 178
using ::wcscmp;
# 179
using ::wcscoll;
# 180
using ::wcscpy;
# 181
using ::wcscspn;
# 182
using ::wcsftime;
# 183
using ::wcslen;
# 184
using ::wcsncat;
# 185
using ::wcsncmp;
# 186
using ::wcsncpy;
# 187
using ::wcsrtombs;
# 188
using ::wcsspn;
# 189
using ::wcstod;
# 191
using ::wcstof;
# 193
using ::wcstok;
# 194
using ::wcstol;
# 195
using ::wcstoul;
# 196
using ::wcsxfrm;
# 197
using ::wctob;
# 198
using ::wmemcmp;
# 199
using ::wmemcpy;
# 200
using ::wmemmove;
# 201
using ::wmemset;
# 202
using ::wprintf;
# 203
using ::wscanf;
# 204
using ::wcschr;
# 205
using ::wcspbrk;
# 206
using ::wcsrchr;
# 207
using ::wcsstr;
# 208
using ::wmemchr;
# 233 "/usr/include/c++/5/cwchar" 3
}
# 241
namespace __gnu_cxx { 
# 248
using ::wcstold;
# 257 "/usr/include/c++/5/cwchar" 3
using ::wcstoll;
# 258
using ::wcstoull;
# 260
}
# 262
namespace std { 
# 264
using __gnu_cxx::wcstold;
# 265
using __gnu_cxx::wcstoll;
# 266
using __gnu_cxx::wcstoull;
# 267
}
# 277 "/usr/include/c++/5/cwchar" 3
namespace std { 
# 297
}
# 68 "/usr/include/c++/5/bits/postypes.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 88 "/usr/include/c++/5/bits/postypes.h" 3
typedef long streamoff; 
# 98 "/usr/include/c++/5/bits/postypes.h" 3
typedef ptrdiff_t streamsize; 
# 111 "/usr/include/c++/5/bits/postypes.h" 3
template< class _StateT> 
# 112
class fpos { 
# 115
streamoff _M_off; 
# 116
_StateT _M_state; 
# 123
public: fpos() : _M_off((0)), _M_state() 
# 124
{ } 
# 133 "/usr/include/c++/5/bits/postypes.h" 3
fpos(streamoff __off) : _M_off(__off), _M_state() 
# 134
{ } 
# 137
operator streamoff() const { return _M_off; } 
# 141
void state(_StateT __st) 
# 142
{ (_M_state) = __st; } 
# 146
_StateT state() const 
# 147
{ return _M_state; } 
# 154
fpos &operator+=(streamoff __off) 
# 155
{ 
# 156
(_M_off) += __off; 
# 157
return *this; 
# 158
} 
# 165
fpos &operator-=(streamoff __off) 
# 166
{ 
# 167
(_M_off) -= __off; 
# 168
return *this; 
# 169
} 
# 178
fpos operator+(streamoff __off) const 
# 179
{ 
# 180
fpos __pos(*this); 
# 181
__pos += __off; 
# 182
return __pos; 
# 183
} 
# 192
fpos operator-(streamoff __off) const 
# 193
{ 
# 194
fpos __pos(*this); 
# 195
__pos -= __off; 
# 196
return __pos; 
# 197
} 
# 205
streamoff operator-(const fpos &__other) const 
# 206
{ return (_M_off) - (__other._M_off); } 
# 207
}; 
# 214
template< class _StateT> inline bool 
# 216
operator==(const fpos< _StateT>  &__lhs, const fpos< _StateT>  &__rhs) 
# 217
{ return ((streamoff)__lhs) == ((streamoff)__rhs); } 
# 219
template< class _StateT> inline bool 
# 221
operator!=(const fpos< _StateT>  &__lhs, const fpos< _StateT>  &__rhs) 
# 222
{ return ((streamoff)__lhs) != ((streamoff)__rhs); } 
# 228
typedef fpos< __mbstate_t>  streampos; 
# 230
typedef fpos< __mbstate_t>  wstreampos; 
# 234
typedef fpos< __mbstate_t>  u16streampos; 
# 236
typedef fpos< __mbstate_t>  u32streampos; 
# 240
}
# 42 "/usr/include/c++/5/iosfwd" 3
namespace std __attribute((__visibility__("default"))) { 
# 74 "/usr/include/c++/5/iosfwd" 3
class ios_base; 
# 76
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ios; 
# 79
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_streambuf; 
# 82
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_istream; 
# 85
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ostream; 
# 88
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_iostream; 
# 92
inline namespace __cxx11 { 
# 94
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 95
_Alloc = allocator< _CharT> > class basic_stringbuf; 
# 98
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 99
_Alloc = allocator< _CharT> > class basic_istringstream; 
# 102
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 103
_Alloc = allocator< _CharT> > class basic_ostringstream; 
# 106
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 107
_Alloc = allocator< _CharT> > class basic_stringstream; 
# 110
}
# 112
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_filebuf; 
# 115
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ifstream; 
# 118
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ofstream; 
# 121
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_fstream; 
# 124
template< class _CharT, class _Traits = char_traits< _CharT> > class istreambuf_iterator; 
# 127
template< class _CharT, class _Traits = char_traits< _CharT> > class ostreambuf_iterator; 
# 132
typedef basic_ios< char>  ios; 
# 135
typedef basic_streambuf< char>  streambuf; 
# 138
typedef basic_istream< char>  istream; 
# 141
typedef basic_ostream< char>  ostream; 
# 144
typedef basic_iostream< char>  iostream; 
# 147
typedef __cxx11::basic_stringbuf< char>  stringbuf; 
# 150
typedef __cxx11::basic_istringstream< char>  istringstream; 
# 153
typedef __cxx11::basic_ostringstream< char>  ostringstream; 
# 156
typedef __cxx11::basic_stringstream< char>  stringstream; 
# 159
typedef basic_filebuf< char>  filebuf; 
# 162
typedef basic_ifstream< char>  ifstream; 
# 165
typedef basic_ofstream< char>  ofstream; 
# 168
typedef basic_fstream< char>  fstream; 
# 172
typedef basic_ios< wchar_t>  wios; 
# 175
typedef basic_streambuf< wchar_t>  wstreambuf; 
# 178
typedef basic_istream< wchar_t>  wistream; 
# 181
typedef basic_ostream< wchar_t>  wostream; 
# 184
typedef basic_iostream< wchar_t>  wiostream; 
# 187
typedef __cxx11::basic_stringbuf< wchar_t>  wstringbuf; 
# 190
typedef __cxx11::basic_istringstream< wchar_t>  wistringstream; 
# 193
typedef __cxx11::basic_ostringstream< wchar_t>  wostringstream; 
# 196
typedef __cxx11::basic_stringstream< wchar_t>  wstringstream; 
# 199
typedef basic_filebuf< wchar_t>  wfilebuf; 
# 202
typedef basic_ifstream< wchar_t>  wifstream; 
# 205
typedef basic_ofstream< wchar_t>  wofstream; 
# 208
typedef basic_fstream< wchar_t>  wfstream; 
# 213
}
# 35 "/usr/include/c++/5/exception" 3
#pragma GCC visibility push ( default )
# 40 "/usr/include/c++/5/exception" 3
extern "C++" {
# 42
namespace std { 
# 60 "/usr/include/c++/5/exception" 3
class exception { 
# 63
public: exception() noexcept { } 
# 64
virtual ~exception() noexcept; 
# 68
virtual const char *what() const noexcept; 
# 69
}; 
# 73
class bad_exception : public exception { 
# 76
public: bad_exception() noexcept { } 
# 80
virtual ~bad_exception() noexcept; 
# 83
virtual const char *what() const noexcept; 
# 84
}; 
# 87
typedef void (*terminate_handler)(void); 
# 90
typedef void (*unexpected_handler)(void); 
# 93
terminate_handler set_terminate(terminate_handler) noexcept; 
# 97
terminate_handler get_terminate() noexcept; 
# 102
void terminate() noexcept __attribute((__noreturn__)); 
# 105
unexpected_handler set_unexpected(unexpected_handler) noexcept; 
# 109
unexpected_handler get_unexpected() noexcept; 
# 114
void unexpected() __attribute((__noreturn__)); 
# 127 "/usr/include/c++/5/exception" 3
bool uncaught_exception() noexcept __attribute((__pure__)); 
# 130
}
# 132
namespace __gnu_cxx { 
# 152 "/usr/include/c++/5/exception" 3
void __verbose_terminate_handler(); 
# 155
}
# 157
}
# 159
#pragma GCC visibility pop
# 34 "/usr/include/c++/5/bits/exception_ptr.h" 3
#pragma GCC visibility push ( default )
# 43 "/usr/include/c++/5/bits/exception_ptr.h" 3
extern "C++" {
# 45
namespace std { 
# 47
class type_info; 
# 53
namespace __exception_ptr { 
# 55
class exception_ptr; 
# 56
}
# 58
using __exception_ptr::exception_ptr;
# 64
__exception_ptr::exception_ptr current_exception() noexcept; 
# 67
void rethrow_exception(__exception_ptr::exception_ptr) __attribute((__noreturn__)); 
# 69
namespace __exception_ptr { 
# 75
class exception_ptr { 
# 77
void *_M_exception_object; 
# 79
explicit exception_ptr(void * __e) noexcept; 
# 81
void _M_addref() noexcept; 
# 82
void _M_release() noexcept; 
# 84
void *_M_get() const noexcept __attribute((__pure__)); 
# 86
friend exception_ptr std::current_exception() noexcept; 
# 87
friend void std::rethrow_exception(exception_ptr); 
# 90
public: exception_ptr() noexcept; 
# 92
exception_ptr(const exception_ptr &) noexcept; 
# 95
exception_ptr(nullptr_t) noexcept : _M_exception_object((0)) 
# 97
{ } 
# 99
exception_ptr(exception_ptr &&__o) noexcept : _M_exception_object(__o._M_exception_object) 
# 101
{ (__o._M_exception_object) = (0); } 
# 112 "/usr/include/c++/5/bits/exception_ptr.h" 3
exception_ptr &operator=(const exception_ptr &) noexcept; 
# 116
exception_ptr &operator=(exception_ptr &&__o) noexcept 
# 117
{ 
# 118
((exception_ptr)(static_cast< exception_ptr &&>(__o))).swap(*this); 
# 119
return *this; 
# 120
} 
# 123
~exception_ptr() noexcept; 
# 126
void swap(exception_ptr &) noexcept; 
# 138 "/usr/include/c++/5/bits/exception_ptr.h" 3
explicit operator bool() const 
# 139
{ return _M_exception_object; } 
# 143
friend bool operator==(const exception_ptr &, const exception_ptr &) noexcept
# 144
 __attribute((__pure__)); 
# 147
const type_info *__cxa_exception_type() const noexcept
# 148
 __attribute((__pure__)); 
# 149
}; 
# 152
bool operator==(const exception_ptr &, const exception_ptr &) noexcept
# 153
 __attribute((__pure__)); 
# 156
bool operator!=(const exception_ptr &, const exception_ptr &) noexcept
# 157
 __attribute((__pure__)); 
# 160
inline void swap(exception_ptr &__lhs, exception_ptr &__rhs) 
# 161
{ __lhs.swap(__rhs); } 
# 163
}
# 167
template< class _Ex> __exception_ptr::exception_ptr 
# 169
make_exception_ptr(_Ex __ex) noexcept 
# 170
{ 
# 172
try 
# 173
{ 
# 174
throw __ex; 
# 175
} 
# 176
catch (...) 
# 177
{ 
# 178
return current_exception(); 
# 179
}  
# 183
} 
# 189
template< class _Ex> __exception_ptr::exception_ptr copy_exception(_Ex __ex) noexcept
# 191
 __attribute((__deprecated__)); 
# 193
template< class _Ex> __exception_ptr::exception_ptr 
# 195
copy_exception(_Ex __ex) noexcept 
# 196
{ return std::make_exception_ptr< _Ex> (__ex); } 
# 199
}
# 201
}
# 203
#pragma GCC visibility pop
# 33 "/usr/include/c++/5/bits/nested_exception.h" 3
#pragma GCC visibility push ( default )
# 45 "/usr/include/c++/5/bits/nested_exception.h" 3
extern "C++" {
# 47
namespace std { 
# 55
class nested_exception { 
# 57
__exception_ptr::exception_ptr _M_ptr; 
# 60
public: nested_exception() noexcept : _M_ptr(current_exception()) { } 
# 62
nested_exception(const nested_exception &) noexcept = default;
# 64
nested_exception &operator=(const nested_exception &) noexcept = default;
# 66
virtual ~nested_exception() noexcept; 
# 68
[[noreturn]] void 
# 70
rethrow_nested() const 
# 71
{ 
# 72
if ((_M_ptr)) { 
# 73
rethrow_exception(_M_ptr); }  
# 74
std::terminate(); 
# 75
} 
# 78
__exception_ptr::exception_ptr nested_ptr() const noexcept 
# 79
{ return _M_ptr; } 
# 80
}; 
# 82
template< class _Except> 
# 83
struct _Nested_exception : public _Except, public nested_exception { 
# 85
explicit _Nested_exception(const _Except &__ex) : _Except(__ex) 
# 87
{ } 
# 89
explicit _Nested_exception(_Except &&__ex) : _Except(static_cast< _Except &&>(__ex)) 
# 91
{ } 
# 92
}; 
# 94
template< class _Tp, bool 
# 95
__with_nested = !__is_base_of(nested_exception, _Tp)> 
# 96
struct _Throw_with_nested_impl { 
# 98
template< class _Up> static void 
# 99
_S_throw(_Up &&__t) 
# 100
{ throw _Nested_exception< _Tp> {static_cast< _Up &&>(__t)}; } 
# 101
}; 
# 103
template< class _Tp> 
# 104
struct _Throw_with_nested_impl< _Tp, false>  { 
# 106
template< class _Up> static void 
# 107
_S_throw(_Up &&__t) 
# 108
{ throw static_cast< _Up &&>(__t); } 
# 109
}; 
# 111
template< class _Tp, bool  = __is_class(_Tp) && (!__is_final(_Tp))> 
# 112
struct _Throw_with_nested_helper : public _Throw_with_nested_impl< _Tp>  { 
# 113
}; 
# 115
template< class _Tp> 
# 116
struct _Throw_with_nested_helper< _Tp, false>  : public _Throw_with_nested_impl< _Tp, false>  { 
# 118
}; 
# 120
template< class _Tp> 
# 121
struct _Throw_with_nested_helper< _Tp &, false>  : public _Throw_with_nested_helper< _Tp>  { 
# 123
}; 
# 125
template< class _Tp> 
# 126
struct _Throw_with_nested_helper< _Tp &&, false>  : public _Throw_with_nested_helper< _Tp>  { 
# 128
}; 
# 132
template< class _Tp> 
# 133
[[noreturn]] inline void 
# 135
throw_with_nested(_Tp &&__t) 
# 136
{ 
# 137
_Throw_with_nested_helper< _Tp> ::_S_throw(static_cast< _Tp &&>(__t)); 
# 138
} 
# 140
template< class _Tp, bool  = __is_polymorphic(_Tp)> 
# 141
struct _Rethrow_if_nested_impl { 
# 143
static void _S_rethrow(const _Tp &__t) 
# 144
{ 
# 145
if (auto __tp = (dynamic_cast< const nested_exception *>(&__t))) { 
# 146
__tp->rethrow_nested(); }  
# 147
} 
# 148
}; 
# 150
template< class _Tp> 
# 151
struct _Rethrow_if_nested_impl< _Tp, false>  { 
# 153
static void _S_rethrow(const _Tp &) { } 
# 154
}; 
# 157
template< class _Ex> inline void 
# 159
rethrow_if_nested(const _Ex &__ex) 
# 160
{ 
# 161
_Rethrow_if_nested_impl< _Ex> ::_S_rethrow(__ex); 
# 162
} 
# 165
}
# 167
}
# 171
#pragma GCC visibility pop
# 42 "/usr/include/c++/5/bits/functexcept.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 48
void __throw_bad_exception() __attribute((__noreturn__)); 
# 52
void __throw_bad_alloc() __attribute((__noreturn__)); 
# 56
void __throw_bad_cast() __attribute((__noreturn__)); 
# 59
void __throw_bad_typeid() __attribute((__noreturn__)); 
# 63
void __throw_logic_error(const char *) __attribute((__noreturn__)); 
# 66
void __throw_domain_error(const char *) __attribute((__noreturn__)); 
# 69
void __throw_invalid_argument(const char *) __attribute((__noreturn__)); 
# 72
void __throw_length_error(const char *) __attribute((__noreturn__)); 
# 75
void __throw_out_of_range(const char *) __attribute((__noreturn__)); 
# 78
void __throw_out_of_range_fmt(const char *, ...) __attribute((__noreturn__))
# 79
 __attribute((__format__(__gnu_printf__, 1, 2))); 
# 82
void __throw_runtime_error(const char *) __attribute((__noreturn__)); 
# 85
void __throw_range_error(const char *) __attribute((__noreturn__)); 
# 88
void __throw_overflow_error(const char *) __attribute((__noreturn__)); 
# 91
void __throw_underflow_error(const char *) __attribute((__noreturn__)); 
# 95
void __throw_ios_failure(const char *) __attribute((__noreturn__)); 
# 98
void __throw_system_error(int) __attribute((__noreturn__)); 
# 101
void __throw_future_error(int) __attribute((__noreturn__)); 
# 105
void __throw_bad_function_call() __attribute((__noreturn__)); 
# 108
}
# 37 "/usr/include/c++/5/ext/numeric_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 54 "/usr/include/c++/5/ext/numeric_traits.h" 3
template< class _Value> 
# 55
struct __numeric_traits_integer { 
# 58
static const _Value __min = ((((_Value)(-1)) < 0) ? ((_Value)1) << ((sizeof(_Value) * (8)) - (((_Value)(-1)) < 0)) : ((_Value)0)); 
# 59
static const _Value __max = ((((_Value)(-1)) < 0) ? (((((_Value)1) << (((sizeof(_Value) * (8)) - (((_Value)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((_Value)0))); 
# 63
static const bool __is_signed = (((_Value)(-1)) < 0); 
# 64
static const int __digits = ((sizeof(_Value) * (8)) - (((_Value)(-1)) < 0)); 
# 65
}; 
# 67
template< class _Value> const _Value 
# 68
__numeric_traits_integer< _Value> ::__min; 
# 70
template< class _Value> const _Value 
# 71
__numeric_traits_integer< _Value> ::__max; 
# 73
template< class _Value> const bool 
# 74
__numeric_traits_integer< _Value> ::__is_signed; 
# 76
template< class _Value> const int 
# 77
__numeric_traits_integer< _Value> ::__digits; 
# 99 "/usr/include/c++/5/ext/numeric_traits.h" 3
template< class _Value> 
# 100
struct __numeric_traits_floating { 
# 103
static const int __max_digits10 = ((2) + ((((std::__are_same< _Value, float> ::__value) ? 24 : ((std::__are_same< _Value, double> ::__value) ? 53 : 113)) * 643L) / (2136))); 
# 106
static const bool __is_signed = true; 
# 107
static const int __digits10 = ((std::__are_same< _Value, float> ::__value) ? 6 : ((std::__are_same< _Value, double> ::__value) ? 15 : 33)); 
# 108
static const int __max_exponent10 = ((std::__are_same< _Value, float> ::__value) ? 38 : ((std::__are_same< _Value, double> ::__value) ? 308 : 4932)); 
# 109
}; 
# 111
template< class _Value> const int 
# 112
__numeric_traits_floating< _Value> ::__max_digits10; 
# 114
template< class _Value> const bool 
# 115
__numeric_traits_floating< _Value> ::__is_signed; 
# 117
template< class _Value> const int 
# 118
__numeric_traits_floating< _Value> ::__digits10; 
# 120
template< class _Value> const int 
# 121
__numeric_traits_floating< _Value> ::__max_exponent10; 
# 123
template< class _Value> 
# 124
struct __numeric_traits : public __conditional_type< std::__is_integer< _Value> ::__value, __numeric_traits_integer< _Value> , __numeric_traits_floating< _Value> > ::__type { 
# 128
}; 
# 131
}
# 36 "/usr/include/c++/5/bits/move.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _Tp> inline _Tp *
# 47
__addressof(_Tp &__r) noexcept 
# 48
{ 
# 49
return reinterpret_cast< _Tp *>(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__r)))); 
# 51
} 
# 54
}
# 42 "/usr/include/c++/5/type_traits" 3
namespace std { 
# 44
typedef unsigned short uint_least16_t; 
# 45
typedef unsigned uint_least32_t; 
# 46
}
# 52
namespace std __attribute((__visibility__("default"))) { 
# 68 "/usr/include/c++/5/type_traits" 3
template< class _Tp, _Tp __v> 
# 69
struct integral_constant { 
# 71
static constexpr _Tp value = (__v); 
# 72
typedef _Tp value_type; 
# 73
typedef integral_constant type; 
# 74
constexpr operator value_type() const { return value; } 
# 81
}; 
# 83
template< class _Tp, _Tp __v> constexpr _Tp 
# 84
integral_constant< _Tp, __v> ::value; 
# 87
typedef integral_constant< bool, true>  true_type; 
# 90
typedef integral_constant< bool, false>  false_type; 
# 92
template< bool __v> using __bool_constant = integral_constant< bool, __v> ; 
# 97
template< bool , class , class > struct conditional; 
# 100
template< class ...> struct __or_; 
# 104
template<> struct __or_< >  : public false_type { 
# 106
}; 
# 108
template< class _B1> 
# 109
struct __or_< _B1>  : public _B1 { 
# 111
}; 
# 113
template< class _B1, class _B2> 
# 114
struct __or_< _B1, _B2>  : public conditional< _B1::value, _B1, _B2> ::type { 
# 116
}; 
# 118
template< class _B1, class _B2, class _B3, class ..._Bn> 
# 119
struct __or_< _B1, _B2, _B3, _Bn...>  : public conditional< _B1::value, _B1, __or_< _B2, _B3, _Bn...> > ::type { 
# 121
}; 
# 123
template< class ...> struct __and_; 
# 127
template<> struct __and_< >  : public true_type { 
# 129
}; 
# 131
template< class _B1> 
# 132
struct __and_< _B1>  : public _B1 { 
# 134
}; 
# 136
template< class _B1, class _B2> 
# 137
struct __and_< _B1, _B2>  : public conditional< _B1::value, _B2, _B1> ::type { 
# 139
}; 
# 141
template< class _B1, class _B2, class _B3, class ..._Bn> 
# 142
struct __and_< _B1, _B2, _B3, _Bn...>  : public conditional< _B1::value, __and_< _B2, _B3, _Bn...> , _B1> ::type { 
# 144
}; 
# 146
template< class _Pp> 
# 147
struct __not_ : public integral_constant< bool, !_Pp::value>  { 
# 149
}; 
# 156
template< class _Tp> 
# 157
struct __success_type { 
# 158
typedef _Tp type; }; 
# 160
struct __failure_type { 
# 161
}; 
# 165
template< class > struct remove_cv; 
# 168
template< class > 
# 169
struct __is_void_helper : public false_type { 
# 170
}; 
# 173
template<> struct __is_void_helper< void>  : public true_type { 
# 174
}; 
# 177
template< class _Tp> 
# 178
struct is_void : public __is_void_helper< typename remove_cv< _Tp> ::type> ::type { 
# 180
}; 
# 182
template< class > 
# 183
struct __is_integral_helper : public false_type { 
# 184
}; 
# 187
template<> struct __is_integral_helper< bool>  : public true_type { 
# 188
}; 
# 191
template<> struct __is_integral_helper< char>  : public true_type { 
# 192
}; 
# 195
template<> struct __is_integral_helper< signed char>  : public true_type { 
# 196
}; 
# 199
template<> struct __is_integral_helper< unsigned char>  : public true_type { 
# 200
}; 
# 204
template<> struct __is_integral_helper< wchar_t>  : public true_type { 
# 205
}; 
# 209
template<> struct __is_integral_helper< char16_t>  : public true_type { 
# 210
}; 
# 213
template<> struct __is_integral_helper< char32_t>  : public true_type { 
# 214
}; 
# 217
template<> struct __is_integral_helper< short>  : public true_type { 
# 218
}; 
# 221
template<> struct __is_integral_helper< unsigned short>  : public true_type { 
# 222
}; 
# 225
template<> struct __is_integral_helper< int>  : public true_type { 
# 226
}; 
# 229
template<> struct __is_integral_helper< unsigned>  : public true_type { 
# 230
}; 
# 233
template<> struct __is_integral_helper< long>  : public true_type { 
# 234
}; 
# 237
template<> struct __is_integral_helper< unsigned long>  : public true_type { 
# 238
}; 
# 241
template<> struct __is_integral_helper< long long>  : public true_type { 
# 242
}; 
# 245
template<> struct __is_integral_helper< unsigned long long>  : public true_type { 
# 246
}; 
# 288 "/usr/include/c++/5/type_traits" 3
template< class _Tp> 
# 289
struct is_integral : public __is_integral_helper< typename remove_cv< _Tp> ::type> ::type { 
# 291
}; 
# 293
template< class > 
# 294
struct __is_floating_point_helper : public false_type { 
# 295
}; 
# 298
template<> struct __is_floating_point_helper< float>  : public true_type { 
# 299
}; 
# 302
template<> struct __is_floating_point_helper< double>  : public true_type { 
# 303
}; 
# 306
template<> struct __is_floating_point_helper< long double>  : public true_type { 
# 307
}; 
# 316 "/usr/include/c++/5/type_traits" 3
template< class _Tp> 
# 317
struct is_floating_point : public __is_floating_point_helper< typename remove_cv< _Tp> ::type> ::type { 
# 319
}; 
# 322
template< class > 
# 323
struct is_array : public false_type { 
# 324
}; 
# 326
template< class _Tp, size_t _Size> 
# 327
struct is_array< _Tp [_Size]>  : public true_type { 
# 328
}; 
# 330
template< class _Tp> 
# 331
struct is_array< _Tp []>  : public true_type { 
# 332
}; 
# 334
template< class > 
# 335
struct __is_pointer_helper : public false_type { 
# 336
}; 
# 338
template< class _Tp> 
# 339
struct __is_pointer_helper< _Tp *>  : public true_type { 
# 340
}; 
# 343
template< class _Tp> 
# 344
struct is_pointer : public __is_pointer_helper< typename remove_cv< _Tp> ::type> ::type { 
# 346
}; 
# 349
template< class > 
# 350
struct is_lvalue_reference : public false_type { 
# 351
}; 
# 353
template< class _Tp> 
# 354
struct is_lvalue_reference< _Tp &>  : public true_type { 
# 355
}; 
# 358
template< class > 
# 359
struct is_rvalue_reference : public false_type { 
# 360
}; 
# 362
template< class _Tp> 
# 363
struct is_rvalue_reference< _Tp &&>  : public true_type { 
# 364
}; 
# 366
template< class > struct is_function; 
# 369
template< class > 
# 370
struct __is_member_object_pointer_helper : public false_type { 
# 371
}; 
# 373
template< class _Tp, class _Cp> 
# 374
struct __is_member_object_pointer_helper< _Tp (_Cp::*)>  : public integral_constant< bool, !is_function< _Tp> ::value>  { 
# 375
}; 
# 378
template< class _Tp> 
# 379
struct is_member_object_pointer : public __is_member_object_pointer_helper< typename remove_cv< _Tp> ::type> ::type { 
# 382
}; 
# 384
template< class > 
# 385
struct __is_member_function_pointer_helper : public false_type { 
# 386
}; 
# 388
template< class _Tp, class _Cp> 
# 389
struct __is_member_function_pointer_helper< _Tp (_Cp::*)>  : public integral_constant< bool, is_function< _Tp> ::value>  { 
# 390
}; 
# 393
template< class _Tp> 
# 394
struct is_member_function_pointer : public __is_member_function_pointer_helper< typename remove_cv< _Tp> ::type> ::type { 
# 397
}; 
# 400
template< class _Tp> 
# 401
struct is_enum : public integral_constant< bool, __is_enum(_Tp)>  { 
# 403
}; 
# 406
template< class _Tp> 
# 407
struct is_union : public integral_constant< bool, __is_union(_Tp)>  { 
# 409
}; 
# 412
template< class _Tp> 
# 413
struct is_class : public integral_constant< bool, __is_class(_Tp)>  { 
# 415
}; 
# 418
template< class > 
# 419
struct is_function : public false_type { 
# 420
}; 
# 422
template< class _Res, class ..._ArgTypes> 
# 423
struct is_function< _Res (_ArgTypes ...)>  : public true_type { 
# 424
}; 
# 426
template< class _Res, class ..._ArgTypes> 
# 427
struct is_function< _Res (_ArgTypes ...) &>  : public true_type { 
# 428
}; 
# 430
template< class _Res, class ..._ArgTypes> 
# 431
struct is_function< _Res (_ArgTypes ...) &&>  : public true_type { 
# 432
}; 
# 434
template< class _Res, class ..._ArgTypes> 
# 435
struct is_function< _Res (_ArgTypes ..., ...)>  : public true_type { 
# 436
}; 
# 438
template< class _Res, class ..._ArgTypes> 
# 439
struct is_function< _Res (_ArgTypes ..., ...) &>  : public true_type { 
# 440
}; 
# 442
template< class _Res, class ..._ArgTypes> 
# 443
struct is_function< _Res (_ArgTypes ..., ...) &&>  : public true_type { 
# 444
}; 
# 446
template< class _Res, class ..._ArgTypes> 
# 447
struct is_function< _Res (_ArgTypes ...) const>  : public true_type { 
# 448
}; 
# 450
template< class _Res, class ..._ArgTypes> 
# 451
struct is_function< _Res (_ArgTypes ...) const &>  : public true_type { 
# 452
}; 
# 454
template< class _Res, class ..._ArgTypes> 
# 455
struct is_function< _Res (_ArgTypes ...) const &&>  : public true_type { 
# 456
}; 
# 458
template< class _Res, class ..._ArgTypes> 
# 459
struct is_function< _Res (_ArgTypes ..., ...) const>  : public true_type { 
# 460
}; 
# 462
template< class _Res, class ..._ArgTypes> 
# 463
struct is_function< _Res (_ArgTypes ..., ...) const &>  : public true_type { 
# 464
}; 
# 466
template< class _Res, class ..._ArgTypes> 
# 467
struct is_function< _Res (_ArgTypes ..., ...) const &&>  : public true_type { 
# 468
}; 
# 470
template< class _Res, class ..._ArgTypes> 
# 471
struct is_function< _Res (_ArgTypes ...) volatile>  : public true_type { 
# 472
}; 
# 474
template< class _Res, class ..._ArgTypes> 
# 475
struct is_function< _Res (_ArgTypes ...) volatile &>  : public true_type { 
# 476
}; 
# 478
template< class _Res, class ..._ArgTypes> 
# 479
struct is_function< _Res (_ArgTypes ...) volatile &&>  : public true_type { 
# 480
}; 
# 482
template< class _Res, class ..._ArgTypes> 
# 483
struct is_function< _Res (_ArgTypes ..., ...) volatile>  : public true_type { 
# 484
}; 
# 486
template< class _Res, class ..._ArgTypes> 
# 487
struct is_function< _Res (_ArgTypes ..., ...) volatile &>  : public true_type { 
# 488
}; 
# 490
template< class _Res, class ..._ArgTypes> 
# 491
struct is_function< _Res (_ArgTypes ..., ...) volatile &&>  : public true_type { 
# 492
}; 
# 494
template< class _Res, class ..._ArgTypes> 
# 495
struct is_function< _Res (_ArgTypes ...) const volatile>  : public true_type { 
# 496
}; 
# 498
template< class _Res, class ..._ArgTypes> 
# 499
struct is_function< _Res (_ArgTypes ...) const volatile &>  : public true_type { 
# 500
}; 
# 502
template< class _Res, class ..._ArgTypes> 
# 503
struct is_function< _Res (_ArgTypes ...) const volatile &&>  : public true_type { 
# 504
}; 
# 506
template< class _Res, class ..._ArgTypes> 
# 507
struct is_function< _Res (_ArgTypes ..., ...) const volatile>  : public true_type { 
# 508
}; 
# 510
template< class _Res, class ..._ArgTypes> 
# 511
struct is_function< _Res (_ArgTypes ..., ...) const volatile &>  : public true_type { 
# 512
}; 
# 514
template< class _Res, class ..._ArgTypes> 
# 515
struct is_function< _Res (_ArgTypes ..., ...) const volatile &&>  : public true_type { 
# 516
}; 
# 520
template< class > 
# 521
struct __is_null_pointer_helper : public false_type { 
# 522
}; 
# 525
template<> struct __is_null_pointer_helper< nullptr_t>  : public true_type { 
# 526
}; 
# 529
template< class _Tp> 
# 530
struct is_null_pointer : public __is_null_pointer_helper< typename remove_cv< _Tp> ::type> ::type { 
# 532
}; 
# 535
template< class _Tp> 
# 536
struct __is_nullptr_t : public is_null_pointer< _Tp>  { 
# 538
}; 
# 543
template< class _Tp> 
# 544
struct is_reference : public __or_< is_lvalue_reference< _Tp> , is_rvalue_reference< _Tp> > ::type { 
# 547
}; 
# 550
template< class _Tp> 
# 551
struct is_arithmetic : public __or_< is_integral< _Tp> , is_floating_point< _Tp> > ::type { 
# 553
}; 
# 556
template< class _Tp> 
# 557
struct is_fundamental : public __or_< is_arithmetic< _Tp> , is_void< _Tp> , is_null_pointer< _Tp> > ::type { 
# 560
}; 
# 563
template< class _Tp> 
# 564
struct is_object : public __not_< __or_< is_function< _Tp> , is_reference< _Tp> , is_void< _Tp> > > ::type { 
# 567
}; 
# 569
template< class > struct is_member_pointer; 
# 573
template< class _Tp> 
# 574
struct is_scalar : public __or_< is_arithmetic< _Tp> , is_enum< _Tp> , is_pointer< _Tp> , is_member_pointer< _Tp> , is_null_pointer< _Tp> > ::type { 
# 577
}; 
# 580
template< class _Tp> 
# 581
struct is_compound : public integral_constant< bool, !is_fundamental< _Tp> ::value>  { 
# 582
}; 
# 584
template< class _Tp> 
# 585
struct __is_member_pointer_helper : public false_type { 
# 586
}; 
# 588
template< class _Tp, class _Cp> 
# 589
struct __is_member_pointer_helper< _Tp (_Cp::*)>  : public true_type { 
# 590
}; 
# 593
template< class _Tp> 
# 594
struct is_member_pointer : public __is_member_pointer_helper< typename remove_cv< _Tp> ::type> ::type { 
# 596
}; 
# 600
template< class _Tp> 
# 601
struct __is_referenceable : public __or_< is_object< _Tp> , is_reference< _Tp> > ::type { 
# 603
}; 
# 605
template< class _Res, class ..._Args> 
# 606
struct __is_referenceable< _Res (_Args ...)>  : public true_type { 
# 608
}; 
# 610
template< class _Res, class ..._Args> 
# 611
struct __is_referenceable< _Res (_Args ..., ...)>  : public true_type { 
# 613
}; 
# 618
template< class > 
# 619
struct is_const : public false_type { 
# 620
}; 
# 622
template< class _Tp> 
# 623
struct is_const< const _Tp>  : public true_type { 
# 624
}; 
# 627
template< class > 
# 628
struct is_volatile : public false_type { 
# 629
}; 
# 631
template< class _Tp> 
# 632
struct is_volatile< volatile _Tp>  : public true_type { 
# 633
}; 
# 636
template< class _Tp> 
# 637
struct is_trivial : public integral_constant< bool, __is_trivial(_Tp)>  { 
# 639
}; 
# 642
template< class _Tp> 
# 643
struct is_trivially_copyable : public integral_constant< bool, __is_trivially_copyable(_Tp)>  { 
# 645
}; 
# 648
template< class _Tp> 
# 649
struct is_standard_layout : public integral_constant< bool, __is_standard_layout(_Tp)>  { 
# 651
}; 
# 655
template< class _Tp> 
# 656
struct is_pod : public integral_constant< bool, __is_pod(_Tp)>  { 
# 658
}; 
# 661
template< class _Tp> 
# 662
struct is_literal_type : public integral_constant< bool, __is_literal_type(_Tp)>  { 
# 664
}; 
# 667
template< class _Tp> 
# 668
struct is_empty : public integral_constant< bool, __is_empty(_Tp)>  { 
# 670
}; 
# 673
template< class _Tp> 
# 674
struct is_polymorphic : public integral_constant< bool, __is_polymorphic(_Tp)>  { 
# 676
}; 
# 688 "/usr/include/c++/5/type_traits" 3
template< class _Tp> 
# 689
struct is_abstract : public integral_constant< bool, __is_abstract(_Tp)>  { 
# 691
}; 
# 693
template< class _Tp, bool 
# 694
 = is_arithmetic< _Tp> ::value> 
# 695
struct __is_signed_helper : public false_type { 
# 696
}; 
# 698
template< class _Tp> 
# 699
struct __is_signed_helper< _Tp, true>  : public integral_constant< bool, ((_Tp)(-1)) < ((_Tp)0)>  { 
# 701
}; 
# 704
template< class _Tp> 
# 705
struct is_signed : public __is_signed_helper< _Tp> ::type { 
# 707
}; 
# 710
template< class _Tp> 
# 711
struct is_unsigned : public __and_< is_arithmetic< _Tp> , __not_< is_signed< _Tp> > > ::type { 
# 713
}; 
# 718
template< class > struct add_rvalue_reference; 
# 725
template< class _Tp> inline typename add_rvalue_reference< _Tp> ::type declval() noexcept; 
# 728
template< class , unsigned  = 0U> struct extent; 
# 731
template< class > struct remove_all_extents; 
# 734
template< class _Tp> 
# 735
struct __is_array_known_bounds : public integral_constant< bool, (extent< _Tp> ::value > 0)>  { 
# 737
}; 
# 739
template< class _Tp> 
# 740
struct __is_array_unknown_bounds : public __and_< is_array< _Tp> , __not_< extent< _Tp> > > ::type { 
# 742
}; 
# 749
struct __do_is_destructible_impl { 
# 751
template< class _Tp, class  = __decltype(((declval< _Tp &> ().~_Tp())))> static true_type __test(int); 
# 754
template< class > static false_type __test(...); 
# 756
}; 
# 758
template< class _Tp> 
# 759
struct __is_destructible_impl : public __do_is_destructible_impl { 
# 762
typedef __decltype((__test< _Tp> (0))) type; 
# 763
}; 
# 765
template< class _Tp, bool 
# 766
 = __or_< is_void< _Tp> , __is_array_unknown_bounds< _Tp> , is_function< _Tp> > ::value, bool 
# 769
 = __or_< is_reference< _Tp> , is_scalar< _Tp> > ::value> struct __is_destructible_safe; 
# 772
template< class _Tp> 
# 773
struct __is_destructible_safe< _Tp, false, false>  : public __is_destructible_impl< typename remove_all_extents< _Tp> ::type> ::type { 
# 776
}; 
# 778
template< class _Tp> 
# 779
struct __is_destructible_safe< _Tp, true, false>  : public false_type { 
# 780
}; 
# 782
template< class _Tp> 
# 783
struct __is_destructible_safe< _Tp, false, true>  : public true_type { 
# 784
}; 
# 787
template< class _Tp> 
# 788
struct is_destructible : public __is_destructible_safe< _Tp> ::type { 
# 790
}; 
# 796
struct __do_is_nt_destructible_impl { 
# 798
template< class _Tp> static integral_constant< bool, noexcept((declval< _Tp &> ().~_Tp()))>  __test(int); 
# 802
template< class > static false_type __test(...); 
# 804
}; 
# 806
template< class _Tp> 
# 807
struct __is_nt_destructible_impl : public __do_is_nt_destructible_impl { 
# 810
typedef __decltype((__test< _Tp> (0))) type; 
# 811
}; 
# 813
template< class _Tp, bool 
# 814
 = __or_< is_void< _Tp> , __is_array_unknown_bounds< _Tp> , is_function< _Tp> > ::value, bool 
# 817
 = __or_< is_reference< _Tp> , is_scalar< _Tp> > ::value> struct __is_nt_destructible_safe; 
# 820
template< class _Tp> 
# 821
struct __is_nt_destructible_safe< _Tp, false, false>  : public __is_nt_destructible_impl< typename remove_all_extents< _Tp> ::type> ::type { 
# 824
}; 
# 826
template< class _Tp> 
# 827
struct __is_nt_destructible_safe< _Tp, true, false>  : public false_type { 
# 828
}; 
# 830
template< class _Tp> 
# 831
struct __is_nt_destructible_safe< _Tp, false, true>  : public true_type { 
# 832
}; 
# 835
template< class _Tp> 
# 836
struct is_nothrow_destructible : public __is_nt_destructible_safe< _Tp> ::type { 
# 838
}; 
# 840
struct __do_is_default_constructible_impl { 
# 842
template< class _Tp, class  = __decltype((_Tp()))> static true_type __test(int); 
# 845
template< class > static false_type __test(...); 
# 847
}; 
# 849
template< class _Tp> 
# 850
struct __is_default_constructible_impl : public __do_is_default_constructible_impl { 
# 853
typedef __decltype((__test< _Tp> (0))) type; 
# 854
}; 
# 856
template< class _Tp> 
# 857
struct __is_default_constructible_atom : public __and_< __not_< is_void< _Tp> > , __is_default_constructible_impl< _Tp> > ::type { 
# 860
}; 
# 862
template< class _Tp, bool  = is_array< _Tp> ::value> struct __is_default_constructible_safe; 
# 870
template< class _Tp> 
# 871
struct __is_default_constructible_safe< _Tp, true>  : public __and_< __is_array_known_bounds< _Tp> , __is_default_constructible_atom< typename remove_all_extents< _Tp> ::type> > ::type { 
# 875
}; 
# 877
template< class _Tp> 
# 878
struct __is_default_constructible_safe< _Tp, false>  : public __is_default_constructible_atom< _Tp> ::type { 
# 880
}; 
# 883
template< class _Tp> 
# 884
struct is_default_constructible : public __is_default_constructible_safe< _Tp> ::type { 
# 886
}; 
# 900 "/usr/include/c++/5/type_traits" 3
struct __do_is_static_castable_impl { 
# 902
template< class _From, class _To, class 
# 903
 = __decltype((static_cast< _To>(declval< _From> ())))> static true_type 
# 902
__test(int); 
# 906
template< class , class > static false_type __test(...); 
# 908
}; 
# 910
template< class _From, class _To> 
# 911
struct __is_static_castable_impl : public __do_is_static_castable_impl { 
# 914
typedef __decltype((__test< _From, _To> (0))) type; 
# 915
}; 
# 917
template< class _From, class _To> 
# 918
struct __is_static_castable_safe : public __is_static_castable_impl< _From, _To> ::type { 
# 920
}; 
# 923
template< class _From, class _To> 
# 924
struct __is_static_castable : public integral_constant< bool, __is_static_castable_safe< _From, _To> ::value>  { 
# 927
}; 
# 934
struct __do_is_direct_constructible_impl { 
# 936
template< class _Tp, class _Arg, class 
# 937
 = __decltype((::new (_Tp)(declval< _Arg> ())))> static true_type 
# 936
__test(int); 
# 940
template< class , class > static false_type __test(...); 
# 942
}; 
# 944
template< class _Tp, class _Arg> 
# 945
struct __is_direct_constructible_impl : public __do_is_direct_constructible_impl { 
# 948
typedef __decltype((__test< _Tp, _Arg> (0))) type; 
# 949
}; 
# 951
template< class _Tp, class _Arg> 
# 952
struct __is_direct_constructible_new_safe : public __and_< is_destructible< _Tp> , __is_direct_constructible_impl< _Tp, _Arg> > ::type { 
# 955
}; 
# 957
template< class , class > struct is_same; 
# 960
template< class , class > struct is_base_of; 
# 963
template< class > struct remove_reference; 
# 966
template< class _From, class _To, bool 
# 967
 = __not_< __or_< is_void< _From> , is_function< _From> > > ::value> struct __is_base_to_derived_ref; 
# 973
template< class _From, class _To> 
# 974
struct __is_base_to_derived_ref< _From, _To, true>  { 
# 977
typedef typename remove_cv< typename remove_reference< _From> ::type> ::type __src_t; 
# 979
typedef typename remove_cv< typename remove_reference< _To> ::type> ::type __dst_t; 
# 981
typedef __and_< __not_< is_same< typename remove_cv< typename remove_reference< _From> ::type> ::type, typename remove_cv< typename remove_reference< _To> ::type> ::type> > , is_base_of< typename remove_cv< typename remove_reference< _From> ::type> ::type, typename remove_cv< typename remove_reference< _To> ::type> ::type> >  type; 
# 982
static constexpr bool value = (type::value); 
# 983
}; 
# 985
template< class _From, class _To> 
# 986
struct __is_base_to_derived_ref< _From, _To, false>  : public false_type { 
# 988
}; 
# 990
template< class _From, class _To, bool 
# 991
 = __and_< is_lvalue_reference< _From> , is_rvalue_reference< _To> > ::value> struct __is_lvalue_to_rvalue_ref; 
# 997
template< class _From, class _To> 
# 998
struct __is_lvalue_to_rvalue_ref< _From, _To, true>  { 
# 1001
typedef typename remove_cv< typename remove_reference< _From> ::type> ::type __src_t; 
# 1003
typedef typename remove_cv< typename remove_reference< _To> ::type> ::type __dst_t; 
# 1006
typedef __and_< __not_< is_function< typename remove_cv< typename remove_reference< _From> ::type> ::type> > , __or_< is_same< typename remove_cv< typename remove_reference< _From> ::type> ::type, typename remove_cv< typename remove_reference< _To> ::type> ::type> , is_base_of< typename remove_cv< typename remove_reference< _To> ::type> ::type, typename remove_cv< typename remove_reference< _From> ::type> ::type> > >  type; 
# 1007
static constexpr bool value = (type::value); 
# 1008
}; 
# 1010
template< class _From, class _To> 
# 1011
struct __is_lvalue_to_rvalue_ref< _From, _To, false>  : public false_type { 
# 1013
}; 
# 1021
template< class _Tp, class _Arg> 
# 1022
struct __is_direct_constructible_ref_cast : public __and_< __is_static_castable< _Arg, _Tp> , __not_< __or_< __is_base_to_derived_ref< _Arg, _Tp> , __is_lvalue_to_rvalue_ref< _Arg, _Tp> > > > ::type { 
# 1027
}; 
# 1029
template< class _Tp, class _Arg> 
# 1030
struct __is_direct_constructible_new : public conditional< is_reference< _Tp> ::value, __is_direct_constructible_ref_cast< _Tp, _Arg> , __is_direct_constructible_new_safe< _Tp, _Arg> > ::type { 
# 1035
}; 
# 1037
template< class _Tp, class _Arg> 
# 1038
struct __is_direct_constructible : public __is_direct_constructible_new< _Tp, _Arg> ::type { 
# 1040
}; 
# 1047
struct __do_is_nary_constructible_impl { 
# 1049
template< class _Tp, class ..._Args, class 
# 1050
 = __decltype((_Tp(declval< _Args> ()...)))> static true_type 
# 1049
__test(int); 
# 1053
template< class , class ...> static false_type __test(...); 
# 1055
}; 
# 1057
template< class _Tp, class ..._Args> 
# 1058
struct __is_nary_constructible_impl : public __do_is_nary_constructible_impl { 
# 1061
typedef __decltype((__test< _Tp, _Args...> (0))) type; 
# 1062
}; 
# 1064
template< class _Tp, class ..._Args> 
# 1065
struct __is_nary_constructible : public __is_nary_constructible_impl< _Tp, _Args...> ::type { 
# 1068
static_assert((sizeof...(_Args) > (1)), "Only useful for > 1 arguments");
# 1070
}; 
# 1072
template< class _Tp, class ..._Args> 
# 1073
struct __is_constructible_impl : public __is_nary_constructible< _Tp, _Args...>  { 
# 1075
}; 
# 1077
template< class _Tp, class _Arg> 
# 1078
struct __is_constructible_impl< _Tp, _Arg>  : public __is_direct_constructible< _Tp, _Arg>  { 
# 1080
}; 
# 1082
template< class _Tp> 
# 1083
struct __is_constructible_impl< _Tp>  : public is_default_constructible< _Tp>  { 
# 1085
}; 
# 1088
template< class _Tp, class ..._Args> 
# 1089
struct is_constructible : public __is_constructible_impl< _Tp, _Args...> ::type { 
# 1091
}; 
# 1093
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_copy_constructible_impl; 
# 1096
template< class _Tp> 
# 1097
struct __is_copy_constructible_impl< _Tp, false>  : public false_type { 
# 1098
}; 
# 1100
template< class _Tp> 
# 1101
struct __is_copy_constructible_impl< _Tp, true>  : public is_constructible< _Tp, const _Tp &>  { 
# 1103
}; 
# 1106
template< class _Tp> 
# 1107
struct is_copy_constructible : public __is_copy_constructible_impl< _Tp>  { 
# 1109
}; 
# 1111
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_move_constructible_impl; 
# 1114
template< class _Tp> 
# 1115
struct __is_move_constructible_impl< _Tp, false>  : public false_type { 
# 1116
}; 
# 1118
template< class _Tp> 
# 1119
struct __is_move_constructible_impl< _Tp, true>  : public is_constructible< _Tp, _Tp &&>  { 
# 1121
}; 
# 1124
template< class _Tp> 
# 1125
struct is_move_constructible : public __is_move_constructible_impl< _Tp>  { 
# 1127
}; 
# 1129
template< class _Tp> 
# 1130
struct __is_nt_default_constructible_atom : public integral_constant< bool, noexcept((_Tp()))>  { 
# 1132
}; 
# 1134
template< class _Tp, bool  = is_array< _Tp> ::value> struct __is_nt_default_constructible_impl; 
# 1137
template< class _Tp> 
# 1138
struct __is_nt_default_constructible_impl< _Tp, true>  : public __and_< __is_array_known_bounds< _Tp> , __is_nt_default_constructible_atom< typename remove_all_extents< _Tp> ::type> > ::type { 
# 1142
}; 
# 1144
template< class _Tp> 
# 1145
struct __is_nt_default_constructible_impl< _Tp, false>  : public __is_nt_default_constructible_atom< _Tp>  { 
# 1147
}; 
# 1150
template< class _Tp> 
# 1151
struct is_nothrow_default_constructible : public __and_< is_default_constructible< _Tp> , __is_nt_default_constructible_impl< _Tp> > ::type { 
# 1154
}; 
# 1156
template< class _Tp, class ..._Args> 
# 1157
struct __is_nt_constructible_impl : public integral_constant< bool, noexcept((_Tp(declval< _Args> ()...)))>  { 
# 1159
}; 
# 1161
template< class _Tp, class _Arg> 
# 1162
struct __is_nt_constructible_impl< _Tp, _Arg>  : public integral_constant< bool, noexcept((static_cast< _Tp>(declval< _Arg> ())))>  { 
# 1165
}; 
# 1167
template< class _Tp> 
# 1168
struct __is_nt_constructible_impl< _Tp>  : public is_nothrow_default_constructible< _Tp>  { 
# 1170
}; 
# 1173
template< class _Tp, class ..._Args> 
# 1174
struct is_nothrow_constructible : public __and_< is_constructible< _Tp, _Args...> , __is_nt_constructible_impl< _Tp, _Args...> > ::type { 
# 1177
}; 
# 1179
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_nothrow_copy_constructible_impl; 
# 1182
template< class _Tp> 
# 1183
struct __is_nothrow_copy_constructible_impl< _Tp, false>  : public false_type { 
# 1184
}; 
# 1186
template< class _Tp> 
# 1187
struct __is_nothrow_copy_constructible_impl< _Tp, true>  : public is_nothrow_constructible< _Tp, const _Tp &>  { 
# 1189
}; 
# 1192
template< class _Tp> 
# 1193
struct is_nothrow_copy_constructible : public __is_nothrow_copy_constructible_impl< _Tp>  { 
# 1195
}; 
# 1197
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_nothrow_move_constructible_impl; 
# 1200
template< class _Tp> 
# 1201
struct __is_nothrow_move_constructible_impl< _Tp, false>  : public false_type { 
# 1202
}; 
# 1204
template< class _Tp> 
# 1205
struct __is_nothrow_move_constructible_impl< _Tp, true>  : public is_nothrow_constructible< _Tp, _Tp &&>  { 
# 1207
}; 
# 1210
template< class _Tp> 
# 1211
struct is_nothrow_move_constructible : public __is_nothrow_move_constructible_impl< _Tp>  { 
# 1213
}; 
# 1215
template< class _Tp, class _Up> 
# 1216
class __is_assignable_helper { 
# 1218
template< class _Tp1, class _Up1, class 
# 1219
 = __decltype((declval< _Tp1> () = declval< _Up1> ()))> static true_type 
# 1218
__test(int); 
# 1223
template< class , class > static false_type __test(...); 
# 1228
public: typedef __decltype((__test< _Tp, _Up> (0))) type; 
# 1229
}; 
# 1232
template< class _Tp, class _Up> 
# 1233
struct is_assignable : public __is_assignable_helper< _Tp, _Up> ::type { 
# 1235
}; 
# 1237
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_copy_assignable_impl; 
# 1240
template< class _Tp> 
# 1241
struct __is_copy_assignable_impl< _Tp, false>  : public false_type { 
# 1242
}; 
# 1244
template< class _Tp> 
# 1245
struct __is_copy_assignable_impl< _Tp, true>  : public is_assignable< _Tp &, const _Tp &>  { 
# 1247
}; 
# 1250
template< class _Tp> 
# 1251
struct is_copy_assignable : public __is_copy_assignable_impl< _Tp>  { 
# 1253
}; 
# 1255
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_move_assignable_impl; 
# 1258
template< class _Tp> 
# 1259
struct __is_move_assignable_impl< _Tp, false>  : public false_type { 
# 1260
}; 
# 1262
template< class _Tp> 
# 1263
struct __is_move_assignable_impl< _Tp, true>  : public is_assignable< _Tp &, _Tp &&>  { 
# 1265
}; 
# 1268
template< class _Tp> 
# 1269
struct is_move_assignable : public __is_move_assignable_impl< _Tp>  { 
# 1271
}; 
# 1273
template< class _Tp, class _Up> 
# 1274
struct __is_nt_assignable_impl : public integral_constant< bool, noexcept((declval< _Tp> () = declval< _Up> ()))>  { 
# 1276
}; 
# 1279
template< class _Tp, class _Up> 
# 1280
struct is_nothrow_assignable : public __and_< is_assignable< _Tp, _Up> , __is_nt_assignable_impl< _Tp, _Up> > ::type { 
# 1283
}; 
# 1285
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_nt_copy_assignable_impl; 
# 1288
template< class _Tp> 
# 1289
struct __is_nt_copy_assignable_impl< _Tp, false>  : public false_type { 
# 1290
}; 
# 1292
template< class _Tp> 
# 1293
struct __is_nt_copy_assignable_impl< _Tp, true>  : public is_nothrow_assignable< _Tp &, const _Tp &>  { 
# 1295
}; 
# 1298
template< class _Tp> 
# 1299
struct is_nothrow_copy_assignable : public __is_nt_copy_assignable_impl< _Tp>  { 
# 1301
}; 
# 1303
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_nt_move_assignable_impl; 
# 1306
template< class _Tp> 
# 1307
struct __is_nt_move_assignable_impl< _Tp, false>  : public false_type { 
# 1308
}; 
# 1310
template< class _Tp> 
# 1311
struct __is_nt_move_assignable_impl< _Tp, true>  : public is_nothrow_assignable< _Tp &, _Tp &&>  { 
# 1313
}; 
# 1316
template< class _Tp> 
# 1317
struct is_nothrow_move_assignable : public __is_nt_move_assignable_impl< _Tp>  { 
# 1319
}; 
# 1322
template< class _Tp, class ..._Args> 
# 1323
struct is_trivially_constructible : public __and_< is_constructible< _Tp, _Args...> , integral_constant< bool, __is_trivially_constructible(_Tp, _Args...)> > ::type { 
# 1326
}; 
# 1329
template< class _Tp> 
# 1330
struct is_trivially_default_constructible : public is_trivially_constructible< _Tp> ::type { 
# 1332
}; 
# 1335
template< class _Tp> 
# 1336
struct is_trivially_copy_constructible : public __and_< is_copy_constructible< _Tp> , integral_constant< bool, __is_trivially_constructible(_Tp, const _Tp &)> > ::type { 
# 1340
}; 
# 1343
template< class _Tp> 
# 1344
struct is_trivially_move_constructible : public __and_< is_move_constructible< _Tp> , integral_constant< bool, __is_trivially_constructible(_Tp, _Tp &&)> > ::type { 
# 1348
}; 
# 1351
template< class _Tp, class _Up> 
# 1352
struct is_trivially_assignable : public __and_< is_assignable< _Tp, _Up> , integral_constant< bool, __is_trivially_assignable(_Tp, _Up)> > ::type { 
# 1356
}; 
# 1359
template< class _Tp> 
# 1360
struct is_trivially_copy_assignable : public __and_< is_copy_assignable< _Tp> , integral_constant< bool, __is_trivially_assignable(_Tp &, const _Tp &)> > ::type { 
# 1364
}; 
# 1367
template< class _Tp> 
# 1368
struct is_trivially_move_assignable : public __and_< is_move_assignable< _Tp> , integral_constant< bool, __is_trivially_assignable(_Tp &, _Tp &&)> > ::type { 
# 1372
}; 
# 1375
template< class _Tp> 
# 1376
struct is_trivially_destructible : public __and_< is_destructible< _Tp> , integral_constant< bool, __has_trivial_destructor(_Tp)> > ::type { 
# 1379
}; 
# 1382
template< class _Tp> 
# 1383
struct has_trivial_default_constructor : public integral_constant< bool, __has_trivial_constructor(_Tp)>  { 
# 1385
} __attribute((__deprecated__)); 
# 1388
template< class _Tp> 
# 1389
struct has_trivial_copy_constructor : public integral_constant< bool, __has_trivial_copy(_Tp)>  { 
# 1391
} __attribute((__deprecated__)); 
# 1394
template< class _Tp> 
# 1395
struct has_trivial_copy_assign : public integral_constant< bool, __has_trivial_assign(_Tp)>  { 
# 1397
} __attribute((__deprecated__)); 
# 1400
template< class _Tp> 
# 1401
struct has_virtual_destructor : public integral_constant< bool, __has_virtual_destructor(_Tp)>  { 
# 1403
}; 
# 1409
template< class _Tp> 
# 1410
struct alignment_of : public integral_constant< unsigned long, __alignof__(_Tp)>  { 
# 1411
}; 
# 1414
template< class > 
# 1415
struct rank : public integral_constant< unsigned long, 0UL>  { 
# 1416
}; 
# 1418
template< class _Tp, size_t _Size> 
# 1419
struct rank< _Tp [_Size]>  : public integral_constant< unsigned long, 1 + rank< _Tp> ::value>  { 
# 1420
}; 
# 1422
template< class _Tp> 
# 1423
struct rank< _Tp []>  : public integral_constant< unsigned long, 1 + rank< _Tp> ::value>  { 
# 1424
}; 
# 1427
template< class , unsigned _Uint> 
# 1428
struct extent : public integral_constant< unsigned long, 0UL>  { 
# 1429
}; 
# 1431
template< class _Tp, unsigned _Uint, size_t _Size> 
# 1432
struct extent< _Tp [_Size], _Uint>  : public integral_constant< unsigned long, (_Uint == (0)) ? _Size : extent< _Tp, _Uint - (1)> ::value>  { 
# 1436
}; 
# 1438
template< class _Tp, unsigned _Uint> 
# 1439
struct extent< _Tp [], _Uint>  : public integral_constant< unsigned long, (_Uint == (0)) ? 0 : extent< _Tp, _Uint - (1)> ::value>  { 
# 1443
}; 
# 1449
template< class , class > 
# 1450
struct is_same : public false_type { 
# 1451
}; 
# 1453
template< class _Tp> 
# 1454
struct is_same< _Tp, _Tp>  : public true_type { 
# 1455
}; 
# 1458
template< class _Base, class _Derived> 
# 1459
struct is_base_of : public integral_constant< bool, __is_base_of(_Base, _Derived)>  { 
# 1461
}; 
# 1463
template< class _From, class _To, bool 
# 1464
 = __or_< is_void< _From> , is_function< _To> , is_array< _To> > ::value> 
# 1466
struct __is_convertible_helper { 
# 1467
typedef typename is_void< _To> ::type type; }; 
# 1469
template< class _From, class _To> 
# 1470
class __is_convertible_helper< _From, _To, false>  { 
# 1472
template< class _To1> static void __test_aux(_To1); 
# 1475
template< class _From1, class _To1, class 
# 1476
 = __decltype((__test_aux< _To1> (std::declval< _From1> ())))> static true_type 
# 1475
__test(int); 
# 1480
template< class , class > static false_type __test(...); 
# 1485
public: typedef __decltype((__test< _From, _To> (0))) type; 
# 1486
}; 
# 1490
template< class _From, class _To> 
# 1491
struct is_convertible : public __is_convertible_helper< _From, _To> ::type { 
# 1493
}; 
# 1499
template< class _Tp> 
# 1500
struct remove_const { 
# 1501
typedef _Tp type; }; 
# 1503
template< class _Tp> 
# 1504
struct remove_const< const _Tp>  { 
# 1505
typedef _Tp type; }; 
# 1508
template< class _Tp> 
# 1509
struct remove_volatile { 
# 1510
typedef _Tp type; }; 
# 1512
template< class _Tp> 
# 1513
struct remove_volatile< volatile _Tp>  { 
# 1514
typedef _Tp type; }; 
# 1517
template< class _Tp> 
# 1518
struct remove_cv { 
# 1521
typedef typename remove_const< typename remove_volatile< _Tp> ::type> ::type type; 
# 1522
}; 
# 1525
template< class _Tp> 
# 1526
struct add_const { 
# 1527
typedef const _Tp type; }; 
# 1530
template< class _Tp> 
# 1531
struct add_volatile { 
# 1532
typedef volatile _Tp type; }; 
# 1535
template< class _Tp> 
# 1536
struct add_cv { 
# 1539
typedef typename add_const< typename add_volatile< _Tp> ::type> ::type type; 
# 1540
}; 
# 1574 "/usr/include/c++/5/type_traits" 3
template< class _Tp> 
# 1575
struct remove_reference { 
# 1576
typedef _Tp type; }; 
# 1578
template< class _Tp> 
# 1579
struct remove_reference< _Tp &>  { 
# 1580
typedef _Tp type; }; 
# 1582
template< class _Tp> 
# 1583
struct remove_reference< _Tp &&>  { 
# 1584
typedef _Tp type; }; 
# 1586
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> 
# 1587
struct __add_lvalue_reference_helper { 
# 1588
typedef _Tp type; }; 
# 1590
template< class _Tp> 
# 1591
struct __add_lvalue_reference_helper< _Tp, true>  { 
# 1592
typedef _Tp &type; }; 
# 1595
template< class _Tp> 
# 1596
struct add_lvalue_reference : public __add_lvalue_reference_helper< _Tp>  { 
# 1598
}; 
# 1600
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> 
# 1601
struct __add_rvalue_reference_helper { 
# 1602
typedef _Tp type; }; 
# 1604
template< class _Tp> 
# 1605
struct __add_rvalue_reference_helper< _Tp, true>  { 
# 1606
typedef _Tp &&type; }; 
# 1609
template< class _Tp> 
# 1610
struct add_rvalue_reference : public __add_rvalue_reference_helper< _Tp>  { 
# 1612
}; 
# 1631 "/usr/include/c++/5/type_traits" 3
template< class _Unqualified, bool _IsConst, bool _IsVol> struct __cv_selector; 
# 1634
template< class _Unqualified> 
# 1635
struct __cv_selector< _Unqualified, false, false>  { 
# 1636
typedef _Unqualified __type; }; 
# 1638
template< class _Unqualified> 
# 1639
struct __cv_selector< _Unqualified, false, true>  { 
# 1640
typedef volatile _Unqualified __type; }; 
# 1642
template< class _Unqualified> 
# 1643
struct __cv_selector< _Unqualified, true, false>  { 
# 1644
typedef const _Unqualified __type; }; 
# 1646
template< class _Unqualified> 
# 1647
struct __cv_selector< _Unqualified, true, true>  { 
# 1648
typedef const volatile _Unqualified __type; }; 
# 1650
template< class _Qualified, class _Unqualified, bool 
# 1651
_IsConst = is_const< _Qualified> ::value, bool 
# 1652
_IsVol = is_volatile< _Qualified> ::value> 
# 1653
class __match_cv_qualifiers { 
# 1655
typedef __cv_selector< _Unqualified, _IsConst, _IsVol>  __match; 
# 1658
public: typedef typename __cv_selector< _Unqualified, _IsConst, _IsVol> ::__type __type; 
# 1659
}; 
# 1662
template< class _Tp> 
# 1663
struct __make_unsigned { 
# 1664
typedef _Tp __type; }; 
# 1667
template<> struct __make_unsigned< char>  { 
# 1668
typedef unsigned char __type; }; 
# 1671
template<> struct __make_unsigned< signed char>  { 
# 1672
typedef unsigned char __type; }; 
# 1675
template<> struct __make_unsigned< short>  { 
# 1676
typedef unsigned short __type; }; 
# 1679
template<> struct __make_unsigned< int>  { 
# 1680
typedef unsigned __type; }; 
# 1683
template<> struct __make_unsigned< long>  { 
# 1684
typedef unsigned long __type; }; 
# 1687
template<> struct __make_unsigned< long long>  { 
# 1688
typedef unsigned long long __type; }; 
# 1718 "/usr/include/c++/5/type_traits" 3
template< class _Tp, bool 
# 1719
_IsInt = is_integral< _Tp> ::value, bool 
# 1720
_IsEnum = is_enum< _Tp> ::value> class __make_unsigned_selector; 
# 1723
template< class _Tp> 
# 1724
class __make_unsigned_selector< _Tp, true, false>  { 
# 1726
typedef __make_unsigned< typename remove_cv< _Tp> ::type>  __unsignedt; 
# 1727
typedef typename __make_unsigned< typename remove_cv< _Tp> ::type> ::__type __unsigned_type; 
# 1728
typedef __match_cv_qualifiers< _Tp, typename __make_unsigned< typename remove_cv< _Tp> ::type> ::__type>  __cv_unsigned; 
# 1731
public: typedef typename __match_cv_qualifiers< _Tp, typename __make_unsigned< typename remove_cv< _Tp> ::type> ::__type> ::__type __type; 
# 1732
}; 
# 1734
template< class _Tp> 
# 1735
class __make_unsigned_selector< _Tp, false, true>  { 
# 1738
typedef unsigned char __smallest; 
# 1739
static const bool __b0 = (sizeof(_Tp) <= sizeof(__smallest)); 
# 1740
static const bool __b1 = (sizeof(_Tp) <= sizeof(unsigned short)); 
# 1741
static const bool __b2 = (sizeof(_Tp) <= sizeof(unsigned)); 
# 1742
typedef conditional< __b2, unsigned, unsigned long>  __cond2; 
# 1743
typedef typename conditional< __b2, unsigned, unsigned long> ::type __cond2_type; 
# 1744
typedef conditional< __b1, unsigned short, typename conditional< __b2, unsigned, unsigned long> ::type>  __cond1; 
# 1745
typedef typename conditional< __b1, unsigned short, typename conditional< __b2, unsigned, unsigned long> ::type> ::type __cond1_type; 
# 1748
public: typedef typename conditional< __b0, unsigned char, typename conditional< __b1, unsigned short, typename conditional< __b2, unsigned, unsigned long> ::type> ::type> ::type __type; 
# 1749
}; 
# 1755
template< class _Tp> 
# 1756
struct make_unsigned { 
# 1757
typedef typename __make_unsigned_selector< _Tp> ::__type type; }; 
# 1761
template<> struct make_unsigned< bool> ; 
# 1765
template< class _Tp> 
# 1766
struct __make_signed { 
# 1767
typedef _Tp __type; }; 
# 1770
template<> struct __make_signed< char>  { 
# 1771
typedef signed char __type; }; 
# 1774
template<> struct __make_signed< unsigned char>  { 
# 1775
typedef signed char __type; }; 
# 1778
template<> struct __make_signed< unsigned short>  { 
# 1779
typedef signed short __type; }; 
# 1782
template<> struct __make_signed< unsigned>  { 
# 1783
typedef signed int __type; }; 
# 1786
template<> struct __make_signed< unsigned long>  { 
# 1787
typedef signed long __type; }; 
# 1790
template<> struct __make_signed< unsigned long long>  { 
# 1791
typedef signed long long __type; }; 
# 1795
template<> struct __make_signed< wchar_t>  : public __make_signed< unsigned>  { 
# 1796
}; 
# 1801
template<> struct __make_signed< char16_t>  : public __make_signed< unsigned short>  { 
# 1802
}; 
# 1804
template<> struct __make_signed< char32_t>  : public __make_signed< unsigned>  { 
# 1805
}; 
# 1830 "/usr/include/c++/5/type_traits" 3
template< class _Tp, bool 
# 1831
_IsInt = is_integral< _Tp> ::value, bool 
# 1832
_IsEnum = is_enum< _Tp> ::value> class __make_signed_selector; 
# 1835
template< class _Tp> 
# 1836
class __make_signed_selector< _Tp, true, false>  { 
# 1838
typedef __make_signed< typename remove_cv< _Tp> ::type>  __signedt; 
# 1839
typedef typename __make_signed< typename remove_cv< _Tp> ::type> ::__type __signed_type; 
# 1840
typedef __match_cv_qualifiers< _Tp, typename __make_signed< typename remove_cv< _Tp> ::type> ::__type>  __cv_signed; 
# 1843
public: typedef typename __match_cv_qualifiers< _Tp, typename __make_signed< typename remove_cv< _Tp> ::type> ::__type> ::__type __type; 
# 1844
}; 
# 1846
template< class _Tp> 
# 1847
class __make_signed_selector< _Tp, false, true>  { 
# 1850
typedef signed char __smallest; 
# 1851
static const bool __b0 = (sizeof(_Tp) <= sizeof(__smallest)); 
# 1852
static const bool __b1 = (sizeof(_Tp) <= sizeof(signed short)); 
# 1853
static const bool __b2 = (sizeof(_Tp) <= sizeof(signed int)); 
# 1854
typedef conditional< __b2, signed int, signed long>  __cond2; 
# 1855
typedef typename conditional< __b2, signed int, signed long> ::type __cond2_type; 
# 1856
typedef conditional< __b1, signed short, typename conditional< __b2, signed int, signed long> ::type>  __cond1; 
# 1857
typedef typename conditional< __b1, signed short, typename conditional< __b2, signed int, signed long> ::type> ::type __cond1_type; 
# 1860
public: typedef typename conditional< __b0, signed char, typename conditional< __b1, signed short, typename conditional< __b2, signed int, signed long> ::type> ::type> ::type __type; 
# 1861
}; 
# 1867
template< class _Tp> 
# 1868
struct make_signed { 
# 1869
typedef typename __make_signed_selector< _Tp> ::__type type; }; 
# 1873
template<> struct make_signed< bool> ; 
# 1888 "/usr/include/c++/5/type_traits" 3
template< class _Tp> 
# 1889
struct remove_extent { 
# 1890
typedef _Tp type; }; 
# 1892
template< class _Tp, size_t _Size> 
# 1893
struct remove_extent< _Tp [_Size]>  { 
# 1894
typedef _Tp type; }; 
# 1896
template< class _Tp> 
# 1897
struct remove_extent< _Tp []>  { 
# 1898
typedef _Tp type; }; 
# 1901
template< class _Tp> 
# 1902
struct remove_all_extents { 
# 1903
typedef _Tp type; }; 
# 1905
template< class _Tp, size_t _Size> 
# 1906
struct remove_all_extents< _Tp [_Size]>  { 
# 1907
typedef typename std::remove_all_extents< _Tp> ::type type; }; 
# 1909
template< class _Tp> 
# 1910
struct remove_all_extents< _Tp []>  { 
# 1911
typedef typename std::remove_all_extents< _Tp> ::type type; }; 
# 1925 "/usr/include/c++/5/type_traits" 3
template< class _Tp, class > 
# 1926
struct __remove_pointer_helper { 
# 1927
typedef _Tp type; }; 
# 1929
template< class _Tp, class _Up> 
# 1930
struct __remove_pointer_helper< _Tp, _Up *>  { 
# 1931
typedef _Up type; }; 
# 1934
template< class _Tp> 
# 1935
struct remove_pointer : public __remove_pointer_helper< _Tp, typename remove_cv< _Tp> ::type>  { 
# 1937
}; 
# 1940
template< class _Tp, bool  = __or_< __is_referenceable< _Tp> , is_void< _Tp> > ::value> 
# 1942
struct __add_pointer_helper { 
# 1943
typedef _Tp type; }; 
# 1945
template< class _Tp> 
# 1946
struct __add_pointer_helper< _Tp, true>  { 
# 1947
typedef typename remove_reference< _Tp> ::type *type; }; 
# 1949
template< class _Tp> 
# 1950
struct add_pointer : public __add_pointer_helper< _Tp>  { 
# 1952
}; 
# 1964 "/usr/include/c++/5/type_traits" 3
template< size_t _Len> 
# 1965
struct __aligned_storage_msa { 
# 1967
union __type { 
# 1969
unsigned char __data[_Len]; 
# 1970
struct __attribute((__aligned__)) { } __align; 
# 1971
}; 
# 1972
}; 
# 1984 "/usr/include/c++/5/type_traits" 3
template< size_t _Len, size_t _Align = __alignof__(typename __aligned_storage_msa< _Len> ::__type)> 
# 1986
struct aligned_storage { 
# 1988
union type { 
# 1990
unsigned char __data[_Len]; 
# 1991
struct __attribute((__aligned__(_Align))) { } __align; 
# 1992
}; 
# 1993
}; 
# 1995
template< class ..._Types> 
# 1996
struct __strictest_alignment { 
# 1998
static const size_t _S_alignment = (0); 
# 1999
static const size_t _S_size = (0); 
# 2000
}; 
# 2002
template< class _Tp, class ..._Types> 
# 2003
struct __strictest_alignment< _Tp, _Types...>  { 
# 2005
static const size_t _S_alignment = ((__alignof__(_Tp) > __strictest_alignment< _Types...> ::_S_alignment) ? __alignof__(_Tp) : __strictest_alignment< _Types...> ::_S_alignment); 
# 2008
static const size_t _S_size = ((sizeof(_Tp) > __strictest_alignment< _Types...> ::_S_size) ? sizeof(_Tp) : __strictest_alignment< _Types...> ::_S_size); 
# 2011
}; 
# 2023 "/usr/include/c++/5/type_traits" 3
template< size_t _Len, class ..._Types> 
# 2024
struct aligned_union { 
# 2027
static_assert((sizeof...(_Types) != (0)), "At least one type is required");
# 2029
private: using __strictest = __strictest_alignment< _Types...> ; 
# 2030
static const size_t _S_len = ((_Len > __strictest::_S_size) ? _Len : __strictest::_S_size); 
# 2034
public: static const size_t alignment_value = (__strictest::_S_alignment); 
# 2036
typedef typename aligned_storage< _S_len, alignment_value> ::type type; 
# 2037
}; 
# 2039
template< size_t _Len, class ..._Types> const size_t 
# 2040
aligned_union< _Len, _Types...> ::alignment_value; 
# 2044
template< class _Up, bool 
# 2045
_IsArray = is_array< _Up> ::value, bool 
# 2046
_IsFunction = is_function< _Up> ::value> struct __decay_selector; 
# 2050
template< class _Up> 
# 2051
struct __decay_selector< _Up, false, false>  { 
# 2052
typedef typename remove_cv< _Up> ::type __type; }; 
# 2054
template< class _Up> 
# 2055
struct __decay_selector< _Up, true, false>  { 
# 2056
typedef typename remove_extent< _Up> ::type *__type; }; 
# 2058
template< class _Up> 
# 2059
struct __decay_selector< _Up, false, true>  { 
# 2060
typedef typename add_pointer< _Up> ::type __type; }; 
# 2063
template< class _Tp> 
# 2064
class decay { 
# 2066
typedef typename remove_reference< _Tp> ::type __remove_type; 
# 2069
public: typedef typename __decay_selector< typename remove_reference< _Tp> ::type> ::__type type; 
# 2070
}; 
# 2072
template< class _Tp> class reference_wrapper; 
# 2076
template< class _Tp> 
# 2077
struct __strip_reference_wrapper { 
# 2079
typedef _Tp __type; 
# 2080
}; 
# 2082
template< class _Tp> 
# 2083
struct __strip_reference_wrapper< reference_wrapper< _Tp> >  { 
# 2085
typedef _Tp &__type; 
# 2086
}; 
# 2088
template< class _Tp> 
# 2089
struct __decay_and_strip { 
# 2092
typedef typename __strip_reference_wrapper< typename decay< _Tp> ::type> ::__type __type; 
# 2093
}; 
# 2098
template< bool , class _Tp = void> 
# 2099
struct enable_if { 
# 2100
}; 
# 2103
template< class _Tp> 
# 2104
struct enable_if< true, _Tp>  { 
# 2105
typedef _Tp type; }; 
# 2107
template< class ..._Cond> using _Require = typename enable_if< __and_< _Cond...> ::value> ::type; 
# 2112
template< bool _Cond, class _Iftrue, class _Iffalse> 
# 2113
struct conditional { 
# 2114
typedef _Iftrue type; }; 
# 2117
template< class _Iftrue, class _Iffalse> 
# 2118
struct conditional< false, _Iftrue, _Iffalse>  { 
# 2119
typedef _Iffalse type; }; 
# 2122
template< class ..._Tp> struct common_type; 
# 2127
struct __do_common_type_impl { 
# 2129
template< class _Tp, class _Up> static __success_type< typename decay< __decltype((true ? std::declval< _Tp> () : std::declval< _Up> ()))> ::type>  _S_test(int); 
# 2134
template< class , class > static __failure_type _S_test(...); 
# 2136
}; 
# 2138
template< class _Tp, class _Up> 
# 2139
struct __common_type_impl : private __do_common_type_impl { 
# 2142
typedef __decltype((_S_test< _Tp, _Up> (0))) type; 
# 2143
}; 
# 2145
struct __do_member_type_wrapper { 
# 2147
template< class _Tp> static __success_type< typename _Tp::type>  _S_test(int); 
# 2150
template< class > static __failure_type _S_test(...); 
# 2152
}; 
# 2154
template< class _Tp> 
# 2155
struct __member_type_wrapper : private __do_member_type_wrapper { 
# 2158
typedef __decltype((_S_test< _Tp> (0))) type; 
# 2159
}; 
# 2161
template< class _CTp, class ..._Args> 
# 2162
struct __expanded_common_type_wrapper { 
# 2164
typedef common_type< typename _CTp::type, _Args...>  type; 
# 2165
}; 
# 2167
template< class ..._Args> 
# 2168
struct __expanded_common_type_wrapper< __failure_type, _Args...>  { 
# 2169
typedef __failure_type type; }; 
# 2171
template< class _Tp> 
# 2172
struct common_type< _Tp>  { 
# 2173
typedef typename decay< _Tp> ::type type; }; 
# 2175
template< class _Tp, class _Up> 
# 2176
struct common_type< _Tp, _Up>  : public __common_type_impl< _Tp, _Up> ::type { 
# 2178
}; 
# 2180
template< class _Tp, class _Up, class ..._Vp> 
# 2181
struct common_type< _Tp, _Up, _Vp...>  : public __expanded_common_type_wrapper< typename __member_type_wrapper< common_type< _Tp, _Up> > ::type, _Vp...> ::type { 
# 2184
}; 
# 2187
template< class _Tp> 
# 2188
struct underlying_type { 
# 2190
typedef __underlying_type(_Tp) type; 
# 2191
}; 
# 2193
template< class _Tp> 
# 2194
struct __declval_protector { 
# 2196
static const bool __stop = false; 
# 2197
static typename add_rvalue_reference< _Tp> ::type __delegate(); 
# 2198
}; 
# 2200
template< class _Tp> inline typename add_rvalue_reference< _Tp> ::type 
# 2202
declval() noexcept 
# 2203
{ 
# 2204
static_assert((__declval_protector< _Tp> ::__stop), "declval() must not be used!");
# 2206
return __declval_protector< _Tp> ::__delegate(); 
# 2207
} 
# 2210
template< class _Signature> class result_of; 
# 2218
struct __result_of_memfun_ref_impl { 
# 2220
template< class _Fp, class _Tp1, class ..._Args> static __success_type< __decltype(((std::declval< _Tp1> ().*std::declval< _Fp> ())(std::declval< _Args> ()...)))>  _S_test(int); 
# 2225
template< class ...> static __failure_type _S_test(...); 
# 2227
}; 
# 2229
template< class _MemPtr, class _Arg, class ..._Args> 
# 2230
struct __result_of_memfun_ref : private __result_of_memfun_ref_impl { 
# 2233
typedef __decltype((_S_test< _MemPtr, _Arg, _Args...> (0))) type; 
# 2234
}; 
# 2237
struct __result_of_memfun_deref_impl { 
# 2239
template< class _Fp, class _Tp1, class ..._Args> static __success_type< __decltype((((*std::declval< _Tp1> ()).*std::declval< _Fp> ())(std::declval< _Args> ()...)))>  _S_test(int); 
# 2244
template< class ...> static __failure_type _S_test(...); 
# 2246
}; 
# 2248
template< class _MemPtr, class _Arg, class ..._Args> 
# 2249
struct __result_of_memfun_deref : private __result_of_memfun_deref_impl { 
# 2252
typedef __decltype((_S_test< _MemPtr, _Arg, _Args...> (0))) type; 
# 2253
}; 
# 2256
struct __result_of_memobj_ref_impl { 
# 2258
template< class _Fp, class _Tp1> static __success_type< __decltype((std::declval< _Tp1> ().*std::declval< _Fp> ()))>  _S_test(int); 
# 2263
template< class , class > static __failure_type _S_test(...); 
# 2265
}; 
# 2267
template< class _MemPtr, class _Arg> 
# 2268
struct __result_of_memobj_ref : private __result_of_memobj_ref_impl { 
# 2271
typedef __decltype((_S_test< _MemPtr, _Arg> (0))) type; 
# 2272
}; 
# 2275
struct __result_of_memobj_deref_impl { 
# 2277
template< class _Fp, class _Tp1> static __success_type< __decltype(((*std::declval< _Tp1> ()).*std::declval< _Fp> ()))>  _S_test(int); 
# 2282
template< class , class > static __failure_type _S_test(...); 
# 2284
}; 
# 2286
template< class _MemPtr, class _Arg> 
# 2287
struct __result_of_memobj_deref : private __result_of_memobj_deref_impl { 
# 2290
typedef __decltype((_S_test< _MemPtr, _Arg> (0))) type; 
# 2291
}; 
# 2293
template< class _MemPtr, class _Arg> struct __result_of_memobj; 
# 2296
template< class _Res, class _Class, class _Arg> 
# 2297
struct __result_of_memobj< _Res (_Class::*), _Arg>  { 
# 2300
typedef typename remove_cv< typename remove_reference< _Arg> ::type> ::type _Argval; 
# 2301
typedef _Res (_Class::*_MemPtr); 
# 2306
typedef typename conditional< __or_< is_same< typename remove_cv< typename remove_reference< _Arg> ::type> ::type, _Class> , is_base_of< _Class, typename remove_cv< typename remove_reference< _Arg> ::type> ::type> > ::value, __result_of_memobj_ref< _Res (_Class::*), _Arg> , __result_of_memobj_deref< _Res (_Class::*), _Arg> > ::type::type type; 
# 2307
}; 
# 2309
template< class _MemPtr, class _Arg, class ..._Args> struct __result_of_memfun; 
# 2312
template< class _Res, class _Class, class _Arg, class ..._Args> 
# 2313
struct __result_of_memfun< _Res (_Class::*), _Arg, _Args...>  { 
# 2316
typedef typename remove_cv< typename remove_reference< _Arg> ::type> ::type _Argval; 
# 2317
typedef _Res (_Class::*_MemPtr); 
# 2322
typedef typename conditional< __or_< is_same< typename remove_cv< typename remove_reference< _Arg> ::type> ::type, _Class> , is_base_of< _Class, typename remove_cv< typename remove_reference< _Arg> ::type> ::type> > ::value, __result_of_memfun_ref< _Res (_Class::*), _Arg, _Args...> , __result_of_memfun_deref< _Res (_Class::*), _Arg, _Args...> > ::type::type type; 
# 2323
}; 
# 2325
template< bool , bool , class _Functor, class ..._ArgTypes> 
# 2326
struct __result_of_impl { 
# 2328
typedef __failure_type type; 
# 2329
}; 
# 2331
template< class _MemPtr, class _Arg> 
# 2332
struct __result_of_impl< true, false, _MemPtr, _Arg>  : public __result_of_memobj< typename decay< _MemPtr> ::type, _Arg>  { 
# 2334
}; 
# 2336
template< class _MemPtr, class _Arg, class ..._Args> 
# 2337
struct __result_of_impl< false, true, _MemPtr, _Arg, _Args...>  : public __result_of_memfun< typename decay< _MemPtr> ::type, _Arg, _Args...>  { 
# 2339
}; 
# 2342
struct __result_of_other_impl { 
# 2344
template< class _Fn, class ..._Args> static __success_type< __decltype((std::declval< _Fn> ()(std::declval< _Args> ()...)))>  _S_test(int); 
# 2349
template< class ...> static __failure_type _S_test(...); 
# 2351
}; 
# 2353
template< class _Functor, class ..._ArgTypes> 
# 2354
struct __result_of_impl< false, false, _Functor, _ArgTypes...>  : private __result_of_other_impl { 
# 2357
typedef __decltype((_S_test< _Functor, _ArgTypes...> (0))) type; 
# 2358
}; 
# 2360
template< class _Functor, class ..._ArgTypes> 
# 2361
struct result_of< _Functor (_ArgTypes ...)>  : public __result_of_impl< is_member_object_pointer< typename remove_reference< _Functor> ::type> ::value, is_member_function_pointer< typename remove_reference< _Functor> ::type> ::value, _Functor, _ArgTypes...> ::type { 
# 2371
}; 
# 2407 "/usr/include/c++/5/type_traits" 3
template< class ...> using __void_t = void; 
# 2426 "/usr/include/c++/5/type_traits" 3
}
# 59 "/usr/include/c++/5/bits/move.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 74 "/usr/include/c++/5/bits/move.h" 3
template< class _Tp> constexpr _Tp &&
# 76
forward(typename remove_reference< _Tp> ::type &__t) noexcept 
# 77
{ return static_cast< _Tp &&>(__t); } 
# 85
template< class _Tp> constexpr _Tp &&
# 87
forward(typename remove_reference< _Tp> ::type &&__t) noexcept 
# 88
{ 
# 89
static_assert((!std::is_lvalue_reference< _Tp> ::value), "template argument substituting _Tp is an lvalue reference type");
# 91
return static_cast< _Tp &&>(__t); 
# 92
} 
# 99
template< class _Tp> constexpr typename remove_reference< _Tp> ::type &&
# 101
move(_Tp &&__t) noexcept 
# 102
{ return static_cast< typename remove_reference< _Tp> ::type &&>(__t); } 
# 105
template< class _Tp> 
# 106
struct __move_if_noexcept_cond : public __and_< __not_< is_nothrow_move_constructible< _Tp> > , is_copy_constructible< _Tp> > ::type { 
# 108
}; 
# 118 "/usr/include/c++/5/bits/move.h" 3
template< class _Tp> constexpr typename conditional< __move_if_noexcept_cond< _Tp> ::value, const _Tp &, _Tp &&> ::type 
# 121
move_if_noexcept(_Tp &__x) noexcept 
# 122
{ return std::move(__x); } 
# 133 "/usr/include/c++/5/bits/move.h" 3
template< class _Tp> inline _Tp *
# 135
addressof(_Tp &__r) noexcept 
# 136
{ return std::__addressof(__r); } 
# 139
template< class _Tp, class _Up = _Tp> inline _Tp 
# 141
__exchange(_Tp &__obj, _Up &&__new_val) 
# 142
{ 
# 143
_Tp __old_val = std::move(__obj); 
# 144
__obj = std::forward< _Up> (__new_val); 
# 145
return __old_val; 
# 146
} 
# 150
}
# 159 "/usr/include/c++/5/bits/move.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 174 "/usr/include/c++/5/bits/move.h" 3
template< class _Tp> inline void 
# 176
swap(_Tp &__a, _Tp &__b) noexcept(__and_< is_nothrow_move_constructible< _Tp> , is_nothrow_move_assignable< _Tp> > ::value) 
# 181
{ 
# 185
_Tp __tmp = std::move(__a); 
# 186
__a = std::move(__b); 
# 187
__b = std::move(__tmp); 
# 188
} 
# 193
template< class _Tp, size_t _Nm> inline void 
# 195
swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(noexcept(swap(*(__a), *(__b)))) 
# 199
{ 
# 200
for (size_t __n = (0); __n < _Nm; ++__n) { 
# 201
swap((__a)[__n], (__b)[__n]); }  
# 202
} 
# 206
}
# 65 "/usr/include/c++/5/bits/stl_pair.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 76 "/usr/include/c++/5/bits/stl_pair.h" 3
struct piecewise_construct_t { }; 
# 79
constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t(); 
# 82
template< class ...> class tuple; 
# 85
template< size_t ...> struct _Index_tuple; 
# 95 "/usr/include/c++/5/bits/stl_pair.h" 3
template< class _T1, class _T2> 
# 96
struct pair { 
# 98
typedef _T1 first_type; 
# 99
typedef _T2 second_type; 
# 101
_T1 first; 
# 102
_T2 second; 
# 108
constexpr pair() : first(), second() 
# 109
{ } 
# 112
constexpr pair(const _T1 &__a, const _T2 &__b) : first(__a), second(__b) 
# 113
{ } 
# 121
template< class _U1, class _U2, class  = typename enable_if< __and_< is_convertible< const _U1 &, _T1> , is_convertible< const _U2 &, _T2> > ::value> ::type> constexpr 
# 124
pair(const std::pair< _U1, _U2>  &__p) : first((__p.first)), second((__p.second)) 
# 125
{ } 
# 127
constexpr pair(const pair &) = default;
# 128
constexpr pair(pair &&) = default;
# 131
template< class _U1, class  = typename enable_if< is_convertible< _U1, _T1> ::value> ::type> constexpr 
# 133
pair(_U1 &&__x, const _T2 &__y) : first(std::forward< _U1> (__x)), second(__y) 
# 134
{ } 
# 136
template< class _U2, class  = typename enable_if< is_convertible< _U2, _T2> ::value> ::type> constexpr 
# 138
pair(const _T1 &__x, _U2 &&__y) : first(__x), second(std::forward< _U2> (__y)) 
# 139
{ } 
# 141
template< class _U1, class _U2, class  = typename enable_if< __and_< is_convertible< _U1, _T1> , is_convertible< _U2, _T2> > ::value> ::type> constexpr 
# 144
pair(_U1 &&__x, _U2 &&__y) : first(std::forward< _U1> (__x)), second(std::forward< _U2> (__y)) 
# 145
{ } 
# 147
template< class _U1, class _U2, class  = typename enable_if< __and_< is_convertible< _U1, _T1> , is_convertible< _U2, _T2> > ::value> ::type> constexpr 
# 150
pair(std::pair< _U1, _U2>  &&__p) : first(std::forward< _U1> ((__p.first))), second(std::forward< _U2> ((__p.second))) 
# 152
{ } 
# 154
template< class ..._Args1, class ..._Args2> inline pair(piecewise_construct_t, tuple< _Args1...> , tuple< _Args2...> ); 
# 158
pair &operator=(const pair &__p) 
# 159
{ 
# 160
(first) = (__p.first); 
# 161
(second) = (__p.second); 
# 162
return *this; 
# 163
} 
# 166
pair &operator=(pair &&__p) noexcept(__and_< is_nothrow_move_assignable< _T1> , is_nothrow_move_assignable< _T2> > ::value) 
# 169
{ 
# 170
(first) = std::forward< first_type> ((__p.first)); 
# 171
(second) = std::forward< second_type> ((__p.second)); 
# 172
return *this; 
# 173
} 
# 175
template< class _U1, class _U2> pair &
# 177
operator=(const std::pair< _U1, _U2>  &__p) 
# 178
{ 
# 179
(first) = (__p.first); 
# 180
(second) = (__p.second); 
# 181
return *this; 
# 182
} 
# 184
template< class _U1, class _U2> pair &
# 186
operator=(std::pair< _U1, _U2>  &&__p) 
# 187
{ 
# 188
(first) = std::forward< _U1> ((__p.first)); 
# 189
(second) = std::forward< _U2> ((__p.second)); 
# 190
return *this; 
# 191
} 
# 194
void swap(pair &__p) noexcept(noexcept(swap(first, (__p.first))) && noexcept(swap(second, (__p.second)))) 
# 197
{ 
# 198
using std::swap;
# 199
swap(first, (__p.first)); 
# 200
swap(second, (__p.second)); 
# 201
} 
# 204
private: template< class ..._Args1, size_t ..._Indexes1, class ...
# 205
_Args2, size_t ..._Indexes2> inline 
# 204
pair(tuple< _Args1...>  &, tuple< _Args2...>  &, _Index_tuple< _Indexes1...> , _Index_tuple< _Indexes2...> ); 
# 209
}; 
# 212
template< class _T1, class _T2> constexpr bool 
# 214
operator==(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 215
{ return ((__x.first) == (__y.first)) && ((__x.second) == (__y.second)); } 
# 218
template< class _T1, class _T2> constexpr bool 
# 220
operator<(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 221
{ return ((__x.first) < (__y.first)) || ((!((__y.first) < (__x.first))) && ((__x.second) < (__y.second))); 
# 222
} 
# 225
template< class _T1, class _T2> constexpr bool 
# 227
operator!=(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 228
{ return !(__x == __y); } 
# 231
template< class _T1, class _T2> constexpr bool 
# 233
operator>(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 234
{ return __y < __x; } 
# 237
template< class _T1, class _T2> constexpr bool 
# 239
operator<=(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 240
{ return !(__y < __x); } 
# 243
template< class _T1, class _T2> constexpr bool 
# 245
operator>=(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 246
{ return !(__x < __y); } 
# 252
template< class _T1, class _T2> inline void 
# 254
swap(pair< _T1, _T2>  &__x, pair< _T1, _T2>  &__y) noexcept(noexcept((__x.swap(__y)))) 
# 256
{ (__x.swap(__y)); } 
# 273 "/usr/include/c++/5/bits/stl_pair.h" 3
template< class _T1, class _T2> constexpr pair< typename __decay_and_strip< _T1> ::__type, typename __decay_and_strip< _T2> ::__type>  
# 276
make_pair(_T1 &&__x, _T2 &&__y) 
# 277
{ 
# 278
typedef typename __decay_and_strip< _T1> ::__type __ds_type1; 
# 279
typedef typename __decay_and_strip< _T2> ::__type __ds_type2; 
# 280
typedef pair< typename __decay_and_strip< _T1> ::__type, typename __decay_and_strip< _T2> ::__type>  __pair_type; 
# 281
return __pair_type(std::forward< _T1> (__x), std::forward< _T2> (__y)); 
# 282
} 
# 293 "/usr/include/c++/5/bits/stl_pair.h" 3
}
# 70 "/usr/include/c++/5/bits/stl_iterator_base_types.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 89 "/usr/include/c++/5/bits/stl_iterator_base_types.h" 3
struct input_iterator_tag { }; 
# 92
struct output_iterator_tag { }; 
# 95
struct forward_iterator_tag : public input_iterator_tag { }; 
# 99
struct bidirectional_iterator_tag : public forward_iterator_tag { }; 
# 103
struct random_access_iterator_tag : public bidirectional_iterator_tag { }; 
# 116 "/usr/include/c++/5/bits/stl_iterator_base_types.h" 3
template< class _Category, class _Tp, class _Distance = ptrdiff_t, class 
# 117
_Pointer = _Tp *, class _Reference = _Tp &> 
# 118
struct iterator { 
# 121
typedef _Category iterator_category; 
# 123
typedef _Tp value_type; 
# 125
typedef _Distance difference_type; 
# 127
typedef _Pointer pointer; 
# 129
typedef _Reference reference; 
# 130
}; 
# 143 "/usr/include/c++/5/bits/stl_iterator_base_types.h" 3
template< class _Iterator, class  = __void_t< > > 
# 144
struct __iterator_traits { }; 
# 146
template< class _Iterator> 
# 147
struct __iterator_traits< _Iterator, __void_t< typename _Iterator::iterator_category, typename _Iterator::value_type, typename _Iterator::difference_type, typename _Iterator::pointer, typename _Iterator::reference> >  { 
# 154
typedef typename _Iterator::iterator_category iterator_category; 
# 155
typedef typename _Iterator::value_type value_type; 
# 156
typedef typename _Iterator::difference_type difference_type; 
# 157
typedef typename _Iterator::pointer pointer; 
# 158
typedef typename _Iterator::reference reference; 
# 159
}; 
# 161
template< class _Iterator> 
# 162
struct iterator_traits : public __iterator_traits< _Iterator>  { 
# 163
}; 
# 177 "/usr/include/c++/5/bits/stl_iterator_base_types.h" 3
template< class _Tp> 
# 178
struct iterator_traits< _Tp *>  { 
# 180
typedef random_access_iterator_tag iterator_category; 
# 181
typedef _Tp value_type; 
# 182
typedef ptrdiff_t difference_type; 
# 183
typedef _Tp *pointer; 
# 184
typedef _Tp &reference; 
# 185
}; 
# 188
template< class _Tp> 
# 189
struct iterator_traits< const _Tp *>  { 
# 191
typedef random_access_iterator_tag iterator_category; 
# 192
typedef _Tp value_type; 
# 193
typedef ptrdiff_t difference_type; 
# 194
typedef const _Tp *pointer; 
# 195
typedef const _Tp &reference; 
# 196
}; 
# 202
template< class _Iter> inline typename iterator_traits< _Iter> ::iterator_category 
# 204
__iterator_category(const _Iter &) 
# 205
{ return typename iterator_traits< _Iter> ::iterator_category(); } 
# 211
template< class _Iterator, bool _HasBase> 
# 212
struct _Iter_base { 
# 214
typedef _Iterator iterator_type; 
# 215
static iterator_type _S_base(_Iterator __it) 
# 216
{ return __it; } 
# 217
}; 
# 219
template< class _Iterator> 
# 220
struct _Iter_base< _Iterator, true>  { 
# 222
typedef typename _Iterator::iterator_type iterator_type; 
# 223
static iterator_type _S_base(_Iterator __it) 
# 224
{ return (__it.base()); } 
# 225
}; 
# 228
template< class _InIter> using _RequireInputIter = typename enable_if< is_convertible< typename iterator_traits< _InIter> ::iterator_category, input_iterator_tag> ::value> ::type; 
# 236
}
# 46 "/usr/include/c++/5/debug/debug.h" 3
namespace std { 
# 48
namespace __debug { }
# 49
}
# 54
namespace __gnu_debug { 
# 56
using namespace std::__debug;
# 57
}
# 67 "/usr/include/c++/5/bits/stl_iterator_base_funcs.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
template< class _InputIterator> inline typename iterator_traits< _InputIterator> ::difference_type 
# 73
__distance(_InputIterator __first, _InputIterator __last, input_iterator_tag) 
# 75
{ 
# 79
typename iterator_traits< _InputIterator> ::difference_type __n = (0); 
# 80
while (__first != __last) 
# 81
{ 
# 82
++__first; 
# 83
++__n; 
# 84
}  
# 85
return __n; 
# 86
} 
# 88
template< class _RandomAccessIterator> inline typename iterator_traits< _RandomAccessIterator> ::difference_type 
# 90
__distance(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag) 
# 92
{ 
# 96
return __last - __first; 
# 97
} 
# 112 "/usr/include/c++/5/bits/stl_iterator_base_funcs.h" 3
template< class _InputIterator> inline typename iterator_traits< _InputIterator> ::difference_type 
# 114
distance(_InputIterator __first, _InputIterator __last) 
# 115
{ 
# 117
return std::__distance(__first, __last, std::__iterator_category(__first)); 
# 119
} 
# 121
template< class _InputIterator, class _Distance> inline void 
# 123
__advance(_InputIterator &__i, _Distance __n, input_iterator_tag) 
# 124
{ 
# 127
; 
# 128
while (__n--) { 
# 129
++__i; }  
# 130
} 
# 132
template< class _BidirectionalIterator, class _Distance> inline void 
# 134
__advance(_BidirectionalIterator &__i, _Distance __n, bidirectional_iterator_tag) 
# 136
{ 
# 140
if (__n > 0) { 
# 141
while (__n--) { 
# 142
++__i; }  } else { 
# 144
while (__n++) { 
# 145
--__i; }  }  
# 146
} 
# 148
template< class _RandomAccessIterator, class _Distance> inline void 
# 150
__advance(_RandomAccessIterator &__i, _Distance __n, random_access_iterator_tag) 
# 152
{ 
# 156
__i += __n; 
# 157
} 
# 171 "/usr/include/c++/5/bits/stl_iterator_base_funcs.h" 3
template< class _InputIterator, class _Distance> inline void 
# 173
advance(_InputIterator &__i, _Distance __n) 
# 174
{ 
# 176
typename iterator_traits< _InputIterator> ::difference_type __d = __n; 
# 177
std::__advance(__i, __d, std::__iterator_category(__i)); 
# 178
} 
# 182
template< class _ForwardIterator> inline _ForwardIterator 
# 184
next(_ForwardIterator __x, typename iterator_traits< _ForwardIterator> ::difference_type 
# 185
__n = 1) 
# 186
{ 
# 187
std::advance(__x, __n); 
# 188
return __x; 
# 189
} 
# 191
template< class _BidirectionalIterator> inline _BidirectionalIterator 
# 193
prev(_BidirectionalIterator __x, typename iterator_traits< _BidirectionalIterator> ::difference_type 
# 194
__n = 1) 
# 195
{ 
# 196
std::advance(__x, -__n); 
# 197
return __x; 
# 198
} 
# 203
}
# 37 "/usr/include/c++/5/bits/ptr_traits.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
template< class _Tp, class  = __void_t< > > struct __has_element_type : public false_type { }; template< class _Tp> struct __has_element_type< _Tp, __void_t< typename _Tp::element_type> >  : public true_type { }; 
# 42
template< class _Tp, class  = __void_t< > > struct __has_difference_type : public false_type { }; template< class _Tp> struct __has_difference_type< _Tp, __void_t< typename _Tp::difference_type> >  : public true_type { }; 
# 44
template< class _Tp, bool  = __has_element_type< _Tp> ::value> struct __ptrtr_elt_type; 
# 47
template< class _Tp> 
# 48
struct __ptrtr_elt_type< _Tp, true>  { 
# 50
typedef typename _Tp::element_type __type; 
# 51
}; 
# 53
template< template< class , class ...>  class _SomePtr, class _Tp, class ...
# 54
_Args> 
# 55
struct __ptrtr_elt_type< _SomePtr< _Tp, _Args...> , false>  { 
# 57
typedef _Tp __type; 
# 58
}; 
# 60
template< class _Tp, bool  = __has_difference_type< _Tp> ::value> 
# 61
struct __ptrtr_diff_type { 
# 63
typedef typename _Tp::difference_type __type; 
# 64
}; 
# 66
template< class _Tp> 
# 67
struct __ptrtr_diff_type< _Tp, false>  { 
# 69
typedef ptrdiff_t __type; 
# 70
}; 
# 72
template< class _Ptr, class _Up> 
# 73
class __ptrtr_rebind_helper { 
# 75
template< class _Ptr2, class _Up2> static constexpr true_type _S_chk(typename _Ptr2::template rebind< _Up2>  *); 
# 79
template< class , class > static constexpr false_type _S_chk(...); 
# 84
public: using __type = __decltype((_S_chk< _Ptr, _Up> (nullptr))); 
# 85
}; 
# 87
template< class _Tp, class _Up, bool 
# 88
 = __ptrtr_rebind_helper< _Tp, _Up> ::__type::value> struct __ptrtr_rebind; 
# 91
template< class _Tp, class _Up> 
# 92
struct __ptrtr_rebind< _Tp, _Up, true>  { 
# 94
typedef typename _Tp::template rebind< _Up>  __type; 
# 95
}; 
# 97
template< template< class , class ...>  class _SomePtr, class _Up, class 
# 98
_Tp, class ..._Args> 
# 99
struct __ptrtr_rebind< _SomePtr< _Tp, _Args...> , _Up, false>  { 
# 101
typedef _SomePtr< _Up, _Args...>  __type; 
# 102
}; 
# 104
template< class _Tp, class  = typename remove_cv< _Tp> ::type> 
# 105
struct __ptrtr_not_void { 
# 107
typedef _Tp __type; 
# 108
}; 
# 110
template< class _Tp> 
# 111
struct __ptrtr_not_void< _Tp, void>  { 
# 113
struct __type { }; 
# 114
}; 
# 116
template< class _Ptr> 
# 117
class __ptrtr_pointer_to { 
# 119
typedef typename __ptrtr_elt_type< _Ptr> ::__type __orig_type; 
# 120
typedef typename __ptrtr_not_void< typename __ptrtr_elt_type< _Ptr> ::__type> ::__type __element_type; 
# 123
public: static _Ptr pointer_to(__element_type &__e) 
# 124
{ return _Ptr::pointer_to(__e); } 
# 125
}; 
# 131
template< class _Ptr> 
# 132
struct pointer_traits : public __ptrtr_pointer_to< _Ptr>  { 
# 135
typedef _Ptr pointer; 
# 137
typedef typename __ptrtr_elt_type< _Ptr> ::__type element_type; 
# 139
typedef typename __ptrtr_diff_type< _Ptr> ::__type difference_type; 
# 141
template< class _Up> using rebind = typename __ptrtr_rebind< _Ptr, _Up> ::__type; 
# 143
}; 
# 149
template< class _Tp> 
# 150
struct pointer_traits< _Tp *>  { 
# 153
typedef _Tp *pointer; 
# 155
typedef _Tp element_type; 
# 157
typedef ptrdiff_t difference_type; 
# 159
template< class _Up> using rebind = _Up *; 
# 168
static pointer pointer_to(typename __ptrtr_not_void< _Tp> ::__type &__r) noexcept 
# 169
{ return std::addressof(__r); } 
# 170
}; 
# 173
}
# 68 "/usr/include/c++/5/bits/stl_iterator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 96 "/usr/include/c++/5/bits/stl_iterator.h" 3
template< class _Iterator> 
# 97
class reverse_iterator : public iterator< typename iterator_traits< _Iterator> ::iterator_category, typename iterator_traits< _Iterator> ::value_type, typename iterator_traits< _Iterator> ::difference_type, typename iterator_traits< _Iterator> ::pointer, typename iterator_traits< _Iterator> ::reference>  { 
# 105
protected: _Iterator current; 
# 107
typedef iterator_traits< _Iterator>  __traits_type; 
# 110
public: typedef _Iterator iterator_type; 
# 111
typedef typename iterator_traits< _Iterator> ::difference_type difference_type; 
# 112
typedef typename iterator_traits< _Iterator> ::pointer pointer; 
# 113
typedef typename iterator_traits< _Iterator> ::reference reference; 
# 121
reverse_iterator() : current() { } 
# 127
explicit reverse_iterator(iterator_type __x) : current(__x) { } 
# 132
reverse_iterator(const reverse_iterator &__x) : current((__x.current)) 
# 133
{ } 
# 139
template< class _Iter> 
# 140
reverse_iterator(const ::std::reverse_iterator< _Iter>  &__x) : current((__x.base())) 
# 141
{ } 
# 147
iterator_type base() const 
# 148
{ return current; } 
# 161 "/usr/include/c++/5/bits/stl_iterator.h" 3
reference operator*() const 
# 162
{ 
# 163
_Iterator __tmp = current; 
# 164
return *(--__tmp); 
# 165
} 
# 173
pointer operator->() const 
# 174
{ return &operator*(); } 
# 182
reverse_iterator &operator++() 
# 183
{ 
# 184
--(current); 
# 185
return *this; 
# 186
} 
# 194
reverse_iterator operator++(int) 
# 195
{ 
# 196
reverse_iterator __tmp = *this; 
# 197
--(current); 
# 198
return __tmp; 
# 199
} 
# 207
reverse_iterator &operator--() 
# 208
{ 
# 209
++(current); 
# 210
return *this; 
# 211
} 
# 219
reverse_iterator operator--(int) 
# 220
{ 
# 221
reverse_iterator __tmp = *this; 
# 222
++(current); 
# 223
return __tmp; 
# 224
} 
# 232
reverse_iterator operator+(difference_type __n) const 
# 233
{ return ((reverse_iterator)((current) - __n)); } 
# 242
reverse_iterator &operator+=(difference_type __n) 
# 243
{ 
# 244
(current) -= __n; 
# 245
return *this; 
# 246
} 
# 254
reverse_iterator operator-(difference_type __n) const 
# 255
{ return ((reverse_iterator)((current) + __n)); } 
# 264
reverse_iterator &operator-=(difference_type __n) 
# 265
{ 
# 266
(current) += __n; 
# 267
return *this; 
# 268
} 
# 276
reference operator[](difference_type __n) const 
# 277
{ return *((*this) + __n); } 
# 278
}; 
# 290 "/usr/include/c++/5/bits/stl_iterator.h" 3
template< class _Iterator> inline bool 
# 292
operator==(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 293
__y) 
# 294
{ return (__x.base()) == (__y.base()); } 
# 296
template< class _Iterator> inline bool 
# 298
operator<(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 299
__y) 
# 300
{ return (__y.base()) < (__x.base()); } 
# 302
template< class _Iterator> inline bool 
# 304
operator!=(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 305
__y) 
# 306
{ return !(__x == __y); } 
# 308
template< class _Iterator> inline bool 
# 310
operator>(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 311
__y) 
# 312
{ return __y < __x; } 
# 314
template< class _Iterator> inline bool 
# 316
operator<=(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 317
__y) 
# 318
{ return !(__y < __x); } 
# 320
template< class _Iterator> inline bool 
# 322
operator>=(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 323
__y) 
# 324
{ return !(__x < __y); } 
# 326
template< class _Iterator> inline typename reverse_iterator< _Iterator> ::difference_type 
# 328
operator-(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 329
__y) 
# 330
{ return (__y.base()) - (__x.base()); } 
# 332
template< class _Iterator> inline reverse_iterator< _Iterator>  
# 334
operator+(typename reverse_iterator< _Iterator> ::difference_type __n, const reverse_iterator< _Iterator>  &
# 335
__x) 
# 336
{ return ((reverse_iterator< _Iterator> )((__x.base()) - __n)); } 
# 340
template< class _IteratorL, class _IteratorR> inline bool 
# 342
operator==(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 343
__y) 
# 344
{ return (__x.base()) == (__y.base()); } 
# 346
template< class _IteratorL, class _IteratorR> inline bool 
# 348
operator<(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 349
__y) 
# 350
{ return (__y.base()) < (__x.base()); } 
# 352
template< class _IteratorL, class _IteratorR> inline bool 
# 354
operator!=(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 355
__y) 
# 356
{ return !(__x == __y); } 
# 358
template< class _IteratorL, class _IteratorR> inline bool 
# 360
operator>(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 361
__y) 
# 362
{ return __y < __x; } 
# 364
template< class _IteratorL, class _IteratorR> inline bool 
# 366
operator<=(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 367
__y) 
# 368
{ return !(__y < __x); } 
# 370
template< class _IteratorL, class _IteratorR> inline bool 
# 372
operator>=(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 373
__y) 
# 374
{ return !(__x < __y); } 
# 376
template< class _IteratorL, class _IteratorR> inline auto 
# 380
operator-(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 381
__y)->__decltype(((__y.base()) - (__x.base()))) 
# 388
{ return (__y.base()) - (__x.base()); } 
# 414 "/usr/include/c++/5/bits/stl_iterator.h" 3
template< class _Container> 
# 415
class back_insert_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 419
protected: _Container *container; 
# 423
public: typedef _Container container_type; 
# 427
explicit back_insert_iterator(_Container &__x) : container((&__x)) { } 
# 449 "/usr/include/c++/5/bits/stl_iterator.h" 3
back_insert_iterator &operator=(const typename _Container::value_type &__value) 
# 450
{ 
# 451
((container)->push_back(__value)); 
# 452
return *this; 
# 453
} 
# 456
back_insert_iterator &operator=(typename _Container::value_type &&__value) 
# 457
{ 
# 458
((container)->push_back(std::move(__value))); 
# 459
return *this; 
# 460
} 
# 465
back_insert_iterator &operator*() 
# 466
{ return *this; } 
# 470
back_insert_iterator &operator++() 
# 471
{ return *this; } 
# 475
back_insert_iterator operator++(int) 
# 476
{ return *this; } 
# 477
}; 
# 490 "/usr/include/c++/5/bits/stl_iterator.h" 3
template< class _Container> inline back_insert_iterator< _Container>  
# 492
back_inserter(_Container &__x) 
# 493
{ return ((back_insert_iterator< _Container> )(__x)); } 
# 505 "/usr/include/c++/5/bits/stl_iterator.h" 3
template< class _Container> 
# 506
class front_insert_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 510
protected: _Container *container; 
# 514
public: typedef _Container container_type; 
# 517
explicit front_insert_iterator(_Container &__x) : container((&__x)) { } 
# 539 "/usr/include/c++/5/bits/stl_iterator.h" 3
front_insert_iterator &operator=(const typename _Container::value_type &__value) 
# 540
{ 
# 541
((container)->push_front(__value)); 
# 542
return *this; 
# 543
} 
# 546
front_insert_iterator &operator=(typename _Container::value_type &&__value) 
# 547
{ 
# 548
((container)->push_front(std::move(__value))); 
# 549
return *this; 
# 550
} 
# 555
front_insert_iterator &operator*() 
# 556
{ return *this; } 
# 560
front_insert_iterator &operator++() 
# 561
{ return *this; } 
# 565
front_insert_iterator operator++(int) 
# 566
{ return *this; } 
# 567
}; 
# 580 "/usr/include/c++/5/bits/stl_iterator.h" 3
template< class _Container> inline front_insert_iterator< _Container>  
# 582
front_inserter(_Container &__x) 
# 583
{ return ((front_insert_iterator< _Container> )(__x)); } 
# 599 "/usr/include/c++/5/bits/stl_iterator.h" 3
template< class _Container> 
# 600
class insert_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 604
protected: _Container *container; 
# 605
typename _Container::iterator iter; 
# 609
public: typedef _Container container_type; 
# 615
insert_iterator(_Container &__x, typename _Container::iterator __i) : container((&__x)), iter(__i) 
# 616
{ } 
# 651 "/usr/include/c++/5/bits/stl_iterator.h" 3
insert_iterator &operator=(const typename _Container::value_type &__value) 
# 652
{ 
# 653
(iter) = ((container)->insert(iter, __value)); 
# 654
++(iter); 
# 655
return *this; 
# 656
} 
# 659
insert_iterator &operator=(typename _Container::value_type &&__value) 
# 660
{ 
# 661
(iter) = ((container)->insert(iter, std::move(__value))); 
# 662
++(iter); 
# 663
return *this; 
# 664
} 
# 669
insert_iterator &operator*() 
# 670
{ return *this; } 
# 674
insert_iterator &operator++() 
# 675
{ return *this; } 
# 679
insert_iterator &operator++(int) 
# 680
{ return *this; } 
# 681
}; 
# 694 "/usr/include/c++/5/bits/stl_iterator.h" 3
template< class _Container, class _Iterator> inline insert_iterator< _Container>  
# 696
inserter(_Container &__x, _Iterator __i) 
# 697
{ 
# 698
return insert_iterator< _Container> (__x, (typename _Container::iterator)__i); 
# 700
} 
# 705
}
# 707
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 718 "/usr/include/c++/5/bits/stl_iterator.h" 3
using std::iterator_traits;
# 719
using std::iterator;
# 720
template< class _Iterator, class _Container> 
# 721
class __normal_iterator { 
# 724
protected: _Iterator _M_current; 
# 726
typedef std::iterator_traits< _Iterator>  __traits_type; 
# 729
public: typedef _Iterator iterator_type; 
# 730
typedef typename std::iterator_traits< _Iterator> ::iterator_category iterator_category; 
# 731
typedef typename std::iterator_traits< _Iterator> ::value_type value_type; 
# 732
typedef typename std::iterator_traits< _Iterator> ::difference_type difference_type; 
# 733
typedef typename std::iterator_traits< _Iterator> ::reference reference; 
# 734
typedef typename std::iterator_traits< _Iterator> ::pointer pointer; 
# 736
constexpr __normal_iterator() noexcept : _M_current(_Iterator()) 
# 737
{ } 
# 740
explicit __normal_iterator(const _Iterator &__i) noexcept : _M_current(__i) 
# 741
{ } 
# 744
template< class _Iter> 
# 745
__normal_iterator(const __gnu_cxx::__normal_iterator< _Iter, typename __enable_if< std::__are_same< _Iter, typename _Container::pointer> ::__value, _Container> ::__type>  &
# 748
__i) noexcept : _M_current((__i.base())) 
# 749
{ } 
# 753
reference operator*() const noexcept 
# 754
{ return *(_M_current); } 
# 757
pointer operator->() const noexcept 
# 758
{ return _M_current; } 
# 761
__normal_iterator &operator++() noexcept 
# 762
{ 
# 763
++(_M_current); 
# 764
return *this; 
# 765
} 
# 768
__normal_iterator operator++(int) noexcept 
# 769
{ return ((__normal_iterator)((_M_current)++)); } 
# 773
__normal_iterator &operator--() noexcept 
# 774
{ 
# 775
--(_M_current); 
# 776
return *this; 
# 777
} 
# 780
__normal_iterator operator--(int) noexcept 
# 781
{ return ((__normal_iterator)((_M_current)--)); } 
# 785
reference operator[](difference_type __n) const noexcept 
# 786
{ return (_M_current)[__n]; } 
# 789
__normal_iterator &operator+=(difference_type __n) noexcept 
# 790
{ (_M_current) += __n; return *this; } 
# 793
__normal_iterator operator+(difference_type __n) const noexcept 
# 794
{ return ((__normal_iterator)((_M_current) + __n)); } 
# 797
__normal_iterator &operator-=(difference_type __n) noexcept 
# 798
{ (_M_current) -= __n; return *this; } 
# 801
__normal_iterator operator-(difference_type __n) const noexcept 
# 802
{ return ((__normal_iterator)((_M_current) - __n)); } 
# 805
const _Iterator &base() const noexcept 
# 806
{ return _M_current; } 
# 807
}; 
# 818 "/usr/include/c++/5/bits/stl_iterator.h" 3
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 820
operator==(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 821
__rhs) noexcept 
# 823
{ return (__lhs.base()) == (__rhs.base()); } 
# 825
template< class _Iterator, class _Container> inline bool 
# 827
operator==(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 828
__rhs) noexcept 
# 830
{ return (__lhs.base()) == (__rhs.base()); } 
# 832
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 834
operator!=(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 835
__rhs) noexcept 
# 837
{ return (__lhs.base()) != (__rhs.base()); } 
# 839
template< class _Iterator, class _Container> inline bool 
# 841
operator!=(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 842
__rhs) noexcept 
# 844
{ return (__lhs.base()) != (__rhs.base()); } 
# 847
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 849
operator<(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 850
__rhs) noexcept 
# 852
{ return (__lhs.base()) < (__rhs.base()); } 
# 854
template< class _Iterator, class _Container> inline bool 
# 856
operator<(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 857
__rhs) noexcept 
# 859
{ return (__lhs.base()) < (__rhs.base()); } 
# 861
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 863
operator>(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 864
__rhs) noexcept 
# 866
{ return (__lhs.base()) > (__rhs.base()); } 
# 868
template< class _Iterator, class _Container> inline bool 
# 870
operator>(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 871
__rhs) noexcept 
# 873
{ return (__lhs.base()) > (__rhs.base()); } 
# 875
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 877
operator<=(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 878
__rhs) noexcept 
# 880
{ return (__lhs.base()) <= (__rhs.base()); } 
# 882
template< class _Iterator, class _Container> inline bool 
# 884
operator<=(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 885
__rhs) noexcept 
# 887
{ return (__lhs.base()) <= (__rhs.base()); } 
# 889
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 891
operator>=(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 892
__rhs) noexcept 
# 894
{ return (__lhs.base()) >= (__rhs.base()); } 
# 896
template< class _Iterator, class _Container> inline bool 
# 898
operator>=(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 899
__rhs) noexcept 
# 901
{ return (__lhs.base()) >= (__rhs.base()); } 
# 907
template< class _IteratorL, class _IteratorR, class _Container> inline auto 
# 911
operator-(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 912
__rhs) noexcept->__decltype(((__lhs.base()) - (__rhs.base()))) 
# 919
{ return (__lhs.base()) - (__rhs.base()); } 
# 921
template< class _Iterator, class _Container> inline typename __normal_iterator< _Iterator, _Container> ::difference_type 
# 923
operator-(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 924
__rhs) noexcept 
# 926
{ return (__lhs.base()) - (__rhs.base()); } 
# 928
template< class _Iterator, class _Container> inline __normal_iterator< _Iterator, _Container>  
# 930
operator+(typename __normal_iterator< _Iterator, _Container> ::difference_type 
# 931
__n, const __normal_iterator< _Iterator, _Container>  &__i) noexcept 
# 933
{ return ((__normal_iterator< _Iterator, _Container> )((__i.base()) + __n)); } 
# 936
}
# 940
namespace std __attribute((__visibility__("default"))) { 
# 958 "/usr/include/c++/5/bits/stl_iterator.h" 3
template< class _Iterator> 
# 959
class move_iterator { 
# 962
protected: _Iterator _M_current; 
# 964
typedef iterator_traits< _Iterator>  __traits_type; 
# 965
typedef typename iterator_traits< _Iterator> ::reference __base_ref; 
# 968
public: typedef _Iterator iterator_type; 
# 969
typedef typename iterator_traits< _Iterator> ::iterator_category iterator_category; 
# 970
typedef typename iterator_traits< _Iterator> ::value_type value_type; 
# 971
typedef typename iterator_traits< _Iterator> ::difference_type difference_type; 
# 973
typedef _Iterator pointer; 
# 978
typedef typename conditional< is_reference< typename iterator_traits< _Iterator> ::reference> ::value, typename remove_reference< typename iterator_traits< _Iterator> ::reference> ::type &&, typename iterator_traits< _Iterator> ::reference> ::type reference; 
# 980
move_iterator() : _M_current() 
# 981
{ } 
# 984
explicit move_iterator(iterator_type __i) : _M_current(__i) 
# 985
{ } 
# 987
template< class _Iter> 
# 988
move_iterator(const std::move_iterator< _Iter>  &__i) : _M_current((__i.base())) 
# 989
{ } 
# 992
iterator_type base() const 
# 993
{ return _M_current; } 
# 996
reference operator*() const 
# 997
{ return static_cast< reference>(*(_M_current)); } 
# 1000
pointer operator->() const 
# 1001
{ return _M_current; } 
# 1004
move_iterator &operator++() 
# 1005
{ 
# 1006
++(_M_current); 
# 1007
return *this; 
# 1008
} 
# 1011
move_iterator operator++(int) 
# 1012
{ 
# 1013
move_iterator __tmp = *this; 
# 1014
++(_M_current); 
# 1015
return __tmp; 
# 1016
} 
# 1019
move_iterator &operator--() 
# 1020
{ 
# 1021
--(_M_current); 
# 1022
return *this; 
# 1023
} 
# 1026
move_iterator operator--(int) 
# 1027
{ 
# 1028
move_iterator __tmp = *this; 
# 1029
--(_M_current); 
# 1030
return __tmp; 
# 1031
} 
# 1034
move_iterator operator+(difference_type __n) const 
# 1035
{ return ((move_iterator)((_M_current) + __n)); } 
# 1038
move_iterator &operator+=(difference_type __n) 
# 1039
{ 
# 1040
(_M_current) += __n; 
# 1041
return *this; 
# 1042
} 
# 1045
move_iterator operator-(difference_type __n) const 
# 1046
{ return ((move_iterator)((_M_current) - __n)); } 
# 1049
move_iterator &operator-=(difference_type __n) 
# 1050
{ 
# 1051
(_M_current) -= __n; 
# 1052
return *this; 
# 1053
} 
# 1056
reference operator[](difference_type __n) const 
# 1057
{ return std::move((_M_current)[__n]); } 
# 1058
}; 
# 1063
template< class _IteratorL, class _IteratorR> inline bool 
# 1065
operator==(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1066
__y) 
# 1067
{ return (__x.base()) == (__y.base()); } 
# 1069
template< class _Iterator> inline bool 
# 1071
operator==(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1072
__y) 
# 1073
{ return (__x.base()) == (__y.base()); } 
# 1075
template< class _IteratorL, class _IteratorR> inline bool 
# 1077
operator!=(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1078
__y) 
# 1079
{ return !(__x == __y); } 
# 1081
template< class _Iterator> inline bool 
# 1083
operator!=(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1084
__y) 
# 1085
{ return !(__x == __y); } 
# 1087
template< class _IteratorL, class _IteratorR> inline bool 
# 1089
operator<(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1090
__y) 
# 1091
{ return (__x.base()) < (__y.base()); } 
# 1093
template< class _Iterator> inline bool 
# 1095
operator<(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1096
__y) 
# 1097
{ return (__x.base()) < (__y.base()); } 
# 1099
template< class _IteratorL, class _IteratorR> inline bool 
# 1101
operator<=(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1102
__y) 
# 1103
{ return !(__y < __x); } 
# 1105
template< class _Iterator> inline bool 
# 1107
operator<=(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1108
__y) 
# 1109
{ return !(__y < __x); } 
# 1111
template< class _IteratorL, class _IteratorR> inline bool 
# 1113
operator>(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1114
__y) 
# 1115
{ return __y < __x; } 
# 1117
template< class _Iterator> inline bool 
# 1119
operator>(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1120
__y) 
# 1121
{ return __y < __x; } 
# 1123
template< class _IteratorL, class _IteratorR> inline bool 
# 1125
operator>=(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1126
__y) 
# 1127
{ return !(__x < __y); } 
# 1129
template< class _Iterator> inline bool 
# 1131
operator>=(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1132
__y) 
# 1133
{ return !(__x < __y); } 
# 1136
template< class _IteratorL, class _IteratorR> inline auto 
# 1138
operator-(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1139
__y)->__decltype(((__x.base()) - (__y.base()))) 
# 1141
{ return (__x.base()) - (__y.base()); } 
# 1143
template< class _Iterator> inline auto 
# 1145
operator-(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1146
__y)->__decltype(((__x.base()) - (__y.base()))) 
# 1148
{ return (__x.base()) - (__y.base()); } 
# 1150
template< class _Iterator> inline move_iterator< _Iterator>  
# 1152
operator+(typename move_iterator< _Iterator> ::difference_type __n, const move_iterator< _Iterator>  &
# 1153
__x) 
# 1154
{ return __x + __n; } 
# 1156
template< class _Iterator> inline move_iterator< _Iterator>  
# 1158
make_move_iterator(_Iterator __i) 
# 1159
{ return ((move_iterator< _Iterator> )(__i)); } 
# 1161
template< class _Iterator, class _ReturnType = typename conditional< __move_if_noexcept_cond< typename iterator_traits< _Iterator> ::value_type> ::value, _Iterator, move_iterator< _Iterator> > ::type> inline _ReturnType 
# 1166
__make_move_if_noexcept_iterator(_Iterator __i) 
# 1167
{ return (_ReturnType)__i; } 
# 1172
}
# 33 "/usr/include/c++/5/bits/predefined_ops.h" 3
namespace __gnu_cxx { 
# 35
namespace __ops { 
# 37
struct _Iter_less_iter { 
# 39
template< class _Iterator1, class _Iterator2> bool 
# 42
operator()(_Iterator1 __it1, _Iterator2 __it2) const 
# 43
{ return (*__it1) < (*__it2); } 
# 44
}; 
# 47
inline _Iter_less_iter __iter_less_iter() 
# 48
{ return _Iter_less_iter(); } 
# 50
struct _Iter_less_val { 
# 52
template< class _Iterator, class _Value> bool 
# 54
operator()(_Iterator __it, _Value &__val) const 
# 55
{ return (*__it) < __val; } 
# 56
}; 
# 59
inline _Iter_less_val __iter_less_val() 
# 60
{ return _Iter_less_val(); } 
# 63
inline _Iter_less_val __iter_comp_val(_Iter_less_iter) 
# 64
{ return _Iter_less_val(); } 
# 66
struct _Val_less_iter { 
# 68
template< class _Value, class _Iterator> bool 
# 70
operator()(_Value &__val, _Iterator __it) const 
# 71
{ return __val < (*__it); } 
# 72
}; 
# 75
inline _Val_less_iter __val_less_iter() 
# 76
{ return _Val_less_iter(); } 
# 79
inline _Val_less_iter __val_comp_iter(_Iter_less_iter) 
# 80
{ return _Val_less_iter(); } 
# 82
struct _Iter_equal_to_iter { 
# 84
template< class _Iterator1, class _Iterator2> bool 
# 86
operator()(_Iterator1 __it1, _Iterator2 __it2) const 
# 87
{ return (*__it1) == (*__it2); } 
# 88
}; 
# 91
inline _Iter_equal_to_iter __iter_equal_to_iter() 
# 92
{ return _Iter_equal_to_iter(); } 
# 94
struct _Iter_equal_to_val { 
# 96
template< class _Iterator, class _Value> bool 
# 98
operator()(_Iterator __it, _Value &__val) const 
# 99
{ return (*__it) == __val; } 
# 100
}; 
# 103
inline _Iter_equal_to_val __iter_equal_to_val() 
# 104
{ return _Iter_equal_to_val(); } 
# 107
inline _Iter_equal_to_val __iter_comp_val(_Iter_equal_to_iter) 
# 108
{ return _Iter_equal_to_val(); } 
# 110
template< class _Compare> 
# 111
struct _Iter_comp_iter { 
# 113
_Compare _M_comp; 
# 115
_Iter_comp_iter(_Compare __comp) : _M_comp(__comp) 
# 117
{ } 
# 119
template< class _Iterator1, class _Iterator2> bool 
# 122
operator()(_Iterator1 __it1, _Iterator2 __it2) 
# 123
{ return (bool)(_M_comp)(*__it1, *__it2); } 
# 124
}; 
# 126
template< class _Compare> inline _Iter_comp_iter< _Compare>  
# 129
__iter_comp_iter(_Compare __comp) 
# 130
{ return ((_Iter_comp_iter< _Compare> )(__comp)); } 
# 132
template< class _Compare> 
# 133
struct _Iter_comp_val { 
# 135
_Compare _M_comp; 
# 137
_Iter_comp_val(_Compare __comp) : _M_comp(__comp) 
# 139
{ } 
# 141
template< class _Iterator, class _Value> bool 
# 143
operator()(_Iterator __it, _Value &__val) 
# 144
{ return (bool)(_M_comp)(*__it, __val); } 
# 145
}; 
# 147
template< class _Compare> inline _Iter_comp_val< _Compare>  
# 149
__iter_comp_val(_Compare __comp) 
# 150
{ return ((_Iter_comp_val< _Compare> )(__comp)); } 
# 152
template< class _Compare> inline _Iter_comp_val< _Compare>  
# 154
__iter_comp_val(_Iter_comp_iter< _Compare>  __comp) 
# 155
{ return ((_Iter_comp_val< _Compare> )((__comp._M_comp))); } 
# 157
template< class _Compare> 
# 158
struct _Val_comp_iter { 
# 160
_Compare _M_comp; 
# 162
_Val_comp_iter(_Compare __comp) : _M_comp(__comp) 
# 164
{ } 
# 166
template< class _Value, class _Iterator> bool 
# 168
operator()(_Value &__val, _Iterator __it) 
# 169
{ return (bool)(_M_comp)(__val, *__it); } 
# 170
}; 
# 172
template< class _Compare> inline _Val_comp_iter< _Compare>  
# 174
__val_comp_iter(_Compare __comp) 
# 175
{ return ((_Val_comp_iter< _Compare> )(__comp)); } 
# 177
template< class _Compare> inline _Val_comp_iter< _Compare>  
# 179
__val_comp_iter(_Iter_comp_iter< _Compare>  __comp) 
# 180
{ return ((_Val_comp_iter< _Compare> )((__comp._M_comp))); } 
# 182
template< class _Value> 
# 183
struct _Iter_equals_val { 
# 185
_Value &_M_value; 
# 187
_Iter_equals_val(_Value &__value) : _M_value(__value) 
# 189
{ } 
# 191
template< class _Iterator> bool 
# 193
operator()(_Iterator __it) 
# 194
{ return (*__it) == (_M_value); } 
# 195
}; 
# 197
template< class _Value> inline _Iter_equals_val< _Value>  
# 199
__iter_equals_val(_Value &__val) 
# 200
{ return ((_Iter_equals_val< _Value> )(__val)); } 
# 202
template< class _Iterator1> 
# 203
struct _Iter_equals_iter { 
# 205
typename std::iterator_traits< _Iterator1> ::reference _M_ref; 
# 207
_Iter_equals_iter(_Iterator1 __it1) : _M_ref(*__it1) 
# 209
{ } 
# 211
template< class _Iterator2> bool 
# 213
operator()(_Iterator2 __it2) 
# 214
{ return (*__it2) == (_M_ref); } 
# 215
}; 
# 217
template< class _Iterator> inline _Iter_equals_iter< _Iterator>  
# 219
__iter_comp_iter(_Iter_equal_to_iter, _Iterator __it) 
# 220
{ return ((_Iter_equals_iter< _Iterator> )(__it)); } 
# 222
template< class _Predicate> 
# 223
struct _Iter_pred { 
# 225
_Predicate _M_pred; 
# 227
_Iter_pred(_Predicate __pred) : _M_pred(__pred) 
# 229
{ } 
# 231
template< class _Iterator> bool 
# 233
operator()(_Iterator __it) 
# 234
{ return (bool)(_M_pred)(*__it); } 
# 235
}; 
# 237
template< class _Predicate> inline _Iter_pred< _Predicate>  
# 239
__pred_iter(_Predicate __pred) 
# 240
{ return ((_Iter_pred< _Predicate> )(__pred)); } 
# 242
template< class _Compare, class _Value> 
# 243
struct _Iter_comp_to_val { 
# 245
_Compare _M_comp; 
# 246
_Value &_M_value; 
# 248
_Iter_comp_to_val(_Compare __comp, _Value &__value) : _M_comp(__comp), _M_value(__value) 
# 250
{ } 
# 252
template< class _Iterator> bool 
# 254
operator()(_Iterator __it) 
# 255
{ return (bool)(_M_comp)(*__it, _M_value); } 
# 256
}; 
# 258
template< class _Compare, class _Value> _Iter_comp_to_val< _Compare, _Value>  
# 260
__iter_comp_val(_Compare __comp, _Value &__val) 
# 261
{ return _Iter_comp_to_val< _Compare, _Value> (__comp, __val); } 
# 263
template< class _Compare, class _Iterator1> 
# 264
struct _Iter_comp_to_iter { 
# 266
_Compare _M_comp; 
# 267
typename std::iterator_traits< _Iterator1> ::reference _M_ref; 
# 269
_Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1) : _M_comp(__comp), _M_ref(*__it1) 
# 271
{ } 
# 273
template< class _Iterator2> bool 
# 275
operator()(_Iterator2 __it2) 
# 276
{ return (bool)(_M_comp)(*__it2, _M_ref); } 
# 277
}; 
# 279
template< class _Compare, class _Iterator> inline _Iter_comp_to_iter< _Compare, _Iterator>  
# 281
__iter_comp_iter(_Iter_comp_iter< _Compare>  __comp, _Iterator __it) 
# 282
{ return _Iter_comp_to_iter< _Compare, _Iterator> ((__comp._M_comp), __it); } 
# 284
template< class _Predicate> 
# 285
struct _Iter_negate { 
# 287
_Predicate _M_pred; 
# 289
_Iter_negate(_Predicate __pred) : _M_pred(__pred) 
# 291
{ } 
# 293
template< class _Iterator> bool 
# 295
operator()(_Iterator __it) 
# 296
{ return !((bool)(_M_pred)(*__it)); } 
# 297
}; 
# 299
template< class _Predicate> inline _Iter_negate< _Predicate>  
# 301
__negate(_Iter_pred< _Predicate>  __pred) 
# 302
{ return ((_Iter_negate< _Predicate> )((__pred._M_pred))); } 
# 304
}
# 305
}
# 73 "/usr/include/c++/5/bits/stl_algobase.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 118 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> inline void 
# 120
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) 
# 121
{ 
# 148 "/usr/include/c++/5/bits/stl_algobase.h" 3
swap(*__a, *__b); 
# 150
} 
# 164 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> _ForwardIterator2 
# 166
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 167
__first2) 
# 168
{ 
# 174
; 
# 176
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 177
std::iter_swap(__first1, __first2); }  
# 178
return __first2; 
# 179
} 
# 192 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _Tp> inline const _Tp &
# 195
min(const _Tp &__a, const _Tp &__b) 
# 196
{ 
# 200
if (__b < __a) { 
# 201
return __b; }  
# 202
return __a; 
# 203
} 
# 216 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _Tp> inline const _Tp &
# 219
max(const _Tp &__a, const _Tp &__b) 
# 220
{ 
# 224
if (__a < __b) { 
# 225
return __b; }  
# 226
return __a; 
# 227
} 
# 240 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _Tp, class _Compare> inline const _Tp &
# 243
min(const _Tp &__a, const _Tp &__b, _Compare __comp) 
# 244
{ 
# 246
if (__comp(__b, __a)) { 
# 247
return __b; }  
# 248
return __a; 
# 249
} 
# 262 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _Tp, class _Compare> inline const _Tp &
# 265
max(const _Tp &__a, const _Tp &__b, _Compare __comp) 
# 266
{ 
# 268
if (__comp(__a, __b)) { 
# 269
return __b; }  
# 270
return __a; 
# 271
} 
# 275
template< class _Iterator> 
# 276
struct _Niter_base : public _Iter_base< _Iterator, __is_normal_iterator< _Iterator> ::__value>  { 
# 278
}; 
# 280
template< class _Iterator> inline typename _Niter_base< _Iterator> ::iterator_type 
# 282
__niter_base(_Iterator __it) 
# 283
{ return std::_Niter_base< _Iterator> ::_S_base(__it); } 
# 286
template< class _Iterator> 
# 287
struct _Miter_base : public _Iter_base< _Iterator, __is_move_iterator< _Iterator> ::__value>  { 
# 289
}; 
# 291
template< class _Iterator> inline typename _Miter_base< _Iterator> ::iterator_type 
# 293
__miter_base(_Iterator __it) 
# 294
{ return std::_Miter_base< _Iterator> ::_S_base(__it); } 
# 302
template< bool , bool , class > 
# 303
struct __copy_move { 
# 305
template< class _II, class _OI> static _OI 
# 307
__copy_m(_II __first, _II __last, _OI __result) 
# 308
{ 
# 309
for (; __first != __last; (++__result), (++__first)) { 
# 310
(*__result) = (*__first); }  
# 311
return __result; 
# 312
} 
# 313
}; 
# 316
template< class _Category> 
# 317
struct __copy_move< true, false, _Category>  { 
# 319
template< class _II, class _OI> static _OI 
# 321
__copy_m(_II __first, _II __last, _OI __result) 
# 322
{ 
# 323
for (; __first != __last; (++__result), (++__first)) { 
# 324
(*__result) = std::move(*__first); }  
# 325
return __result; 
# 326
} 
# 327
}; 
# 331
template<> struct __copy_move< false, false, random_access_iterator_tag>  { 
# 333
template< class _II, class _OI> static _OI 
# 335
__copy_m(_II __first, _II __last, _OI __result) 
# 336
{ 
# 337
typedef typename iterator_traits< _II> ::difference_type _Distance; 
# 338
for (_Distance __n = __last - __first; __n > 0; --__n) 
# 339
{ 
# 340
(*__result) = (*__first); 
# 341
++__first; 
# 342
++__result; 
# 343
}  
# 344
return __result; 
# 345
} 
# 346
}; 
# 350
template<> struct __copy_move< true, false, random_access_iterator_tag>  { 
# 352
template< class _II, class _OI> static _OI 
# 354
__copy_m(_II __first, _II __last, _OI __result) 
# 355
{ 
# 356
typedef typename iterator_traits< _II> ::difference_type _Distance; 
# 357
for (_Distance __n = __last - __first; __n > 0; --__n) 
# 358
{ 
# 359
(*__result) = std::move(*__first); 
# 360
++__first; 
# 361
++__result; 
# 362
}  
# 363
return __result; 
# 364
} 
# 365
}; 
# 368
template< bool _IsMove> 
# 369
struct __copy_move< _IsMove, true, random_access_iterator_tag>  { 
# 371
template< class _Tp> static _Tp *
# 373
__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result) 
# 374
{ 
# 376
using __assignable = conditional< _IsMove, is_move_assignable< _Tp> , is_copy_assignable< _Tp> > ; 
# 380
static_assert((__assignable::type::value), "type is not assignable");
# 382
const ptrdiff_t _Num = __last - __first; 
# 383
if (_Num) { 
# 384
__builtin_memmove(__result, __first, sizeof(_Tp) * _Num); }  
# 385
return __result + _Num; 
# 386
} 
# 387
}; 
# 389
template< bool _IsMove, class _II, class _OI> inline _OI 
# 391
__copy_move_a(_II __first, _II __last, _OI __result) 
# 392
{ 
# 393
typedef typename iterator_traits< _II> ::value_type _ValueTypeI; 
# 394
typedef typename iterator_traits< _OI> ::value_type _ValueTypeO; 
# 395
typedef typename iterator_traits< _II> ::iterator_category _Category; 
# 396
const bool __simple = (__is_trivial(_ValueTypeI) && __is_pointer< _II> ::__value && __is_pointer< _OI> ::__value && __are_same< typename iterator_traits< _II> ::value_type, typename iterator_traits< _OI> ::value_type> ::__value); 
# 401
return std::__copy_move< _IsMove, __simple, typename iterator_traits< _II> ::iterator_category> ::__copy_m(__first, __last, __result); 
# 403
} 
# 407
template< class _CharT> struct char_traits; 
# 410
template< class _CharT, class _Traits> class istreambuf_iterator; 
# 413
template< class _CharT, class _Traits> class ostreambuf_iterator; 
# 416
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator< _CharT, char_traits< _CharT> > ); 
# 422
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator< _CharT, char_traits< _CharT> > ); 
# 428
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, _CharT *> ::__type __copy_move_a2(istreambuf_iterator< _CharT, char_traits< _CharT> > , istreambuf_iterator< _CharT, char_traits< _CharT> > , _CharT *); 
# 434
template< bool _IsMove, class _II, class _OI> inline _OI 
# 436
__copy_move_a2(_II __first, _II __last, _OI __result) 
# 437
{ 
# 438
return (_OI)std::__copy_move_a< _IsMove> (std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)); 
# 441
} 
# 460 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _II, class _OI> inline _OI 
# 462
copy(_II __first, _II __last, _OI __result) 
# 463
{ 
# 468
; 
# 470
return std::__copy_move_a2< __is_move_iterator< _II> ::__value> (std::__miter_base(__first), std::__miter_base(__last), __result); 
# 473
} 
# 493 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _II, class _OI> inline _OI 
# 495
move(_II __first, _II __last, _OI __result) 
# 496
{ 
# 501
; 
# 503
return std::__copy_move_a2< true> (std::__miter_base(__first), std::__miter_base(__last), __result); 
# 505
} 
# 512
template< bool , bool , class > 
# 513
struct __copy_move_backward { 
# 515
template< class _BI1, class _BI2> static _BI2 
# 517
__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) 
# 518
{ 
# 519
while (__first != __last) { 
# 520
(*(--__result)) = (*(--__last)); }  
# 521
return __result; 
# 522
} 
# 523
}; 
# 526
template< class _Category> 
# 527
struct __copy_move_backward< true, false, _Category>  { 
# 529
template< class _BI1, class _BI2> static _BI2 
# 531
__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) 
# 532
{ 
# 533
while (__first != __last) { 
# 534
(*(--__result)) = std::move(*(--__last)); }  
# 535
return __result; 
# 536
} 
# 537
}; 
# 541
template<> struct __copy_move_backward< false, false, random_access_iterator_tag>  { 
# 543
template< class _BI1, class _BI2> static _BI2 
# 545
__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) 
# 546
{ 
# 547
typename iterator_traits< _BI1> ::difference_type __n; 
# 548
for (__n = (__last - __first); __n > 0; --__n) { 
# 549
(*(--__result)) = (*(--__last)); }  
# 550
return __result; 
# 551
} 
# 552
}; 
# 556
template<> struct __copy_move_backward< true, false, random_access_iterator_tag>  { 
# 558
template< class _BI1, class _BI2> static _BI2 
# 560
__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) 
# 561
{ 
# 562
typename iterator_traits< _BI1> ::difference_type __n; 
# 563
for (__n = (__last - __first); __n > 0; --__n) { 
# 564
(*(--__result)) = std::move(*(--__last)); }  
# 565
return __result; 
# 566
} 
# 567
}; 
# 570
template< bool _IsMove> 
# 571
struct __copy_move_backward< _IsMove, true, random_access_iterator_tag>  { 
# 573
template< class _Tp> static _Tp *
# 575
__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result) 
# 576
{ 
# 578
using __assignable = conditional< _IsMove, is_move_assignable< _Tp> , is_copy_assignable< _Tp> > ; 
# 582
static_assert((__assignable::type::value), "type is not assignable");
# 584
const ptrdiff_t _Num = __last - __first; 
# 585
if (_Num) { 
# 586
__builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num); }  
# 587
return __result - _Num; 
# 588
} 
# 589
}; 
# 591
template< bool _IsMove, class _BI1, class _BI2> inline _BI2 
# 593
__copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result) 
# 594
{ 
# 595
typedef typename iterator_traits< _BI1> ::value_type _ValueType1; 
# 596
typedef typename iterator_traits< _BI2> ::value_type _ValueType2; 
# 597
typedef typename iterator_traits< _BI1> ::iterator_category _Category; 
# 598
const bool __simple = (__is_trivial(_ValueType1) && __is_pointer< _BI1> ::__value && __is_pointer< _BI2> ::__value && __are_same< typename iterator_traits< _BI1> ::value_type, typename iterator_traits< _BI2> ::value_type> ::__value); 
# 603
return std::__copy_move_backward< _IsMove, __simple, typename iterator_traits< _BI1> ::iterator_category> ::__copy_move_b(__first, __last, __result); 
# 607
} 
# 609
template< bool _IsMove, class _BI1, class _BI2> inline _BI2 
# 611
__copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result) 
# 612
{ 
# 613
return (_BI2)std::__copy_move_backward_a< _IsMove> (std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)); 
# 616
} 
# 636 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _BI1, class _BI2> inline _BI2 
# 638
copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) 
# 639
{ 
# 646
; 
# 648
return std::__copy_move_backward_a2< __is_move_iterator< _BI1> ::__value> (std::__miter_base(__first), std::__miter_base(__last), __result); 
# 651
} 
# 672 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _BI1, class _BI2> inline _BI2 
# 674
move_backward(_BI1 __first, _BI1 __last, _BI2 __result) 
# 675
{ 
# 682
; 
# 684
return std::__copy_move_backward_a2< true> (std::__miter_base(__first), std::__miter_base(__last), __result); 
# 687
} 
# 694
template< class _ForwardIterator, class _Tp> inline typename __gnu_cxx::__enable_if< !__is_scalar< _Tp> ::__value, void> ::__type 
# 697
__fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 698
__value) 
# 699
{ 
# 700
for (; __first != __last; ++__first) { 
# 701
(*__first) = __value; }  
# 702
} 
# 704
template< class _ForwardIterator, class _Tp> inline typename __gnu_cxx::__enable_if< __is_scalar< _Tp> ::__value, void> ::__type 
# 707
__fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 708
__value) 
# 709
{ 
# 710
const _Tp __tmp = __value; 
# 711
for (; __first != __last; ++__first) { 
# 712
(*__first) = __tmp; }  
# 713
} 
# 716
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_byte< _Tp> ::__value, void> ::__type 
# 719
__fill_a(_Tp *__first, _Tp *__last, const _Tp &__c) 
# 720
{ 
# 721
const _Tp __tmp = __c; 
# 722
if (const size_t __len = __last - __first) { 
# 723
__builtin_memset(__first, static_cast< unsigned char>(__tmp), __len); }  
# 724
} 
# 738 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _ForwardIterator, class _Tp> inline void 
# 740
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value) 
# 741
{ 
# 745
; 
# 747
std::__fill_a(std::__niter_base(__first), std::__niter_base(__last), __value); 
# 749
} 
# 751
template< class _OutputIterator, class _Size, class _Tp> inline typename __gnu_cxx::__enable_if< !__is_scalar< _Tp> ::__value, _OutputIterator> ::__type 
# 754
__fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value) 
# 755
{ 
# 756
for (__decltype((__n + 0)) __niter = __n; __niter > 0; (--__niter), (++__first)) { 
# 758
(*__first) = __value; }  
# 759
return __first; 
# 760
} 
# 762
template< class _OutputIterator, class _Size, class _Tp> inline typename __gnu_cxx::__enable_if< __is_scalar< _Tp> ::__value, _OutputIterator> ::__type 
# 765
__fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value) 
# 766
{ 
# 767
const _Tp __tmp = __value; 
# 768
for (__decltype((__n + 0)) __niter = __n; __niter > 0; (--__niter), (++__first)) { 
# 770
(*__first) = __tmp; }  
# 771
return __first; 
# 772
} 
# 774
template< class _Size, class _Tp> inline typename __gnu_cxx::__enable_if< __is_byte< _Tp> ::__value, _Tp *> ::__type 
# 777
__fill_n_a(_Tp *__first, _Size __n, const _Tp &__c) 
# 778
{ 
# 779
std::__fill_a(__first, __first + __n, __c); 
# 780
return __first + __n; 
# 781
} 
# 798 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _OI, class _Size, class _Tp> inline _OI 
# 800
fill_n(_OI __first, _Size __n, const _Tp &__value) 
# 801
{ 
# 805
return (_OI)std::__fill_n_a(std::__niter_base(__first), __n, __value); 
# 806
} 
# 808
template< bool _BoolType> 
# 809
struct __equal { 
# 811
template< class _II1, class _II2> static bool 
# 813
equal(_II1 __first1, _II1 __last1, _II2 __first2) 
# 814
{ 
# 815
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 816
if (!((*__first1) == (*__first2))) { 
# 817
return false; }  }  
# 818
return true; 
# 819
} 
# 820
}; 
# 823
template<> struct __equal< true>  { 
# 825
template< class _Tp> static bool 
# 827
equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2) 
# 828
{ 
# 829
if (const size_t __len = __last1 - __first1) { 
# 830
return !(__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len)); }  
# 831
return true; 
# 832
} 
# 833
}; 
# 835
template< class _II1, class _II2> inline bool 
# 837
__equal_aux(_II1 __first1, _II1 __last1, _II2 __first2) 
# 838
{ 
# 839
typedef typename iterator_traits< _II1> ::value_type _ValueType1; 
# 840
typedef typename iterator_traits< _II2> ::value_type _ValueType2; 
# 841
const bool __simple = ((__is_integer< typename iterator_traits< _II1> ::value_type> ::__value || __is_pointer< typename iterator_traits< _II1> ::value_type> ::__value) && __is_pointer< _II1> ::__value && __is_pointer< _II2> ::__value && __are_same< typename iterator_traits< _II1> ::value_type, typename iterator_traits< _II2> ::value_type> ::__value); 
# 847
return std::__equal< __simple> ::equal(__first1, __last1, __first2); 
# 848
} 
# 850
template< class , class > 
# 851
struct __lc_rai { 
# 853
template< class _II1, class _II2> static _II1 
# 855
__newlast1(_II1, _II1 __last1, _II2, _II2) 
# 856
{ return __last1; } 
# 858
template< class _II> static bool 
# 860
__cnd2(_II __first, _II __last) 
# 861
{ return __first != __last; } 
# 862
}; 
# 865
template<> struct __lc_rai< random_access_iterator_tag, random_access_iterator_tag>  { 
# 867
template< class _RAI1, class _RAI2> static _RAI1 
# 869
__newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 
# 870
__first2, _RAI2 __last2) 
# 871
{ 
# 873
const typename iterator_traits< _RAI1> ::difference_type __diff1 = __last1 - __first1; 
# 875
const typename iterator_traits< _RAI2> ::difference_type __diff2 = __last2 - __first2; 
# 876
return (__diff2 < __diff1) ? __first1 + __diff2 : __last1; 
# 877
} 
# 879
template< class _RAI> static bool 
# 881
__cnd2(_RAI, _RAI) 
# 882
{ return true; } 
# 883
}; 
# 885
template< class _II1, class _II2, class _Compare> bool 
# 887
__lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 
# 888
__first2, _II2 __last2, _Compare 
# 889
__comp) 
# 890
{ 
# 891
typedef typename iterator_traits< _II1> ::iterator_category _Category1; 
# 892
typedef typename iterator_traits< _II2> ::iterator_category _Category2; 
# 893
typedef __lc_rai< typename iterator_traits< _II1> ::iterator_category, typename iterator_traits< _II2> ::iterator_category>  __rai_type; 
# 895
__last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2); 
# 896
for (; (__first1 != __last1) && __rai_type::__cnd2(__first2, __last2); (++__first1), (++__first2)) 
# 898
{ 
# 899
if (__comp(__first1, __first2)) { 
# 900
return true; }  
# 901
if (__comp(__first2, __first1)) { 
# 902
return false; }  
# 903
}  
# 904
return (__first1 == __last1) && (__first2 != __last2); 
# 905
} 
# 907
template< bool _BoolType> 
# 908
struct __lexicographical_compare { 
# 910
template< class _II1, class _II2> static bool __lc(_II1, _II1, _II2, _II2); 
# 912
}; 
# 914
template< bool _BoolType> 
# 915
template< class _II1, class _II2> bool 
# 918
__lexicographical_compare< _BoolType> ::__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) 
# 919
{ 
# 920
return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_less_iter()); 
# 923
} 
# 926
template<> struct __lexicographical_compare< true>  { 
# 928
template< class _Tp, class _Up> static bool 
# 930
__lc(const _Tp *__first1, const _Tp *__last1, const _Up *
# 931
__first2, const _Up *__last2) 
# 932
{ 
# 933
const size_t __len1 = __last1 - __first1; 
# 934
const size_t __len2 = __last2 - __first2; 
# 935
if (const size_t __len = std::min(__len1, __len2)) { 
# 936
if (int __result = __builtin_memcmp(__first1, __first2, __len)) { 
# 937
return __result < 0; }  }  
# 938
return __len1 < __len2; 
# 939
} 
# 940
}; 
# 942
template< class _II1, class _II2> inline bool 
# 944
__lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 
# 945
__first2, _II2 __last2) 
# 946
{ 
# 947
typedef typename iterator_traits< _II1> ::value_type _ValueType1; 
# 948
typedef typename iterator_traits< _II2> ::value_type _ValueType2; 
# 949
const bool __simple = (__is_byte< typename iterator_traits< _II1> ::value_type> ::__value && __is_byte< typename iterator_traits< _II2> ::value_type> ::__value && (!__gnu_cxx::__numeric_traits< typename iterator_traits< _II1> ::value_type> ::__is_signed) && (!__gnu_cxx::__numeric_traits< typename iterator_traits< _II2> ::value_type> ::__is_signed) && __is_pointer< _II1> ::__value && __is_pointer< _II2> ::__value); 
# 956
return std::__lexicographical_compare< __simple> ::__lc(__first1, __last1, __first2, __last2); 
# 958
} 
# 960
template< class _ForwardIterator, class _Tp, class _Compare> _ForwardIterator 
# 962
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 963
__val, _Compare __comp) 
# 964
{ 
# 966
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 968
_DistanceType __len = std::distance(__first, __last); 
# 970
while (__len > 0) 
# 971
{ 
# 972
_DistanceType __half = __len >> 1; 
# 973
_ForwardIterator __middle = __first; 
# 974
std::advance(__middle, __half); 
# 975
if (__comp(__middle, __val)) 
# 976
{ 
# 977
__first = __middle; 
# 978
++__first; 
# 979
__len = ((__len - __half) - 1); 
# 980
} else { 
# 982
__len = __half; }  
# 983
}  
# 984
return __first; 
# 985
} 
# 998 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _ForwardIterator, class _Tp> inline _ForwardIterator 
# 1000
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 1001
__val) 
# 1002
{ 
# 1007
; 
# 1009
return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val()); 
# 1011
} 
# 1016
constexpr int __lg(int __n) 
# 1017
{ return ((sizeof(int) * (8)) - (1)) - (__builtin_clz(__n)); } 
# 1020
constexpr unsigned __lg(unsigned __n) 
# 1021
{ return ((sizeof(int) * (8)) - (1)) - (__builtin_clz(__n)); } 
# 1024
constexpr long __lg(long __n) 
# 1025
{ return ((sizeof(long) * (8)) - (1)) - (__builtin_clzl(__n)); } 
# 1028
constexpr unsigned long __lg(unsigned long __n) 
# 1029
{ return ((sizeof(long) * (8)) - (1)) - (__builtin_clzl(__n)); } 
# 1032
constexpr long long __lg(long long __n) 
# 1033
{ return ((sizeof(long long) * (8)) - (1)) - (__builtin_clzll(__n)); } 
# 1036
constexpr unsigned long long __lg(unsigned long long __n) 
# 1037
{ return ((sizeof(long long) * (8)) - (1)) - (__builtin_clzll(__n)); } 
# 1055 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _II1, class _II2> inline bool 
# 1057
equal(_II1 __first1, _II1 __last1, _II2 __first2) 
# 1058
{ 
# 1065
; 
# 1067
return std::__equal_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2)); 
# 1070
} 
# 1087 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _IIter1, class _IIter2, class _BinaryPredicate> inline bool 
# 1089
equal(_IIter1 __first1, _IIter1 __last1, _IIter2 
# 1090
__first2, _BinaryPredicate __binary_pred) 
# 1091
{ 
# 1095
; 
# 1097
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 1098
if (!((bool)__binary_pred(*__first1, *__first2))) { 
# 1099
return false; }  }  
# 1100
return true; 
# 1101
} 
# 1215 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _II1, class _II2> inline bool 
# 1217
lexicographical_compare(_II1 __first1, _II1 __last1, _II2 
# 1218
__first2, _II2 __last2) 
# 1219
{ 
# 1229
; 
# 1230
; 
# 1232
return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2)); 
# 1236
} 
# 1251 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _II1, class _II2, class _Compare> inline bool 
# 1253
lexicographical_compare(_II1 __first1, _II1 __last1, _II2 
# 1254
__first2, _II2 __last2, _Compare __comp) 
# 1255
{ 
# 1259
; 
# 1260
; 
# 1262
return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 1265
} 
# 1267
template< class _InputIterator1, class _InputIterator2, class 
# 1268
_BinaryPredicate> pair< _InputIterator1, _InputIterator2>  
# 1270
__mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1271
__first2, _BinaryPredicate __binary_pred) 
# 1272
{ 
# 1273
while ((__first1 != __last1) && __binary_pred(__first1, __first2)) 
# 1274
{ 
# 1275
++__first1; 
# 1276
++__first2; 
# 1277
}  
# 1278
return pair< _InputIterator1, _InputIterator2> (__first1, __first2); 
# 1279
} 
# 1294 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _InputIterator1, class _InputIterator2> inline pair< _InputIterator1, _InputIterator2>  
# 1296
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1297
__first2) 
# 1298
{ 
# 1305
; 
# 1307
return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 1309
} 
# 1327 "/usr/include/c++/5/bits/stl_algobase.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 1328
_BinaryPredicate> inline pair< _InputIterator1, _InputIterator2>  
# 1330
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1331
__first2, _BinaryPredicate __binary_pred) 
# 1332
{ 
# 1336
; 
# 1338
return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred)); 
# 1340
} 
# 1428 "/usr/include/c++/5/bits/stl_algobase.h" 3
}
# 43 "/usr/include/c++/5/bits/char_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 57 "/usr/include/c++/5/bits/char_traits.h" 3
template< class _CharT> 
# 58
struct _Char_types { 
# 60
typedef unsigned long int_type; 
# 61
typedef std::streampos pos_type; 
# 62
typedef std::streamoff off_type; 
# 63
typedef mbstate_t state_type; 
# 64
}; 
# 82 "/usr/include/c++/5/bits/char_traits.h" 3
template< class _CharT> 
# 83
struct char_traits { 
# 85
typedef _CharT char_type; 
# 86
typedef typename _Char_types< _CharT> ::int_type int_type; 
# 87
typedef typename _Char_types< _CharT> ::pos_type pos_type; 
# 88
typedef typename _Char_types< _CharT> ::off_type off_type; 
# 89
typedef typename _Char_types< _CharT> ::state_type state_type; 
# 92
static void assign(char_type &__c1, const char_type &__c2) 
# 93
{ __c1 = __c2; } 
# 96
static constexpr bool eq(const char_type &__c1, const char_type &__c2) 
# 97
{ return __c1 == __c2; } 
# 100
static constexpr bool lt(const char_type &__c1, const char_type &__c2) 
# 101
{ return __c1 < __c2; } 
# 104
static int compare(const char_type * __s1, const char_type * __s2, std::size_t __n); 
# 107
static std::size_t length(const char_type * __s); 
# 110
static const char_type *find(const char_type * __s, std::size_t __n, const char_type & __a); 
# 113
static char_type *move(char_type * __s1, const char_type * __s2, std::size_t __n); 
# 116
static char_type *copy(char_type * __s1, const char_type * __s2, std::size_t __n); 
# 119
static char_type *assign(char_type * __s, std::size_t __n, char_type __a); 
# 122
static constexpr char_type to_char_type(const int_type &__c) 
# 123
{ return static_cast< char_type>(__c); } 
# 126
static constexpr int_type to_int_type(const char_type &__c) 
# 127
{ return static_cast< int_type>(__c); } 
# 130
static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) 
# 131
{ return __c1 == __c2; } 
# 134
static constexpr int_type eof() 
# 135
{ return static_cast< int_type>(-1); } 
# 138
static constexpr int_type not_eof(const int_type &__c) 
# 139
{ return (!(eq_int_type)(__c, (eof)())) ? __c : (to_int_type)(char_type()); } 
# 140
}; 
# 142
template< class _CharT> int 
# 145
char_traits< _CharT> ::compare(const char_type *__s1, const char_type *__s2, std::size_t __n) 
# 146
{ 
# 147
for (std::size_t __i = (0); __i < __n; ++__i) { 
# 148
if ((lt)(__s1[__i], __s2[__i])) { 
# 149
return -1; } else { 
# 150
if ((lt)(__s2[__i], __s1[__i])) { 
# 151
return 1; }  }  }  
# 152
return 0; 
# 153
} 
# 155
template< class _CharT> std::size_t 
# 158
char_traits< _CharT> ::length(const char_type *__p) 
# 159
{ 
# 160
std::size_t __i = (0); 
# 161
while (!(eq)(__p[__i], char_type())) { 
# 162
++__i; }  
# 163
return __i; 
# 164
} 
# 166
template< class _CharT> const typename char_traits< _CharT> ::char_type *
# 169
char_traits< _CharT> ::find(const char_type *__s, std::size_t __n, const char_type &__a) 
# 170
{ 
# 171
for (std::size_t __i = (0); __i < __n; ++__i) { 
# 172
if ((eq)(__s[__i], __a)) { 
# 173
return __s + __i; }  }  
# 174
return 0; 
# 175
} 
# 177
template< class _CharT> typename char_traits< _CharT> ::char_type *
# 180
char_traits< _CharT> ::move(char_type *__s1, const char_type *__s2, std::size_t __n) 
# 181
{ 
# 182
return static_cast< _CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))); 
# 184
} 
# 186
template< class _CharT> typename char_traits< _CharT> ::char_type *
# 189
char_traits< _CharT> ::copy(char_type *__s1, const char_type *__s2, std::size_t __n) 
# 190
{ 
# 192
std::copy(__s2, __s2 + __n, __s1); 
# 193
return __s1; 
# 194
} 
# 196
template< class _CharT> typename char_traits< _CharT> ::char_type *
# 199
char_traits< _CharT> ::assign(char_type *__s, std::size_t __n, char_type __a) 
# 200
{ 
# 202
std::fill_n(__s, __n, __a); 
# 203
return __s; 
# 204
} 
# 207
}
# 209
namespace std __attribute((__visibility__("default"))) { 
# 226 "/usr/include/c++/5/bits/char_traits.h" 3
template< class _CharT> 
# 227
struct char_traits : public __gnu_cxx::char_traits< _CharT>  { 
# 228
}; 
# 233
template<> struct char_traits< char>  { 
# 235
typedef char char_type; 
# 236
typedef int int_type; 
# 237
typedef streampos pos_type; 
# 238
typedef streamoff off_type; 
# 239
typedef mbstate_t state_type; 
# 242
static void assign(char_type &__c1, const char_type &__c2) noexcept 
# 243
{ __c1 = __c2; } 
# 246
static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
# 247
{ return __c1 == __c2; } 
# 250
static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
# 251
{ 
# 253
return (static_cast< unsigned char>(__c1)) < (static_cast< unsigned char>(__c2)); 
# 255
} 
# 258
static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
# 259
{ 
# 260
if (__n == (0)) { 
# 261
return 0; }  
# 262
return __builtin_memcmp(__s1, __s2, __n); 
# 263
} 
# 266
static size_t length(const char_type *__s) 
# 267
{ return __builtin_strlen(__s); } 
# 270
static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
# 271
{ 
# 272
if (__n == (0)) { 
# 273
return 0; }  
# 274
return static_cast< const char_type *>(__builtin_memchr(__s, __a, __n)); 
# 275
} 
# 278
static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
# 279
{ 
# 280
if (__n == (0)) { 
# 281
return __s1; }  
# 282
return static_cast< char_type *>(__builtin_memmove(__s1, __s2, __n)); 
# 283
} 
# 286
static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
# 287
{ 
# 288
if (__n == (0)) { 
# 289
return __s1; }  
# 290
return static_cast< char_type *>(__builtin_memcpy(__s1, __s2, __n)); 
# 291
} 
# 294
static char_type *assign(char_type *__s, size_t __n, char_type __a) 
# 295
{ 
# 296
if (__n == (0)) { 
# 297
return __s; }  
# 298
return static_cast< char_type *>(__builtin_memset(__s, __a, __n)); 
# 299
} 
# 302
static constexpr char_type to_char_type(const int_type &__c) noexcept 
# 303
{ return static_cast< char_type>(__c); } 
# 308
static constexpr int_type to_int_type(const char_type &__c) noexcept 
# 309
{ return static_cast< int_type>(static_cast< unsigned char>(__c)); } 
# 312
static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
# 313
{ return __c1 == __c2; } 
# 316
static constexpr int_type eof() noexcept 
# 317
{ return static_cast< int_type>(-1); } 
# 320
static constexpr int_type not_eof(const int_type &__c) noexcept 
# 321
{ return (__c == eof()) ? 0 : __c; } 
# 322
}; 
# 328
template<> struct char_traits< wchar_t>  { 
# 330
typedef wchar_t char_type; 
# 331
typedef wint_t int_type; 
# 332
typedef streamoff off_type; 
# 333
typedef wstreampos pos_type; 
# 334
typedef mbstate_t state_type; 
# 337
static void assign(char_type &__c1, const char_type &__c2) noexcept 
# 338
{ __c1 = __c2; } 
# 341
static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
# 342
{ return __c1 == __c2; } 
# 345
static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
# 346
{ return __c1 < __c2; } 
# 349
static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
# 350
{ 
# 351
if (__n == (0)) { 
# 352
return 0; }  
# 353
return wmemcmp(__s1, __s2, __n); 
# 354
} 
# 357
static size_t length(const char_type *__s) 
# 358
{ return wcslen(__s); } 
# 361
static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
# 362
{ 
# 363
if (__n == (0)) { 
# 364
return 0; }  
# 365
return wmemchr(__s, __a, __n); 
# 366
} 
# 369
static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
# 370
{ 
# 371
if (__n == (0)) { 
# 372
return __s1; }  
# 373
return wmemmove(__s1, __s2, __n); 
# 374
} 
# 377
static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
# 378
{ 
# 379
if (__n == (0)) { 
# 380
return __s1; }  
# 381
return wmemcpy(__s1, __s2, __n); 
# 382
} 
# 385
static char_type *assign(char_type *__s, size_t __n, char_type __a) 
# 386
{ 
# 387
if (__n == (0)) { 
# 388
return __s; }  
# 389
return wmemset(__s, __a, __n); 
# 390
} 
# 393
static constexpr char_type to_char_type(const int_type &__c) noexcept 
# 394
{ return (char_type)__c; } 
# 397
static constexpr int_type to_int_type(const char_type &__c) noexcept 
# 398
{ return (int_type)__c; } 
# 401
static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
# 402
{ return __c1 == __c2; } 
# 405
static constexpr int_type eof() noexcept 
# 406
{ return static_cast< int_type>(4294967295U); } 
# 409
static constexpr int_type not_eof(const int_type &__c) noexcept 
# 410
{ return eq_int_type(__c, eof()) ? 0 : __c; } 
# 411
}; 
# 415
}
# 422
namespace std __attribute((__visibility__("default"))) { 
# 427
template<> struct char_traits< char16_t>  { 
# 429
typedef char16_t char_type; 
# 430
typedef uint_least16_t int_type; 
# 431
typedef streamoff off_type; 
# 432
typedef u16streampos pos_type; 
# 433
typedef mbstate_t state_type; 
# 436
static void assign(char_type &__c1, const char_type &__c2) noexcept 
# 437
{ __c1 = __c2; } 
# 440
static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
# 441
{ return __c1 == __c2; } 
# 444
static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
# 445
{ return __c1 < __c2; } 
# 448
static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
# 449
{ 
# 450
for (size_t __i = (0); __i < __n; ++__i) { 
# 451
if (lt(__s1[__i], __s2[__i])) { 
# 452
return -1; } else { 
# 453
if (lt(__s2[__i], __s1[__i])) { 
# 454
return 1; }  }  }  
# 455
return 0; 
# 456
} 
# 459
static size_t length(const char_type *__s) 
# 460
{ 
# 461
size_t __i = (0); 
# 462
while (!eq(__s[__i], char_type())) { 
# 463
++__i; }  
# 464
return __i; 
# 465
} 
# 468
static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
# 469
{ 
# 470
for (size_t __i = (0); __i < __n; ++__i) { 
# 471
if (eq(__s[__i], __a)) { 
# 472
return __s + __i; }  }  
# 473
return 0; 
# 474
} 
# 477
static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
# 478
{ 
# 479
if (__n == (0)) { 
# 480
return __s1; }  
# 481
return static_cast< char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))); 
# 483
} 
# 486
static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
# 487
{ 
# 488
if (__n == (0)) { 
# 489
return __s1; }  
# 490
return static_cast< char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))); 
# 492
} 
# 495
static char_type *assign(char_type *__s, size_t __n, char_type __a) 
# 496
{ 
# 497
for (size_t __i = (0); __i < __n; ++__i) { 
# 498
assign(__s[__i], __a); }  
# 499
return __s; 
# 500
} 
# 503
static constexpr char_type to_char_type(const int_type &__c) noexcept 
# 504
{ return (char_type)__c; } 
# 507
static constexpr int_type to_int_type(const char_type &__c) noexcept 
# 508
{ return (int_type)__c; } 
# 511
static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
# 512
{ return __c1 == __c2; } 
# 515
static constexpr int_type eof() noexcept 
# 516
{ return static_cast< int_type>(-1); } 
# 519
static constexpr int_type not_eof(const int_type &__c) noexcept 
# 520
{ return eq_int_type(__c, eof()) ? 0 : (__c); } 
# 521
}; 
# 524
template<> struct char_traits< char32_t>  { 
# 526
typedef char32_t char_type; 
# 527
typedef uint_least32_t int_type; 
# 528
typedef streamoff off_type; 
# 529
typedef u32streampos pos_type; 
# 530
typedef mbstate_t state_type; 
# 533
static void assign(char_type &__c1, const char_type &__c2) noexcept 
# 534
{ __c1 = __c2; } 
# 537
static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
# 538
{ return __c1 == __c2; } 
# 541
static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
# 542
{ return __c1 < __c2; } 
# 545
static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
# 546
{ 
# 547
for (size_t __i = (0); __i < __n; ++__i) { 
# 548
if (lt(__s1[__i], __s2[__i])) { 
# 549
return -1; } else { 
# 550
if (lt(__s2[__i], __s1[__i])) { 
# 551
return 1; }  }  }  
# 552
return 0; 
# 553
} 
# 556
static size_t length(const char_type *__s) 
# 557
{ 
# 558
size_t __i = (0); 
# 559
while (!eq(__s[__i], char_type())) { 
# 560
++__i; }  
# 561
return __i; 
# 562
} 
# 565
static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
# 566
{ 
# 567
for (size_t __i = (0); __i < __n; ++__i) { 
# 568
if (eq(__s[__i], __a)) { 
# 569
return __s + __i; }  }  
# 570
return 0; 
# 571
} 
# 574
static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
# 575
{ 
# 576
if (__n == (0)) { 
# 577
return __s1; }  
# 578
return static_cast< char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))); 
# 580
} 
# 583
static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
# 584
{ 
# 585
if (__n == (0)) { 
# 586
return __s1; }  
# 587
return static_cast< char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))); 
# 589
} 
# 592
static char_type *assign(char_type *__s, size_t __n, char_type __a) 
# 593
{ 
# 594
for (size_t __i = (0); __i < __n; ++__i) { 
# 595
assign(__s[__i], __a); }  
# 596
return __s; 
# 597
} 
# 600
static constexpr char_type to_char_type(const int_type &__c) noexcept 
# 601
{ return (char_type)__c; } 
# 604
static constexpr int_type to_int_type(const char_type &__c) noexcept 
# 605
{ return (int_type)__c; } 
# 608
static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
# 609
{ return __c1 == __c2; } 
# 612
static constexpr int_type eof() noexcept 
# 613
{ return static_cast< int_type>(-1); } 
# 616
static constexpr int_type not_eof(const int_type &__c) noexcept 
# 617
{ return eq_int_type(__c, eof()) ? 0 : __c; } 
# 618
}; 
# 621
}
# 31 "/usr/include/locale.h" 3
extern "C" {
# 53 "/usr/include/locale.h" 3
struct lconv { 
# 57
char *decimal_point; 
# 58
char *thousands_sep; 
# 64
char *grouping; 
# 70
char *int_curr_symbol; 
# 71
char *currency_symbol; 
# 72
char *mon_decimal_point; 
# 73
char *mon_thousands_sep; 
# 74
char *mon_grouping; 
# 75
char *positive_sign; 
# 76
char *negative_sign; 
# 77
char int_frac_digits; 
# 78
char frac_digits; 
# 80
char p_cs_precedes; 
# 82
char p_sep_by_space; 
# 84
char n_cs_precedes; 
# 86
char n_sep_by_space; 
# 93
char p_sign_posn; 
# 94
char n_sign_posn; 
# 97
char int_p_cs_precedes; 
# 99
char int_p_sep_by_space; 
# 101
char int_n_cs_precedes; 
# 103
char int_n_sep_by_space; 
# 110
char int_p_sign_posn; 
# 111
char int_n_sign_posn; 
# 120 "/usr/include/locale.h" 3
}; 
# 124
extern char *setlocale(int __category, const char * __locale) throw(); 
# 127
extern lconv *localeconv() throw(); 
# 151 "/usr/include/locale.h" 3
extern __locale_t newlocale(int __category_mask, const char * __locale, __locale_t __base) throw(); 
# 186 "/usr/include/locale.h" 3
extern __locale_t duplocale(__locale_t __dataset) throw(); 
# 190
extern void freelocale(__locale_t __dataset) throw(); 
# 197
extern __locale_t uselocale(__locale_t __dataset) throw(); 
# 205
}
# 51 "/usr/include/c++/5/clocale" 3
namespace std { 
# 53
using ::lconv;
# 54
using ::setlocale;
# 55
using ::localeconv;
# 56
}
# 48 "/usr/include/aarch64-linux-gnu/c++/5/bits/c++locale.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 52
extern "C" __typeof__(uselocale) __uselocale; 
# 55
}
# 58
namespace std __attribute((__visibility__("default"))) { 
# 62
typedef __locale_t __c_locale; 
# 69
inline int __convert_from_v(const __c_locale &__cloc __attribute((__unused__)), char *
# 70
__out, const int 
# 71
__size __attribute((__unused__)), const char *
# 72
__fmt, ...) 
# 73
{ 
# 75
__c_locale __old = __gnu_cxx::__uselocale(__cloc); 
# 88 "/usr/include/aarch64-linux-gnu/c++/5/bits/c++locale.h" 3
__builtin_va_list __args; 
# 89
__builtin_va_start(__args,__fmt); 
# 92
const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args); 
# 97
__builtin_va_end(__args); 
# 100
__gnu_cxx::__uselocale(__old); 
# 108
return __ret; 
# 109
} 
# 112
}
# 28 "/usr/include/ctype.h" 3
extern "C" {
# 47 "/usr/include/ctype.h" 3
enum { 
# 48
_ISupper = 256, 
# 49
_ISlower = 512, 
# 50
_ISalpha = 1024, 
# 51
_ISdigit = 2048, 
# 52
_ISxdigit = 4096, 
# 53
_ISspace = 8192, 
# 54
_ISprint = 16384, 
# 55
_ISgraph = 32768, 
# 56
_ISblank = 1, 
# 57
_IScntrl, 
# 58
_ISpunct = 4, 
# 59
_ISalnum = 8
# 60
}; 
# 79 "/usr/include/ctype.h" 3
extern const unsigned short **__ctype_b_loc() throw()
# 80
 __attribute((const)); 
# 81
extern const __int32_t **__ctype_tolower_loc() throw()
# 82
 __attribute((const)); 
# 83
extern const __int32_t **__ctype_toupper_loc() throw()
# 84
 __attribute((const)); 
# 110 "/usr/include/ctype.h" 3
extern int isalnum(int) throw(); 
# 111
extern int isalpha(int) throw(); 
# 112
extern int iscntrl(int) throw(); 
# 113
extern int isdigit(int) throw(); 
# 114
extern int islower(int) throw(); 
# 115
extern int isgraph(int) throw(); 
# 116
extern int isprint(int) throw(); 
# 117
extern int ispunct(int) throw(); 
# 118
extern int isspace(int) throw(); 
# 119
extern int isupper(int) throw(); 
# 120
extern int isxdigit(int) throw(); 
# 124
extern int tolower(int __c) throw(); 
# 127
extern int toupper(int __c) throw(); 
# 136
extern int isblank(int) throw(); 
# 143
extern int isctype(int __c, int __mask) throw(); 
# 150
extern int isascii(int __c) throw(); 
# 154
extern int toascii(int __c) throw(); 
# 158
extern int _toupper(int) throw(); 
# 159
extern int _tolower(int) throw(); 
# 271 "/usr/include/ctype.h" 3
extern int isalnum_l(int, __locale_t) throw(); 
# 272
extern int isalpha_l(int, __locale_t) throw(); 
# 273
extern int iscntrl_l(int, __locale_t) throw(); 
# 274
extern int isdigit_l(int, __locale_t) throw(); 
# 275
extern int islower_l(int, __locale_t) throw(); 
# 276
extern int isgraph_l(int, __locale_t) throw(); 
# 277
extern int isprint_l(int, __locale_t) throw(); 
# 278
extern int ispunct_l(int, __locale_t) throw(); 
# 279
extern int isspace_l(int, __locale_t) throw(); 
# 280
extern int isupper_l(int, __locale_t) throw(); 
# 281
extern int isxdigit_l(int, __locale_t) throw(); 
# 283
extern int isblank_l(int, __locale_t) throw(); 
# 287
extern int __tolower_l(int __c, __locale_t __l) throw(); 
# 288
extern int tolower_l(int __c, __locale_t __l) throw(); 
# 291
extern int __toupper_l(int __c, __locale_t __l) throw(); 
# 292
extern int toupper_l(int __c, __locale_t __l) throw(); 
# 347 "/usr/include/ctype.h" 3
}
# 62 "/usr/include/c++/5/cctype" 3
namespace std { 
# 64
using ::isalnum;
# 65
using ::isalpha;
# 66
using ::iscntrl;
# 67
using ::isdigit;
# 68
using ::isgraph;
# 69
using ::islower;
# 70
using ::isprint;
# 71
using ::ispunct;
# 72
using ::isspace;
# 73
using ::isupper;
# 74
using ::isxdigit;
# 75
using ::tolower;
# 76
using ::toupper;
# 77
}
# 85
namespace std { 
# 87
using ::isblank;
# 88
}
# 44 "/usr/include/c++/5/bits/localefwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 55 "/usr/include/c++/5/bits/localefwd.h" 3
class locale; 
# 57
template< class _Facet> bool has_facet(const locale &) throw(); 
# 61
template< class _Facet> const _Facet &use_facet(const locale &); 
# 66
template< class _CharT> inline bool isspace(_CharT, const locale &); 
# 70
template< class _CharT> inline bool isprint(_CharT, const locale &); 
# 74
template< class _CharT> inline bool iscntrl(_CharT, const locale &); 
# 78
template< class _CharT> inline bool isupper(_CharT, const locale &); 
# 82
template< class _CharT> inline bool islower(_CharT, const locale &); 
# 86
template< class _CharT> inline bool isalpha(_CharT, const locale &); 
# 90
template< class _CharT> inline bool isdigit(_CharT, const locale &); 
# 94
template< class _CharT> inline bool ispunct(_CharT, const locale &); 
# 98
template< class _CharT> inline bool isxdigit(_CharT, const locale &); 
# 102
template< class _CharT> inline bool isalnum(_CharT, const locale &); 
# 106
template< class _CharT> inline bool isgraph(_CharT, const locale &); 
# 111
template< class _CharT> inline bool isblank(_CharT, const locale &); 
# 116
template< class _CharT> inline _CharT toupper(_CharT, const locale &); 
# 120
template< class _CharT> inline _CharT tolower(_CharT, const locale &); 
# 125
struct ctype_base; 
# 126
template< class _CharT> class ctype; 
# 128
template<> class ctype< char> ; 
# 130
template<> class ctype< wchar_t> ; 
# 132
template< class _CharT> class ctype_byname; 
# 136
class codecvt_base; 
# 137
template< class _InternT, class _ExternT, class _StateT> class codecvt; 
# 139
template<> class codecvt< char, char, __mbstate_t> ; 
# 141
template<> class codecvt< wchar_t, char, __mbstate_t> ; 
# 143
template< class _InternT, class _ExternT, class _StateT> class codecvt_byname; 
# 148
template< class _CharT, class _InIter = istreambuf_iterator< _CharT, char_traits< _CharT> > > class num_get; 
# 150
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT, char_traits< _CharT> > > class num_put; 
# 153
inline namespace __cxx11 { 
# 154
template< class _CharT> class numpunct; 
# 155
template< class _CharT> class numpunct_byname; 
# 156
}
# 158
inline namespace __cxx11 { 
# 160
template< class _CharT> class collate; 
# 162
template< class _CharT> class collate_byname; 
# 164
}
# 167
class time_base; 
# 168
inline namespace __cxx11 { 
# 169
template< class _CharT, class _InIter = istreambuf_iterator< _CharT, char_traits< _CharT> > > class time_get; 
# 171
template< class _CharT, class _InIter = istreambuf_iterator< _CharT, char_traits< _CharT> > > class time_get_byname; 
# 173
}
# 174
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT, char_traits< _CharT> > > class time_put; 
# 176
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT, char_traits< _CharT> > > class time_put_byname; 
# 180
class money_base; 
# 181
inline namespace __cxx11 { 
# 182
template< class _CharT, class _InIter = istreambuf_iterator< _CharT, char_traits< _CharT> > > class money_get; 
# 184
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT, char_traits< _CharT> > > class money_put; 
# 186
}
# 187
inline namespace __cxx11 { 
# 188
template< class _CharT, bool _Intl = false> class moneypunct; 
# 190
template< class _CharT, bool _Intl = false> class moneypunct_byname; 
# 192
}
# 195
struct messages_base; 
# 196
inline namespace __cxx11 { 
# 197
template< class _CharT> class messages; 
# 199
template< class _CharT> class messages_byname; 
# 201
}
# 204
}
# 30 "/usr/include/aarch64-linux-gnu/c++/5/bits/gthr.h" 3
#pragma GCC visibility push ( default )
# 72 "/usr/include/aarch64-linux-gnu/bits/sched.h" 3
struct sched_param { 
# 74
int __sched_priority; 
# 75
}; 
# 77
extern "C" {
# 81
extern int clone(int (* __fn)(void * __arg), void * __child_stack, int __flags, void * __arg, ...) throw(); 
# 85
extern int unshare(int __flags) throw(); 
# 88
extern int sched_getcpu() throw(); 
# 91
extern int setns(int __fd, int __nstype) throw(); 
# 95
}
# 103
struct __sched_param { 
# 105
int __sched_priority; 
# 106
}; 
# 118 "/usr/include/aarch64-linux-gnu/bits/sched.h" 3
typedef unsigned long __cpu_mask; 
# 128
typedef 
# 126
struct { 
# 127
__cpu_mask __bits[(1024) / ((8) * sizeof(__cpu_mask))]; 
# 128
} cpu_set_t; 
# 201 "/usr/include/aarch64-linux-gnu/bits/sched.h" 3
extern "C" {
# 203
extern int __sched_cpucount(size_t __setsize, const cpu_set_t * __setp) throw(); 
# 205
extern cpu_set_t *__sched_cpualloc(size_t __count) throw(); 
# 206
extern void __sched_cpufree(cpu_set_t * __set) throw(); 
# 208
}
# 48 "/usr/include/sched.h" 3
extern "C" {
# 51
extern int sched_setparam(__pid_t __pid, const sched_param * __param) throw(); 
# 55
extern int sched_getparam(__pid_t __pid, sched_param * __param) throw(); 
# 58
extern int sched_setscheduler(__pid_t __pid, int __policy, const sched_param * __param) throw(); 
# 62
extern int sched_getscheduler(__pid_t __pid) throw(); 
# 65
extern int sched_yield() throw(); 
# 68
extern int sched_get_priority_max(int __algorithm) throw(); 
# 71
extern int sched_get_priority_min(int __algorithm) throw(); 
# 74
extern int sched_rr_get_interval(__pid_t __pid, timespec * __t) throw(); 
# 118 "/usr/include/sched.h" 3
extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize, const cpu_set_t * __cpuset) throw(); 
# 122
extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t * __cpuset) throw(); 
# 126
}
# 30 "/usr/include/aarch64-linux-gnu/bits/setjmp.h" 3
__extension__ typedef unsigned long long __jmp_buf[22]; 
# 33 "/usr/include/pthread.h" 3
enum { 
# 34
PTHREAD_CREATE_JOINABLE, 
# 36
PTHREAD_CREATE_DETACHED
# 38
}; 
# 43
enum { 
# 44
PTHREAD_MUTEX_TIMED_NP, 
# 45
PTHREAD_MUTEX_RECURSIVE_NP, 
# 46
PTHREAD_MUTEX_ERRORCHECK_NP, 
# 47
PTHREAD_MUTEX_ADAPTIVE_NP, 
# 50
PTHREAD_MUTEX_NORMAL = 0, 
# 51
PTHREAD_MUTEX_RECURSIVE, 
# 52
PTHREAD_MUTEX_ERRORCHECK, 
# 53
PTHREAD_MUTEX_DEFAULT = 0, 
# 57
PTHREAD_MUTEX_FAST_NP = 0
# 59
}; 
# 65
enum { 
# 66
PTHREAD_MUTEX_STALLED, 
# 67
PTHREAD_MUTEX_STALLED_NP = 0, 
# 68
PTHREAD_MUTEX_ROBUST, 
# 69
PTHREAD_MUTEX_ROBUST_NP = 1
# 70
}; 
# 77
enum { 
# 78
PTHREAD_PRIO_NONE, 
# 79
PTHREAD_PRIO_INHERIT, 
# 80
PTHREAD_PRIO_PROTECT
# 81
}; 
# 115 "/usr/include/pthread.h" 3
enum { 
# 116
PTHREAD_RWLOCK_PREFER_READER_NP, 
# 117
PTHREAD_RWLOCK_PREFER_WRITER_NP, 
# 118
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 
# 119
PTHREAD_RWLOCK_DEFAULT_NP = 0
# 120
}; 
# 156 "/usr/include/pthread.h" 3
enum { 
# 157
PTHREAD_INHERIT_SCHED, 
# 159
PTHREAD_EXPLICIT_SCHED
# 161
}; 
# 166
enum { 
# 167
PTHREAD_SCOPE_SYSTEM, 
# 169
PTHREAD_SCOPE_PROCESS
# 171
}; 
# 176
enum { 
# 177
PTHREAD_PROCESS_PRIVATE, 
# 179
PTHREAD_PROCESS_SHARED
# 181
}; 
# 190 "/usr/include/pthread.h" 3
struct _pthread_cleanup_buffer { 
# 192
void (*__routine)(void *); 
# 193
void *__arg; 
# 194
int __canceltype; 
# 195
_pthread_cleanup_buffer *__prev; 
# 196
}; 
# 200
enum { 
# 201
PTHREAD_CANCEL_ENABLE, 
# 203
PTHREAD_CANCEL_DISABLE
# 205
}; 
# 207
enum { 
# 208
PTHREAD_CANCEL_DEFERRED, 
# 210
PTHREAD_CANCEL_ASYNCHRONOUS
# 212
}; 
# 228 "/usr/include/pthread.h" 3
extern "C" {
# 233
extern int pthread_create(pthread_t *__restrict__ __newthread, const pthread_attr_t *__restrict__ __attr, void *(* __start_routine)(void *), void *__restrict__ __arg) throw()
# 236
 __attribute((__nonnull__(1, 3))); 
# 242
extern void pthread_exit(void * __retval) __attribute((__noreturn__)); 
# 250
extern int pthread_join(pthread_t __th, void ** __thread_return); 
# 255
extern int pthread_tryjoin_np(pthread_t __th, void ** __thread_return) throw(); 
# 263
extern int pthread_timedjoin_np(pthread_t __th, void ** __thread_return, const timespec * __abstime); 
# 271
extern int pthread_detach(pthread_t __th) throw(); 
# 275
extern pthread_t pthread_self() throw() __attribute((const)); 
# 278
extern int pthread_equal(pthread_t __thread1, pthread_t __thread2) throw()
# 279
 __attribute((const)); 
# 287
extern int pthread_attr_init(pthread_attr_t * __attr) throw() __attribute((__nonnull__(1))); 
# 290
extern int pthread_attr_destroy(pthread_attr_t * __attr) throw()
# 291
 __attribute((__nonnull__(1))); 
# 294
extern int pthread_attr_getdetachstate(const pthread_attr_t * __attr, int * __detachstate) throw()
# 296
 __attribute((__nonnull__(1, 2))); 
# 299
extern int pthread_attr_setdetachstate(pthread_attr_t * __attr, int __detachstate) throw()
# 301
 __attribute((__nonnull__(1))); 
# 305
extern int pthread_attr_getguardsize(const pthread_attr_t * __attr, size_t * __guardsize) throw()
# 307
 __attribute((__nonnull__(1, 2))); 
# 310
extern int pthread_attr_setguardsize(pthread_attr_t * __attr, size_t __guardsize) throw()
# 312
 __attribute((__nonnull__(1))); 
# 316
extern int pthread_attr_getschedparam(const pthread_attr_t *__restrict__ __attr, sched_param *__restrict__ __param) throw()
# 318
 __attribute((__nonnull__(1, 2))); 
# 321
extern int pthread_attr_setschedparam(pthread_attr_t *__restrict__ __attr, const sched_param *__restrict__ __param) throw()
# 323
 __attribute((__nonnull__(1, 2))); 
# 326
extern int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict__ __attr, int *__restrict__ __policy) throw()
# 328
 __attribute((__nonnull__(1, 2))); 
# 331
extern int pthread_attr_setschedpolicy(pthread_attr_t * __attr, int __policy) throw()
# 332
 __attribute((__nonnull__(1))); 
# 335
extern int pthread_attr_getinheritsched(const pthread_attr_t *__restrict__ __attr, int *__restrict__ __inherit) throw()
# 337
 __attribute((__nonnull__(1, 2))); 
# 340
extern int pthread_attr_setinheritsched(pthread_attr_t * __attr, int __inherit) throw()
# 342
 __attribute((__nonnull__(1))); 
# 346
extern int pthread_attr_getscope(const pthread_attr_t *__restrict__ __attr, int *__restrict__ __scope) throw()
# 348
 __attribute((__nonnull__(1, 2))); 
# 351
extern int pthread_attr_setscope(pthread_attr_t * __attr, int __scope) throw()
# 352
 __attribute((__nonnull__(1))); 
# 355
extern int pthread_attr_getstackaddr(const pthread_attr_t *__restrict__ __attr, void **__restrict__ __stackaddr) throw()
# 357
 __attribute((__nonnull__(1, 2))) __attribute((__deprecated__)); 
# 363
extern int pthread_attr_setstackaddr(pthread_attr_t * __attr, void * __stackaddr) throw()
# 365
 __attribute((__nonnull__(1))) __attribute((__deprecated__)); 
# 368
extern int pthread_attr_getstacksize(const pthread_attr_t *__restrict__ __attr, size_t *__restrict__ __stacksize) throw()
# 370
 __attribute((__nonnull__(1, 2))); 
# 375
extern int pthread_attr_setstacksize(pthread_attr_t * __attr, size_t __stacksize) throw()
# 377
 __attribute((__nonnull__(1))); 
# 381
extern int pthread_attr_getstack(const pthread_attr_t *__restrict__ __attr, void **__restrict__ __stackaddr, size_t *__restrict__ __stacksize) throw()
# 384
 __attribute((__nonnull__(1, 2, 3))); 
# 389
extern int pthread_attr_setstack(pthread_attr_t * __attr, void * __stackaddr, size_t __stacksize) throw()
# 390
 __attribute((__nonnull__(1))); 
# 396
extern int pthread_attr_setaffinity_np(pthread_attr_t * __attr, size_t __cpusetsize, const cpu_set_t * __cpuset) throw()
# 399
 __attribute((__nonnull__(1, 3))); 
# 403
extern int pthread_attr_getaffinity_np(const pthread_attr_t * __attr, size_t __cpusetsize, cpu_set_t * __cpuset) throw()
# 406
 __attribute((__nonnull__(1, 3))); 
# 409
extern int pthread_getattr_default_np(pthread_attr_t * __attr) throw()
# 410
 __attribute((__nonnull__(1))); 
# 414
extern int pthread_setattr_default_np(const pthread_attr_t * __attr) throw()
# 415
 __attribute((__nonnull__(1))); 
# 420
extern int pthread_getattr_np(pthread_t __th, pthread_attr_t * __attr) throw()
# 421
 __attribute((__nonnull__(2))); 
# 429
extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const sched_param * __param) throw()
# 431
 __attribute((__nonnull__(3))); 
# 434
extern int pthread_getschedparam(pthread_t __target_thread, int *__restrict__ __policy, sched_param *__restrict__ __param) throw()
# 437
 __attribute((__nonnull__(2, 3))); 
# 440
extern int pthread_setschedprio(pthread_t __target_thread, int __prio) throw(); 
# 446
extern int pthread_getname_np(pthread_t __target_thread, char * __buf, size_t __buflen) throw()
# 448
 __attribute((__nonnull__(2))); 
# 451
extern int pthread_setname_np(pthread_t __target_thread, const char * __name) throw()
# 452
 __attribute((__nonnull__(2))); 
# 458
extern int pthread_getconcurrency() throw(); 
# 461
extern int pthread_setconcurrency(int __level) throw(); 
# 469
extern int pthread_yield() throw(); 
# 474
extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, const cpu_set_t * __cpuset) throw()
# 476
 __attribute((__nonnull__(3))); 
# 479
extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t * __cpuset) throw()
# 481
 __attribute((__nonnull__(3))); 
# 494 "/usr/include/pthread.h" 3
extern int pthread_once(pthread_once_t * __once_control, void (* __init_routine)(void))
# 495
 __attribute((__nonnull__(1, 2))); 
# 506 "/usr/include/pthread.h" 3
extern int pthread_setcancelstate(int __state, int * __oldstate); 
# 510
extern int pthread_setcanceltype(int __type, int * __oldtype); 
# 513
extern int pthread_cancel(pthread_t __th); 
# 518
extern void pthread_testcancel(); 
# 531
typedef 
# 524
struct { 
# 526
struct { 
# 527
__jmp_buf __cancel_jmp_buf; 
# 528
int __mask_was_saved; 
# 529
} __cancel_jmp_buf[1]; 
# 530
void *__pad[4]; 
# 531
} __pthread_unwind_buf_t __attribute((__aligned__)); 
# 540 "/usr/include/pthread.h" 3
struct __pthread_cleanup_frame { 
# 542
void (*__cancel_routine)(void *); 
# 543
void *__cancel_arg; 
# 544
int __do_it; 
# 545
int __cancel_type; 
# 546
}; 
# 551
class __pthread_cleanup_class { 
# 553
void (*__cancel_routine)(void *); 
# 554
void *__cancel_arg; 
# 555
int __do_it; 
# 556
int __cancel_type; 
# 559
public: __pthread_cleanup_class(void (*__fct)(void *), void *__arg) : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1) 
# 560
{ } 
# 561
~__pthread_cleanup_class() { if (__do_it) { (__cancel_routine)(__cancel_arg); }  } 
# 562
void __setdoit(int __newval) { (__do_it) = __newval; } 
# 563
void __defer() { pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &(__cancel_type)); 
# 564
} 
# 565
void __restore() const { pthread_setcanceltype(__cancel_type, 0); } 
# 566
}; 
# 742 "/usr/include/pthread.h" 3
struct __jmp_buf_tag; 
# 743
extern int __sigsetjmp(__jmp_buf_tag * __env, int __savemask) throw(); 
# 749
extern int pthread_mutex_init(pthread_mutex_t * __mutex, const pthread_mutexattr_t * __mutexattr) throw()
# 751
 __attribute((__nonnull__(1))); 
# 754
extern int pthread_mutex_destroy(pthread_mutex_t * __mutex) throw()
# 755
 __attribute((__nonnull__(1))); 
# 758
extern int pthread_mutex_trylock(pthread_mutex_t * __mutex) throw()
# 759
 __attribute((__nonnull__(1))); 
# 762
extern int pthread_mutex_lock(pthread_mutex_t * __mutex) throw()
# 763
 __attribute((__nonnull__(1))); 
# 767
extern int pthread_mutex_timedlock(pthread_mutex_t *__restrict__ __mutex, const timespec *__restrict__ __abstime) throw()
# 769
 __attribute((__nonnull__(1, 2))); 
# 773
extern int pthread_mutex_unlock(pthread_mutex_t * __mutex) throw()
# 774
 __attribute((__nonnull__(1))); 
# 778
extern int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict__ __mutex, int *__restrict__ __prioceiling) throw()
# 781
 __attribute((__nonnull__(1, 2))); 
# 785
extern int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict__ __mutex, int __prioceiling, int *__restrict__ __old_ceiling) throw()
# 788
 __attribute((__nonnull__(1, 3))); 
# 793
extern int pthread_mutex_consistent(pthread_mutex_t * __mutex) throw()
# 794
 __attribute((__nonnull__(1))); 
# 796
extern int pthread_mutex_consistent_np(pthread_mutex_t * __mutex) throw()
# 797
 __attribute((__nonnull__(1))); 
# 806 "/usr/include/pthread.h" 3
extern int pthread_mutexattr_init(pthread_mutexattr_t * __attr) throw()
# 807
 __attribute((__nonnull__(1))); 
# 810
extern int pthread_mutexattr_destroy(pthread_mutexattr_t * __attr) throw()
# 811
 __attribute((__nonnull__(1))); 
# 814
extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 817
 __attribute((__nonnull__(1, 2))); 
# 820
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t * __attr, int __pshared) throw()
# 822
 __attribute((__nonnull__(1))); 
# 826
extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __kind) throw()
# 828
 __attribute((__nonnull__(1, 2))); 
# 833
extern int pthread_mutexattr_settype(pthread_mutexattr_t * __attr, int __kind) throw()
# 834
 __attribute((__nonnull__(1))); 
# 838
extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __protocol) throw()
# 841
 __attribute((__nonnull__(1, 2))); 
# 845
extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t * __attr, int __protocol) throw()
# 847
 __attribute((__nonnull__(1))); 
# 850
extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __prioceiling) throw()
# 853
 __attribute((__nonnull__(1, 2))); 
# 856
extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * __attr, int __prioceiling) throw()
# 858
 __attribute((__nonnull__(1))); 
# 862
extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t * __attr, int * __robustness) throw()
# 864
 __attribute((__nonnull__(1, 2))); 
# 866
extern int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t * __attr, int * __robustness) throw()
# 868
 __attribute((__nonnull__(1, 2))); 
# 872
extern int pthread_mutexattr_setrobust(pthread_mutexattr_t * __attr, int __robustness) throw()
# 874
 __attribute((__nonnull__(1))); 
# 876
extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t * __attr, int __robustness) throw()
# 878
 __attribute((__nonnull__(1))); 
# 888 "/usr/include/pthread.h" 3
extern int pthread_rwlock_init(pthread_rwlock_t *__restrict__ __rwlock, const pthread_rwlockattr_t *__restrict__ __attr) throw()
# 890
 __attribute((__nonnull__(1))); 
# 893
extern int pthread_rwlock_destroy(pthread_rwlock_t * __rwlock) throw()
# 894
 __attribute((__nonnull__(1))); 
# 897
extern int pthread_rwlock_rdlock(pthread_rwlock_t * __rwlock) throw()
# 898
 __attribute((__nonnull__(1))); 
# 901
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t * __rwlock) throw()
# 902
 __attribute((__nonnull__(1))); 
# 906
extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict__ __rwlock, const timespec *__restrict__ __abstime) throw()
# 908
 __attribute((__nonnull__(1, 2))); 
# 912
extern int pthread_rwlock_wrlock(pthread_rwlock_t * __rwlock) throw()
# 913
 __attribute((__nonnull__(1))); 
# 916
extern int pthread_rwlock_trywrlock(pthread_rwlock_t * __rwlock) throw()
# 917
 __attribute((__nonnull__(1))); 
# 921
extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict__ __rwlock, const timespec *__restrict__ __abstime) throw()
# 923
 __attribute((__nonnull__(1, 2))); 
# 927
extern int pthread_rwlock_unlock(pthread_rwlock_t * __rwlock) throw()
# 928
 __attribute((__nonnull__(1))); 
# 934
extern int pthread_rwlockattr_init(pthread_rwlockattr_t * __attr) throw()
# 935
 __attribute((__nonnull__(1))); 
# 938
extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t * __attr) throw()
# 939
 __attribute((__nonnull__(1))); 
# 942
extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 945
 __attribute((__nonnull__(1, 2))); 
# 948
extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * __attr, int __pshared) throw()
# 950
 __attribute((__nonnull__(1))); 
# 953
extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict__ __attr, int *__restrict__ __pref) throw()
# 956
 __attribute((__nonnull__(1, 2))); 
# 959
extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t * __attr, int __pref) throw()
# 960
 __attribute((__nonnull__(1))); 
# 968
extern int pthread_cond_init(pthread_cond_t *__restrict__ __cond, const pthread_condattr_t *__restrict__ __cond_attr) throw()
# 970
 __attribute((__nonnull__(1))); 
# 973
extern int pthread_cond_destroy(pthread_cond_t * __cond) throw()
# 974
 __attribute((__nonnull__(1))); 
# 977
extern int pthread_cond_signal(pthread_cond_t * __cond) throw()
# 978
 __attribute((__nonnull__(1))); 
# 981
extern int pthread_cond_broadcast(pthread_cond_t * __cond) throw()
# 982
 __attribute((__nonnull__(1))); 
# 989
extern int pthread_cond_wait(pthread_cond_t *__restrict__ __cond, pthread_mutex_t *__restrict__ __mutex)
# 991
 __attribute((__nonnull__(1, 2))); 
# 1000 "/usr/include/pthread.h" 3
extern int pthread_cond_timedwait(pthread_cond_t *__restrict__ __cond, pthread_mutex_t *__restrict__ __mutex, const timespec *__restrict__ __abstime)
# 1003
 __attribute((__nonnull__(1, 2, 3))); 
# 1008
extern int pthread_condattr_init(pthread_condattr_t * __attr) throw()
# 1009
 __attribute((__nonnull__(1))); 
# 1012
extern int pthread_condattr_destroy(pthread_condattr_t * __attr) throw()
# 1013
 __attribute((__nonnull__(1))); 
# 1016
extern int pthread_condattr_getpshared(const pthread_condattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 1019
 __attribute((__nonnull__(1, 2))); 
# 1022
extern int pthread_condattr_setpshared(pthread_condattr_t * __attr, int __pshared) throw()
# 1023
 __attribute((__nonnull__(1))); 
# 1027
extern int pthread_condattr_getclock(const pthread_condattr_t *__restrict__ __attr, __clockid_t *__restrict__ __clock_id) throw()
# 1030
 __attribute((__nonnull__(1, 2))); 
# 1033
extern int pthread_condattr_setclock(pthread_condattr_t * __attr, __clockid_t __clock_id) throw()
# 1035
 __attribute((__nonnull__(1))); 
# 1044 "/usr/include/pthread.h" 3
extern int pthread_spin_init(pthread_spinlock_t * __lock, int __pshared) throw()
# 1045
 __attribute((__nonnull__(1))); 
# 1048
extern int pthread_spin_destroy(pthread_spinlock_t * __lock) throw()
# 1049
 __attribute((__nonnull__(1))); 
# 1052
extern int pthread_spin_lock(pthread_spinlock_t * __lock) throw()
# 1053
 __attribute((__nonnull__(1))); 
# 1056
extern int pthread_spin_trylock(pthread_spinlock_t * __lock) throw()
# 1057
 __attribute((__nonnull__(1))); 
# 1060
extern int pthread_spin_unlock(pthread_spinlock_t * __lock) throw()
# 1061
 __attribute((__nonnull__(1))); 
# 1068
extern int pthread_barrier_init(pthread_barrier_t *__restrict__ __barrier, const pthread_barrierattr_t *__restrict__ __attr, unsigned __count) throw()
# 1071
 __attribute((__nonnull__(1))); 
# 1074
extern int pthread_barrier_destroy(pthread_barrier_t * __barrier) throw()
# 1075
 __attribute((__nonnull__(1))); 
# 1078
extern int pthread_barrier_wait(pthread_barrier_t * __barrier) throw()
# 1079
 __attribute((__nonnull__(1))); 
# 1083
extern int pthread_barrierattr_init(pthread_barrierattr_t * __attr) throw()
# 1084
 __attribute((__nonnull__(1))); 
# 1087
extern int pthread_barrierattr_destroy(pthread_barrierattr_t * __attr) throw()
# 1088
 __attribute((__nonnull__(1))); 
# 1091
extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 1094
 __attribute((__nonnull__(1, 2))); 
# 1097
extern int pthread_barrierattr_setpshared(pthread_barrierattr_t * __attr, int __pshared) throw()
# 1099
 __attribute((__nonnull__(1))); 
# 1111 "/usr/include/pthread.h" 3
extern int pthread_key_create(pthread_key_t * __key, void (* __destr_function)(void *)) throw()
# 1113
 __attribute((__nonnull__(1))); 
# 1116
extern int pthread_key_delete(pthread_key_t __key) throw(); 
# 1119
extern void *pthread_getspecific(pthread_key_t __key) throw(); 
# 1122
extern int pthread_setspecific(pthread_key_t __key, const void * __pointer) throw(); 
# 1128
extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t * __clock_id) throw()
# 1130
 __attribute((__nonnull__(2))); 
# 1145 "/usr/include/pthread.h" 3
extern int pthread_atfork(void (* __prepare)(void), void (* __parent)(void), void (* __child)(void)) throw(); 
# 1159 "/usr/include/pthread.h" 3
}
# 47 "/usr/include/aarch64-linux-gnu/c++/5/bits/gthr-default.h" 3
typedef pthread_t __gthread_t; 
# 48
typedef pthread_key_t __gthread_key_t; 
# 49
typedef pthread_once_t __gthread_once_t; 
# 50
typedef pthread_mutex_t __gthread_mutex_t; 
# 51
typedef pthread_mutex_t __gthread_recursive_mutex_t; 
# 52
typedef pthread_cond_t __gthread_cond_t; 
# 53
typedef timespec __gthread_time_t; 
# 101 "/usr/include/aarch64-linux-gnu/c++/5/bits/gthr-default.h" 3
static __typeof__(pthread_once) __gthrw_pthread_once __attribute((__weakref__("pthread_once"))); 
# 102
static __typeof__(pthread_getspecific) __gthrw_pthread_getspecific __attribute((__weakref__("pthread_getspecific"))); 
# 103
static __typeof__(pthread_setspecific) __gthrw_pthread_setspecific __attribute((__weakref__("pthread_setspecific"))); 
# 105
static __typeof__(pthread_create) __gthrw_pthread_create __attribute((__weakref__("pthread_create"))); 
# 106
static __typeof__(pthread_join) __gthrw_pthread_join __attribute((__weakref__("pthread_join"))); 
# 107
static __typeof__(pthread_equal) __gthrw_pthread_equal __attribute((__weakref__("pthread_equal"))); 
# 108
static __typeof__(pthread_self) __gthrw_pthread_self __attribute((__weakref__("pthread_self"))); 
# 109
static __typeof__(pthread_detach) __gthrw_pthread_detach __attribute((__weakref__("pthread_detach"))); 
# 111
static __typeof__(pthread_cancel) __gthrw_pthread_cancel __attribute((__weakref__("pthread_cancel"))); 
# 113
static __typeof__(sched_yield) __gthrw_sched_yield __attribute((__weakref__("sched_yield"))); 
# 115
static __typeof__(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute((__weakref__("pthread_mutex_lock"))); 
# 116
static __typeof__(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute((__weakref__("pthread_mutex_trylock"))); 
# 118
static __typeof__(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute((__weakref__("pthread_mutex_timedlock"))); 
# 120
static __typeof__(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute((__weakref__("pthread_mutex_unlock"))); 
# 121
static __typeof__(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute((__weakref__("pthread_mutex_init"))); 
# 122
static __typeof__(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute((__weakref__("pthread_mutex_destroy"))); 
# 124
static __typeof__(pthread_cond_init) __gthrw_pthread_cond_init __attribute((__weakref__("pthread_cond_init"))); 
# 125
static __typeof__(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute((__weakref__("pthread_cond_broadcast"))); 
# 126
static __typeof__(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute((__weakref__("pthread_cond_signal"))); 
# 127
static __typeof__(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute((__weakref__("pthread_cond_wait"))); 
# 128
static __typeof__(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute((__weakref__("pthread_cond_timedwait"))); 
# 129
static __typeof__(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute((__weakref__("pthread_cond_destroy"))); 
# 131
static __typeof__(pthread_key_create) __gthrw_pthread_key_create __attribute((__weakref__("pthread_key_create"))); 
# 132
static __typeof__(pthread_key_delete) __gthrw_pthread_key_delete __attribute((__weakref__("pthread_key_delete"))); 
# 133
static __typeof__(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute((__weakref__("pthread_mutexattr_init"))); 
# 134
static __typeof__(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute((__weakref__("pthread_mutexattr_settype"))); 
# 135
static __typeof__(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute((__weakref__("pthread_mutexattr_destroy"))); 
# 236 "/usr/include/aarch64-linux-gnu/c++/5/bits/gthr-default.h" 3
static __typeof__(pthread_key_create) __gthrw___pthread_key_create __attribute((__weakref__("__pthread_key_create"))); 
# 247 "/usr/include/aarch64-linux-gnu/c++/5/bits/gthr-default.h" 3
static inline int __gthread_active_p() 
# 248
{ 
# 249
static void *const __gthread_active_ptr = __extension__ ((void *)(&__gthrw___pthread_key_create)); 
# 251
return __gthread_active_ptr != (0); 
# 252
} 
# 659 "/usr/include/aarch64-linux-gnu/c++/5/bits/gthr-default.h" 3
static inline int __gthread_create(__gthread_t *__threadid, void *(*__func)(void *), void *
# 660
__args) 
# 661
{ 
# 662
return __gthrw_pthread_create(__threadid, __null, __func, __args); 
# 663
} 
# 666
static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr) 
# 667
{ 
# 668
return __gthrw_pthread_join(__threadid, __value_ptr); 
# 669
} 
# 672
static inline int __gthread_detach(__gthread_t __threadid) 
# 673
{ 
# 674
return __gthrw_pthread_detach(__threadid); 
# 675
} 
# 678
static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2) 
# 679
{ 
# 680
return __gthrw_pthread_equal(__t1, __t2); 
# 681
} 
# 684
static inline __gthread_t __gthread_self() 
# 685
{ 
# 686
return __gthrw_pthread_self(); 
# 687
} 
# 690
static inline int __gthread_yield() 
# 691
{ 
# 692
return __gthrw_sched_yield(); 
# 693
} 
# 696
static inline int __gthread_once(__gthread_once_t *__once, void (*__func)(void)) 
# 697
{ 
# 698
if (__gthread_active_p()) { 
# 699
return __gthrw_pthread_once(__once, __func); } else { 
# 701
return -1; }  
# 702
} 
# 705
static inline int __gthread_key_create(__gthread_key_t *__key, void (*__dtor)(void *)) 
# 706
{ 
# 707
return __gthrw_pthread_key_create(__key, __dtor); 
# 708
} 
# 711
static inline int __gthread_key_delete(__gthread_key_t __key) 
# 712
{ 
# 713
return __gthrw_pthread_key_delete(__key); 
# 714
} 
# 717
static inline void *__gthread_getspecific(__gthread_key_t __key) 
# 718
{ 
# 719
return __gthrw_pthread_getspecific(__key); 
# 720
} 
# 723
static inline int __gthread_setspecific(__gthread_key_t __key, const void *__ptr) 
# 724
{ 
# 725
return __gthrw_pthread_setspecific(__key, __ptr); 
# 726
} 
# 729
static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) 
# 730
{ 
# 731
if (__gthread_active_p()) { 
# 732
__gthrw_pthread_mutex_init(__mutex, __null); }  
# 733
} 
# 736
static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex) 
# 737
{ 
# 738
if (__gthread_active_p()) { 
# 739
return __gthrw_pthread_mutex_destroy(__mutex); } else { 
# 741
return 0; }  
# 742
} 
# 745
static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) 
# 746
{ 
# 747
if (__gthread_active_p()) { 
# 748
return __gthrw_pthread_mutex_lock(__mutex); } else { 
# 750
return 0; }  
# 751
} 
# 754
static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) 
# 755
{ 
# 756
if (__gthread_active_p()) { 
# 757
return __gthrw_pthread_mutex_trylock(__mutex); } else { 
# 759
return 0; }  
# 760
} 
# 764
static inline int __gthread_mutex_timedlock(__gthread_mutex_t *__mutex, const __gthread_time_t *
# 765
__abs_timeout) 
# 766
{ 
# 767
if (__gthread_active_p()) { 
# 768
return __gthrw_pthread_mutex_timedlock(__mutex, __abs_timeout); } else { 
# 770
return 0; }  
# 771
} 
# 775
static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) 
# 776
{ 
# 777
if (__gthread_active_p()) { 
# 778
return __gthrw_pthread_mutex_unlock(__mutex); } else { 
# 780
return 0; }  
# 781
} 
# 808 "/usr/include/aarch64-linux-gnu/c++/5/bits/gthr-default.h" 3
static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) 
# 809
{ 
# 810
return __gthread_mutex_lock(__mutex); 
# 811
} 
# 814
static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) 
# 815
{ 
# 816
return __gthread_mutex_trylock(__mutex); 
# 817
} 
# 821
static inline int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex, const __gthread_time_t *
# 822
__abs_timeout) 
# 823
{ 
# 824
return __gthread_mutex_timedlock(__mutex, __abs_timeout); 
# 825
} 
# 829
static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) 
# 830
{ 
# 831
return __gthread_mutex_unlock(__mutex); 
# 832
} 
# 835
static inline int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) 
# 836
{ 
# 837
return __gthread_mutex_destroy(__mutex); 
# 838
} 
# 850 "/usr/include/aarch64-linux-gnu/c++/5/bits/gthr-default.h" 3
static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond) 
# 851
{ 
# 852
return __gthrw_pthread_cond_broadcast(__cond); 
# 853
} 
# 856
static inline int __gthread_cond_signal(__gthread_cond_t *__cond) 
# 857
{ 
# 858
return __gthrw_pthread_cond_signal(__cond); 
# 859
} 
# 862
static inline int __gthread_cond_wait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex) 
# 863
{ 
# 864
return __gthrw_pthread_cond_wait(__cond, __mutex); 
# 865
} 
# 868
static inline int __gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex, const __gthread_time_t *
# 869
__abs_timeout) 
# 870
{ 
# 871
return __gthrw_pthread_cond_timedwait(__cond, __mutex, __abs_timeout); 
# 872
} 
# 875
static inline int __gthread_cond_wait_recursive(__gthread_cond_t *__cond, __gthread_recursive_mutex_t *
# 876
__mutex) 
# 877
{ 
# 878
return __gthread_cond_wait(__cond, __mutex); 
# 879
} 
# 882
static inline int __gthread_cond_destroy(__gthread_cond_t *__cond) 
# 883
{ 
# 884
return __gthrw_pthread_cond_destroy(__cond); 
# 885
} 
# 151 "/usr/include/aarch64-linux-gnu/c++/5/bits/gthr.h" 3
#pragma GCC visibility pop
# 33 "/usr/include/aarch64-linux-gnu/c++/5/bits/atomic_word.h" 3
typedef int _Atomic_word; 
# 38 "/usr/include/c++/5/ext/atomicity.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 48
static inline _Atomic_word __exchange_and_add(volatile _Atomic_word *__mem, int __val) 
# 49
{ return __atomic_fetch_add(__mem, __val, 4); } 
# 52
static inline void __atomic_add(volatile _Atomic_word *__mem, int __val) 
# 53
{ __atomic_fetch_add(__mem, __val, 4); } 
# 65 "/usr/include/c++/5/ext/atomicity.h" 3
static inline _Atomic_word __exchange_and_add_single(_Atomic_word *__mem, int __val) 
# 66
{ 
# 67
_Atomic_word __result = *__mem; 
# 68
(*__mem) += __val; 
# 69
return __result; 
# 70
} 
# 73
static inline void __atomic_add_single(_Atomic_word *__mem, int __val) 
# 74
{ (*__mem) += __val; } 
# 77
__attribute((__unused__)) static inline _Atomic_word 
# 78
__exchange_and_add_dispatch(_Atomic_word *__mem, int __val) 
# 79
{ 
# 81
if (__gthread_active_p()) { 
# 82
return __exchange_and_add(__mem, __val); } else { 
# 84
return __exchange_and_add_single(__mem, __val); }  
# 88
} 
# 91
__attribute((__unused__)) static inline void 
# 92
__atomic_add_dispatch(_Atomic_word *__mem, int __val) 
# 93
{ 
# 95
if (__gthread_active_p()) { 
# 96
__atomic_add(__mem, __val); } else { 
# 98
__atomic_add_single(__mem, __val); }  
# 102
} 
# 105
}
# 42 "/usr/include/c++/5/new" 3
#pragma GCC visibility push ( default )
# 44
extern "C++" {
# 46
namespace std { 
# 54
class bad_alloc : public exception { 
# 57
public: bad_alloc() throw() { } 
# 61
virtual ~bad_alloc() throw(); 
# 64
virtual const char *what() const throw(); 
# 65
}; 
# 68
class bad_array_new_length : public bad_alloc { 
# 71
public: bad_array_new_length() throw() { } 
# 75
virtual ~bad_array_new_length() throw(); 
# 78
virtual const char *what() const throw(); 
# 79
}; 
# 82
struct nothrow_t { }; 
# 84
extern const nothrow_t nothrow; 
# 88
typedef void (*new_handler)(void); 
# 92
new_handler set_new_handler(new_handler) throw(); 
# 96
new_handler get_new_handler() noexcept; 
# 98
}
# 111 "/usr/include/c++/5/new" 3
void *operator new(std::size_t)
# 112
 __attribute((__externally_visible__)); 
# 113
void *operator new[](std::size_t)
# 114
 __attribute((__externally_visible__)); 
# 115
void operator delete(void *) noexcept
# 116
 __attribute((__externally_visible__)); 
# 117
void operator delete[](void *) noexcept
# 118
 __attribute((__externally_visible__)); 
# 119
void *operator new(std::size_t, const std::nothrow_t &) noexcept
# 120
 __attribute((__externally_visible__)); 
# 121
void *operator new[](std::size_t, const std::nothrow_t &) noexcept
# 122
 __attribute((__externally_visible__)); 
# 123
void operator delete(void *, const std::nothrow_t &) noexcept
# 124
 __attribute((__externally_visible__)); 
# 125
void operator delete[](void *, const std::nothrow_t &) noexcept
# 126
 __attribute((__externally_visible__)); 
# 129
inline void *operator new(std::size_t, void *__p) noexcept 
# 130
{ return __p; } 
# 131
inline void *operator new[](std::size_t, void *__p) noexcept 
# 132
{ return __p; } 
# 135
inline void operator delete(void *, void *) noexcept { } 
# 136
inline void operator delete[](void *, void *) noexcept { } 
# 138
}
# 140
#pragma GCC visibility pop
# 40 "/usr/include/c++/5/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 44
using std::size_t;
# 45
using std::ptrdiff_t;
# 57 "/usr/include/c++/5/ext/new_allocator.h" 3
template< class _Tp> 
# 58
class new_allocator { 
# 61
public: typedef std::size_t size_type; 
# 62
typedef std::ptrdiff_t difference_type; 
# 63
typedef _Tp *pointer; 
# 64
typedef const _Tp *const_pointer; 
# 65
typedef _Tp &reference; 
# 66
typedef const _Tp &const_reference; 
# 67
typedef _Tp value_type; 
# 69
template< class _Tp1> 
# 70
struct rebind { 
# 71
typedef __gnu_cxx::new_allocator< _Tp1>  other; }; 
# 76
typedef std::true_type propagate_on_container_move_assignment; 
# 79
new_allocator() noexcept { } 
# 81
new_allocator(const new_allocator &) noexcept { } 
# 83
template< class _Tp1> 
# 84
new_allocator(const __gnu_cxx::new_allocator< _Tp1>  &) noexcept { } 
# 86
~new_allocator() noexcept { } 
# 89
pointer address(reference __x) const noexcept 
# 90
{ return std::__addressof(__x); } 
# 93
const_pointer address(const_reference __x) const noexcept 
# 94
{ return std::__addressof(__x); } 
# 99
pointer allocate(size_type __n, const void * = 0) 
# 100
{ 
# 101
if (__n > this->max_size()) { 
# 102
std::__throw_bad_alloc(); }  
# 104
return static_cast< _Tp *>(::operator new(__n * sizeof(_Tp))); 
# 105
} 
# 109
void deallocate(pointer __p, size_type) 
# 110
{ ::operator delete(__p); } 
# 113
size_type max_size() const noexcept 
# 114
{ return ((std::size_t)(-1)) / sizeof(_Tp); } 
# 117
template< class _Up, class ..._Args> void 
# 119
construct(_Up *__p, _Args &&...__args) 
# 120
{ ::new ((void *)__p) (_Up)(std::forward< _Args> (__args)...); } 
# 122
template< class _Up> void 
# 124
destroy(_Up *__p) { (__p->~_Up()); } 
# 135 "/usr/include/c++/5/ext/new_allocator.h" 3
}; 
# 137
template< class _Tp> inline bool 
# 139
operator==(const new_allocator< _Tp>  &, const new_allocator< _Tp>  &) 
# 140
{ return true; } 
# 142
template< class _Tp> inline bool 
# 144
operator!=(const new_allocator< _Tp>  &, const new_allocator< _Tp>  &) 
# 145
{ return false; } 
# 148
}
# 36 "/usr/include/aarch64-linux-gnu/c++/5/bits/c++allocator.h" 3
namespace std { 
# 47 "/usr/include/aarch64-linux-gnu/c++/5/bits/c++allocator.h" 3
template< class _Tp> using __allocator_base = __gnu_cxx::new_allocator< _Tp> ; 
# 49
}
# 52 "/usr/include/c++/5/bits/allocator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 63
template<> class allocator< void>  { 
# 66
public: typedef size_t size_type; 
# 67
typedef ptrdiff_t difference_type; 
# 68
typedef void *pointer; 
# 69
typedef const void *const_pointer; 
# 70
typedef void value_type; 
# 72
template< class _Tp1> 
# 73
struct rebind { 
# 74
typedef std::allocator< _Tp1>  other; }; 
# 79
typedef true_type propagate_on_container_move_assignment; 
# 81
}; 
# 91 "/usr/include/c++/5/bits/allocator.h" 3
template< class _Tp> 
# 92
class allocator : public __allocator_base< _Tp>  { 
# 95
public: typedef ::std::size_t size_type; 
# 96
typedef ::std::ptrdiff_t difference_type; 
# 97
typedef _Tp *pointer; 
# 98
typedef const _Tp *const_pointer; 
# 99
typedef _Tp &reference; 
# 100
typedef const _Tp &const_reference; 
# 101
typedef _Tp value_type; 
# 103
template< class _Tp1> 
# 104
struct rebind { 
# 105
typedef ::std::allocator< _Tp1>  other; }; 
# 110
typedef ::std::true_type propagate_on_container_move_assignment; 
# 113
allocator() throw() { } 
# 115
allocator(const allocator &__a) throw() : ::std::__allocator_base< _Tp> (__a) 
# 116
{ } 
# 118
template< class _Tp1> 
# 119
allocator(const ::std::allocator< _Tp1>  &) throw() { } 
# 121
~allocator() throw() { } 
# 124
}; 
# 126
template< class _T1, class _T2> inline bool 
# 128
operator==(const allocator< _T1>  &, const allocator< _T2>  &) noexcept 
# 130
{ return true; } 
# 132
template< class _Tp> inline bool 
# 134
operator==(const allocator< _Tp>  &, const allocator< _Tp>  &) noexcept 
# 136
{ return true; } 
# 138
template< class _T1, class _T2> inline bool 
# 140
operator!=(const allocator< _T1>  &, const allocator< _T2>  &) noexcept 
# 142
{ return false; } 
# 144
template< class _Tp> inline bool 
# 146
operator!=(const allocator< _Tp>  &, const allocator< _Tp>  &) noexcept 
# 148
{ return false; } 
# 155
extern template class allocator< char> ;
# 156
extern template class allocator< wchar_t> ;
# 163
template< class _Alloc, bool  = __is_empty(_Alloc)> 
# 164
struct __alloc_swap { 
# 165
static void _S_do_it(_Alloc &, _Alloc &) noexcept { } }; 
# 167
template< class _Alloc> 
# 168
struct __alloc_swap< _Alloc, false>  { 
# 171
static void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept 
# 172
{ 
# 174
if (__one != __two) { 
# 175
swap(__one, __two); }  
# 176
} 
# 177
}; 
# 180
template< class _Alloc, bool  = __is_empty(_Alloc)> 
# 181
struct __alloc_neq { 
# 184
static bool _S_do_it(const _Alloc &, const _Alloc &) 
# 185
{ return false; } 
# 186
}; 
# 188
template< class _Alloc> 
# 189
struct __alloc_neq< _Alloc, false>  { 
# 192
static bool _S_do_it(const _Alloc &__one, const _Alloc &__two) 
# 193
{ return __one != __two; } 
# 194
}; 
# 197
template< class _Tp, bool 
# 198
 = __or_< is_copy_constructible< typename _Tp::value_type> , is_nothrow_move_constructible< typename _Tp::value_type> > ::value> 
# 200
struct __shrink_to_fit_aux { 
# 201
static bool _S_do_it(_Tp &) noexcept { return false; } }; 
# 203
template< class _Tp> 
# 204
struct __shrink_to_fit_aux< _Tp, true>  { 
# 207
static bool _S_do_it(_Tp &__c) noexcept 
# 208
{ 
# 210
try 
# 211
{ 
# 212
(_Tp(__make_move_if_noexcept_iterator((__c.begin())), __make_move_if_noexcept_iterator((__c.end())), (__c.get_allocator())).swap(__c)); 
# 215
return true; 
# 216
} 
# 217
catch (...) 
# 218
{ return false; }  
# 222
} 
# 223
}; 
# 227
}
# 36 "/usr/include/c++/5/bits/cxxabi_forced.h" 3
#pragma GCC visibility push ( default )
# 39
namespace __cxxabiv1 { 
# 48
class __forced_unwind { 
# 50
virtual ~__forced_unwind() throw(); 
# 53
virtual void __pure_dummy() = 0; 
# 54
}; 
# 55
}
# 58
#pragma GCC visibility pop
# 38 "/usr/include/c++/5/bits/ostream_insert.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 42
template< class _CharT, class _Traits> inline void 
# 44
__ostream_write(basic_ostream< _CharT, _Traits>  &__out, const _CharT *
# 45
__s, streamsize __n) 
# 46
{ 
# 47
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 48
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 50
const streamsize __put = ((__out.rdbuf())->sputn(__s, __n)); 
# 51
if (__put != __n) { 
# 52
(__out.setstate(__ios_base::badbit)); }  
# 53
} 
# 55
template< class _CharT, class _Traits> inline void 
# 57
__ostream_fill(basic_ostream< _CharT, _Traits>  &__out, streamsize __n) 
# 58
{ 
# 59
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 60
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 62
const _CharT __c = (__out.fill()); 
# 63
for (; __n > (0); --__n) 
# 64
{ 
# 65
const typename _Traits::int_type __put = ((__out.rdbuf())->sputc(__c)); 
# 66
if (_Traits::eq_int_type(__put, _Traits::eof())) 
# 67
{ 
# 68
(__out.setstate(__ios_base::badbit)); 
# 69
break; 
# 70
}  
# 71
}  
# 72
} 
# 74
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 76
__ostream_insert(basic_ostream< _CharT, _Traits>  &__out, const _CharT *
# 77
__s, streamsize __n) 
# 78
{ 
# 79
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 80
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 82
typename basic_ostream< _CharT, _Traits> ::sentry __cerb(__out); 
# 83
if (__cerb) 
# 84
{ 
# 85
try 
# 86
{ 
# 87
const streamsize __w = (__out.width()); 
# 88
if (__w > __n) 
# 89
{ 
# 90
const bool __left = ((__out.flags()) & __ios_base::adjustfield) == __ios_base::left; 
# 93
if (!__left) { 
# 94
__ostream_fill(__out, __w - __n); }  
# 95
if ((__out.good())) { 
# 96
__ostream_write(__out, __s, __n); }  
# 97
if (__left && (__out.good())) { 
# 98
__ostream_fill(__out, __w - __n); }  
# 99
} else { 
# 101
__ostream_write(__out, __s, __n); }  
# 102
(__out.width(0)); 
# 103
} 
# 104
catch (__cxxabiv1::__forced_unwind &) 
# 105
{ 
# 106
(__out._M_setstate(__ios_base::badbit)); 
# 107
throw; 
# 108
} 
# 109
catch (...) 
# 110
{ (__out._M_setstate(__ios_base::badbit)); }  
# 111
}  
# 112
return __out; 
# 113
} 
# 118
extern template basic_ostream< char>  &__ostream_insert(basic_ostream< char>  & __out, const char * __s, streamsize __n);
# 121
extern template basic_ostream< wchar_t>  &__ostream_insert(basic_ostream< wchar_t>  & __out, const wchar_t * __s, streamsize __n);
# 127
}
# 63 "/usr/include/c++/5/bits/stl_function.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 104 "/usr/include/c++/5/bits/stl_function.h" 3
template< class _Arg, class _Result> 
# 105
struct unary_function { 
# 108
typedef _Arg argument_type; 
# 111
typedef _Result result_type; 
# 112
}; 
# 117
template< class _Arg1, class _Arg2, class _Result> 
# 118
struct binary_function { 
# 121
typedef _Arg1 first_argument_type; 
# 124
typedef _Arg2 second_argument_type; 
# 127
typedef _Result result_type; 
# 128
}; 
# 166 "/usr/include/c++/5/bits/stl_function.h" 3
template< class _Tp> 
# 167
struct plus : public binary_function< _Tp, _Tp, _Tp>  { 
# 171
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 172
{ return __x + __y; } 
# 173
}; 
# 176
template< class _Tp> 
# 177
struct minus : public binary_function< _Tp, _Tp, _Tp>  { 
# 181
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 182
{ return __x - __y; } 
# 183
}; 
# 186
template< class _Tp> 
# 187
struct multiplies : public binary_function< _Tp, _Tp, _Tp>  { 
# 191
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 192
{ return __x * __y; } 
# 193
}; 
# 196
template< class _Tp> 
# 197
struct divides : public binary_function< _Tp, _Tp, _Tp>  { 
# 201
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 202
{ return __x / __y; } 
# 203
}; 
# 206
template< class _Tp> 
# 207
struct modulus : public binary_function< _Tp, _Tp, _Tp>  { 
# 211
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 212
{ return __x % __y; } 
# 213
}; 
# 216
template< class _Tp> 
# 217
struct negate : public unary_function< _Tp, _Tp>  { 
# 221
_Tp operator()(const _Tp &__x) const 
# 222
{ return -__x; } 
# 223
}; 
# 351 "/usr/include/c++/5/bits/stl_function.h" 3
template< class _Tp> 
# 352
struct equal_to : public binary_function< _Tp, _Tp, bool>  { 
# 356
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 357
{ return __x == __y; } 
# 358
}; 
# 361
template< class _Tp> 
# 362
struct not_equal_to : public binary_function< _Tp, _Tp, bool>  { 
# 366
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 367
{ return __x != __y; } 
# 368
}; 
# 371
template< class _Tp> 
# 372
struct greater : public binary_function< _Tp, _Tp, bool>  { 
# 376
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 377
{ return __x > __y; } 
# 378
}; 
# 381
template< class _Tp> 
# 382
struct less : public binary_function< _Tp, _Tp, bool>  { 
# 386
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 387
{ return __x < __y; } 
# 388
}; 
# 391
template< class _Tp> 
# 392
struct greater_equal : public binary_function< _Tp, _Tp, bool>  { 
# 396
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 397
{ return __x >= __y; } 
# 398
}; 
# 401
template< class _Tp> 
# 402
struct less_equal : public binary_function< _Tp, _Tp, bool>  { 
# 406
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 407
{ return __x <= __y; } 
# 408
}; 
# 524 "/usr/include/c++/5/bits/stl_function.h" 3
template< class _Tp> 
# 525
struct logical_and : public binary_function< _Tp, _Tp, bool>  { 
# 529
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 530
{ return __x && __y; } 
# 531
}; 
# 534
template< class _Tp> 
# 535
struct logical_or : public binary_function< _Tp, _Tp, bool>  { 
# 539
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 540
{ return __x || __y; } 
# 541
}; 
# 544
template< class _Tp> 
# 545
struct logical_not : public unary_function< _Tp, bool>  { 
# 549
bool operator()(const _Tp &__x) const 
# 550
{ return !__x; } 
# 551
}; 
# 617 "/usr/include/c++/5/bits/stl_function.h" 3
template< class _Tp> 
# 618
struct bit_and : public binary_function< _Tp, _Tp, _Tp>  { 
# 622
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 623
{ return __x & __y; } 
# 624
}; 
# 626
template< class _Tp> 
# 627
struct bit_or : public binary_function< _Tp, _Tp, _Tp>  { 
# 631
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 632
{ return __x | __y; } 
# 633
}; 
# 635
template< class _Tp> 
# 636
struct bit_xor : public binary_function< _Tp, _Tp, _Tp>  { 
# 640
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 641
{ return __x ^ __y; } 
# 642
}; 
# 644
template< class _Tp> 
# 645
struct bit_not : public unary_function< _Tp, _Tp>  { 
# 649
_Tp operator()(const _Tp &__x) const 
# 650
{ return ~__x; } 
# 651
}; 
# 741 "/usr/include/c++/5/bits/stl_function.h" 3
template< class _Predicate> 
# 742
class unary_negate : public unary_function< typename _Predicate::argument_type, bool>  { 
# 746
protected: _Predicate _M_pred; 
# 751
public: explicit unary_negate(const _Predicate &__x) : _M_pred(__x) { } 
# 755
bool operator()(const typename _Predicate::argument_type &__x) const 
# 756
{ return !(_M_pred)(__x); } 
# 757
}; 
# 760
template< class _Predicate> inline unary_negate< _Predicate>  
# 763
not1(const _Predicate &__pred) 
# 764
{ return ((unary_negate< _Predicate> )(__pred)); } 
# 767
template< class _Predicate> 
# 768
class binary_negate : public binary_function< typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool>  { 
# 773
protected: _Predicate _M_pred; 
# 778
public: explicit binary_negate(const _Predicate &__x) : _M_pred(__x) { } 
# 782
bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &
# 783
__y) const 
# 784
{ return !(_M_pred)(__x, __y); } 
# 785
}; 
# 788
template< class _Predicate> inline binary_negate< _Predicate>  
# 791
not2(const _Predicate &__pred) 
# 792
{ return ((binary_negate< _Predicate> )(__pred)); } 
# 818 "/usr/include/c++/5/bits/stl_function.h" 3
template< class _Arg, class _Result> 
# 819
class pointer_to_unary_function : public unary_function< _Arg, _Result>  { 
# 822
protected: _Result (*_M_ptr)(_Arg); 
# 825
public: pointer_to_unary_function() { } 
# 828
explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) 
# 829
{ } 
# 832
_Result operator()(_Arg __x) const 
# 833
{ return (_M_ptr)(__x); } 
# 834
}; 
# 837
template< class _Arg, class _Result> inline pointer_to_unary_function< _Arg, _Result>  
# 839
ptr_fun(_Result (*__x)(_Arg)) 
# 840
{ return ((pointer_to_unary_function< _Arg, _Result> )(__x)); } 
# 843
template< class _Arg1, class _Arg2, class _Result> 
# 844
class pointer_to_binary_function : public binary_function< _Arg1, _Arg2, _Result>  { 
# 848
protected: _Result (*_M_ptr)(_Arg1, _Arg2); 
# 851
public: pointer_to_binary_function() { } 
# 854
explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2)) : _M_ptr(__x) 
# 855
{ } 
# 858
_Result operator()(_Arg1 __x, _Arg2 __y) const 
# 859
{ return (_M_ptr)(__x, __y); } 
# 860
}; 
# 863
template< class _Arg1, class _Arg2, class _Result> inline pointer_to_binary_function< _Arg1, _Arg2, _Result>  
# 865
ptr_fun(_Result (*__x)(_Arg1, _Arg2)) 
# 866
{ return ((pointer_to_binary_function< _Arg1, _Arg2, _Result> )(__x)); } 
# 869
template< class _Tp> 
# 870
struct _Identity : public unary_function< _Tp, _Tp>  { 
# 874
_Tp &operator()(_Tp &__x) const 
# 875
{ return __x; } 
# 878
const _Tp &operator()(const _Tp &__x) const 
# 879
{ return __x; } 
# 880
}; 
# 882
template< class _Pair> 
# 883
struct _Select1st : public unary_function< _Pair, typename _Pair::first_type>  { 
# 887
typename _Pair::first_type &operator()(_Pair &__x) const 
# 888
{ return __x.first; } 
# 891
const typename _Pair::first_type &operator()(const _Pair &__x) const 
# 892
{ return __x.first; } 
# 895
template< class _Pair2> typename _Pair2::first_type &
# 897
operator()(_Pair2 &__x) const 
# 898
{ return __x.first; } 
# 900
template< class _Pair2> const typename _Pair2::first_type &
# 902
operator()(const _Pair2 &__x) const 
# 903
{ return __x.first; } 
# 905
}; 
# 907
template< class _Pair> 
# 908
struct _Select2nd : public unary_function< _Pair, typename _Pair::second_type>  { 
# 912
typename _Pair::second_type &operator()(_Pair &__x) const 
# 913
{ return __x.second; } 
# 916
const typename _Pair::second_type &operator()(const _Pair &__x) const 
# 917
{ return __x.second; } 
# 918
}; 
# 938 "/usr/include/c++/5/bits/stl_function.h" 3
template< class _Ret, class _Tp> 
# 939
class mem_fun_t : public unary_function< _Tp *, _Ret>  { 
# 943
public: explicit mem_fun_t(_Ret (_Tp::*__pf)(void)) : _M_f(__pf) 
# 944
{ } 
# 947
_Ret operator()(_Tp *__p) const 
# 948
{ return (__p->*(_M_f))(); } 
# 951
private: _Ret (_Tp::*_M_f)(void); 
# 952
}; 
# 956
template< class _Ret, class _Tp> 
# 957
class const_mem_fun_t : public unary_function< const _Tp *, _Ret>  { 
# 961
public: explicit const_mem_fun_t(_Ret (_Tp::*__pf)(void) const) : _M_f(__pf) 
# 962
{ } 
# 965
_Ret operator()(const _Tp *__p) const 
# 966
{ return (__p->*(_M_f))(); } 
# 969
private: _Ret (_Tp::*_M_f)(void) const; 
# 970
}; 
# 974
template< class _Ret, class _Tp> 
# 975
class mem_fun_ref_t : public unary_function< _Tp, _Ret>  { 
# 979
public: explicit mem_fun_ref_t(_Ret (_Tp::*__pf)(void)) : _M_f(__pf) 
# 980
{ } 
# 983
_Ret operator()(_Tp &__r) const 
# 984
{ return (__r.*(_M_f))(); } 
# 987
private: _Ret (_Tp::*_M_f)(void); 
# 988
}; 
# 992
template< class _Ret, class _Tp> 
# 993
class const_mem_fun_ref_t : public unary_function< _Tp, _Ret>  { 
# 997
public: explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)(void) const) : _M_f(__pf) 
# 998
{ } 
# 1001
_Ret operator()(const _Tp &__r) const 
# 1002
{ return (__r.*(_M_f))(); } 
# 1005
private: _Ret (_Tp::*_M_f)(void) const; 
# 1006
}; 
# 1010
template< class _Ret, class _Tp, class _Arg> 
# 1011
class mem_fun1_t : public binary_function< _Tp *, _Arg, _Ret>  { 
# 1015
public: explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) 
# 1016
{ } 
# 1019
_Ret operator()(_Tp *__p, _Arg __x) const 
# 1020
{ return (__p->*(_M_f))(__x); } 
# 1023
private: _Ret (_Tp::*_M_f)(_Arg); 
# 1024
}; 
# 1028
template< class _Ret, class _Tp, class _Arg> 
# 1029
class const_mem_fun1_t : public binary_function< const _Tp *, _Arg, _Ret>  { 
# 1033
public: explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) 
# 1034
{ } 
# 1037
_Ret operator()(const _Tp *__p, _Arg __x) const 
# 1038
{ return (__p->*(_M_f))(__x); } 
# 1041
private: _Ret (_Tp::*_M_f)(_Arg) const; 
# 1042
}; 
# 1046
template< class _Ret, class _Tp, class _Arg> 
# 1047
class mem_fun1_ref_t : public binary_function< _Tp, _Arg, _Ret>  { 
# 1051
public: explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) 
# 1052
{ } 
# 1055
_Ret operator()(_Tp &__r, _Arg __x) const 
# 1056
{ return (__r.*(_M_f))(__x); } 
# 1059
private: _Ret (_Tp::*_M_f)(_Arg); 
# 1060
}; 
# 1064
template< class _Ret, class _Tp, class _Arg> 
# 1065
class const_mem_fun1_ref_t : public binary_function< _Tp, _Arg, _Ret>  { 
# 1069
public: explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) 
# 1070
{ } 
# 1073
_Ret operator()(const _Tp &__r, _Arg __x) const 
# 1074
{ return (__r.*(_M_f))(__x); } 
# 1077
private: _Ret (_Tp::*_M_f)(_Arg) const; 
# 1078
}; 
# 1082
template< class _Ret, class _Tp> inline mem_fun_t< _Ret, _Tp>  
# 1084
mem_fun(_Ret (_Tp::*__f)(void)) 
# 1085
{ return ((mem_fun_t< _Ret, _Tp> )(__f)); } 
# 1087
template< class _Ret, class _Tp> inline const_mem_fun_t< _Ret, _Tp>  
# 1089
mem_fun(_Ret (_Tp::*__f)(void) const) 
# 1090
{ return ((const_mem_fun_t< _Ret, _Tp> )(__f)); } 
# 1092
template< class _Ret, class _Tp> inline mem_fun_ref_t< _Ret, _Tp>  
# 1094
mem_fun_ref(_Ret (_Tp::*__f)(void)) 
# 1095
{ return ((mem_fun_ref_t< _Ret, _Tp> )(__f)); } 
# 1097
template< class _Ret, class _Tp> inline const_mem_fun_ref_t< _Ret, _Tp>  
# 1099
mem_fun_ref(_Ret (_Tp::*__f)(void) const) 
# 1100
{ return ((const_mem_fun_ref_t< _Ret, _Tp> )(__f)); } 
# 1102
template< class _Ret, class _Tp, class _Arg> inline mem_fun1_t< _Ret, _Tp, _Arg>  
# 1104
mem_fun(_Ret (_Tp::*__f)(_Arg)) 
# 1105
{ return ((mem_fun1_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1107
template< class _Ret, class _Tp, class _Arg> inline const_mem_fun1_t< _Ret, _Tp, _Arg>  
# 1109
mem_fun(_Ret (_Tp::*__f)(_Arg) const) 
# 1110
{ return ((const_mem_fun1_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1112
template< class _Ret, class _Tp, class _Arg> inline mem_fun1_ref_t< _Ret, _Tp, _Arg>  
# 1114
mem_fun_ref(_Ret (_Tp::*__f)(_Arg)) 
# 1115
{ return ((mem_fun1_ref_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1117
template< class _Ret, class _Tp, class _Arg> inline const_mem_fun1_ref_t< _Ret, _Tp, _Arg>  
# 1119
mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const) 
# 1120
{ return ((const_mem_fun1_ref_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1125
}
# 60 "/usr/include/c++/5/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 63
namespace std __attribute((__visibility__("default"))) { 
# 107 "/usr/include/c++/5/backward/binders.h" 3
template< class _Operation> 
# 108
class binder1st : public unary_function< typename _Operation::second_argument_type, typename _Operation::result_type>  { 
# 113
protected: _Operation op; 
# 114
typename _Operation::first_argument_type value; 
# 117
public: binder1st(const _Operation &__x, const typename _Operation::first_argument_type &
# 118
__y) : op(__x), value(__y) 
# 119
{ } 
# 122
typename _Operation::result_type operator()(const typename _Operation::second_argument_type &__x) const 
# 123
{ return (op)(value, __x); } 
# 128
typename _Operation::result_type operator()(typename _Operation::second_argument_type &__x) const 
# 129
{ return (op)(value, __x); } 
# 130
} __attribute((__deprecated__)); 
# 133
template< class _Operation, class _Tp> inline binder1st< _Operation>  
# 135
bind1st(const _Operation &__fn, const _Tp &__x) 
# 136
{ 
# 137
typedef typename _Operation::first_argument_type _Arg1_type; 
# 138
return binder1st< _Operation> (__fn, (_Arg1_type)__x); 
# 139
} 
# 142
template< class _Operation> 
# 143
class binder2nd : public unary_function< typename _Operation::first_argument_type, typename _Operation::result_type>  { 
# 148
protected: _Operation op; 
# 149
typename _Operation::second_argument_type value; 
# 152
public: binder2nd(const _Operation &__x, const typename _Operation::second_argument_type &
# 153
__y) : op(__x), value(__y) 
# 154
{ } 
# 157
typename _Operation::result_type operator()(const typename _Operation::first_argument_type &__x) const 
# 158
{ return (op)(__x, value); } 
# 163
typename _Operation::result_type operator()(typename _Operation::first_argument_type &__x) const 
# 164
{ return (op)(__x, value); } 
# 165
} __attribute((__deprecated__)); 
# 168
template< class _Operation, class _Tp> inline binder2nd< _Operation>  
# 170
bind2nd(const _Operation &__fn, const _Tp &__x) 
# 171
{ 
# 172
typedef typename _Operation::second_argument_type _Arg2_type; 
# 173
return binder2nd< _Operation> (__fn, (_Arg2_type)__x); 
# 174
} 
# 178
}
# 180
#pragma GCC diagnostic pop
# 39 "/usr/include/c++/5/initializer_list" 3
#pragma GCC visibility push ( default )
# 43
namespace std { 
# 46
template< class _E> 
# 47
class initializer_list { 
# 50
public: typedef _E value_type; 
# 51
typedef const _E &reference; 
# 52
typedef const _E &const_reference; 
# 53
typedef size_t size_type; 
# 54
typedef const _E *iterator; 
# 55
typedef const _E *const_iterator; 
# 58
private: iterator _M_array; 
# 59
size_type _M_len; 
# 62
constexpr initializer_list(const_iterator __a, size_type __l) : _M_array(__a), _M_len(__l) 
# 63
{ } 
# 66
public: constexpr initializer_list() noexcept : _M_array((0)), _M_len((0)) 
# 67
{ } 
# 71
constexpr size_type size() const noexcept { return _M_len; } 
# 75
constexpr const_iterator begin() const noexcept { return _M_array; } 
# 79
constexpr const_iterator end() const noexcept { return begin() + size(); } 
# 80
}; 
# 87
template< class _Tp> constexpr const _Tp *
# 89
begin(initializer_list< _Tp>  __ils) noexcept 
# 90
{ return (__ils.begin()); } 
# 97
template< class _Tp> constexpr const _Tp *
# 99
end(initializer_list< _Tp>  __ils) noexcept 
# 100
{ return (__ils.end()); } 
# 101
}
# 103
#pragma GCC visibility pop
# 37 "/usr/include/c++/5/bits/range_access.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 46
template< class _Container> inline auto 
# 48
begin(_Container &__cont)->__decltype(((__cont.begin()))) 
# 49
{ return (__cont.begin()); } 
# 56
template< class _Container> inline auto 
# 58
begin(const _Container &__cont)->__decltype(((__cont.begin()))) 
# 59
{ return (__cont.begin()); } 
# 66
template< class _Container> inline auto 
# 68
end(_Container &__cont)->__decltype(((__cont.end()))) 
# 69
{ return (__cont.end()); } 
# 76
template< class _Container> inline auto 
# 78
end(const _Container &__cont)->__decltype(((__cont.end()))) 
# 79
{ return (__cont.end()); } 
# 85
template< class _Tp, size_t _Nm> inline _Tp *
# 87
begin(_Tp (&__arr)[_Nm]) 
# 88
{ return __arr; } 
# 95
template< class _Tp, size_t _Nm> inline _Tp *
# 97
end(_Tp (&__arr)[_Nm]) 
# 98
{ return (__arr) + _Nm; } 
# 234 "/usr/include/c++/5/bits/range_access.h" 3
}
# 39 "/usr/include/c++/5/bits/alloc_traits.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _Alloc, class _Tp> 
# 44
class __alloctr_rebind_helper { 
# 46
template< class _Alloc2, class _Tp2> static constexpr true_type _S_chk(typename _Alloc2::template rebind< _Tp2> ::other *); 
# 50
template< class , class > static constexpr false_type _S_chk(...); 
# 55
public: using __type = __decltype((_S_chk< _Alloc, _Tp> (nullptr))); 
# 56
}; 
# 58
template< class _Alloc, class _Tp, bool 
# 59
 = __alloctr_rebind_helper< _Alloc, _Tp> ::__type::value> struct __alloctr_rebind; 
# 62
template< class _Alloc, class _Tp> 
# 63
struct __alloctr_rebind< _Alloc, _Tp, true>  { 
# 65
typedef typename _Alloc::template rebind< _Tp> ::other __type; 
# 66
}; 
# 68
template< template< class , class ...>  class _Alloc, class _Tp, class 
# 69
_Up, class ..._Args> 
# 70
struct __alloctr_rebind< _Alloc< _Up, _Args...> , _Tp, false>  { 
# 72
typedef _Alloc< _Tp, _Args...>  __type; 
# 73
}; 
# 75
template< class _Alloc, class _Tp> using __alloc_rebind = typename __alloctr_rebind< _Alloc, _Tp> ::__type; 
# 82
template< class _Alloc> 
# 83
struct allocator_traits { 
# 86
typedef _Alloc allocator_type; 
# 88
typedef typename _Alloc::value_type value_type; 
# 98 "/usr/include/c++/5/bits/alloc_traits.h" 3
private: template< class _Tp> static typename _Tp::pointer _S_pointer_helper(_Tp *); static value_type *_S_pointer_helper(...); typedef __decltype((_S_pointer_helper((_Alloc *)0))) __pointer; 
# 105
public: typedef __pointer pointer; 
# 107
private: template< class _Tp> static typename _Tp::const_pointer _S_const_pointer_helper(_Tp *); static typename pointer_traits< __pointer> ::template rebind< const typename _Alloc::value_type>  _S_const_pointer_helper(...); typedef __decltype((_S_const_pointer_helper((_Alloc *)0))) __const_pointer; 
# 116 "/usr/include/c++/5/bits/alloc_traits.h" 3
public: typedef __const_pointer const_pointer; 
# 118
private: template< class _Tp> static typename _Tp::void_pointer _S_void_pointer_helper(_Tp *); static typename pointer_traits< __pointer> ::template rebind< void>  _S_void_pointer_helper(...); typedef __decltype((_S_void_pointer_helper((_Alloc *)0))) __void_pointer; 
# 127 "/usr/include/c++/5/bits/alloc_traits.h" 3
public: typedef __void_pointer void_pointer; 
# 129
private: template< class _Tp> static typename _Tp::const_void_pointer _S_const_void_pointer_helper(_Tp *); static typename pointer_traits< __pointer> ::template rebind< const void>  _S_const_void_pointer_helper(...); typedef __decltype((_S_const_void_pointer_helper((_Alloc *)0))) __const_void_pointer; 
# 138 "/usr/include/c++/5/bits/alloc_traits.h" 3
public: typedef __const_void_pointer const_void_pointer; 
# 140
private: template< class _Tp> static typename _Tp::difference_type _S_difference_type_helper(_Tp *); static typename pointer_traits< __pointer> ::difference_type _S_difference_type_helper(...); typedef __decltype((_S_difference_type_helper((_Alloc *)0))) __difference_type; 
# 149 "/usr/include/c++/5/bits/alloc_traits.h" 3
public: typedef __difference_type difference_type; 
# 151
private: template< class _Tp> static typename _Tp::size_type _S_size_type_helper(_Tp *); static typename make_unsigned< __difference_type> ::type _S_size_type_helper(...); typedef __decltype((_S_size_type_helper((_Alloc *)0))) __size_type; 
# 160 "/usr/include/c++/5/bits/alloc_traits.h" 3
public: typedef __size_type size_type; 
# 162
private: template< class _Tp> static typename _Tp::propagate_on_container_copy_assignment _S_propagate_on_container_copy_assignment_helper(_Tp *); static false_type _S_propagate_on_container_copy_assignment_helper(...); typedef __decltype((_S_propagate_on_container_copy_assignment_helper((_Alloc *)0))) __propagate_on_container_copy_assignment; 
# 172 "/usr/include/c++/5/bits/alloc_traits.h" 3
public: typedef __propagate_on_container_copy_assignment propagate_on_container_copy_assignment; 
# 174
private: template< class _Tp> static typename _Tp::propagate_on_container_move_assignment _S_propagate_on_container_move_assignment_helper(_Tp *); static false_type _S_propagate_on_container_move_assignment_helper(...); typedef __decltype((_S_propagate_on_container_move_assignment_helper((_Alloc *)0))) __propagate_on_container_move_assignment; 
# 184 "/usr/include/c++/5/bits/alloc_traits.h" 3
public: typedef __propagate_on_container_move_assignment propagate_on_container_move_assignment; 
# 186
private: template< class _Tp> static typename _Tp::propagate_on_container_swap _S_propagate_on_container_swap_helper(_Tp *); static false_type _S_propagate_on_container_swap_helper(...); typedef __decltype((_S_propagate_on_container_swap_helper((_Alloc *)0))) __propagate_on_container_swap; 
# 195 "/usr/include/c++/5/bits/alloc_traits.h" 3
public: typedef __propagate_on_container_swap propagate_on_container_swap; 
# 199
template< class _Tp> using rebind_alloc = typename __alloctr_rebind< _Alloc, _Tp> ::__type; 
# 201
template< class _Tp> using rebind_traits = std::allocator_traits< rebind_alloc< _Tp> > ; 
# 206
private: 
# 205
template< class _Alloc2> 
# 206
struct __allocate_helper { 
# 208
template< class _Alloc3, class 
# 209
 = __decltype(((std::declval< _Alloc3 *> ()->allocate(std::declval< size_type> (), std::declval< const_void_pointer> ()))))> static true_type 
# 208
__test(int); 
# 214
template< class > static false_type __test(...); 
# 217
using type = __decltype((__test< _Alloc> (0))); 
# 218
}; 
# 220
template< class _Alloc2> using __has_allocate = typename __allocate_helper< _Alloc2> ::type; 
# 223
template< class _Alloc2, class 
# 224
 = _Require< __has_allocate< _Alloc2> > > static pointer 
# 226
_S_allocate(_Alloc2 &__a, size_type __n, const_void_pointer __hint) 
# 227
{ return (__a.allocate(__n, __hint)); } 
# 229
template< class _Alloc2, class _UnusedHint, class 
# 230
 = _Require< __not_< __has_allocate< _Alloc2> > > > static pointer 
# 232
_S_allocate(_Alloc2 &__a, size_type __n, _UnusedHint) 
# 233
{ return (__a.allocate(__n)); } 
# 235
template< class _Tp, class ..._Args> 
# 236
struct __construct_helper { 
# 238
template< class _Alloc2, class 
# 239
 = __decltype(((std::declval< _Alloc2 *> ()->construct(std::declval< _Tp *> (), std::declval< _Args> ()...))))> static true_type 
# 238
__test(int); 
# 243
template< class > static false_type __test(...); 
# 246
using type = __decltype((__test< _Alloc> (0))); 
# 247
}; 
# 249
template< class _Tp, class ..._Args> using __has_construct = typename __construct_helper< _Tp, _Args...> ::type; 
# 253
template< class _Tp, class ..._Args> static _Require< __has_construct< _Tp, _Args...> >  
# 255
_S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) 
# 256
{ (__a.construct(__p, std::forward< _Args> (__args)...)); } 
# 258
template< class _Tp, class ..._Args> static _Require< __and_< __not_< __has_construct< _Tp, _Args...> > , is_constructible< _Tp, _Args...> > >  
# 262
_S_construct(_Alloc &, _Tp *__p, _Args &&...__args) 
# 263
{ ::new ((void *)__p) (_Tp)(std::forward< _Args> (__args)...); } 
# 265
template< class _Tp> 
# 266
struct __destroy_helper { 
# 268
template< class _Alloc2, class 
# 269
 = __decltype(((std::declval< _Alloc2 *> ()->destroy(std::declval< _Tp *> ()))))> static true_type 
# 268
__test(int); 
# 273
template< class > static false_type __test(...); 
# 276
using type = __decltype((__test< _Alloc> (0))); 
# 277
}; 
# 279
template< class _Tp> using __has_destroy = typename __destroy_helper< _Tp> ::type; 
# 282
template< class _Tp> static _Require< __has_destroy< _Tp> >  
# 284
_S_destroy(_Alloc &__a, _Tp *__p) 
# 285
{ (__a.destroy(__p)); } 
# 287
template< class _Tp> static _Require< __not_< __has_destroy< _Tp> > >  
# 289
_S_destroy(_Alloc &, _Tp *__p) 
# 290
{ (__p->~_Tp()); } 
# 292
template< class _Alloc2> 
# 293
struct __maxsize_helper { 
# 295
template< class _Alloc3, class 
# 296
 = __decltype(((std::declval< _Alloc3 *> ()->max_size())))> static true_type 
# 295
__test(int); 
# 299
template< class > static false_type __test(...); 
# 302
using type = __decltype((__test< _Alloc2> (0))); 
# 303
}; 
# 305
template< class _Alloc2> using __has_max_size = typename __maxsize_helper< _Alloc2> ::type; 
# 308
template< class _Alloc2, class 
# 309
 = _Require< __has_max_size< _Alloc2> > > static size_type 
# 311
_S_max_size(_Alloc2 &__a, int) 
# 312
{ return (__a.max_size()); } 
# 314
template< class _Alloc2, class 
# 315
 = _Require< __not_< __has_max_size< _Alloc2> > > > static size_type 
# 317
_S_max_size(_Alloc2 &, ...) 
# 318
{ return __gnu_cxx::__numeric_traits< __size_type> ::__max; } 
# 320
template< class _Alloc2> 
# 321
struct __select_helper { 
# 323
template< class _Alloc3, class 
# 324
 = __decltype(((std::declval< _Alloc3 *> ()->select_on_container_copy_construction())))> static true_type 
# 323
__test(int); 
# 328
template< class > static false_type __test(...); 
# 331
using type = __decltype((__test< _Alloc2> (0))); 
# 332
}; 
# 334
template< class _Alloc2> using __has_soccc = typename __select_helper< _Alloc2> ::type; 
# 337
template< class _Alloc2, class 
# 338
 = _Require< __has_soccc< _Alloc2> > > static _Alloc2 
# 340
_S_select(_Alloc2 &__a, int) 
# 341
{ return (__a.select_on_container_copy_construction()); } 
# 343
template< class _Alloc2, class 
# 344
 = _Require< __not_< __has_soccc< _Alloc2> > > > static _Alloc2 
# 346
_S_select(_Alloc2 &__a, ...) 
# 347
{ return __a; } 
# 359 "/usr/include/c++/5/bits/alloc_traits.h" 3
public: static pointer allocate(_Alloc &__a, size_type __n) 
# 360
{ return (__a.allocate(__n)); } 
# 374 "/usr/include/c++/5/bits/alloc_traits.h" 3
static pointer allocate(_Alloc &__a, size_type __n, const_void_pointer __hint) 
# 375
{ return _S_allocate(__a, __n, __hint); } 
# 385 "/usr/include/c++/5/bits/alloc_traits.h" 3
static void deallocate(_Alloc &__a, pointer __p, size_type __n) 
# 386
{ (__a.deallocate(__p, __n)); } 
# 399 "/usr/include/c++/5/bits/alloc_traits.h" 3
template< class _Tp, class ..._Args> static auto 
# 400
construct(_Alloc &__a, _Tp *__p, _Args &&...__args)->__decltype((_S_construct(__a, __p, std::forward< _Args> (__args)...))) 
# 402
{ _S_construct(__a, __p, std::forward< _Args> (__args)...); } 
# 412 "/usr/include/c++/5/bits/alloc_traits.h" 3
template< class _Tp> static void 
# 413
destroy(_Alloc &__a, _Tp *__p) 
# 414
{ _S_destroy(__a, __p); } 
# 424 "/usr/include/c++/5/bits/alloc_traits.h" 3
static size_type max_size(const _Alloc &__a) noexcept 
# 425
{ return _S_max_size(__a, 0); } 
# 436 "/usr/include/c++/5/bits/alloc_traits.h" 3
static _Alloc select_on_container_copy_construction(const _Alloc &__rhs) 
# 437
{ return _S_select(__rhs, 0); } 
# 438
}; 
# 441
template< class _Tp> 
# 442
struct allocator_traits< allocator< _Tp> >  { 
# 445
using allocator_type = allocator< _Tp> ; 
# 447
using value_type = _Tp; 
# 450
using pointer = _Tp *; 
# 453
using const_pointer = const _Tp *; 
# 456
using void_pointer = void *; 
# 459
using const_void_pointer = const void *; 
# 462
using difference_type = ptrdiff_t; 
# 465
using size_type = size_t; 
# 468
using propagate_on_container_copy_assignment = false_type; 
# 471
using propagate_on_container_move_assignment = true_type; 
# 474
using propagate_on_container_swap = false_type; 
# 476
template< class _Up> using rebind_alloc = allocator< _Up> ; 
# 479
template< class _Up> using rebind_traits = std::allocator_traits< allocator< _Up> > ; 
# 490 "/usr/include/c++/5/bits/alloc_traits.h" 3
static pointer allocate(allocator_type &__a, size_type __n) 
# 491
{ return (__a.allocate(__n)); } 
# 504 "/usr/include/c++/5/bits/alloc_traits.h" 3
static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) 
# 505
{ return (__a.allocate(__n, __hint)); } 
# 516 "/usr/include/c++/5/bits/alloc_traits.h" 3
static void deallocate(allocator_type &__a, pointer __p, size_type __n) 
# 517
{ (__a.deallocate(__p, __n)); } 
# 527 "/usr/include/c++/5/bits/alloc_traits.h" 3
template< class _Up, class ..._Args> static void 
# 529
construct(allocator_type &__a, _Up *__p, _Args &&...__args) 
# 530
{ (__a.construct(__p, std::forward< _Args> (__args)...)); } 
# 539 "/usr/include/c++/5/bits/alloc_traits.h" 3
template< class _Up> static void 
# 541
destroy(allocator_type &__a, _Up *__p) 
# 542
{ (__a.destroy(__p)); } 
# 550
static size_type max_size(const allocator_type &__a) noexcept 
# 551
{ return (__a.max_size()); } 
# 559
static allocator_type select_on_container_copy_construction(const allocator_type &__rhs) 
# 560
{ return __rhs; } 
# 561
}; 
# 564
template< class _Alloc> inline void 
# 566
__do_alloc_on_copy(_Alloc &__one, const _Alloc &__two, true_type) 
# 567
{ __one = __two; } 
# 569
template< class _Alloc> inline void 
# 571
__do_alloc_on_copy(_Alloc &, const _Alloc &, false_type) 
# 572
{ } 
# 574
template< class _Alloc> inline void 
# 575
__alloc_on_copy(_Alloc &__one, const _Alloc &__two) 
# 576
{ 
# 577
typedef allocator_traits< _Alloc>  __traits; 
# 578
typedef typename allocator_traits< _Alloc> ::propagate_on_container_copy_assignment __pocca; 
# 579
__do_alloc_on_copy(__one, __two, __pocca()); 
# 580
} 
# 582
template< class _Alloc> inline _Alloc 
# 583
__alloc_on_copy(const _Alloc &__a) 
# 584
{ 
# 585
typedef allocator_traits< _Alloc>  __traits; 
# 586
return __traits::select_on_container_copy_construction(__a); 
# 587
} 
# 589
template< class _Alloc> inline void 
# 590
__do_alloc_on_move(_Alloc &__one, _Alloc &__two, true_type) 
# 591
{ __one = std::move(__two); } 
# 593
template< class _Alloc> inline void 
# 594
__do_alloc_on_move(_Alloc &, _Alloc &, false_type) 
# 595
{ } 
# 597
template< class _Alloc> inline void 
# 598
__alloc_on_move(_Alloc &__one, _Alloc &__two) 
# 599
{ 
# 600
typedef allocator_traits< _Alloc>  __traits; 
# 601
typedef typename allocator_traits< _Alloc> ::propagate_on_container_move_assignment __pocma; 
# 602
__do_alloc_on_move(__one, __two, __pocma()); 
# 603
} 
# 605
template< class _Alloc> inline void 
# 606
__do_alloc_on_swap(_Alloc &__one, _Alloc &__two, true_type) 
# 607
{ 
# 608
using std::swap;
# 609
swap(__one, __two); 
# 610
} 
# 612
template< class _Alloc> inline void 
# 613
__do_alloc_on_swap(_Alloc &, _Alloc &, false_type) 
# 614
{ } 
# 616
template< class _Alloc> inline void 
# 617
__alloc_on_swap(_Alloc &__one, _Alloc &__two) 
# 618
{ 
# 619
typedef allocator_traits< _Alloc>  __traits; 
# 620
typedef typename allocator_traits< _Alloc> ::propagate_on_container_swap __pocs; 
# 621
__do_alloc_on_swap(__one, __two, __pocs()); 
# 622
} 
# 624
template< class _Alloc> 
# 625
class __is_copy_insertable_impl { 
# 627
typedef allocator_traits< _Alloc>  _Traits; 
# 629
template< class _Up, class 
# 630
 = __decltype((_Traits::construct(std::declval< _Alloc &> (), std::declval< _Up *> (), std::declval< const _Up &> ())))> static true_type 
# 629
_M_select(int); 
# 636
template< class _Up> static false_type _M_select(...); 
# 641
public: typedef __decltype((_M_select< typename _Alloc::value_type> (0))) type; 
# 642
}; 
# 645
template< class _Alloc> 
# 646
struct __is_copy_insertable : public __is_copy_insertable_impl< _Alloc> ::type { 
# 648
}; 
# 651
template< class _Tp> 
# 652
struct __is_copy_insertable< allocator< _Tp> >  : public is_copy_constructible< _Tp>  { 
# 654
}; 
# 657
}
# 41 "/usr/include/c++/5/ext/alloc_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 46
template< class _Alloc> 
# 47
struct __allocator_always_compares_equal : public std::false_type { }; 
# 49
template< class _Tp> 
# 50
struct __allocator_always_compares_equal< std::allocator< _Tp> >  : public std::true_type { 
# 51
}; 
# 53
template< class , class > struct array_allocator; 
# 55
template< class _Tp, class _Array> 
# 56
struct __allocator_always_compares_equal< array_allocator< _Tp, _Array> >  : public std::true_type { 
# 57
}; 
# 59
template< class > struct bitmap_allocator; 
# 61
template< class _Tp> 
# 62
struct __allocator_always_compares_equal< bitmap_allocator< _Tp> >  : public std::true_type { 
# 63
}; 
# 65
template< class > struct malloc_allocator; 
# 67
template< class _Tp> 
# 68
struct __allocator_always_compares_equal< malloc_allocator< _Tp> >  : public std::true_type { 
# 69
}; 
# 71
template< class > struct mt_allocator; 
# 73
template< class _Tp> 
# 74
struct __allocator_always_compares_equal< mt_allocator< _Tp> >  : public std::true_type { 
# 75
}; 
# 77
template< class > class new_allocator; 
# 79
template< class _Tp> 
# 80
struct __allocator_always_compares_equal< new_allocator< _Tp> >  : public std::true_type { 
# 81
}; 
# 83
template< class > struct pool_allocator; 
# 85
template< class _Tp> 
# 86
struct __allocator_always_compares_equal< pool_allocator< _Tp> >  : public std::true_type { 
# 87
}; 
# 94
template< class _Alloc> 
# 95
struct __alloc_traits : public std::allocator_traits< _Alloc>  { 
# 100
typedef _Alloc allocator_type; 
# 102
typedef ::std::allocator_traits< _Alloc>  _Base_type; 
# 103
typedef typename ::std::allocator_traits< _Alloc> ::value_type value_type; 
# 104
typedef typename ::std::allocator_traits< _Alloc> ::pointer pointer; 
# 105
typedef typename ::std::allocator_traits< _Alloc> ::const_pointer const_pointer; 
# 106
typedef typename ::std::allocator_traits< _Alloc> ::size_type size_type; 
# 107
typedef typename ::std::allocator_traits< _Alloc> ::difference_type difference_type; 
# 109
typedef value_type &reference; 
# 110
typedef const value_type &const_reference; 
# 111
using ::std::allocator_traits< _Alloc> ::allocate;
# 112
using ::std::allocator_traits< _Alloc> ::deallocate;
# 113
using ::std::allocator_traits< _Alloc> ::construct;
# 114
using ::std::allocator_traits< _Alloc> ::destroy;
# 115
using ::std::allocator_traits< _Alloc> ::max_size;
# 119
private: 
# 118
template< class _Ptr> using __is_custom_pointer = ::std::__and_< ::std::is_same< typename ::std::allocator_traits< _Alloc> ::pointer, _Ptr> , ::std::__not_< ::std::is_pointer< _Ptr> > > ; 
# 127
public: 
# 125
template< class _Ptr, class ..._Args> static typename ::std::enable_if< ::std::__and_< ::std::is_same< typename ::std::allocator_traits< _Alloc> ::pointer, _Ptr> , ::std::__not_< ::std::is_pointer< _Ptr> > > ::value> ::type 
# 127
construct(_Alloc &__a, _Ptr __p, _Args &&...__args) 
# 128
{ 
# 129
_Base_type::construct(__a, ::std::addressof(*__p), ::std::forward< _Args> (__args)...); 
# 131
} 
# 134
template< class _Ptr> static typename ::std::enable_if< ::std::__and_< ::std::is_same< typename ::std::allocator_traits< _Alloc> ::pointer, _Ptr> , ::std::__not_< ::std::is_pointer< _Ptr> > > ::value> ::type 
# 136
destroy(_Alloc &__a, _Ptr __p) 
# 137
{ _Base_type::destroy(__a, ::std::addressof(*__p)); } 
# 139
static _Alloc _S_select_on_copy(const _Alloc &__a) 
# 140
{ return _Base_type::select_on_container_copy_construction(__a); } 
# 142
static void _S_on_swap(_Alloc &__a, _Alloc &__b) 
# 143
{ ::std::__alloc_on_swap(__a, __b); } 
# 145
static constexpr bool _S_propagate_on_copy_assign() 
# 146
{ return _Base_type::propagate_on_container_copy_assignment::value; } 
# 148
static constexpr bool _S_propagate_on_move_assign() 
# 149
{ return _Base_type::propagate_on_container_move_assignment::value; } 
# 151
static constexpr bool _S_propagate_on_swap() 
# 152
{ return _Base_type::propagate_on_container_swap::value; } 
# 154
static constexpr bool _S_always_equal() 
# 155
{ return __allocator_always_compares_equal< _Alloc> ::value; } 
# 157
static constexpr bool _S_nothrow_move() 
# 158
{ return (_S_propagate_on_move_assign)() || (_S_always_equal)(); } 
# 160
static constexpr bool _S_nothrow_swap() 
# 161
{ 
# 162
using ::std::swap;
# 163
return (!(_S_propagate_on_swap)()) || noexcept(swap(::std::declval< _Alloc &> (), ::std::declval< _Alloc &> ())); 
# 165
} 
# 167
template< class _Tp> 
# 168
struct rebind { 
# 169
typedef typename ::std::allocator_traits< _Alloc> ::template rebind_alloc< _Tp>  other; }; 
# 210 "/usr/include/c++/5/ext/alloc_traits.h" 3
}; 
# 213
}
# 46 "/usr/include/c++/5/bits/basic_string.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 51
inline namespace __cxx11 { 
# 70 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> 
# 71
class basic_string { 
# 74
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other _Char_alloc_type; 
# 75
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other>  _Alloc_traits; 
# 79
public: typedef _Traits traits_type; 
# 80
typedef typename _Traits::char_type value_type; 
# 81
typedef _Char_alloc_type allocator_type; 
# 82
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::size_type size_type; 
# 83
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::difference_type difference_type; 
# 84
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::reference reference; 
# 85
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::const_reference const_reference; 
# 86
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::pointer pointer; 
# 87
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::const_pointer const_pointer; 
# 88
typedef __gnu_cxx::__normal_iterator< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::pointer, basic_string>  iterator; 
# 90
typedef __gnu_cxx::__normal_iterator< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::const_pointer, basic_string>  const_iterator; 
# 91
typedef std::reverse_iterator< __gnu_cxx::__normal_iterator< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::const_pointer, basic_string> >  const_reverse_iterator; 
# 92
typedef std::reverse_iterator< __gnu_cxx::__normal_iterator< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::pointer, basic_string> >  reverse_iterator; 
# 95
static const size_type npos = (static_cast< size_type>(-1)); 
# 102
private: typedef const_iterator __const_iterator; 
# 106
struct _Alloc_hider : public allocator_type { 
# 108
_Alloc_hider(typename ::std::__cxx11::basic_string< _CharT, _Traits, _Alloc> ::pointer __dat, const _Alloc &__a = _Alloc()) : ::std::__cxx11::basic_string< _CharT, _Traits, _Alloc> ::allocator_type(__a), _M_p(__dat) 
# 109
{ } 
# 111
typename ::std::__cxx11::basic_string< _CharT, _Traits, _Alloc> ::pointer _M_p; 
# 112
}; 
# 114
_Alloc_hider _M_dataplus; 
# 115
size_type _M_string_length; 
# 117
enum { _S_local_capacity = (15) / sizeof(_CharT)}; 
# 120
union { 
# 121
_CharT _M_local_buf[(_S_local_capacity) + 1]; 
# 122
size_type _M_allocated_capacity; 
# 123
}; 
# 126
void _M_data(pointer __p) 
# 127
{ ((_M_dataplus)._M_p) = __p; } 
# 130
void _M_length(size_type __length) 
# 131
{ (_M_string_length) = __length; } 
# 134
pointer _M_data() const 
# 135
{ return (_M_dataplus)._M_p; } 
# 138
pointer _M_local_data() 
# 139
{ 
# 141
return std::pointer_traits< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::pointer> ::pointer_to(*(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf)); 
# 145
} 
# 148
const_pointer _M_local_data() const 
# 149
{ 
# 151
return std::pointer_traits< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::const_pointer> ::pointer_to(*(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf)); 
# 155
} 
# 158
void _M_capacity(size_type __capacity) 
# 159
{ (__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_allocated_capacity) = __capacity; } 
# 162
void _M_set_length(size_type __n) 
# 163
{ 
# 164
_M_length(__n); 
# 165
traits_type::assign(_M_data()[__n], _CharT()); 
# 166
} 
# 169
bool _M_is_local() const 
# 170
{ return _M_data() == this->_M_local_data(); } 
# 174
pointer _M_create(size_type &, size_type); 
# 177
void _M_dispose() 
# 178
{ 
# 179
if (!_M_is_local()) { 
# 180
_M_destroy(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_allocated_capacity); }  
# 181
} 
# 184
void _M_destroy(size_type __size) throw() 
# 185
{ _Alloc_traits::deallocate(this->_M_get_allocator(), _M_data(), __size + 1); } 
# 189
template< class _InIterator> void 
# 191
_M_construct_aux(_InIterator __beg, _InIterator __end, __false_type) 
# 193
{ 
# 194
typedef typename iterator_traits< _InIterator> ::iterator_category _Tag; 
# 195
_M_construct(__beg, __end, _Tag()); 
# 196
} 
# 200
template< class _Integer> void 
# 202
_M_construct_aux(_Integer __beg, _Integer __end, __true_type) 
# 203
{ _M_construct_aux_2(static_cast< size_type>(__beg), __end); } 
# 206
void _M_construct_aux_2(size_type __req, _CharT __c) 
# 207
{ _M_construct(__req, __c); } 
# 209
template< class _InIterator> void 
# 211
_M_construct(_InIterator __beg, _InIterator __end) 
# 212
{ 
# 213
typedef typename __is_integer< _InIterator> ::__type _Integral; 
# 214
_M_construct_aux(__beg, __end, _Integral()); 
# 215
} 
# 218
template< class _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, input_iterator_tag); 
# 225
template< class _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, forward_iterator_tag); 
# 231
void _M_construct(size_type __req, _CharT __c); 
# 234
allocator_type &_M_get_allocator() 
# 235
{ return _M_dataplus; } 
# 238
const allocator_type &_M_get_allocator() const 
# 239
{ return _M_dataplus; } 
# 258 "/usr/include/c++/5/bits/basic_string.h" 3
size_type _M_check(size_type __pos, const char *__s) const 
# 259
{ 
# 260
if (__pos > this->size()) { 
# 261
__throw_out_of_range_fmt("%s: __pos (which is %zu) > this->size() (which is %zu)", __s, __pos, this->size()); }  
# 264
return __pos; 
# 265
} 
# 268
void _M_check_length(size_type __n1, size_type __n2, const char *__s) const 
# 269
{ 
# 270
if ((this->max_size() - (this->size() - __n1)) < __n2) { 
# 271
__throw_length_error(__s); }  
# 272
} 
# 277
size_type _M_limit(size_type __pos, size_type __off) const noexcept 
# 278
{ 
# 279
const bool __testoff = __off < (this->size() - __pos); 
# 280
return __testoff ? __off : (this->size() - __pos); 
# 281
} 
# 285
bool _M_disjunct(const _CharT *__s) const noexcept 
# 286
{ 
# 287
return less< const _CharT *> ()(__s, _M_data()) || less< const _CharT *> ()(_M_data() + this->size(), __s); 
# 289
} 
# 294
static void _S_copy(_CharT *__d, const _CharT *__s, size_type __n) 
# 295
{ 
# 296
if (__n == 1) { 
# 297
traits_type::assign(*__d, *__s); } else { 
# 299
traits_type::copy(__d, __s, __n); }  
# 300
} 
# 303
static void _S_move(_CharT *__d, const _CharT *__s, size_type __n) 
# 304
{ 
# 305
if (__n == 1) { 
# 306
traits_type::assign(*__d, *__s); } else { 
# 308
traits_type::move(__d, __s, __n); }  
# 309
} 
# 312
static void _S_assign(_CharT *__d, size_type __n, _CharT __c) 
# 313
{ 
# 314
if (__n == 1) { 
# 315
traits_type::assign(*__d, __c); } else { 
# 317
traits_type::assign(__d, __n, __c); }  
# 318
} 
# 322
template< class _Iterator> static void 
# 324
_S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2) 
# 325
{ 
# 326
for (; __k1 != __k2; (++__k1), (++__p)) { 
# 327
traits_type::assign(*__p, *__k1); }  
# 328
} 
# 331
static void _S_copy_chars(_CharT *__p, iterator __k1, iterator __k2) noexcept 
# 332
{ _S_copy_chars(__p, (__k1.base()), (__k2.base())); } 
# 335
static void _S_copy_chars(_CharT *__p, const_iterator __k1, const_iterator __k2) noexcept 
# 337
{ _S_copy_chars(__p, (__k1.base()), (__k2.base())); } 
# 340
static void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2) noexcept 
# 341
{ (_S_copy)(__p, __k1, __k2 - __k1); } 
# 344
static void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2) noexcept 
# 346
{ (_S_copy)(__p, __k1, __k2 - __k1); } 
# 349
static int _S_compare(size_type __n1, size_type __n2) noexcept 
# 350
{ 
# 351
const difference_type __d = (difference_type)(__n1 - __n2); 
# 353
if (__d > __gnu_cxx::__numeric_traits< int> ::__max) { 
# 354
return __gnu_cxx::__numeric_traits_integer< int> ::__max; } else { 
# 355
if (__d < __gnu_cxx::__numeric_traits< int> ::__min) { 
# 356
return __gnu_cxx::__numeric_traits_integer< int> ::__min; } else { 
# 358
return (int)__d; }  }  
# 359
} 
# 362
void _M_assign(const basic_string & __rcs); 
# 365
void _M_mutate(size_type __pos, size_type __len1, const _CharT * __s, size_type __len2); 
# 369
void _M_erase(size_type __pos, size_type __n); 
# 379
public: basic_string() noexcept(is_nothrow_default_constructible< _Alloc> ::value) : _M_dataplus(this->_M_local_data()) 
# 384
{ _M_set_length(0); } 
# 390
explicit basic_string(const _Alloc &__a) : _M_dataplus(this->_M_local_data(), __a) 
# 392
{ _M_set_length(0); } 
# 398
basic_string(const basic_string &__str) : _M_dataplus(this->_M_local_data(), (__str._M_get_allocator())) 
# 400
{ _M_construct((__str._M_data()), (__str._M_data()) + (__str.length())); } 
# 410 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string(const basic_string &__str, size_type __pos, size_type 
# 411
__n = npos) : _M_dataplus(this->_M_local_data()) 
# 413
{ 
# 414
const _CharT *__start = (__str._M_data()) + (__str._M_check(__pos, "basic_string::basic_string")); 
# 416
_M_construct(__start, __start + (__str._M_limit(__pos, __n))); 
# 417
} 
# 426 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string(const basic_string &__str, size_type __pos, size_type 
# 427
__n, const _Alloc &__a) : _M_dataplus(this->_M_local_data(), __a) 
# 429
{ 
# 430
const _CharT *__start = (__str._M_data()) + (__str._M_check(__pos, "string::string")); 
# 432
_M_construct(__start, __start + (__str._M_limit(__pos, __n))); 
# 433
} 
# 444 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string(const _CharT *__s, size_type __n, const _Alloc &
# 445
__a = _Alloc()) : _M_dataplus(this->_M_local_data(), __a) 
# 447
{ _M_construct(__s, __s + __n); } 
# 454
basic_string(const _CharT *__s, const _Alloc &__a = _Alloc()) : _M_dataplus(this->_M_local_data(), __a) 
# 456
{ _M_construct(__s, (__s) ? __s + traits_type::length(__s) : (__s + npos)); } 
# 464
basic_string(size_type __n, _CharT __c, const _Alloc &__a = _Alloc()) : _M_dataplus(this->_M_local_data(), __a) 
# 466
{ _M_construct(__n, __c); } 
# 476 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string(basic_string &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move((__str._M_get_allocator()))) 
# 478
{ 
# 479
if ((__str._M_is_local())) 
# 480
{ 
# 481
traits_type::copy(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (__str._M_local_buf), (_S_local_capacity) + 1); 
# 483
} else 
# 485
{ 
# 486
_M_data((__str._M_data())); 
# 487
_M_capacity((__str._M_allocated_capacity)); 
# 488
}  
# 493
_M_length((__str.length())); 
# 494
(__str._M_data((__str._M_local_data()))); 
# 495
(__str._M_set_length(0)); 
# 496
} 
# 503
basic_string(initializer_list< _CharT>  __l, const _Alloc &__a = _Alloc()) : _M_dataplus(this->_M_local_data(), __a) 
# 505
{ _M_construct((__l.begin()), (__l.end())); } 
# 507
basic_string(const basic_string &__str, const _Alloc &__a) : _M_dataplus(this->_M_local_data(), __a) 
# 509
{ _M_construct((__str.begin()), (__str.end())); } 
# 511
basic_string(basic_string &&__str, const _Alloc &__a) : _M_dataplus(this->_M_local_data(), __a) 
# 513
{ 
# 514
if ((__str.get_allocator()) == __a) { 
# 515
(*this) = std::move(__str); } else { 
# 517
_M_construct((__str.begin()), (__str.end())); }  
# 518
} 
# 529 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _InputIterator, class 
# 530
 = _RequireInputIter< _InputIterator> > 
# 534
basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc &
# 535
__a = _Alloc()) : _M_dataplus(this->_M_local_data(), __a) 
# 537
{ _M_construct(__beg, __end); } 
# 542
~basic_string() 
# 543
{ _M_dispose(); } 
# 550
basic_string &operator=(const basic_string &__str) 
# 551
{ return (this->assign(__str)); } 
# 558
basic_string &operator=(const _CharT *__s) 
# 559
{ return (this->assign(__s)); } 
# 569 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &operator=(_CharT __c) 
# 570
{ 
# 571
(this->assign(1, __c)); 
# 572
return *this; 
# 573
} 
# 587 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &operator=(basic_string &&__str) 
# 588
{ 
# 589
this->swap(__str); 
# 590
return *this; 
# 591
} 
# 598
basic_string &operator=(initializer_list< _CharT>  __l) 
# 599
{ 
# 600
(this->assign((__l.begin()), (__l.size()))); 
# 601
return *this; 
# 602
} 
# 611
iterator begin() noexcept 
# 612
{ return ((iterator)(_M_data())); } 
# 619
const_iterator begin() const noexcept 
# 620
{ return ((const_iterator)(_M_data())); } 
# 627
iterator end() noexcept 
# 628
{ return ((iterator)(_M_data() + this->size())); } 
# 635
const_iterator end() const noexcept 
# 636
{ return ((const_iterator)(_M_data() + this->size())); } 
# 644
reverse_iterator rbegin() noexcept 
# 645
{ return ((reverse_iterator)(this->end())); } 
# 653
const_reverse_iterator rbegin() const noexcept 
# 654
{ return ((const_reverse_iterator)(this->end())); } 
# 662
reverse_iterator rend() noexcept 
# 663
{ return ((reverse_iterator)(this->begin())); } 
# 671
const_reverse_iterator rend() const noexcept 
# 672
{ return ((const_reverse_iterator)(this->begin())); } 
# 680
const_iterator cbegin() const noexcept 
# 681
{ return ((const_iterator)((this->_M_data()))); } 
# 688
const_iterator cend() const noexcept 
# 689
{ return ((const_iterator)((this->_M_data()) + this->size())); } 
# 697
const_reverse_iterator crbegin() const noexcept 
# 698
{ return ((const_reverse_iterator)(this->end())); } 
# 706
const_reverse_iterator crend() const noexcept 
# 707
{ return ((const_reverse_iterator)(this->begin())); } 
# 715
size_type size() const noexcept 
# 716
{ return _M_string_length; } 
# 721
size_type length() const noexcept 
# 722
{ return _M_string_length; } 
# 726
size_type max_size() const noexcept 
# 727
{ return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2; } 
# 740 "/usr/include/c++/5/bits/basic_string.h" 3
void resize(size_type __n, _CharT __c); 
# 753 "/usr/include/c++/5/bits/basic_string.h" 3
void resize(size_type __n) 
# 754
{ (this->resize(__n, _CharT())); } 
# 759
void shrink_to_fit() noexcept 
# 760
{ 
# 762
if (capacity() > size()) 
# 763
{ 
# 764
try 
# 765
{ reserve(0); } 
# 766
catch (...) 
# 767
{ }  
# 768
}  
# 770
} 
# 778
size_type capacity() const noexcept 
# 779
{ 
# 780
return (_M_is_local()) ? (size_type)(_S_local_capacity) : (__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_allocated_capacity); 
# 782
} 
# 802 "/usr/include/c++/5/bits/basic_string.h" 3
void reserve(size_type __res_arg = 0); 
# 808
void clear() noexcept 
# 809
{ _M_set_length(0); } 
# 816
bool empty() const noexcept 
# 817
{ return this->size() == 0; } 
# 831 "/usr/include/c++/5/bits/basic_string.h" 3
const_reference operator[](size_type __pos) const noexcept 
# 832
{ 
# 833
; 
# 834
return _M_data()[__pos]; 
# 835
} 
# 848 "/usr/include/c++/5/bits/basic_string.h" 3
reference operator[](size_type __pos) 
# 849
{ 
# 852
; 
# 854
; 
# 855
return _M_data()[__pos]; 
# 856
} 
# 869 "/usr/include/c++/5/bits/basic_string.h" 3
const_reference at(size_type __n) const 
# 870
{ 
# 871
if (__n >= this->size()) { 
# 872
__throw_out_of_range_fmt("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size()); }  
# 876
return _M_data()[__n]; 
# 877
} 
# 890 "/usr/include/c++/5/bits/basic_string.h" 3
reference at(size_type __n) 
# 891
{ 
# 892
if (__n >= size()) { 
# 893
__throw_out_of_range_fmt("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size()); }  
# 897
return _M_data()[__n]; 
# 898
} 
# 906
reference front() noexcept 
# 907
{ return operator[](0); } 
# 914
const_reference front() const noexcept 
# 915
{ return operator[](0); } 
# 922
reference back() noexcept 
# 923
{ return operator[](this->size() - 1); } 
# 930
const_reference back() const noexcept 
# 931
{ return operator[](this->size() - 1); } 
# 941 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &operator+=(const basic_string &__str) 
# 942
{ return (this->append(__str)); } 
# 950
basic_string &operator+=(const _CharT *__s) 
# 951
{ return (this->append(__s)); } 
# 959
basic_string &operator+=(_CharT __c) 
# 960
{ 
# 961
this->push_back(__c); 
# 962
return *this; 
# 963
} 
# 972
basic_string &operator+=(initializer_list< _CharT>  __l) 
# 973
{ return (this->append((__l.begin()), (__l.size()))); } 
# 982
basic_string &append(const basic_string &__str) 
# 983
{ return _M_append((__str._M_data()), (__str.size())); } 
# 999 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &append(const basic_string &__str, size_type __pos, size_type __n) 
# 1000
{ return _M_append((__str._M_data()) + (__str._M_check(__pos, "basic_string::append")), (__str._M_limit(__pos, __n))); 
# 1002
} 
# 1011
basic_string &append(const _CharT *__s, size_type __n) 
# 1012
{ 
# 1013
; 
# 1014
_M_check_length((size_type)0, __n, "basic_string::append"); 
# 1015
return _M_append(__s, __n); 
# 1016
} 
# 1024
basic_string &append(const _CharT *__s) 
# 1025
{ 
# 1026
; 
# 1027
const size_type __n = traits_type::length(__s); 
# 1028
_M_check_length((size_type)0, __n, "basic_string::append"); 
# 1029
return _M_append(__s, __n); 
# 1030
} 
# 1041 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &append(size_type __n, _CharT __c) 
# 1042
{ return _M_replace_aux(this->size(), (size_type)0, __n, __c); } 
# 1051
basic_string &append(initializer_list< _CharT>  __l) 
# 1052
{ return (this->append((__l.begin()), (__l.size()))); } 
# 1064 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _InputIterator, class 
# 1065
 = _RequireInputIter< _InputIterator> > basic_string &
# 1070
append(_InputIterator __first, _InputIterator __last) 
# 1071
{ return (this->replace(this->end(), this->end(), __first, __last)); } 
# 1078
void push_back(_CharT __c) 
# 1079
{ 
# 1080
const size_type __size = this->size(); 
# 1081
if ((__size + 1) > this->capacity()) { 
# 1082
this->_M_mutate(__size, (size_type)0, 0, (size_type)1); }  
# 1083
traits_type::assign((this->_M_data())[__size], __c); 
# 1084
this->_M_set_length(__size + 1); 
# 1085
} 
# 1093
basic_string &assign(const basic_string &__str) 
# 1094
{ 
# 1095
this->_M_assign(__str); 
# 1096
return *this; 
# 1097
} 
# 1109 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &assign(basic_string &&__str) 
# 1110
{ 
# 1113
return (*this) = std::move(__str); 
# 1114
} 
# 1131 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &assign(const basic_string &__str, size_type __pos, size_type __n) 
# 1132
{ return _M_replace((size_type)0, this->size(), (__str._M_data()) + (__str._M_check(__pos, "basic_string::assign")), (__str._M_limit(__pos, __n))); 
# 1134
} 
# 1147 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &assign(const _CharT *__s, size_type __n) 
# 1148
{ 
# 1149
; 
# 1150
return _M_replace((size_type)0, this->size(), __s, __n); 
# 1151
} 
# 1163 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &assign(const _CharT *__s) 
# 1164
{ 
# 1165
; 
# 1166
return _M_replace((size_type)0, this->size(), __s, traits_type::length(__s)); 
# 1168
} 
# 1180 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &assign(size_type __n, _CharT __c) 
# 1181
{ return _M_replace_aux((size_type)0, this->size(), __n, __c); } 
# 1192 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _InputIterator, class 
# 1193
 = _RequireInputIter< _InputIterator> > basic_string &
# 1198
assign(_InputIterator __first, _InputIterator __last) 
# 1199
{ return (this->replace(this->begin(), this->end(), __first, __last)); } 
# 1208
basic_string &assign(initializer_list< _CharT>  __l) 
# 1209
{ return (this->assign((__l.begin()), (__l.size()))); } 
# 1229 "/usr/include/c++/5/bits/basic_string.h" 3
iterator insert(const_iterator __p, size_type __n, _CharT __c) 
# 1230
{ 
# 1231
; 
# 1232
const size_type __pos = __p - this->begin(); 
# 1233
(this->replace(__p, __p, __n, __c)); 
# 1234
return ((iterator)((this->_M_data()) + __pos)); 
# 1235
} 
# 1270 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _InputIterator, class 
# 1271
 = _RequireInputIter< _InputIterator> > iterator 
# 1273
insert(const_iterator __p, _InputIterator __beg, _InputIterator __end) 
# 1274
{ 
# 1275
; 
# 1276
const size_type __pos = __p - this->begin(); 
# 1277
(this->replace(__p, __p, __beg, __end)); 
# 1278
return ((iterator)((this->_M_data()) + __pos)); 
# 1279
} 
# 1307 "/usr/include/c++/5/bits/basic_string.h" 3
void insert(iterator __p, initializer_list< _CharT>  __l) 
# 1308
{ 
# 1309
; 
# 1310
(this->insert(__p - this->begin(), (__l.begin()), (__l.size()))); 
# 1311
} 
# 1327 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &insert(size_type __pos1, const basic_string &__str) 
# 1328
{ return (this->replace(__pos1, (size_type)0, (__str._M_data()), (__str.size()))); 
# 1329
} 
# 1350 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &insert(size_type __pos1, const basic_string &__str, size_type 
# 1351
__pos2, size_type __n) 
# 1352
{ return (this->replace(__pos1, (size_type)0, (__str._M_data()) + (__str._M_check(__pos2, "basic_string::insert")), (__str._M_limit(__pos2, __n)))); 
# 1354
} 
# 1373 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &insert(size_type __pos, const _CharT *__s, size_type __n) 
# 1374
{ return (this->replace(__pos, (size_type)0, __s, __n)); } 
# 1392 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &insert(size_type __pos, const _CharT *__s) 
# 1393
{ 
# 1394
; 
# 1395
return (this->replace(__pos, (size_type)0, __s, traits_type::length(__s))); 
# 1397
} 
# 1416 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &insert(size_type __pos, size_type __n, _CharT __c) 
# 1417
{ return _M_replace_aux(_M_check(__pos, "basic_string::insert"), (size_type)0, __n, __c); 
# 1418
} 
# 1434 "/usr/include/c++/5/bits/basic_string.h" 3
iterator insert(__const_iterator __p, _CharT __c) 
# 1435
{ 
# 1436
; 
# 1437
const size_type __pos = __p - this->begin(); 
# 1438
_M_replace_aux(__pos, (size_type)0, (size_type)1, __c); 
# 1439
return ((iterator)(_M_data() + __pos)); 
# 1440
} 
# 1458 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &erase(size_type __pos = 0, size_type __n = npos) 
# 1459
{ 
# 1460
this->_M_erase(_M_check(__pos, "basic_string::erase"), _M_limit(__pos, __n)); 
# 1462
return *this; 
# 1463
} 
# 1474 "/usr/include/c++/5/bits/basic_string.h" 3
iterator erase(__const_iterator __position) 
# 1475
{ 
# 1477
; 
# 1478
const size_type __pos = __position - this->begin(); 
# 1479
this->_M_erase(__pos, (size_type)1); 
# 1480
return ((iterator)(_M_data() + __pos)); 
# 1481
} 
# 1493 "/usr/include/c++/5/bits/basic_string.h" 3
iterator erase(__const_iterator __first, __const_iterator __last) 
# 1494
{ 
# 1496
; 
# 1497
const size_type __pos = __first - this->begin(); 
# 1498
this->_M_erase(__pos, __last - __first); 
# 1499
return ((iterator)((this->_M_data()) + __pos)); 
# 1500
} 
# 1509
void pop_back() noexcept 
# 1510
{ _M_erase(size() - 1, 1); } 
# 1531 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(size_type __pos, size_type __n, const basic_string &__str) 
# 1532
{ return (this->replace(__pos, __n, (__str._M_data()), (__str.size()))); } 
# 1553 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(size_type __pos1, size_type __n1, const basic_string &__str, size_type 
# 1554
__pos2, size_type __n2) 
# 1555
{ return (this->replace(__pos1, __n1, (__str._M_data()) + (__str._M_check(__pos2, "basic_string::replace")), (__str._M_limit(__pos2, __n2)))); 
# 1557
} 
# 1578 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(size_type __pos, size_type __n1, const _CharT *__s, size_type 
# 1579
__n2) 
# 1580
{ 
# 1581
; 
# 1582
return _M_replace(_M_check(__pos, "basic_string::replace"), _M_limit(__pos, __n1), __s, __n2); 
# 1584
} 
# 1603 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(size_type __pos, size_type __n1, const _CharT *__s) 
# 1604
{ 
# 1605
; 
# 1606
return (this->replace(__pos, __n1, __s, traits_type::length(__s))); 
# 1607
} 
# 1627 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c) 
# 1628
{ return _M_replace_aux(_M_check(__pos, "basic_string::replace"), _M_limit(__pos, __n1), __n2, __c); 
# 1629
} 
# 1645 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const basic_string &
# 1646
__str) 
# 1647
{ return (this->replace(__i1, __i2, (__str._M_data()), (__str.size()))); } 
# 1665 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *
# 1666
__s, size_type __n) 
# 1667
{ 
# 1669
; 
# 1670
return (this->replace(__i1 - this->begin(), __i2 - __i1, __s, __n)); 
# 1671
} 
# 1687 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *__s) 
# 1688
{ 
# 1689
; 
# 1690
return (this->replace(__i1, __i2, __s, traits_type::length(__s))); 
# 1691
} 
# 1708 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, _CharT 
# 1709
__c) 
# 1710
{ 
# 1712
; 
# 1713
return _M_replace_aux(__i1 - this->begin(), __i2 - __i1, __n, __c); 
# 1714
} 
# 1732 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _InputIterator, class 
# 1733
 = _RequireInputIter< _InputIterator> > basic_string &
# 1735
replace(const_iterator __i1, const_iterator __i2, _InputIterator 
# 1736
__k1, _InputIterator __k2) 
# 1737
{ 
# 1739
; 
# 1740
; 
# 1741
return (this->_M_replace_dispatch(__i1, __i2, __k1, __k2, __false_type())); 
# 1743
} 
# 1765 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(__const_iterator __i1, __const_iterator __i2, _CharT *
# 1766
__k1, _CharT *__k2) 
# 1767
{ 
# 1769
; 
# 1770
; 
# 1771
return (this->replace(__i1 - this->begin(), __i2 - __i1, __k1, __k2 - __k1)); 
# 1773
} 
# 1776
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *
# 1777
__k1, const _CharT *__k2) 
# 1778
{ 
# 1780
; 
# 1781
; 
# 1782
return (this->replace(__i1 - this->begin(), __i2 - __i1, __k1, __k2 - __k1)); 
# 1784
} 
# 1787
basic_string &replace(__const_iterator __i1, __const_iterator __i2, iterator 
# 1788
__k1, iterator __k2) 
# 1789
{ 
# 1791
; 
# 1792
; 
# 1793
return (this->replace(__i1 - this->begin(), __i2 - __i1, (__k1.base()), __k2 - __k1)); 
# 1795
} 
# 1798
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const_iterator 
# 1799
__k1, const_iterator __k2) 
# 1800
{ 
# 1802
; 
# 1803
; 
# 1804
return (this->replace(__i1 - this->begin(), __i2 - __i1, (__k1.base()), __k2 - __k1)); 
# 1806
} 
# 1823 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string &replace(const_iterator __i1, const_iterator __i2, initializer_list< _CharT>  
# 1824
__l) 
# 1825
{ return (this->replace(__i1, __i2, (__l.begin()), (__l.end()))); } 
# 1831
private: 
# 1829
template< class _Integer> basic_string &
# 1831
_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer 
# 1832
__n, _Integer __val, __true_type) 
# 1833
{ return _M_replace_aux(__i1 - this->begin(), __i2 - __i1, __n, __val); } 
# 1835
template< class _InputIterator> basic_string &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type); 
# 1842
basic_string &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT __c); 
# 1846
basic_string &_M_replace(size_type __pos, size_type __len1, const _CharT * __s, const size_type __len2); 
# 1850
basic_string &_M_append(const _CharT * __s, size_type __n); 
# 1867 "/usr/include/c++/5/bits/basic_string.h" 3
public: size_type copy(_CharT * __s, size_type __n, size_type __pos = 0) const; 
# 1877 "/usr/include/c++/5/bits/basic_string.h" 3
void swap(basic_string & __s) noexcept; 
# 1887 "/usr/include/c++/5/bits/basic_string.h" 3
const _CharT *c_str() const noexcept 
# 1888
{ return _M_data(); } 
# 1897
const _CharT *data() const noexcept 
# 1898
{ return _M_data(); } 
# 1904
allocator_type get_allocator() const noexcept 
# 1905
{ return this->_M_get_allocator(); } 
# 1920 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find(const _CharT * __s, size_type __pos, size_type __n) const; 
# 1933 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find(const basic_string &__str, size_type __pos = 0) const noexcept 
# 1935
{ return (this->find((__str.data()), __pos, (__str.size()))); } 
# 1948 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find(const _CharT *__s, size_type __pos = 0) const 
# 1949
{ 
# 1950
; 
# 1951
return (this->find(__s, __pos, traits_type::length(__s))); 
# 1952
} 
# 1965 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find(_CharT __c, size_type __pos = 0) const noexcept; 
# 1978 "/usr/include/c++/5/bits/basic_string.h" 3
size_type rfind(const basic_string &__str, size_type __pos = npos) const noexcept 
# 1980
{ return (this->rfind((__str.data()), __pos, (__str.size()))); } 
# 1995 "/usr/include/c++/5/bits/basic_string.h" 3
size_type rfind(const _CharT * __s, size_type __pos, size_type __n) const; 
# 2008 "/usr/include/c++/5/bits/basic_string.h" 3
size_type rfind(const _CharT *__s, size_type __pos = npos) const 
# 2009
{ 
# 2010
; 
# 2011
return (this->rfind(__s, __pos, traits_type::length(__s))); 
# 2012
} 
# 2025 "/usr/include/c++/5/bits/basic_string.h" 3
size_type rfind(_CharT __c, size_type __pos = npos) const noexcept; 
# 2039 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_first_of(const basic_string &__str, size_type __pos = 0) const noexcept 
# 2041
{ return (this->find_first_of((__str.data()), __pos, (__str.size()))); } 
# 2056 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_first_of(const _CharT * __s, size_type __pos, size_type __n) const; 
# 2069 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_first_of(const _CharT *__s, size_type __pos = 0) const 
# 2070
{ 
# 2071
; 
# 2072
return (this->find_first_of(__s, __pos, traits_type::length(__s))); 
# 2073
} 
# 2088 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept 
# 2089
{ return (this->find(__c, __pos)); } 
# 2103 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_last_of(const basic_string &__str, size_type __pos = npos) const noexcept 
# 2105
{ return (this->find_last_of((__str.data()), __pos, (__str.size()))); } 
# 2120 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_last_of(const _CharT * __s, size_type __pos, size_type __n) const; 
# 2133 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_last_of(const _CharT *__s, size_type __pos = npos) const 
# 2134
{ 
# 2135
; 
# 2136
return (this->find_last_of(__s, __pos, traits_type::length(__s))); 
# 2137
} 
# 2152 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept 
# 2153
{ return (this->rfind(__c, __pos)); } 
# 2166 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_first_not_of(const basic_string &__str, size_type __pos = 0) const noexcept 
# 2168
{ return (this->find_first_not_of((__str.data()), __pos, (__str.size()))); } 
# 2183 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_first_not_of(const _CharT * __s, size_type __pos, size_type __n) const; 
# 2197 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_first_not_of(const _CharT *__s, size_type __pos = 0) const 
# 2198
{ 
# 2199
; 
# 2200
return (this->find_first_not_of(__s, __pos, traits_type::length(__s))); 
# 2201
} 
# 2214 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept; 
# 2229 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_last_not_of(const basic_string &__str, size_type __pos = npos) const noexcept 
# 2231
{ return (this->find_last_not_of((__str.data()), __pos, (__str.size()))); } 
# 2246 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_last_not_of(const _CharT * __s, size_type __pos, size_type __n) const; 
# 2260 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_last_not_of(const _CharT *__s, size_type __pos = npos) const 
# 2261
{ 
# 2262
; 
# 2263
return (this->find_last_not_of(__s, __pos, traits_type::length(__s))); 
# 2264
} 
# 2277 "/usr/include/c++/5/bits/basic_string.h" 3
size_type find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept; 
# 2293 "/usr/include/c++/5/bits/basic_string.h" 3
basic_string substr(size_type __pos = 0, size_type __n = npos) const 
# 2294
{ return basic_string(*this, _M_check(__pos, "basic_string::substr"), __n); 
# 2295
} 
# 2312 "/usr/include/c++/5/bits/basic_string.h" 3
int compare(const basic_string &__str) const 
# 2313
{ 
# 2314
const size_type __size = this->size(); 
# 2315
const size_type __osize = (__str.size()); 
# 2316
const size_type __len = std::min(__size, __osize); 
# 2318
int __r = traits_type::compare(_M_data(), (__str.data()), __len); 
# 2319
if (!__r) { 
# 2320
__r = (_S_compare)(__size, __osize); }  
# 2321
return __r; 
# 2322
} 
# 2344 "/usr/include/c++/5/bits/basic_string.h" 3
int compare(size_type __pos, size_type __n, const basic_string & __str) const; 
# 2370 "/usr/include/c++/5/bits/basic_string.h" 3
int compare(size_type __pos1, size_type __n1, const basic_string & __str, size_type __pos2, size_type __n2) const; 
# 2388 "/usr/include/c++/5/bits/basic_string.h" 3
int compare(const _CharT * __s) const; 
# 2412 "/usr/include/c++/5/bits/basic_string.h" 3
int compare(size_type __pos, size_type __n1, const _CharT * __s) const; 
# 2439 "/usr/include/c++/5/bits/basic_string.h" 3
int compare(size_type __pos, size_type __n1, const _CharT * __s, size_type __n2) const; 
# 2441
}; 
# 2442
}
# 4781 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4783
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4784
__rhs) 
# 4785
{ 
# 4786
__cxx11::basic_string< _CharT, _Traits, _Alloc>  __str(__lhs); 
# 4787
(__str.append(__rhs)); 
# 4788
return __str; 
# 4789
} 
# 4797
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  operator+(const _CharT * __lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __rhs); 
# 4808
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  operator+(_CharT __lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __rhs); 
# 4818
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4820
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 4821
__rhs) 
# 4822
{ 
# 4823
__cxx11::basic_string< _CharT, _Traits, _Alloc>  __str(__lhs); 
# 4824
(__str.append(__rhs)); 
# 4825
return __str; 
# 4826
} 
# 4834
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4836
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, _CharT __rhs) 
# 4837
{ 
# 4838
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 4839
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 4840
__string_type __str(__lhs); 
# 4841
(__str.append((__size_type)1, __rhs)); 
# 4842
return __str; 
# 4843
} 
# 4846
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4848
operator+(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &&__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4849
__rhs) 
# 4850
{ return std::move((__lhs.append(__rhs))); } 
# 4852
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4854
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &&
# 4855
__rhs) 
# 4856
{ return std::move((__rhs.insert(0, __lhs))); } 
# 4858
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4860
operator+(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &&__lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &&
# 4861
__rhs) 
# 4862
{ 
# 4863
const auto __size = (__lhs.size()) + (__rhs.size()); 
# 4864
const bool __cond = (__size > (__lhs.capacity())) && (__size <= (__rhs.capacity())); 
# 4866
return __cond ? std::move((__rhs.insert(0, __lhs))) : std::move((__lhs.append(__rhs))); 
# 4868
} 
# 4870
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4872
operator+(const _CharT *__lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &&
# 4873
__rhs) 
# 4874
{ return std::move((__rhs.insert(0, __lhs))); } 
# 4876
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4878
operator+(_CharT __lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &&
# 4879
__rhs) 
# 4880
{ return std::move((__rhs.insert(0, 1, __lhs))); } 
# 4882
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4884
operator+(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &&__lhs, const _CharT *
# 4885
__rhs) 
# 4886
{ return std::move((__lhs.append(__rhs))); } 
# 4888
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4890
operator+(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &&__lhs, _CharT 
# 4891
__rhs) 
# 4892
{ return std::move((__lhs.append(1, __rhs))); } 
# 4902 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4904
operator==(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4905
__rhs) 
# 4906
{ return (__lhs.compare(__rhs)) == 0; } 
# 4908
template< class _CharT> inline typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, bool> ::__type 
# 4911
operator==(const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &__lhs, const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &
# 4912
__rhs) 
# 4913
{ return ((__lhs.size()) == (__rhs.size())) && (!std::char_traits< _CharT> ::compare((__lhs.data()), (__rhs.data()), (__lhs.size()))); 
# 4915
} 
# 4923
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4925
operator==(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4926
__rhs) 
# 4927
{ return (__rhs.compare(__lhs)) == 0; } 
# 4935
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4937
operator==(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 4938
__rhs) 
# 4939
{ return (__lhs.compare(__rhs)) == 0; } 
# 4948 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4950
operator!=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4951
__rhs) 
# 4952
{ return !(__lhs == __rhs); } 
# 4960
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4962
operator!=(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4963
__rhs) 
# 4964
{ return !(__lhs == __rhs); } 
# 4972
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4974
operator!=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 4975
__rhs) 
# 4976
{ return !(__lhs == __rhs); } 
# 4985 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4987
operator<(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4988
__rhs) 
# 4989
{ return (__lhs.compare(__rhs)) < 0; } 
# 4997
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4999
operator<(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 5000
__rhs) 
# 5001
{ return (__lhs.compare(__rhs)) < 0; } 
# 5009
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5011
operator<(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5012
__rhs) 
# 5013
{ return (__rhs.compare(__lhs)) > 0; } 
# 5022 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5024
operator>(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5025
__rhs) 
# 5026
{ return (__lhs.compare(__rhs)) > 0; } 
# 5034
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5036
operator>(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 5037
__rhs) 
# 5038
{ return (__lhs.compare(__rhs)) > 0; } 
# 5046
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5048
operator>(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5049
__rhs) 
# 5050
{ return (__rhs.compare(__lhs)) < 0; } 
# 5059 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5061
operator<=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5062
__rhs) 
# 5063
{ return (__lhs.compare(__rhs)) <= 0; } 
# 5071
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5073
operator<=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 5074
__rhs) 
# 5075
{ return (__lhs.compare(__rhs)) <= 0; } 
# 5083
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5085
operator<=(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5086
__rhs) 
# 5087
{ return (__rhs.compare(__lhs)) >= 0; } 
# 5096 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5098
operator>=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5099
__rhs) 
# 5100
{ return (__lhs.compare(__rhs)) >= 0; } 
# 5108
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5110
operator>=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 5111
__rhs) 
# 5112
{ return (__lhs.compare(__rhs)) >= 0; } 
# 5120
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5122
operator>=(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5123
__rhs) 
# 5124
{ return (__rhs.compare(__lhs)) <= 0; } 
# 5133 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline void 
# 5135
swap(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5136
__rhs) 
# 5137
{ (__lhs.swap(__rhs)); } 
# 5152 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __str); 
# 5159
template<> basic_istream< char>  &operator>>(basic_istream< char>  & __is, __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str); 
# 5170 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline basic_ostream< _CharT, _Traits>  &
# 5172
operator<<(basic_ostream< _CharT, _Traits>  &__os, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5173
__str) 
# 5174
{ 
# 5177
return __ostream_insert(__os, (__str.data()), (__str.size())); 
# 5178
} 
# 5193 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &getline(basic_istream< _CharT, _Traits>  & __is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __str, _CharT __delim); 
# 5210 "/usr/include/c++/5/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline basic_istream< _CharT, _Traits>  &
# 5212
getline(basic_istream< _CharT, _Traits>  &__is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5213
__str) 
# 5214
{ return std::getline(__is, __str, (__is.widen('\n'))); } 
# 5218
template< class _CharT, class _Traits, class _Alloc> inline basic_istream< _CharT, _Traits>  &
# 5220
getline(basic_istream< _CharT, _Traits>  &&__is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5221
__str, _CharT __delim) 
# 5222
{ return std::getline(__is, __str, __delim); } 
# 5225
template< class _CharT, class _Traits, class _Alloc> inline basic_istream< _CharT, _Traits>  &
# 5227
getline(basic_istream< _CharT, _Traits>  &&__is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5228
__str) 
# 5229
{ return std::getline(__is, __str); } 
# 5234
template<> basic_istream< char>  &getline(basic_istream< char>  & __in, __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str, char __delim); 
# 5240
template<> basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __in, __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> >  & __str, wchar_t __delim); 
# 5245
}
# 96 "/usr/include/c++/5/cstdio" 3
namespace std { 
# 98
using ::FILE;
# 99
using ::fpos_t;
# 101
using ::clearerr;
# 102
using ::fclose;
# 103
using ::feof;
# 104
using ::ferror;
# 105
using ::fflush;
# 106
using ::fgetc;
# 107
using ::fgetpos;
# 108
using ::fgets;
# 109
using ::fopen;
# 110
using ::fprintf;
# 111
using ::fputc;
# 112
using ::fputs;
# 113
using ::fread;
# 114
using ::freopen;
# 115
using ::fscanf;
# 116
using ::fseek;
# 117
using ::fsetpos;
# 118
using ::ftell;
# 119
using ::fwrite;
# 120
using ::getc;
# 121
using ::getchar;
# 124
using ::gets;
# 126
using ::perror;
# 127
using ::printf;
# 128
using ::putc;
# 129
using ::putchar;
# 130
using ::puts;
# 131
using ::remove;
# 132
using ::rename;
# 133
using ::rewind;
# 134
using ::scanf;
# 135
using ::setbuf;
# 136
using ::setvbuf;
# 137
using ::sprintf;
# 138
using ::sscanf;
# 139
using ::tmpfile;
# 141
using ::tmpnam;
# 143
using ::ungetc;
# 144
using ::vfprintf;
# 145
using ::vprintf;
# 146
using ::vsprintf;
# 147
}
# 157 "/usr/include/c++/5/cstdio" 3
namespace __gnu_cxx { 
# 175 "/usr/include/c++/5/cstdio" 3
using ::snprintf;
# 176
using ::vfscanf;
# 177
using ::vscanf;
# 178
using ::vsnprintf;
# 179
using ::vsscanf;
# 181
}
# 183
namespace std { 
# 185
using __gnu_cxx::snprintf;
# 186
using __gnu_cxx::vfscanf;
# 187
using __gnu_cxx::vscanf;
# 188
using __gnu_cxx::vsnprintf;
# 189
using __gnu_cxx::vsscanf;
# 190
}
# 31 "/usr/include/errno.h" 3
extern "C" {
# 50 "/usr/include/aarch64-linux-gnu/bits/errno.h" 3
extern int *__errno_location() throw() __attribute((const)); 
# 54 "/usr/include/errno.h" 3
extern char *program_invocation_name, *program_invocation_short_name; 
# 58
}
# 68 "/usr/include/errno.h" 3
typedef int error_t; 
# 46 "/usr/include/c++/5/ext/string_conversions.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 51
template< class _TRet, class _Ret = _TRet, class _CharT, class ...
# 52
_Base> _Ret 
# 54
__stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base ...), const char *
# 55
__name, const _CharT *__str, std::size_t *__idx, _Base ...
# 56
__base) 
# 57
{ 
# 58
_Ret __ret; 
# 60
_CharT *__endptr; 
# 61
(*__errno_location()) = 0; 
# 62
const _TRet __tmp = __convf(__str, &__endptr, __base...); 
# 64
if (__endptr == __str) { 
# 65
std::__throw_invalid_argument(__name); } else { 
# 66
if (((*__errno_location()) == 34) || (std::__are_same< _Ret, int> ::__value && ((__tmp < __numeric_traits< int> ::__min) || (__tmp > __numeric_traits< int> ::__max)))) { 
# 70
std::__throw_out_of_range(__name); } else { 
# 72
__ret = __tmp; }  }  
# 74
if (__idx) { 
# 75
(*__idx) = (__endptr - __str); }  
# 77
return __ret; 
# 78
} 
# 81
template< class _String, class _CharT = typename _String::value_type> _String 
# 83
__to_xstring(int (*__convf)(_CharT *, std::size_t, const _CharT *, __builtin_va_list), std::size_t 
# 84
__n, const _CharT *
# 85
__fmt, ...) 
# 86
{ 
# 89
_CharT *__s = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __n)); 
# 92
__builtin_va_list __args; 
# 93
__builtin_va_start(__args,__fmt); 
# 95
const int __len = __convf(__s, __n, __fmt, __args); 
# 97
__builtin_va_end(__args); 
# 99
return _String(__s, __s + __len); 
# 100
} 
# 103
}
# 5251 "/usr/include/c++/5/bits/basic_string.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 5254
inline namespace __cxx11 { 
# 5258
inline int stoi(const string &__str, size_t *__idx = 0, int __base = 10) 
# 5259
{ return __gnu_cxx::__stoa< long, int> (&std::strtol, "stoi", __str.c_str(), __idx, __base); 
# 5260
} 
# 5263
inline long stol(const string &__str, size_t *__idx = 0, int __base = 10) 
# 5264
{ return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(), __idx, __base); 
# 5265
} 
# 5268
inline unsigned long stoul(const string &__str, size_t *__idx = 0, int __base = 10) 
# 5269
{ return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(), __idx, __base); 
# 5270
} 
# 5273
inline long long stoll(const string &__str, size_t *__idx = 0, int __base = 10) 
# 5274
{ return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(), __idx, __base); 
# 5275
} 
# 5278
inline unsigned long long stoull(const string &__str, size_t *__idx = 0, int __base = 10) 
# 5279
{ return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(), __idx, __base); 
# 5280
} 
# 5284
inline float stof(const string &__str, size_t *__idx = 0) 
# 5285
{ return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); } 
# 5288
inline double stod(const string &__str, size_t *__idx = 0) 
# 5289
{ return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); } 
# 5292
inline long double stold(const string &__str, size_t *__idx = 0) 
# 5293
{ return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); } 
# 5299
inline string to_string(int __val) 
# 5300
{ return __gnu_cxx::__to_xstring< basic_string< char, char_traits< char> , allocator< char> > > (&std::vsnprintf, (4) * sizeof(int), "%d", __val); 
# 5301
} 
# 5304
inline string to_string(unsigned __val) 
# 5305
{ return __gnu_cxx::__to_xstring< basic_string< char, char_traits< char> , allocator< char> > > (&std::vsnprintf, (4) * sizeof(unsigned), "%u", __val); 
# 5307
} 
# 5310
inline string to_string(long __val) 
# 5311
{ return __gnu_cxx::__to_xstring< basic_string< char, char_traits< char> , allocator< char> > > (&std::vsnprintf, (4) * sizeof(long), "%ld", __val); 
# 5312
} 
# 5315
inline string to_string(unsigned long __val) 
# 5316
{ return __gnu_cxx::__to_xstring< basic_string< char, char_traits< char> , allocator< char> > > (&std::vsnprintf, (4) * sizeof(unsigned long), "%lu", __val); 
# 5318
} 
# 5321
inline string to_string(long long __val) 
# 5322
{ return __gnu_cxx::__to_xstring< basic_string< char, char_traits< char> , allocator< char> > > (&std::vsnprintf, (4) * sizeof(long long), "%lld", __val); 
# 5324
} 
# 5327
inline string to_string(unsigned long long __val) 
# 5328
{ return __gnu_cxx::__to_xstring< basic_string< char, char_traits< char> , allocator< char> > > (&std::vsnprintf, (4) * sizeof(unsigned long long), "%llu", __val); 
# 5330
} 
# 5333
inline string to_string(float __val) 
# 5334
{ 
# 5335
const int __n = (__gnu_cxx::__numeric_traits_floating< float> ::__max_exponent10 + 20); 
# 5337
return __gnu_cxx::__to_xstring< basic_string< char, char_traits< char> , allocator< char> > > (&std::vsnprintf, __n, "%f", __val); 
# 5339
} 
# 5342
inline string to_string(double __val) 
# 5343
{ 
# 5344
const int __n = (__gnu_cxx::__numeric_traits_floating< double> ::__max_exponent10 + 20); 
# 5346
return __gnu_cxx::__to_xstring< basic_string< char, char_traits< char> , allocator< char> > > (&std::vsnprintf, __n, "%f", __val); 
# 5348
} 
# 5351
inline string to_string(long double __val) 
# 5352
{ 
# 5353
const int __n = (__gnu_cxx::__numeric_traits_floating< long double> ::__max_exponent10 + 20); 
# 5355
return __gnu_cxx::__to_xstring< basic_string< char, char_traits< char> , allocator< char> > > (&std::vsnprintf, __n, "%Lf", __val); 
# 5357
} 
# 5361
inline int stoi(const wstring &__str, size_t *__idx = 0, int __base = 10) 
# 5362
{ return __gnu_cxx::__stoa< long, int> (&std::wcstol, "stoi", __str.c_str(), __idx, __base); 
# 5363
} 
# 5366
inline long stol(const wstring &__str, size_t *__idx = 0, int __base = 10) 
# 5367
{ return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(), __idx, __base); 
# 5368
} 
# 5371
inline unsigned long stoul(const wstring &__str, size_t *__idx = 0, int __base = 10) 
# 5372
{ return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(), __idx, __base); 
# 5373
} 
# 5376
inline long long stoll(const wstring &__str, size_t *__idx = 0, int __base = 10) 
# 5377
{ return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(), __idx, __base); 
# 5378
} 
# 5381
inline unsigned long long stoull(const wstring &__str, size_t *__idx = 0, int __base = 10) 
# 5382
{ return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(), __idx, __base); 
# 5383
} 
# 5387
inline float stof(const wstring &__str, size_t *__idx = 0) 
# 5388
{ return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); } 
# 5391
inline double stod(const wstring &__str, size_t *__idx = 0) 
# 5392
{ return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); } 
# 5395
inline long double stold(const wstring &__str, size_t *__idx = 0) 
# 5396
{ return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); } 
# 5401
inline wstring to_wstring(int __val) 
# 5402
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > > (&std::vswprintf, (4) * sizeof(int), L"\x25\x64", __val); 
# 5403
} 
# 5406
inline wstring to_wstring(unsigned __val) 
# 5407
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > > (&std::vswprintf, (4) * sizeof(unsigned), L"\x25\x75", __val); 
# 5409
} 
# 5412
inline wstring to_wstring(long __val) 
# 5413
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > > (&std::vswprintf, (4) * sizeof(long), L"\x25\x6c\x64", __val); 
# 5414
} 
# 5417
inline wstring to_wstring(unsigned long __val) 
# 5418
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > > (&std::vswprintf, (4) * sizeof(unsigned long), L"\x25\x6c\x75", __val); 
# 5420
} 
# 5423
inline wstring to_wstring(long long __val) 
# 5424
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > > (&std::vswprintf, (4) * sizeof(long long), L"\x25\x6c\x6c\x64", __val); 
# 5426
} 
# 5429
inline wstring to_wstring(unsigned long long __val) 
# 5430
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > > (&std::vswprintf, (4) * sizeof(unsigned long long), L"\x25\x6c\x6c\x75", __val); 
# 5432
} 
# 5435
inline wstring to_wstring(float __val) 
# 5436
{ 
# 5437
const int __n = (__gnu_cxx::__numeric_traits_floating< float> ::__max_exponent10 + 20); 
# 5439
return __gnu_cxx::__to_xstring< basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > > (&std::vswprintf, __n, L"\x25\x66", __val); 
# 5441
} 
# 5444
inline wstring to_wstring(double __val) 
# 5445
{ 
# 5446
const int __n = (__gnu_cxx::__numeric_traits_floating< double> ::__max_exponent10 + 20); 
# 5448
return __gnu_cxx::__to_xstring< basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > > (&std::vswprintf, __n, L"\x25\x66", __val); 
# 5450
} 
# 5453
inline wstring to_wstring(long double __val) 
# 5454
{ 
# 5455
const int __n = (__gnu_cxx::__numeric_traits_floating< long double> ::__max_exponent10 + 20); 
# 5457
return __gnu_cxx::__to_xstring< basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > > (&std::vswprintf, __n, L"\x25\x4c\x66", __val); 
# 5459
} 
# 5463
}
# 5465
}
# 37 "/usr/include/c++/5/bits/hash_bytes.h" 3
namespace std { 
# 47
size_t _Hash_bytes(const void * __ptr, size_t __len, size_t __seed); 
# 54
size_t _Fnv_hash_bytes(const void * __ptr, size_t __len, size_t __seed); 
# 57
}
# 37 "/usr/include/c++/5/bits/functional_hash.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 49 "/usr/include/c++/5/bits/functional_hash.h" 3
template< class _Result, class _Arg> 
# 50
struct __hash_base { 
# 52
typedef _Result result_type; 
# 53
typedef _Arg argument_type; 
# 54
}; 
# 57
template< class _Tp> struct hash; 
# 61
template< class _Tp> 
# 62
struct hash< _Tp *>  : public __hash_base< unsigned long, _Tp *>  { 
# 65
::std::size_t operator()(_Tp *__p) const noexcept 
# 66
{ return reinterpret_cast< ::std::size_t>(__p); } 
# 67
}; 
# 80 "/usr/include/c++/5/bits/functional_hash.h" 3
template<> struct hash< bool>  : public __hash_base< unsigned long, bool>  { size_t operator()(bool __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 83
template<> struct hash< char>  : public __hash_base< unsigned long, char>  { size_t operator()(char __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 86
template<> struct hash< signed char>  : public __hash_base< unsigned long, signed char>  { size_t operator()(signed char __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 89
template<> struct hash< unsigned char>  : public __hash_base< unsigned long, unsigned char>  { size_t operator()(unsigned char __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 92
template<> struct hash< wchar_t>  : public __hash_base< unsigned long, wchar_t>  { size_t operator()(wchar_t __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 95
template<> struct hash< char16_t>  : public __hash_base< unsigned long, char16_t>  { size_t operator()(char16_t __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 98
template<> struct hash< char32_t>  : public __hash_base< unsigned long, char32_t>  { size_t operator()(char32_t __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 101
template<> struct hash< short>  : public __hash_base< unsigned long, short>  { size_t operator()(short __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 104
template<> struct hash< int>  : public __hash_base< unsigned long, int>  { size_t operator()(int __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 107
template<> struct hash< long>  : public __hash_base< unsigned long, long>  { size_t operator()(long __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 110
template<> struct hash< long long>  : public __hash_base< unsigned long, long long>  { size_t operator()(long long __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 113
template<> struct hash< unsigned short>  : public __hash_base< unsigned long, unsigned short>  { size_t operator()(unsigned short __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 116
template<> struct hash< unsigned>  : public __hash_base< unsigned long, unsigned>  { size_t operator()(unsigned __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 119
template<> struct hash< unsigned long>  : public __hash_base< unsigned long, unsigned long>  { size_t operator()(unsigned long __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 122
template<> struct hash< unsigned long long>  : public __hash_base< unsigned long, unsigned long long>  { size_t operator()(unsigned long long __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 126
struct _Hash_impl { 
# 129
static size_t hash(const void *__ptr, size_t __clength, size_t 
# 130
__seed = static_cast< size_t>(3339675911UL)) 
# 131
{ return _Hash_bytes(__ptr, __clength, __seed); } 
# 133
template< class _Tp> static size_t 
# 135
hash(const _Tp &__val) 
# 136
{ return hash(&__val, sizeof(__val)); } 
# 138
template< class _Tp> static size_t 
# 140
__hash_combine(const _Tp &__val, size_t __hash) 
# 141
{ return hash(&__val, sizeof(__val), __hash); } 
# 142
}; 
# 144
struct _Fnv_hash_impl { 
# 147
static size_t hash(const void *__ptr, size_t __clength, size_t 
# 148
__seed = static_cast< size_t>(2166136261UL)) 
# 149
{ return _Fnv_hash_bytes(__ptr, __clength, __seed); } 
# 151
template< class _Tp> static size_t 
# 153
hash(const _Tp &__val) 
# 154
{ return hash(&__val, sizeof(__val)); } 
# 156
template< class _Tp> static size_t 
# 158
__hash_combine(const _Tp &__val, size_t __hash) 
# 159
{ return hash(&__val, sizeof(__val), __hash); } 
# 160
}; 
# 164
template<> struct hash< float>  : public __hash_base< unsigned long, float>  { 
# 167
size_t operator()(float __val) const noexcept 
# 168
{ 
# 170
return (__val != (0.0F)) ? std::_Hash_impl::hash(__val) : (0); 
# 171
} 
# 172
}; 
# 176
template<> struct hash< double>  : public __hash_base< unsigned long, double>  { 
# 179
size_t operator()(double __val) const noexcept 
# 180
{ 
# 182
return (__val != (0.0)) ? std::_Hash_impl::hash(__val) : (0); 
# 183
} 
# 184
}; 
# 188
template<> struct hash< long double>  : public __hash_base< unsigned long, long double>  { 
# 191
__attribute((__pure__)) size_t 
# 192
operator()(long double __val) const noexcept; 
# 193
}; 
# 201
template< class _Hash> 
# 202
struct __is_fast_hash : public true_type { 
# 203
}; 
# 206
template<> struct __is_fast_hash< hash< long double> >  : public false_type { 
# 207
}; 
# 210
}
# 5473 "/usr/include/c++/5/bits/basic_string.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 5482
template<> struct hash< __cxx11::basic_string< char, char_traits< char> , allocator< char> > >  : public __hash_base< unsigned long, __cxx11::basic_string< char, char_traits< char> , allocator< char> > >  { 
# 5486
size_t operator()(const __cxx11::string &__s) const noexcept 
# 5487
{ return std::_Hash_impl::hash(__s.data(), __s.length()); } 
# 5488
}; 
# 5491
template<> struct __is_fast_hash< hash< __cxx11::basic_string< char, char_traits< char> , allocator< char> > > >  : public false_type { 
# 5492
}; 
# 5497
template<> struct hash< __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > >  : public __hash_base< unsigned long, __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > >  { 
# 5501
size_t operator()(const __cxx11::wstring &__s) const noexcept 
# 5502
{ return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t)); 
# 5503
} 
# 5504
}; 
# 5507
template<> struct __is_fast_hash< hash< __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > > >  : public false_type { 
# 5508
}; 
# 5515
template<> struct hash< __cxx11::basic_string< char16_t, char_traits< char16_t> , allocator< char16_t> > >  : public __hash_base< unsigned long, __cxx11::basic_string< char16_t, char_traits< char16_t> , allocator< char16_t> > >  { 
# 5519
size_t operator()(const __cxx11::u16string &__s) const noexcept 
# 5520
{ return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t)); 
# 5521
} 
# 5522
}; 
# 5525
template<> struct __is_fast_hash< hash< __cxx11::basic_string< char16_t, char_traits< char16_t> , allocator< char16_t> > > >  : public false_type { 
# 5526
}; 
# 5530
template<> struct hash< __cxx11::basic_string< char32_t, char_traits< char32_t> , allocator< char32_t> > >  : public __hash_base< unsigned long, __cxx11::basic_string< char32_t, char_traits< char32_t> , allocator< char32_t> > >  { 
# 5534
size_t operator()(const __cxx11::u32string &__s) const noexcept 
# 5535
{ return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t)); 
# 5536
} 
# 5537
}; 
# 5540
template<> struct __is_fast_hash< hash< __cxx11::basic_string< char32_t, char_traits< char32_t> , allocator< char32_t> > > >  : public false_type { 
# 5541
}; 
# 5583 "/usr/include/c++/5/bits/basic_string.h" 3
}
# 46 "/usr/include/c++/5/bits/basic_string.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 52
template< class _CharT, class _Traits, class _Alloc> const typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 54
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::npos; 
# 56
template< class _CharT, class _Traits, class _Alloc> void 
# 59
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::swap(basic_string &__s) noexcept 
# 60
{ 
# 61
if (this == (&__s)) { 
# 62
return; }  
# 67
std::__alloc_swap< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::_S_do_it(this->_M_get_allocator(), (__s._M_get_allocator())); 
# 70
if (_M_is_local()) { 
# 71
if ((__s._M_is_local())) 
# 72
{ 
# 73
if (length() && (__s.length())) 
# 74
{ 
# 75
_CharT __tmp_data[(_S_local_capacity) + 1]; 
# 76
traits_type::copy(__tmp_data, (__s._M_local_buf), (_S_local_capacity) + 1); 
# 78
traits_type::copy((__s._M_local_buf), __cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (_S_local_capacity) + 1); 
# 80
traits_type::copy(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, __tmp_data, (_S_local_capacity) + 1); 
# 82
} else { 
# 83
if ((__s.length())) 
# 84
{ 
# 85
traits_type::copy(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (__s._M_local_buf), (_S_local_capacity) + 1); 
# 87
_M_length((__s.length())); 
# 88
(__s._M_set_length(0)); 
# 89
return; 
# 90
} else { 
# 91
if (length()) 
# 92
{ 
# 93
traits_type::copy((__s._M_local_buf), __cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (_S_local_capacity) + 1); 
# 95
(__s._M_length(length())); 
# 96
_M_set_length(0); 
# 97
return; 
# 98
}  }  }  
# 99
} else 
# 101
{ 
# 102
const size_type __tmp_capacity = ((__s._M_allocated_capacity)); 
# 103
traits_type::copy((__s._M_local_buf), __cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (_S_local_capacity) + 1); 
# 105
_M_data((__s._M_data())); 
# 106
(__s._M_data((__s._M_local_buf))); 
# 107
_M_capacity(__tmp_capacity); 
# 108
}  } else 
# 110
{ 
# 111
const size_type __tmp_capacity = __cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_allocated_capacity; 
# 112
if ((__s._M_is_local())) 
# 113
{ 
# 114
traits_type::copy(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (__s._M_local_buf), (_S_local_capacity) + 1); 
# 116
(__s._M_data(_M_data())); 
# 117
_M_data(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf); 
# 118
} else 
# 120
{ 
# 121
pointer __tmp_ptr = _M_data(); 
# 122
_M_data((__s._M_data())); 
# 123
(__s._M_data(__tmp_ptr)); 
# 124
_M_capacity((__s._M_allocated_capacity)); 
# 125
}  
# 126
(__s._M_capacity(__tmp_capacity)); 
# 127
}  
# 129
const size_type __tmp_length = length(); 
# 130
_M_length((__s.length())); 
# 131
(__s._M_length(__tmp_length)); 
# 132
} 
# 134
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::pointer 
# 137
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_create(size_type &__capacity, size_type __old_capacity) 
# 138
{ 
# 141
if (__capacity > max_size()) { 
# 142
std::__throw_length_error("basic_string::_M_create"); }  
# 147
if ((__capacity > __old_capacity) && (__capacity < (2 * __old_capacity))) 
# 148
{ 
# 149
__capacity = (2 * __old_capacity); 
# 151
if (__capacity > max_size()) { 
# 152
__capacity = max_size(); }  
# 153
}  
# 157
return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1); 
# 158
} 
# 164
template< class _CharT, class _Traits, class _Alloc> 
# 165
template< class _InIterator> void 
# 168
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_construct(_InIterator __beg, _InIterator __end, input_iterator_tag) 
# 170
{ 
# 171
size_type __len = (0); 
# 172
size_type __capacity = ((size_type)(_S_local_capacity)); 
# 174
while ((__beg != __end) && (__len < __capacity)) 
# 175
{ 
# 176
(_M_data()[__len++]) = (*__beg); 
# 177
++__beg; 
# 178
}  
# 180
try 
# 181
{ 
# 182
while (__beg != __end) 
# 183
{ 
# 184
if (__len == __capacity) 
# 185
{ 
# 187
__capacity = (__len + 1); 
# 188
pointer __another = _M_create(__capacity, __len); 
# 189
(this->_S_copy(__another, _M_data(), __len)); 
# 190
_M_dispose(); 
# 191
_M_data(__another); 
# 192
_M_capacity(__capacity); 
# 193
}  
# 194
(_M_data()[__len++]) = (*__beg); 
# 195
++__beg; 
# 196
}  
# 197
} 
# 198
catch (...) 
# 199
{ 
# 200
_M_dispose(); 
# 201
throw; 
# 202
}  
# 204
_M_set_length(__len); 
# 205
} 
# 207
template< class _CharT, class _Traits, class _Alloc> 
# 208
template< class _InIterator> void 
# 211
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_construct(_InIterator __beg, _InIterator __end, forward_iterator_tag) 
# 213
{ 
# 215
if (__gnu_cxx::__is_null_pointer(__beg) && (__beg != __end)) { 
# 216
std::__throw_logic_error("basic_string::_M_construct null not valid"); }  
# 219
size_type __dnew = static_cast< size_type>(std::distance(__beg, __end)); 
# 221
if (__dnew > ((size_type)(_S_local_capacity))) 
# 222
{ 
# 223
_M_data(_M_create(__dnew, (size_type)0)); 
# 224
_M_capacity(__dnew); 
# 225
}  
# 228
try 
# 229
{ (this->_S_copy_chars(_M_data(), __beg, __end)); } 
# 230
catch (...) 
# 231
{ 
# 232
_M_dispose(); 
# 233
throw; 
# 234
}  
# 236
_M_set_length(__dnew); 
# 237
} 
# 239
template< class _CharT, class _Traits, class _Alloc> void 
# 242
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_construct(size_type __n, _CharT __c) 
# 243
{ 
# 244
if (__n > ((size_type)(_S_local_capacity))) 
# 245
{ 
# 246
_M_data(_M_create(__n, (size_type)0)); 
# 247
_M_capacity(__n); 
# 248
}  
# 250
if (__n) { 
# 251
(this->_S_assign(_M_data(), __n, __c)); }  
# 253
_M_set_length(__n); 
# 254
} 
# 256
template< class _CharT, class _Traits, class _Alloc> void 
# 259
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_assign(const basic_string &__str) 
# 260
{ 
# 261
if (this != (&__str)) 
# 262
{ 
# 263
const size_type __rsize = (__str.length()); 
# 264
const size_type __capacity = capacity(); 
# 266
if (__rsize > __capacity) 
# 267
{ 
# 268
size_type __new_capacity = __rsize; 
# 269
pointer __tmp = _M_create(__new_capacity, __capacity); 
# 270
_M_dispose(); 
# 271
_M_data(__tmp); 
# 272
_M_capacity(__new_capacity); 
# 273
}  
# 275
if (__rsize) { 
# 276
(this->_S_copy(_M_data(), (__str._M_data()), __rsize)); }  
# 278
_M_set_length(__rsize); 
# 279
}  
# 280
} 
# 282
template< class _CharT, class _Traits, class _Alloc> void 
# 285
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::reserve(size_type __res) 
# 286
{ 
# 288
if (__res < length()) { 
# 289
__res = length(); }  
# 291
const size_type __capacity = capacity(); 
# 292
if (__res != __capacity) 
# 293
{ 
# 294
if ((__res > __capacity) || (__res > ((size_type)(_S_local_capacity)))) 
# 296
{ 
# 297
pointer __tmp = _M_create(__res, __capacity); 
# 298
(this->_S_copy(__tmp, _M_data(), length() + 1)); 
# 299
_M_dispose(); 
# 300
_M_data(__tmp); 
# 301
_M_capacity(__res); 
# 302
} else { 
# 303
if (!_M_is_local()) 
# 304
{ 
# 305
(this->_S_copy(this->_M_local_data(), _M_data(), length() + 1)); 
# 306
_M_destroy(__capacity); 
# 307
_M_data(this->_M_local_data()); 
# 308
}  }  
# 309
}  
# 310
} 
# 312
template< class _CharT, class _Traits, class _Alloc> void 
# 315
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_mutate(size_type __pos, size_type __len1, const _CharT *__s, size_type 
# 316
__len2) 
# 317
{ 
# 318
const size_type __how_much = (length() - __pos) - __len1; 
# 320
size_type __new_capacity = (length() + __len2) - __len1; 
# 321
pointer __r = _M_create(__new_capacity, capacity()); 
# 323
if (__pos) { 
# 324
(this->_S_copy(__r, _M_data(), __pos)); }  
# 325
if (__s && __len2) { 
# 326
(this->_S_copy(__r + __pos, __s, __len2)); }  
# 327
if (__how_much) { 
# 328
(this->_S_copy((__r + __pos) + __len2, (_M_data() + __pos) + __len1, __how_much)); }  
# 331
_M_dispose(); 
# 332
_M_data(__r); 
# 333
_M_capacity(__new_capacity); 
# 334
} 
# 336
template< class _CharT, class _Traits, class _Alloc> void 
# 339
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_erase(size_type __pos, size_type __n) 
# 340
{ 
# 341
const size_type __how_much = (length() - __pos) - __n; 
# 343
if (__how_much && __n) { 
# 344
(this->_S_move(_M_data() + __pos, (_M_data() + __pos) + __n, __how_much)); }  
# 346
_M_set_length(length() - __n); 
# 347
} 
# 349
template< class _CharT, class _Traits, class _Alloc> void 
# 352
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::resize(size_type __n, _CharT __c) 
# 353
{ 
# 354
const size_type __size = this->size(); 
# 355
if (__size < __n) { 
# 356
(this->append(__n - __size, __c)); } else { 
# 357
if (__n < __size) { 
# 358
this->_M_erase(__n, __size - __n); }  }  
# 359
} 
# 361
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 364
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_append(const _CharT *__s, size_type __n) 
# 365
{ 
# 366
const size_type __len = __n + this->size(); 
# 368
if (__len <= this->capacity()) 
# 369
{ 
# 370
if (__n) { 
# 371
(this->_S_copy((this->_M_data()) + this->size(), __s, __n)); }  
# 372
} else { 
# 374
this->_M_mutate(this->size(), (size_type)0, __s, __n); }  
# 376
this->_M_set_length(__len); 
# 377
return *this; 
# 378
} 
# 380
template< class _CharT, class _Traits, class _Alloc> 
# 381
template< class _InputIterator> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 384
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator 
# 385
__k1, _InputIterator __k2, __false_type) 
# 387
{ 
# 388
const basic_string __s(__k1, __k2); 
# 389
const size_type __n1 = __i2 - __i1; 
# 390
return _M_replace(__i1 - this->begin(), __n1, (__s._M_data()), (__s.size())); 
# 392
} 
# 394
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 397
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT 
# 398
__c) 
# 399
{ 
# 400
_M_check_length(__n1, __n2, "basic_string::_M_replace_aux"); 
# 402
const size_type __old_size = this->size(); 
# 403
const size_type __new_size = (__old_size + __n2) - __n1; 
# 405
if (__new_size <= this->capacity()) 
# 406
{ 
# 407
_CharT *__p = (this->_M_data()) + __pos1; 
# 409
const size_type __how_much = (__old_size - __pos1) - __n1; 
# 410
if (__how_much && (__n1 != __n2)) { 
# 411
(this->_S_move(__p + __n2, __p + __n1, __how_much)); }  
# 412
} else { 
# 414
this->_M_mutate(__pos1, __n1, 0, __n2); }  
# 416
if (__n2) { 
# 417
(this->_S_assign((this->_M_data()) + __pos1, __n2, __c)); }  
# 419
this->_M_set_length(__new_size); 
# 420
return *this; 
# 421
} 
# 423
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 426
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_replace(size_type __pos, size_type __len1, const _CharT *__s, const typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::size_type 
# 427
__len2) 
# 428
{ 
# 429
_M_check_length(__len1, __len2, "basic_string::_M_replace"); 
# 431
const size_type __old_size = this->size(); 
# 432
const size_type __new_size = (__old_size + __len2) - __len1; 
# 434
if (__new_size <= this->capacity()) 
# 435
{ 
# 436
_CharT *__p = (this->_M_data()) + __pos; 
# 438
const size_type __how_much = (__old_size - __pos) - __len1; 
# 439
if (_M_disjunct(__s)) 
# 440
{ 
# 441
if (__how_much && (__len1 != __len2)) { 
# 442
(this->_S_move(__p + __len2, __p + __len1, __how_much)); }  
# 443
if (__len2) { 
# 444
(this->_S_copy(__p, __s, __len2)); }  
# 445
} else 
# 447
{ 
# 449
if (__len2 && (__len2 <= __len1)) { 
# 450
(this->_S_move(__p, __s, __len2)); }  
# 451
if (__how_much && (__len1 != __len2)) { 
# 452
(this->_S_move(__p + __len2, __p + __len1, __how_much)); }  
# 453
if (__len2 > __len1) 
# 454
{ 
# 455
if ((__s + __len2) <= (__p + __len1)) { 
# 456
(this->_S_move(__p, __s, __len2)); } else { 
# 457
if (__s >= (__p + __len1)) { 
# 458
(this->_S_copy(__p, (__s + __len2) - __len1, __len2)); } else 
# 460
{ 
# 461
const size_type __nleft = (__p + __len1) - __s; 
# 462
(this->_S_move(__p, __s, __nleft)); 
# 463
(this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft)); 
# 465
}  }  
# 466
}  
# 467
}  
# 468
} else { 
# 470
this->_M_mutate(__pos, __len1, __s, __len2); }  
# 472
this->_M_set_length(__new_size); 
# 473
return *this; 
# 474
} 
# 476
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 479
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::copy(_CharT *__s, size_type __n, size_type __pos) const 
# 480
{ 
# 481
_M_check(__pos, "basic_string::copy"); 
# 482
__n = _M_limit(__pos, __n); 
# 483
; 
# 484
if (__n) { 
# 485
(_S_copy)(__s, _M_data() + __pos, __n); }  
# 487
return __n; 
# 488
} 
# 1149 "/usr/include/c++/5/bits/basic_string.tcc" 3
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 1151
operator+(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 1152
__rhs) 
# 1153
{ 
# 1154
; 
# 1155
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1156
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1157
const __size_type __len = _Traits::length(__lhs); 
# 1158
__string_type __str; 
# 1159
(__str.reserve(__len + (__rhs.size()))); 
# 1160
(__str.append(__lhs, __len)); 
# 1161
(__str.append(__rhs)); 
# 1162
return __str; 
# 1163
} 
# 1165
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 1167
operator+(_CharT __lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__rhs) 
# 1168
{ 
# 1169
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1170
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1171
__string_type __str; 
# 1172
const __size_type __len = (__rhs.size()); 
# 1173
(__str.reserve(__len + 1)); 
# 1174
(__str.append((__size_type)1, __lhs)); 
# 1175
(__str.append(__rhs)); 
# 1176
return __str; 
# 1177
} 
# 1179
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1182
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find(const _CharT *__s, size_type __pos, size_type __n) const 
# 1183
{ 
# 1184
; 
# 1185
const size_type __size = this->size(); 
# 1186
const _CharT *__data = _M_data(); 
# 1188
if (__n == 0) { 
# 1189
return (__pos <= __size) ? __pos : npos; }  
# 1191
if (__n <= __size) 
# 1192
{ 
# 1193
for (; __pos <= (__size - __n); ++__pos) { 
# 1194
if (traits_type::eq(__data[__pos], __s[0]) && (traits_type::compare((__data + __pos) + 1, __s + 1, __n - 1) == 0)) { 
# 1197
return __pos; }  }  
# 1198
}  
# 1199
return npos; 
# 1200
} 
# 1202
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1205
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find(_CharT __c, size_type __pos) const noexcept 
# 1206
{ 
# 1207
size_type __ret = npos; 
# 1208
const size_type __size = this->size(); 
# 1209
if (__pos < __size) 
# 1210
{ 
# 1211
const _CharT *__data = _M_data(); 
# 1212
const size_type __n = __size - __pos; 
# 1213
const _CharT *__p = traits_type::find(__data + __pos, __n, __c); 
# 1214
if (__p) { 
# 1215
__ret = (__p - __data); }  
# 1216
}  
# 1217
return __ret; 
# 1218
} 
# 1220
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1223
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::rfind(const _CharT *__s, size_type __pos, size_type __n) const 
# 1224
{ 
# 1225
; 
# 1226
const size_type __size = this->size(); 
# 1227
if (__n <= __size) 
# 1228
{ 
# 1229
__pos = std::min((size_type)(__size - __n), __pos); 
# 1230
const _CharT *__data = _M_data(); 
# 1231
do 
# 1232
{ 
# 1233
if (traits_type::compare(__data + __pos, __s, __n) == 0) { 
# 1234
return __pos; }  
# 1235
} 
# 1236
while ((__pos--) > 0); 
# 1237
}  
# 1238
return npos; 
# 1239
} 
# 1241
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1244
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::rfind(_CharT __c, size_type __pos) const noexcept 
# 1245
{ 
# 1246
size_type __size = this->size(); 
# 1247
if (__size) 
# 1248
{ 
# 1249
if ((--__size) > __pos) { 
# 1250
__size = __pos; }  
# 1251
for (++__size; (__size--) > 0;) { 
# 1252
if (traits_type::eq(_M_data()[__size], __c)) { 
# 1253
return __size; }  }  
# 1254
}  
# 1255
return npos; 
# 1256
} 
# 1258
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1261
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_first_of(const _CharT *__s, size_type __pos, size_type __n) const 
# 1262
{ 
# 1263
; 
# 1264
for (; __n && (__pos < this->size()); ++__pos) 
# 1265
{ 
# 1266
const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]); 
# 1267
if (__p) { 
# 1268
return __pos; }  
# 1269
}  
# 1270
return npos; 
# 1271
} 
# 1273
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1276
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_last_of(const _CharT *__s, size_type __pos, size_type __n) const 
# 1277
{ 
# 1278
; 
# 1279
size_type __size = this->size(); 
# 1280
if (__size && __n) 
# 1281
{ 
# 1282
if ((--__size) > __pos) { 
# 1283
__size = __pos; }  
# 1284
do 
# 1285
{ 
# 1286
if (traits_type::find(__s, __n, _M_data()[__size])) { 
# 1287
return __size; }  
# 1288
} 
# 1289
while ((__size--) != 0); 
# 1290
}  
# 1291
return npos; 
# 1292
} 
# 1294
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1297
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_first_not_of(const _CharT *__s, size_type __pos, size_type __n) const 
# 1298
{ 
# 1299
; 
# 1300
for (; __pos < this->size(); ++__pos) { 
# 1301
if (!traits_type::find(__s, __n, _M_data()[__pos])) { 
# 1302
return __pos; }  }  
# 1303
return npos; 
# 1304
} 
# 1306
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1309
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_first_not_of(_CharT __c, size_type __pos) const noexcept 
# 1310
{ 
# 1311
for (; __pos < this->size(); ++__pos) { 
# 1312
if (!traits_type::eq(_M_data()[__pos], __c)) { 
# 1313
return __pos; }  }  
# 1314
return npos; 
# 1315
} 
# 1317
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1320
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_last_not_of(const _CharT *__s, size_type __pos, size_type __n) const 
# 1321
{ 
# 1322
; 
# 1323
size_type __size = this->size(); 
# 1324
if (__size) 
# 1325
{ 
# 1326
if ((--__size) > __pos) { 
# 1327
__size = __pos; }  
# 1328
do 
# 1329
{ 
# 1330
if (!traits_type::find(__s, __n, _M_data()[__size])) { 
# 1331
return __size; }  
# 1332
} 
# 1333
while (__size--); 
# 1334
}  
# 1335
return npos; 
# 1336
} 
# 1338
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1341
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_last_not_of(_CharT __c, size_type __pos) const noexcept 
# 1342
{ 
# 1343
size_type __size = this->size(); 
# 1344
if (__size) 
# 1345
{ 
# 1346
if ((--__size) > __pos) { 
# 1347
__size = __pos; }  
# 1348
do 
# 1349
{ 
# 1350
if (!traits_type::eq(_M_data()[__size], __c)) { 
# 1351
return __size; }  
# 1352
} 
# 1353
while (__size--); 
# 1354
}  
# 1355
return npos; 
# 1356
} 
# 1358
template< class _CharT, class _Traits, class _Alloc> int 
# 1361
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos, size_type __n, const basic_string &__str) const 
# 1362
{ 
# 1363
_M_check(__pos, "basic_string::compare"); 
# 1364
__n = _M_limit(__pos, __n); 
# 1365
const size_type __osize = (__str.size()); 
# 1366
const size_type __len = std::min(__n, __osize); 
# 1367
int __r = traits_type::compare(_M_data() + __pos, (__str.data()), __len); 
# 1368
if (!__r) { 
# 1369
__r = (_S_compare)(__n, __osize); }  
# 1370
return __r; 
# 1371
} 
# 1373
template< class _CharT, class _Traits, class _Alloc> int 
# 1376
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos1, size_type __n1, const basic_string &__str, size_type 
# 1377
__pos2, size_type __n2) const 
# 1378
{ 
# 1379
_M_check(__pos1, "basic_string::compare"); 
# 1380
(__str._M_check(__pos2, "basic_string::compare")); 
# 1381
__n1 = _M_limit(__pos1, __n1); 
# 1382
__n2 = (__str._M_limit(__pos2, __n2)); 
# 1383
const size_type __len = std::min(__n1, __n2); 
# 1384
int __r = traits_type::compare(_M_data() + __pos1, (__str.data()) + __pos2, __len); 
# 1386
if (!__r) { 
# 1387
__r = (_S_compare)(__n1, __n2); }  
# 1388
return __r; 
# 1389
} 
# 1391
template< class _CharT, class _Traits, class _Alloc> int 
# 1394
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(const _CharT *__s) const 
# 1395
{ 
# 1396
; 
# 1397
const size_type __size = this->size(); 
# 1398
const size_type __osize = traits_type::length(__s); 
# 1399
const size_type __len = std::min(__size, __osize); 
# 1400
int __r = traits_type::compare(_M_data(), __s, __len); 
# 1401
if (!__r) { 
# 1402
__r = (_S_compare)(__size, __osize); }  
# 1403
return __r; 
# 1404
} 
# 1406
template< class _CharT, class _Traits, class _Alloc> int 
# 1409
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos, size_type __n1, const _CharT *__s) const 
# 1410
{ 
# 1411
; 
# 1412
_M_check(__pos, "basic_string::compare"); 
# 1413
__n1 = _M_limit(__pos, __n1); 
# 1414
const size_type __osize = traits_type::length(__s); 
# 1415
const size_type __len = std::min(__n1, __osize); 
# 1416
int __r = traits_type::compare(_M_data() + __pos, __s, __len); 
# 1417
if (!__r) { 
# 1418
__r = (_S_compare)(__n1, __osize); }  
# 1419
return __r; 
# 1420
} 
# 1422
template< class _CharT, class _Traits, class _Alloc> int 
# 1425
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos, size_type __n1, const _CharT *__s, size_type 
# 1426
__n2) const 
# 1427
{ 
# 1428
; 
# 1429
_M_check(__pos, "basic_string::compare"); 
# 1430
__n1 = _M_limit(__pos, __n1); 
# 1431
const size_type __len = std::min(__n1, __n2); 
# 1432
int __r = traits_type::compare(_M_data() + __pos, __s, __len); 
# 1433
if (!__r) { 
# 1434
__r = (_S_compare)(__n1, __n2); }  
# 1435
return __r; 
# 1436
} 
# 1439
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &
# 1441
operator>>(basic_istream< _CharT, _Traits>  &__in, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 1442
__str) 
# 1443
{ 
# 1444
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1445
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1446
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1447
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 1448
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1449
typedef ctype< _CharT>  __ctype_type; 
# 1450
typedef typename ctype< _CharT> ::ctype_base __ctype_base; 
# 1452
__size_type __extracted = (0); 
# 1453
typename basic_istream< _CharT, _Traits> ::ios_base::iostate __err = (__ios_base::goodbit); 
# 1454
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, false); 
# 1455
if (__cerb) 
# 1456
{ 
# 1457
try 
# 1458
{ 
# 1460
(__str.erase()); 
# 1461
_CharT __buf[128]; 
# 1462
__size_type __len = (0); 
# 1463
const streamsize __w = (__in.width()); 
# 1464
const __size_type __n = (__w > (0)) ? static_cast< __size_type>(__w) : (__str.max_size()); 
# 1466
const __ctype_type &__ct = use_facet< ctype< _CharT> > ((__in.getloc())); 
# 1467
const __int_type __eof = _Traits::eof(); 
# 1468
__int_type __c = ((__in.rdbuf())->sgetc()); 
# 1470
while ((__extracted < __n) && (!_Traits::eq_int_type(__c, __eof)) && (!(__ct.is(__ctype_base::space, _Traits::to_char_type(__c))))) 
# 1474
{ 
# 1475
if (__len == (sizeof(__buf) / sizeof(_CharT))) 
# 1476
{ 
# 1477
(__str.append(__buf, sizeof(__buf) / sizeof(_CharT))); 
# 1478
__len = 0; 
# 1479
}  
# 1480
(__buf[__len++]) = _Traits::to_char_type(__c); 
# 1481
++__extracted; 
# 1482
__c = ((__in.rdbuf())->snextc()); 
# 1483
}  
# 1484
(__str.append(__buf, __len)); 
# 1486
if (_Traits::eq_int_type(__c, __eof)) { 
# 1487
__err |= __ios_base::eofbit; }  
# 1488
(__in.width(0)); 
# 1489
} 
# 1490
catch (__cxxabiv1::__forced_unwind &) 
# 1491
{ 
# 1492
(__in._M_setstate(__ios_base::badbit)); 
# 1493
throw; 
# 1494
} 
# 1495
catch (...) 
# 1496
{ 
# 1500
(__in._M_setstate(__ios_base::badbit)); 
# 1501
}  
# 1502
}  
# 1504
if (!__extracted) { 
# 1505
__err |= __ios_base::failbit; }  
# 1506
if (__err) { 
# 1507
(__in.setstate(__err)); }  
# 1508
return __in; 
# 1509
} 
# 1511
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &
# 1513
getline(basic_istream< _CharT, _Traits>  &__in, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 1514
__str, _CharT __delim) 
# 1515
{ 
# 1516
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1517
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1518
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1519
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 1520
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1522
__size_type __extracted = (0); 
# 1523
const __size_type __n = (__str.max_size()); 
# 1524
typename basic_istream< _CharT, _Traits> ::ios_base::iostate __err = (__ios_base::goodbit); 
# 1525
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, true); 
# 1526
if (__cerb) 
# 1527
{ 
# 1528
try 
# 1529
{ 
# 1530
(__str.erase()); 
# 1531
const __int_type __idelim = _Traits::to_int_type(__delim); 
# 1532
const __int_type __eof = _Traits::eof(); 
# 1533
__int_type __c = ((__in.rdbuf())->sgetc()); 
# 1535
while ((__extracted < __n) && (!_Traits::eq_int_type(__c, __eof)) && (!_Traits::eq_int_type(__c, __idelim))) 
# 1538
{ 
# 1539
__str += _Traits::to_char_type(__c); 
# 1540
++__extracted; 
# 1541
__c = ((__in.rdbuf())->snextc()); 
# 1542
}  
# 1544
if (_Traits::eq_int_type(__c, __eof)) { 
# 1545
__err |= __ios_base::eofbit; } else { 
# 1546
if (_Traits::eq_int_type(__c, __idelim)) 
# 1547
{ 
# 1548
++__extracted; 
# 1549
((__in.rdbuf())->sbumpc()); 
# 1550
} else { 
# 1552
__err |= __ios_base::failbit; }  }  
# 1553
} 
# 1554
catch (__cxxabiv1::__forced_unwind &) 
# 1555
{ 
# 1556
(__in._M_setstate(__ios_base::badbit)); 
# 1557
throw; 
# 1558
} 
# 1559
catch (...) 
# 1560
{ 
# 1564
(__in._M_setstate(__ios_base::badbit)); 
# 1565
}  
# 1566
}  
# 1567
if (!__extracted) { 
# 1568
__err |= __ios_base::failbit; }  
# 1569
if (__err) { 
# 1570
(__in.setstate(__err)); }  
# 1571
return __in; 
# 1572
} 
# 1577
extern template class __cxx11::basic_string< char, char_traits< char> , allocator< char> > ;
# 1578
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str);
# 1581
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, const __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str);
# 1584
extern template basic_istream< char>  &getline(basic_istream< char>  & __is, __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str, char __delim);
# 1587
extern template basic_istream< char>  &getline(basic_istream< char>  & __is, __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str);
# 1592
extern template class __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > ;
# 1593
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> >  & __str);
# 1596
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, const __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> >  & __str);
# 1599
extern template basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> >  & __str, wchar_t __delim);
# 1602
extern template basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> >  & __str);
# 1609
}
# 43 "/usr/include/c++/5/bits/locale_classes.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 62 "/usr/include/c++/5/bits/locale_classes.h" 3
class locale { 
# 67
public: typedef int category; 
# 70
class facet; 
# 71
class id; 
# 72
class _Impl; 
# 74
friend class facet; 
# 75
friend class _Impl; 
# 77
template< class _Facet> friend bool has_facet(const locale &) throw(); 
# 81
template< class _Facet> friend const _Facet &use_facet(const locale &); 
# 85
template< class _Cache> friend struct __use_cache; 
# 98 "/usr/include/c++/5/bits/locale_classes.h" 3
static const category none = 0; 
# 99
static const category ctype = (1L << 0); 
# 100
static const category numeric = (1L << 1); 
# 101
static const category collate = (1L << 2); 
# 102
static const category time = (1L << 3); 
# 103
static const category monetary = (1L << 4); 
# 104
static const category messages = (1L << 5); 
# 105
static const category all = (((((ctype | numeric) | collate) | time) | monetary) | messages); 
# 117 "/usr/include/c++/5/bits/locale_classes.h" 3
locale() throw(); 
# 126 "/usr/include/c++/5/bits/locale_classes.h" 3
locale(const locale & __other) throw(); 
# 137 "/usr/include/c++/5/bits/locale_classes.h" 3
explicit locale(const char * __s); 
# 151 "/usr/include/c++/5/bits/locale_classes.h" 3
locale(const locale & __base, const char * __s, category __cat); 
# 163 "/usr/include/c++/5/bits/locale_classes.h" 3
explicit locale(const __cxx11::string &__s) : locale(__s.c_str()) { } 
# 177 "/usr/include/c++/5/bits/locale_classes.h" 3
locale(const locale &__base, const __cxx11::string &__s, category __cat) : locale(__base, __s.c_str(), __cat) 
# 178
{ } 
# 192 "/usr/include/c++/5/bits/locale_classes.h" 3
locale(const locale & __base, const locale & __add, category __cat); 
# 205 "/usr/include/c++/5/bits/locale_classes.h" 3
template< class _Facet> locale(const locale & __other, _Facet * __f); 
# 209
~locale() throw(); 
# 220 "/usr/include/c++/5/bits/locale_classes.h" 3
const locale &operator=(const locale & __other) throw(); 
# 234 "/usr/include/c++/5/bits/locale_classes.h" 3
template< class _Facet> locale combine(const locale & __other) const; 
# 243
__attribute((__abi_tag__("cxx11"))) __cxx11::string 
# 245
name() const; 
# 255 "/usr/include/c++/5/bits/locale_classes.h" 3
bool operator==(const locale & __other) const throw(); 
# 264
bool operator!=(const locale &__other) const throw() 
# 265
{ return !this->operator==(__other); } 
# 282 "/usr/include/c++/5/bits/locale_classes.h" 3
template< class _Char, class _Traits, class _Alloc> bool operator()(const __cxx11::basic_string< _Char, _Traits, _Alloc>  & __s1, const __cxx11::basic_string< _Char, _Traits, _Alloc>  & __s2) const; 
# 299 "/usr/include/c++/5/bits/locale_classes.h" 3
static locale global(const locale & __loc); 
# 305
static const locale &classic(); 
# 309
private: _Impl *_M_impl; 
# 312
static _Impl *_S_classic; 
# 315
static _Impl *_S_global; 
# 321
static const char *const *const _S_categories; 
# 333 "/usr/include/c++/5/bits/locale_classes.h" 3
enum { _S_categories_size = 12}; 
# 336
static __gthread_once_t _S_once; 
# 340
explicit locale(_Impl *) throw(); 
# 343
static void _S_initialize(); 
# 346
static void _S_initialize_once() throw(); 
# 349
static category _S_normalize_category(category); 
# 352
void _M_coalesce(const locale & __base, const locale & __add, category __cat); 
# 355
static const id *const _S_twinned_facets[]; 
# 357
}; 
# 371 "/usr/include/c++/5/bits/locale_classes.h" 3
class locale::facet { 
# 374
friend class locale; 
# 375
friend class _Impl; 
# 377
mutable _Atomic_word _M_refcount; 
# 380
static __c_locale _S_c_locale; 
# 383
static const char _S_c_name[2]; 
# 386
static __gthread_once_t _S_once; 
# 390
static void _S_initialize_once(); 
# 403 "/usr/include/c++/5/bits/locale_classes.h" 3
protected: explicit facet(size_t __refs = 0) throw() : _M_refcount((__refs) ? 1 : 0) 
# 404
{ } 
# 408
virtual ~facet(); 
# 411
static void _S_create_c_locale(__c_locale & __cloc, const char * __s, __c_locale __old = 0); 
# 415
static __c_locale _S_clone_c_locale(__c_locale & __cloc) throw(); 
# 418
static void _S_destroy_c_locale(__c_locale & __cloc); 
# 421
static __c_locale _S_lc_ctype_c_locale(__c_locale __cloc, const char * __s); 
# 426
static __c_locale _S_get_c_locale(); 
# 428
__attribute((const)) static const char *
# 429
_S_get_c_name() throw(); 
# 433
private: void _M_add_reference() const throw() 
# 434
{ __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 
# 437
void _M_remove_reference() const throw() 
# 438
{ 
# 440
; 
# 441
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1) == 1) 
# 442
{ 
# 443
; 
# 444
try 
# 445
{ delete this; } 
# 446
catch (...) 
# 447
{ }  
# 448
}  
# 449
} 
# 451
facet(const facet &); 
# 454
facet &operator=(const facet &); 
# 456
class __shim; 
# 458
const facet *_M_sso_shim(const id *) const; 
# 459
const facet *_M_cow_shim(const id *) const; 
# 460
}; 
# 474 "/usr/include/c++/5/bits/locale_classes.h" 3
class locale::id { 
# 477
friend class locale; 
# 478
friend class _Impl; 
# 480
template< class _Facet> friend const _Facet &use_facet(const locale &); 
# 484
template< class _Facet> friend bool has_facet(const locale &) throw(); 
# 491
mutable size_t _M_index; 
# 494
static _Atomic_word _S_refcount; 
# 497
void operator=(const id &); 
# 499
id(const id &); 
# 505
public: id() { } 
# 508
size_t _M_id() const throw(); 
# 509
}; 
# 513
class locale::_Impl { 
# 517
friend class locale; 
# 518
friend class facet; 
# 520
template< class _Facet> friend bool has_facet(const locale &) throw(); 
# 524
template< class _Facet> friend const _Facet &use_facet(const locale &); 
# 528
template< class _Cache> friend struct __use_cache; 
# 533
_Atomic_word _M_refcount; 
# 534
const facet **_M_facets; 
# 535
size_t _M_facets_size; 
# 536
const facet **_M_caches; 
# 537
char **_M_names; 
# 538
static const id *const _S_id_ctype[]; 
# 539
static const id *const _S_id_numeric[]; 
# 540
static const id *const _S_id_collate[]; 
# 541
static const id *const _S_id_time[]; 
# 542
static const id *const _S_id_monetary[]; 
# 543
static const id *const _S_id_messages[]; 
# 544
static const id *const *const _S_facet_categories[]; 
# 547
void _M_add_reference() throw() 
# 548
{ __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 
# 551
void _M_remove_reference() throw() 
# 552
{ 
# 554
; 
# 555
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1) == 1) 
# 556
{ 
# 557
; 
# 558
try 
# 559
{ delete this; } 
# 560
catch (...) 
# 561
{ }  
# 562
}  
# 563
} 
# 565
_Impl(const _Impl &, size_t); 
# 566
_Impl(const char *, size_t); 
# 567
_Impl(size_t) throw(); 
# 569
~_Impl() throw(); 
# 571
_Impl(const _Impl &); 
# 574
void operator=(const _Impl &); 
# 577
bool _M_check_same_name() 
# 578
{ 
# 579
bool __ret = true; 
# 580
if ((_M_names)[1]) { 
# 582
for (size_t __i = (0); __ret && (__i < ((_S_categories_size) - 1)); ++__i) { 
# 583
__ret = (__builtin_strcmp((_M_names)[__i], (_M_names)[__i + (1)]) == 0); }  }  
# 584
return __ret; 
# 585
} 
# 588
void _M_replace_categories(const _Impl *, category); 
# 591
void _M_replace_category(const _Impl *, const id *const *); 
# 594
void _M_replace_facet(const _Impl *, const id *); 
# 597
void _M_install_facet(const id *, const facet *); 
# 599
template< class _Facet> void 
# 601
_M_init_facet(_Facet *__facet) 
# 602
{ this->_M_install_facet(&_Facet::id, __facet); } 
# 604
template< class _Facet> void 
# 606
_M_init_facet_unchecked(_Facet *__facet) 
# 607
{ 
# 608
(__facet->_M_add_reference()); 
# 609
((_M_facets)[(_Facet::id._M_id)()]) = __facet; 
# 610
} 
# 613
void _M_install_cache(const facet *, size_t); 
# 615
void _M_init_extra(facet **); 
# 616
void _M_init_extra(void *, void *, const char *, const char *); 
# 617
}; 
# 632 "/usr/include/c++/5/bits/locale_classes.h" 3
template< class _CharT> 
# 633
class __cxx11::collate : public locale::facet { 
# 639
public: typedef _CharT char_type; 
# 640
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 646
protected: __c_locale _M_c_locale_collate; 
# 650
public: static locale::id id; 
# 660 "/usr/include/c++/5/bits/locale_classes.h" 3
explicit collate(size_t __refs = 0) : locale::facet(__refs), _M_c_locale_collate(_S_get_c_locale()) 
# 662
{ } 
# 674 "/usr/include/c++/5/bits/locale_classes.h" 3
explicit collate(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc)) 
# 676
{ } 
# 691 "/usr/include/c++/5/bits/locale_classes.h" 3
int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *
# 692
__lo2, const _CharT *__hi2) const 
# 693
{ return this->do_compare(__lo1, __hi1, __lo2, __hi2); } 
# 710 "/usr/include/c++/5/bits/locale_classes.h" 3
string_type transform(const _CharT *__lo, const _CharT *__hi) const 
# 711
{ return this->do_transform(__lo, __hi); } 
# 724 "/usr/include/c++/5/bits/locale_classes.h" 3
long hash(const _CharT *__lo, const _CharT *__hi) const 
# 725
{ return this->do_hash(__lo, __hi); } 
# 729
int _M_compare(const _CharT *, const _CharT *) const throw(); 
# 732
size_t _M_transform(_CharT *, const _CharT *, size_t) const throw(); 
# 737
protected: virtual ~collate() 
# 738
{ _S_destroy_c_locale(_M_c_locale_collate); } 
# 753 "/usr/include/c++/5/bits/locale_classes.h" 3
virtual int do_compare(const _CharT * __lo1, const _CharT * __hi1, const _CharT * __lo2, const _CharT * __hi2) const; 
# 767 "/usr/include/c++/5/bits/locale_classes.h" 3
virtual string_type do_transform(const _CharT * __lo, const _CharT * __hi) const; 
# 780 "/usr/include/c++/5/bits/locale_classes.h" 3
virtual long do_hash(const _CharT * __lo, const _CharT * __hi) const; 
# 781
}; 
# 783
template< class _CharT> locale::id 
# 784
__cxx11::collate< _CharT> ::id; 
# 789
template<> int collate< char> ::_M_compare(const char *, const char *) const throw(); 
# 793
template<> size_t collate< char> ::_M_transform(char *, const char *, size_t) const throw(); 
# 798
template<> int collate< wchar_t> ::_M_compare(const wchar_t *, const wchar_t *) const throw(); 
# 802
template<> size_t collate< wchar_t> ::_M_transform(wchar_t *, const wchar_t *, size_t) const throw(); 
# 806
template< class _CharT> 
# 807
class __cxx11::collate_byname : public collate< _CharT>  { 
# 812
public: typedef _CharT char_type; 
# 813
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 817
explicit collate_byname(const char *__s, ::std::size_t __refs = 0) : ::std::__cxx11::collate< _CharT> (__refs) 
# 819
{ 
# 820
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 822
{ 
# 823
(this->_S_destroy_c_locale((this->_M_c_locale_collate))); 
# 824
(this->_S_create_c_locale((this->_M_c_locale_collate), __s)); 
# 825
}  
# 826
} 
# 830
explicit collate_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs = 0) : collate_byname(__s.c_str(), __refs) 
# 831
{ } 
# 836
protected: virtual ~collate_byname() { } 
# 837
}; 
# 840
}
# 39 "/usr/include/c++/5/bits/locale_classes.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _Facet> 
# 45
locale::locale(const locale &__other, _Facet *__f) 
# 46
{ 
# 47
(_M_impl) = (new _Impl(*(__other._M_impl), 1)); 
# 49
try 
# 50
{ (_M_impl)->_M_install_facet(&_Facet::id, __f); } 
# 51
catch (...) 
# 52
{ 
# 53
(_M_impl)->_M_remove_reference(); 
# 54
throw; 
# 55
}  
# 56
delete [] (((_M_impl)->_M_names)[0]); 
# 57
(((_M_impl)->_M_names)[0]) = (0); 
# 58
} 
# 60
template< class _Facet> locale 
# 63
locale::combine(const locale &__other) const 
# 64
{ 
# 65
_Impl *__tmp = new _Impl(*(_M_impl), 1); 
# 66
try 
# 67
{ 
# 68
__tmp->_M_replace_facet(__other._M_impl, &_Facet::id); 
# 69
} 
# 70
catch (...) 
# 71
{ 
# 72
__tmp->_M_remove_reference(); 
# 73
throw; 
# 74
}  
# 75
return ((locale)(__tmp)); 
# 76
} 
# 78
template< class _CharT, class _Traits, class _Alloc> bool 
# 81
locale::operator()(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__s1, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 82
__s2) const 
# 83
{ 
# 84
typedef __cxx11::collate< _CharT>  __collate_type; 
# 85
const __collate_type &__collate = use_facet< __cxx11::collate< _CharT> > (*this); 
# 86
return (__collate.compare((__s1.data()), (__s1.data()) + (__s1.length()), (__s2.data()), (__s2.data()) + (__s2.length()))) < 0; 
# 88
} 
# 102 "/usr/include/c++/5/bits/locale_classes.tcc" 3
template< class _Facet> bool 
# 104
has_facet(const locale &__loc) throw() 
# 105
{ 
# 106
const size_t __i = (_Facet::id._M_id)(); 
# 107
const locale::facet **__facets = (__loc._M_impl)->_M_facets; 
# 108
return (__i < ((__loc._M_impl)->_M_facets_size)) && (dynamic_cast< const _Facet *>(__facets[__i])); 
# 114
} 
# 130 "/usr/include/c++/5/bits/locale_classes.tcc" 3
template< class _Facet> const _Facet &
# 132
use_facet(const locale &__loc) 
# 133
{ 
# 134
const size_t __i = (_Facet::id._M_id)(); 
# 135
const locale::facet **__facets = (__loc._M_impl)->_M_facets; 
# 136
if ((__i >= ((__loc._M_impl)->_M_facets_size)) || (!(__facets[__i]))) { 
# 137
__throw_bad_cast(); }  
# 139
return dynamic_cast< const _Facet &>(*(__facets[__i])); 
# 143
} 
# 147
template< class _CharT> int 
# 149
__cxx11::collate< _CharT> ::_M_compare(const _CharT *, const _CharT *) const throw() 
# 150
{ return 0; } 
# 153
template< class _CharT> size_t 
# 155
__cxx11::collate< _CharT> ::_M_transform(_CharT *, const _CharT *, size_t) const throw() 
# 156
{ return 0; } 
# 158
template< class _CharT> int 
# 161
__cxx11::collate< _CharT> ::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *
# 162
__lo2, const _CharT *__hi2) const 
# 163
{ 
# 166
const string_type __one(__lo1, __hi1); 
# 167
const string_type __two(__lo2, __hi2); 
# 169
const _CharT *__p = (__one.c_str()); 
# 170
const _CharT *__pend = (__one.data()) + (__one.length()); 
# 171
const _CharT *__q = (__two.c_str()); 
# 172
const _CharT *__qend = (__two.data()) + (__two.length()); 
# 177
for (; ;) 
# 178
{ 
# 179
const int __res = _M_compare(__p, __q); 
# 180
if (__res) { 
# 181
return __res; }  
# 183
__p += char_traits< _CharT> ::length(__p); 
# 184
__q += char_traits< _CharT> ::length(__q); 
# 185
if ((__p == __pend) && (__q == __qend)) { 
# 186
return 0; } else { 
# 187
if (__p == __pend) { 
# 188
return -1; } else { 
# 189
if (__q == __qend) { 
# 190
return 1; }  }  }  
# 192
__p++; 
# 193
__q++; 
# 194
}  
# 195
} 
# 197
template< class _CharT> typename __cxx11::collate< _CharT> ::string_type 
# 200
__cxx11::collate< _CharT> ::do_transform(const _CharT *__lo, const _CharT *__hi) const 
# 201
{ 
# 202
string_type __ret; 
# 205
const string_type __str(__lo, __hi); 
# 207
const _CharT *__p = (__str.c_str()); 
# 208
const _CharT *__pend = (__str.data()) + (__str.length()); 
# 210
size_t __len = (__hi - __lo) * 2; 
# 212
_CharT *__c = new _CharT [__len]; 
# 214
try 
# 215
{ 
# 219
for (; ;) 
# 220
{ 
# 222
size_t __res = _M_transform(__c, __p, __len); 
# 225
if (__res >= __len) 
# 226
{ 
# 227
__len = (__res + (1)); 
# 228
(delete [] __c), (__c = 0); 
# 229
__c = (new _CharT [__len]); 
# 230
__res = _M_transform(__c, __p, __len); 
# 231
}  
# 233
(__ret.append(__c, __res)); 
# 234
__p += char_traits< _CharT> ::length(__p); 
# 235
if (__p == __pend) { 
# 236
break; }  
# 238
__p++; 
# 239
(__ret.push_back(_CharT())); 
# 240
}  
# 241
} 
# 242
catch (...) 
# 243
{ 
# 244
delete [] __c; 
# 245
throw; 
# 246
}  
# 248
delete [] __c; 
# 250
return __ret; 
# 251
} 
# 253
template< class _CharT> long 
# 256
__cxx11::collate< _CharT> ::do_hash(const _CharT *__lo, const _CharT *__hi) const 
# 257
{ 
# 258
unsigned long __val = (0); 
# 259
for (; __lo < __hi; ++__lo) { 
# 260
__val = ((*__lo) + ((__val << 7) | (__val >> (__gnu_cxx::__numeric_traits_integer< unsigned long> ::__digits - 7)))); }  
# 264
return static_cast< long>(__val); 
# 265
} 
# 270
extern template class __cxx11::collate< char> ;
# 271
extern template class __cxx11::collate_byname< char> ;
# 273
extern template const __cxx11::collate< char>  &use_facet< __cxx11::collate< char> > (const locale &);
# 277
extern template bool has_facet< __cxx11::collate< char> > (const locale &) throw();
# 282
extern template class __cxx11::collate< wchar_t> ;
# 283
extern template class __cxx11::collate_byname< wchar_t> ;
# 285
extern template const __cxx11::collate< wchar_t>  &use_facet< __cxx11::collate< wchar_t> > (const locale &);
# 289
extern template bool has_facet< __cxx11::collate< wchar_t> > (const locale &) throw();
# 296
}
# 36 "/usr/include/aarch64-linux-gnu/c++/5/bits/error_constants.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 40
enum class errc { 
# 42
address_family_not_supported = 97, 
# 43
address_in_use, 
# 44
address_not_available, 
# 45
already_connected = 106, 
# 46
argument_list_too_long = 7, 
# 47
argument_out_of_domain = 33, 
# 48
bad_address = 14, 
# 49
bad_file_descriptor = 9, 
# 52
bad_message = 74, 
# 55
broken_pipe = 32, 
# 56
connection_aborted = 103, 
# 57
connection_already_in_progress = 114, 
# 58
connection_refused = 111, 
# 59
connection_reset = 104, 
# 60
cross_device_link = 18, 
# 61
destination_address_required = 89, 
# 62
device_or_resource_busy = 16, 
# 63
directory_not_empty = 39, 
# 64
executable_format_error = 8, 
# 65
file_exists = 17, 
# 66
file_too_large = 27, 
# 67
filename_too_long = 36, 
# 68
function_not_supported = 38, 
# 69
host_unreachable = 113, 
# 72
identifier_removed = 43, 
# 75
illegal_byte_sequence = 84, 
# 76
inappropriate_io_control_operation = 25, 
# 77
interrupted = 4, 
# 78
invalid_argument = 22, 
# 79
invalid_seek = 29, 
# 80
io_error = 5, 
# 81
is_a_directory = 21, 
# 82
message_size = 90, 
# 83
network_down = 100, 
# 84
network_reset = 102, 
# 85
network_unreachable = 101, 
# 86
no_buffer_space = 105, 
# 87
no_child_process = 10, 
# 90
no_link = 67, 
# 93
no_lock_available = 37, 
# 96
no_message_available = 61, 
# 99
no_message = 42, 
# 100
no_protocol_option = 92, 
# 101
no_space_on_device = 28, 
# 104
no_stream_resources = 63, 
# 107
no_such_device_or_address = 6, 
# 108
no_such_device = 19, 
# 109
no_such_file_or_directory = 2, 
# 110
no_such_process, 
# 111
not_a_directory = 20, 
# 112
not_a_socket = 88, 
# 115
not_a_stream = 60, 
# 118
not_connected = 107, 
# 119
not_enough_memory = 12, 
# 122
not_supported = 95, 
# 126
operation_canceled = 125, 
# 129
operation_in_progress = 115, 
# 130
operation_not_permitted = 1, 
# 131
operation_not_supported = 95, 
# 132
operation_would_block = 11, 
# 135
owner_dead = 130, 
# 138
permission_denied = 13, 
# 141
protocol_error = 71, 
# 144
protocol_not_supported = 93, 
# 145
read_only_file_system = 30, 
# 146
resource_deadlock_would_occur = 35, 
# 147
resource_unavailable_try_again = 11, 
# 148
result_out_of_range = 34, 
# 151
state_not_recoverable = 131, 
# 155
stream_timeout = 62, 
# 159
text_file_busy = 26, 
# 162
timed_out = 110, 
# 163
too_many_files_open_in_system = 23, 
# 164
too_many_files_open, 
# 165
too_many_links = 31, 
# 166
too_many_symbolic_link_levels = 40, 
# 169
value_too_large = 75, 
# 172
wrong_protocol_type = 91
# 173
}; 
# 176
}
# 41 "/usr/include/c++/5/stdexcept" 3
namespace std __attribute((__visibility__("default"))) { 
# 48
struct __cow_string { 
# 50
union { 
# 51
const char *_M_p; 
# 52
char _M_bytes[sizeof(const char *)]; 
# 53
}; 
# 55
__cow_string(); 
# 56
__cow_string(const __cxx11::string &); 
# 57
__cow_string(const char *, size_t); 
# 58
__cow_string(const __cow_string &) noexcept; 
# 59
__cow_string &operator=(const __cow_string &) noexcept; 
# 60
~__cow_string(); 
# 62
__cow_string(__cow_string &&) noexcept; 
# 63
__cow_string &operator=(__cow_string &&) noexcept; 
# 65
}; 
# 67
typedef __cxx11::basic_string< char, char_traits< char> , allocator< char> >  __sso_string; 
# 113 "/usr/include/c++/5/stdexcept" 3
class logic_error : public exception { 
# 115
__cow_string _M_msg; 
# 120
public: explicit logic_error(const __cxx11::string & __arg); 
# 124
explicit logic_error(const char *); 
# 128
logic_error(const logic_error &) noexcept; 
# 129
logic_error &operator=(const logic_error &) noexcept; 
# 132
virtual ~logic_error() noexcept; 
# 137
virtual const char *what() const noexcept; 
# 138
}; 
# 142
class domain_error : public logic_error { 
# 145
public: explicit domain_error(const __cxx11::string & __arg); 
# 147
explicit domain_error(const char *); 
# 149
virtual ~domain_error() noexcept; 
# 150
}; 
# 153
class invalid_argument : public logic_error { 
# 156
public: explicit invalid_argument(const __cxx11::string & __arg); 
# 158
explicit invalid_argument(const char *); 
# 160
virtual ~invalid_argument() noexcept; 
# 161
}; 
# 165
class length_error : public logic_error { 
# 168
public: explicit length_error(const __cxx11::string & __arg); 
# 170
explicit length_error(const char *); 
# 172
virtual ~length_error() noexcept; 
# 173
}; 
# 177
class out_of_range : public logic_error { 
# 180
public: explicit out_of_range(const __cxx11::string & __arg); 
# 182
explicit out_of_range(const char *); 
# 184
virtual ~out_of_range() noexcept; 
# 185
}; 
# 192
class runtime_error : public exception { 
# 194
__cow_string _M_msg; 
# 199
public: explicit runtime_error(const __cxx11::string & __arg); 
# 203
explicit runtime_error(const char *); 
# 207
runtime_error(const runtime_error &) noexcept; 
# 208
runtime_error &operator=(const runtime_error &) noexcept; 
# 211
virtual ~runtime_error() noexcept; 
# 216
virtual const char *what() const noexcept; 
# 217
}; 
# 220
class range_error : public runtime_error { 
# 223
public: explicit range_error(const __cxx11::string & __arg); 
# 225
explicit range_error(const char *); 
# 227
virtual ~range_error() noexcept; 
# 228
}; 
# 231
class overflow_error : public runtime_error { 
# 234
public: explicit overflow_error(const __cxx11::string & __arg); 
# 236
explicit overflow_error(const char *); 
# 238
virtual ~overflow_error() noexcept; 
# 239
}; 
# 242
class underflow_error : public runtime_error { 
# 245
public: explicit underflow_error(const __cxx11::string & __arg); 
# 247
explicit underflow_error(const char *); 
# 249
virtual ~underflow_error() noexcept; 
# 250
}; 
# 255
}
# 43 "/usr/include/c++/5/system_error" 3
namespace std __attribute((__visibility__("default"))) { 
# 47
struct error_code; 
# 48
struct error_condition; 
# 49
class system_error; 
# 52
template< class _Tp> 
# 53
struct is_error_code_enum : public false_type { }; 
# 56
template< class _Tp> 
# 57
struct is_error_condition_enum : public false_type { }; 
# 60
template<> struct is_error_condition_enum< errc>  : public true_type { 
# 61
}; 
# 63
inline namespace _V2 { 
# 66
class error_category { 
# 69
public: constexpr error_category() noexcept = default;
# 71
virtual ~error_category(); 
# 73
error_category(const error_category &) = delete;
# 74
error_category &operator=(const error_category &) = delete;
# 77
virtual const char *name() const noexcept = 0; 
# 87
private: 
# 85
__attribute((__abi_tag__("cxx11"))) virtual __cow_string 
# 87
_M_message(int) const; 
# 92
public: 
# 90
__attribute((__abi_tag__("cxx11"))) virtual __cxx11::string 
# 92
message(int) const = 0; 
# 104 "/usr/include/c++/5/system_error" 3
virtual error_condition default_error_condition(int __i) const noexcept; 
# 107
virtual bool equivalent(int __i, const error_condition & __cond) const noexcept; 
# 110
virtual bool equivalent(const error_code & __code, int __i) const noexcept; 
# 113
bool operator<(const error_category &__other) const noexcept 
# 114
{ return less< const error_category *> ()(this, &__other); } 
# 117
bool operator==(const error_category &__other) const noexcept 
# 118
{ return this == (&__other); } 
# 121
bool operator!=(const error_category &__other) const noexcept 
# 122
{ return this != (&__other); } 
# 123
}; 
# 126
__attribute((const)) const error_category &system_category() noexcept; 
# 127
__attribute((const)) const error_category &generic_category() noexcept; 
# 129
}
# 131
inline error_code make_error_code(errc) noexcept; 
# 133
template< class _Tp> struct hash; 
# 138
struct error_code { 
# 140
error_code() noexcept : _M_value(0), _M_cat(&system_category()) 
# 141
{ } 
# 143
error_code(int __v, const _V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat) 
# 144
{ } 
# 146
template< class _ErrorCodeEnum, class  = typename enable_if< is_error_code_enum< _ErrorCodeEnum> ::value> ::type> 
# 148
error_code(_ErrorCodeEnum __e) noexcept 
# 149
{ (*this) = make_error_code(__e); } 
# 152
void assign(int __v, const _V2::error_category &__cat) noexcept 
# 153
{ 
# 154
(_M_value) = __v; 
# 155
(_M_cat) = (&__cat); 
# 156
} 
# 159
void clear() noexcept 
# 160
{ this->assign(0, system_category()); } 
# 163
template< class _ErrorCodeEnum> typename enable_if< is_error_code_enum< _ErrorCodeEnum> ::value, error_code &> ::type 
# 166
operator=(_ErrorCodeEnum __e) noexcept 
# 167
{ return (*this) = make_error_code(__e); } 
# 170
int value() const noexcept { return _M_value; } 
# 173
const _V2::error_category &category() const noexcept { return *(_M_cat); } 
# 176
error_condition default_error_condition() const noexcept; 
# 178
__attribute((__abi_tag__("cxx11"))) __cxx11::string 
# 180
message() const 
# 181
{ return this->category().message(this->value()); } 
# 183
explicit operator bool() const noexcept 
# 184
{ return ((_M_value) != 0) ? true : false; } 
# 188
friend struct hash< error_code> ; 
# 190
private: int _M_value; 
# 191
const _V2::error_category *_M_cat; 
# 192
}; 
# 196
inline error_code make_error_code(errc __e) noexcept 
# 197
{ return error_code(static_cast< int>(__e), generic_category()); } 
# 200
inline bool operator<(const error_code &__lhs, const error_code &__rhs) noexcept 
# 201
{ 
# 202
return ((__lhs.category()) < (__rhs.category())) || (((__lhs.category()) == (__rhs.category())) && (__lhs.value() < __rhs.value())); 
# 205
} 
# 207
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 209
operator<<(basic_ostream< _CharT, _Traits>  &__os, const error_code &__e) 
# 210
{ return ((__os << __e.category().name()) << ':') << __e.value(); } 
# 212
inline error_condition make_error_condition(errc) noexcept; 
# 216
struct error_condition { 
# 218
error_condition() noexcept : _M_value(0), _M_cat(&generic_category()) 
# 219
{ } 
# 221
error_condition(int __v, const _V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat) 
# 222
{ } 
# 224
template< class _ErrorConditionEnum, class  = typename enable_if< is_error_condition_enum< _ErrorConditionEnum> ::value> ::type> 
# 226
error_condition(_ErrorConditionEnum __e) noexcept 
# 227
{ (*this) = make_error_condition(__e); } 
# 230
void assign(int __v, const _V2::error_category &__cat) noexcept 
# 231
{ 
# 232
(_M_value) = __v; 
# 233
(_M_cat) = (&__cat); 
# 234
} 
# 237
template< class _ErrorConditionEnum> typename enable_if< is_error_condition_enum< _ErrorConditionEnum> ::value, error_condition &> ::type 
# 240
operator=(_ErrorConditionEnum __e) noexcept 
# 241
{ return (*this) = make_error_condition(__e); } 
# 244
void clear() noexcept 
# 245
{ this->assign(0, generic_category()); } 
# 249
int value() const noexcept { return _M_value; } 
# 252
const _V2::error_category &category() const noexcept { return *(_M_cat); } 
# 254
__attribute((__abi_tag__("cxx11"))) __cxx11::string 
# 256
message() const 
# 257
{ return this->category().message(this->value()); } 
# 259
explicit operator bool() const noexcept 
# 260
{ return ((_M_value) != 0) ? true : false; } 
# 264
private: int _M_value; 
# 265
const _V2::error_category *_M_cat; 
# 266
}; 
# 270
inline error_condition make_error_condition(errc __e) noexcept 
# 271
{ return error_condition(static_cast< int>(__e), generic_category()); } 
# 274
inline bool operator<(const error_condition &__lhs, const error_condition &
# 275
__rhs) noexcept 
# 276
{ 
# 277
return ((__lhs.category()) < (__rhs.category())) || (((__lhs.category()) == (__rhs.category())) && (__lhs.value() < __rhs.value())); 
# 280
} 
# 284
inline bool operator==(const error_code &__lhs, const error_code &__rhs) noexcept 
# 285
{ return ((__lhs.category()) == (__rhs.category())) && (__lhs.value() == __rhs.value()); 
# 286
} 
# 289
inline bool operator==(const error_code &__lhs, const error_condition &__rhs) noexcept 
# 290
{ 
# 291
return __lhs.category().equivalent(__lhs.value(), __rhs) || __rhs.category().equivalent(__lhs, __rhs.value()); 
# 293
} 
# 296
inline bool operator==(const error_condition &__lhs, const error_code &__rhs) noexcept 
# 297
{ 
# 298
return __rhs.category().equivalent(__rhs.value(), __lhs) || __lhs.category().equivalent(__rhs, __lhs.value()); 
# 300
} 
# 303
inline bool operator==(const error_condition &__lhs, const error_condition &
# 304
__rhs) noexcept 
# 305
{ 
# 306
return ((__lhs.category()) == (__rhs.category())) && (__lhs.value() == __rhs.value()); 
# 308
} 
# 311
inline bool operator!=(const error_code &__lhs, const error_code &__rhs) noexcept 
# 312
{ return !((__lhs == __rhs)); } 
# 315
inline bool operator!=(const error_code &__lhs, const error_condition &__rhs) noexcept 
# 316
{ return !((__lhs == __rhs)); } 
# 319
inline bool operator!=(const error_condition &__lhs, const error_code &__rhs) noexcept 
# 320
{ return !((__lhs == __rhs)); } 
# 323
inline bool operator!=(const error_condition &__lhs, const error_condition &
# 324
__rhs) noexcept 
# 325
{ return !((__lhs == __rhs)); } 
# 333
class system_error : public runtime_error { 
# 336
error_code _M_code; 
# 339
public: system_error(error_code __ec = error_code()) : runtime_error(__ec.message()), _M_code(__ec) 
# 340
{ } 
# 342
system_error(error_code __ec, const __cxx11::string &__what) : runtime_error((((__what + (": "))) + (__ec.message()))), _M_code(__ec) 
# 343
{ } 
# 345
system_error(error_code __ec, const char *__what) : runtime_error((__what + (((": ") + (__ec.message()))))), _M_code(__ec) 
# 346
{ } 
# 348
system_error(int __v, const _V2::error_category &__ecat, const char *__what) : system_error(error_code(__v, __ecat), __what) 
# 349
{ } 
# 351
system_error(int __v, const _V2::error_category &__ecat) : runtime_error(error_code(__v, __ecat).message()), _M_code(__v, __ecat) 
# 353
{ } 
# 355
system_error(int __v, const _V2::error_category &__ecat, const __cxx11::string &__what) : runtime_error((((__what + (": "))) + (error_code(__v, __ecat).message()))), _M_code(__v, __ecat) 
# 357
{ } 
# 359
virtual ~system_error() noexcept; 
# 362
const error_code &code() const noexcept { return _M_code; } 
# 363
}; 
# 366
}
# 372
namespace std __attribute((__visibility__("default"))) { 
# 379
template<> struct hash< error_code>  : public __hash_base< unsigned long, error_code>  { 
# 383
size_t operator()(const error_code &__e) const noexcept 
# 384
{ 
# 385
const size_t __tmp = std::_Hash_impl::hash(__e._M_value); 
# 386
return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp); 
# 387
} 
# 388
}; 
# 391
}
# 49 "/usr/include/c++/5/bits/ios_base.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 57
enum _Ios_Fmtflags { 
# 59
_S_boolalpha = 1, 
# 60
_S_dec, 
# 61
_S_fixed = 4, 
# 62
_S_hex = 8, 
# 63
_S_internal = 16, 
# 64
_S_left = 32, 
# 65
_S_oct = 64, 
# 66
_S_right = 128, 
# 67
_S_scientific = 256, 
# 68
_S_showbase = 512, 
# 69
_S_showpoint = 1024, 
# 70
_S_showpos = 2048, 
# 71
_S_skipws = 4096, 
# 72
_S_unitbuf = 8192, 
# 73
_S_uppercase = 16384, 
# 74
_S_adjustfield = 176, 
# 75
_S_basefield = 74, 
# 76
_S_floatfield = 260, 
# 77
_S_ios_fmtflags_end = 65536, 
# 78
_S_ios_fmtflags_max = 2147483647, 
# 79
_S_ios_fmtflags_min = (-2147483647-1)
# 80
}; 
# 83
constexpr _Ios_Fmtflags operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
# 84
{ return (_Ios_Fmtflags)((static_cast< int>(__a)) & (static_cast< int>(__b))); } 
# 87
constexpr _Ios_Fmtflags operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
# 88
{ return (_Ios_Fmtflags)((static_cast< int>(__a)) | (static_cast< int>(__b))); } 
# 91
constexpr _Ios_Fmtflags operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
# 92
{ return (_Ios_Fmtflags)((static_cast< int>(__a)) ^ (static_cast< int>(__b))); } 
# 95
constexpr _Ios_Fmtflags operator~(_Ios_Fmtflags __a) 
# 96
{ return (_Ios_Fmtflags)(~(static_cast< int>(__a))); } 
# 99
inline const _Ios_Fmtflags &operator|=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
# 100
{ return __a = ((__a | __b)); } 
# 103
inline const _Ios_Fmtflags &operator&=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
# 104
{ return __a = ((__a & __b)); } 
# 107
inline const _Ios_Fmtflags &operator^=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
# 108
{ return __a = ((__a ^ __b)); } 
# 111
enum _Ios_Openmode { 
# 113
_S_app = 1, 
# 114
_S_ate, 
# 115
_S_bin = 4, 
# 116
_S_in = 8, 
# 117
_S_out = 16, 
# 118
_S_trunc = 32, 
# 119
_S_ios_openmode_end = 65536, 
# 120
_S_ios_openmode_max = 2147483647, 
# 121
_S_ios_openmode_min = (-2147483647-1)
# 122
}; 
# 125
constexpr _Ios_Openmode operator&(_Ios_Openmode __a, _Ios_Openmode __b) 
# 126
{ return (_Ios_Openmode)((static_cast< int>(__a)) & (static_cast< int>(__b))); } 
# 129
constexpr _Ios_Openmode operator|(_Ios_Openmode __a, _Ios_Openmode __b) 
# 130
{ return (_Ios_Openmode)((static_cast< int>(__a)) | (static_cast< int>(__b))); } 
# 133
constexpr _Ios_Openmode operator^(_Ios_Openmode __a, _Ios_Openmode __b) 
# 134
{ return (_Ios_Openmode)((static_cast< int>(__a)) ^ (static_cast< int>(__b))); } 
# 137
constexpr _Ios_Openmode operator~(_Ios_Openmode __a) 
# 138
{ return (_Ios_Openmode)(~(static_cast< int>(__a))); } 
# 141
inline const _Ios_Openmode &operator|=(_Ios_Openmode &__a, _Ios_Openmode __b) 
# 142
{ return __a = ((__a | __b)); } 
# 145
inline const _Ios_Openmode &operator&=(_Ios_Openmode &__a, _Ios_Openmode __b) 
# 146
{ return __a = ((__a & __b)); } 
# 149
inline const _Ios_Openmode &operator^=(_Ios_Openmode &__a, _Ios_Openmode __b) 
# 150
{ return __a = ((__a ^ __b)); } 
# 153
enum _Ios_Iostate { 
# 155
_S_goodbit, 
# 156
_S_badbit, 
# 157
_S_eofbit, 
# 158
_S_failbit = 4, 
# 159
_S_ios_iostate_end = 65536, 
# 160
_S_ios_iostate_max = 2147483647, 
# 161
_S_ios_iostate_min = (-2147483647-1)
# 162
}; 
# 165
constexpr _Ios_Iostate operator&(_Ios_Iostate __a, _Ios_Iostate __b) 
# 166
{ return (_Ios_Iostate)((static_cast< int>(__a)) & (static_cast< int>(__b))); } 
# 169
constexpr _Ios_Iostate operator|(_Ios_Iostate __a, _Ios_Iostate __b) 
# 170
{ return (_Ios_Iostate)((static_cast< int>(__a)) | (static_cast< int>(__b))); } 
# 173
constexpr _Ios_Iostate operator^(_Ios_Iostate __a, _Ios_Iostate __b) 
# 174
{ return (_Ios_Iostate)((static_cast< int>(__a)) ^ (static_cast< int>(__b))); } 
# 177
constexpr _Ios_Iostate operator~(_Ios_Iostate __a) 
# 178
{ return (_Ios_Iostate)(~(static_cast< int>(__a))); } 
# 181
inline const _Ios_Iostate &operator|=(_Ios_Iostate &__a, _Ios_Iostate __b) 
# 182
{ return __a = ((__a | __b)); } 
# 185
inline const _Ios_Iostate &operator&=(_Ios_Iostate &__a, _Ios_Iostate __b) 
# 186
{ return __a = ((__a & __b)); } 
# 189
inline const _Ios_Iostate &operator^=(_Ios_Iostate &__a, _Ios_Iostate __b) 
# 190
{ return __a = ((__a ^ __b)); } 
# 193
enum _Ios_Seekdir { 
# 195
_S_beg, 
# 196
_S_cur, 
# 197
_S_end, 
# 198
_S_ios_seekdir_end = 65536
# 199
}; 
# 203
enum class io_errc { stream = 1}; 
# 205
template<> struct is_error_code_enum< io_errc>  : public true_type { }; 
# 207
const _V2::error_category &iostream_category() noexcept; 
# 210
inline error_code make_error_code(io_errc e) noexcept 
# 211
{ return error_code(static_cast< int>(e), iostream_category()); } 
# 214
inline error_condition make_error_condition(io_errc e) noexcept 
# 215
{ return error_condition(static_cast< int>(e), iostream_category()); } 
# 228 "/usr/include/c++/5/bits/ios_base.h" 3
class ios_base { 
# 255 "/usr/include/c++/5/bits/ios_base.h" 3
public: class __attribute((__abi_tag__("cxx11"))) failure : public system_error { 
# 259
public: explicit failure(const __cxx11::string & __str); 
# 263
explicit failure(const __cxx11::string &, const error_code &); 
# 266
explicit failure(const char *, const error_code & = io_errc::stream); 
# 270
virtual ~failure() throw(); 
# 273
virtual const char *what() const throw(); 
# 274
}; 
# 323 "/usr/include/c++/5/bits/ios_base.h" 3
typedef _Ios_Fmtflags fmtflags; 
# 326
static const fmtflags boolalpha = _S_boolalpha; 
# 329
static const fmtflags dec = _S_dec; 
# 332
static const fmtflags fixed = _S_fixed; 
# 335
static const fmtflags hex = _S_hex; 
# 340
static const fmtflags internal = _S_internal; 
# 344
static const fmtflags left = _S_left; 
# 347
static const fmtflags oct = _S_oct; 
# 351
static const fmtflags right = _S_right; 
# 354
static const fmtflags scientific = _S_scientific; 
# 358
static const fmtflags showbase = _S_showbase; 
# 362
static const fmtflags showpoint = _S_showpoint; 
# 365
static const fmtflags showpos = _S_showpos; 
# 368
static const fmtflags skipws = _S_skipws; 
# 371
static const fmtflags unitbuf = _S_unitbuf; 
# 375
static const fmtflags uppercase = _S_uppercase; 
# 378
static const fmtflags adjustfield = _S_adjustfield; 
# 381
static const fmtflags basefield = _S_basefield; 
# 384
static const fmtflags floatfield = _S_floatfield; 
# 398 "/usr/include/c++/5/bits/ios_base.h" 3
typedef _Ios_Iostate iostate; 
# 402
static const iostate badbit = _S_badbit; 
# 405
static const iostate eofbit = _S_eofbit; 
# 410
static const iostate failbit = _S_failbit; 
# 413
static const iostate goodbit = _S_goodbit; 
# 429 "/usr/include/c++/5/bits/ios_base.h" 3
typedef _Ios_Openmode openmode; 
# 432
static const openmode app = _S_app; 
# 435
static const openmode ate = _S_ate; 
# 440
static const openmode binary = _S_bin; 
# 443
static const openmode in = _S_in; 
# 446
static const openmode out = _S_out; 
# 449
static const openmode trunc = _S_trunc; 
# 461 "/usr/include/c++/5/bits/ios_base.h" 3
typedef _Ios_Seekdir seekdir; 
# 464
static const seekdir beg = _S_beg; 
# 467
static const seekdir cur = _S_cur; 
# 470
static const seekdir end = _S_end; 
# 473
typedef int io_state; 
# 474
typedef int open_mode; 
# 475
typedef int seek_dir; 
# 477
typedef std::streampos streampos; 
# 478
typedef std::streamoff streamoff; 
# 487 "/usr/include/c++/5/bits/ios_base.h" 3
enum event { 
# 489
erase_event, 
# 490
imbue_event, 
# 491
copyfmt_event
# 492
}; 
# 504 "/usr/include/c++/5/bits/ios_base.h" 3
typedef void (*event_callback)(event __e, ios_base & __b, int __i); 
# 517 "/usr/include/c++/5/bits/ios_base.h" 3
void register_callback(event_callback __fn, int __index); 
# 520
protected: streamsize _M_precision; 
# 521
streamsize _M_width; 
# 522
fmtflags _M_flags; 
# 523
iostate _M_exception; 
# 524
iostate _M_streambuf_state; 
# 528
struct _Callback_list { 
# 531
_Callback_list *_M_next; 
# 532
event_callback _M_fn; 
# 533
int _M_index; 
# 534
_Atomic_word _M_refcount; 
# 536
_Callback_list(event_callback __fn, int __index, _Callback_list *
# 537
__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) 
# 538
{ } 
# 541
void _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 
# 545
int _M_remove_reference() 
# 546
{ 
# 548
; 
# 549
int __res = __gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1); 
# 550
if (__res == 0) 
# 551
{ 
# 552
; 
# 553
}  
# 554
return __res; 
# 555
} 
# 556
}; 
# 558
_Callback_list *_M_callbacks; 
# 561
void _M_call_callbacks(event __ev) throw(); 
# 564
void _M_dispose_callbacks() throw(); 
# 567
struct _Words { 
# 569
void *_M_pword; 
# 570
long _M_iword; 
# 571
_Words() : _M_pword((0)), _M_iword((0)) { } 
# 572
}; 
# 575
_Words _M_word_zero; 
# 579
enum { _S_local_word_size = 8}; 
# 580
_Words _M_local_word[_S_local_word_size]; 
# 583
int _M_word_size; 
# 584
_Words *_M_word; 
# 587
_Words &_M_grow_words(int __index, bool __iword); 
# 590
locale _M_ios_locale; 
# 593
void _M_init() throw(); 
# 601
public: class Init { 
# 603
friend class ios_base; 
# 605
public: Init(); 
# 606
~Init(); 
# 609
private: static _Atomic_word _S_refcount; 
# 610
static bool _S_synced_with_stdio; 
# 611
}; 
# 619
fmtflags flags() const 
# 620
{ return _M_flags; } 
# 630 "/usr/include/c++/5/bits/ios_base.h" 3
fmtflags flags(fmtflags __fmtfl) 
# 631
{ 
# 632
fmtflags __old = _M_flags; 
# 633
(_M_flags) = __fmtfl; 
# 634
return __old; 
# 635
} 
# 646 "/usr/include/c++/5/bits/ios_base.h" 3
fmtflags setf(fmtflags __fmtfl) 
# 647
{ 
# 648
fmtflags __old = _M_flags; 
# 649
((_M_flags) |= __fmtfl); 
# 650
return __old; 
# 651
} 
# 663 "/usr/include/c++/5/bits/ios_base.h" 3
fmtflags setf(fmtflags __fmtfl, fmtflags __mask) 
# 664
{ 
# 665
fmtflags __old = _M_flags; 
# 666
((_M_flags) &= ((~__mask))); 
# 667
((_M_flags) |= ((__fmtfl & __mask))); 
# 668
return __old; 
# 669
} 
# 678
void unsetf(fmtflags __mask) 
# 679
{ ((_M_flags) &= ((~__mask))); } 
# 689 "/usr/include/c++/5/bits/ios_base.h" 3
streamsize precision() const 
# 690
{ return _M_precision; } 
# 698
streamsize precision(streamsize __prec) 
# 699
{ 
# 700
streamsize __old = _M_precision; 
# 701
(_M_precision) = __prec; 
# 702
return __old; 
# 703
} 
# 712
streamsize width() const 
# 713
{ return _M_width; } 
# 721
streamsize width(streamsize __wide) 
# 722
{ 
# 723
streamsize __old = _M_width; 
# 724
(_M_width) = __wide; 
# 725
return __old; 
# 726
} 
# 740 "/usr/include/c++/5/bits/ios_base.h" 3
static bool sync_with_stdio(bool __sync = true); 
# 752 "/usr/include/c++/5/bits/ios_base.h" 3
locale imbue(const locale & __loc) throw(); 
# 763 "/usr/include/c++/5/bits/ios_base.h" 3
locale getloc() const 
# 764
{ return _M_ios_locale; } 
# 774 "/usr/include/c++/5/bits/ios_base.h" 3
const locale &_M_getloc() const 
# 775
{ return _M_ios_locale; } 
# 793 "/usr/include/c++/5/bits/ios_base.h" 3
static int xalloc() throw(); 
# 809 "/usr/include/c++/5/bits/ios_base.h" 3
long &iword(int __ix) 
# 810
{ 
# 811
_Words &__word = (__ix < (_M_word_size)) ? (_M_word)[__ix] : this->_M_grow_words(__ix, true); 
# 813
return __word._M_iword; 
# 814
} 
# 830 "/usr/include/c++/5/bits/ios_base.h" 3
void *&pword(int __ix) 
# 831
{ 
# 832
_Words &__word = (__ix < (_M_word_size)) ? (_M_word)[__ix] : this->_M_grow_words(__ix, false); 
# 834
return __word._M_pword; 
# 835
} 
# 846 "/usr/include/c++/5/bits/ios_base.h" 3
virtual ~ios_base(); 
# 849
protected: ios_base() throw(); 
# 861 "/usr/include/c++/5/bits/ios_base.h" 3
public: ios_base(const ios_base &) = delete;
# 864
ios_base &operator=(const ios_base &) = delete;
# 868
protected: void _M_move(ios_base &) noexcept; 
# 871
void _M_swap(ios_base & __rhs) noexcept; 
# 873
}; 
# 878
inline ios_base &boolalpha(ios_base &__base) 
# 879
{ 
# 880
__base.setf(ios_base::boolalpha); 
# 881
return __base; 
# 882
} 
# 886
inline ios_base &noboolalpha(ios_base &__base) 
# 887
{ 
# 888
__base.unsetf(ios_base::boolalpha); 
# 889
return __base; 
# 890
} 
# 894
inline ios_base &showbase(ios_base &__base) 
# 895
{ 
# 896
__base.setf(ios_base::showbase); 
# 897
return __base; 
# 898
} 
# 902
inline ios_base &noshowbase(ios_base &__base) 
# 903
{ 
# 904
__base.unsetf(ios_base::showbase); 
# 905
return __base; 
# 906
} 
# 910
inline ios_base &showpoint(ios_base &__base) 
# 911
{ 
# 912
__base.setf(ios_base::showpoint); 
# 913
return __base; 
# 914
} 
# 918
inline ios_base &noshowpoint(ios_base &__base) 
# 919
{ 
# 920
__base.unsetf(ios_base::showpoint); 
# 921
return __base; 
# 922
} 
# 926
inline ios_base &showpos(ios_base &__base) 
# 927
{ 
# 928
__base.setf(ios_base::showpos); 
# 929
return __base; 
# 930
} 
# 934
inline ios_base &noshowpos(ios_base &__base) 
# 935
{ 
# 936
__base.unsetf(ios_base::showpos); 
# 937
return __base; 
# 938
} 
# 942
inline ios_base &skipws(ios_base &__base) 
# 943
{ 
# 944
__base.setf(ios_base::skipws); 
# 945
return __base; 
# 946
} 
# 950
inline ios_base &noskipws(ios_base &__base) 
# 951
{ 
# 952
__base.unsetf(ios_base::skipws); 
# 953
return __base; 
# 954
} 
# 958
inline ios_base &uppercase(ios_base &__base) 
# 959
{ 
# 960
__base.setf(ios_base::uppercase); 
# 961
return __base; 
# 962
} 
# 966
inline ios_base &nouppercase(ios_base &__base) 
# 967
{ 
# 968
__base.unsetf(ios_base::uppercase); 
# 969
return __base; 
# 970
} 
# 974
inline ios_base &unitbuf(ios_base &__base) 
# 975
{ 
# 976
__base.setf(ios_base::unitbuf); 
# 977
return __base; 
# 978
} 
# 982
inline ios_base &nounitbuf(ios_base &__base) 
# 983
{ 
# 984
__base.unsetf(ios_base::unitbuf); 
# 985
return __base; 
# 986
} 
# 991
inline ios_base &internal(ios_base &__base) 
# 992
{ 
# 993
__base.setf(ios_base::internal, ios_base::adjustfield); 
# 994
return __base; 
# 995
} 
# 999
inline ios_base &left(ios_base &__base) 
# 1000
{ 
# 1001
__base.setf(ios_base::left, ios_base::adjustfield); 
# 1002
return __base; 
# 1003
} 
# 1007
inline ios_base &right(ios_base &__base) 
# 1008
{ 
# 1009
__base.setf(ios_base::right, ios_base::adjustfield); 
# 1010
return __base; 
# 1011
} 
# 1016
inline ios_base &dec(ios_base &__base) 
# 1017
{ 
# 1018
__base.setf(ios_base::dec, ios_base::basefield); 
# 1019
return __base; 
# 1020
} 
# 1024
inline ios_base &hex(ios_base &__base) 
# 1025
{ 
# 1026
__base.setf(ios_base::hex, ios_base::basefield); 
# 1027
return __base; 
# 1028
} 
# 1032
inline ios_base &oct(ios_base &__base) 
# 1033
{ 
# 1034
__base.setf(ios_base::oct, ios_base::basefield); 
# 1035
return __base; 
# 1036
} 
# 1041
inline ios_base &fixed(ios_base &__base) 
# 1042
{ 
# 1043
__base.setf(ios_base::fixed, ios_base::floatfield); 
# 1044
return __base; 
# 1045
} 
# 1049
inline ios_base &scientific(ios_base &__base) 
# 1050
{ 
# 1051
__base.setf(ios_base::scientific, ios_base::floatfield); 
# 1052
return __base; 
# 1053
} 
# 1061
inline ios_base &hexfloat(ios_base &__base) 
# 1062
{ 
# 1063
__base.setf((ios_base::fixed | ios_base::scientific), ios_base::floatfield); 
# 1064
return __base; 
# 1065
} 
# 1069
inline ios_base &defaultfloat(ios_base &__base) 
# 1070
{ 
# 1071
__base.unsetf(ios_base::floatfield); 
# 1072
return __base; 
# 1073
} 
# 1077
}
# 45 "/usr/include/c++/5/streambuf" 3
namespace std __attribute((__visibility__("default"))) { 
# 49
template< class _CharT, class _Traits> streamsize __copy_streambufs_eof(basic_streambuf< _CharT, _Traits>  *, basic_streambuf< _CharT, _Traits>  *, bool &); 
# 119 "/usr/include/c++/5/streambuf" 3
template< class _CharT, class _Traits> 
# 120
class basic_streambuf { 
# 129
public: typedef _CharT char_type; 
# 130
typedef _Traits traits_type; 
# 131
typedef typename _Traits::int_type int_type; 
# 132
typedef typename _Traits::pos_type pos_type; 
# 133
typedef typename _Traits::off_type off_type; 
# 138
typedef basic_streambuf __streambuf_type; 
# 141
friend class basic_ios< _CharT, _Traits> ; 
# 142
friend class basic_istream< _CharT, _Traits> ; 
# 143
friend class basic_ostream< _CharT, _Traits> ; 
# 144
friend class istreambuf_iterator< _CharT, _Traits> ; 
# 145
friend class ostreambuf_iterator< _CharT, _Traits> ; 
# 148
friend streamsize __copy_streambufs_eof<> (basic_streambuf *, basic_streambuf *, bool &); 
# 150
template< bool _IsMove, class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, _CharT2 *> ::__type __copy_move_a2(istreambuf_iterator< _CharT2, char_traits< _CharT2> > , istreambuf_iterator< _CharT2, char_traits< _CharT2> > , _CharT2 *); 
# 156
template< class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, istreambuf_iterator< _CharT2, char_traits< _CharT2> > > ::__type find(istreambuf_iterator< _CharT2, char_traits< _CharT2> > , istreambuf_iterator< _CharT2, char_traits< _CharT2> > , const _CharT2 &); 
# 162
template< class _CharT2, class _Traits2> friend basic_istream< _CharT2, _Traits2>  &operator>>(basic_istream< _CharT2, _Traits2>  &, _CharT2 *); 
# 166
template< class _CharT2, class _Traits2, class _Alloc> friend basic_istream< _CharT2, _Traits2>  &operator>>(basic_istream< _CharT2, _Traits2>  &, __cxx11::basic_string< _CharT2, _Traits2, _Alloc>  &); 
# 171
template< class _CharT2, class _Traits2, class _Alloc> friend basic_istream< _CharT2, _Traits2>  &getline(basic_istream< _CharT2, _Traits2>  &, __cxx11::basic_string< _CharT2, _Traits2, _Alloc>  &, _CharT2); 
# 184
protected: char_type *_M_in_beg; 
# 185
char_type *_M_in_cur; 
# 186
char_type *_M_in_end; 
# 187
char_type *_M_out_beg; 
# 188
char_type *_M_out_cur; 
# 189
char_type *_M_out_end; 
# 192
locale _M_buf_locale; 
# 197
public: virtual ~basic_streambuf() 
# 198
{ } 
# 209 "/usr/include/c++/5/streambuf" 3
locale pubimbue(const locale &__loc) 
# 210
{ 
# 211
locale __tmp(this->getloc()); 
# 212
this->imbue(__loc); 
# 213
((_M_buf_locale) = __loc); 
# 214
return __tmp; 
# 215
} 
# 226 "/usr/include/c++/5/streambuf" 3
locale getloc() const 
# 227
{ return _M_buf_locale; } 
# 239 "/usr/include/c++/5/streambuf" 3
basic_streambuf *pubsetbuf(char_type *__s, streamsize __n) 
# 240
{ return this->setbuf(__s, __n); } 
# 251 "/usr/include/c++/5/streambuf" 3
pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode 
# 252
__mode = (ios_base::in | ios_base::out)) 
# 253
{ return this->seekoff(__off, __way, __mode); } 
# 263 "/usr/include/c++/5/streambuf" 3
pos_type pubseekpos(pos_type __sp, ios_base::openmode 
# 264
__mode = (ios_base::in | ios_base::out)) 
# 265
{ return this->seekpos(__sp, __mode); } 
# 271
int pubsync() { return this->sync(); } 
# 284 "/usr/include/c++/5/streambuf" 3
streamsize in_avail() 
# 285
{ 
# 286
const streamsize __ret = this->egptr() - this->gptr(); 
# 287
return (__ret) ? __ret : this->showmanyc(); 
# 288
} 
# 298 "/usr/include/c++/5/streambuf" 3
int_type snextc() 
# 299
{ 
# 300
int_type __ret = traits_type::eof(); 
# 301
if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true)) { 
# 303
__ret = this->sgetc(); }  
# 304
return __ret; 
# 305
} 
# 316 "/usr/include/c++/5/streambuf" 3
int_type sbumpc() 
# 317
{ 
# 318
int_type __ret; 
# 319
if (__builtin_expect(this->gptr() < this->egptr(), true)) 
# 320
{ 
# 321
__ret = traits_type::to_int_type(*this->gptr()); 
# 322
this->gbump(1); 
# 323
} else { 
# 325
__ret = this->uflow(); }  
# 326
return __ret; 
# 327
} 
# 338 "/usr/include/c++/5/streambuf" 3
int_type sgetc() 
# 339
{ 
# 340
int_type __ret; 
# 341
if (__builtin_expect(this->gptr() < this->egptr(), true)) { 
# 342
__ret = traits_type::to_int_type(*this->gptr()); } else { 
# 344
__ret = this->underflow(); }  
# 345
return __ret; 
# 346
} 
# 357 "/usr/include/c++/5/streambuf" 3
streamsize sgetn(char_type *__s, streamsize __n) 
# 358
{ return this->xsgetn(__s, __n); } 
# 372 "/usr/include/c++/5/streambuf" 3
int_type sputbackc(char_type __c) 
# 373
{ 
# 374
int_type __ret; 
# 375
const bool __testpos = this->eback() < this->gptr(); 
# 376
if (__builtin_expect((!__testpos) || (!traits_type::eq(__c, this->gptr()[-1])), false)) { 
# 378
__ret = this->pbackfail(traits_type::to_int_type(__c)); } else 
# 380
{ 
# 381
this->gbump(-1); 
# 382
__ret = traits_type::to_int_type(*this->gptr()); 
# 383
}  
# 384
return __ret; 
# 385
} 
# 397 "/usr/include/c++/5/streambuf" 3
int_type sungetc() 
# 398
{ 
# 399
int_type __ret; 
# 400
if (__builtin_expect(this->eback() < this->gptr(), true)) 
# 401
{ 
# 402
this->gbump(-1); 
# 403
__ret = traits_type::to_int_type(*this->gptr()); 
# 404
} else { 
# 406
__ret = this->pbackfail(); }  
# 407
return __ret; 
# 408
} 
# 424 "/usr/include/c++/5/streambuf" 3
int_type sputc(char_type __c) 
# 425
{ 
# 426
int_type __ret; 
# 427
if (__builtin_expect(this->pptr() < this->epptr(), true)) 
# 428
{ 
# 429
(*this->pptr()) = __c; 
# 430
this->pbump(1); 
# 431
__ret = traits_type::to_int_type(__c); 
# 432
} else { 
# 434
__ret = this->overflow(traits_type::to_int_type(__c)); }  
# 435
return __ret; 
# 436
} 
# 450 "/usr/include/c++/5/streambuf" 3
streamsize sputn(const char_type *__s, streamsize __n) 
# 451
{ return this->xsputn(__s, __n); } 
# 463 "/usr/include/c++/5/streambuf" 3
protected: basic_streambuf() : _M_in_beg((0)), _M_in_cur((0)), _M_in_end((0)), _M_out_beg((0)), _M_out_cur((0)), _M_out_end((0)), _M_buf_locale(locale()) 
# 467
{ } 
# 482 "/usr/include/c++/5/streambuf" 3
char_type *eback() const { return _M_in_beg; } 
# 485
char_type *gptr() const { return _M_in_cur; } 
# 488
char_type *egptr() const { return _M_in_end; } 
# 498 "/usr/include/c++/5/streambuf" 3
void gbump(int __n) { (_M_in_cur) += __n; } 
# 509 "/usr/include/c++/5/streambuf" 3
void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) 
# 510
{ 
# 511
(_M_in_beg) = __gbeg; 
# 512
(_M_in_cur) = __gnext; 
# 513
(_M_in_end) = __gend; 
# 514
} 
# 529 "/usr/include/c++/5/streambuf" 3
char_type *pbase() const { return _M_out_beg; } 
# 532
char_type *pptr() const { return _M_out_cur; } 
# 535
char_type *epptr() const { return _M_out_end; } 
# 545 "/usr/include/c++/5/streambuf" 3
void pbump(int __n) { (_M_out_cur) += __n; } 
# 555 "/usr/include/c++/5/streambuf" 3
void setp(char_type *__pbeg, char_type *__pend) 
# 556
{ 
# 557
(_M_out_beg) = ((_M_out_cur) = __pbeg); 
# 558
(_M_out_end) = __pend; 
# 559
} 
# 576 "/usr/include/c++/5/streambuf" 3
virtual void imbue(const locale &__loc) 
# 577
{ } 
# 591 "/usr/include/c++/5/streambuf" 3
virtual basic_streambuf *setbuf(char_type *, streamsize) 
# 592
{ return this; } 
# 602 "/usr/include/c++/5/streambuf" 3
virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode = (ios_base::in | ios_base::out)) 
# 604
{ return (pos_type)((off_type)(-1)); } 
# 614 "/usr/include/c++/5/streambuf" 3
virtual pos_type seekpos(pos_type, ios_base::openmode = (ios_base::in | ios_base::out)) 
# 616
{ return (pos_type)((off_type)(-1)); } 
# 627 "/usr/include/c++/5/streambuf" 3
virtual int sync() { return 0; } 
# 649 "/usr/include/c++/5/streambuf" 3
virtual streamsize showmanyc() { return 0; } 
# 665 "/usr/include/c++/5/streambuf" 3
virtual streamsize xsgetn(char_type * __s, streamsize __n); 
# 687 "/usr/include/c++/5/streambuf" 3
virtual int_type underflow() 
# 688
{ return traits_type::eof(); } 
# 700 "/usr/include/c++/5/streambuf" 3
virtual int_type uflow() 
# 701
{ 
# 702
int_type __ret = traits_type::eof(); 
# 703
const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret); 
# 705
if (!__testeof) 
# 706
{ 
# 707
__ret = traits_type::to_int_type(*this->gptr()); 
# 708
this->gbump(1); 
# 709
}  
# 710
return __ret; 
# 711
} 
# 724 "/usr/include/c++/5/streambuf" 3
virtual int_type pbackfail(int_type __c = traits_type::eof()) 
# 725
{ return traits_type::eof(); } 
# 742 "/usr/include/c++/5/streambuf" 3
virtual streamsize xsputn(const char_type * __s, streamsize __n); 
# 768 "/usr/include/c++/5/streambuf" 3
virtual int_type overflow(int_type __c = traits_type::eof()) 
# 769
{ return traits_type::eof(); } 
# 783 "/usr/include/c++/5/streambuf" 3
public: void stossc() 
# 784
{ 
# 785
if (this->gptr() < this->egptr()) { 
# 786
this->gbump(1); } else { 
# 788
this->uflow(); }  
# 789
} 
# 794
void __safe_gbump(streamsize __n) { (_M_in_cur) += __n; } 
# 797
void __safe_pbump(streamsize __n) { (_M_out_cur) += __n; } 
# 804
protected: basic_streambuf(const basic_streambuf &); 
# 807
basic_streambuf &operator=(const basic_streambuf &); 
# 811
void swap(basic_streambuf &__sb) 
# 812
{ 
# 813
std::swap(_M_in_beg, (__sb._M_in_beg)); 
# 814
std::swap(_M_in_cur, (__sb._M_in_cur)); 
# 815
std::swap(_M_in_end, (__sb._M_in_end)); 
# 816
std::swap(_M_out_beg, (__sb._M_out_beg)); 
# 817
std::swap(_M_out_cur, (__sb._M_out_cur)); 
# 818
std::swap(_M_out_end, (__sb._M_out_end)); 
# 819
std::swap(_M_buf_locale, (__sb._M_buf_locale)); 
# 820
} 
# 822
}; 
# 825
template < typename _CharT, typename _Traits >
    std :: basic_streambuf < _CharT, _Traits > ::
    basic_streambuf ( const basic_streambuf & ) = default;
# 829
template < typename _CharT, typename _Traits >
    std :: basic_streambuf < _CharT, _Traits > &
    std :: basic_streambuf < _CharT, _Traits > ::
    operator = ( const basic_streambuf & ) = default;
# 838
template<> streamsize __copy_streambufs_eof(basic_streambuf< char, char_traits< char> >  * __sbin, basic_streambuf< char, char_traits< char> >  * __sbout, bool & __ineof); 
# 843
template<> streamsize __copy_streambufs_eof(basic_streambuf< wchar_t, char_traits< wchar_t> >  * __sbin, basic_streambuf< wchar_t, char_traits< wchar_t> >  * __sbout, bool & __ineof); 
# 848
}
# 39 "/usr/include/c++/5/bits/streambuf.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _CharT, class _Traits> streamsize 
# 46
basic_streambuf< _CharT, _Traits> ::xsgetn(char_type *__s, streamsize __n) 
# 47
{ 
# 48
streamsize __ret = (0); 
# 49
while (__ret < __n) 
# 50
{ 
# 51
const streamsize __buf_len = this->egptr() - this->gptr(); 
# 52
if (__buf_len) 
# 53
{ 
# 54
const streamsize __remaining = __n - __ret; 
# 55
const streamsize __len = std::min(__buf_len, __remaining); 
# 56
traits_type::copy(__s, this->gptr(), __len); 
# 57
__ret += __len; 
# 58
__s += __len; 
# 59
this->__safe_gbump(__len); 
# 60
}  
# 62
if (__ret < __n) 
# 63
{ 
# 64
const int_type __c = this->uflow(); 
# 65
if (!traits_type::eq_int_type(__c, traits_type::eof())) 
# 66
{ 
# 67
traits_type::assign(*(__s++), traits_type::to_char_type(__c)); 
# 68
++__ret; 
# 69
} else { 
# 71
break; }  
# 72
}  
# 73
}  
# 74
return __ret; 
# 75
} 
# 77
template< class _CharT, class _Traits> streamsize 
# 80
basic_streambuf< _CharT, _Traits> ::xsputn(const char_type *__s, streamsize __n) 
# 81
{ 
# 82
streamsize __ret = (0); 
# 83
while (__ret < __n) 
# 84
{ 
# 85
const streamsize __buf_len = this->epptr() - this->pptr(); 
# 86
if (__buf_len) 
# 87
{ 
# 88
const streamsize __remaining = __n - __ret; 
# 89
const streamsize __len = std::min(__buf_len, __remaining); 
# 90
traits_type::copy(this->pptr(), __s, __len); 
# 91
__ret += __len; 
# 92
__s += __len; 
# 93
this->__safe_pbump(__len); 
# 94
}  
# 96
if (__ret < __n) 
# 97
{ 
# 98
int_type __c = this->overflow(traits_type::to_int_type(*__s)); 
# 99
if (!traits_type::eq_int_type(__c, traits_type::eof())) 
# 100
{ 
# 101
++__ret; 
# 102
++__s; 
# 103
} else { 
# 105
break; }  
# 106
}  
# 107
}  
# 108
return __ret; 
# 109
} 
# 114
template< class _CharT, class _Traits> streamsize 
# 116
__copy_streambufs_eof(basic_streambuf< _CharT, _Traits>  *__sbin, basic_streambuf< _CharT, _Traits>  *
# 117
__sbout, bool &
# 118
__ineof) 
# 119
{ 
# 120
streamsize __ret = (0); 
# 121
__ineof = true; 
# 122
typename _Traits::int_type __c = (__sbin->sgetc()); 
# 123
while (!_Traits::eq_int_type(__c, _Traits::eof())) 
# 124
{ 
# 125
__c = (__sbout->sputc(_Traits::to_char_type(__c))); 
# 126
if (_Traits::eq_int_type(__c, _Traits::eof())) 
# 127
{ 
# 128
__ineof = false; 
# 129
break; 
# 130
}  
# 131
++__ret; 
# 132
__c = (__sbin->snextc()); 
# 133
}  
# 134
return __ret; 
# 135
} 
# 137
template< class _CharT, class _Traits> inline streamsize 
# 139
__copy_streambufs(basic_streambuf< _CharT, _Traits>  *__sbin, basic_streambuf< _CharT, _Traits>  *
# 140
__sbout) 
# 141
{ 
# 142
bool __ineof; 
# 143
return __copy_streambufs_eof(__sbin, __sbout, __ineof); 
# 144
} 
# 149
extern template class basic_streambuf< char, char_traits< char> > ;
# 150
extern template streamsize __copy_streambufs(basic_streambuf< char, char_traits< char> >  * __sbin, basic_streambuf< char, char_traits< char> >  * __sbout);
# 154
extern template streamsize __copy_streambufs_eof< char, char_traits< char> > (basic_streambuf< char, char_traits< char> >  *, basic_streambuf< char, char_traits< char> >  *, bool &);
# 160
extern template class basic_streambuf< wchar_t, char_traits< wchar_t> > ;
# 161
extern template streamsize __copy_streambufs(basic_streambuf< wchar_t, char_traits< wchar_t> >  * __sbin, basic_streambuf< wchar_t, char_traits< wchar_t> >  * __sbout);
# 165
extern template streamsize __copy_streambufs_eof< wchar_t, char_traits< wchar_t> > (basic_streambuf< wchar_t, char_traits< wchar_t> >  *, basic_streambuf< wchar_t, char_traits< wchar_t> >  *, bool &);
# 173
}
# 52 "/usr/include/wctype.h" 3
typedef unsigned long wctype_t; 
# 72 "/usr/include/wctype.h" 3
enum { 
# 73
__ISwupper, 
# 74
__ISwlower, 
# 75
__ISwalpha, 
# 76
__ISwdigit, 
# 77
__ISwxdigit, 
# 78
__ISwspace, 
# 79
__ISwprint, 
# 80
__ISwgraph, 
# 81
__ISwblank, 
# 82
__ISwcntrl, 
# 83
__ISwpunct, 
# 84
__ISwalnum, 
# 86
_ISwupper = 16777216, 
# 87
_ISwlower = 33554432, 
# 88
_ISwalpha = 67108864, 
# 89
_ISwdigit = 134217728, 
# 90
_ISwxdigit = 268435456, 
# 91
_ISwspace = 536870912, 
# 92
_ISwprint = 1073741824, 
# 93
_ISwgraph = (-2147483647-1), 
# 94
_ISwblank = 65536, 
# 95
_ISwcntrl = 131072, 
# 96
_ISwpunct = 262144, 
# 97
_ISwalnum = 524288
# 98
}; 
# 102
extern "C" {
# 111
extern int iswalnum(wint_t __wc) throw(); 
# 117
extern int iswalpha(wint_t __wc) throw(); 
# 120
extern int iswcntrl(wint_t __wc) throw(); 
# 124
extern int iswdigit(wint_t __wc) throw(); 
# 128
extern int iswgraph(wint_t __wc) throw(); 
# 133
extern int iswlower(wint_t __wc) throw(); 
# 136
extern int iswprint(wint_t __wc) throw(); 
# 141
extern int iswpunct(wint_t __wc) throw(); 
# 146
extern int iswspace(wint_t __wc) throw(); 
# 151
extern int iswupper(wint_t __wc) throw(); 
# 156
extern int iswxdigit(wint_t __wc) throw(); 
# 162
extern int iswblank(wint_t __wc) throw(); 
# 171 "/usr/include/wctype.h" 3
extern wctype_t wctype(const char * __property) throw(); 
# 175
extern int iswctype(wint_t __wc, wctype_t __desc) throw(); 
# 186
typedef const __int32_t *wctrans_t; 
# 194
extern wint_t towlower(wint_t __wc) throw(); 
# 197
extern wint_t towupper(wint_t __wc) throw(); 
# 200
}
# 213 "/usr/include/wctype.h" 3
extern "C" {
# 218
extern wctrans_t wctrans(const char * __property) throw(); 
# 221
extern wint_t towctrans(wint_t __wc, wctrans_t __desc) throw(); 
# 230
extern int iswalnum_l(wint_t __wc, __locale_t __locale) throw(); 
# 236
extern int iswalpha_l(wint_t __wc, __locale_t __locale) throw(); 
# 239
extern int iswcntrl_l(wint_t __wc, __locale_t __locale) throw(); 
# 243
extern int iswdigit_l(wint_t __wc, __locale_t __locale) throw(); 
# 247
extern int iswgraph_l(wint_t __wc, __locale_t __locale) throw(); 
# 252
extern int iswlower_l(wint_t __wc, __locale_t __locale) throw(); 
# 255
extern int iswprint_l(wint_t __wc, __locale_t __locale) throw(); 
# 260
extern int iswpunct_l(wint_t __wc, __locale_t __locale) throw(); 
# 265
extern int iswspace_l(wint_t __wc, __locale_t __locale) throw(); 
# 270
extern int iswupper_l(wint_t __wc, __locale_t __locale) throw(); 
# 275
extern int iswxdigit_l(wint_t __wc, __locale_t __locale) throw(); 
# 280
extern int iswblank_l(wint_t __wc, __locale_t __locale) throw(); 
# 284
extern wctype_t wctype_l(const char * __property, __locale_t __locale) throw(); 
# 289
extern int iswctype_l(wint_t __wc, wctype_t __desc, __locale_t __locale) throw(); 
# 298
extern wint_t towlower_l(wint_t __wc, __locale_t __locale) throw(); 
# 301
extern wint_t towupper_l(wint_t __wc, __locale_t __locale) throw(); 
# 305
extern wctrans_t wctrans_l(const char * __property, __locale_t __locale) throw(); 
# 309
extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc, __locale_t __locale) throw(); 
# 314
}
# 80 "/usr/include/c++/5/cwctype" 3
namespace std { 
# 82
using ::wctrans_t;
# 83
using ::wctype_t;
# 86
using ::iswalnum;
# 87
using ::iswalpha;
# 89
using ::iswblank;
# 91
using ::iswcntrl;
# 92
using ::iswctype;
# 93
using ::iswdigit;
# 94
using ::iswgraph;
# 95
using ::iswlower;
# 96
using ::iswprint;
# 97
using ::iswpunct;
# 98
using ::iswspace;
# 99
using ::iswupper;
# 100
using ::iswxdigit;
# 101
using ::towctrans;
# 102
using ::towlower;
# 103
using ::towupper;
# 104
using ::wctrans;
# 105
using ::wctype;
# 106
}
# 36 "/usr/include/aarch64-linux-gnu/c++/5/bits/ctype_base.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
struct ctype_base { 
# 44
typedef const int *__to_type; 
# 48
typedef unsigned short mask; 
# 49
static const mask upper = (_ISupper); 
# 50
static const mask lower = (_ISlower); 
# 51
static const mask alpha = (_ISalpha); 
# 52
static const mask digit = (_ISdigit); 
# 53
static const mask xdigit = (_ISxdigit); 
# 54
static const mask space = (_ISspace); 
# 55
static const mask print = (_ISprint); 
# 56
static const mask graph = (((_ISalpha) | (_ISdigit)) | (_ISpunct)); 
# 57
static const mask cntrl = (_IScntrl); 
# 58
static const mask punct = (_ISpunct); 
# 59
static const mask alnum = ((_ISalpha) | (_ISdigit)); 
# 61
static const mask blank = (_ISblank); 
# 63
}; 
# 66
}
# 38 "/usr/include/c++/5/bits/streambuf_iterator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 49 "/usr/include/c++/5/bits/streambuf_iterator.h" 3
template< class _CharT, class _Traits> 
# 50
class istreambuf_iterator : public iterator< input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT>  { 
# 64
public: typedef _CharT char_type; 
# 65
typedef _Traits traits_type; 
# 66
typedef typename _Traits::int_type int_type; 
# 67
typedef basic_streambuf< _CharT, _Traits>  streambuf_type; 
# 68
typedef basic_istream< _CharT, _Traits>  istream_type; 
# 71
template< class _CharT2> friend typename ::__gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, ostreambuf_iterator< _CharT2, char_traits< _CharT2> > > ::__type copy(::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , ::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , ostreambuf_iterator< _CharT2, char_traits< _CharT2> > ); 
# 77
template< bool _IsMove, class _CharT2> friend typename ::__gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, _CharT2 *> ::__type __copy_move_a2(::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , ::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , _CharT2 *); 
# 83
template< class _CharT2> friend typename ::__gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, ::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > > ::__type find(::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , ::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , const _CharT2 &); 
# 97
private: mutable streambuf_type *_M_sbuf; 
# 98
mutable int_type _M_c; 
# 102
public: constexpr istreambuf_iterator() noexcept : _M_sbuf((0)), _M_c(traits_type::eof()) 
# 103
{ } 
# 106
istreambuf_iterator(const istreambuf_iterator &) noexcept = default;
# 108
~istreambuf_iterator() = default;
# 112
istreambuf_iterator(istream_type &__s) noexcept : _M_sbuf((__s.rdbuf())), _M_c(traits_type::eof()) 
# 113
{ } 
# 116
istreambuf_iterator(streambuf_type *__s) noexcept : _M_sbuf(__s), _M_c(traits_type::eof()) 
# 117
{ } 
# 123
char_type operator*() const 
# 124
{ 
# 132
return traits_type::to_char_type(_M_get()); 
# 133
} 
# 137
istreambuf_iterator &operator++() 
# 138
{ 
# 141
; 
# 142
if (_M_sbuf) 
# 143
{ 
# 144
((_M_sbuf)->sbumpc()); 
# 145
(_M_c) = traits_type::eof(); 
# 146
}  
# 147
return *this; 
# 148
} 
# 152
istreambuf_iterator operator++(int) 
# 153
{ 
# 156
; 
# 158
istreambuf_iterator __old = *this; 
# 159
if (_M_sbuf) 
# 160
{ 
# 161
(__old._M_c) = ((_M_sbuf)->sbumpc()); 
# 162
(_M_c) = traits_type::eof(); 
# 163
}  
# 164
return __old; 
# 165
} 
# 172
bool equal(const istreambuf_iterator &__b) const 
# 173
{ return _M_at_eof() == (__b._M_at_eof()); } 
# 177
private: int_type _M_get() const 
# 178
{ 
# 179
const int_type __eof = traits_type::eof(); 
# 180
int_type __ret = __eof; 
# 181
if (_M_sbuf) 
# 182
{ 
# 183
if (!traits_type::eq_int_type(_M_c, __eof)) { 
# 184
__ret = (_M_c); } else { 
# 185
if (!traits_type::eq_int_type(__ret = ((_M_sbuf)->sgetc()), __eof)) { 
# 187
(_M_c) = __ret; } else { 
# 189
(_M_sbuf) = 0; }  }  
# 190
}  
# 191
return __ret; 
# 192
} 
# 195
bool _M_at_eof() const 
# 196
{ 
# 197
const int_type __eof = traits_type::eof(); 
# 198
return traits_type::eq_int_type(_M_get(), __eof); 
# 199
} 
# 200
}; 
# 202
template< class _CharT, class _Traits> inline bool 
# 204
operator==(const istreambuf_iterator< _CharT, _Traits>  &__a, const istreambuf_iterator< _CharT, _Traits>  &
# 205
__b) 
# 206
{ return (__a.equal(__b)); } 
# 208
template< class _CharT, class _Traits> inline bool 
# 210
operator!=(const istreambuf_iterator< _CharT, _Traits>  &__a, const istreambuf_iterator< _CharT, _Traits>  &
# 211
__b) 
# 212
{ return !(__a.equal(__b)); } 
# 215
template< class _CharT, class _Traits> 
# 216
class ostreambuf_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 223
public: typedef _CharT char_type; 
# 224
typedef _Traits traits_type; 
# 225
typedef basic_streambuf< _CharT, _Traits>  streambuf_type; 
# 226
typedef basic_ostream< _CharT, _Traits>  ostream_type; 
# 229
template< class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, std::ostreambuf_iterator< _CharT2, char_traits< _CharT2> > > ::__type copy(istreambuf_iterator< _CharT2, char_traits< _CharT2> > , istreambuf_iterator< _CharT2, char_traits< _CharT2> > , std::ostreambuf_iterator< _CharT2, char_traits< _CharT2> > ); 
# 236
private: streambuf_type *_M_sbuf; 
# 237
bool _M_failed; 
# 241
public: ostreambuf_iterator(ostream_type &__s) noexcept : _M_sbuf((__s.rdbuf())), _M_failed(!(_M_sbuf)) 
# 242
{ } 
# 245
ostreambuf_iterator(streambuf_type *__s) noexcept : _M_sbuf(__s), _M_failed(!(_M_sbuf)) 
# 246
{ } 
# 250
ostreambuf_iterator &operator=(_CharT __c) 
# 251
{ 
# 252
if ((!(_M_failed)) && _Traits::eq_int_type(((_M_sbuf)->sputc(__c)), _Traits::eof())) { 
# 254
(_M_failed) = true; }  
# 255
return *this; 
# 256
} 
# 260
ostreambuf_iterator &operator*() 
# 261
{ return *this; } 
# 265
ostreambuf_iterator &operator++(int) 
# 266
{ return *this; } 
# 270
ostreambuf_iterator &operator++() 
# 271
{ return *this; } 
# 275
bool failed() const noexcept 
# 276
{ return _M_failed; } 
# 279
ostreambuf_iterator &_M_put(const _CharT *__ws, streamsize __len) 
# 280
{ 
# 281
if ((__builtin_expect(!(_M_failed), true)) && (__builtin_expect(((this->_M_sbuf)->sputn(__ws, __len)) != __len, false))) { 
# 284
(_M_failed) = true; }  
# 285
return *this; 
# 286
} 
# 287
}; 
# 290
template< class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type 
# 293
copy(istreambuf_iterator< _CharT, char_traits< _CharT> >  __first, istreambuf_iterator< _CharT, char_traits< _CharT> >  
# 294
__last, ostreambuf_iterator< _CharT, char_traits< _CharT> >  
# 295
__result) 
# 296
{ 
# 297
if ((__first._M_sbuf) && (!(__last._M_sbuf)) && (!(__result._M_failed))) 
# 298
{ 
# 299
bool __ineof; 
# 300
__copy_streambufs_eof((__first._M_sbuf), (__result._M_sbuf), __ineof); 
# 301
if (!__ineof) { 
# 302
(__result._M_failed) = true; }  
# 303
}  
# 304
return __result; 
# 305
} 
# 307
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type 
# 310
__copy_move_a2(_CharT *__first, _CharT *__last, ostreambuf_iterator< _CharT, char_traits< _CharT> >  
# 311
__result) 
# 312
{ 
# 313
const streamsize __num = __last - __first; 
# 314
if (__num > (0)) { 
# 315
(__result._M_put(__first, __num)); }  
# 316
return __result; 
# 317
} 
# 319
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type 
# 322
__copy_move_a2(const _CharT *__first, const _CharT *__last, ostreambuf_iterator< _CharT, char_traits< _CharT> >  
# 323
__result) 
# 324
{ 
# 325
const streamsize __num = __last - __first; 
# 326
if (__num > (0)) { 
# 327
(__result._M_put(__first, __num)); }  
# 328
return __result; 
# 329
} 
# 331
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, _CharT *> ::__type 
# 334
__copy_move_a2(istreambuf_iterator< _CharT, char_traits< _CharT> >  __first, istreambuf_iterator< _CharT, char_traits< _CharT> >  
# 335
__last, _CharT *__result) 
# 336
{ 
# 337
typedef istreambuf_iterator< _CharT, char_traits< _CharT> >  __is_iterator_type; 
# 338
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::traits_type traits_type; 
# 339
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::streambuf_type streambuf_type; 
# 340
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::traits_type::int_type int_type; 
# 342
if ((__first._M_sbuf) && (!(__last._M_sbuf))) 
# 343
{ 
# 344
streambuf_type *__sb = ((__first._M_sbuf)); 
# 345
int_type __c = (__sb->sgetc()); 
# 346
while (!traits_type::eq_int_type(__c, traits_type::eof())) 
# 347
{ 
# 348
const streamsize __n = (__sb->egptr()) - (__sb->gptr()); 
# 349
if (__n > (1)) 
# 350
{ 
# 351
traits_type::copy(__result, (__sb->gptr()), __n); 
# 352
(__sb->__safe_gbump(__n)); 
# 353
__result += __n; 
# 354
__c = (__sb->underflow()); 
# 355
} else 
# 357
{ 
# 358
(*(__result++)) = traits_type::to_char_type(__c); 
# 359
__c = (__sb->snextc()); 
# 360
}  
# 361
}  
# 362
}  
# 363
return __result; 
# 364
} 
# 366
template< class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, istreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type 
# 369
find(istreambuf_iterator< _CharT, char_traits< _CharT> >  __first, istreambuf_iterator< _CharT, char_traits< _CharT> >  
# 370
__last, const _CharT &__val) 
# 371
{ 
# 372
typedef istreambuf_iterator< _CharT, char_traits< _CharT> >  __is_iterator_type; 
# 373
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::traits_type traits_type; 
# 374
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::streambuf_type streambuf_type; 
# 375
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::traits_type::int_type int_type; 
# 377
if ((__first._M_sbuf) && (!(__last._M_sbuf))) 
# 378
{ 
# 379
const int_type __ival = traits_type::to_int_type(__val); 
# 380
streambuf_type *__sb = ((__first._M_sbuf)); 
# 381
int_type __c = (__sb->sgetc()); 
# 382
while ((!traits_type::eq_int_type(__c, traits_type::eof())) && (!traits_type::eq_int_type(__c, __ival))) 
# 384
{ 
# 385
streamsize __n = (__sb->egptr()) - (__sb->gptr()); 
# 386
if (__n > (1)) 
# 387
{ 
# 388
const _CharT *__p = traits_type::find((__sb->gptr()), __n, __val); 
# 390
if (__p) { 
# 391
__n = (__p - (__sb->gptr())); }  
# 392
(__sb->__safe_gbump(__n)); 
# 393
__c = (__sb->sgetc()); 
# 394
} else { 
# 396
__c = (__sb->snextc()); }  
# 397
}  
# 399
if (!traits_type::eq_int_type(__c, traits_type::eof())) { 
# 400
(__first._M_c) = __c; } else { 
# 402
(__first._M_sbuf) = 0; }  
# 403
}  
# 404
return __first; 
# 405
} 
# 410
}
# 50 "/usr/include/c++/5/bits/locale_facets.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71 "/usr/include/c++/5/bits/locale_facets.h" 3
template< class _Tp> void __convert_to_v(const char *, _Tp &, ios_base::iostate &, const __c_locale &) throw(); 
# 79
template<> void __convert_to_v(const char *, float &, ios_base::iostate &, const __c_locale &) throw(); 
# 84
template<> void __convert_to_v(const char *, double &, ios_base::iostate &, const __c_locale &) throw(); 
# 89
template<> void __convert_to_v(const char *, long double &, ios_base::iostate &, const __c_locale &) throw(); 
# 94
template< class _CharT, class _Traits> 
# 95
struct __pad { 
# 98
static void _S_pad(ios_base & __io, _CharT __fill, _CharT * __news, const _CharT * __olds, streamsize __newlen, streamsize __oldlen); 
# 100
}; 
# 107
template< class _CharT> _CharT *__add_grouping(_CharT * __s, _CharT __sep, const char * __gbeg, size_t __gsize, const _CharT * __first, const _CharT * __last); 
# 116
template< class _CharT> inline ostreambuf_iterator< _CharT, char_traits< _CharT> >  
# 119
__write(ostreambuf_iterator< _CharT, char_traits< _CharT> >  __s, const _CharT *__ws, int __len) 
# 120
{ 
# 121
(__s._M_put(__ws, __len)); 
# 122
return __s; 
# 123
} 
# 126
template< class _CharT, class _OutIter> inline _OutIter 
# 129
__write(_OutIter __s, const _CharT *__ws, int __len) 
# 130
{ 
# 131
for (int __j = 0; __j < __len; (__j++), (++__s)) { 
# 132
(*__s) = (__ws[__j]); }  
# 133
return __s; 
# 134
} 
# 149 "/usr/include/c++/5/bits/locale_facets.h" 3
template< class _CharT> 
# 150
class __ctype_abstract_base : public locale::facet, public ctype_base { 
# 155
public: typedef _CharT char_type; 
# 169 "/usr/include/c++/5/bits/locale_facets.h" 3
bool is(mask __m, char_type __c) const 
# 170
{ return (this->do_is(__m, __c)); } 
# 186 "/usr/include/c++/5/bits/locale_facets.h" 3
const char_type *is(const char_type *__lo, const char_type *__hi, mask *__vec) const 
# 187
{ return (this->do_is(__lo, __hi, __vec)); } 
# 202 "/usr/include/c++/5/bits/locale_facets.h" 3
const char_type *scan_is(mask __m, const char_type *__lo, const char_type *__hi) const 
# 203
{ return this->do_scan_is(__m, __lo, __hi); } 
# 218 "/usr/include/c++/5/bits/locale_facets.h" 3
const char_type *scan_not(mask __m, const char_type *__lo, const char_type *__hi) const 
# 219
{ return this->do_scan_not(__m, __lo, __hi); } 
# 232 "/usr/include/c++/5/bits/locale_facets.h" 3
char_type toupper(char_type __c) const 
# 233
{ return (this->do_toupper(__c)); } 
# 247 "/usr/include/c++/5/bits/locale_facets.h" 3
const char_type *toupper(char_type *__lo, const char_type *__hi) const 
# 248
{ return (this->do_toupper(__lo, __hi)); } 
# 261 "/usr/include/c++/5/bits/locale_facets.h" 3
char_type tolower(char_type __c) const 
# 262
{ return (this->do_tolower(__c)); } 
# 276 "/usr/include/c++/5/bits/locale_facets.h" 3
const char_type *tolower(char_type *__lo, const char_type *__hi) const 
# 277
{ return (this->do_tolower(__lo, __hi)); } 
# 293 "/usr/include/c++/5/bits/locale_facets.h" 3
char_type widen(char __c) const 
# 294
{ return (this->do_widen(__c)); } 
# 312 "/usr/include/c++/5/bits/locale_facets.h" 3
const char *widen(const char *__lo, const char *__hi, char_type *__to) const 
# 313
{ return (this->do_widen(__lo, __hi, __to)); } 
# 331 "/usr/include/c++/5/bits/locale_facets.h" 3
char narrow(char_type __c, char __dfault) const 
# 332
{ return (this->do_narrow(__c, __dfault)); } 
# 353 "/usr/include/c++/5/bits/locale_facets.h" 3
const char_type *narrow(const char_type *__lo, const char_type *__hi, char 
# 354
__dfault, char *__to) const 
# 355
{ return (this->do_narrow(__lo, __hi, __dfault, __to)); } 
# 359
protected: explicit __ctype_abstract_base(size_t __refs = 0) : locale::facet(__refs) { } 
# 362
virtual ~__ctype_abstract_base() { } 
# 378 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual bool do_is(mask __m, char_type __c) const = 0; 
# 397 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const = 0; 
# 416 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const = 0; 
# 435 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const = 0; 
# 453 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_toupper(char_type __c) const = 0; 
# 470 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const = 0; 
# 486 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_tolower(char_type __c) const = 0; 
# 503 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const = 0; 
# 522 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_widen(char __c) const = 0; 
# 543 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char *do_widen(const char * __lo, const char * __hi, char_type * __to) const = 0; 
# 564 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char do_narrow(char_type __c, char __dfault) const = 0; 
# 589 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const = 0; 
# 591
}; 
# 611 "/usr/include/c++/5/bits/locale_facets.h" 3
template< class _CharT> 
# 612
class ctype : public __ctype_abstract_base< _CharT>  { 
# 616
public: typedef _CharT char_type; 
# 617
typedef typename ::std::__ctype_abstract_base< _CharT> ::mask mask; 
# 620
static ::std::locale::id id; 
# 623
explicit ctype(::std::size_t __refs = 0) : ::std::__ctype_abstract_base< _CharT> (__refs) { } 
# 627
protected: virtual ~ctype(); 
# 630
virtual bool do_is(mask __m, char_type __c) const; 
# 633
virtual const char_type *do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const; 
# 636
virtual const char_type *do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 639
virtual const char_type *do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 643
virtual char_type do_toupper(char_type __c) const; 
# 646
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 649
virtual char_type do_tolower(char_type __c) const; 
# 652
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 655
virtual char_type do_widen(char __c) const; 
# 658
virtual const char *do_widen(const char * __lo, const char * __hi, char_type * __dest) const; 
# 661
virtual char do_narrow(char_type, char __dfault) const; 
# 664
virtual const char_type *do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const; 
# 666
}; 
# 668
template< class _CharT> locale::id 
# 669
ctype< _CharT> ::id; 
# 681 "/usr/include/c++/5/bits/locale_facets.h" 3
template<> class ctype< char>  : public locale::facet, public ctype_base { 
# 686
public: typedef char char_type; 
# 690
protected: __c_locale _M_c_locale_ctype; 
# 691
bool _M_del; 
# 692
__to_type _M_toupper; 
# 693
__to_type _M_tolower; 
# 694
const mask *_M_table; 
# 695
mutable char _M_widen_ok; 
# 696
mutable char _M_widen[1 + (static_cast< unsigned char>(-1))]; 
# 697
mutable char _M_narrow[1 + (static_cast< unsigned char>(-1))]; 
# 698
mutable char _M_narrow_ok; 
# 703
public: static locale::id id; 
# 705
static const size_t table_size = (1 + (static_cast< unsigned char>(-1))); 
# 718 "/usr/include/c++/5/bits/locale_facets.h" 3
explicit ctype(const mask * __table = 0, bool __del = false, size_t __refs = 0); 
# 731 "/usr/include/c++/5/bits/locale_facets.h" 3
explicit ctype(__c_locale __cloc, const mask * __table = 0, bool __del = false, size_t __refs = 0); 
# 744 "/usr/include/c++/5/bits/locale_facets.h" 3
inline bool is(mask __m, char __c) const; 
# 759 "/usr/include/c++/5/bits/locale_facets.h" 3
inline const char *is(const char * __lo, const char * __hi, mask * __vec) const; 
# 773 "/usr/include/c++/5/bits/locale_facets.h" 3
inline const char *scan_is(mask __m, const char * __lo, const char * __hi) const; 
# 787 "/usr/include/c++/5/bits/locale_facets.h" 3
inline const char *scan_not(mask __m, const char * __lo, const char * __hi) const; 
# 802 "/usr/include/c++/5/bits/locale_facets.h" 3
char_type toupper(char_type __c) const 
# 803
{ return this->do_toupper(__c); } 
# 819 "/usr/include/c++/5/bits/locale_facets.h" 3
const char_type *toupper(char_type *__lo, const char_type *__hi) const 
# 820
{ return this->do_toupper(__lo, __hi); } 
# 835 "/usr/include/c++/5/bits/locale_facets.h" 3
char_type tolower(char_type __c) const 
# 836
{ return this->do_tolower(__c); } 
# 852 "/usr/include/c++/5/bits/locale_facets.h" 3
const char_type *tolower(char_type *__lo, const char_type *__hi) const 
# 853
{ return this->do_tolower(__lo, __hi); } 
# 872 "/usr/include/c++/5/bits/locale_facets.h" 3
char_type widen(char __c) const 
# 873
{ 
# 874
if (_M_widen_ok) { 
# 875
return (_M_widen)[static_cast< unsigned char>(__c)]; }  
# 876
this->_M_widen_init(); 
# 877
return this->do_widen(__c); 
# 878
} 
# 899 "/usr/include/c++/5/bits/locale_facets.h" 3
const char *widen(const char *__lo, const char *__hi, char_type *__to) const 
# 900
{ 
# 901
if ((_M_widen_ok) == 1) 
# 902
{ 
# 903
__builtin_memcpy(__to, __lo, __hi - __lo); 
# 904
return __hi; 
# 905
}  
# 906
if (!(_M_widen_ok)) { 
# 907
this->_M_widen_init(); }  
# 908
return this->do_widen(__lo, __hi, __to); 
# 909
} 
# 930 "/usr/include/c++/5/bits/locale_facets.h" 3
char narrow(char_type __c, char __dfault) const 
# 931
{ 
# 932
if ((_M_narrow)[static_cast< unsigned char>(__c)]) { 
# 933
return (_M_narrow)[static_cast< unsigned char>(__c)]; }  
# 934
const char __t = this->do_narrow(__c, __dfault); 
# 935
if (__t != __dfault) { 
# 936
((_M_narrow)[static_cast< unsigned char>(__c)]) = __t; }  
# 937
return __t; 
# 938
} 
# 963 "/usr/include/c++/5/bits/locale_facets.h" 3
const char_type *narrow(const char_type *__lo, const char_type *__hi, char 
# 964
__dfault, char *__to) const 
# 965
{ 
# 966
if (__builtin_expect((_M_narrow_ok) == 1, true)) 
# 967
{ 
# 968
__builtin_memcpy(__to, __lo, __hi - __lo); 
# 969
return __hi; 
# 970
}  
# 971
if (!(_M_narrow_ok)) { 
# 972
this->_M_narrow_init(); }  
# 973
return this->do_narrow(__lo, __hi, __dfault, __to); 
# 974
} 
# 981
const mask *table() const throw() 
# 982
{ return _M_table; } 
# 986
static const mask *classic_table() throw(); 
# 996
protected: virtual ~ctype(); 
# 1012 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_toupper(char_type __c) const; 
# 1029 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 1045 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_tolower(char_type __c) const; 
# 1062 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 1082 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_widen(char __c) const 
# 1083
{ return __c; } 
# 1105 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const 
# 1106
{ 
# 1107
__builtin_memcpy(__to, __lo, __hi - __lo); 
# 1108
return __hi; 
# 1109
} 
# 1131 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char do_narrow(char_type __c, char __dfault) const 
# 1132
{ return __c; } 
# 1157 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char 
# 1158
__dfault, char *__to) const 
# 1159
{ 
# 1160
__builtin_memcpy(__to, __lo, __hi - __lo); 
# 1161
return __hi; 
# 1162
} 
# 1165
private: void _M_narrow_init() const; 
# 1166
void _M_widen_init() const; 
# 1167
}; 
# 1182 "/usr/include/c++/5/bits/locale_facets.h" 3
template<> class ctype< wchar_t>  : public __ctype_abstract_base< wchar_t>  { 
# 1187
public: typedef wchar_t char_type; 
# 1188
typedef wctype_t __wmask_type; 
# 1191
protected: __c_locale _M_c_locale_ctype; 
# 1194
bool _M_narrow_ok; 
# 1195
char _M_narrow[128]; 
# 1196
wint_t _M_widen[1 + (static_cast< unsigned char>(-1))]; 
# 1199
mask _M_bit[16]; 
# 1200
__wmask_type _M_wmask[16]; 
# 1205
public: static locale::id id; 
# 1215 "/usr/include/c++/5/bits/locale_facets.h" 3
explicit ctype(size_t __refs = 0); 
# 1226 "/usr/include/c++/5/bits/locale_facets.h" 3
explicit ctype(__c_locale __cloc, size_t __refs = 0); 
# 1230
protected: __wmask_type _M_convert_to_wmask(const mask __m) const throw(); 
# 1234
virtual ~ctype(); 
# 1250 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual bool do_is(mask __m, char_type __c) const; 
# 1269 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const; 
# 1287 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 1305 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 1322 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_toupper(char_type __c) const; 
# 1339 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 1355 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_tolower(char_type __c) const; 
# 1372 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 1392 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_widen(char __c) const; 
# 1414 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char *do_widen(const char * __lo, const char * __hi, char_type * __to) const; 
# 1437 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char do_narrow(char_type __c, char __dfault) const; 
# 1463 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual const char_type *do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const; 
# 1468
void _M_initialize_ctype() throw(); 
# 1469
}; 
# 1473
template< class _CharT> 
# 1474
class ctype_byname : public ctype< _CharT>  { 
# 1477
public: typedef typename ::std::ctype< _CharT> ::mask mask; 
# 1480
explicit ctype_byname(const char * __s, ::std::size_t __refs = 0); 
# 1484
explicit ctype_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs = 0) : ctype_byname(__s.c_str(), __refs) 
# 1485
{ } 
# 1490
protected: virtual ~ctype_byname() { } 
# 1491
}; 
# 1495
template<> class ctype_byname< char>  : public ctype< char>  { 
# 1499
public: explicit ctype_byname(const char * __s, size_t __refs = 0); 
# 1503
explicit ctype_byname(const __cxx11::string & __s, size_t __refs = 0); 
# 1508
protected: virtual ~ctype_byname(); 
# 1509
}; 
# 1513
template<> class ctype_byname< wchar_t>  : public ctype< wchar_t>  { 
# 1517
public: explicit ctype_byname(const char * __s, size_t __refs = 0); 
# 1521
explicit ctype_byname(const __cxx11::string & __s, size_t __refs = 0); 
# 1526
protected: virtual ~ctype_byname(); 
# 1527
}; 
# 1531
}
# 37 "/usr/include/aarch64-linux-gnu/c++/5/bits/ctype_inline.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
inline bool ctype< char> ::is(mask __m, char __c) const 
# 44
{ return ((_M_table)[static_cast< unsigned char>(__c)]) & __m; } 
# 48
inline const char *ctype< char> ::is(const char *__low, const char *__high, mask *__vec) const 
# 49
{ 
# 50
while (__low < __high) { 
# 51
(*(__vec++)) = ((_M_table)[static_cast< unsigned char>(*(__low++))]); }  
# 52
return __high; 
# 53
} 
# 57
inline const char *ctype< char> ::scan_is(mask __m, const char *__low, const char *__high) const 
# 58
{ 
# 59
while ((__low < __high) && (!(((_M_table)[static_cast< unsigned char>(*__low)]) & __m))) { 
# 61
++__low; }  
# 62
return __low; 
# 63
} 
# 67
inline const char *ctype< char> ::scan_not(mask __m, const char *__low, const char *__high) const 
# 68
{ 
# 69
while ((__low < __high) && ((((_M_table)[static_cast< unsigned char>(*__low)]) & __m) != 0)) { 
# 71
++__low; }  
# 72
return __low; 
# 73
} 
# 76
}
# 1536 "/usr/include/c++/5/bits/locale_facets.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 1541
class __num_base { 
# 1547
public: enum { 
# 1548
_S_ominus, 
# 1549
_S_oplus, 
# 1550
_S_ox, 
# 1551
_S_oX, 
# 1552
_S_odigits, 
# 1553
_S_odigits_end = 20, 
# 1554
_S_oudigits = 20, 
# 1555
_S_oudigits_end = 36, 
# 1556
_S_oe = 18, 
# 1557
_S_oE = 34, 
# 1558
_S_oend = 36
# 1559
}; 
# 1566
static const char *_S_atoms_out; 
# 1570
static const char *_S_atoms_in; 
# 1573
enum { 
# 1574
_S_iminus, 
# 1575
_S_iplus, 
# 1576
_S_ix, 
# 1577
_S_iX, 
# 1578
_S_izero, 
# 1579
_S_ie = 18, 
# 1580
_S_iE = 24, 
# 1581
_S_iend = 26
# 1582
}; 
# 1587
static void _S_format_float(const ios_base & __io, char * __fptr, char __mod) throw(); 
# 1588
}; 
# 1590
template< class _CharT> 
# 1591
struct __numpunct_cache : public locale::facet { 
# 1593
const char *_M_grouping; 
# 1594
size_t _M_grouping_size; 
# 1595
bool _M_use_grouping; 
# 1596
const _CharT *_M_truename; 
# 1597
size_t _M_truename_size; 
# 1598
const _CharT *_M_falsename; 
# 1599
size_t _M_falsename_size; 
# 1600
_CharT _M_decimal_point; 
# 1601
_CharT _M_thousands_sep; 
# 1607
_CharT _M_atoms_out[__num_base::_S_oend]; 
# 1613
_CharT _M_atoms_in[__num_base::_S_iend]; 
# 1615
bool _M_allocated; 
# 1617
__numpunct_cache(size_t __refs = 0) : locale::facet(__refs), _M_grouping((0)), _M_grouping_size((0)), _M_use_grouping(false), _M_truename((0)), _M_truename_size((0)), _M_falsename((0)), _M_falsename_size((0)), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false) 
# 1623
{ } 
# 1625
virtual ~__numpunct_cache(); 
# 1628
void _M_cache(const locale & __loc); 
# 1632
private: __numpunct_cache &operator=(const __numpunct_cache &); 
# 1635
explicit __numpunct_cache(const __numpunct_cache &); 
# 1636
}; 
# 1638
template< class _CharT> 
# 1639
__numpunct_cache< _CharT> ::~__numpunct_cache() 
# 1640
{ 
# 1641
if (_M_allocated) 
# 1642
{ 
# 1643
delete [] (_M_grouping); 
# 1644
delete [] (_M_truename); 
# 1645
delete [] (_M_falsename); 
# 1646
}  
# 1647
} 
# 1649
inline namespace __cxx11 { 
# 1665 "/usr/include/c++/5/bits/locale_facets.h" 3
template< class _CharT> 
# 1666
class numpunct : public locale::facet { 
# 1672
public: typedef _CharT char_type; 
# 1673
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 1675
typedef __numpunct_cache< _CharT>  __cache_type; 
# 1678
protected: __cache_type *_M_data; 
# 1682
public: static locale::id id; 
# 1690
explicit numpunct(size_t __refs = 0) : locale::facet(__refs), _M_data((0)) 
# 1692
{ _M_initialize_numpunct(); } 
# 1704 "/usr/include/c++/5/bits/locale_facets.h" 3
explicit numpunct(__cache_type *__cache, size_t __refs = 0) : locale::facet(__refs), _M_data(__cache) 
# 1706
{ _M_initialize_numpunct(); } 
# 1718 "/usr/include/c++/5/bits/locale_facets.h" 3
explicit numpunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs), _M_data((0)) 
# 1720
{ _M_initialize_numpunct(__cloc); } 
# 1732 "/usr/include/c++/5/bits/locale_facets.h" 3
char_type decimal_point() const 
# 1733
{ return this->do_decimal_point(); } 
# 1745 "/usr/include/c++/5/bits/locale_facets.h" 3
char_type thousands_sep() const 
# 1746
{ return this->do_thousands_sep(); } 
# 1776 "/usr/include/c++/5/bits/locale_facets.h" 3
string grouping() const 
# 1777
{ return this->do_grouping(); } 
# 1789 "/usr/include/c++/5/bits/locale_facets.h" 3
string_type truename() const 
# 1790
{ return this->do_truename(); } 
# 1802 "/usr/include/c++/5/bits/locale_facets.h" 3
string_type falsename() const 
# 1803
{ return this->do_falsename(); } 
# 1808
protected: virtual ~numpunct(); 
# 1819 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_decimal_point() const 
# 1820
{ return (_M_data)->_M_decimal_point; } 
# 1831 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual char_type do_thousands_sep() const 
# 1832
{ return (_M_data)->_M_thousands_sep; } 
# 1844 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual string do_grouping() const 
# 1845
{ return ((_M_data)->_M_grouping); } 
# 1857 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual string_type do_truename() const 
# 1858
{ return ((_M_data)->_M_truename); } 
# 1870 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual string_type do_falsename() const 
# 1871
{ return ((_M_data)->_M_falsename); } 
# 1875
void _M_initialize_numpunct(__c_locale __cloc = 0); 
# 1876
}; 
# 1878
template< class _CharT> locale::id 
# 1879
numpunct< _CharT> ::id; 
# 1882
template<> numpunct< char> ::~numpunct(); 
# 1886
template<> void numpunct< char> ::_M_initialize_numpunct(__c_locale __cloc); 
# 1890
template<> numpunct< wchar_t> ::~numpunct(); 
# 1894
template<> void numpunct< wchar_t> ::_M_initialize_numpunct(__c_locale __cloc); 
# 1898
template< class _CharT> 
# 1899
class numpunct_byname : public numpunct< _CharT>  { 
# 1902
public: typedef _CharT char_type; 
# 1903
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 1906
explicit numpunct_byname(const char *__s, ::std::size_t __refs = 0) : ::std::__cxx11::numpunct< _CharT> (__refs) 
# 1908
{ 
# 1909
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 1911
{ 
# 1912
::std::__c_locale __tmp; 
# 1913
(this->_S_create_c_locale(__tmp, __s)); 
# 1914
(this->_M_initialize_numpunct(__tmp)); 
# 1915
(this->_S_destroy_c_locale(__tmp)); 
# 1916
}  
# 1917
} 
# 1921
explicit numpunct_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs = 0) : numpunct_byname(__s.c_str(), __refs) 
# 1922
{ } 
# 1927
protected: virtual ~numpunct_byname() { } 
# 1928
}; 
# 1930
}
# 1947 "/usr/include/c++/5/bits/locale_facets.h" 3
template< class _CharT, class _InIter> 
# 1948
class num_get : public locale::facet { 
# 1954
public: typedef _CharT char_type; 
# 1955
typedef _InIter iter_type; 
# 1959
static locale::id id; 
# 1969 "/usr/include/c++/5/bits/locale_facets.h" 3
explicit num_get(size_t __refs = 0) : locale::facet(__refs) { } 
# 1995 "/usr/include/c++/5/bits/locale_facets.h" 3
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 1996
__err, bool &__v) const 
# 1997
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2032 "/usr/include/c++/5/bits/locale_facets.h" 3
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2033
__err, long &__v) const 
# 2034
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2037
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2038
__err, unsigned short &__v) const 
# 2039
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2042
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2043
__err, unsigned &__v) const 
# 2044
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2047
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2048
__err, unsigned long &__v) const 
# 2049
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2053
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2054
__err, long long &__v) const 
# 2055
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2058
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2059
__err, unsigned long long &__v) const 
# 2060
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2092 "/usr/include/c++/5/bits/locale_facets.h" 3
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2093
__err, float &__v) const 
# 2094
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2097
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2098
__err, double &__v) const 
# 2099
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2102
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2103
__err, long double &__v) const 
# 2104
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2135 "/usr/include/c++/5/bits/locale_facets.h" 3
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2136
__err, void *&__v) const 
# 2137
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2141
protected: virtual ~num_get() { } 
# 2143
__attribute((__abi_tag__("cxx11"))) iter_type 
# 2145
_M_extract_float(iter_type, iter_type, ios_base &, ios_base::iostate &, __cxx11::string &) const; 
# 2148
template< class _ValueT> 
# 2149
__attribute((__abi_tag__("cxx11"))) iter_type 
# 2148
_M_extract_int(iter_type, iter_type, ios_base &, ios_base::iostate &, _ValueT &) const; 
# 2154
template< class _CharT2> typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, int> ::__type 
# 2156
_M_find(const _CharT2 *, size_t __len, _CharT2 __c) const 
# 2157
{ 
# 2158
int __ret = (-1); 
# 2159
if (__len <= (10)) 
# 2160
{ 
# 2161
if ((__c >= ((_CharT2)'0')) && (__c < ((_CharT2)(((_CharT2)'0') + __len)))) { 
# 2162
__ret = (__c - ((_CharT2)'0')); }  
# 2163
} else 
# 2165
{ 
# 2166
if ((__c >= ((_CharT2)'0')) && (__c <= ((_CharT2)'9'))) { 
# 2167
__ret = (__c - ((_CharT2)'0')); } else { 
# 2168
if ((__c >= ((_CharT2)'a')) && (__c <= ((_CharT2)'f'))) { 
# 2169
__ret = (10 + (__c - ((_CharT2)'a'))); } else { 
# 2170
if ((__c >= ((_CharT2)'A')) && (__c <= ((_CharT2)'F'))) { 
# 2171
__ret = (10 + (__c - ((_CharT2)'A'))); }  }  }  
# 2172
}  
# 2173
return __ret; 
# 2174
} 
# 2176
template< class _CharT2> typename __gnu_cxx::__enable_if< !__is_char< _CharT2> ::__value, int> ::__type 
# 2179
_M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const 
# 2180
{ 
# 2181
int __ret = (-1); 
# 2182
const char_type *__q = char_traits< _CharT2> ::find(__zero, __len, __c); 
# 2183
if (__q) 
# 2184
{ 
# 2185
__ret = (__q - __zero); 
# 2186
if (__ret > 15) { 
# 2187
__ret -= 6; }  
# 2188
}  
# 2189
return __ret; 
# 2190
} 
# 2208 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, bool &) const; 
# 2211
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2212
__err, long &__v) const 
# 2213
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2216
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2217
__err, unsigned short &__v) const 
# 2218
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2221
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2222
__err, unsigned &__v) const 
# 2223
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2226
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2227
__err, unsigned long &__v) const 
# 2228
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2232
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2233
__err, long long &__v) const 
# 2234
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2237
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2238
__err, unsigned long long &__v) const 
# 2239
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2243
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, float &) const; 
# 2246
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, double &) const; 
# 2256
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, long double &) const; 
# 2261
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, void *&) const; 
# 2270 "/usr/include/c++/5/bits/locale_facets.h" 3
}; 
# 2272
template< class _CharT, class _InIter> locale::id 
# 2273
num_get< _CharT, _InIter> ::id; 
# 2288 "/usr/include/c++/5/bits/locale_facets.h" 3
template< class _CharT, class _OutIter> 
# 2289
class num_put : public locale::facet { 
# 2295
public: typedef _CharT char_type; 
# 2296
typedef _OutIter iter_type; 
# 2300
static locale::id id; 
# 2310 "/usr/include/c++/5/bits/locale_facets.h" 3
explicit num_put(size_t __refs = 0) : locale::facet(__refs) { } 
# 2328 "/usr/include/c++/5/bits/locale_facets.h" 3
iter_type put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const 
# 2329
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2370 "/usr/include/c++/5/bits/locale_facets.h" 3
iter_type put(iter_type __s, ios_base &__io, char_type __fill, long __v) const 
# 2371
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2374
iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long 
# 2375
__v) const 
# 2376
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2380
iter_type put(iter_type __s, ios_base &__io, char_type __fill, long long __v) const 
# 2381
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2384
iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long 
# 2385
__v) const 
# 2386
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2433 "/usr/include/c++/5/bits/locale_facets.h" 3
iter_type put(iter_type __s, ios_base &__io, char_type __fill, double __v) const 
# 2434
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2437
iter_type put(iter_type __s, ios_base &__io, char_type __fill, long double 
# 2438
__v) const 
# 2439
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2458 "/usr/include/c++/5/bits/locale_facets.h" 3
iter_type put(iter_type __s, ios_base &__io, char_type __fill, const void *
# 2459
__v) const 
# 2460
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2463
protected: template< class _ValueT> iter_type _M_insert_float(iter_type, ios_base & __io, char_type __fill, char __mod, _ValueT __v) const; 
# 2469
void _M_group_float(const char * __grouping, size_t __grouping_size, char_type __sep, const char_type * __p, char_type * __new, char_type * __cs, int & __len) const; 
# 2473
template< class _ValueT> iter_type _M_insert_int(iter_type, ios_base & __io, char_type __fill, _ValueT __v) const; 
# 2479
void _M_group_int(const char * __grouping, size_t __grouping_size, char_type __sep, ios_base & __io, char_type * __new, char_type * __cs, int & __len) const; 
# 2484
void _M_pad(char_type __fill, streamsize __w, ios_base & __io, char_type * __new, const char_type * __cs, int & __len) const; 
# 2489
virtual ~num_put() { } 
# 2506 "/usr/include/c++/5/bits/locale_facets.h" 3
virtual iter_type do_put(iter_type __s, ios_base & __io, char_type __fill, bool __v) const; 
# 2509
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long __v) const 
# 2510
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2513
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long 
# 2514
__v) const 
# 2515
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2519
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long long 
# 2520
__v) const 
# 2521
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2524
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long 
# 2525
__v) const 
# 2526
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2530
virtual iter_type do_put(iter_type, ios_base &, char_type, double) const; 
# 2538
virtual iter_type do_put(iter_type, ios_base &, char_type, long double) const; 
# 2542
virtual iter_type do_put(iter_type, ios_base &, char_type, const void *) const; 
# 2550
}; 
# 2552
template< class _CharT, class _OutIter> locale::id 
# 2553
num_put< _CharT, _OutIter> ::id; 
# 2563
template< class _CharT> inline bool 
# 2565
isspace(_CharT __c, const locale &__loc) 
# 2566
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::space, __c)); } 
# 2569
template< class _CharT> inline bool 
# 2571
isprint(_CharT __c, const locale &__loc) 
# 2572
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::print, __c)); } 
# 2575
template< class _CharT> inline bool 
# 2577
iscntrl(_CharT __c, const locale &__loc) 
# 2578
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::cntrl, __c)); } 
# 2581
template< class _CharT> inline bool 
# 2583
isupper(_CharT __c, const locale &__loc) 
# 2584
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::upper, __c)); } 
# 2587
template< class _CharT> inline bool 
# 2589
islower(_CharT __c, const locale &__loc) 
# 2590
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::lower, __c)); } 
# 2593
template< class _CharT> inline bool 
# 2595
isalpha(_CharT __c, const locale &__loc) 
# 2596
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::alpha, __c)); } 
# 2599
template< class _CharT> inline bool 
# 2601
isdigit(_CharT __c, const locale &__loc) 
# 2602
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::digit, __c)); } 
# 2605
template< class _CharT> inline bool 
# 2607
ispunct(_CharT __c, const locale &__loc) 
# 2608
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::punct, __c)); } 
# 2611
template< class _CharT> inline bool 
# 2613
isxdigit(_CharT __c, const locale &__loc) 
# 2614
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::xdigit, __c)); } 
# 2617
template< class _CharT> inline bool 
# 2619
isalnum(_CharT __c, const locale &__loc) 
# 2620
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::alnum, __c)); } 
# 2623
template< class _CharT> inline bool 
# 2625
isgraph(_CharT __c, const locale &__loc) 
# 2626
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::graph, __c)); } 
# 2630
template< class _CharT> inline bool 
# 2632
isblank(_CharT __c, const locale &__loc) 
# 2633
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::blank, __c)); } 
# 2637
template< class _CharT> inline _CharT 
# 2639
toupper(_CharT __c, const locale &__loc) 
# 2640
{ return (use_facet< ctype< _CharT> > (__loc).toupper(__c)); } 
# 2643
template< class _CharT> inline _CharT 
# 2645
tolower(_CharT __c, const locale &__loc) 
# 2646
{ return (use_facet< ctype< _CharT> > (__loc).tolower(__c)); } 
# 2649
}
# 35 "/usr/include/c++/5/bits/locale_facets.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
template< class _Facet> 
# 42
struct __use_cache { 
# 45
const _Facet *operator()(const locale & __loc) const; 
# 46
}; 
# 49
template< class _CharT> 
# 50
struct __use_cache< __numpunct_cache< _CharT> >  { 
# 53
const __numpunct_cache< _CharT>  *operator()(const locale &__loc) const 
# 54
{ 
# 55
const size_t __i = (numpunct< _CharT> ::id._M_id)(); 
# 56
const locale::facet **__caches = (__loc._M_impl)->_M_caches; 
# 57
if (!(__caches[__i])) 
# 58
{ 
# 59
__numpunct_cache< _CharT>  *__tmp = (0); 
# 60
try 
# 61
{ 
# 62
__tmp = (new __numpunct_cache< _CharT> ); 
# 63
(__tmp->_M_cache(__loc)); 
# 64
} 
# 65
catch (...) 
# 66
{ 
# 67
delete __tmp; 
# 68
throw; 
# 69
}  
# 70
(__loc._M_impl)->_M_install_cache(__tmp, __i); 
# 71
}  
# 72
return static_cast< const __numpunct_cache< _CharT>  *>(__caches[__i]); 
# 73
} 
# 74
}; 
# 76
template< class _CharT> void 
# 78
__numpunct_cache< _CharT> ::_M_cache(const locale &__loc) 
# 79
{ 
# 80
const __cxx11::numpunct< _CharT>  &__np = use_facet< __cxx11::numpunct< _CharT> > (__loc); 
# 82
char *__grouping = (0); 
# 83
_CharT *__truename = (0); 
# 84
_CharT *__falsename = (0); 
# 85
try 
# 86
{ 
# 87
const __cxx11::string &__g = (__np.grouping()); 
# 88
(_M_grouping_size) = __g.size(); 
# 89
__grouping = (new char [_M_grouping_size]); 
# 90
__g.copy(__grouping, _M_grouping_size); 
# 91
(_M_use_grouping) = ((_M_grouping_size) && ((static_cast< signed char>(__grouping[0])) > 0) && ((__grouping[0]) != __gnu_cxx::__numeric_traits_integer< char> ::__max)); 
# 96
const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &__tn = (__np.truename()); 
# 97
(_M_truename_size) = (__tn.size()); 
# 98
__truename = (new _CharT [_M_truename_size]); 
# 99
(__tn.copy(__truename, _M_truename_size)); 
# 101
const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &__fn = (__np.falsename()); 
# 102
(_M_falsename_size) = (__fn.size()); 
# 103
__falsename = (new _CharT [_M_falsename_size]); 
# 104
(__fn.copy(__falsename, _M_falsename_size)); 
# 106
(_M_decimal_point) = (__np.decimal_point()); 
# 107
(_M_thousands_sep) = (__np.thousands_sep()); 
# 109
const ctype< _CharT>  &__ct = use_facet< ctype< _CharT> > (__loc); 
# 110
(__ct.widen(__num_base::_S_atoms_out, __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out)); 
# 113
(__ct.widen(__num_base::_S_atoms_in, __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in)); 
# 117
(_M_grouping) = __grouping; 
# 118
(_M_truename) = __truename; 
# 119
(_M_falsename) = __falsename; 
# 120
(_M_allocated) = true; 
# 121
} 
# 122
catch (...) 
# 123
{ 
# 124
delete [] __grouping; 
# 125
delete [] __truename; 
# 126
delete [] __falsename; 
# 127
throw; 
# 128
}  
# 129
} 
# 139 "/usr/include/c++/5/bits/locale_facets.tcc" 3
__attribute((__pure__)) bool 
# 140
__verify_grouping(const char * __grouping, size_t __grouping_size, const __cxx11::string & __grouping_tmp) throw(); 
# 145
template< class _CharT, class _InIter> 
# 146
__attribute((__abi_tag__("cxx11"))) _InIter 
# 149
num_get< _CharT, _InIter> ::_M_extract_float(_InIter __beg, _InIter __end, ios_base &__io, ios_base::iostate &
# 150
__err, __cxx11::string &__xtrc) const 
# 151
{ 
# 152
typedef char_traits< _CharT>  __traits_type; 
# 153
typedef __numpunct_cache< _CharT>  __cache_type; 
# 154
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 155
const locale &__loc = __io._M_getloc(); 
# 156
const __cache_type *__lc = __uc(__loc); 
# 157
const _CharT *__lit = ((__lc->_M_atoms_in)); 
# 158
char_type __c = (char_type()); 
# 161
bool __testeof = __beg == __end; 
# 164
if (!__testeof) 
# 165
{ 
# 166
__c = (*__beg); 
# 167
const bool __plus = __c == (__lit[__num_base::_S_iplus]); 
# 168
if ((__plus || (__c == (__lit[__num_base::_S_iminus]))) && (!((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)))) && (!(__c == (__lc->_M_decimal_point)))) 
# 171
{ 
# 172
(__xtrc += (__plus ? '+' : '-')); 
# 173
if ((++__beg) != __end) { 
# 174
__c = (*__beg); } else { 
# 176
__testeof = true; }  
# 177
}  
# 178
}  
# 181
bool __found_mantissa = false; 
# 182
int __sep_pos = 0; 
# 183
while (!__testeof) 
# 184
{ 
# 185
if (((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) || (__c == (__lc->_M_decimal_point))) { 
# 187
break; } else { 
# 188
if (__c == (__lit[__num_base::_S_izero])) 
# 189
{ 
# 190
if (!__found_mantissa) 
# 191
{ 
# 192
(__xtrc += ('0')); 
# 193
__found_mantissa = true; 
# 194
}  
# 195
++__sep_pos; 
# 197
if ((++__beg) != __end) { 
# 198
__c = (*__beg); } else { 
# 200
__testeof = true; }  
# 201
} else { 
# 203
break; }  }  
# 204
}  
# 207
bool __found_dec = false; 
# 208
bool __found_sci = false; 
# 209
__cxx11::string __found_grouping; 
# 210
if (__lc->_M_use_grouping) { 
# 211
__found_grouping.reserve(32); }  
# 212
const char_type *__lit_zero = __lit + __num_base::_S_izero; 
# 214
if (!(__lc->_M_allocated)) { 
# 216
while (!__testeof) { 
# 217
{ 
# 218
const int __digit = _M_find(__lit_zero, 10, __c); 
# 219
if (__digit != (-1)) 
# 220
{ 
# 221
(__xtrc += (('0') + __digit)); 
# 222
__found_mantissa = true; 
# 223
} else { 
# 224
if ((__c == (__lc->_M_decimal_point)) && (!__found_dec) && (!__found_sci)) 
# 226
{ 
# 227
(__xtrc += ('.')); 
# 228
__found_dec = true; 
# 229
} else { 
# 230
if (((__c == (__lit[__num_base::_S_ie])) || (__c == (__lit[__num_base::_S_iE]))) && (!__found_sci) && __found_mantissa) 
# 233
{ 
# 235
(__xtrc += ('e')); 
# 236
__found_sci = true; 
# 239
if ((++__beg) != __end) 
# 240
{ 
# 241
__c = (*__beg); 
# 242
const bool __plus = __c == (__lit[__num_base::_S_iplus]); 
# 243
if (__plus || (__c == (__lit[__num_base::_S_iminus]))) { 
# 244
(__xtrc += (__plus ? '+' : '-')); } else { 
# 246
continue; }  
# 247
} else 
# 249
{ 
# 250
__testeof = true; 
# 251
break; 
# 252
}  
# 253
} else { 
# 255
break; }  }  }  
# 257
if ((++__beg) != __end) { 
# 258
__c = (*__beg); } else { 
# 260
__testeof = true; }  
# 261
} }  } else { 
# 263
while (!__testeof) { 
# 264
{ 
# 267
if ((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) 
# 268
{ 
# 269
if ((!__found_dec) && (!__found_sci)) 
# 270
{ 
# 273
if (__sep_pos) 
# 274
{ 
# 275
(__found_grouping += (static_cast< char>(__sep_pos))); 
# 276
__sep_pos = 0; 
# 277
} else 
# 279
{ 
# 282
__xtrc.clear(); 
# 283
break; 
# 284
}  
# 285
} else { 
# 287
break; }  
# 288
} else { 
# 289
if (__c == (__lc->_M_decimal_point)) 
# 290
{ 
# 291
if ((!__found_dec) && (!__found_sci)) 
# 292
{ 
# 296
if (__found_grouping.size()) { 
# 297
(__found_grouping += (static_cast< char>(__sep_pos))); }  
# 298
(__xtrc += ('.')); 
# 299
__found_dec = true; 
# 300
} else { 
# 302
break; }  
# 303
} else 
# 305
{ 
# 306
const char_type *__q = __traits_type::find(__lit_zero, 10, __c); 
# 308
if (__q) 
# 309
{ 
# 310
__xtrc += ('0' + (__q - __lit_zero)); 
# 311
__found_mantissa = true; 
# 312
++__sep_pos; 
# 313
} else { 
# 314
if (((__c == (__lit[__num_base::_S_ie])) || (__c == (__lit[__num_base::_S_iE]))) && (!__found_sci) && __found_mantissa) 
# 317
{ 
# 319
if ((__found_grouping.size()) && (!__found_dec)) { 
# 320
(__found_grouping += (static_cast< char>(__sep_pos))); }  
# 321
(__xtrc += ('e')); 
# 322
__found_sci = true; 
# 325
if ((++__beg) != __end) 
# 326
{ 
# 327
__c = (*__beg); 
# 328
const bool __plus = __c == (__lit[__num_base::_S_iplus]); 
# 329
if ((__plus || (__c == (__lit[__num_base::_S_iminus]))) && (!((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)))) && (!(__c == (__lc->_M_decimal_point)))) { 
# 333
(__xtrc += (__plus ? '+' : '-')); } else { 
# 335
continue; }  
# 336
} else 
# 338
{ 
# 339
__testeof = true; 
# 340
break; 
# 341
}  
# 342
} else { 
# 344
break; }  }  
# 345
}  }  
# 347
if ((++__beg) != __end) { 
# 348
__c = (*__beg); } else { 
# 350
__testeof = true; }  
# 351
} }  }  
# 355
if (__found_grouping.size()) 
# 356
{ 
# 358
if ((!__found_dec) && (!__found_sci)) { 
# 359
(__found_grouping += (static_cast< char>(__sep_pos))); }  
# 361
if (!std::__verify_grouping((__lc->_M_grouping), (__lc->_M_grouping_size), __found_grouping)) { 
# 364
__err = ios_base::failbit; }  
# 365
}  
# 367
return __beg; 
# 368
} 
# 370
template< class _CharT, class _InIter> 
# 371
template< class _ValueT> 
# 372
__attribute((__abi_tag__("cxx11"))) _InIter 
# 375
num_get< _CharT, _InIter> ::_M_extract_int(_InIter __beg, _InIter __end, ios_base &__io, ios_base::iostate &
# 376
__err, _ValueT &__v) const 
# 377
{ 
# 378
typedef char_traits< _CharT>  __traits_type; 
# 379
using __gnu_cxx::__add_unsigned;
# 380
typedef typename __gnu_cxx::__add_unsigned< _ValueT> ::__type __unsigned_type; 
# 381
typedef __numpunct_cache< _CharT>  __cache_type; 
# 382
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 383
const locale &__loc = __io._M_getloc(); 
# 384
const __cache_type *__lc = __uc(__loc); 
# 385
const _CharT *__lit = ((__lc->_M_atoms_in)); 
# 386
char_type __c = (char_type()); 
# 389
const ios_base::fmtflags __basefield = ((__io.flags()) & ios_base::basefield); 
# 391
const bool __oct = __basefield == ios_base::oct; 
# 392
int __base = __oct ? 8 : ((__basefield == ios_base::hex) ? 16 : 10); 
# 395
bool __testeof = __beg == __end; 
# 398
bool __negative = false; 
# 399
if (!__testeof) 
# 400
{ 
# 401
__c = (*__beg); 
# 402
__negative = (__c == (__lit[__num_base::_S_iminus])); 
# 403
if ((__negative || (__c == (__lit[__num_base::_S_iplus]))) && (!((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)))) && (!(__c == (__lc->_M_decimal_point)))) 
# 406
{ 
# 407
if ((++__beg) != __end) { 
# 408
__c = (*__beg); } else { 
# 410
__testeof = true; }  
# 411
}  
# 412
}  
# 416
bool __found_zero = false; 
# 417
int __sep_pos = 0; 
# 418
while (!__testeof) 
# 419
{ 
# 420
if (((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) || (__c == (__lc->_M_decimal_point))) { 
# 422
break; } else { 
# 423
if ((__c == (__lit[__num_base::_S_izero])) && ((!__found_zero) || (__base == 10))) 
# 425
{ 
# 426
__found_zero = true; 
# 427
++__sep_pos; 
# 428
if (__basefield == 0) { 
# 429
__base = 8; }  
# 430
if (__base == 8) { 
# 431
__sep_pos = 0; }  
# 432
} else { 
# 433
if (__found_zero && ((__c == (__lit[__num_base::_S_ix])) || (__c == (__lit[__num_base::_S_iX])))) 
# 436
{ 
# 437
if (__basefield == 0) { 
# 438
__base = 16; }  
# 439
if (__base == 16) 
# 440
{ 
# 441
__found_zero = false; 
# 442
__sep_pos = 0; 
# 443
} else { 
# 445
break; }  
# 446
} else { 
# 448
break; }  }  }  
# 450
if ((++__beg) != __end) 
# 451
{ 
# 452
__c = (*__beg); 
# 453
if (!__found_zero) { 
# 454
break; }  
# 455
} else { 
# 457
__testeof = true; }  
# 458
}  
# 462
const size_t __len = (__base == 16) ? (__num_base::_S_iend) - (__num_base::_S_izero) : __base; 
# 466
__cxx11::string __found_grouping; 
# 467
if (__lc->_M_use_grouping) { 
# 468
__found_grouping.reserve(32); }  
# 469
bool __testfail = false; 
# 470
bool __testoverflow = false; 
# 471
const __unsigned_type __max = (__negative && __gnu_cxx::__numeric_traits< _ValueT> ::__is_signed) ? -__gnu_cxx::__numeric_traits< _ValueT> ::__min : __gnu_cxx::__numeric_traits< _ValueT> ::__max; 
# 475
const __unsigned_type __smax = __max / __base; 
# 476
__unsigned_type __result = (0); 
# 477
int __digit = 0; 
# 478
const char_type *__lit_zero = __lit + __num_base::_S_izero; 
# 480
if (!(__lc->_M_allocated)) { 
# 482
while (!__testeof) 
# 483
{ 
# 484
__digit = _M_find(__lit_zero, __len, __c); 
# 485
if (__digit == (-1)) { 
# 486
break; }  
# 488
if (__result > __smax) { 
# 489
__testoverflow = true; } else 
# 491
{ 
# 492
__result *= __base; 
# 493
__testoverflow |= (__result > (__max - __digit)); 
# 494
__result += __digit; 
# 495
++__sep_pos; 
# 496
}  
# 498
if ((++__beg) != __end) { 
# 499
__c = (*__beg); } else { 
# 501
__testeof = true; }  
# 502
}  } else { 
# 504
while (!__testeof) 
# 505
{ 
# 508
if ((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) 
# 509
{ 
# 512
if (__sep_pos) 
# 513
{ 
# 514
(__found_grouping += (static_cast< char>(__sep_pos))); 
# 515
__sep_pos = 0; 
# 516
} else 
# 518
{ 
# 519
__testfail = true; 
# 520
break; 
# 521
}  
# 522
} else { 
# 523
if (__c == (__lc->_M_decimal_point)) { 
# 524
break; } else 
# 526
{ 
# 527
const char_type *__q = __traits_type::find(__lit_zero, __len, __c); 
# 529
if (!__q) { 
# 530
break; }  
# 532
__digit = (__q - __lit_zero); 
# 533
if (__digit > 15) { 
# 534
__digit -= 6; }  
# 535
if (__result > __smax) { 
# 536
__testoverflow = true; } else 
# 538
{ 
# 539
__result *= __base; 
# 540
__testoverflow |= (__result > (__max - __digit)); 
# 541
__result += __digit; 
# 542
++__sep_pos; 
# 543
}  
# 544
}  }  
# 546
if ((++__beg) != __end) { 
# 547
__c = (*__beg); } else { 
# 549
__testeof = true; }  
# 550
}  }  
# 554
if (__found_grouping.size()) 
# 555
{ 
# 557
(__found_grouping += (static_cast< char>(__sep_pos))); 
# 559
if (!std::__verify_grouping((__lc->_M_grouping), (__lc->_M_grouping_size), __found_grouping)) { 
# 562
__err = ios_base::failbit; }  
# 563
}  
# 567
if (((!__sep_pos) && (!__found_zero) && (!(__found_grouping.size()))) || __testfail) 
# 569
{ 
# 570
__v = 0; 
# 571
__err = ios_base::failbit; 
# 572
} else { 
# 573
if (__testoverflow) 
# 574
{ 
# 575
if (__negative && __gnu_cxx::__numeric_traits< _ValueT> ::__is_signed) { 
# 577
__v = __gnu_cxx::__numeric_traits< _ValueT> ::__min; } else { 
# 579
__v = __gnu_cxx::__numeric_traits< _ValueT> ::__max; }  
# 580
__err = ios_base::failbit; 
# 581
} else { 
# 583
__v = (__negative ? -__result : __result); }  }  
# 585
if (__testeof) { 
# 586
(__err |= ios_base::eofbit); }  
# 587
return __beg; 
# 588
} 
# 592
template< class _CharT, class _InIter> _InIter 
# 595
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 596
__err, bool &__v) const 
# 597
{ 
# 598
if (!(((__io.flags()) & ios_base::boolalpha))) 
# 599
{ 
# 603
long __l = (-1); 
# 604
__beg = _M_extract_int(__beg, __end, __io, __err, __l); 
# 605
if ((__l == (0)) || (__l == (1))) { 
# 606
__v = ((bool)__l); } else 
# 608
{ 
# 611
__v = true; 
# 612
__err = ios_base::failbit; 
# 613
if (__beg == __end) { 
# 614
(__err |= ios_base::eofbit); }  
# 615
}  
# 616
} else 
# 618
{ 
# 620
typedef __numpunct_cache< _CharT>  __cache_type; 
# 621
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 622
const locale &__loc = __io._M_getloc(); 
# 623
const __cache_type *__lc = __uc(__loc); 
# 625
bool __testf = true; 
# 626
bool __testt = true; 
# 627
bool __donef = (__lc->_M_falsename_size) == 0; 
# 628
bool __donet = (__lc->_M_truename_size) == 0; 
# 629
bool __testeof = false; 
# 630
size_t __n = (0); 
# 631
while ((!__donef) || (!__donet)) 
# 632
{ 
# 633
if (__beg == __end) 
# 634
{ 
# 635
__testeof = true; 
# 636
break; 
# 637
}  
# 639
const char_type __c = *__beg; 
# 641
if (!__donef) { 
# 642
__testf = (__c == ((__lc->_M_falsename)[__n])); }  
# 644
if ((!__testf) && __donet) { 
# 645
break; }  
# 647
if (!__donet) { 
# 648
__testt = (__c == ((__lc->_M_truename)[__n])); }  
# 650
if ((!__testt) && __donef) { 
# 651
break; }  
# 653
if ((!__testt) && (!__testf)) { 
# 654
break; }  
# 656
++__n; 
# 657
++__beg; 
# 659
__donef = ((!__testf) || (__n >= (__lc->_M_falsename_size))); 
# 660
__donet = ((!__testt) || (__n >= (__lc->_M_truename_size))); 
# 661
}  
# 662
if (__testf && (__n == (__lc->_M_falsename_size)) && __n) 
# 663
{ 
# 664
__v = false; 
# 665
if (__testt && (__n == (__lc->_M_truename_size))) { 
# 666
__err = ios_base::failbit; } else { 
# 668
__err = (__testeof ? ios_base::eofbit : ios_base::goodbit); }  
# 669
} else { 
# 670
if (__testt && (__n == (__lc->_M_truename_size)) && __n) 
# 671
{ 
# 672
__v = true; 
# 673
__err = (__testeof ? ios_base::eofbit : ios_base::goodbit); 
# 674
} else 
# 676
{ 
# 679
__v = false; 
# 680
__err = ios_base::failbit; 
# 681
if (__testeof) { 
# 682
(__err |= ios_base::eofbit); }  
# 683
}  }  
# 684
}  
# 685
return __beg; 
# 686
} 
# 688
template< class _CharT, class _InIter> _InIter 
# 691
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 692
__err, float &__v) const 
# 693
{ 
# 694
__cxx11::string __xtrc; 
# 695
__xtrc.reserve(32); 
# 696
__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc); 
# 697
std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale()); 
# 698
if (__beg == __end) { 
# 699
(__err |= ios_base::eofbit); }  
# 700
return __beg; 
# 701
} 
# 703
template< class _CharT, class _InIter> _InIter 
# 706
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 707
__err, double &__v) const 
# 708
{ 
# 709
__cxx11::string __xtrc; 
# 710
__xtrc.reserve(32); 
# 711
__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc); 
# 712
std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale()); 
# 713
if (__beg == __end) { 
# 714
(__err |= ios_base::eofbit); }  
# 715
return __beg; 
# 716
} 
# 735 "/usr/include/c++/5/bits/locale_facets.tcc" 3
template< class _CharT, class _InIter> _InIter 
# 738
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 739
__err, long double &__v) const 
# 740
{ 
# 741
__cxx11::string __xtrc; 
# 742
__xtrc.reserve(32); 
# 743
__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc); 
# 744
std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale()); 
# 745
if (__beg == __end) { 
# 746
(__err |= ios_base::eofbit); }  
# 747
return __beg; 
# 748
} 
# 750
template< class _CharT, class _InIter> _InIter 
# 753
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 754
__err, void *&__v) const 
# 755
{ 
# 757
typedef ios_base::fmtflags fmtflags; 
# 758
const fmtflags __fmt = __io.flags(); 
# 759
__io.flags((((__fmt & ((~ios_base::basefield)))) | ios_base::hex)); 
# 763
typedef __gnu_cxx::__conditional_type< true, unsigned long, unsigned long long> ::__type _UIntPtrType; 
# 765
_UIntPtrType __ul; 
# 766
__beg = _M_extract_int(__beg, __end, __io, __err, __ul); 
# 769
__io.flags(__fmt); 
# 771
__v = (reinterpret_cast< void *>(__ul)); 
# 772
return __beg; 
# 773
} 
# 777
template< class _CharT, class _OutIter> void 
# 780
num_put< _CharT, _OutIter> ::_M_pad(_CharT __fill, streamsize __w, ios_base &__io, _CharT *
# 781
__new, const _CharT *__cs, int &__len) const 
# 782
{ 
# 785
__pad< _CharT, char_traits< _CharT> > ::_S_pad(__io, __fill, __new, __cs, __w, __len); 
# 787
__len = (static_cast< int>(__w)); 
# 788
} 
# 792
template< class _CharT, class _ValueT> int 
# 794
__int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ios_base::fmtflags 
# 795
__flags, bool __dec) 
# 796
{ 
# 797
_CharT *__buf = __bufend; 
# 798
if (__builtin_expect(__dec, true)) 
# 799
{ 
# 801
do 
# 802
{ 
# 803
(*(--__buf)) = (__lit[(__v % 10) + __num_base::_S_odigits]); 
# 804
__v /= 10; 
# 805
} 
# 806
while (__v != 0); 
# 807
} else { 
# 808
if (((__flags & ios_base::basefield)) == ios_base::oct) 
# 809
{ 
# 811
do 
# 812
{ 
# 813
(*(--__buf)) = (__lit[(__v & 7) + __num_base::_S_odigits]); 
# 814
__v >>= 3; 
# 815
} 
# 816
while (__v != 0); 
# 817
} else 
# 819
{ 
# 821
const bool __uppercase = (__flags & ios_base::uppercase); 
# 822
const int __case_offset = __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits; 
# 824
do 
# 825
{ 
# 826
(*(--__buf)) = (__lit[(__v & 15) + __case_offset]); 
# 827
__v >>= 4; 
# 828
} 
# 829
while (__v != 0); 
# 830
}  }  
# 831
return __bufend - __buf; 
# 832
} 
# 836
template< class _CharT, class _OutIter> void 
# 839
num_put< _CharT, _OutIter> ::_M_group_int(const char *__grouping, size_t __grouping_size, _CharT __sep, ios_base &, _CharT *
# 840
__new, _CharT *__cs, int &__len) const 
# 841
{ 
# 842
_CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len); 
# 844
__len = (__p - __new); 
# 845
} 
# 847
template< class _CharT, class _OutIter> 
# 848
template< class _ValueT> _OutIter 
# 851
num_put< _CharT, _OutIter> ::_M_insert_int(_OutIter __s, ios_base &__io, _CharT __fill, _ValueT 
# 852
__v) const 
# 853
{ 
# 854
using __gnu_cxx::__add_unsigned;
# 855
typedef typename __gnu_cxx::__add_unsigned< _ValueT> ::__type __unsigned_type; 
# 856
typedef __numpunct_cache< _CharT>  __cache_type; 
# 857
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 858
const locale &__loc = __io._M_getloc(); 
# 859
const __cache_type *__lc = __uc(__loc); 
# 860
const _CharT *__lit = ((__lc->_M_atoms_out)); 
# 861
const ios_base::fmtflags __flags = __io.flags(); 
# 864
const int __ilen = ((5) * sizeof(_ValueT)); 
# 865
_CharT *__cs = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen)); 
# 870
const ios_base::fmtflags __basefield = (__flags & ios_base::basefield); 
# 871
const bool __dec = (__basefield != ios_base::oct) && (__basefield != ios_base::hex); 
# 873
const __unsigned_type __u = ((__v > 0) || (!__dec)) ? (__unsigned_type)__v : (-((__unsigned_type)__v)); 
# 876
int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec); 
# 877
__cs += (__ilen - __len); 
# 880
if (__lc->_M_use_grouping) 
# 881
{ 
# 884
_CharT *__cs2 = static_cast< _CharT *>(__builtin_alloca((sizeof(_CharT) * (__len + 1)) * (2))); 
# 887
_M_group_int((__lc->_M_grouping), (__lc->_M_grouping_size), (__lc->_M_thousands_sep), __io, __cs2 + 2, __cs, __len); 
# 889
__cs = (__cs2 + 2); 
# 890
}  
# 893
if (__builtin_expect(__dec, true)) 
# 894
{ 
# 896
if (__v >= 0) 
# 897
{ 
# 898
if (((bool)((__flags & ios_base::showpos))) && __gnu_cxx::__numeric_traits< _ValueT> ::__is_signed) { 
# 900
((*(--__cs)) = (__lit[__num_base::_S_oplus])), (++__len); }  
# 901
} else { 
# 903
((*(--__cs)) = (__lit[__num_base::_S_ominus])), (++__len); }  
# 904
} else { 
# 905
if (((bool)((__flags & ios_base::showbase))) && __v) 
# 906
{ 
# 907
if (__basefield == ios_base::oct) { 
# 908
((*(--__cs)) = (__lit[__num_base::_S_odigits])), (++__len); } else 
# 910
{ 
# 912
const bool __uppercase = (__flags & ios_base::uppercase); 
# 913
(*(--__cs)) = (__lit[(__num_base::_S_ox) + __uppercase]); 
# 915
(*(--__cs)) = (__lit[__num_base::_S_odigits]); 
# 916
__len += 2; 
# 917
}  
# 918
}  }  
# 921
const streamsize __w = __io.width(); 
# 922
if (__w > (static_cast< streamsize>(__len))) 
# 923
{ 
# 924
_CharT *__cs3 = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __w)); 
# 926
_M_pad(__fill, __w, __io, __cs3, __cs, __len); 
# 927
__cs = __cs3; 
# 928
}  
# 929
__io.width(0); 
# 933
return std::__write(__s, __cs, __len); 
# 934
} 
# 936
template< class _CharT, class _OutIter> void 
# 939
num_put< _CharT, _OutIter> ::_M_group_float(const char *__grouping, size_t __grouping_size, _CharT 
# 940
__sep, const _CharT *__p, _CharT *__new, _CharT *
# 941
__cs, int &__len) const 
# 942
{ 
# 946
const int __declen = (__p) ? __p - __cs : __len; 
# 947
_CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen); 
# 952
int __newlen = __p2 - __new; 
# 953
if (__p) 
# 954
{ 
# 955
char_traits< _CharT> ::copy(__p2, __p, __len - __declen); 
# 956
__newlen += (__len - __declen); 
# 957
}  
# 958
__len = __newlen; 
# 959
} 
# 971 "/usr/include/c++/5/bits/locale_facets.tcc" 3
template< class _CharT, class _OutIter> 
# 972
template< class _ValueT> _OutIter 
# 975
num_put< _CharT, _OutIter> ::_M_insert_float(_OutIter __s, ios_base &__io, _CharT __fill, char __mod, _ValueT 
# 976
__v) const 
# 977
{ 
# 978
typedef __numpunct_cache< _CharT>  __cache_type; 
# 979
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 980
const locale &__loc = __io._M_getloc(); 
# 981
const __cache_type *__lc = __uc(__loc); 
# 984
const streamsize __prec = (__io.precision() < (0)) ? 6 : __io.precision(); 
# 986
const int __max_digits = (__gnu_cxx::__numeric_traits< _ValueT> ::__digits10); 
# 990
int __len; 
# 992
char __fbuf[16]; 
# 993
__num_base::_S_format_float(__io, __fbuf, __mod); 
# 997
const bool __use_prec = (((__io.flags()) & ios_base::floatfield)) != ios_base::floatfield; 
# 1002
int __cs_size = (__max_digits * 3); 
# 1003
char *__cs = static_cast< char *>(__builtin_alloca(__cs_size)); 
# 1004
if (__use_prec) { 
# 1005
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v); } else { 
# 1008
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v); }  
# 1012
if (__len >= __cs_size) 
# 1013
{ 
# 1014
__cs_size = (__len + 1); 
# 1015
__cs = (static_cast< char *>(__builtin_alloca(__cs_size))); 
# 1016
if (__use_prec) { 
# 1017
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v); } else { 
# 1020
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v); }  
# 1022
}  
# 1044 "/usr/include/c++/5/bits/locale_facets.tcc" 3
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1046
_CharT *__ws = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __len)); 
# 1048
(__ctype.widen(__cs, __cs + __len, __ws)); 
# 1051
_CharT *__wp = (0); 
# 1052
const char *__p = char_traits< char> ::find(__cs, __len, '.'); 
# 1053
if (__p) 
# 1054
{ 
# 1055
__wp = (__ws + (__p - __cs)); 
# 1056
(*__wp) = (__lc->_M_decimal_point); 
# 1057
}  
# 1062
if ((__lc->_M_use_grouping) && ((__wp || (__len < 3)) || (((__cs[1]) <= ('9')) && ((__cs[2]) <= ('9')) && ((__cs[1]) >= ('0')) && ((__cs[2]) >= ('0'))))) 
# 1065
{ 
# 1068
_CharT *__ws2 = static_cast< _CharT *>(__builtin_alloca((sizeof(_CharT) * __len) * (2))); 
# 1071
streamsize __off = (0); 
# 1072
if (((__cs[0]) == ('-')) || ((__cs[0]) == ('+'))) 
# 1073
{ 
# 1074
__off = (1); 
# 1075
(__ws2[0]) = (__ws[0]); 
# 1076
__len -= 1; 
# 1077
}  
# 1079
_M_group_float((__lc->_M_grouping), (__lc->_M_grouping_size), (__lc->_M_thousands_sep), __wp, __ws2 + __off, __ws + __off, __len); 
# 1082
__len += __off; 
# 1084
__ws = __ws2; 
# 1085
}  
# 1088
const streamsize __w = __io.width(); 
# 1089
if (__w > (static_cast< streamsize>(__len))) 
# 1090
{ 
# 1091
_CharT *__ws3 = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __w)); 
# 1093
_M_pad(__fill, __w, __io, __ws3, __ws, __len); 
# 1094
__ws = __ws3; 
# 1095
}  
# 1096
__io.width(0); 
# 1100
return std::__write(__s, __ws, __len); 
# 1101
} 
# 1103
template< class _CharT, class _OutIter> _OutIter 
# 1106
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const 
# 1107
{ 
# 1108
const ios_base::fmtflags __flags = __io.flags(); 
# 1109
if (((__flags & ios_base::boolalpha)) == 0) 
# 1110
{ 
# 1111
const long __l = __v; 
# 1112
__s = _M_insert_int(__s, __io, __fill, __l); 
# 1113
} else 
# 1115
{ 
# 1116
typedef __numpunct_cache< _CharT>  __cache_type; 
# 1117
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 1118
const locale &__loc = __io._M_getloc(); 
# 1119
const __cache_type *__lc = __uc(__loc); 
# 1121
const _CharT *__name = __v ? __lc->_M_truename : (__lc->_M_falsename); 
# 1123
int __len = __v ? __lc->_M_truename_size : (__lc->_M_falsename_size); 
# 1126
const streamsize __w = __io.width(); 
# 1127
if (__w > (static_cast< streamsize>(__len))) 
# 1128
{ 
# 1129
const streamsize __plen = __w - __len; 
# 1130
_CharT *__ps = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __plen)); 
# 1134
char_traits< _CharT> ::assign(__ps, __plen, __fill); 
# 1135
__io.width(0); 
# 1137
if (((__flags & ios_base::adjustfield)) == ios_base::left) 
# 1138
{ 
# 1139
__s = std::__write(__s, __name, __len); 
# 1140
__s = std::__write(__s, __ps, __plen); 
# 1141
} else 
# 1143
{ 
# 1144
__s = std::__write(__s, __ps, __plen); 
# 1145
__s = std::__write(__s, __name, __len); 
# 1146
}  
# 1147
return __s; 
# 1148
}  
# 1149
__io.width(0); 
# 1150
__s = std::__write(__s, __name, __len); 
# 1151
}  
# 1152
return __s; 
# 1153
} 
# 1155
template< class _CharT, class _OutIter> _OutIter 
# 1158
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, double __v) const 
# 1159
{ return _M_insert_float(__s, __io, __fill, ((char)0), __v); } 
# 1169 "/usr/include/c++/5/bits/locale_facets.tcc" 3
template< class _CharT, class _OutIter> _OutIter 
# 1172
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, long double 
# 1173
__v) const 
# 1174
{ return _M_insert_float(__s, __io, __fill, 'L', __v); } 
# 1176
template< class _CharT, class _OutIter> _OutIter 
# 1179
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, const void *
# 1180
__v) const 
# 1181
{ 
# 1182
const ios_base::fmtflags __flags = __io.flags(); 
# 1183
const ios_base::fmtflags __fmt = (~((ios_base::basefield | ios_base::uppercase))); 
# 1185
__io.flags((((__flags & __fmt)) | ((ios_base::hex | ios_base::showbase)))); 
# 1189
typedef __gnu_cxx::__conditional_type< true, unsigned long, unsigned long long> ::__type _UIntPtrType; 
# 1191
__s = _M_insert_int(__s, __io, __fill, reinterpret_cast< _UIntPtrType>(__v)); 
# 1193
__io.flags(__flags); 
# 1194
return __s; 
# 1195
} 
# 1206 "/usr/include/c++/5/bits/locale_facets.tcc" 3
template< class _CharT, class _Traits> void 
# 1208
__pad< _CharT, _Traits> ::_S_pad(ios_base &__io, _CharT __fill, _CharT *
# 1209
__news, const _CharT *__olds, streamsize 
# 1210
__newlen, streamsize __oldlen) 
# 1211
{ 
# 1212
const size_t __plen = static_cast< size_t>(__newlen - __oldlen); 
# 1213
const ios_base::fmtflags __adjust = ((__io.flags()) & ios_base::adjustfield); 
# 1216
if (__adjust == ios_base::left) 
# 1217
{ 
# 1218
_Traits::copy(__news, __olds, __oldlen); 
# 1219
_Traits::assign(__news + __oldlen, __plen, __fill); 
# 1220
return; 
# 1221
}  
# 1223
size_t __mod = (0); 
# 1224
if (__adjust == ios_base::internal) 
# 1225
{ 
# 1229
const locale &__loc = __io._M_getloc(); 
# 1230
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1232
if (((__ctype.widen('-')) == (__olds[0])) || ((__ctype.widen('+')) == (__olds[0]))) 
# 1234
{ 
# 1235
(__news[0]) = (__olds[0]); 
# 1236
__mod = (1); 
# 1237
++__news; 
# 1238
} else { 
# 1239
if (((__ctype.widen('0')) == (__olds[0])) && (__oldlen > (1)) && (((__ctype.widen('x')) == (__olds[1])) || ((__ctype.widen('X')) == (__olds[1])))) 
# 1243
{ 
# 1244
(__news[0]) = (__olds[0]); 
# 1245
(__news[1]) = (__olds[1]); 
# 1246
__mod = (2); 
# 1247
__news += 2; 
# 1248
}  }  
# 1250
}  
# 1251
_Traits::assign(__news, __plen, __fill); 
# 1252
_Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod); 
# 1253
} 
# 1255
template< class _CharT> _CharT *
# 1257
__add_grouping(_CharT *__s, _CharT __sep, const char *
# 1258
__gbeg, size_t __gsize, const _CharT *
# 1259
__first, const _CharT *__last) 
# 1260
{ 
# 1261
size_t __idx = (0); 
# 1262
size_t __ctr = (0); 
# 1264
while (((__last - __first) > (__gbeg[__idx])) && ((static_cast< signed char>(__gbeg[__idx])) > 0) && ((__gbeg[__idx]) != __gnu_cxx::__numeric_traits_integer< char> ::__max)) 
# 1267
{ 
# 1268
__last -= (__gbeg[__idx]); 
# 1269
(__idx < (__gsize - (1))) ? ++__idx : (++__ctr); 
# 1270
}  
# 1272
while (__first != __last) { 
# 1273
(*(__s++)) = (*(__first++)); }  
# 1275
while (__ctr--) 
# 1276
{ 
# 1277
(*(__s++)) = __sep; 
# 1278
for (char __i = __gbeg[__idx]; __i > 0; --__i) { 
# 1279
(*(__s++)) = (*(__first++)); }  
# 1280
}  
# 1282
while (__idx--) 
# 1283
{ 
# 1284
(*(__s++)) = __sep; 
# 1285
for (char __i = __gbeg[__idx]; __i > 0; --__i) { 
# 1286
(*(__s++)) = (*(__first++)); }  
# 1287
}  
# 1289
return __s; 
# 1290
} 
# 1295
extern template class __cxx11::numpunct< char> ;
# 1296
extern template class __cxx11::numpunct_byname< char> ;
# 1297
extern template class num_get< char, istreambuf_iterator< char, char_traits< char> > > ;
# 1298
extern template class num_put< char, ostreambuf_iterator< char, char_traits< char> > > ;
# 1301
extern template const ctype< char>  &use_facet< ctype< char> > (const locale &);
# 1305
extern template const __cxx11::numpunct< char>  &use_facet< __cxx11::numpunct< char> > (const locale &);
# 1309
extern template const num_put< char, ostreambuf_iterator< char, char_traits< char> > >  &use_facet< num_put< char, ostreambuf_iterator< char, char_traits< char> > > > (const locale &);
# 1313
extern template const num_get< char, istreambuf_iterator< char, char_traits< char> > >  &use_facet< num_get< char, istreambuf_iterator< char, char_traits< char> > > > (const locale &);
# 1317
extern template bool has_facet< ctype< char> > (const locale &) throw();
# 1321
extern template bool has_facet< __cxx11::numpunct< char> > (const locale &) throw();
# 1325
extern template bool has_facet< num_put< char, ostreambuf_iterator< char, char_traits< char> > > > (const locale &) throw();
# 1329
extern template bool has_facet< num_get< char, istreambuf_iterator< char, char_traits< char> > > > (const locale &) throw();
# 1334
extern template class __cxx11::numpunct< wchar_t> ;
# 1335
extern template class __cxx11::numpunct_byname< wchar_t> ;
# 1336
extern template class num_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > ;
# 1337
extern template class num_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > ;
# 1340
extern template const ctype< wchar_t>  &use_facet< ctype< wchar_t> > (const locale &);
# 1344
extern template const __cxx11::numpunct< wchar_t>  &use_facet< __cxx11::numpunct< wchar_t> > (const locale &);
# 1348
extern template const num_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > >  &use_facet< num_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &);
# 1352
extern template const num_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > >  &use_facet< num_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &);
# 1356
extern template bool has_facet< ctype< wchar_t> > (const locale &) throw();
# 1360
extern template bool has_facet< __cxx11::numpunct< wchar_t> > (const locale &) throw();
# 1364
extern template bool has_facet< num_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &) throw();
# 1368
extern template bool has_facet< num_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &) throw();
# 1375
}
# 41 "/usr/include/c++/5/bits/basic_ios.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _Facet> inline const _Facet &
# 47
__check_facet(const _Facet *__f) 
# 48
{ 
# 49
if (!__f) { 
# 50
__throw_bad_cast(); }  
# 51
return *__f; 
# 52
} 
# 66 "/usr/include/c++/5/bits/basic_ios.h" 3
template< class _CharT, class _Traits> 
# 67
class basic_ios : public ios_base { 
# 76
public: typedef _CharT char_type; 
# 77
typedef typename _Traits::int_type int_type; 
# 78
typedef typename _Traits::pos_type pos_type; 
# 79
typedef typename _Traits::off_type off_type; 
# 80
typedef _Traits traits_type; 
# 87
typedef ctype< _CharT>  __ctype_type; 
# 89
typedef num_put< _CharT, ostreambuf_iterator< _CharT, _Traits> >  __num_put_type; 
# 91
typedef num_get< _CharT, istreambuf_iterator< _CharT, _Traits> >  __num_get_type; 
# 96
protected: basic_ostream< _CharT, _Traits>  *_M_tie; 
# 97
mutable char_type _M_fill; 
# 98
mutable bool _M_fill_init; 
# 99
basic_streambuf< _CharT, _Traits>  *_M_streambuf; 
# 102
const __ctype_type *_M_ctype; 
# 104
const __num_put_type *_M_num_put; 
# 106
const __num_get_type *_M_num_get; 
# 117 "/usr/include/c++/5/bits/basic_ios.h" 3
public: explicit operator bool() const 
# 118
{ return !this->fail(); } 
# 125
bool operator!() const 
# 126
{ return this->fail(); } 
# 137 "/usr/include/c++/5/bits/basic_ios.h" 3
iostate rdstate() const 
# 138
{ return _M_streambuf_state; } 
# 148 "/usr/include/c++/5/bits/basic_ios.h" 3
void clear(iostate __state = goodbit); 
# 157
void setstate(iostate __state) 
# 158
{ this->clear(((this->rdstate()) | __state)); } 
# 164
void _M_setstate(iostate __state) 
# 165
{ 
# 168
((_M_streambuf_state) |= __state); 
# 169
if (((this->exceptions()) & __state)) { 
# 170
throw; }  
# 171
} 
# 180
bool good() const 
# 181
{ return (this->rdstate()) == 0; } 
# 190
bool eof() const 
# 191
{ return (((this->rdstate()) & eofbit)) != 0; } 
# 201 "/usr/include/c++/5/bits/basic_ios.h" 3
bool fail() const 
# 202
{ return (((this->rdstate()) & ((badbit | failbit)))) != 0; } 
# 211
bool bad() const 
# 212
{ return (((this->rdstate()) & badbit)) != 0; } 
# 222 "/usr/include/c++/5/bits/basic_ios.h" 3
iostate exceptions() const 
# 223
{ return _M_exception; } 
# 257 "/usr/include/c++/5/bits/basic_ios.h" 3
void exceptions(iostate __except) 
# 258
{ 
# 259
(_M_exception) = __except; 
# 260
this->clear(_M_streambuf_state); 
# 261
} 
# 270
explicit basic_ios(basic_streambuf< _CharT, _Traits>  *__sb) : ios_base(), _M_tie((0)), _M_fill(), _M_fill_init(false), _M_streambuf((0)), _M_ctype((0)), _M_num_put((0)), _M_num_get((0)) 
# 273
{ this->init(__sb); } 
# 282
virtual ~basic_ios() { } 
# 295 "/usr/include/c++/5/bits/basic_ios.h" 3
basic_ostream< _CharT, _Traits>  *tie() const 
# 296
{ return _M_tie; } 
# 307 "/usr/include/c++/5/bits/basic_ios.h" 3
basic_ostream< _CharT, _Traits>  *tie(basic_ostream< _CharT, _Traits>  *__tiestr) 
# 308
{ 
# 309
basic_ostream< _CharT, _Traits>  *__old = _M_tie; 
# 310
(_M_tie) = __tiestr; 
# 311
return __old; 
# 312
} 
# 321
basic_streambuf< _CharT, _Traits>  *rdbuf() const 
# 322
{ return _M_streambuf; } 
# 347 "/usr/include/c++/5/bits/basic_ios.h" 3
basic_streambuf< _CharT, _Traits>  *rdbuf(basic_streambuf< _CharT, _Traits>  * __sb); 
# 361 "/usr/include/c++/5/bits/basic_ios.h" 3
basic_ios &copyfmt(const basic_ios & __rhs); 
# 370
char_type fill() const 
# 371
{ 
# 372
if (!(_M_fill_init)) 
# 373
{ 
# 374
(_M_fill) = this->widen(' '); 
# 375
(_M_fill_init) = true; 
# 376
}  
# 377
return _M_fill; 
# 378
} 
# 390 "/usr/include/c++/5/bits/basic_ios.h" 3
char_type fill(char_type __ch) 
# 391
{ 
# 392
char_type __old = (this->fill()); 
# 393
(_M_fill) = __ch; 
# 394
return __old; 
# 395
} 
# 410 "/usr/include/c++/5/bits/basic_ios.h" 3
locale imbue(const locale & __loc); 
# 430 "/usr/include/c++/5/bits/basic_ios.h" 3
char narrow(char_type __c, char __dfault) const 
# 431
{ return (__check_facet(_M_ctype).narrow(__c, __dfault)); } 
# 449 "/usr/include/c++/5/bits/basic_ios.h" 3
char_type widen(char __c) const 
# 450
{ return (__check_facet(_M_ctype).widen(__c)); } 
# 460
protected: basic_ios() : ios_base(), _M_tie((0)), _M_fill(char_type()), _M_fill_init(false), _M_streambuf((0)), _M_ctype((0)), _M_num_put((0)), _M_num_get((0)) 
# 463
{ } 
# 472
void init(basic_streambuf< _CharT, _Traits>  * __sb); 
# 475
basic_ios(const basic_ios &) = delete;
# 476
basic_ios &operator=(const basic_ios &) = delete;
# 479
void move(basic_ios &__rhs) 
# 480
{ 
# 481
this->ios_base::_M_move(__rhs); 
# 482
_M_cache_locale(_M_ios_locale); 
# 483
(this->tie((__rhs.tie(nullptr)))); 
# 484
(_M_fill) = (__rhs._M_fill); 
# 485
(_M_fill_init) = (__rhs._M_fill_init); 
# 486
(_M_streambuf) = nullptr; 
# 487
} 
# 490
void move(basic_ios &&__rhs) 
# 491
{ (this->move(__rhs)); } 
# 494
void swap(basic_ios &__rhs) noexcept 
# 495
{ 
# 496
this->ios_base::_M_swap(__rhs); 
# 497
_M_cache_locale(_M_ios_locale); 
# 498
(__rhs._M_cache_locale((__rhs._M_ios_locale))); 
# 499
std::swap(_M_tie, (__rhs._M_tie)); 
# 500
std::swap(_M_fill, (__rhs._M_fill)); 
# 501
std::swap(_M_fill_init, (__rhs._M_fill_init)); 
# 502
} 
# 505
void set_rdbuf(basic_streambuf< _CharT, _Traits>  *__sb) 
# 506
{ (_M_streambuf) = __sb; } 
# 510
void _M_cache_locale(const locale & __loc); 
# 511
}; 
# 514
}
# 35 "/usr/include/c++/5/bits/basic_ios.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 39
template< class _CharT, class _Traits> void 
# 41
basic_ios< _CharT, _Traits> ::clear(iostate __state) 
# 42
{ 
# 43
if ((this->rdbuf())) { 
# 44
(_M_streambuf_state) = __state; } else { 
# 46
(_M_streambuf_state) = ((__state | badbit)); }  
# 47
if (((this->exceptions()) & (this->rdstate()))) { 
# 48
__throw_ios_failure("basic_ios::clear"); }  
# 49
} 
# 51
template< class _CharT, class _Traits> basic_streambuf< _CharT, _Traits>  *
# 53
basic_ios< _CharT, _Traits> ::rdbuf(basic_streambuf< _CharT, _Traits>  *__sb) 
# 54
{ 
# 55
basic_streambuf< _CharT, _Traits>  *__old = _M_streambuf; 
# 56
(_M_streambuf) = __sb; 
# 57
this->clear(); 
# 58
return __old; 
# 59
} 
# 61
template< class _CharT, class _Traits> basic_ios< _CharT, _Traits>  &
# 63
basic_ios< _CharT, _Traits> ::copyfmt(const basic_ios &__rhs) 
# 64
{ 
# 67
if (this != (&__rhs)) 
# 68
{ 
# 73
_Words *__words = ((__rhs._M_word_size) <= _S_local_word_size) ? _M_local_word : (new _Words [__rhs._M_word_size]); 
# 77
_Callback_list *__cb = ((__rhs._M_callbacks)); 
# 78
if (__cb) { 
# 79
__cb->_M_add_reference(); }  
# 80
this->ios_base::_M_call_callbacks(erase_event); 
# 81
if ((_M_word) != (_M_local_word)) 
# 82
{ 
# 83
delete [] (_M_word); 
# 84
(_M_word) = (0); 
# 85
}  
# 86
this->ios_base::_M_dispose_callbacks(); 
# 89
(_M_callbacks) = __cb; 
# 90
for (int __i = 0; __i < (__rhs._M_word_size); ++__i) { 
# 91
(__words[__i]) = ((__rhs._M_word)[__i]); }  
# 92
(_M_word) = __words; 
# 93
(_M_word_size) = (__rhs._M_word_size); 
# 95
(this->flags((__rhs.flags()))); 
# 96
(this->width((__rhs.width()))); 
# 97
(this->precision((__rhs.precision()))); 
# 98
(this->tie((__rhs.tie()))); 
# 99
(this->fill((__rhs.fill()))); 
# 100
(_M_ios_locale) = (__rhs.getloc()); 
# 101
_M_cache_locale(_M_ios_locale); 
# 103
this->ios_base::_M_call_callbacks(copyfmt_event); 
# 106
(this->exceptions((__rhs.exceptions()))); 
# 107
}  
# 108
return *this; 
# 109
} 
# 112
template< class _CharT, class _Traits> locale 
# 114
basic_ios< _CharT, _Traits> ::imbue(const locale &__loc) 
# 115
{ 
# 116
locale __old(this->getloc()); 
# 117
this->ios_base::imbue(__loc); 
# 118
_M_cache_locale(__loc); 
# 119
if ((this->rdbuf()) != 0) { 
# 120
((this->rdbuf())->pubimbue(__loc)); }  
# 121
return __old; 
# 122
} 
# 124
template< class _CharT, class _Traits> void 
# 126
basic_ios< _CharT, _Traits> ::init(basic_streambuf< _CharT, _Traits>  *__sb) 
# 127
{ 
# 129
this->ios_base::_M_init(); 
# 132
_M_cache_locale(_M_ios_locale); 
# 146 "/usr/include/c++/5/bits/basic_ios.tcc" 3
(_M_fill) = _CharT(); 
# 147
(_M_fill_init) = false; 
# 149
(_M_tie) = 0; 
# 150
(_M_exception) = goodbit; 
# 151
(_M_streambuf) = __sb; 
# 152
(_M_streambuf_state) = ((__sb) ? goodbit : badbit); 
# 153
} 
# 155
template< class _CharT, class _Traits> void 
# 157
basic_ios< _CharT, _Traits> ::_M_cache_locale(const locale &__loc) 
# 158
{ 
# 159
if (__builtin_expect(has_facet< __ctype_type> (__loc), true)) { 
# 160
(_M_ctype) = (&use_facet< __ctype_type> (__loc)); } else { 
# 162
(_M_ctype) = 0; }  
# 164
if (__builtin_expect(has_facet< __num_put_type> (__loc), true)) { 
# 165
(_M_num_put) = (&use_facet< __num_put_type> (__loc)); } else { 
# 167
(_M_num_put) = 0; }  
# 169
if (__builtin_expect(has_facet< __num_get_type> (__loc), true)) { 
# 170
(_M_num_get) = (&use_facet< __num_get_type> (__loc)); } else { 
# 172
(_M_num_get) = 0; }  
# 173
} 
# 178
extern template class basic_ios< char, char_traits< char> > ;
# 181
extern template class basic_ios< wchar_t, char_traits< wchar_t> > ;
# 186
}
# 41 "/usr/include/c++/5/ostream" 3
namespace std __attribute((__visibility__("default"))) { 
# 57 "/usr/include/c++/5/ostream" 3
template< class _CharT, class _Traits> 
# 58
class basic_ostream : virtual public basic_ios< _CharT, _Traits>  { 
# 62
public: typedef _CharT char_type; 
# 63
typedef typename _Traits::int_type int_type; 
# 64
typedef typename _Traits::pos_type pos_type; 
# 65
typedef typename _Traits::off_type off_type; 
# 66
typedef _Traits traits_type; 
# 69
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 70
typedef ::std::basic_ios< _CharT, _Traits>  __ios_type; 
# 71
typedef basic_ostream __ostream_type; 
# 73
typedef num_put< _CharT, ostreambuf_iterator< _CharT, _Traits> >  __num_put_type; 
# 74
typedef ctype< _CharT>  __ctype_type; 
# 84 "/usr/include/c++/5/ostream" 3
explicit basic_ostream(__streambuf_type *__sb) 
# 85
{ (this->init(__sb)); } 
# 93
virtual ~basic_ostream() { } 
# 96
class sentry; 
# 97
friend class sentry; 
# 108 "/usr/include/c++/5/ostream" 3
__ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &)) 
# 109
{ 
# 113
return __pf(*this); 
# 114
} 
# 117
__ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &)) 
# 118
{ 
# 122
__pf(*this); 
# 123
return *this; 
# 124
} 
# 127
__ostream_type &operator<<(::std::ios_base &(*__pf)(::std::ios_base &)) 
# 128
{ 
# 132
__pf(*this); 
# 133
return *this; 
# 134
} 
# 166 "/usr/include/c++/5/ostream" 3
__ostream_type &operator<<(long __n) 
# 167
{ return _M_insert(__n); } 
# 170
__ostream_type &operator<<(unsigned long __n) 
# 171
{ return _M_insert(__n); } 
# 174
__ostream_type &operator<<(bool __n) 
# 175
{ return _M_insert(__n); } 
# 178
__ostream_type &operator<<(short __n); 
# 181
__ostream_type &operator<<(unsigned short __n) 
# 182
{ 
# 185
return _M_insert(static_cast< unsigned long>(__n)); 
# 186
} 
# 189
__ostream_type &operator<<(int __n); 
# 192
__ostream_type &operator<<(unsigned __n) 
# 193
{ 
# 196
return _M_insert(static_cast< unsigned long>(__n)); 
# 197
} 
# 201
__ostream_type &operator<<(long long __n) 
# 202
{ return _M_insert(__n); } 
# 205
__ostream_type &operator<<(unsigned long long __n) 
# 206
{ return _M_insert(__n); } 
# 220 "/usr/include/c++/5/ostream" 3
__ostream_type &operator<<(double __f) 
# 221
{ return _M_insert(__f); } 
# 224
__ostream_type &operator<<(float __f) 
# 225
{ 
# 228
return _M_insert(static_cast< double>(__f)); 
# 229
} 
# 232
__ostream_type &operator<<(long double __f) 
# 233
{ return _M_insert(__f); } 
# 245 "/usr/include/c++/5/ostream" 3
__ostream_type &operator<<(const void *__p) 
# 246
{ return _M_insert(__p); } 
# 270 "/usr/include/c++/5/ostream" 3
__ostream_type &operator<<(__streambuf_type * __sb); 
# 303 "/usr/include/c++/5/ostream" 3
__ostream_type &put(char_type __c); 
# 311
void _M_write(const char_type *__s, ::std::streamsize __n) 
# 312
{ 
# 313
const ::std::streamsize __put = ((this->rdbuf())->sputn(__s, __n)); 
# 314
if (__put != __n) { 
# 315
(this->setstate(ios_base::badbit)); }  
# 316
} 
# 335 "/usr/include/c++/5/ostream" 3
__ostream_type &write(const char_type * __s, ::std::streamsize __n); 
# 348 "/usr/include/c++/5/ostream" 3
__ostream_type &flush(); 
# 358 "/usr/include/c++/5/ostream" 3
pos_type tellp(); 
# 369 "/usr/include/c++/5/ostream" 3
__ostream_type &seekp(pos_type); 
# 381 "/usr/include/c++/5/ostream" 3
__ostream_type &seekp(off_type, ::std::ios_base::seekdir); 
# 384
protected: basic_ostream() 
# 385
{ (this->init(0)); } 
# 389
basic_ostream(basic_iostream< _CharT, _Traits>  &) { } 
# 391
basic_ostream(const basic_ostream &) = delete;
# 393
basic_ostream(basic_ostream &&__rhs) : __ios_type() 
# 395
{ __ios_type::move(__rhs); } 
# 399
basic_ostream &operator=(const basic_ostream &) = delete;
# 402
basic_ostream &operator=(basic_ostream &&__rhs) 
# 403
{ 
# 404
swap(__rhs); 
# 405
return *this; 
# 406
} 
# 409
void swap(basic_ostream &__rhs) 
# 410
{ __ios_type::swap(__rhs); } 
# 413
template< class _ValueT> __ostream_type &_M_insert(_ValueT __v); 
# 416
}; 
# 425 "/usr/include/c++/5/ostream" 3
template< class _CharT, class _Traits> 
# 426
class basic_ostream< _CharT, _Traits> ::sentry { 
# 429
bool _M_ok; 
# 430
basic_ostream &_M_os; 
# 445 "/usr/include/c++/5/ostream" 3
public: explicit sentry(basic_ostream & __os); 
# 454 "/usr/include/c++/5/ostream" 3
~sentry() 
# 455
{ 
# 457
if (((bool)(((_M_os).flags()) & ios_base::unitbuf)) && (!uncaught_exception())) 
# 458
{ 
# 460
if (((_M_os).rdbuf()) && ((((_M_os).rdbuf())->pubsync()) == (-1))) { 
# 461
((_M_os).setstate(ios_base::badbit)); }  
# 462
}  
# 463
} 
# 475 "/usr/include/c++/5/ostream" 3
explicit operator bool() const 
# 476
{ return _M_ok; } 
# 477
}; 
# 495 "/usr/include/c++/5/ostream" 3
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 497
operator<<(basic_ostream< _CharT, _Traits>  &__out, _CharT __c) 
# 498
{ return __ostream_insert(__out, &__c, 1); } 
# 500
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 502
operator<<(basic_ostream< _CharT, _Traits>  &__out, char __c) 
# 503
{ return __out << (__out.widen(__c)); } 
# 506
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 508
operator<<(basic_ostream< char, _Traits>  &__out, char __c) 
# 509
{ return __ostream_insert(__out, &__c, 1); } 
# 512
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 514
operator<<(basic_ostream< char, _Traits>  &__out, signed char __c) 
# 515
{ return __out << (static_cast< char>(__c)); } 
# 517
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 519
operator<<(basic_ostream< char, _Traits>  &__out, unsigned char __c) 
# 520
{ return __out << (static_cast< char>(__c)); } 
# 537 "/usr/include/c++/5/ostream" 3
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 539
operator<<(basic_ostream< _CharT, _Traits>  &__out, const _CharT *__s) 
# 540
{ 
# 541
if (!__s) { 
# 542
(__out.setstate(ios_base::badbit)); } else { 
# 544
__ostream_insert(__out, __s, static_cast< streamsize>(_Traits::length(__s))); }  
# 546
return __out; 
# 547
} 
# 549
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __out, const char * __s); 
# 554
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 556
operator<<(basic_ostream< char, _Traits>  &__out, const char *__s) 
# 557
{ 
# 558
if (!__s) { 
# 559
(__out.setstate(ios_base::badbit)); } else { 
# 561
__ostream_insert(__out, __s, static_cast< streamsize>(_Traits::length(__s))); }  
# 563
return __out; 
# 564
} 
# 567
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 569
operator<<(basic_ostream< char, _Traits>  &__out, const signed char *__s) 
# 570
{ return __out << (reinterpret_cast< const char *>(__s)); } 
# 572
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 574
operator<<(basic_ostream< char, _Traits>  &__out, const unsigned char *__s) 
# 575
{ return __out << (reinterpret_cast< const char *>(__s)); } 
# 588 "/usr/include/c++/5/ostream" 3
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 590
endl(basic_ostream< _CharT, _Traits>  &__os) 
# 591
{ return flush((__os.put((__os.widen('\n'))))); } 
# 600 "/usr/include/c++/5/ostream" 3
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 602
ends(basic_ostream< _CharT, _Traits>  &__os) 
# 603
{ return (__os.put(_CharT())); } 
# 610
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 612
flush(basic_ostream< _CharT, _Traits>  &__os) 
# 613
{ return (__os.flush()); } 
# 626 "/usr/include/c++/5/ostream" 3
template< class _CharT, class _Traits, class _Tp> inline basic_ostream< _CharT, _Traits>  &
# 628
operator<<(basic_ostream< _CharT, _Traits>  &&__os, const _Tp &__x) 
# 629
{ 
# 630
__os << __x; 
# 631
return __os; 
# 632
} 
# 636
}
# 41 "/usr/include/c++/5/bits/ostream.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _CharT, class _Traits> 
# 47
basic_ostream< _CharT, _Traits> ::sentry::sentry(basic_ostream &__os) : _M_ok(false), _M_os(__os) 
# 49
{ 
# 51
if ((__os.tie()) && (__os.good())) { 
# 52
((__os.tie())->flush()); }  
# 54
if ((__os.good())) { 
# 55
(_M_ok) = true; } else { 
# 57
(__os.setstate(ios_base::failbit)); }  
# 58
} 
# 60
template< class _CharT, class _Traits> 
# 61
template< class _ValueT> basic_ostream< _CharT, _Traits>  &
# 64
basic_ostream< _CharT, _Traits> ::_M_insert(_ValueT __v) 
# 65
{ 
# 66
sentry __cerb(*this); 
# 67
if (__cerb) 
# 68
{ 
# 69
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 70
try 
# 71
{ 
# 72
const __num_put_type &__np = __check_facet((this->_M_num_put)); 
# 73
if (((__np.put(*this, *this, (this->fill()), __v)).failed())) { 
# 74
(__err |= ::std::ios_base::badbit); }  
# 75
} 
# 76
catch (::__cxxabiv1::__forced_unwind &) 
# 77
{ 
# 78
(this->_M_setstate(ios_base::badbit)); 
# 79
throw; 
# 80
} 
# 81
catch (...) 
# 82
{ (this->_M_setstate(ios_base::badbit)); }  
# 83
if (__err) { 
# 84
(this->setstate(__err)); }  
# 85
}  
# 86
return *this; 
# 87
} 
# 89
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 92
basic_ostream< _CharT, _Traits> ::operator<<(short __n) 
# 93
{ 
# 96
const ::std::ios_base::fmtflags __fmt = (this->flags()) & ios_base::basefield; 
# 97
if ((__fmt == ::std::ios_base::oct) || (__fmt == ::std::ios_base::hex)) { 
# 98
return _M_insert(static_cast< long>(static_cast< unsigned short>(__n))); } else { 
# 100
return _M_insert(static_cast< long>(__n)); }  
# 101
} 
# 103
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 106
basic_ostream< _CharT, _Traits> ::operator<<(int __n) 
# 107
{ 
# 110
const ::std::ios_base::fmtflags __fmt = (this->flags()) & ios_base::basefield; 
# 111
if ((__fmt == ::std::ios_base::oct) || (__fmt == ::std::ios_base::hex)) { 
# 112
return _M_insert(static_cast< long>(static_cast< unsigned>(__n))); } else { 
# 114
return _M_insert(static_cast< long>(__n)); }  
# 115
} 
# 117
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 120
basic_ostream< _CharT, _Traits> ::operator<<(__streambuf_type *__sbin) 
# 121
{ 
# 122
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 123
sentry __cerb(*this); 
# 124
if (__cerb && __sbin) 
# 125
{ 
# 126
try 
# 127
{ 
# 128
if (!__copy_streambufs(__sbin, (this->rdbuf()))) { 
# 129
(__err |= ::std::ios_base::failbit); }  
# 130
} 
# 131
catch (::__cxxabiv1::__forced_unwind &) 
# 132
{ 
# 133
(this->_M_setstate(ios_base::badbit)); 
# 134
throw; 
# 135
} 
# 136
catch (...) 
# 137
{ (this->_M_setstate(ios_base::failbit)); }  
# 138
} else { 
# 139
if (!__sbin) { 
# 140
(__err |= ::std::ios_base::badbit); }  }  
# 141
if (__err) { 
# 142
(this->setstate(__err)); }  
# 143
return *this; 
# 144
} 
# 146
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 149
basic_ostream< _CharT, _Traits> ::put(char_type __c) 
# 150
{ 
# 157
sentry __cerb(*this); 
# 158
if (__cerb) 
# 159
{ 
# 160
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 161
try 
# 162
{ 
# 163
const int_type __put = ((this->rdbuf())->sputc(__c)); 
# 164
if (traits_type::eq_int_type(__put, traits_type::eof())) { 
# 165
(__err |= ::std::ios_base::badbit); }  
# 166
} 
# 167
catch (::__cxxabiv1::__forced_unwind &) 
# 168
{ 
# 169
(this->_M_setstate(ios_base::badbit)); 
# 170
throw; 
# 171
} 
# 172
catch (...) 
# 173
{ (this->_M_setstate(ios_base::badbit)); }  
# 174
if (__err) { 
# 175
(this->setstate(__err)); }  
# 176
}  
# 177
return *this; 
# 178
} 
# 180
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 183
basic_ostream< _CharT, _Traits> ::write(const _CharT *__s, ::std::streamsize __n) 
# 184
{ 
# 192
sentry __cerb(*this); 
# 193
if (__cerb) 
# 194
{ 
# 195
try 
# 196
{ _M_write(__s, __n); } 
# 197
catch (::__cxxabiv1::__forced_unwind &) 
# 198
{ 
# 199
(this->_M_setstate(ios_base::badbit)); 
# 200
throw; 
# 201
} 
# 202
catch (...) 
# 203
{ (this->_M_setstate(ios_base::badbit)); }  
# 204
}  
# 205
return *this; 
# 206
} 
# 208
template< class _CharT, class _Traits> typename basic_ostream< _CharT, _Traits> ::__ostream_type &
# 211
basic_ostream< _CharT, _Traits> ::flush() 
# 212
{ 
# 216
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 217
try 
# 218
{ 
# 219
if ((this->rdbuf()) && (((this->rdbuf())->pubsync()) == (-1))) { 
# 220
(__err |= ::std::ios_base::badbit); }  
# 221
} 
# 222
catch (::__cxxabiv1::__forced_unwind &) 
# 223
{ 
# 224
(this->_M_setstate(ios_base::badbit)); 
# 225
throw; 
# 226
} 
# 227
catch (...) 
# 228
{ (this->_M_setstate(ios_base::badbit)); }  
# 229
if (__err) { 
# 230
(this->setstate(__err)); }  
# 231
return *this; 
# 232
} 
# 234
template< class _CharT, class _Traits> typename basic_ostream< _CharT, _Traits> ::pos_type 
# 237
basic_ostream< _CharT, _Traits> ::tellp() 
# 238
{ 
# 239
pos_type __ret = ((pos_type)(-1)); 
# 240
try 
# 241
{ 
# 242
if (!(this->fail())) { 
# 243
__ret = ((this->rdbuf())->pubseekoff(0, ios_base::cur, ios_base::out)); }  
# 244
} 
# 245
catch (::__cxxabiv1::__forced_unwind &) 
# 246
{ 
# 247
(this->_M_setstate(ios_base::badbit)); 
# 248
throw; 
# 249
} 
# 250
catch (...) 
# 251
{ (this->_M_setstate(ios_base::badbit)); }  
# 252
return __ret; 
# 253
} 
# 255
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 258
basic_ostream< _CharT, _Traits> ::seekp(pos_type __pos) 
# 259
{ 
# 260
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 261
try 
# 262
{ 
# 263
if (!(this->fail())) 
# 264
{ 
# 267
const pos_type __p = ((this->rdbuf())->pubseekpos(__pos, ios_base::out)); 
# 271
if (__p == ((pos_type)((off_type)(-1)))) { 
# 272
(__err |= ::std::ios_base::failbit); }  
# 273
}  
# 274
} 
# 275
catch (::__cxxabiv1::__forced_unwind &) 
# 276
{ 
# 277
(this->_M_setstate(ios_base::badbit)); 
# 278
throw; 
# 279
} 
# 280
catch (...) 
# 281
{ (this->_M_setstate(ios_base::badbit)); }  
# 282
if (__err) { 
# 283
(this->setstate(__err)); }  
# 284
return *this; 
# 285
} 
# 287
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 290
basic_ostream< _CharT, _Traits> ::seekp(off_type __off, ::std::ios_base::seekdir __dir) 
# 291
{ 
# 292
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 293
try 
# 294
{ 
# 295
if (!(this->fail())) 
# 296
{ 
# 299
const pos_type __p = ((this->rdbuf())->pubseekoff(__off, __dir, ios_base::out)); 
# 303
if (__p == ((pos_type)((off_type)(-1)))) { 
# 304
(__err |= ::std::ios_base::failbit); }  
# 305
}  
# 306
} 
# 307
catch (::__cxxabiv1::__forced_unwind &) 
# 308
{ 
# 309
(this->_M_setstate(ios_base::badbit)); 
# 310
throw; 
# 311
} 
# 312
catch (...) 
# 313
{ (this->_M_setstate(ios_base::badbit)); }  
# 314
if (__err) { 
# 315
(this->setstate(__err)); }  
# 316
return *this; 
# 317
} 
# 319
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 321
operator<<(basic_ostream< _CharT, _Traits>  &__out, const char *__s) 
# 322
{ 
# 323
if (!__s) { 
# 324
(__out.setstate(ios_base::badbit)); } else 
# 326
{ 
# 329
const size_t __clen = char_traits< char> ::length(__s); 
# 330
try 
# 331
{ 
# 332
struct __ptr_guard { 
# 334
_CharT *__p; 
# 335
__ptr_guard(_CharT *__ip) : __p(__ip) { } 
# 336
~__ptr_guard() { delete [] (__p); } 
# 337
_CharT *__get() { return __p; } 
# 338
} __pg(new _CharT [__clen]); 
# 340
_CharT *__ws = __pg.__get(); 
# 341
for (size_t __i = (0); __i < __clen; ++__i) { 
# 342
(__ws[__i]) = (__out.widen(__s[__i])); }  
# 343
__ostream_insert(__out, __ws, __clen); 
# 344
} 
# 345
catch (__cxxabiv1::__forced_unwind &) 
# 346
{ 
# 347
(__out._M_setstate(ios_base::badbit)); 
# 348
throw; 
# 349
} 
# 350
catch (...) 
# 351
{ (__out._M_setstate(ios_base::badbit)); }  
# 352
}  
# 353
return __out; 
# 354
} 
# 359
extern template class basic_ostream< char, char_traits< char> > ;
# 360
extern template basic_ostream< char, char_traits< char> >  &endl(basic_ostream< char, char_traits< char> >  & __os);
# 361
extern template basic_ostream< char, char_traits< char> >  &ends(basic_ostream< char, char_traits< char> >  & __os);
# 362
extern template basic_ostream< char, char_traits< char> >  &flush(basic_ostream< char, char_traits< char> >  & __os);
# 363
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, char __c);
# 364
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, unsigned char __c);
# 365
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, signed char __c);
# 366
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, const char * __s);
# 367
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, const unsigned char * __s);
# 368
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, const signed char * __s);
# 370
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(long __v);
# 371
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(unsigned long __v);
# 372
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(bool __v);
# 374
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(long long __v);
# 375
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(unsigned long long __v);
# 377
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(double __v);
# 378
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(long double __v);
# 379
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(const void * __v);
# 382
extern template class basic_ostream< wchar_t, char_traits< wchar_t> > ;
# 383
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &endl(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os);
# 384
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &ends(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os);
# 385
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &flush(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os);
# 386
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __out, wchar_t __c);
# 387
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __out, char __c);
# 388
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __out, const wchar_t * __s);
# 389
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __out, const char * __s);
# 391
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(long __v);
# 392
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(unsigned long __v);
# 393
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(bool __v);
# 395
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(long long __v);
# 396
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(unsigned long long __v);
# 398
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(double __v);
# 399
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(long double __v);
# 400
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(const void * __v);
# 405
}
# 41 "/usr/include/c++/5/istream" 3
namespace std __attribute((__visibility__("default"))) { 
# 57 "/usr/include/c++/5/istream" 3
template< class _CharT, class _Traits> 
# 58
class basic_istream : virtual public basic_ios< _CharT, _Traits>  { 
# 62
public: typedef _CharT char_type; 
# 63
typedef typename _Traits::int_type int_type; 
# 64
typedef typename _Traits::pos_type pos_type; 
# 65
typedef typename _Traits::off_type off_type; 
# 66
typedef _Traits traits_type; 
# 69
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 70
typedef ::std::basic_ios< _CharT, _Traits>  __ios_type; 
# 71
typedef basic_istream __istream_type; 
# 73
typedef num_get< _CharT, istreambuf_iterator< _CharT, _Traits> >  __num_get_type; 
# 74
typedef ctype< _CharT>  __ctype_type; 
# 82
protected: ::std::streamsize _M_gcount; 
# 93
public: explicit basic_istream(__streambuf_type *__sb) : _M_gcount(((::std::streamsize)0)) 
# 95
{ (this->init(__sb)); } 
# 103
virtual ~basic_istream() 
# 104
{ (_M_gcount) = ((::std::streamsize)0); } 
# 107
class sentry; 
# 108
friend class sentry; 
# 120 "/usr/include/c++/5/istream" 3
__istream_type &operator>>(__istream_type &(*__pf)(__istream_type &)) 
# 121
{ return __pf(*this); } 
# 124
__istream_type &operator>>(__ios_type &(*__pf)(__ios_type &)) 
# 125
{ 
# 126
__pf(*this); 
# 127
return *this; 
# 128
} 
# 131
__istream_type &operator>>(::std::ios_base &(*__pf)(::std::ios_base &)) 
# 132
{ 
# 133
__pf(*this); 
# 134
return *this; 
# 135
} 
# 168 "/usr/include/c++/5/istream" 3
__istream_type &operator>>(bool &__n) 
# 169
{ return _M_extract(__n); } 
# 172
__istream_type &operator>>(short & __n); 
# 175
__istream_type &operator>>(unsigned short &__n) 
# 176
{ return _M_extract(__n); } 
# 179
__istream_type &operator>>(int & __n); 
# 182
__istream_type &operator>>(unsigned &__n) 
# 183
{ return _M_extract(__n); } 
# 186
__istream_type &operator>>(long &__n) 
# 187
{ return _M_extract(__n); } 
# 190
__istream_type &operator>>(unsigned long &__n) 
# 191
{ return _M_extract(__n); } 
# 195
__istream_type &operator>>(long long &__n) 
# 196
{ return _M_extract(__n); } 
# 199
__istream_type &operator>>(unsigned long long &__n) 
# 200
{ return _M_extract(__n); } 
# 214 "/usr/include/c++/5/istream" 3
__istream_type &operator>>(float &__f) 
# 215
{ return _M_extract(__f); } 
# 218
__istream_type &operator>>(double &__f) 
# 219
{ return _M_extract(__f); } 
# 222
__istream_type &operator>>(long double &__f) 
# 223
{ return _M_extract(__f); } 
# 235 "/usr/include/c++/5/istream" 3
__istream_type &operator>>(void *&__p) 
# 236
{ return _M_extract(__p); } 
# 259 "/usr/include/c++/5/istream" 3
__istream_type &operator>>(__streambuf_type * __sb); 
# 269 "/usr/include/c++/5/istream" 3
::std::streamsize gcount() const 
# 270
{ return _M_gcount; } 
# 302 "/usr/include/c++/5/istream" 3
int_type get(); 
# 316 "/usr/include/c++/5/istream" 3
__istream_type &get(char_type & __c); 
# 343 "/usr/include/c++/5/istream" 3
__istream_type &get(char_type * __s, ::std::streamsize __n, char_type __delim); 
# 354 "/usr/include/c++/5/istream" 3
__istream_type &get(char_type *__s, ::std::streamsize __n) 
# 355
{ return (this->get(__s, __n, (this->widen('\n')))); } 
# 377 "/usr/include/c++/5/istream" 3
__istream_type &get(__streambuf_type & __sb, char_type __delim); 
# 387 "/usr/include/c++/5/istream" 3
__istream_type &get(__streambuf_type &__sb) 
# 388
{ return (this->get(__sb, (this->widen('\n')))); } 
# 416 "/usr/include/c++/5/istream" 3
__istream_type &getline(char_type * __s, ::std::streamsize __n, char_type __delim); 
# 427 "/usr/include/c++/5/istream" 3
__istream_type &getline(char_type *__s, ::std::streamsize __n) 
# 428
{ return (this->getline(__s, __n, (this->widen('\n')))); } 
# 451 "/usr/include/c++/5/istream" 3
__istream_type &ignore(::std::streamsize __n, int_type __delim); 
# 454
__istream_type &ignore(::std::streamsize __n); 
# 457
__istream_type &ignore(); 
# 468 "/usr/include/c++/5/istream" 3
int_type peek(); 
# 486 "/usr/include/c++/5/istream" 3
__istream_type &read(char_type * __s, ::std::streamsize __n); 
# 505 "/usr/include/c++/5/istream" 3
::std::streamsize readsome(char_type * __s, ::std::streamsize __n); 
# 522 "/usr/include/c++/5/istream" 3
__istream_type &putback(char_type __c); 
# 538 "/usr/include/c++/5/istream" 3
__istream_type &unget(); 
# 556 "/usr/include/c++/5/istream" 3
int sync(); 
# 571 "/usr/include/c++/5/istream" 3
pos_type tellg(); 
# 586 "/usr/include/c++/5/istream" 3
__istream_type &seekg(pos_type); 
# 602 "/usr/include/c++/5/istream" 3
__istream_type &seekg(off_type, ::std::ios_base::seekdir); 
# 606
protected: basic_istream() : _M_gcount(((::std::streamsize)0)) 
# 608
{ (this->init(0)); } 
# 611
basic_istream(const basic_istream &) = delete;
# 613
basic_istream(basic_istream &&__rhs) : __ios_type(), _M_gcount(((__rhs._M_gcount))) 
# 615
{ 
# 616
__ios_type::move(__rhs); 
# 617
(__rhs._M_gcount) = 0; 
# 618
} 
# 622
basic_istream &operator=(const basic_istream &) = delete;
# 625
basic_istream &operator=(basic_istream &&__rhs) 
# 626
{ 
# 627
swap(__rhs); 
# 628
return *this; 
# 629
} 
# 632
void swap(basic_istream &__rhs) 
# 633
{ 
# 634
__ios_type::swap(__rhs); 
# 635
::std::swap(_M_gcount, (__rhs._M_gcount)); 
# 636
} 
# 639
template< class _ValueT> __istream_type &_M_extract(_ValueT & __v); 
# 642
}; 
# 648
template<> basic_istream< char, char_traits< char> >  &basic_istream< char, char_traits< char> > ::getline(char_type * __s, streamsize __n, char_type __delim); 
# 653
template<> basic_istream< char, char_traits< char> >  &basic_istream< char, char_traits< char> > ::ignore(streamsize __n); 
# 658
template<> basic_istream< char, char_traits< char> >  &basic_istream< char, char_traits< char> > ::ignore(streamsize __n, int_type __delim); 
# 664
template<> basic_istream< wchar_t, char_traits< wchar_t> >  &basic_istream< wchar_t, char_traits< wchar_t> > ::getline(char_type * __s, streamsize __n, char_type __delim); 
# 669
template<> basic_istream< wchar_t, char_traits< wchar_t> >  &basic_istream< wchar_t, char_traits< wchar_t> > ::ignore(streamsize __n); 
# 674
template<> basic_istream< wchar_t, char_traits< wchar_t> >  &basic_istream< wchar_t, char_traits< wchar_t> > ::ignore(streamsize __n, int_type __delim); 
# 685 "/usr/include/c++/5/istream" 3
template< class _CharT, class _Traits> 
# 686
class basic_istream< _CharT, _Traits> ::sentry { 
# 689
bool _M_ok; 
# 693
public: typedef _Traits traits_type; 
# 694
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 695
typedef basic_istream __istream_type; 
# 696
typedef typename ::std::basic_istream< _CharT, _Traits> ::__ctype_type __ctype_type; 
# 697
typedef typename _Traits::int_type __int_type; 
# 722 "/usr/include/c++/5/istream" 3
explicit sentry(basic_istream & __is, bool __noskipws = false); 
# 734 "/usr/include/c++/5/istream" 3
explicit operator bool() const 
# 735
{ return _M_ok; } 
# 736
}; 
# 750 "/usr/include/c++/5/istream" 3
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __in, _CharT & __c); 
# 754
template< class _Traits> inline basic_istream< char, _Traits>  &
# 756
operator>>(basic_istream< char, _Traits>  &__in, unsigned char &__c) 
# 757
{ return __in >> (reinterpret_cast< char &>(__c)); } 
# 759
template< class _Traits> inline basic_istream< char, _Traits>  &
# 761
operator>>(basic_istream< char, _Traits>  &__in, signed char &__c) 
# 762
{ return __in >> (reinterpret_cast< char &>(__c)); } 
# 792 "/usr/include/c++/5/istream" 3
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __in, _CharT * __s); 
# 799
template<> basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, char * __s); 
# 801
template< class _Traits> inline basic_istream< char, _Traits>  &
# 803
operator>>(basic_istream< char, _Traits>  &__in, unsigned char *__s) 
# 804
{ return __in >> (reinterpret_cast< char *>(__s)); } 
# 806
template< class _Traits> inline basic_istream< char, _Traits>  &
# 808
operator>>(basic_istream< char, _Traits>  &__in, signed char *__s) 
# 809
{ return __in >> (reinterpret_cast< char *>(__s)); } 
# 823 "/usr/include/c++/5/istream" 3
template< class _CharT, class _Traits> 
# 824
class basic_iostream : public basic_istream< _CharT, _Traits> , public basic_ostream< _CharT, _Traits>  { 
# 832
public: typedef _CharT char_type; 
# 833
typedef typename _Traits::int_type int_type; 
# 834
typedef typename _Traits::pos_type pos_type; 
# 835
typedef typename _Traits::off_type off_type; 
# 836
typedef _Traits traits_type; 
# 839
typedef ::std::basic_istream< _CharT, _Traits>  __istream_type; 
# 840
typedef ::std::basic_ostream< _CharT, _Traits>  __ostream_type; 
# 849
explicit basic_iostream(basic_streambuf< _CharT, _Traits>  *__sb) : __istream_type(__sb), __ostream_type(__sb) 
# 850
{ } 
# 856
virtual ~basic_iostream() { } 
# 859
protected: basic_iostream() : __istream_type(), __ostream_type() 
# 860
{ } 
# 863
basic_iostream(const basic_iostream &) = delete;
# 865
basic_iostream(basic_iostream &&__rhs) : __istream_type(::std::move(__rhs)), __ostream_type(*this) 
# 867
{ } 
# 871
basic_iostream &operator=(const basic_iostream &) = delete;
# 874
basic_iostream &operator=(basic_iostream &&__rhs) 
# 875
{ 
# 876
swap(__rhs); 
# 877
return *this; 
# 878
} 
# 881
void swap(basic_iostream &__rhs) 
# 882
{ __istream_type::swap(__rhs); } 
# 884
}; 
# 906 "/usr/include/c++/5/istream" 3
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &ws(basic_istream< _CharT, _Traits>  & __is); 
# 922 "/usr/include/c++/5/istream" 3
template< class _CharT, class _Traits, class _Tp> inline basic_istream< _CharT, _Traits>  &
# 924
operator>>(basic_istream< _CharT, _Traits>  &&__is, _Tp &__x) 
# 925
{ 
# 926
__is >> __x; 
# 927
return __is; 
# 928
} 
# 932
}
# 41 "/usr/include/c++/5/bits/istream.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _CharT, class _Traits> 
# 47
basic_istream< _CharT, _Traits> ::sentry::sentry(basic_istream &__in, bool __noskip) : _M_ok(false) 
# 48
{ 
# 49
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 50
if ((__in.good())) 
# 51
{ 
# 52
if ((__in.tie())) { 
# 53
((__in.tie())->flush()); }  
# 54
if ((!__noskip) && ((bool)((__in.flags()) & ios_base::skipws))) 
# 55
{ 
# 56
const __int_type __eof = traits_type::eof(); 
# 57
__streambuf_type *__sb = (__in.rdbuf()); 
# 58
__int_type __c = (__sb->sgetc()); 
# 60
const __ctype_type &__ct = __check_facet((__in._M_ctype)); 
# 61
while ((!traits_type::eq_int_type(__c, __eof)) && (__ct.is(ctype_base::space, traits_type::to_char_type(__c)))) { 
# 64
__c = (__sb->snextc()); }  
# 69
if (traits_type::eq_int_type(__c, __eof)) { 
# 70
(__err |= ::std::ios_base::eofbit); }  
# 71
}  
# 72
}  
# 74
if ((__in.good()) && (__err == ::std::ios_base::goodbit)) { 
# 75
(_M_ok) = true; } else 
# 77
{ 
# 78
(__err |= ::std::ios_base::failbit); 
# 79
(__in.setstate(__err)); 
# 80
}  
# 81
} 
# 83
template< class _CharT, class _Traits> 
# 84
template< class _ValueT> basic_istream< _CharT, _Traits>  &
# 87
basic_istream< _CharT, _Traits> ::_M_extract(_ValueT &__v) 
# 88
{ 
# 89
sentry __cerb(*this, false); 
# 90
if (__cerb) 
# 91
{ 
# 92
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 93
try 
# 94
{ 
# 95
const __num_get_type &__ng = __check_facet((this->_M_num_get)); 
# 96
(__ng.get(*this, 0, *this, __err, __v)); 
# 97
} 
# 98
catch (::__cxxabiv1::__forced_unwind &) 
# 99
{ 
# 100
(this->_M_setstate(ios_base::badbit)); 
# 101
throw; 
# 102
} 
# 103
catch (...) 
# 104
{ (this->_M_setstate(ios_base::badbit)); }  
# 105
if (__err) { 
# 106
(this->setstate(__err)); }  
# 107
}  
# 108
return *this; 
# 109
} 
# 111
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 114
basic_istream< _CharT, _Traits> ::operator>>(short &__n) 
# 115
{ 
# 118
sentry __cerb(*this, false); 
# 119
if (__cerb) 
# 120
{ 
# 121
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 122
try 
# 123
{ 
# 124
long __l; 
# 125
const __num_get_type &__ng = __check_facet((this->_M_num_get)); 
# 126
(__ng.get(*this, 0, *this, __err, __l)); 
# 130
if (__l < ::__gnu_cxx::__numeric_traits_integer< short> ::__min) 
# 131
{ 
# 132
(__err |= ::std::ios_base::failbit); 
# 133
__n = ::__gnu_cxx::__numeric_traits_integer< short> ::__min; 
# 134
} else { 
# 135
if (__l > ::__gnu_cxx::__numeric_traits_integer< short> ::__max) 
# 136
{ 
# 137
(__err |= ::std::ios_base::failbit); 
# 138
__n = ::__gnu_cxx::__numeric_traits_integer< short> ::__max; 
# 139
} else { 
# 141
__n = ((short)__l); }  }  
# 142
} 
# 143
catch (::__cxxabiv1::__forced_unwind &) 
# 144
{ 
# 145
(this->_M_setstate(ios_base::badbit)); 
# 146
throw; 
# 147
} 
# 148
catch (...) 
# 149
{ (this->_M_setstate(ios_base::badbit)); }  
# 150
if (__err) { 
# 151
(this->setstate(__err)); }  
# 152
}  
# 153
return *this; 
# 154
} 
# 156
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 159
basic_istream< _CharT, _Traits> ::operator>>(int &__n) 
# 160
{ 
# 163
sentry __cerb(*this, false); 
# 164
if (__cerb) 
# 165
{ 
# 166
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 167
try 
# 168
{ 
# 169
long __l; 
# 170
const __num_get_type &__ng = __check_facet((this->_M_num_get)); 
# 171
(__ng.get(*this, 0, *this, __err, __l)); 
# 175
if (__l < ::__gnu_cxx::__numeric_traits_integer< int> ::__min) 
# 176
{ 
# 177
(__err |= ::std::ios_base::failbit); 
# 178
__n = ::__gnu_cxx::__numeric_traits_integer< int> ::__min; 
# 179
} else { 
# 180
if (__l > ::__gnu_cxx::__numeric_traits_integer< int> ::__max) 
# 181
{ 
# 182
(__err |= ::std::ios_base::failbit); 
# 183
__n = ::__gnu_cxx::__numeric_traits_integer< int> ::__max; 
# 184
} else { 
# 186
__n = ((int)__l); }  }  
# 187
} 
# 188
catch (::__cxxabiv1::__forced_unwind &) 
# 189
{ 
# 190
(this->_M_setstate(ios_base::badbit)); 
# 191
throw; 
# 192
} 
# 193
catch (...) 
# 194
{ (this->_M_setstate(ios_base::badbit)); }  
# 195
if (__err) { 
# 196
(this->setstate(__err)); }  
# 197
}  
# 198
return *this; 
# 199
} 
# 201
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 204
basic_istream< _CharT, _Traits> ::operator>>(__streambuf_type *__sbout) 
# 205
{ 
# 206
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 207
sentry __cerb(*this, false); 
# 208
if (__cerb && __sbout) 
# 209
{ 
# 210
try 
# 211
{ 
# 212
bool __ineof; 
# 213
if (!__copy_streambufs_eof((this->rdbuf()), __sbout, __ineof)) { 
# 214
(__err |= ::std::ios_base::failbit); }  
# 215
if (__ineof) { 
# 216
(__err |= ::std::ios_base::eofbit); }  
# 217
} 
# 218
catch (::__cxxabiv1::__forced_unwind &) 
# 219
{ 
# 220
(this->_M_setstate(ios_base::failbit)); 
# 221
throw; 
# 222
} 
# 223
catch (...) 
# 224
{ (this->_M_setstate(ios_base::failbit)); }  
# 225
} else { 
# 226
if (!__sbout) { 
# 227
(__err |= ::std::ios_base::failbit); }  }  
# 228
if (__err) { 
# 229
(this->setstate(__err)); }  
# 230
return *this; 
# 231
} 
# 233
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::int_type 
# 236
basic_istream< _CharT, _Traits> ::get() 
# 237
{ 
# 238
const int_type __eof = traits_type::eof(); 
# 239
int_type __c = __eof; 
# 240
(_M_gcount) = (0); 
# 241
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 242
sentry __cerb(*this, true); 
# 243
if (__cerb) 
# 244
{ 
# 245
try 
# 246
{ 
# 247
__c = ((this->rdbuf())->sbumpc()); 
# 249
if (!traits_type::eq_int_type(__c, __eof)) { 
# 250
(_M_gcount) = (1); } else { 
# 252
(__err |= ::std::ios_base::eofbit); }  
# 253
} 
# 254
catch (::__cxxabiv1::__forced_unwind &) 
# 255
{ 
# 256
(this->_M_setstate(ios_base::badbit)); 
# 257
throw; 
# 258
} 
# 259
catch (...) 
# 260
{ (this->_M_setstate(ios_base::badbit)); }  
# 261
}  
# 262
if (!(_M_gcount)) { 
# 263
(__err |= ::std::ios_base::failbit); }  
# 264
if (__err) { 
# 265
(this->setstate(__err)); }  
# 266
return __c; 
# 267
} 
# 269
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 272
basic_istream< _CharT, _Traits> ::get(char_type &__c) 
# 273
{ 
# 274
(_M_gcount) = (0); 
# 275
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 276
sentry __cerb(*this, true); 
# 277
if (__cerb) 
# 278
{ 
# 279
try 
# 280
{ 
# 281
const int_type __cb = ((this->rdbuf())->sbumpc()); 
# 283
if (!traits_type::eq_int_type(__cb, traits_type::eof())) 
# 284
{ 
# 285
(_M_gcount) = (1); 
# 286
__c = traits_type::to_char_type(__cb); 
# 287
} else { 
# 289
(__err |= ::std::ios_base::eofbit); }  
# 290
} 
# 291
catch (::__cxxabiv1::__forced_unwind &) 
# 292
{ 
# 293
(this->_M_setstate(ios_base::badbit)); 
# 294
throw; 
# 295
} 
# 296
catch (...) 
# 297
{ (this->_M_setstate(ios_base::badbit)); }  
# 298
}  
# 299
if (!(_M_gcount)) { 
# 300
(__err |= ::std::ios_base::failbit); }  
# 301
if (__err) { 
# 302
(this->setstate(__err)); }  
# 303
return *this; 
# 304
} 
# 306
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 309
basic_istream< _CharT, _Traits> ::get(char_type *__s, ::std::streamsize __n, char_type __delim) 
# 310
{ 
# 311
(_M_gcount) = (0); 
# 312
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 313
sentry __cerb(*this, true); 
# 314
if (__cerb) 
# 315
{ 
# 316
try 
# 317
{ 
# 318
const int_type __idelim = traits_type::to_int_type(__delim); 
# 319
const int_type __eof = traits_type::eof(); 
# 320
__streambuf_type *__sb = (this->rdbuf()); 
# 321
int_type __c = (__sb->sgetc()); 
# 323
while ((((_M_gcount) + (1)) < __n) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __idelim))) 
# 326
{ 
# 327
(*(__s++)) = traits_type::to_char_type(__c); 
# 328
++(_M_gcount); 
# 329
__c = (__sb->snextc()); 
# 330
}  
# 331
if (traits_type::eq_int_type(__c, __eof)) { 
# 332
(__err |= ::std::ios_base::eofbit); }  
# 333
} 
# 334
catch (::__cxxabiv1::__forced_unwind &) 
# 335
{ 
# 336
(this->_M_setstate(ios_base::badbit)); 
# 337
throw; 
# 338
} 
# 339
catch (...) 
# 340
{ (this->_M_setstate(ios_base::badbit)); }  
# 341
}  
# 344
if (__n > (0)) { 
# 345
(*__s) = char_type(); }  
# 346
if (!(_M_gcount)) { 
# 347
(__err |= ::std::ios_base::failbit); }  
# 348
if (__err) { 
# 349
(this->setstate(__err)); }  
# 350
return *this; 
# 351
} 
# 353
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 356
basic_istream< _CharT, _Traits> ::get(__streambuf_type &__sb, char_type __delim) 
# 357
{ 
# 358
(_M_gcount) = (0); 
# 359
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 360
sentry __cerb(*this, true); 
# 361
if (__cerb) 
# 362
{ 
# 363
try 
# 364
{ 
# 365
const int_type __idelim = traits_type::to_int_type(__delim); 
# 366
const int_type __eof = traits_type::eof(); 
# 367
__streambuf_type *__this_sb = (this->rdbuf()); 
# 368
int_type __c = (__this_sb->sgetc()); 
# 369
char_type __c2 = traits_type::to_char_type(__c); 
# 371
while ((!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __idelim)) && (!traits_type::eq_int_type((__sb.sputc(__c2)), __eof))) 
# 374
{ 
# 375
++(_M_gcount); 
# 376
__c = (__this_sb->snextc()); 
# 377
__c2 = traits_type::to_char_type(__c); 
# 378
}  
# 379
if (traits_type::eq_int_type(__c, __eof)) { 
# 380
(__err |= ::std::ios_base::eofbit); }  
# 381
} 
# 382
catch (::__cxxabiv1::__forced_unwind &) 
# 383
{ 
# 384
(this->_M_setstate(ios_base::badbit)); 
# 385
throw; 
# 386
} 
# 387
catch (...) 
# 388
{ (this->_M_setstate(ios_base::badbit)); }  
# 389
}  
# 390
if (!(_M_gcount)) { 
# 391
(__err |= ::std::ios_base::failbit); }  
# 392
if (__err) { 
# 393
(this->setstate(__err)); }  
# 394
return *this; 
# 395
} 
# 397
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 400
basic_istream< _CharT, _Traits> ::getline(char_type *__s, ::std::streamsize __n, char_type __delim) 
# 401
{ 
# 402
(_M_gcount) = (0); 
# 403
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 404
sentry __cerb(*this, true); 
# 405
if (__cerb) 
# 406
{ 
# 407
try 
# 408
{ 
# 409
const int_type __idelim = traits_type::to_int_type(__delim); 
# 410
const int_type __eof = traits_type::eof(); 
# 411
__streambuf_type *__sb = (this->rdbuf()); 
# 412
int_type __c = (__sb->sgetc()); 
# 414
while ((((_M_gcount) + (1)) < __n) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __idelim))) 
# 417
{ 
# 418
(*(__s++)) = traits_type::to_char_type(__c); 
# 419
__c = (__sb->snextc()); 
# 420
++(_M_gcount); 
# 421
}  
# 422
if (traits_type::eq_int_type(__c, __eof)) { 
# 423
(__err |= ::std::ios_base::eofbit); } else 
# 425
{ 
# 426
if (traits_type::eq_int_type(__c, __idelim)) 
# 427
{ 
# 428
(__sb->sbumpc()); 
# 429
++(_M_gcount); 
# 430
} else { 
# 432
(__err |= ::std::ios_base::failbit); }  
# 433
}  
# 434
} 
# 435
catch (::__cxxabiv1::__forced_unwind &) 
# 436
{ 
# 437
(this->_M_setstate(ios_base::badbit)); 
# 438
throw; 
# 439
} 
# 440
catch (...) 
# 441
{ (this->_M_setstate(ios_base::badbit)); }  
# 442
}  
# 445
if (__n > (0)) { 
# 446
(*__s) = char_type(); }  
# 447
if (!(_M_gcount)) { 
# 448
(__err |= ::std::ios_base::failbit); }  
# 449
if (__err) { 
# 450
(this->setstate(__err)); }  
# 451
return *this; 
# 452
} 
# 457
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::__istream_type &
# 460
basic_istream< _CharT, _Traits> ::ignore() 
# 461
{ 
# 462
(_M_gcount) = (0); 
# 463
sentry __cerb(*this, true); 
# 464
if (__cerb) 
# 465
{ 
# 466
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 467
try 
# 468
{ 
# 469
const int_type __eof = traits_type::eof(); 
# 470
__streambuf_type *__sb = (this->rdbuf()); 
# 472
if (traits_type::eq_int_type((__sb->sbumpc()), __eof)) { 
# 473
(__err |= ::std::ios_base::eofbit); } else { 
# 475
(_M_gcount) = (1); }  
# 476
} 
# 477
catch (::__cxxabiv1::__forced_unwind &) 
# 478
{ 
# 479
(this->_M_setstate(ios_base::badbit)); 
# 480
throw; 
# 481
} 
# 482
catch (...) 
# 483
{ (this->_M_setstate(ios_base::badbit)); }  
# 484
if (__err) { 
# 485
(this->setstate(__err)); }  
# 486
}  
# 487
return *this; 
# 488
} 
# 490
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 493
basic_istream< _CharT, _Traits> ::ignore(::std::streamsize __n) 
# 494
{ 
# 495
(_M_gcount) = (0); 
# 496
sentry __cerb(*this, true); 
# 497
if (__cerb && (__n > (0))) 
# 498
{ 
# 499
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 500
try 
# 501
{ 
# 502
const int_type __eof = traits_type::eof(); 
# 503
__streambuf_type *__sb = (this->rdbuf()); 
# 504
int_type __c = (__sb->sgetc()); 
# 513 "/usr/include/c++/5/bits/istream.tcc" 3
bool __large_ignore = false; 
# 514
while (true) 
# 515
{ 
# 516
while (((_M_gcount) < __n) && (!traits_type::eq_int_type(__c, __eof))) 
# 518
{ 
# 519
++(_M_gcount); 
# 520
__c = (__sb->snextc()); 
# 521
}  
# 522
if ((__n == ::__gnu_cxx::__numeric_traits_integer< long> ::__max) && (!traits_type::eq_int_type(__c, __eof))) 
# 524
{ 
# 525
(_M_gcount) = ::__gnu_cxx::__numeric_traits_integer< long> ::__min; 
# 527
__large_ignore = true; 
# 528
} else { 
# 530
break; }  
# 531
}  
# 533
if (__large_ignore) { 
# 534
(_M_gcount) = ::__gnu_cxx::__numeric_traits_integer< long> ::__max; }  
# 536
if (traits_type::eq_int_type(__c, __eof)) { 
# 537
(__err |= ::std::ios_base::eofbit); }  
# 538
} 
# 539
catch (::__cxxabiv1::__forced_unwind &) 
# 540
{ 
# 541
(this->_M_setstate(ios_base::badbit)); 
# 542
throw; 
# 543
} 
# 544
catch (...) 
# 545
{ (this->_M_setstate(ios_base::badbit)); }  
# 546
if (__err) { 
# 547
(this->setstate(__err)); }  
# 548
}  
# 549
return *this; 
# 550
} 
# 552
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 555
basic_istream< _CharT, _Traits> ::ignore(::std::streamsize __n, int_type __delim) 
# 556
{ 
# 557
(_M_gcount) = (0); 
# 558
sentry __cerb(*this, true); 
# 559
if (__cerb && (__n > (0))) 
# 560
{ 
# 561
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 562
try 
# 563
{ 
# 564
const int_type __eof = traits_type::eof(); 
# 565
__streambuf_type *__sb = (this->rdbuf()); 
# 566
int_type __c = (__sb->sgetc()); 
# 569
bool __large_ignore = false; 
# 570
while (true) 
# 571
{ 
# 572
while (((_M_gcount) < __n) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __delim))) 
# 575
{ 
# 576
++(_M_gcount); 
# 577
__c = (__sb->snextc()); 
# 578
}  
# 579
if ((__n == ::__gnu_cxx::__numeric_traits_integer< long> ::__max) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __delim))) 
# 582
{ 
# 583
(_M_gcount) = ::__gnu_cxx::__numeric_traits_integer< long> ::__min; 
# 585
__large_ignore = true; 
# 586
} else { 
# 588
break; }  
# 589
}  
# 591
if (__large_ignore) { 
# 592
(_M_gcount) = ::__gnu_cxx::__numeric_traits_integer< long> ::__max; }  
# 594
if (traits_type::eq_int_type(__c, __eof)) { 
# 595
(__err |= ::std::ios_base::eofbit); } else { 
# 596
if (traits_type::eq_int_type(__c, __delim)) 
# 597
{ 
# 598
if ((_M_gcount) < ::__gnu_cxx::__numeric_traits_integer< long> ::__max) { 
# 600
++(_M_gcount); }  
# 601
(__sb->sbumpc()); 
# 602
}  }  
# 603
} 
# 604
catch (::__cxxabiv1::__forced_unwind &) 
# 605
{ 
# 606
(this->_M_setstate(ios_base::badbit)); 
# 607
throw; 
# 608
} 
# 609
catch (...) 
# 610
{ (this->_M_setstate(ios_base::badbit)); }  
# 611
if (__err) { 
# 612
(this->setstate(__err)); }  
# 613
}  
# 614
return *this; 
# 615
} 
# 617
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::int_type 
# 620
basic_istream< _CharT, _Traits> ::peek() 
# 621
{ 
# 622
int_type __c = traits_type::eof(); 
# 623
(_M_gcount) = (0); 
# 624
sentry __cerb(*this, true); 
# 625
if (__cerb) 
# 626
{ 
# 627
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 628
try 
# 629
{ 
# 630
__c = ((this->rdbuf())->sgetc()); 
# 631
if (traits_type::eq_int_type(__c, traits_type::eof())) { 
# 632
(__err |= ::std::ios_base::eofbit); }  
# 633
} 
# 634
catch (::__cxxabiv1::__forced_unwind &) 
# 635
{ 
# 636
(this->_M_setstate(ios_base::badbit)); 
# 637
throw; 
# 638
} 
# 639
catch (...) 
# 640
{ (this->_M_setstate(ios_base::badbit)); }  
# 641
if (__err) { 
# 642
(this->setstate(__err)); }  
# 643
}  
# 644
return __c; 
# 645
} 
# 647
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 650
basic_istream< _CharT, _Traits> ::read(char_type *__s, ::std::streamsize __n) 
# 651
{ 
# 652
(_M_gcount) = (0); 
# 653
sentry __cerb(*this, true); 
# 654
if (__cerb) 
# 655
{ 
# 656
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 657
try 
# 658
{ 
# 659
(_M_gcount) = ((this->rdbuf())->sgetn(__s, __n)); 
# 660
if ((_M_gcount) != __n) { 
# 661
(__err |= ((::std::ios_base::eofbit | ::std::ios_base::failbit))); }  
# 662
} 
# 663
catch (::__cxxabiv1::__forced_unwind &) 
# 664
{ 
# 665
(this->_M_setstate(ios_base::badbit)); 
# 666
throw; 
# 667
} 
# 668
catch (...) 
# 669
{ (this->_M_setstate(ios_base::badbit)); }  
# 670
if (__err) { 
# 671
(this->setstate(__err)); }  
# 672
}  
# 673
return *this; 
# 674
} 
# 676
template< class _CharT, class _Traits> streamsize 
# 679
basic_istream< _CharT, _Traits> ::readsome(char_type *__s, ::std::streamsize __n) 
# 680
{ 
# 681
(_M_gcount) = (0); 
# 682
sentry __cerb(*this, true); 
# 683
if (__cerb) 
# 684
{ 
# 685
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 686
try 
# 687
{ 
# 689
const ::std::streamsize __num = ((this->rdbuf())->in_avail()); 
# 690
if (__num > (0)) { 
# 691
(_M_gcount) = ((this->rdbuf())->sgetn(__s, std::min(__num, __n))); } else { 
# 692
if (__num == (-1)) { 
# 693
(__err |= ::std::ios_base::eofbit); }  }  
# 694
} 
# 695
catch (::__cxxabiv1::__forced_unwind &) 
# 696
{ 
# 697
(this->_M_setstate(ios_base::badbit)); 
# 698
throw; 
# 699
} 
# 700
catch (...) 
# 701
{ (this->_M_setstate(ios_base::badbit)); }  
# 702
if (__err) { 
# 703
(this->setstate(__err)); }  
# 704
}  
# 705
return _M_gcount; 
# 706
} 
# 708
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 711
basic_istream< _CharT, _Traits> ::putback(char_type __c) 
# 712
{ 
# 715
(_M_gcount) = (0); 
# 717
(this->clear((this->rdstate()) & ((~::std::ios_base::eofbit)))); 
# 718
sentry __cerb(*this, true); 
# 719
if (__cerb) 
# 720
{ 
# 721
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 722
try 
# 723
{ 
# 724
const int_type __eof = traits_type::eof(); 
# 725
__streambuf_type *__sb = (this->rdbuf()); 
# 726
if ((!__sb) || traits_type::eq_int_type((__sb->sputbackc(__c)), __eof)) { 
# 728
(__err |= ::std::ios_base::badbit); }  
# 729
} 
# 730
catch (::__cxxabiv1::__forced_unwind &) 
# 731
{ 
# 732
(this->_M_setstate(ios_base::badbit)); 
# 733
throw; 
# 734
} 
# 735
catch (...) 
# 736
{ (this->_M_setstate(ios_base::badbit)); }  
# 737
if (__err) { 
# 738
(this->setstate(__err)); }  
# 739
}  
# 740
return *this; 
# 741
} 
# 743
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::__istream_type &
# 746
basic_istream< _CharT, _Traits> ::unget() 
# 747
{ 
# 750
(_M_gcount) = (0); 
# 752
(this->clear((this->rdstate()) & ((~::std::ios_base::eofbit)))); 
# 753
sentry __cerb(*this, true); 
# 754
if (__cerb) 
# 755
{ 
# 756
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 757
try 
# 758
{ 
# 759
const int_type __eof = traits_type::eof(); 
# 760
__streambuf_type *__sb = (this->rdbuf()); 
# 761
if ((!__sb) || traits_type::eq_int_type((__sb->sungetc()), __eof)) { 
# 763
(__err |= ::std::ios_base::badbit); }  
# 764
} 
# 765
catch (::__cxxabiv1::__forced_unwind &) 
# 766
{ 
# 767
(this->_M_setstate(ios_base::badbit)); 
# 768
throw; 
# 769
} 
# 770
catch (...) 
# 771
{ (this->_M_setstate(ios_base::badbit)); }  
# 772
if (__err) { 
# 773
(this->setstate(__err)); }  
# 774
}  
# 775
return *this; 
# 776
} 
# 778
template< class _CharT, class _Traits> int 
# 781
basic_istream< _CharT, _Traits> ::sync() 
# 782
{ 
# 785
int __ret = (-1); 
# 786
sentry __cerb(*this, true); 
# 787
if (__cerb) 
# 788
{ 
# 789
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 790
try 
# 791
{ 
# 792
__streambuf_type *__sb = (this->rdbuf()); 
# 793
if (__sb) 
# 794
{ 
# 795
if ((__sb->pubsync()) == (-1)) { 
# 796
(__err |= ::std::ios_base::badbit); } else { 
# 798
__ret = 0; }  
# 799
}  
# 800
} 
# 801
catch (::__cxxabiv1::__forced_unwind &) 
# 802
{ 
# 803
(this->_M_setstate(ios_base::badbit)); 
# 804
throw; 
# 805
} 
# 806
catch (...) 
# 807
{ (this->_M_setstate(ios_base::badbit)); }  
# 808
if (__err) { 
# 809
(this->setstate(__err)); }  
# 810
}  
# 811
return __ret; 
# 812
} 
# 814
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::pos_type 
# 817
basic_istream< _CharT, _Traits> ::tellg() 
# 818
{ 
# 821
pos_type __ret = ((pos_type)(-1)); 
# 822
sentry __cerb(*this, true); 
# 823
if (__cerb) 
# 824
{ 
# 825
try 
# 826
{ 
# 827
if (!(this->fail())) { 
# 828
__ret = ((this->rdbuf())->pubseekoff(0, ios_base::cur, ios_base::in)); }  
# 830
} 
# 831
catch (::__cxxabiv1::__forced_unwind &) 
# 832
{ 
# 833
(this->_M_setstate(ios_base::badbit)); 
# 834
throw; 
# 835
} 
# 836
catch (...) 
# 837
{ (this->_M_setstate(ios_base::badbit)); }  
# 838
}  
# 839
return __ret; 
# 840
} 
# 842
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 845
basic_istream< _CharT, _Traits> ::seekg(pos_type __pos) 
# 846
{ 
# 850
(this->clear((this->rdstate()) & ((~::std::ios_base::eofbit)))); 
# 851
sentry __cerb(*this, true); 
# 852
if (__cerb) 
# 853
{ 
# 854
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 855
try 
# 856
{ 
# 857
if (!(this->fail())) 
# 858
{ 
# 860
const pos_type __p = ((this->rdbuf())->pubseekpos(__pos, ios_base::in)); 
# 864
if (__p == ((pos_type)((off_type)(-1)))) { 
# 865
(__err |= ::std::ios_base::failbit); }  
# 866
}  
# 867
} 
# 868
catch (::__cxxabiv1::__forced_unwind &) 
# 869
{ 
# 870
(this->_M_setstate(ios_base::badbit)); 
# 871
throw; 
# 872
} 
# 873
catch (...) 
# 874
{ (this->_M_setstate(ios_base::badbit)); }  
# 875
if (__err) { 
# 876
(this->setstate(__err)); }  
# 877
}  
# 878
return *this; 
# 879
} 
# 881
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 884
basic_istream< _CharT, _Traits> ::seekg(off_type __off, ::std::ios_base::seekdir __dir) 
# 885
{ 
# 889
(this->clear((this->rdstate()) & ((~::std::ios_base::eofbit)))); 
# 890
sentry __cerb(*this, true); 
# 891
if (__cerb) 
# 892
{ 
# 893
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 894
try 
# 895
{ 
# 896
if (!(this->fail())) 
# 897
{ 
# 899
const pos_type __p = ((this->rdbuf())->pubseekoff(__off, __dir, ios_base::in)); 
# 903
if (__p == ((pos_type)((off_type)(-1)))) { 
# 904
(__err |= ::std::ios_base::failbit); }  
# 905
}  
# 906
} 
# 907
catch (::__cxxabiv1::__forced_unwind &) 
# 908
{ 
# 909
(this->_M_setstate(ios_base::badbit)); 
# 910
throw; 
# 911
} 
# 912
catch (...) 
# 913
{ (this->_M_setstate(ios_base::badbit)); }  
# 914
if (__err) { 
# 915
(this->setstate(__err)); }  
# 916
}  
# 917
return *this; 
# 918
} 
# 921
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 923
operator>>(basic_istream< _CharT, _Traits>  &__in, _CharT &__c) 
# 924
{ 
# 925
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 926
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 928
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, false); 
# 929
if (__cerb) 
# 930
{ 
# 931
ios_base::iostate __err = ios_base::goodbit; 
# 932
try 
# 933
{ 
# 934
const __int_type __cb = ((__in.rdbuf())->sbumpc()); 
# 935
if (!_Traits::eq_int_type(__cb, _Traits::eof())) { 
# 936
__c = _Traits::to_char_type(__cb); } else { 
# 938
(__err |= ((ios_base::eofbit | ios_base::failbit))); }  
# 939
} 
# 940
catch (__cxxabiv1::__forced_unwind &) 
# 941
{ 
# 942
(__in._M_setstate(ios_base::badbit)); 
# 943
throw; 
# 944
} 
# 945
catch (...) 
# 946
{ (__in._M_setstate(ios_base::badbit)); }  
# 947
if (__err) { 
# 948
(__in.setstate(__err)); }  
# 949
}  
# 950
return __in; 
# 951
} 
# 953
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 955
operator>>(basic_istream< _CharT, _Traits>  &__in, _CharT *__s) 
# 956
{ 
# 957
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 958
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 959
typedef typename _Traits::int_type int_type; 
# 960
typedef _CharT char_type; 
# 961
typedef ctype< _CharT>  __ctype_type; 
# 963
streamsize __extracted = (0); 
# 964
ios_base::iostate __err = ios_base::goodbit; 
# 965
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, false); 
# 966
if (__cerb) 
# 967
{ 
# 968
try 
# 969
{ 
# 971
streamsize __num = (__in.width()); 
# 972
if (__num <= (0)) { 
# 973
__num = __gnu_cxx::__numeric_traits_integer< long> ::__max; }  
# 975
const __ctype_type &__ct = use_facet< ctype< _CharT> > ((__in.getloc())); 
# 977
const int_type __eof = _Traits::eof(); 
# 978
__streambuf_type *__sb = (__in.rdbuf()); 
# 979
int_type __c = (__sb->sgetc()); 
# 981
while ((__extracted < (__num - (1))) && (!_Traits::eq_int_type(__c, __eof)) && (!(__ct.is(ctype_base::space, _Traits::to_char_type(__c))))) 
# 985
{ 
# 986
(*(__s++)) = _Traits::to_char_type(__c); 
# 987
++__extracted; 
# 988
__c = (__sb->snextc()); 
# 989
}  
# 990
if (_Traits::eq_int_type(__c, __eof)) { 
# 991
(__err |= ios_base::eofbit); }  
# 995
(*__s) = char_type(); 
# 996
(__in.width(0)); 
# 997
} 
# 998
catch (__cxxabiv1::__forced_unwind &) 
# 999
{ 
# 1000
(__in._M_setstate(ios_base::badbit)); 
# 1001
throw; 
# 1002
} 
# 1003
catch (...) 
# 1004
{ (__in._M_setstate(ios_base::badbit)); }  
# 1005
}  
# 1006
if (!__extracted) { 
# 1007
(__err |= ios_base::failbit); }  
# 1008
if (__err) { 
# 1009
(__in.setstate(__err)); }  
# 1010
return __in; 
# 1011
} 
# 1014
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 1016
ws(basic_istream< _CharT, _Traits>  &__in) 
# 1017
{ 
# 1018
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1019
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 1020
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 1021
typedef ctype< _CharT>  __ctype_type; 
# 1023
const __ctype_type &__ct = use_facet< ctype< _CharT> > ((__in.getloc())); 
# 1024
const __int_type __eof = _Traits::eof(); 
# 1025
__streambuf_type *__sb = (__in.rdbuf()); 
# 1026
__int_type __c = (__sb->sgetc()); 
# 1028
while ((!_Traits::eq_int_type(__c, __eof)) && (__ct.is(ctype_base::space, _Traits::to_char_type(__c)))) { 
# 1030
__c = (__sb->snextc()); }  
# 1032
if (_Traits::eq_int_type(__c, __eof)) { 
# 1033
(__in.setstate(ios_base::eofbit)); }  
# 1034
return __in; 
# 1035
} 
# 1040
extern template class basic_istream< char, char_traits< char> > ;
# 1041
extern template basic_istream< char, char_traits< char> >  &ws(basic_istream< char, char_traits< char> >  & __is);
# 1042
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, char & __c);
# 1043
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  &, char *);
# 1044
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, unsigned char & __c);
# 1045
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, signed char & __c);
# 1046
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, unsigned char * __s);
# 1047
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, signed char * __s);
# 1049
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(unsigned short & __v);
# 1050
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(unsigned & __v);
# 1051
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(long & __v);
# 1052
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(unsigned long & __v);
# 1053
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(bool & __v);
# 1055
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(long long & __v);
# 1056
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(unsigned long long & __v);
# 1058
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(float & __v);
# 1059
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(double & __v);
# 1060
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(long double & __v);
# 1061
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(void *& __v);
# 1063
extern template class basic_iostream< char, char_traits< char> > ;
# 1066
extern template class basic_istream< wchar_t, char_traits< wchar_t> > ;
# 1067
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &ws(basic_istream< wchar_t, char_traits< wchar_t> >  & __is);
# 1068
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __in, wchar_t & __c);
# 1069
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  &, wchar_t *);
# 1071
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(unsigned short & __v);
# 1072
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(unsigned & __v);
# 1073
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(long & __v);
# 1074
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(unsigned long & __v);
# 1075
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(bool & __v);
# 1077
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(long long & __v);
# 1078
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(unsigned long long & __v);
# 1080
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(float & __v);
# 1081
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(double & __v);
# 1082
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(long double & __v);
# 1083
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(void *& __v);
# 1085
extern template class basic_iostream< wchar_t, char_traits< wchar_t> > ;
# 1090
}
# 42 "/usr/include/c++/5/iostream" 3
namespace std __attribute((__visibility__("default"))) { 
# 60 "/usr/include/c++/5/iostream" 3
extern istream cin; 
# 61
extern ostream cout; 
# 62
extern ostream cerr; 
# 63
extern ostream clog; 
# 66
extern wistream wcin; 
# 67
extern wostream wcout; 
# 68
extern wostream wcerr; 
# 69
extern wostream wclog; 
# 74
static ios_base::Init __ioinit; 
# 77
}
# 13 "/usr/local/include/librealsense2/rs.h" 3
extern "C" {
# 13 "/usr/local/include/librealsense2/h/rs_types.h" 3
extern "C" {
# 25
typedef 
# 17
enum rs2_notification_category { 
# 18
RS2_NOTIFICATION_CATEGORY_FRAMES_TIMEOUT, 
# 19
RS2_NOTIFICATION_CATEGORY_FRAME_CORRUPTED, 
# 20
RS2_NOTIFICATION_CATEGORY_HARDWARE_ERROR, 
# 21
RS2_NOTIFICATION_CATEGORY_HARDWARE_EVENT, 
# 22
RS2_NOTIFICATION_CATEGORY_UNKNOWN_ERROR, 
# 23
RS2_NOTIFICATION_CATEGORY_FIRMWARE_UPDATE_RECOMMENDED, 
# 24
RS2_NOTIFICATION_CATEGORY_COUNT
# 25
} rs2_notification_category; 
# 26
const char *rs2_notification_category_to_string(rs2_notification_category category); 
# 40
typedef 
# 29
enum rs2_exception_type { 
# 31
RS2_EXCEPTION_TYPE_UNKNOWN, 
# 32
RS2_EXCEPTION_TYPE_CAMERA_DISCONNECTED, 
# 33
RS2_EXCEPTION_TYPE_BACKEND, 
# 34
RS2_EXCEPTION_TYPE_INVALID_VALUE, 
# 35
RS2_EXCEPTION_TYPE_WRONG_API_CALL_SEQUENCE, 
# 36
RS2_EXCEPTION_TYPE_NOT_IMPLEMENTED, 
# 37
RS2_EXCEPTION_TYPE_DEVICE_IN_RECOVERY_MODE, 
# 38
RS2_EXCEPTION_TYPE_IO, 
# 39
RS2_EXCEPTION_TYPE_COUNT
# 40
} rs2_exception_type; 
# 41
const char *rs2_exception_type_to_string(rs2_exception_type type); 
# 52
typedef 
# 44
enum rs2_distortion { 
# 46
RS2_DISTORTION_NONE, 
# 47
RS2_DISTORTION_MODIFIED_BROWN_CONRADY, 
# 48
RS2_DISTORTION_INVERSE_BROWN_CONRADY, 
# 49
RS2_DISTORTION_FTHETA, 
# 50
RS2_DISTORTION_BROWN_CONRADY, 
# 51
RS2_DISTORTION_COUNT
# 52
} rs2_distortion; 
# 53
const char *rs2_distortion_to_string(rs2_distortion distortion); 
# 66
typedef 
# 56
struct rs2_intrinsics { 
# 58
int width; 
# 59
int height; 
# 60
float ppx; 
# 61
float ppy; 
# 62
float fx; 
# 63
float fy; 
# 64
rs2_distortion model; 
# 65
float coeffs[5]; 
# 66
} rs2_intrinsics; 
# 79
typedef 
# 69
struct rs2_motion_device_intrinsic { 
# 75
float data[3][4]; 
# 77
float noise_variances[3]; 
# 78
float bias_variances[3]; 
# 79
} rs2_motion_device_intrinsic; 
# 90
typedef 
# 82
enum rs2_log_severity { 
# 83
RS2_LOG_SEVERITY_DEBUG, 
# 84
RS2_LOG_SEVERITY_INFO, 
# 85
RS2_LOG_SEVERITY_WARN, 
# 86
RS2_LOG_SEVERITY_ERROR, 
# 87
RS2_LOG_SEVERITY_FATAL, 
# 88
RS2_LOG_SEVERITY_NONE, 
# 89
RS2_LOG_SEVERITY_COUNT
# 90
} rs2_log_severity; 
# 91
const char *rs2_log_severity_to_string(rs2_log_severity info); 
# 122
typedef 
# 94
enum rs2_extension { 
# 96
RS2_EXTENSION_UNKNOWN, 
# 97
RS2_EXTENSION_DEBUG, 
# 98
RS2_EXTENSION_INFO, 
# 99
RS2_EXTENSION_MOTION, 
# 100
RS2_EXTENSION_OPTIONS, 
# 101
RS2_EXTENSION_VIDEO, 
# 102
RS2_EXTENSION_ROI, 
# 103
RS2_EXTENSION_DEPTH_SENSOR, 
# 104
RS2_EXTENSION_VIDEO_FRAME, 
# 105
RS2_EXTENSION_MOTION_FRAME, 
# 106
RS2_EXTENSION_COMPOSITE_FRAME, 
# 107
RS2_EXTENSION_POINTS, 
# 108
RS2_EXTENSION_DEPTH_FRAME, 
# 109
RS2_EXTENSION_ADVANCED_MODE, 
# 110
RS2_EXTENSION_RECORD, 
# 111
RS2_EXTENSION_VIDEO_PROFILE, 
# 112
RS2_EXTENSION_PLAYBACK, 
# 113
RS2_EXTENSION_DEPTH_STEREO_SENSOR, 
# 114
RS2_EXTENSION_DISPARITY_FRAME, 
# 115
RS2_EXTENSION_MOTION_PROFILE, 
# 116
RS2_EXTENSION_POSE_FRAME, 
# 117
RS2_EXTENSION_POSE_PROFILE, 
# 118
RS2_EXTENSION_TM2, 
# 119
RS2_EXTENSION_SOFTWARE_DEVICE, 
# 120
RS2_EXTENSION_SOFTWARE_SENSOR, 
# 121
RS2_EXTENSION_COUNT
# 122
} rs2_extension; 
# 123
const char *rs2_extension_type_to_string(rs2_extension type); 
# 124
const char *rs2_extension_to_string(rs2_extension type); 
# 145
typedef 
# 127
enum rs2_matchers { 
# 129
RS2_MATCHER_DI, 
# 131
RS2_MATCHER_DI_C, 
# 135
RS2_MATCHER_DLR_C, 
# 139
RS2_MATCHER_DLR, 
# 142
RS2_MATCHER_DEFAULT, 
# 144
RS2_MATCHER_COUNT
# 145
} rs2_matchers; 
# 147
typedef struct rs2_device_info rs2_device_info; 
# 148
typedef struct rs2_device rs2_device; 
# 149
typedef struct rs2_error rs2_error; 
# 150
typedef struct rs2_raw_data_buffer rs2_raw_data_buffer; 
# 151
typedef struct rs2_frame rs2_frame; 
# 152
typedef struct rs2_frame_queue rs2_frame_queue; 
# 153
typedef struct rs2_pipeline rs2_pipeline; 
# 154
typedef struct rs2_pipeline_profile rs2_pipeline_profile; 
# 155
typedef struct rs2_config rs2_config; 
# 156
typedef struct rs2_device_list rs2_device_list; 
# 157
typedef struct rs2_stream_profile_list rs2_stream_profile_list; 
# 158
typedef struct rs2_stream_profile rs2_stream_profile; 
# 159
typedef struct rs2_frame_callback rs2_frame_callback; 
# 160
typedef struct rs2_log_callback rs2_log_callback; 
# 161
typedef struct rs2_syncer rs2_syncer; 
# 162
typedef struct rs2_device_serializer rs2_device_serializer; 
# 163
typedef struct rs2_source rs2_source; 
# 164
typedef struct rs2_processing_block rs2_processing_block; 
# 165
typedef struct rs2_frame_processor_callback rs2_frame_processor_callback; 
# 166
typedef struct rs2_playback_status_changed_callback rs2_playback_status_changed_callback; 
# 167
typedef struct rs2_context rs2_context; 
# 168
typedef struct rs2_device_hub rs2_device_hub; 
# 169
typedef struct rs2_sensor_list rs2_sensor_list; 
# 170
typedef struct rs2_sensor rs2_sensor; 
# 171
typedef struct rs2_options rs2_options; 
# 172
typedef struct rs2_devices_changed_callback rs2_devices_changed_callback; 
# 173
typedef struct rs2_notification rs2_notification; 
# 174
typedef struct rs2_notifications_callback rs2_notifications_callback; 
# 175
typedef void (*rs2_notification_callback_ptr)(rs2_notification *, void *); 
# 176
typedef void (*rs2_devices_changed_callback_ptr)(rs2_device_list *, rs2_device_list *, void *); 
# 177
typedef void (*rs2_frame_callback_ptr)(rs2_frame *, void *); 
# 178
typedef void (*rs2_frame_processor_callback_ptr)(rs2_frame *, rs2_source *, void *); 
# 180
typedef double rs2_time_t; 
# 181
typedef long long rs2_metadata_type; 
# 183
rs2_exception_type rs2_get_librealsense_exception_type(const rs2_error * error); 
# 184
const char *rs2_get_failed_function(const rs2_error * error); 
# 185
const char *rs2_get_failed_args(const rs2_error * error); 
# 186
const char *rs2_get_error_message(const rs2_error * error); 
# 187
void rs2_free_error(rs2_error * error); 
# 190
}
# 13 "/usr/local/include/librealsense2/h/rs_context.h" 3
extern "C" {
# 23 "/usr/local/include/librealsense2/h/rs_context.h" 3
rs2_context *rs2_create_context(int api_version, rs2_error ** error); 
# 29
void rs2_delete_context(rs2_context * context); 
# 38 "/usr/local/include/librealsense2/h/rs_context.h" 3
void rs2_set_devices_changed_callback_cpp(rs2_context * context, rs2_devices_changed_callback * callback, rs2_error ** error); 
# 47 "/usr/local/include/librealsense2/h/rs_context.h" 3
void rs2_set_devices_changed_callback(const rs2_context * context, rs2_devices_changed_callback_ptr callback, void * user, rs2_error ** error); 
# 56 "/usr/local/include/librealsense2/h/rs_context.h" 3
rs2_device *rs2_context_add_device(rs2_context * ctx, const char * file, rs2_error ** error); 
# 64
void rs2_context_remove_device(rs2_context * ctx, const char * file, rs2_error ** error); 
# 72
rs2_device_list *rs2_query_devices(const rs2_context * context, rs2_error ** error); 
# 87 "/usr/local/include/librealsense2/h/rs_context.h" 3
rs2_device_list *rs2_query_devices_ex(const rs2_context * context, int product_mask, rs2_error ** error); 
# 95
rs2_device_hub *rs2_create_device_hub(const rs2_context * context, rs2_error ** error); 
# 101
void rs2_delete_device_hub(const rs2_device_hub * hub); 
# 111 "/usr/local/include/librealsense2/h/rs_context.h" 3
rs2_device *rs2_device_hub_wait_for_device(const rs2_device_hub * hub, rs2_error ** error); 
# 120 "/usr/local/include/librealsense2/h/rs_context.h" 3
int rs2_device_hub_is_device_connected(const rs2_device_hub * hub, const rs2_device * device, rs2_error ** error); 
# 124
}
# 13 "/usr/local/include/librealsense2/h/rs_device.h" 3
extern "C" {
# 14 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
extern "C" {
# 34
typedef 
# 22
enum rs2_camera_info { 
# 23
RS2_CAMERA_INFO_NAME, 
# 24
RS2_CAMERA_INFO_SERIAL_NUMBER, 
# 25
RS2_CAMERA_INFO_FIRMWARE_VERSION, 
# 26
RS2_CAMERA_INFO_RECOMMENDED_FIRMWARE_VERSION, 
# 27
RS2_CAMERA_INFO_PHYSICAL_PORT, 
# 28
RS2_CAMERA_INFO_DEBUG_OP_CODE, 
# 29
RS2_CAMERA_INFO_ADVANCED_MODE, 
# 30
RS2_CAMERA_INFO_PRODUCT_ID, 
# 31
RS2_CAMERA_INFO_CAMERA_LOCKED, 
# 32
RS2_CAMERA_INFO_USB_TYPE_DESCRIPTOR, 
# 33
RS2_CAMERA_INFO_COUNT
# 34
} rs2_camera_info; 
# 35
const char *rs2_camera_info_to_string(rs2_camera_info info); 
# 51
typedef 
# 38
enum rs2_stream { 
# 40
RS2_STREAM_ANY, 
# 41
RS2_STREAM_DEPTH, 
# 42
RS2_STREAM_COLOR, 
# 43
RS2_STREAM_INFRARED, 
# 44
RS2_STREAM_FISHEYE, 
# 45
RS2_STREAM_GYRO, 
# 46
RS2_STREAM_ACCEL, 
# 47
RS2_STREAM_GPIO, 
# 48
RS2_STREAM_POSE, 
# 49
RS2_STREAM_CONFIDENCE, 
# 50
RS2_STREAM_COUNT
# 51
} rs2_stream; 
# 52
const char *rs2_stream_to_string(rs2_stream stream); 
# 78
typedef 
# 55
enum rs2_format { 
# 57
RS2_FORMAT_ANY, 
# 58
RS2_FORMAT_Z16, 
# 59
RS2_FORMAT_DISPARITY16, 
# 60
RS2_FORMAT_XYZ32F, 
# 61
RS2_FORMAT_YUYV, 
# 62
RS2_FORMAT_RGB8, 
# 63
RS2_FORMAT_BGR8, 
# 64
RS2_FORMAT_RGBA8, 
# 65
RS2_FORMAT_BGRA8, 
# 66
RS2_FORMAT_Y8, 
# 67
RS2_FORMAT_Y16, 
# 68
RS2_FORMAT_RAW10, 
# 69
RS2_FORMAT_RAW16, 
# 70
RS2_FORMAT_RAW8, 
# 71
RS2_FORMAT_UYVY, 
# 72
RS2_FORMAT_MOTION_RAW, 
# 73
RS2_FORMAT_MOTION_XYZ32F, 
# 74
RS2_FORMAT_GPIO_RAW, 
# 75
RS2_FORMAT_6DOF, 
# 76
RS2_FORMAT_DISPARITY32, 
# 77
RS2_FORMAT_COUNT
# 78
} rs2_format; 
# 79
const char *rs2_format_to_string(rs2_format format); 
# 86
typedef 
# 82
struct rs2_extrinsics { 
# 84
float rotation[9]; 
# 85
float translation[3]; 
# 86
} rs2_extrinsics; 
# 92
void rs2_delete_sensor_list(rs2_sensor_list * info_list); 
# 100
int rs2_get_sensors_count(const rs2_sensor_list * info_list, rs2_error ** error); 
# 106
void rs2_delete_sensor(rs2_sensor * sensor); 
# 114
rs2_sensor *rs2_create_sensor(const rs2_sensor_list * list, int index, rs2_error ** error); 
# 122
rs2_device *rs2_create_device_from_sensor(const rs2_sensor * sensor, rs2_error ** error); 
# 131 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
const char *rs2_get_sensor_info(const rs2_sensor * sensor, rs2_camera_info info, rs2_error ** error); 
# 139
int rs2_supports_sensor_info(const rs2_sensor * sensor, rs2_camera_info info, rs2_error ** error); 
# 148 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
int rs2_is_sensor_extendable_to(const rs2_sensor * sensor, rs2_extension extension, rs2_error ** error); 
# 155
float rs2_get_depth_scale(rs2_sensor * sensor, rs2_error ** error); 
# 162
float rs2_depth_stereo_frame_get_baseline(const rs2_frame * frame_ref, rs2_error ** error); 
# 173 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
void rs2_set_region_of_interest(const rs2_sensor * sensor, int min_x, int min_y, int max_x, int max_y, rs2_error ** error); 
# 184 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
void rs2_get_region_of_interest(const rs2_sensor * sensor, int * min_x, int * min_y, int * max_x, int * max_y, rs2_error ** error); 
# 192
void rs2_open(rs2_sensor * device, const rs2_stream_profile * profile, rs2_error ** error); 
# 202 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
void rs2_open_multiple(rs2_sensor * device, const rs2_stream_profile ** profiles, int count, rs2_error ** error); 
# 209
void rs2_close(const rs2_sensor * sensor, rs2_error ** error); 
# 218 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
void rs2_start(const rs2_sensor * sensor, rs2_frame_callback_ptr on_frame, void * user, rs2_error ** error); 
# 226
void rs2_start_cpp(const rs2_sensor * sensor, rs2_frame_callback * callback, rs2_error ** error); 
# 234
void rs2_start_queue(const rs2_sensor * sensor, rs2_frame_queue * queue, rs2_error ** error); 
# 241
void rs2_stop(const rs2_sensor * sensor, rs2_error ** error); 
# 249
void rs2_set_notifications_callback(const rs2_sensor * sensor, rs2_notification_callback_ptr on_notification, void * user, rs2_error ** error); 
# 257
void rs2_set_notifications_callback_cpp(const rs2_sensor * sensor, rs2_notifications_callback * callback, rs2_error ** error); 
# 265
const char *rs2_get_notification_description(rs2_notification * notification, rs2_error ** error); 
# 273
rs2_time_t rs2_get_notification_timestamp(rs2_notification * notification, rs2_error ** error); 
# 281
rs2_log_severity rs2_get_notification_severity(rs2_notification * notification, rs2_error ** error); 
# 289
rs2_notification_category rs2_get_notification_category(rs2_notification * notification, rs2_error ** error); 
# 297
const char *rs2_get_notification_serialized_data(rs2_notification * notification, rs2_error ** error); 
# 305
rs2_stream_profile_list *rs2_get_stream_profiles(rs2_sensor * device, rs2_error ** error); 
# 313
const rs2_stream_profile *rs2_get_stream_profile(const rs2_stream_profile_list * list, int index, rs2_error ** error); 
# 325 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
void rs2_get_stream_profile_data(const rs2_stream_profile * mode, rs2_stream * stream, rs2_format * format, int * index, int * unique_id, int * framerate, rs2_error ** error); 
# 335 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
void rs2_set_stream_profile_data(rs2_stream_profile * mode, rs2_stream stream, int index, rs2_format format, rs2_error ** error); 
# 346 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
rs2_stream_profile *rs2_clone_stream_profile(const rs2_stream_profile * mode, rs2_stream stream, int index, rs2_format format, rs2_error ** error); 
# 353
void rs2_delete_stream_profile(rs2_stream_profile * mode); 
# 362 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
int rs2_stream_profile_is(const rs2_stream_profile * mode, rs2_extension type, rs2_error ** error); 
# 371 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
void rs2_get_video_stream_resolution(const rs2_stream_profile * mode, int * width, int * height, rs2_error ** error); 
# 379
void rs2_get_motion_intrinsics(const rs2_stream_profile * mode, rs2_motion_device_intrinsic * intrinsics, rs2_error ** error); 
# 388 "/usr/local/include/librealsense2/h/rs_sensor.h" 3
int rs2_is_stream_profile_default(const rs2_stream_profile * mode, rs2_error ** error); 
# 396
int rs2_get_stream_profiles_count(const rs2_stream_profile_list * list, rs2_error ** error); 
# 402
void rs2_delete_stream_profiles_list(rs2_stream_profile_list * list); 
# 410
void rs2_get_extrinsics(const rs2_stream_profile * from, const rs2_stream_profile * to, rs2_extrinsics * extrin, rs2_error ** error); 
# 420
void rs2_register_extrinsics(const rs2_stream_profile * from, const rs2_stream_profile * to, rs2_extrinsics extrin, rs2_error ** error); 
# 430
void rs2_get_video_stream_intrinsics(const rs2_stream_profile * mode, rs2_intrinsics * intrinsics, rs2_error ** error); 
# 434
}
# 25 "/usr/local/include/librealsense2/h/rs_device.h" 3
int rs2_get_device_count(const rs2_device_list * info_list, rs2_error ** error); 
# 31
void rs2_delete_device_list(rs2_device_list * info_list); 
# 40 "/usr/local/include/librealsense2/h/rs_device.h" 3
int rs2_device_list_contains(const rs2_device_list * info_list, const rs2_device * device, rs2_error ** error); 
# 49 "/usr/local/include/librealsense2/h/rs_device.h" 3
rs2_device *rs2_create_device(const rs2_device_list * info_list, int index, rs2_error ** error); 
# 55
void rs2_delete_device(rs2_device * device); 
# 64 "/usr/local/include/librealsense2/h/rs_device.h" 3
const char *rs2_get_device_info(const rs2_device * device, rs2_camera_info info, rs2_error ** error); 
# 73 "/usr/local/include/librealsense2/h/rs_device.h" 3
int rs2_supports_device_info(const rs2_device * device, rs2_camera_info info, rs2_error ** error); 
# 81
void rs2_hardware_reset(const rs2_device * device, rs2_error ** error); 
# 91 "/usr/local/include/librealsense2/h/rs_device.h" 3
const rs2_raw_data_buffer *rs2_send_and_receive_raw_data(rs2_device * device, void * raw_data_to_send, unsigned size_of_raw_data_to_send, rs2_error ** error); 
# 100 "/usr/local/include/librealsense2/h/rs_device.h" 3
int rs2_is_device_extendable_to(const rs2_device * device, rs2_extension extension, rs2_error ** error); 
# 108
rs2_sensor_list *rs2_query_sensors(const rs2_device * device, rs2_error ** error); 
# 116
void rs2_loopback_enable(const rs2_device * device, const char * from_file, rs2_error ** error); 
# 123
void rs2_loopback_disable(const rs2_device * device, rs2_error ** error); 
# 131
int rs2_loopback_is_enabled(const rs2_device * device, rs2_error ** error); 
# 139
void rs2_connect_tm2_controller(const rs2_device * device, const unsigned char * mac_addr, rs2_error ** error); 
# 147
void rs2_disconnect_tm2_controller(const rs2_device * device, int id, rs2_error ** error); 
# 150
}
# 14 "/usr/local/include/librealsense2/h/rs_frame.h" 3
extern "C" {
# 24
typedef 
# 19
enum rs2_timestamp_domain { 
# 21
RS2_TIMESTAMP_DOMAIN_HARDWARE_CLOCK, 
# 22
RS2_TIMESTAMP_DOMAIN_SYSTEM_TIME, 
# 23
RS2_TIMESTAMP_DOMAIN_COUNT
# 24
} rs2_timestamp_domain; 
# 25
const char *rs2_timestamp_domain_to_string(rs2_timestamp_domain info); 
# 61
typedef 
# 28
enum rs2_frame_metadata_value { 
# 30
RS2_FRAME_METADATA_FRAME_COUNTER, 
# 31
RS2_FRAME_METADATA_FRAME_TIMESTAMP, 
# 32
RS2_FRAME_METADATA_SENSOR_TIMESTAMP, 
# 33
RS2_FRAME_METADATA_ACTUAL_EXPOSURE, 
# 34
RS2_FRAME_METADATA_GAIN_LEVEL, 
# 36
RS2_FRAME_METADATA_AUTO_EXPOSURE, 
# 37
RS2_FRAME_METADATA_WHITE_BALANCE, 
# 38
RS2_FRAME_METADATA_TIME_OF_ARRIVAL, 
# 39
RS2_FRAME_METADATA_TEMPERATURE, 
# 40
RS2_FRAME_METADATA_BACKEND_TIMESTAMP, 
# 41
RS2_FRAME_METADATA_ACTUAL_FPS, 
# 42
RS2_FRAME_METADATA_FRAME_LASER_POWER, 
# 43
RS2_FRAME_METADATA_FRAME_LASER_POWER_MODE, 
# 44
RS2_FRAME_METADATA_EXPOSURE_PRIORITY, 
# 45
RS2_FRAME_METADATA_EXPOSURE_ROI_LEFT, 
# 46
RS2_FRAME_METADATA_EXPOSURE_ROI_RIGHT, 
# 47
RS2_FRAME_METADATA_EXPOSURE_ROI_TOP, 
# 48
RS2_FRAME_METADATA_EXPOSURE_ROI_BOTTOM, 
# 49
RS2_FRAME_METADATA_BRIGHTNESS, 
# 50
RS2_FRAME_METADATA_CONTRAST, 
# 51
RS2_FRAME_METADATA_SATURATION, 
# 52
RS2_FRAME_METADATA_SHARPNESS, 
# 53
RS2_FRAME_METADATA_AUTO_WHITE_BALANCE_TEMPERATURE, 
# 54
RS2_FRAME_METADATA_BACKLIGHT_COMPENSATION, 
# 55
RS2_FRAME_METADATA_HUE, 
# 56
RS2_FRAME_METADATA_GAMMA, 
# 57
RS2_FRAME_METADATA_MANUAL_WHITE_BALANCE, 
# 58
RS2_FRAME_METADATA_POWER_LINE_FREQUENCY, 
# 59
RS2_FRAME_METADATA_LOW_LIGHT_COMPENSATION, 
# 60
RS2_FRAME_METADATA_COUNT
# 61
} rs2_frame_metadata_value; 
# 62
const char *rs2_frame_metadata_to_string(rs2_frame_metadata_value metadata); 
# 63
const char *rs2_frame_metadata_value_to_string(rs2_frame_metadata_value metadata); 
# 70
typedef 
# 67
struct rs2_vertex { 
# 69
float xyz[3]; 
# 70
} rs2_vertex; 
# 76
typedef 
# 73
struct rs2_pixel { 
# 75
int ij[2]; 
# 76
} rs2_pixel; 
# 82
typedef 
# 79
struct rs2_vector { 
# 81
float x, y, z; 
# 82
} rs2_vector; 
# 88
typedef 
# 85
struct rs2_quaternion { 
# 87
float x, y, z, w; 
# 88
} rs2_quaternion; 
# 100
typedef 
# 90
struct rs2_pose { 
# 92
rs2_vector translation; 
# 93
rs2_vector velocity; 
# 94
rs2_vector acceleration; 
# 95
rs2_quaternion rotation; 
# 96
rs2_vector angular_velocity; 
# 97
rs2_vector angular_acceleration; 
# 98
unsigned tracker_confidence; 
# 99
unsigned mapper_confidence; 
# 100
} rs2_pose; 
# 110 "/usr/local/include/librealsense2/h/rs_frame.h" 3
rs2_metadata_type rs2_get_frame_metadata(const rs2_frame * frame, rs2_frame_metadata_value frame_metadata, rs2_error ** error); 
# 119 "/usr/local/include/librealsense2/h/rs_frame.h" 3
int rs2_supports_frame_metadata(const rs2_frame * frame, rs2_frame_metadata_value frame_metadata, rs2_error ** error); 
# 129 "/usr/local/include/librealsense2/h/rs_frame.h" 3
rs2_timestamp_domain rs2_get_frame_timestamp_domain(const rs2_frame * frameset, rs2_error ** error); 
# 137
rs2_time_t rs2_get_frame_timestamp(const rs2_frame * frame, rs2_error ** error); 
# 145
unsigned long long rs2_get_frame_number(const rs2_frame * frame, rs2_error ** error); 
# 153
const void *rs2_get_frame_data(const rs2_frame * frame, rs2_error ** error); 
# 161
int rs2_get_frame_width(const rs2_frame * frame, rs2_error ** error); 
# 169
int rs2_get_frame_height(const rs2_frame * frame, rs2_error ** error); 
# 177
int rs2_get_frame_stride_in_bytes(const rs2_frame * frame, rs2_error ** error); 
# 186 "/usr/local/include/librealsense2/h/rs_frame.h" 3
int rs2_get_frame_bits_per_pixel(const rs2_frame * frame, rs2_error ** error); 
# 194
void rs2_frame_add_ref(rs2_frame * frame, rs2_error ** error); 
# 200
void rs2_release_frame(rs2_frame * frame); 
# 208
void rs2_keep_frame(rs2_frame * frame); 
# 217 "/usr/local/include/librealsense2/h/rs_frame.h" 3
rs2_vertex *rs2_get_frame_vertices(const rs2_frame * frame, rs2_error ** error); 
# 226 "/usr/local/include/librealsense2/h/rs_frame.h" 3
void rs2_export_to_ply(const rs2_frame * frame, const char * fname, rs2_frame * texture, rs2_error ** error); 
# 235 "/usr/local/include/librealsense2/h/rs_frame.h" 3
rs2_pixel *rs2_get_frame_texture_coordinates(const rs2_frame * frame, rs2_error ** error); 
# 243
int rs2_get_frame_points_count(const rs2_frame * frame, rs2_error ** error); 
# 251
const rs2_stream_profile *rs2_get_frame_stream_profile(const rs2_frame * frame, rs2_error ** error); 
# 260 "/usr/local/include/librealsense2/h/rs_frame.h" 3
int rs2_is_frame_extendable_to(const rs2_frame * frame, rs2_extension extension_type, rs2_error ** error); 
# 276 "/usr/local/include/librealsense2/h/rs_frame.h" 3
rs2_frame *rs2_allocate_synthetic_video_frame(rs2_source * source, const rs2_stream_profile * new_stream, rs2_frame * original, int new_bpp, int new_width, int new_height, int new_stride, rs2_extension frame_type, rs2_error ** error); 
# 288 "/usr/local/include/librealsense2/h/rs_frame.h" 3
rs2_frame *rs2_allocate_points(rs2_source * source, const rs2_stream_profile * new_stream, rs2_frame * original, rs2_error ** error); 
# 299 "/usr/local/include/librealsense2/h/rs_frame.h" 3
rs2_frame *rs2_allocate_composite_frame(rs2_source * source, rs2_frame ** frames, int count, rs2_error ** error); 
# 310 "/usr/local/include/librealsense2/h/rs_frame.h" 3
rs2_frame *rs2_extract_frame(rs2_frame * composite, int index, rs2_error ** error); 
# 318
int rs2_embedded_frames_count(rs2_frame * composite, rs2_error ** error); 
# 326
void rs2_synthetic_frame_ready(rs2_source * source, rs2_frame * frame, rs2_error ** error); 
# 335 "/usr/local/include/librealsense2/h/rs_frame.h" 3
void rs2_pose_frame_get_pose_data(const rs2_frame * frame, rs2_pose * pose, rs2_error ** error); 
# 338
}
# 14 "/usr/local/include/librealsense2/h/rs_option.h" 3
extern "C" {
# 72
typedef 
# 22
enum rs2_option { 
# 24
RS2_OPTION_BACKLIGHT_COMPENSATION, 
# 25
RS2_OPTION_BRIGHTNESS, 
# 26
RS2_OPTION_CONTRAST, 
# 27
RS2_OPTION_EXPOSURE, 
# 28
RS2_OPTION_GAIN, 
# 29
RS2_OPTION_GAMMA, 
# 30
RS2_OPTION_HUE, 
# 31
RS2_OPTION_SATURATION, 
# 32
RS2_OPTION_SHARPNESS, 
# 33
RS2_OPTION_WHITE_BALANCE, 
# 34
RS2_OPTION_ENABLE_AUTO_EXPOSURE, 
# 35
RS2_OPTION_ENABLE_AUTO_WHITE_BALANCE, 
# 36
RS2_OPTION_VISUAL_PRESET, 
# 37
RS2_OPTION_LASER_POWER, 
# 38
RS2_OPTION_ACCURACY, 
# 39
RS2_OPTION_MOTION_RANGE, 
# 40
RS2_OPTION_FILTER_OPTION, 
# 41
RS2_OPTION_CONFIDENCE_THRESHOLD, 
# 42
RS2_OPTION_EMITTER_ENABLED, 
# 43
RS2_OPTION_FRAMES_QUEUE_SIZE, 
# 44
RS2_OPTION_TOTAL_FRAME_DROPS, 
# 45
RS2_OPTION_AUTO_EXPOSURE_MODE, 
# 46
RS2_OPTION_POWER_LINE_FREQUENCY, 
# 47
RS2_OPTION_ASIC_TEMPERATURE, 
# 48
RS2_OPTION_ERROR_POLLING_ENABLED, 
# 49
RS2_OPTION_PROJECTOR_TEMPERATURE, 
# 50
RS2_OPTION_OUTPUT_TRIGGER_ENABLED, 
# 51
RS2_OPTION_MOTION_MODULE_TEMPERATURE, 
# 52
RS2_OPTION_DEPTH_UNITS, 
# 53
RS2_OPTION_ENABLE_MOTION_CORRECTION, 
# 54
RS2_OPTION_AUTO_EXPOSURE_PRIORITY, 
# 55
RS2_OPTION_COLOR_SCHEME, 
# 56
RS2_OPTION_HISTOGRAM_EQUALIZATION_ENABLED, 
# 57
RS2_OPTION_MIN_DISTANCE, 
# 58
RS2_OPTION_MAX_DISTANCE, 
# 59
RS2_OPTION_TEXTURE_SOURCE, 
# 60
RS2_OPTION_FILTER_MAGNITUDE, 
# 61
RS2_OPTION_FILTER_SMOOTH_ALPHA, 
# 62
RS2_OPTION_FILTER_SMOOTH_DELTA, 
# 63
RS2_OPTION_HOLES_FILL, 
# 64
RS2_OPTION_STEREO_BASELINE, 
# 65
RS2_OPTION_AUTO_EXPOSURE_CONVERGE_STEP, 
# 66
RS2_OPTION_INTER_CAM_SYNC_MODE, 
# 67
RS2_OPTION_STREAM_FILTER, 
# 68
RS2_OPTION_STREAM_FORMAT_FILTER, 
# 69
RS2_OPTION_STREAM_INDEX_FILTER, 
# 70
RS2_OPTION_EMITTER_ON_OFF, 
# 71
RS2_OPTION_COUNT
# 72
} rs2_option; 
# 73
const char *rs2_option_to_string(rs2_option option); 
# 90
typedef 
# 76
enum rs2_sr300_visual_preset { 
# 78
RS2_SR300_VISUAL_PRESET_SHORT_RANGE, 
# 79
RS2_SR300_VISUAL_PRESET_LONG_RANGE, 
# 80
RS2_SR300_VISUAL_PRESET_BACKGROUND_SEGMENTATION, 
# 81
RS2_SR300_VISUAL_PRESET_GESTURE_RECOGNITION, 
# 82
RS2_SR300_VISUAL_PRESET_OBJECT_SCANNING, 
# 83
RS2_SR300_VISUAL_PRESET_FACE_ANALYTICS, 
# 84
RS2_SR300_VISUAL_PRESET_FACE_LOGIN, 
# 85
RS2_SR300_VISUAL_PRESET_GR_CURSOR, 
# 86
RS2_SR300_VISUAL_PRESET_DEFAULT, 
# 87
RS2_SR300_VISUAL_PRESET_MID_RANGE, 
# 88
RS2_SR300_VISUAL_PRESET_IR_ONLY, 
# 89
RS2_SR300_VISUAL_PRESET_COUNT
# 90
} rs2_sr300_visual_preset; 
# 91
const char *rs2_sr300_visual_preset_to_string(rs2_sr300_visual_preset preset); 
# 104
typedef 
# 94
enum rs2_rs400_visual_preset { 
# 96
RS2_RS400_VISUAL_PRESET_CUSTOM, 
# 97
RS2_RS400_VISUAL_PRESET_DEFAULT, 
# 98
RS2_RS400_VISUAL_PRESET_HAND, 
# 99
RS2_RS400_VISUAL_PRESET_HIGH_ACCURACY, 
# 100
RS2_RS400_VISUAL_PRESET_HIGH_DENSITY, 
# 101
RS2_RS400_VISUAL_PRESET_MEDIUM_DENSITY, 
# 102
RS2_RS400_VISUAL_PRESET_REMOVE_IR_PATTERN, 
# 103
RS2_RS400_VISUAL_PRESET_COUNT
# 104
} rs2_rs400_visual_preset; 
# 105
const char *rs2_rs400_visual_preset_to_string(rs2_rs400_visual_preset preset); 
# 114 "/usr/local/include/librealsense2/h/rs_option.h" 3
int rs2_is_option_read_only(const rs2_options * options, rs2_option option, rs2_error ** error); 
# 123 "/usr/local/include/librealsense2/h/rs_option.h" 3
float rs2_get_option(const rs2_options * options, rs2_option option, rs2_error ** error); 
# 132 "/usr/local/include/librealsense2/h/rs_option.h" 3
void rs2_set_option(const rs2_options * options, rs2_option option, float value, rs2_error ** error); 
# 141 "/usr/local/include/librealsense2/h/rs_option.h" 3
int rs2_supports_option(const rs2_options * options, rs2_option option, rs2_error ** error); 
# 153 "/usr/local/include/librealsense2/h/rs_option.h" 3
void rs2_get_option_range(const rs2_options * sensor, rs2_option option, float * min, float * max, float * step, float * def, rs2_error ** error); 
# 162 "/usr/local/include/librealsense2/h/rs_option.h" 3
const char *rs2_get_option_description(const rs2_options * options, rs2_option option, rs2_error ** error); 
# 172 "/usr/local/include/librealsense2/h/rs_option.h" 3
const char *rs2_get_option_value_description(const rs2_options * options, rs2_option option, float value, rs2_error ** error); 
# 175
}
# 14 "/usr/local/include/librealsense2/h/rs_processing.h" 3
extern "C" {
# 28 "/usr/local/include/librealsense2/h/rs_processing.h" 3
rs2_processing_block *rs2_create_colorizer(rs2_error ** error); 
# 36
rs2_processing_block *rs2_create_sync_processing_block(rs2_error ** error); 
# 43
rs2_processing_block *rs2_create_pointcloud(rs2_error ** error); 
# 54 "/usr/local/include/librealsense2/h/rs_processing.h" 3
rs2_processing_block *rs2_create_yuy_decoder(rs2_error ** error); 
# 62
rs2_processing_block *rs2_create_threshold(rs2_error ** error); 
# 71 "/usr/local/include/librealsense2/h/rs_processing.h" 3
rs2_processing_block *rs2_create_processing_block(rs2_frame_processor_callback * proc, rs2_error ** error); 
# 81 "/usr/local/include/librealsense2/h/rs_processing.h" 3
rs2_processing_block *rs2_create_processing_block_fptr(rs2_frame_processor_callback_ptr proc, void * context, rs2_error ** error); 
# 95 "/usr/local/include/librealsense2/h/rs_processing.h" 3
int rs2_processing_block_register_simple_option(rs2_processing_block * block, rs2_option option_id, float min, float max, float step, float def, rs2_error ** error); 
# 103
void rs2_start_processing(rs2_processing_block * block, rs2_frame_callback * on_frame, rs2_error ** error); 
# 112 "/usr/local/include/librealsense2/h/rs_processing.h" 3
void rs2_start_processing_fptr(rs2_processing_block * block, rs2_frame_callback_ptr on_frame, void * user, rs2_error ** error); 
# 120
void rs2_start_processing_queue(rs2_processing_block * block, rs2_frame_queue * queue, rs2_error ** error); 
# 128
void rs2_process_frame(rs2_processing_block * block, rs2_frame * frame, rs2_error ** error); 
# 134
void rs2_delete_processing_block(rs2_processing_block * block); 
# 143 "/usr/local/include/librealsense2/h/rs_processing.h" 3
rs2_frame_queue *rs2_create_frame_queue(int capacity, rs2_error ** error); 
# 149
void rs2_delete_frame_queue(rs2_frame_queue * queue); 
# 158 "/usr/local/include/librealsense2/h/rs_processing.h" 3
rs2_frame *rs2_wait_for_frame(rs2_frame_queue * queue, unsigned timeout_ms, rs2_error ** error); 
# 167 "/usr/local/include/librealsense2/h/rs_processing.h" 3
int rs2_poll_for_frame(rs2_frame_queue * queue, rs2_frame ** output_frame, rs2_error ** error); 
# 177 "/usr/local/include/librealsense2/h/rs_processing.h" 3
int rs2_try_wait_for_frame(rs2_frame_queue * queue, unsigned timeout_ms, rs2_frame ** output_frame, rs2_error ** error); 
# 184
void rs2_enqueue_frame(rs2_frame * frame, void * queue); 
# 190
rs2_processing_block *rs2_create_align(rs2_stream align_to, rs2_error ** error); 
# 197
rs2_processing_block *rs2_create_decimation_filter_block(rs2_error ** error); 
# 203
rs2_processing_block *rs2_create_temporal_filter_block(rs2_error ** error); 
# 209
rs2_processing_block *rs2_create_spatial_filter_block(rs2_error ** error); 
# 216
rs2_processing_block *rs2_create_disparity_transform_block(unsigned char transform_to_disparity, rs2_error ** error); 
# 222
rs2_processing_block *rs2_create_hole_filling_filter_block(rs2_error ** error); 
# 229
rs2_processing_block *rs2_create_rates_printer_block(rs2_error ** error); 
# 232
}
# 14 "/usr/local/include/librealsense2/h/rs_record_playback.h" 3
extern "C" {
# 26
typedef 
# 19
enum rs2_playback_status { 
# 21
RS2_PLAYBACK_STATUS_UNKNOWN, 
# 22
RS2_PLAYBACK_STATUS_PLAYING, 
# 23
RS2_PLAYBACK_STATUS_PAUSED, 
# 24
RS2_PLAYBACK_STATUS_STOPPED, 
# 25
RS2_PLAYBACK_STATUS_COUNT
# 26
} rs2_playback_status; 
# 28
const char *rs2_playback_status_to_string(rs2_playback_status status); 
# 30
typedef void (*rs2_playback_status_changed_callback_ptr)(rs2_playback_status); 
# 39 "/usr/local/include/librealsense2/h/rs_record_playback.h" 3
rs2_device *rs2_create_record_device(const rs2_device * device, const char * file, rs2_error ** error); 
# 49 "/usr/local/include/librealsense2/h/rs_record_playback.h" 3
rs2_device *rs2_create_record_device_ex(const rs2_device * device, const char * file, int compression_enabled, rs2_error ** error); 
# 57
void rs2_record_device_pause(const rs2_device * device, rs2_error ** error); 
# 64
void rs2_record_device_resume(const rs2_device * device, rs2_error ** error); 
# 72
const char *rs2_record_device_filename(const rs2_device * device, rs2_error ** error); 
# 80
rs2_device *rs2_create_playback_device(const char * file, rs2_error ** error); 
# 88
const char *rs2_playback_device_get_file_path(const rs2_device * device, rs2_error ** error); 
# 96
unsigned long long rs2_playback_get_duration(const rs2_device * device, rs2_error ** error); 
# 104
void rs2_playback_seek(const rs2_device * device, long long time, rs2_error ** error); 
# 112
unsigned long long rs2_playback_get_position(const rs2_device * device, rs2_error ** error); 
# 121 "/usr/local/include/librealsense2/h/rs_record_playback.h" 3
void rs2_playback_device_resume(const rs2_device * device, rs2_error ** error); 
# 129
void rs2_playback_device_pause(const rs2_device * device, rs2_error ** error); 
# 143 "/usr/local/include/librealsense2/h/rs_record_playback.h" 3
void rs2_playback_device_set_real_time(const rs2_device * device, int real_time, rs2_error ** error); 
# 151
int rs2_playback_device_is_real_time(const rs2_device * device, rs2_error ** error); 
# 162 "/usr/local/include/librealsense2/h/rs_record_playback.h" 3
void rs2_playback_device_set_status_changed_callback(const rs2_device * device, rs2_playback_status_changed_callback * callback, rs2_error ** error); 
# 170
rs2_playback_status rs2_playback_device_get_current_status(const rs2_device * device, rs2_error ** error); 
# 179 "/usr/local/include/librealsense2/h/rs_record_playback.h" 3
void rs2_playback_device_set_playback_speed(const rs2_device * device, float speed, rs2_error ** error); 
# 187
void rs2_playback_device_stop(const rs2_device * device, rs2_error ** error); 
# 190
}
# 47 "/usr/local/include/librealsense2/rs.h" 3
int rs2_get_raw_data_size(const rs2_raw_data_buffer * buffer, rs2_error ** error); 
# 53
void rs2_delete_raw_data(const rs2_raw_data_buffer * buffer); 
# 61
const unsigned char *rs2_get_raw_data(const rs2_raw_data_buffer * buffer, rs2_error ** error); 
# 68
int rs2_get_api_version(rs2_error ** error); 
# 70
void rs2_log_to_console(rs2_log_severity min_severity, rs2_error ** error); 
# 72
void rs2_log_to_file(rs2_log_severity min_severity, const char * file_path, rs2_error ** error); 
# 80
void rs2_log(rs2_log_severity severity, const char * message, rs2_error ** error); 
# 88
float rs2_depth_frame_get_distance(const rs2_frame * frame_ref, int x, int y, rs2_error ** error); 
# 95
rs2_time_t rs2_get_time(rs2_error ** error); 
# 98
}
# 14 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
extern "C" {
# 14 "/usr/local/include/librealsense2/h/rs_config.h" 3
extern "C" {
# 31 "/usr/local/include/librealsense2/h/rs_config.h" 3
rs2_config *rs2_create_config(rs2_error ** error); 
# 38
void rs2_delete_config(rs2_config * config); 
# 61 "/usr/local/include/librealsense2/h/rs_config.h" 3
void rs2_config_enable_stream(rs2_config * config, rs2_stream stream, int index, int width, int height, rs2_format format, int framerate, rs2_error ** error); 
# 79 "/usr/local/include/librealsense2/h/rs_config.h" 3
void rs2_config_enable_all_stream(rs2_config * config, rs2_error ** error); 
# 91 "/usr/local/include/librealsense2/h/rs_config.h" 3
void rs2_config_enable_device(rs2_config * config, const char * serial, rs2_error ** error); 
# 104 "/usr/local/include/librealsense2/h/rs_config.h" 3
void rs2_config_enable_device_from_file(rs2_config * config, const char * file, rs2_error ** error); 
# 118 "/usr/local/include/librealsense2/h/rs_config.h" 3
void rs2_config_enable_device_from_file_repeat_option(rs2_config * config, const char * file, int repeat_playback, rs2_error ** error); 
# 128 "/usr/local/include/librealsense2/h/rs_config.h" 3
void rs2_config_enable_record_to_file(rs2_config * config, const char * file, rs2_error ** error); 
# 140 "/usr/local/include/librealsense2/h/rs_config.h" 3
void rs2_config_disable_stream(rs2_config * config, rs2_stream stream, rs2_error ** error); 
# 152 "/usr/local/include/librealsense2/h/rs_config.h" 3
void rs2_config_disable_indexed_stream(rs2_config * config, rs2_stream stream, int index, rs2_error ** error); 
# 162 "/usr/local/include/librealsense2/h/rs_config.h" 3
void rs2_config_disable_all_streams(rs2_config * config, rs2_error ** error); 
# 182 "/usr/local/include/librealsense2/h/rs_config.h" 3
rs2_pipeline_profile *rs2_config_resolve(rs2_config * config, rs2_pipeline * pipe, rs2_error ** error); 
# 193 "/usr/local/include/librealsense2/h/rs_config.h" 3
int rs2_config_can_resolve(rs2_config * config, rs2_pipeline * pipe, rs2_error ** error); 
# 196
}
# 32 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_pipeline *rs2_create_pipeline(rs2_context * ctx, rs2_error ** error); 
# 42 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
void rs2_pipeline_stop(rs2_pipeline * pipe, rs2_error ** error); 
# 58 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_frame *rs2_pipeline_wait_for_frames(rs2_pipeline * pipe, unsigned timeout_ms, rs2_error ** error); 
# 75 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
int rs2_pipeline_poll_for_frames(rs2_pipeline * pipe, rs2_frame ** output_frame, rs2_error ** error); 
# 92 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
int rs2_pipeline_try_wait_for_frames(rs2_pipeline * pipe, rs2_frame ** output_frame, unsigned timeout_ms, rs2_error ** error); 
# 99
void rs2_delete_pipeline(rs2_pipeline * pipe); 
# 113 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_pipeline_profile *rs2_pipeline_start(rs2_pipeline * pipe, rs2_error ** error); 
# 133 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_pipeline_profile *rs2_pipeline_start_with_config(rs2_pipeline * pipe, rs2_config * config, rs2_error ** error); 
# 147 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_pipeline_profile *rs2_pipeline_start_with_callback(rs2_pipeline * pipe, rs2_frame_callback_ptr on_frame, void * user, rs2_error ** error); 
# 160 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_pipeline_profile *rs2_pipeline_start_with_callback_cpp(rs2_pipeline * pipe, rs2_frame_callback * callback, rs2_error ** error); 
# 180 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_pipeline_profile *rs2_pipeline_start_with_config_and_callback(rs2_pipeline * pipe, rs2_config * config, rs2_frame_callback_ptr on_frame, void * user, rs2_error ** error); 
# 199 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_pipeline_profile *rs2_pipeline_start_with_config_and_callback_cpp(rs2_pipeline * pipe, rs2_config * config, rs2_frame_callback * callback, rs2_error ** error); 
# 211 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_pipeline_profile *rs2_pipeline_get_active_profile(rs2_pipeline * pipe, rs2_error ** error); 
# 226 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_device *rs2_pipeline_profile_get_device(rs2_pipeline_profile * profile, rs2_error ** error); 
# 235 "/usr/local/include/librealsense2/h/rs_pipeline.h" 3
rs2_stream_profile_list *rs2_pipeline_profile_get_streams(rs2_pipeline_profile * profile, rs2_error ** error); 
# 242
void rs2_delete_pipeline_profile(rs2_pipeline_profile * profile); 
# 245
}
# 63 "/usr/include/c++/5/bits/stl_construct.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 72
template< class _T1, class ..._Args> inline void 
# 74
_Construct(_T1 *__p, _Args &&...__args) 
# 75
{ ::new (static_cast< void *>(__p)) (_T1)(std::forward< _Args> (__args)...); } 
# 90 "/usr/include/c++/5/bits/stl_construct.h" 3
template< class _Tp> inline void 
# 92
_Destroy(_Tp *__pointer) 
# 93
{ (__pointer->~_Tp()); } 
# 95
template< bool > 
# 96
struct _Destroy_aux { 
# 98
template< class _ForwardIterator> static void 
# 100
__destroy(_ForwardIterator __first, _ForwardIterator __last) 
# 101
{ 
# 102
for (; __first != __last; ++__first) { 
# 103
std::_Destroy(std::__addressof(*__first)); }  
# 104
} 
# 105
}; 
# 108
template<> struct _Destroy_aux< true>  { 
# 110
template< class _ForwardIterator> static void 
# 112
__destroy(_ForwardIterator, _ForwardIterator) { } 
# 113
}; 
# 120
template< class _ForwardIterator> inline void 
# 122
_Destroy(_ForwardIterator __first, _ForwardIterator __last) 
# 123
{ 
# 125
typedef typename iterator_traits< _ForwardIterator> ::value_type _Value_type; 
# 126
std::_Destroy_aux< __has_trivial_destructor(typename iterator_traits< _ForwardIterator> ::value_type)> ::__destroy(__first, __last); 
# 128
} 
# 136
template< class _ForwardIterator, class _Allocator> void 
# 138
_Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &
# 139
__alloc) 
# 140
{ 
# 141
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 142
for (; __first != __last; ++__first) { 
# 143
__traits::destroy(__alloc, std::__addressof(*__first)); }  
# 144
} 
# 146
template< class _ForwardIterator, class _Tp> inline void 
# 148
_Destroy(_ForwardIterator __first, _ForwardIterator __last, allocator< _Tp>  &) 
# 150
{ 
# 151
_Destroy(__first, __last); 
# 152
} 
# 155
}
# 59 "/usr/include/c++/5/bits/stl_uninitialized.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 63
template< bool _TrivialValueTypes> 
# 64
struct __uninitialized_copy { 
# 66
template< class _InputIterator, class _ForwardIterator> static _ForwardIterator 
# 68
__uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 69
__result) 
# 70
{ 
# 71
_ForwardIterator __cur = __result; 
# 72
try 
# 73
{ 
# 74
for (; __first != __last; (++__first), (++__cur)) { 
# 75
std::_Construct(std::__addressof(*__cur), *__first); }  
# 76
return __cur; 
# 77
} 
# 78
catch (...) 
# 79
{ 
# 80
std::_Destroy(__result, __cur); 
# 81
throw; 
# 82
}  
# 83
} 
# 84
}; 
# 87
template<> struct __uninitialized_copy< true>  { 
# 89
template< class _InputIterator, class _ForwardIterator> static _ForwardIterator 
# 91
__uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 92
__result) 
# 93
{ return std::copy(__first, __last, __result); } 
# 94
}; 
# 105 "/usr/include/c++/5/bits/stl_uninitialized.h" 3
template< class _InputIterator, class _ForwardIterator> inline _ForwardIterator 
# 107
uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 108
__result) 
# 109
{ 
# 111
typedef typename iterator_traits< _InputIterator> ::value_type _ValueType1; 
# 113
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType2; 
# 118
typedef typename iterator_traits< _InputIterator> ::reference _RefType1; 
# 119
typedef typename iterator_traits< _ForwardIterator> ::reference _RefType2; 
# 120
const bool __assignable = (is_assignable< typename iterator_traits< _ForwardIterator> ::reference, typename iterator_traits< _InputIterator> ::reference> ::value); 
# 123
return std::__uninitialized_copy< __is_trivial(typename iterator_traits< _InputIterator> ::value_type) && __is_trivial(typename iterator_traits< _ForwardIterator> ::value_type) && __assignable> ::__uninit_copy(__first, __last, __result); 
# 127
} 
# 130
template< bool _TrivialValueType> 
# 131
struct __uninitialized_fill { 
# 133
template< class _ForwardIterator, class _Tp> static void 
# 135
__uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 136
__x) 
# 137
{ 
# 138
_ForwardIterator __cur = __first; 
# 139
try 
# 140
{ 
# 141
for (; __cur != __last; ++__cur) { 
# 142
std::_Construct(std::__addressof(*__cur), __x); }  
# 143
} 
# 144
catch (...) 
# 145
{ 
# 146
std::_Destroy(__first, __cur); 
# 147
throw; 
# 148
}  
# 149
} 
# 150
}; 
# 153
template<> struct __uninitialized_fill< true>  { 
# 155
template< class _ForwardIterator, class _Tp> static void 
# 157
__uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 158
__x) 
# 159
{ std::fill(__first, __last, __x); } 
# 160
}; 
# 171 "/usr/include/c++/5/bits/stl_uninitialized.h" 3
template< class _ForwardIterator, class _Tp> inline void 
# 173
uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 174
__x) 
# 175
{ 
# 177
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 182
const bool __assignable = (is_copy_assignable< typename iterator_traits< _ForwardIterator> ::value_type> ::value); 
# 185
std::__uninitialized_fill< __is_trivial(typename iterator_traits< _ForwardIterator> ::value_type) && __assignable> ::__uninit_fill(__first, __last, __x); 
# 187
} 
# 190
template< bool _TrivialValueType> 
# 191
struct __uninitialized_fill_n { 
# 193
template< class _ForwardIterator, class _Size, class _Tp> static _ForwardIterator 
# 195
__uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &
# 196
__x) 
# 197
{ 
# 198
_ForwardIterator __cur = __first; 
# 199
try 
# 200
{ 
# 201
for (; __n > 0; (--__n), (++__cur)) { 
# 202
std::_Construct(std::__addressof(*__cur), __x); }  
# 203
return __cur; 
# 204
} 
# 205
catch (...) 
# 206
{ 
# 207
std::_Destroy(__first, __cur); 
# 208
throw; 
# 209
}  
# 210
} 
# 211
}; 
# 214
template<> struct __uninitialized_fill_n< true>  { 
# 216
template< class _ForwardIterator, class _Size, class _Tp> static _ForwardIterator 
# 218
__uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &
# 219
__x) 
# 220
{ return std::fill_n(__first, __n, __x); } 
# 221
}; 
# 234 "/usr/include/c++/5/bits/stl_uninitialized.h" 3
template< class _ForwardIterator, class _Size, class _Tp> inline _ForwardIterator 
# 236
uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) 
# 237
{ 
# 239
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 244
const bool __assignable = (is_copy_assignable< typename iterator_traits< _ForwardIterator> ::value_type> ::value); 
# 246
return __uninitialized_fill_n< __is_trivial(typename iterator_traits< _ForwardIterator> ::value_type) && __assignable> ::__uninit_fill_n(__first, __n, __x); 
# 248
} 
# 256
template< class _InputIterator, class _ForwardIterator, class 
# 257
_Allocator> _ForwardIterator 
# 259
__uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 260
__result, _Allocator &__alloc) 
# 261
{ 
# 262
_ForwardIterator __cur = __result; 
# 263
try 
# 264
{ 
# 265
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 266
for (; __first != __last; (++__first), (++__cur)) { 
# 267
__traits::construct(__alloc, std::__addressof(*__cur), *__first); }  
# 268
return __cur; 
# 269
} 
# 270
catch (...) 
# 271
{ 
# 272
std::_Destroy(__result, __cur, __alloc); 
# 273
throw; 
# 274
}  
# 275
} 
# 277
template< class _InputIterator, class _ForwardIterator, class _Tp> inline _ForwardIterator 
# 279
__uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 280
__result, allocator< _Tp>  &) 
# 281
{ return std::uninitialized_copy(__first, __last, __result); } 
# 283
template< class _InputIterator, class _ForwardIterator, class 
# 284
_Allocator> inline _ForwardIterator 
# 286
__uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 287
__result, _Allocator &__alloc) 
# 288
{ 
# 289
return std::__uninitialized_copy_a(std::make_move_iterator(__first), std::make_move_iterator(__last), __result, __alloc); 
# 292
} 
# 294
template< class _InputIterator, class _ForwardIterator, class 
# 295
_Allocator> inline _ForwardIterator 
# 297
__uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator 
# 298
__last, _ForwardIterator 
# 299
__result, _Allocator &
# 300
__alloc) 
# 301
{ 
# 302
return std::__uninitialized_copy_a(std::__make_move_if_noexcept_iterator(__first), std::__make_move_if_noexcept_iterator(__last), __result, __alloc); 
# 305
} 
# 307
template< class _ForwardIterator, class _Tp, class _Allocator> void 
# 309
__uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 310
__x, _Allocator &__alloc) 
# 311
{ 
# 312
_ForwardIterator __cur = __first; 
# 313
try 
# 314
{ 
# 315
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 316
for (; __cur != __last; ++__cur) { 
# 317
__traits::construct(__alloc, std::__addressof(*__cur), __x); }  
# 318
} 
# 319
catch (...) 
# 320
{ 
# 321
std::_Destroy(__first, __cur, __alloc); 
# 322
throw; 
# 323
}  
# 324
} 
# 326
template< class _ForwardIterator, class _Tp, class _Tp2> inline void 
# 328
__uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 329
__x, allocator< _Tp2>  &) 
# 330
{ std::uninitialized_fill(__first, __last, __x); } 
# 332
template< class _ForwardIterator, class _Size, class _Tp, class 
# 333
_Allocator> _ForwardIterator 
# 335
__uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &
# 336
__x, _Allocator &__alloc) 
# 337
{ 
# 338
_ForwardIterator __cur = __first; 
# 339
try 
# 340
{ 
# 341
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 342
for (; __n > 0; (--__n), (++__cur)) { 
# 343
__traits::construct(__alloc, std::__addressof(*__cur), __x); }  
# 344
return __cur; 
# 345
} 
# 346
catch (...) 
# 347
{ 
# 348
std::_Destroy(__first, __cur, __alloc); 
# 349
throw; 
# 350
}  
# 351
} 
# 353
template< class _ForwardIterator, class _Size, class _Tp, class 
# 354
_Tp2> inline _ForwardIterator 
# 356
__uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &
# 357
__x, allocator< _Tp2>  &) 
# 358
{ return std::uninitialized_fill_n(__first, __n, __x); } 
# 370 "/usr/include/c++/5/bits/stl_uninitialized.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 371
_ForwardIterator, class _Allocator> inline _ForwardIterator 
# 373
__uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 
# 374
__last1, _InputIterator2 
# 375
__first2, _InputIterator2 
# 376
__last2, _ForwardIterator 
# 377
__result, _Allocator &
# 378
__alloc) 
# 379
{ 
# 380
_ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1, __result, __alloc); 
# 383
try 
# 384
{ 
# 385
return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc); 
# 386
} 
# 387
catch (...) 
# 388
{ 
# 389
std::_Destroy(__result, __mid, __alloc); 
# 390
throw; 
# 391
}  
# 392
} 
# 398
template< class _InputIterator1, class _InputIterator2, class 
# 399
_ForwardIterator, class _Allocator> inline _ForwardIterator 
# 401
__uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 
# 402
__last1, _InputIterator2 
# 403
__first2, _InputIterator2 
# 404
__last2, _ForwardIterator 
# 405
__result, _Allocator &
# 406
__alloc) 
# 407
{ 
# 408
_ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1, __result, __alloc); 
# 411
try 
# 412
{ 
# 413
return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc); 
# 414
} 
# 415
catch (...) 
# 416
{ 
# 417
std::_Destroy(__result, __mid, __alloc); 
# 418
throw; 
# 419
}  
# 420
} 
# 425
template< class _ForwardIterator, class _Tp, class _InputIterator, class 
# 426
_Allocator> inline _ForwardIterator 
# 428
__uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &
# 429
__x, _InputIterator __first, _InputIterator 
# 430
__last, _Allocator &__alloc) 
# 431
{ 
# 432
std::__uninitialized_fill_a(__result, __mid, __x, __alloc); 
# 433
try 
# 434
{ 
# 435
return std::__uninitialized_move_a(__first, __last, __mid, __alloc); 
# 436
} 
# 437
catch (...) 
# 438
{ 
# 439
std::_Destroy(__result, __mid, __alloc); 
# 440
throw; 
# 441
}  
# 442
} 
# 447
template< class _InputIterator, class _ForwardIterator, class _Tp, class 
# 448
_Allocator> inline void 
# 450
__uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator 
# 451
__first2, _ForwardIterator 
# 452
__last2, const _Tp &__x, _Allocator &
# 453
__alloc) 
# 454
{ 
# 455
_ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1, __first2, __alloc); 
# 458
try 
# 459
{ 
# 460
std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc); 
# 461
} 
# 462
catch (...) 
# 463
{ 
# 464
std::_Destroy(__first2, __mid2, __alloc); 
# 465
throw; 
# 466
}  
# 467
} 
# 473
template< bool _TrivialValueType> 
# 474
struct __uninitialized_default_1 { 
# 476
template< class _ForwardIterator> static void 
# 478
__uninit_default(_ForwardIterator __first, _ForwardIterator __last) 
# 479
{ 
# 480
_ForwardIterator __cur = __first; 
# 481
try 
# 482
{ 
# 483
for (; __cur != __last; ++__cur) { 
# 484
std::_Construct(std::__addressof(*__cur)); }  
# 485
} 
# 486
catch (...) 
# 487
{ 
# 488
std::_Destroy(__first, __cur); 
# 489
throw; 
# 490
}  
# 491
} 
# 492
}; 
# 495
template<> struct __uninitialized_default_1< true>  { 
# 497
template< class _ForwardIterator> static void 
# 499
__uninit_default(_ForwardIterator __first, _ForwardIterator __last) 
# 500
{ 
# 502
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 504
std::fill(__first, __last, _ValueType()); 
# 505
} 
# 506
}; 
# 508
template< bool _TrivialValueType> 
# 509
struct __uninitialized_default_n_1 { 
# 511
template< class _ForwardIterator, class _Size> static _ForwardIterator 
# 513
__uninit_default_n(_ForwardIterator __first, _Size __n) 
# 514
{ 
# 515
_ForwardIterator __cur = __first; 
# 516
try 
# 517
{ 
# 518
for (; __n > 0; (--__n), (++__cur)) { 
# 519
std::_Construct(std::__addressof(*__cur)); }  
# 520
return __cur; 
# 521
} 
# 522
catch (...) 
# 523
{ 
# 524
std::_Destroy(__first, __cur); 
# 525
throw; 
# 526
}  
# 527
} 
# 528
}; 
# 531
template<> struct __uninitialized_default_n_1< true>  { 
# 533
template< class _ForwardIterator, class _Size> static _ForwardIterator 
# 535
__uninit_default_n(_ForwardIterator __first, _Size __n) 
# 536
{ 
# 538
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 540
return std::fill_n(__first, __n, _ValueType()); 
# 541
} 
# 542
}; 
# 547
template< class _ForwardIterator> inline void 
# 549
__uninitialized_default(_ForwardIterator __first, _ForwardIterator 
# 550
__last) 
# 551
{ 
# 553
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 555
const bool __assignable = (is_copy_assignable< typename iterator_traits< _ForwardIterator> ::value_type> ::value); 
# 557
std::__uninitialized_default_1< __is_trivial(typename iterator_traits< _ForwardIterator> ::value_type) && __assignable> ::__uninit_default(__first, __last); 
# 560
} 
# 564
template< class _ForwardIterator, class _Size> inline _ForwardIterator 
# 566
__uninitialized_default_n(_ForwardIterator __first, _Size __n) 
# 567
{ 
# 569
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 571
const bool __assignable = (is_copy_assignable< typename iterator_traits< _ForwardIterator> ::value_type> ::value); 
# 573
return __uninitialized_default_n_1< __is_trivial(typename iterator_traits< _ForwardIterator> ::value_type) && __assignable> ::__uninit_default_n(__first, __n); 
# 576
} 
# 582
template< class _ForwardIterator, class _Allocator> void 
# 584
__uninitialized_default_a(_ForwardIterator __first, _ForwardIterator 
# 585
__last, _Allocator &
# 586
__alloc) 
# 587
{ 
# 588
_ForwardIterator __cur = __first; 
# 589
try 
# 590
{ 
# 591
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 592
for (; __cur != __last; ++__cur) { 
# 593
__traits::construct(__alloc, std::__addressof(*__cur)); }  
# 594
} 
# 595
catch (...) 
# 596
{ 
# 597
std::_Destroy(__first, __cur, __alloc); 
# 598
throw; 
# 599
}  
# 600
} 
# 602
template< class _ForwardIterator, class _Tp> inline void 
# 604
__uninitialized_default_a(_ForwardIterator __first, _ForwardIterator 
# 605
__last, allocator< _Tp>  &) 
# 607
{ std::__uninitialized_default(__first, __last); } 
# 613
template< class _ForwardIterator, class _Size, class _Allocator> _ForwardIterator 
# 615
__uninitialized_default_n_a(_ForwardIterator __first, _Size __n, _Allocator &
# 616
__alloc) 
# 617
{ 
# 618
_ForwardIterator __cur = __first; 
# 619
try 
# 620
{ 
# 621
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 622
for (; __n > 0; (--__n), (++__cur)) { 
# 623
__traits::construct(__alloc, std::__addressof(*__cur)); }  
# 624
return __cur; 
# 625
} 
# 626
catch (...) 
# 627
{ 
# 628
std::_Destroy(__first, __cur, __alloc); 
# 629
throw; 
# 630
}  
# 631
} 
# 633
template< class _ForwardIterator, class _Size, class _Tp> inline _ForwardIterator 
# 635
__uninitialized_default_n_a(_ForwardIterator __first, _Size __n, allocator< _Tp>  &) 
# 637
{ return std::__uninitialized_default_n(__first, __n); } 
# 640
template< class _InputIterator, class _Size, class 
# 641
_ForwardIterator> _ForwardIterator 
# 643
__uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator 
# 644
__result, input_iterator_tag) 
# 645
{ 
# 646
_ForwardIterator __cur = __result; 
# 647
try 
# 648
{ 
# 649
for (; __n > 0; ((--__n), (++__first)), (++__cur)) { 
# 650
std::_Construct(std::__addressof(*__cur), *__first); }  
# 651
return __cur; 
# 652
} 
# 653
catch (...) 
# 654
{ 
# 655
std::_Destroy(__result, __cur); 
# 656
throw; 
# 657
}  
# 658
} 
# 660
template< class _RandomAccessIterator, class _Size, class 
# 661
_ForwardIterator> inline _ForwardIterator 
# 663
__uninitialized_copy_n(_RandomAccessIterator __first, _Size __n, _ForwardIterator 
# 664
__result, random_access_iterator_tag) 
# 666
{ return std::uninitialized_copy(__first, __first + __n, __result); } 
# 677 "/usr/include/c++/5/bits/stl_uninitialized.h" 3
template< class _InputIterator, class _Size, class _ForwardIterator> inline _ForwardIterator 
# 679
uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator 
# 680
__result) 
# 681
{ return std::__uninitialized_copy_n(__first, __n, __result, std::__iterator_category(__first)); 
# 682
} 
# 686
}
# 66 "/usr/include/c++/5/bits/stl_vector.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
template< class _Tp, class _Alloc> 
# 72
struct _Vector_base { 
# 75
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other _Tp_alloc_type; 
# 77
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::pointer pointer; 
# 79
struct _Vector_impl : public _Tp_alloc_type { 
# 82
typename ::std::_Vector_base< _Tp, _Alloc> ::pointer _M_start; 
# 83
typename ::std::_Vector_base< _Tp, _Alloc> ::pointer _M_finish; 
# 84
typename ::std::_Vector_base< _Tp, _Alloc> ::pointer _M_end_of_storage; 
# 86
_Vector_impl() : ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage() 
# 88
{ } 
# 90
_Vector_impl(const typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type &__a) noexcept : ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage() 
# 92
{ } 
# 95
_Vector_impl(typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type &&__a) noexcept : ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type(::std::move(__a)), _M_start(), _M_finish(), _M_end_of_storage() 
# 98
{ } 
# 101
void _M_swap_data(_Vector_impl &__x) noexcept 
# 102
{ 
# 103
::std::swap(_M_start, (__x._M_start)); 
# 104
::std::swap(_M_finish, (__x._M_finish)); 
# 105
::std::swap(_M_end_of_storage, (__x._M_end_of_storage)); 
# 106
} 
# 107
}; 
# 110
typedef _Alloc allocator_type; 
# 113
_Tp_alloc_type &_M_get_Tp_allocator() noexcept 
# 114
{ return *(static_cast< _Tp_alloc_type *>(&(this->_M_impl))); } 
# 117
const _Tp_alloc_type &_M_get_Tp_allocator() const noexcept 
# 118
{ return *(static_cast< const _Tp_alloc_type *>(&(this->_M_impl))); } 
# 121
allocator_type get_allocator() const noexcept 
# 122
{ return (allocator_type)this->_M_get_Tp_allocator(); } 
# 124
_Vector_base() : _M_impl() 
# 125
{ } 
# 127
_Vector_base(const allocator_type &__a) noexcept : _M_impl(__a) 
# 128
{ } 
# 130
_Vector_base(size_t __n) : _M_impl() 
# 132
{ _M_create_storage(__n); } 
# 134
_Vector_base(size_t __n, const allocator_type &__a) : _M_impl(__a) 
# 136
{ _M_create_storage(__n); } 
# 139
_Vector_base(_Tp_alloc_type &&__a) noexcept : _M_impl(std::move(__a)) 
# 140
{ } 
# 142
_Vector_base(_Vector_base &&__x) noexcept : _M_impl(std::move((__x._M_get_Tp_allocator()))) 
# 144
{ ((this->_M_impl)._M_swap_data((__x._M_impl))); } 
# 146
_Vector_base(_Vector_base &&__x, const allocator_type &__a) : _M_impl(__a) 
# 148
{ 
# 149
if ((__x.get_allocator()) == __a) { 
# 150
((this->_M_impl)._M_swap_data((__x._M_impl))); } else 
# 152
{ 
# 153
size_t __n = ((__x._M_impl)._M_finish) - ((__x._M_impl)._M_start); 
# 154
_M_create_storage(__n); 
# 155
}  
# 156
} 
# 159
~_Vector_base() noexcept 
# 160
{ _M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 161
} 
# 164
_Vector_impl _M_impl; 
# 167
pointer _M_allocate(size_t __n) 
# 168
{ 
# 169
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other>  _Tr; 
# 170
return (__n != (0)) ? _Tr::allocate(_M_impl, __n) : (pointer()); 
# 171
} 
# 174
void _M_deallocate(pointer __p, size_t __n) 
# 175
{ 
# 176
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other>  _Tr; 
# 177
if (__p) { 
# 178
_Tr::deallocate(_M_impl, __p, __n); }  
# 179
} 
# 183
private: void _M_create_storage(size_t __n) 
# 184
{ 
# 185
((this->_M_impl)._M_start) = this->_M_allocate(__n); 
# 186
((this->_M_impl)._M_finish) = ((this->_M_impl)._M_start); 
# 187
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __n); 
# 188
} 
# 189
}; 
# 213 "/usr/include/c++/5/bits/stl_vector.h" 3
template< class _Tp, class _Alloc = allocator< _Tp> > 
# 214
class vector : protected _Vector_base< _Tp, _Alloc>  { 
# 217
typedef typename _Alloc::value_type _Alloc_value_type; 
# 221
typedef ::std::_Vector_base< _Tp, _Alloc>  _Base; 
# 222
typedef typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type _Tp_alloc_type; 
# 223
typedef ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type>  _Alloc_traits; 
# 226
public: typedef _Tp value_type; 
# 227
typedef typename ::std::_Vector_base< _Tp, _Alloc> ::pointer pointer; 
# 228
typedef typename ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::const_pointer const_pointer; 
# 229
typedef typename ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::reference reference; 
# 230
typedef typename ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::const_reference const_reference; 
# 231
typedef ::__gnu_cxx::__normal_iterator< typename ::std::_Vector_base< _Tp, _Alloc> ::pointer, vector>  iterator; 
# 233
typedef ::__gnu_cxx::__normal_iterator< typename ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::const_pointer, vector>  const_iterator; 
# 234
typedef ::std::reverse_iterator< ::__gnu_cxx::__normal_iterator< typename ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::const_pointer, vector> >  const_reverse_iterator; 
# 235
typedef ::std::reverse_iterator< ::__gnu_cxx::__normal_iterator< typename ::std::_Vector_base< _Tp, _Alloc> ::pointer, vector> >  reverse_iterator; 
# 236
typedef ::std::size_t size_type; 
# 237
typedef ::std::ptrdiff_t difference_type; 
# 238
typedef _Alloc allocator_type; 
# 241
protected: using ::std::_Vector_base< _Tp, _Alloc> ::_M_allocate;
# 242
using ::std::_Vector_base< _Tp, _Alloc> ::_M_deallocate;
# 243
using ::std::_Vector_base< _Tp, _Alloc> ::_M_impl;
# 244
using ::std::_Vector_base< _Tp, _Alloc> ::_M_get_Tp_allocator;
# 253
public: vector() noexcept(is_nothrow_default_constructible< _Alloc> ::value) : _Base() 
# 257
{ } 
# 264
explicit vector(const allocator_type &__a) noexcept : _Base(__a) 
# 265
{ } 
# 277 "/usr/include/c++/5/bits/stl_vector.h" 3
explicit vector(size_type __n, const allocator_type &__a = allocator_type()) : _Base(__n, __a) 
# 279
{ _M_default_initialize(__n); } 
# 289 "/usr/include/c++/5/bits/stl_vector.h" 3
vector(size_type __n, const value_type &__value, const allocator_type &
# 290
__a = allocator_type()) : _Base(__n, __a) 
# 292
{ _M_fill_initialize(__n, __value); } 
# 318 "/usr/include/c++/5/bits/stl_vector.h" 3
vector(const vector &__x) : _Base((__x.size()), _Alloc_traits::_S_select_on_copy((__x._M_get_Tp_allocator()))) 
# 321
{ ((this->_M_impl)._M_finish) = ::std::__uninitialized_copy_a((__x.begin()), (__x.end()), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 325
} 
# 335 "/usr/include/c++/5/bits/stl_vector.h" 3
vector(vector &&__x) noexcept : _Base(::std::move(__x)) 
# 336
{ } 
# 339
vector(const vector &__x, const allocator_type &__a) : _Base((__x.size()), __a) 
# 341
{ ((this->_M_impl)._M_finish) = ::std::__uninitialized_copy_a((__x.begin()), (__x.end()), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 345
} 
# 348
vector(vector &&__rv, const allocator_type &__m) noexcept(_Alloc_traits::_S_always_equal()) : _Base(::std::move(__rv), __m) 
# 351
{ 
# 352
if ((__rv.get_allocator()) != __m) 
# 353
{ 
# 354
((this->_M_impl)._M_finish) = ::std::__uninitialized_move_a((__rv.begin()), (__rv.end()), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 358
(__rv.clear()); 
# 359
}  
# 360
} 
# 373 "/usr/include/c++/5/bits/stl_vector.h" 3
vector(initializer_list< _Tp>  __l, const allocator_type &
# 374
__a = allocator_type()) : _Base(__a) 
# 376
{ 
# 377
_M_range_initialize((__l.begin()), (__l.end()), ::std::random_access_iterator_tag()); 
# 379
} 
# 399 "/usr/include/c++/5/bits/stl_vector.h" 3
template< class _InputIterator, class 
# 400
 = ::std::_RequireInputIter< _InputIterator> > 
# 401
vector(_InputIterator __first, _InputIterator __last, const allocator_type &
# 402
__a = allocator_type()) : _Base(__a) 
# 404
{ _M_initialize_dispatch(__first, __last, ::std::__false_type()); } 
# 423 "/usr/include/c++/5/bits/stl_vector.h" 3
~vector() noexcept 
# 424
{ ::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 425
} 
# 436 "/usr/include/c++/5/bits/stl_vector.h" 3
vector &operator=(const vector & __x); 
# 448 "/usr/include/c++/5/bits/stl_vector.h" 3
vector &operator=(vector &&__x) noexcept(_Alloc_traits::_S_nothrow_move()) 
# 449
{ 
# 450
constexpr bool __move_storage = (_Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal()); 
# 453
_M_move_assign(::std::move(__x), integral_constant< bool, __move_storage> ()); 
# 455
return *this; 
# 456
} 
# 470 "/usr/include/c++/5/bits/stl_vector.h" 3
vector &operator=(initializer_list< _Tp>  __l) 
# 471
{ 
# 472
(this->assign((__l.begin()), (__l.end()))); 
# 473
return *this; 
# 474
} 
# 488 "/usr/include/c++/5/bits/stl_vector.h" 3
void assign(size_type __n, const value_type &__val) 
# 489
{ _M_fill_assign(__n, __val); } 
# 504 "/usr/include/c++/5/bits/stl_vector.h" 3
template< class _InputIterator, class 
# 505
 = ::std::_RequireInputIter< _InputIterator> > void 
# 507
assign(_InputIterator __first, _InputIterator __last) 
# 508
{ _M_assign_dispatch(__first, __last, ::std::__false_type()); } 
# 533 "/usr/include/c++/5/bits/stl_vector.h" 3
void assign(initializer_list< _Tp>  __l) 
# 534
{ (this->assign((__l.begin()), (__l.end()))); } 
# 538
using ::std::_Vector_base< _Tp, _Alloc> ::get_allocator;
# 547
iterator begin() noexcept 
# 548
{ return ((iterator)(((this->_M_impl)._M_start))); } 
# 556
const_iterator begin() const noexcept 
# 557
{ return ((const_iterator)(((this->_M_impl)._M_start))); } 
# 565
iterator end() noexcept 
# 566
{ return ((iterator)(((this->_M_impl)._M_finish))); } 
# 574
const_iterator end() const noexcept 
# 575
{ return ((const_iterator)(((this->_M_impl)._M_finish))); } 
# 583
reverse_iterator rbegin() noexcept 
# 584
{ return ((reverse_iterator)(this->end())); } 
# 592
const_reverse_iterator rbegin() const noexcept 
# 593
{ return ((const_reverse_iterator)(this->end())); } 
# 601
reverse_iterator rend() noexcept 
# 602
{ return ((reverse_iterator)(this->begin())); } 
# 610
const_reverse_iterator rend() const noexcept 
# 611
{ return ((const_reverse_iterator)(this->begin())); } 
# 620
const_iterator cbegin() const noexcept 
# 621
{ return ((const_iterator)(((this->_M_impl)._M_start))); } 
# 629
const_iterator cend() const noexcept 
# 630
{ return ((const_iterator)(((this->_M_impl)._M_finish))); } 
# 638
const_reverse_iterator crbegin() const noexcept 
# 639
{ return ((const_reverse_iterator)(this->end())); } 
# 647
const_reverse_iterator crend() const noexcept 
# 648
{ return ((const_reverse_iterator)(this->begin())); } 
# 654
size_type size() const noexcept 
# 655
{ return (size_type)(((this->_M_impl)._M_finish) - ((this->_M_impl)._M_start)); } 
# 659
size_type max_size() const noexcept 
# 660
{ return _Alloc_traits::max_size(_M_get_Tp_allocator()); } 
# 673 "/usr/include/c++/5/bits/stl_vector.h" 3
void resize(size_type __new_size) 
# 674
{ 
# 675
if (__new_size > size()) { 
# 676
_M_default_append(__new_size - size()); } else { 
# 677
if (__new_size < size()) { 
# 678
_M_erase_at_end(((this->_M_impl)._M_start) + __new_size); }  }  
# 679
} 
# 693 "/usr/include/c++/5/bits/stl_vector.h" 3
void resize(size_type __new_size, const value_type &__x) 
# 694
{ 
# 695
if (__new_size > size()) { 
# 696
insert(this->end(), __new_size - size(), __x); } else { 
# 697
if (__new_size < size()) { 
# 698
_M_erase_at_end(((this->_M_impl)._M_start) + __new_size); }  }  
# 699
} 
# 725 "/usr/include/c++/5/bits/stl_vector.h" 3
void shrink_to_fit() 
# 726
{ _M_shrink_to_fit(); } 
# 734
size_type capacity() const noexcept 
# 735
{ return (size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 736
} 
# 743
bool empty() const noexcept 
# 744
{ return this->begin() == this->end(); } 
# 764 "/usr/include/c++/5/bits/stl_vector.h" 3
void reserve(size_type __n); 
# 779 "/usr/include/c++/5/bits/stl_vector.h" 3
reference operator[](size_type __n) noexcept 
# 780
{ return *(((this->_M_impl)._M_start) + __n); } 
# 794 "/usr/include/c++/5/bits/stl_vector.h" 3
const_reference operator[](size_type __n) const noexcept 
# 795
{ return *(((this->_M_impl)._M_start) + __n); } 
# 800
protected: void _M_range_check(size_type __n) const 
# 801
{ 
# 802
if (__n >= this->size()) { 
# 803
__throw_out_of_range_fmt("vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size()); }  
# 807
} 
# 822 "/usr/include/c++/5/bits/stl_vector.h" 3
public: reference at(size_type __n) 
# 823
{ 
# 824
_M_range_check(__n); 
# 825
return (*this)[__n]; 
# 826
} 
# 840 "/usr/include/c++/5/bits/stl_vector.h" 3
const_reference at(size_type __n) const 
# 841
{ 
# 842
_M_range_check(__n); 
# 843
return (*this)[__n]; 
# 844
} 
# 851
reference front() noexcept 
# 852
{ return *this->begin(); } 
# 859
const_reference front() const noexcept 
# 860
{ return *this->begin(); } 
# 867
reference back() noexcept 
# 868
{ return *(this->end() - 1); } 
# 875
const_reference back() const noexcept 
# 876
{ return *(this->end() - 1); } 
# 890 "/usr/include/c++/5/bits/stl_vector.h" 3
_Tp *data() noexcept 
# 891
{ return _M_data_ptr(((this->_M_impl)._M_start)); } 
# 898
const _Tp *data() const noexcept 
# 899
{ return _M_data_ptr(((this->_M_impl)._M_start)); } 
# 913 "/usr/include/c++/5/bits/stl_vector.h" 3
void push_back(const value_type &__x) 
# 914
{ 
# 915
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) 
# 916
{ 
# 917
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), __x); 
# 919
++((this->_M_impl)._M_finish); 
# 920
} else { 
# 923
_M_emplace_back_aux(__x); }  
# 927
} 
# 931
void push_back(value_type &&__x) 
# 932
{ emplace_back(::std::move(__x)); } 
# 934
template< class ..._Args> void emplace_back(_Args && ...__args); 
# 949 "/usr/include/c++/5/bits/stl_vector.h" 3
void pop_back() noexcept 
# 950
{ 
# 951
--((this->_M_impl)._M_finish); 
# 952
_Alloc_traits::destroy((this->_M_impl), ((this->_M_impl)._M_finish)); 
# 953
} 
# 968 "/usr/include/c++/5/bits/stl_vector.h" 3
template< class ..._Args> iterator emplace(const_iterator __position, _Args && ...__args); 
# 984 "/usr/include/c++/5/bits/stl_vector.h" 3
iterator insert(const_iterator __position, const value_type & __x); 
# 1014 "/usr/include/c++/5/bits/stl_vector.h" 3
iterator insert(const_iterator __position, value_type &&__x) 
# 1015
{ return emplace(__position, ::std::move(__x)); } 
# 1031 "/usr/include/c++/5/bits/stl_vector.h" 3
iterator insert(const_iterator __position, initializer_list< _Tp>  __l) 
# 1032
{ return (this->insert(__position, (__l.begin()), (__l.end()))); } 
# 1051 "/usr/include/c++/5/bits/stl_vector.h" 3
iterator insert(const_iterator __position, size_type __n, const value_type &__x) 
# 1052
{ 
# 1053
difference_type __offset = __position - cbegin(); 
# 1054
_M_fill_insert(this->begin() + __offset, __n, __x); 
# 1055
return this->begin() + __offset; 
# 1056
} 
# 1092 "/usr/include/c++/5/bits/stl_vector.h" 3
template< class _InputIterator, class 
# 1093
 = ::std::_RequireInputIter< _InputIterator> > iterator 
# 1095
insert(const_iterator __position, _InputIterator __first, _InputIterator 
# 1096
__last) 
# 1097
{ 
# 1098
difference_type __offset = __position - cbegin(); 
# 1099
_M_insert_dispatch(this->begin() + __offset, __first, __last, ::std::__false_type()); 
# 1101
return this->begin() + __offset; 
# 1102
} 
# 1146 "/usr/include/c++/5/bits/stl_vector.h" 3
iterator erase(const_iterator __position) 
# 1147
{ return _M_erase(this->begin() + (__position - cbegin())); } 
# 1173 "/usr/include/c++/5/bits/stl_vector.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 1174
{ 
# 1175
const auto __beg = this->begin(); 
# 1176
const auto __cbeg = cbegin(); 
# 1177
return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg)); 
# 1178
} 
# 1194 "/usr/include/c++/5/bits/stl_vector.h" 3
void swap(vector &__x) noexcept(_Alloc_traits::_S_nothrow_swap()) 
# 1198
{ 
# 1199
((this->_M_impl)._M_swap_data((__x._M_impl))); 
# 1200
_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(), (__x._M_get_Tp_allocator())); 
# 1202
} 
# 1211
void clear() noexcept 
# 1212
{ _M_erase_at_end(((this->_M_impl)._M_start)); } 
# 1221
protected: 
# 1219
template< class _ForwardIterator> pointer 
# 1221
_M_allocate_and_copy(size_type __n, _ForwardIterator 
# 1222
__first, _ForwardIterator __last) 
# 1223
{ 
# 1224
pointer __result = (this->_M_allocate(__n)); 
# 1225
try 
# 1226
{ 
# 1227
::std::__uninitialized_copy_a(__first, __last, __result, _M_get_Tp_allocator()); 
# 1229
return __result; 
# 1230
} 
# 1231
catch (...) 
# 1232
{ 
# 1233
_M_deallocate(__result, __n); 
# 1234
throw; 
# 1235
}  
# 1236
} 
# 1245 "/usr/include/c++/5/bits/stl_vector.h" 3
template< class _Integer> void 
# 1247
_M_initialize_dispatch(_Integer __n, _Integer __value, ::std::__true_type) 
# 1248
{ 
# 1249
((this->_M_impl)._M_start) = _M_allocate(static_cast< size_type>(__n)); 
# 1250
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + (static_cast< size_type>(__n))); 
# 1252
_M_fill_initialize(static_cast< size_type>(__n), __value); 
# 1253
} 
# 1256
template< class _InputIterator> void 
# 1258
_M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1260
{ 
# 1262
typedef typename iterator_traits< _InputIterator> ::iterator_category _IterCategory; 
# 1263
_M_range_initialize(__first, __last, _IterCategory()); 
# 1264
} 
# 1267
template< class _InputIterator> void 
# 1269
_M_range_initialize(_InputIterator __first, _InputIterator 
# 1270
__last, ::std::input_iterator_tag) 
# 1271
{ 
# 1272
for (; __first != __last; ++__first) { 
# 1274
emplace_back(*__first); }  
# 1278
} 
# 1281
template< class _ForwardIterator> void 
# 1283
_M_range_initialize(_ForwardIterator __first, _ForwardIterator 
# 1284
__last, ::std::forward_iterator_tag) 
# 1285
{ 
# 1286
const size_type __n = ::std::distance(__first, __last); 
# 1287
((this->_M_impl)._M_start) = (this->_M_allocate(__n)); 
# 1288
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __n); 
# 1289
((this->_M_impl)._M_finish) = ::std::__uninitialized_copy_a(__first, __last, ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 1293
} 
# 1298
void _M_fill_initialize(size_type __n, const value_type &__value) 
# 1299
{ 
# 1300
((this->_M_impl)._M_finish) = ::std::__uninitialized_fill_n_a(((this->_M_impl)._M_start), __n, __value, _M_get_Tp_allocator()); 
# 1303
} 
# 1308
void _M_default_initialize(size_type __n) 
# 1309
{ 
# 1310
((this->_M_impl)._M_finish) = ::std::__uninitialized_default_n_a(((this->_M_impl)._M_start), __n, _M_get_Tp_allocator()); 
# 1313
} 
# 1323 "/usr/include/c++/5/bits/stl_vector.h" 3
template< class _Integer> void 
# 1325
_M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type) 
# 1326
{ _M_fill_assign(__n, __val); } 
# 1329
template< class _InputIterator> void 
# 1331
_M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1333
{ 
# 1335
typedef typename iterator_traits< _InputIterator> ::iterator_category _IterCategory; 
# 1336
_M_assign_aux(__first, __last, _IterCategory()); 
# 1337
} 
# 1340
template< class _InputIterator> void _M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag); 
# 1346
template< class _ForwardIterator> void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag); 
# 1354
void _M_fill_assign(size_type __n, const value_type & __val); 
# 1363 "/usr/include/c++/5/bits/stl_vector.h" 3
template< class _Integer> void 
# 1365
_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, ::std::__true_type) 
# 1367
{ _M_fill_insert(__pos, __n, __val); } 
# 1370
template< class _InputIterator> void 
# 1372
_M_insert_dispatch(iterator __pos, _InputIterator __first, _InputIterator 
# 1373
__last, ::std::__false_type) 
# 1374
{ 
# 1376
typedef typename iterator_traits< _InputIterator> ::iterator_category _IterCategory; 
# 1377
_M_range_insert(__pos, __first, __last, _IterCategory()); 
# 1378
} 
# 1381
template< class _InputIterator> void _M_range_insert(iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag); 
# 1387
template< class _ForwardIterator> void _M_range_insert(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag); 
# 1395
void _M_fill_insert(iterator __pos, size_type __n, const value_type & __x); 
# 1400
void _M_default_append(size_type __n); 
# 1403
bool _M_shrink_to_fit(); 
# 1411
template< class ..._Args> void _M_insert_aux(iterator __position, _Args && ...__args); 
# 1415
template< class ..._Args> void _M_emplace_back_aux(_Args && ...__args); 
# 1422
size_type _M_check_len(size_type __n, const char *__s) const 
# 1423
{ 
# 1424
if ((max_size() - size()) < __n) { 
# 1425
__throw_length_error(__s); }  
# 1427
const size_type __len = size() + ::std::max(size(), __n); 
# 1428
return ((__len < size()) || (__len > max_size())) ? max_size() : __len; 
# 1429
} 
# 1436
void _M_erase_at_end(pointer __pos) noexcept 
# 1437
{ 
# 1438
::std::_Destroy(__pos, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 1439
((this->_M_impl)._M_finish) = __pos; 
# 1440
} 
# 1443
iterator _M_erase(iterator __position); 
# 1446
iterator _M_erase(iterator __first, iterator __last); 
# 1454
private: void _M_move_assign(vector &&__x, ::std::true_type) noexcept 
# 1455
{ 
# 1456
vector __tmp(get_allocator()); 
# 1457
((this->_M_impl)._M_swap_data((__tmp._M_impl))); 
# 1458
((this->_M_impl)._M_swap_data((__x._M_impl))); 
# 1459
::std::__alloc_on_move(_M_get_Tp_allocator(), (__x._M_get_Tp_allocator())); 
# 1460
} 
# 1465
void _M_move_assign(vector &&__x, ::std::false_type) 
# 1466
{ 
# 1467
if ((__x._M_get_Tp_allocator()) == (this->_M_get_Tp_allocator())) { 
# 1468
_M_move_assign(::std::move(__x), ::std::true_type()); } else 
# 1470
{ 
# 1473
(this->assign(::std::__make_move_if_noexcept_iterator((__x.begin())), ::std::__make_move_if_noexcept_iterator((__x.end())))); 
# 1475
(__x.clear()); 
# 1476
}  
# 1477
} 
# 1481
template< class _Up> _Up *
# 1483
_M_data_ptr(_Up *__ptr) const 
# 1484
{ return __ptr; } 
# 1486
template< class _Ptr> typename pointer_traits< _Ptr> ::element_type *
# 1488
_M_data_ptr(_Ptr __ptr) const 
# 1489
{ return (empty()) ? nullptr : ::std::__addressof(*__ptr); } 
# 1496
}; 
# 1509 "/usr/include/c++/5/bits/stl_vector.h" 3
template< class _Tp, class _Alloc> inline bool 
# 1511
operator==(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1512
{ return ((__x.size()) == (__y.size())) && std::equal((__x.begin()), (__x.end()), (__y.begin())); 
# 1513
} 
# 1526 "/usr/include/c++/5/bits/stl_vector.h" 3
template< class _Tp, class _Alloc> inline bool 
# 1528
operator<(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1529
{ return std::lexicographical_compare((__x.begin()), (__x.end()), (__y.begin()), (__y.end())); 
# 1530
} 
# 1533
template< class _Tp, class _Alloc> inline bool 
# 1535
operator!=(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1536
{ return !(__x == __y); } 
# 1539
template< class _Tp, class _Alloc> inline bool 
# 1541
operator>(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1542
{ return __y < __x; } 
# 1545
template< class _Tp, class _Alloc> inline bool 
# 1547
operator<=(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1548
{ return !(__y < __x); } 
# 1551
template< class _Tp, class _Alloc> inline bool 
# 1553
operator>=(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1554
{ return !(__x < __y); } 
# 1557
template< class _Tp, class _Alloc> inline void 
# 1559
swap(vector< _Tp, _Alloc>  &__x, vector< _Tp, _Alloc>  &__y) 
# 1560
{ (__x.swap(__y)); } 
# 1563
}
# 63 "/usr/include/c++/5/bits/stl_bvector.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 67
typedef unsigned long _Bit_type; 
# 68
enum { _S_word_bit = 64}; 
# 70
struct _Bit_reference { 
# 72
_Bit_type *_M_p; 
# 73
_Bit_type _M_mask; 
# 75
_Bit_reference(_Bit_type *__x, _Bit_type __y) : _M_p(__x), _M_mask(__y) 
# 76
{ } 
# 78
_Bit_reference() noexcept : _M_p((0)), _M_mask((0)) { } 
# 80
operator bool() const noexcept 
# 81
{ return !(!((*(_M_p)) & (_M_mask))); } 
# 84
_Bit_reference &operator=(bool __x) noexcept 
# 85
{ 
# 86
if (__x) { 
# 87
(*(_M_p)) |= (_M_mask); } else { 
# 89
(*(_M_p)) &= (~(_M_mask)); }  
# 90
return *this; 
# 91
} 
# 94
_Bit_reference &operator=(const _Bit_reference &__x) noexcept 
# 95
{ return ((*this) = ((bool)__x)); } 
# 98
bool operator==(const _Bit_reference &__x) const 
# 99
{ return ((bool)(*this)) == ((bool)__x); } 
# 102
bool operator<(const _Bit_reference &__x) const 
# 103
{ return (!((bool)(*this))) && ((bool)__x); } 
# 106
void flip() noexcept 
# 107
{ (*(_M_p)) ^= (_M_mask); } 
# 108
}; 
# 112
inline void swap(_Bit_reference __x, _Bit_reference __y) noexcept 
# 113
{ 
# 114
bool __tmp = __x; 
# 115
(__x = __y); 
# 116
(__y = __tmp); 
# 117
} 
# 120
inline void swap(_Bit_reference __x, bool &__y) noexcept 
# 121
{ 
# 122
bool __tmp = __x; 
# 123
(__x = __y); 
# 124
__y = __tmp; 
# 125
} 
# 128
inline void swap(bool &__x, _Bit_reference __y) noexcept 
# 129
{ 
# 130
bool __tmp = __x; 
# 131
__x = __y; 
# 132
(__y = __tmp); 
# 133
} 
# 136
struct _Bit_iterator_base : public iterator< random_access_iterator_tag, bool>  { 
# 139
_Bit_type *_M_p; 
# 140
unsigned _M_offset; 
# 142
_Bit_iterator_base(_Bit_type *__x, unsigned __y) : _M_p(__x), _M_offset(__y) 
# 143
{ } 
# 146
void _M_bump_up() 
# 147
{ 
# 148
if (((_M_offset)++) == (((int)_S_word_bit) - 1)) 
# 149
{ 
# 150
(_M_offset) = (0); 
# 151
++(_M_p); 
# 152
}  
# 153
} 
# 156
void _M_bump_down() 
# 157
{ 
# 158
if (((_M_offset)--) == (0)) 
# 159
{ 
# 160
(_M_offset) = (((int)_S_word_bit) - 1); 
# 161
--(_M_p); 
# 162
}  
# 163
} 
# 166
void _M_incr(ptrdiff_t __i) 
# 167
{ 
# 168
difference_type __n = __i + (_M_offset); 
# 169
(_M_p) += (__n / ((int)_S_word_bit)); 
# 170
__n = (__n % ((int)_S_word_bit)); 
# 171
if (__n < (0)) 
# 172
{ 
# 173
__n += ((int)_S_word_bit); 
# 174
--(_M_p); 
# 175
}  
# 176
(_M_offset) = (static_cast< unsigned>(__n)); 
# 177
} 
# 180
bool operator==(const _Bit_iterator_base &__i) const 
# 181
{ return ((_M_p) == (__i._M_p)) && ((_M_offset) == (__i._M_offset)); } 
# 184
bool operator<(const _Bit_iterator_base &__i) const 
# 185
{ 
# 186
return ((_M_p) < (__i._M_p)) || (((_M_p) == (__i._M_p)) && ((_M_offset) < (__i._M_offset))); 
# 188
} 
# 191
bool operator!=(const _Bit_iterator_base &__i) const 
# 192
{ return !((*this) == __i); } 
# 195
bool operator>(const _Bit_iterator_base &__i) const 
# 196
{ return (__i < (*this)); } 
# 199
bool operator<=(const _Bit_iterator_base &__i) const 
# 200
{ return !(__i < (*this)); } 
# 203
bool operator>=(const _Bit_iterator_base &__i) const 
# 204
{ return !((*this) < __i); } 
# 205
}; 
# 208
inline ptrdiff_t operator-(const _Bit_iterator_base &__x, const _Bit_iterator_base &__y) 
# 209
{ 
# 210
return ((((int)_S_word_bit) * ((__x._M_p) - (__y._M_p))) + (__x._M_offset)) - (__y._M_offset); 
# 212
} 
# 214
struct _Bit_iterator : public _Bit_iterator_base { 
# 216
typedef _Bit_reference reference; 
# 217
typedef _Bit_reference *pointer; 
# 218
typedef _Bit_iterator iterator; 
# 220
_Bit_iterator() : _Bit_iterator_base(0, 0) { } 
# 222
_Bit_iterator(_Bit_type *__x, unsigned __y) : _Bit_iterator_base(__x, __y) 
# 223
{ } 
# 226
iterator _M_const_cast() const 
# 227
{ return *this; } 
# 230
reference operator*() const 
# 231
{ return reference(_M_p, 1UL << (_M_offset)); } 
# 234
iterator &operator++() 
# 235
{ 
# 236
this->_M_bump_up(); 
# 237
return *this; 
# 238
} 
# 241
iterator operator++(int) 
# 242
{ 
# 243
iterator __tmp = *this; 
# 244
this->_M_bump_up(); 
# 245
return __tmp; 
# 246
} 
# 249
iterator &operator--() 
# 250
{ 
# 251
this->_M_bump_down(); 
# 252
return *this; 
# 253
} 
# 256
iterator operator--(int) 
# 257
{ 
# 258
iterator __tmp = *this; 
# 259
this->_M_bump_down(); 
# 260
return __tmp; 
# 261
} 
# 264
iterator &operator+=(difference_type __i) 
# 265
{ 
# 266
this->_M_incr(__i); 
# 267
return *this; 
# 268
} 
# 271
iterator &operator-=(difference_type __i) 
# 272
{ 
# 273
((*this) += (-__i)); 
# 274
return *this; 
# 275
} 
# 278
iterator operator+(difference_type __i) const 
# 279
{ 
# 280
iterator __tmp = *this; 
# 281
return (__tmp += __i); 
# 282
} 
# 285
iterator operator-(difference_type __i) const 
# 286
{ 
# 287
iterator __tmp = *this; 
# 288
return (__tmp -= __i); 
# 289
} 
# 292
reference operator[](difference_type __i) const 
# 293
{ return (*(((*this) + __i))); } 
# 294
}; 
# 297
inline _Bit_iterator operator+(ptrdiff_t __n, const _Bit_iterator &__x) 
# 298
{ return (__x + __n); } 
# 300
struct _Bit_const_iterator : public _Bit_iterator_base { 
# 302
typedef bool reference; 
# 303
typedef bool const_reference; 
# 304
typedef const bool *pointer; 
# 305
typedef _Bit_const_iterator const_iterator; 
# 307
_Bit_const_iterator() : _Bit_iterator_base(0, 0) { } 
# 309
_Bit_const_iterator(_Bit_type *__x, unsigned __y) : _Bit_iterator_base(__x, __y) 
# 310
{ } 
# 312
_Bit_const_iterator(const _Bit_iterator &__x) : _Bit_iterator_base(__x._M_p, __x._M_offset) 
# 313
{ } 
# 316
_Bit_iterator _M_const_cast() const 
# 317
{ return _Bit_iterator(_M_p, _M_offset); } 
# 320
const_reference operator*() const 
# 321
{ return _Bit_reference(_M_p, 1UL << (_M_offset)); } 
# 324
const_iterator &operator++() 
# 325
{ 
# 326
this->_M_bump_up(); 
# 327
return *this; 
# 328
} 
# 331
const_iterator operator++(int) 
# 332
{ 
# 333
const_iterator __tmp = *this; 
# 334
this->_M_bump_up(); 
# 335
return __tmp; 
# 336
} 
# 339
const_iterator &operator--() 
# 340
{ 
# 341
this->_M_bump_down(); 
# 342
return *this; 
# 343
} 
# 346
const_iterator operator--(int) 
# 347
{ 
# 348
const_iterator __tmp = *this; 
# 349
this->_M_bump_down(); 
# 350
return __tmp; 
# 351
} 
# 354
const_iterator &operator+=(difference_type __i) 
# 355
{ 
# 356
this->_M_incr(__i); 
# 357
return *this; 
# 358
} 
# 361
const_iterator &operator-=(difference_type __i) 
# 362
{ 
# 363
((*this) += (-__i)); 
# 364
return *this; 
# 365
} 
# 368
const_iterator operator+(difference_type __i) const 
# 369
{ 
# 370
const_iterator __tmp = *this; 
# 371
return (__tmp += __i); 
# 372
} 
# 375
const_iterator operator-(difference_type __i) const 
# 376
{ 
# 377
const_iterator __tmp = *this; 
# 378
return (__tmp -= __i); 
# 379
} 
# 382
const_reference operator[](difference_type __i) const 
# 383
{ return (*(((*this) + __i))); } 
# 384
}; 
# 387
inline _Bit_const_iterator operator+(ptrdiff_t __n, const _Bit_const_iterator &__x) 
# 388
{ return (__x + __n); } 
# 391
inline void __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x) 
# 392
{ 
# 393
for (; (__first != __last); (++__first)) { 
# 394
(((*__first)) = __x); }  
# 395
} 
# 398
inline void fill(_Bit_iterator __first, _Bit_iterator __last, const bool &__x) 
# 399
{ 
# 400
if ((__first._M_p) != (__last._M_p)) 
# 401
{ 
# 402
std::fill((__first._M_p) + 1, __last._M_p, __x ? ~0 : 0); 
# 403
__fill_bvector(__first, _Bit_iterator((__first._M_p) + 1, 0), __x); 
# 404
__fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x); 
# 405
} else { 
# 407
__fill_bvector(__first, __last, __x); }  
# 408
} 
# 410
template< class _Alloc> 
# 411
struct _Bvector_base { 
# 414
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< unsigned long> ::other _Bit_alloc_type; 
# 416
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< unsigned long> ::other>  _Bit_alloc_traits; 
# 417
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< unsigned long> ::other> ::pointer _Bit_pointer; 
# 419
struct _Bvector_impl : public _Bit_alloc_type { 
# 422
::std::_Bit_iterator _M_start; 
# 423
::std::_Bit_iterator _M_finish; 
# 424
typename ::std::_Bvector_base< _Alloc> ::_Bit_pointer _M_end_of_storage; 
# 426
_Bvector_impl() : ::std::_Bvector_base< _Alloc> ::_Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage() 
# 428
{ } 
# 430
_Bvector_impl(const typename ::std::_Bvector_base< _Alloc> ::_Bit_alloc_type &__a) : ::std::_Bvector_base< _Alloc> ::_Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage() 
# 432
{ } 
# 435
_Bvector_impl(typename ::std::_Bvector_base< _Alloc> ::_Bit_alloc_type &&__a) : ::std::_Bvector_base< _Alloc> ::_Bit_alloc_type(::std::move(__a)), _M_start(), _M_finish(), _M_end_of_storage() 
# 438
{ } 
# 442
::std::_Bit_type *_M_end_addr() const noexcept 
# 443
{ 
# 444
if (_M_end_of_storage) { 
# 445
return ::std::__addressof((_M_end_of_storage)[-1]) + 1; }  
# 446
return 0; 
# 447
} 
# 448
}; 
# 451
typedef _Alloc allocator_type; 
# 454
_Bit_alloc_type &_M_get_Bit_allocator() noexcept 
# 455
{ return *(static_cast< _Bit_alloc_type *>(&(this->_M_impl))); } 
# 458
const _Bit_alloc_type &_M_get_Bit_allocator() const noexcept 
# 459
{ return *(static_cast< const _Bit_alloc_type *>(&(this->_M_impl))); } 
# 462
allocator_type get_allocator() const noexcept 
# 463
{ return (allocator_type)this->_M_get_Bit_allocator(); } 
# 465
_Bvector_base() : _M_impl() 
# 466
{ } 
# 468
_Bvector_base(const allocator_type &__a) : _M_impl(__a) 
# 469
{ } 
# 472
_Bvector_base(_Bvector_base &&__x) noexcept : _M_impl(std::move((__x._M_get_Bit_allocator()))) 
# 474
{ 
# 475
((this->_M_impl)._M_start) = ((__x._M_impl)._M_start); 
# 476
((this->_M_impl)._M_finish) = ((__x._M_impl)._M_finish); 
# 477
((this->_M_impl)._M_end_of_storage) = ((__x._M_impl)._M_end_of_storage); 
# 478
((__x._M_impl)._M_start) = _Bit_iterator(); 
# 479
((__x._M_impl)._M_finish) = _Bit_iterator(); 
# 480
((__x._M_impl)._M_end_of_storage) = nullptr; 
# 481
} 
# 484
~_Bvector_base() 
# 485
{ this->_M_deallocate(); } 
# 488
protected: _Bvector_impl _M_impl; 
# 491
_Bit_pointer _M_allocate(size_t __n) 
# 492
{ return _Bit_alloc_traits::allocate(_M_impl, (_S_nword)(__n)); } 
# 495
void _M_deallocate() 
# 496
{ 
# 497
if (((_M_impl)._M_start)._M_p) 
# 498
{ 
# 499
const size_t __n = ((_M_impl)._M_end_addr()) - (((_M_impl)._M_start)._M_p); 
# 500
_Bit_alloc_traits::deallocate(_M_impl, ((_M_impl)._M_end_of_storage) - __n, __n); 
# 503
}  
# 504
} 
# 507
static size_t _S_nword(size_t __n) 
# 508
{ return ((__n + ((int)_S_word_bit)) - (1)) / ((int)_S_word_bit); } 
# 509
}; 
# 512
}
# 517
namespace std __attribute((__visibility__("default"))) { 
# 540 "/usr/include/c++/5/bits/stl_bvector.h" 3
template< class _Alloc> 
# 541
class vector< bool, _Alloc>  : protected _Bvector_base< _Alloc>  { 
# 543
typedef ::std::_Bvector_base< _Alloc>  _Base; 
# 544
typedef typename ::std::_Bvector_base< _Alloc> ::_Bit_pointer _Bit_pointer; 
# 545
typedef typename ::std::_Bvector_base< _Alloc> ::_Bit_alloc_traits _Bit_alloc_traits; 
# 548
template< class > friend struct hash; 
# 552
public: typedef bool value_type; 
# 553
typedef ::std::size_t size_type; 
# 554
typedef ::std::ptrdiff_t difference_type; 
# 555
typedef ::std::_Bit_reference reference; 
# 556
typedef bool const_reference; 
# 557
typedef ::std::_Bit_reference *pointer; 
# 558
typedef const bool *const_pointer; 
# 559
typedef ::std::_Bit_iterator iterator; 
# 560
typedef ::std::_Bit_const_iterator const_iterator; 
# 561
typedef ::std::reverse_iterator< ::std::_Bit_const_iterator>  const_reverse_iterator; 
# 562
typedef ::std::reverse_iterator< ::std::_Bit_iterator>  reverse_iterator; 
# 563
typedef _Alloc allocator_type; 
# 565
allocator_type get_allocator() const 
# 566
{ return _Base::get_allocator(); } 
# 569
protected: using ::std::_Bvector_base< _Alloc> ::_M_allocate;
# 570
using ::std::_Bvector_base< _Alloc> ::_M_deallocate;
# 571
using ::std::_Bvector_base< _Alloc> ::_S_nword;
# 572
using ::std::_Bvector_base< _Alloc> ::_M_get_Bit_allocator;
# 575
public: vector() noexcept(is_nothrow_default_constructible< _Alloc> ::value) : _Base() 
# 579
{ } 
# 582
explicit vector(const allocator_type &__a) : _Base(__a) 
# 583
{ } 
# 587
explicit vector(size_type __n, const allocator_type &__a = allocator_type()) : vector(__n, false, __a) 
# 589
{ } 
# 591
vector(size_type __n, const bool &__value, const allocator_type &
# 592
__a = allocator_type()) : _Base(__a) 
# 594
{ 
# 595
_M_initialize(__n); 
# 596
::std::fill((((this->_M_impl)._M_start)._M_p), ((this->_M_impl)._M_end_addr()), __value ? ~0 : 0); 
# 598
} 
# 611 "/usr/include/c++/5/bits/stl_bvector.h" 3
vector(const ::std::vector< bool, _Alloc>  &__x) : _Base(_Bit_alloc_traits::_S_select_on_copy((__x._M_get_Bit_allocator()))) 
# 613
{ 
# 614
_M_initialize((__x.size())); 
# 615
_M_copy_aligned((__x.begin()), (__x.end()), ((this->_M_impl)._M_start)); 
# 616
} 
# 619
vector(::std::vector< bool, _Alloc>  &&__x) noexcept : _Base(::std::move(__x)) 
# 620
{ } 
# 622
vector(::std::vector< bool, _Alloc>  &&__x, const allocator_type &__a) noexcept(_Bit_alloc_traits::_S_always_equal()) : _Base(__a) 
# 625
{ 
# 626
if ((__x.get_allocator()) == __a) 
# 627
{ 
# 628
((this->_M_impl)._M_start) = ((__x._M_impl)._M_start); 
# 629
((this->_M_impl)._M_finish) = ((__x._M_impl)._M_finish); 
# 630
((this->_M_impl)._M_end_of_storage) = ((__x._M_impl)._M_end_of_storage); 
# 631
((__x._M_impl)._M_start) = ::std::_Bit_iterator(); 
# 632
((__x._M_impl)._M_finish) = ::std::_Bit_iterator(); 
# 633
((__x._M_impl)._M_end_of_storage) = nullptr; 
# 634
} else 
# 636
{ 
# 637
_M_initialize((__x.size())); 
# 638
_M_copy_aligned((__x.begin()), (__x.end()), this->begin()); 
# 639
(__x.clear()); 
# 640
}  
# 641
} 
# 643
vector(const ::std::vector< bool, _Alloc>  &__x, const allocator_type &__a) : _Base(__a) 
# 645
{ 
# 646
_M_initialize((__x.size())); 
# 647
_M_copy_aligned((__x.begin()), (__x.end()), ((this->_M_impl)._M_start)); 
# 648
} 
# 650
vector(::std::initializer_list< bool>  __l, const allocator_type &
# 651
__a = allocator_type()) : _Base(__a) 
# 653
{ 
# 654
_M_initialize_range(__l.begin(), __l.end(), ::std::random_access_iterator_tag()); 
# 656
} 
# 660
template< class _InputIterator, class 
# 661
 = ::std::_RequireInputIter< _InputIterator> > 
# 662
vector(_InputIterator __first, _InputIterator __last, const allocator_type &
# 663
__a = allocator_type()) : _Base(__a) 
# 665
{ _M_initialize_dispatch(__first, __last, ::std::__false_type()); } 
# 677 "/usr/include/c++/5/bits/stl_bvector.h" 3
~vector() noexcept { } 
# 680
::std::vector< bool, _Alloc>  &operator=(const ::std::vector< bool, _Alloc>  &__x) 
# 681
{ 
# 682
if ((&__x) == this) { 
# 683
return *this; }  
# 685
if (_Bit_alloc_traits::_S_propagate_on_copy_assign()) 
# 686
{ 
# 687
if ((this->_M_get_Bit_allocator()) != (__x._M_get_Bit_allocator())) 
# 688
{ 
# 689
(this->_M_deallocate()); 
# 690
::std::__alloc_on_copy(_M_get_Bit_allocator(), (__x._M_get_Bit_allocator())); 
# 692
_M_initialize((__x.size())); 
# 693
} else { 
# 695
::std::__alloc_on_copy(_M_get_Bit_allocator(), (__x._M_get_Bit_allocator())); }  
# 697
}  
# 699
if ((__x.size()) > capacity()) 
# 700
{ 
# 701
(this->_M_deallocate()); 
# 702
_M_initialize((__x.size())); 
# 703
}  
# 704
((this->_M_impl)._M_finish) = _M_copy_aligned((__x.begin()), (__x.end()), this->begin()); 
# 706
return *this; 
# 707
} 
# 711
::std::vector< bool, _Alloc>  &operator=(::std::vector< bool, _Alloc>  &&__x) noexcept(_Bit_alloc_traits::_S_nothrow_move()) 
# 712
{ 
# 713
if (_Bit_alloc_traits::_S_propagate_on_move_assign() || ((this->_M_get_Bit_allocator()) == (__x._M_get_Bit_allocator()))) 
# 715
{ 
# 716
(this->_M_deallocate()); 
# 717
((this->_M_impl)._M_start) = ((__x._M_impl)._M_start); 
# 718
((this->_M_impl)._M_finish) = ((__x._M_impl)._M_finish); 
# 719
((this->_M_impl)._M_end_of_storage) = ((__x._M_impl)._M_end_of_storage); 
# 720
((__x._M_impl)._M_start) = ::std::_Bit_iterator(); 
# 721
((__x._M_impl)._M_finish) = ::std::_Bit_iterator(); 
# 722
((__x._M_impl)._M_end_of_storage) = nullptr; 
# 723
::std::__alloc_on_move(_M_get_Bit_allocator(), (__x._M_get_Bit_allocator())); 
# 725
} else 
# 727
{ 
# 728
if ((__x.size()) > capacity()) 
# 729
{ 
# 730
(this->_M_deallocate()); 
# 731
_M_initialize((__x.size())); 
# 732
}  
# 733
((this->_M_impl)._M_finish) = _M_copy_aligned((__x.begin()), (__x.end()), this->begin()); 
# 735
(__x.clear()); 
# 736
}  
# 737
return *this; 
# 738
} 
# 741
::std::vector< bool, _Alloc>  &operator=(::std::initializer_list< bool>  __l) 
# 742
{ 
# 743
(this->assign(__l.begin(), __l.end())); 
# 744
return *this; 
# 745
} 
# 753
void assign(size_type __n, const bool &__x) 
# 754
{ _M_fill_assign(__n, __x); } 
# 757
template< class _InputIterator, class 
# 758
 = ::std::_RequireInputIter< _InputIterator> > void 
# 760
assign(_InputIterator __first, _InputIterator __last) 
# 761
{ _M_assign_dispatch(__first, __last, ::std::__false_type()); } 
# 774 "/usr/include/c++/5/bits/stl_bvector.h" 3
void assign(::std::initializer_list< bool>  __l) 
# 775
{ (this->assign(__l.begin(), __l.end())); } 
# 779
iterator begin() noexcept 
# 780
{ return ((this->_M_impl)._M_start); } 
# 783
const_iterator begin() const noexcept 
# 784
{ return ((this->_M_impl)._M_start); } 
# 787
iterator end() noexcept 
# 788
{ return ((this->_M_impl)._M_finish); } 
# 791
const_iterator end() const noexcept 
# 792
{ return ((this->_M_impl)._M_finish); } 
# 795
reverse_iterator rbegin() noexcept 
# 796
{ return ((reverse_iterator)(this->end())); } 
# 799
const_reverse_iterator rbegin() const noexcept 
# 800
{ return ((const_reverse_iterator)(this->end())); } 
# 803
reverse_iterator rend() noexcept 
# 804
{ return ((reverse_iterator)(this->begin())); } 
# 807
const_reverse_iterator rend() const noexcept 
# 808
{ return ((const_reverse_iterator)(this->begin())); } 
# 812
const_iterator cbegin() const noexcept 
# 813
{ return ((this->_M_impl)._M_start); } 
# 816
const_iterator cend() const noexcept 
# 817
{ return ((this->_M_impl)._M_finish); } 
# 820
const_reverse_iterator crbegin() const noexcept 
# 821
{ return ((const_reverse_iterator)(this->end())); } 
# 824
const_reverse_iterator crend() const noexcept 
# 825
{ return ((const_reverse_iterator)(this->begin())); } 
# 829
size_type size() const noexcept 
# 830
{ return (size_type)(((this->end()) - (this->begin()))); } 
# 833
size_type max_size() const noexcept 
# 834
{ 
# 835
const size_type __isize = ((::__gnu_cxx::__numeric_traits_integer< long> ::__max - ((int)_S_word_bit)) + (1)); 
# 838
const size_type __asize = _Bit_alloc_traits::max_size(_M_get_Bit_allocator()); 
# 840
return (__asize <= (__isize / ((int)_S_word_bit))) ? __asize * ((int)_S_word_bit) : __isize; 
# 842
} 
# 845
size_type capacity() const noexcept 
# 846
{ return (size_type)((const_iterator(((this->_M_impl)._M_end_addr()), 0) - (this->begin()))); 
# 847
} 
# 850
bool empty() const noexcept 
# 851
{ return ((this->begin()) == (this->end())); } 
# 854
reference operator[](size_type __n) 
# 855
{ 
# 856
return (*iterator((((this->_M_impl)._M_start)._M_p) + (__n / ((int)_S_word_bit)), __n % ((int)_S_word_bit))); 
# 858
} 
# 861
const_reference operator[](size_type __n) const 
# 862
{ 
# 863
return (*const_iterator((((this->_M_impl)._M_start)._M_p) + (__n / ((int)_S_word_bit)), __n % ((int)_S_word_bit))); 
# 865
} 
# 869
protected: void _M_range_check(size_type __n) const 
# 870
{ 
# 871
if (__n >= this->size()) { 
# 872
__throw_out_of_range_fmt("vector<bool>::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size()); }  
# 876
} 
# 880
public: reference at(size_type __n) 
# 881
{ _M_range_check(__n); return (*this)[__n]; } 
# 884
const_reference at(size_type __n) const 
# 885
{ _M_range_check(__n); return (*this)[__n]; } 
# 888
void reserve(size_type __n) 
# 889
{ 
# 890
if (__n > max_size()) { 
# 891
__throw_length_error("vector::reserve"); }  
# 892
if (capacity() < __n) { 
# 893
_M_reallocate(__n); }  
# 894
} 
# 897
reference front() 
# 898
{ return (*(this->begin())); } 
# 901
const_reference front() const 
# 902
{ return (*(this->begin())); } 
# 905
reference back() 
# 906
{ return (*(((this->end()) - (1)))); } 
# 909
const_reference back() const 
# 910
{ return (*(((this->end()) - (1)))); } 
# 918
void data() noexcept { } 
# 921
void push_back(bool __x) 
# 922
{ 
# 923
if ((((this->_M_impl)._M_finish)._M_p) != ((this->_M_impl)._M_end_addr())) { 
# 924
(*(((this->_M_impl)._M_finish)++)) = __x; } else { 
# 926
_M_insert_aux(this->end(), __x); }  
# 927
} 
# 930
void swap(::std::vector< bool, _Alloc>  &__x) noexcept(_Bit_alloc_traits::_S_nothrow_swap()) 
# 934
{ 
# 935
::std::swap(((this->_M_impl)._M_start), ((__x._M_impl)._M_start)); 
# 936
::std::swap(((this->_M_impl)._M_finish), ((__x._M_impl)._M_finish)); 
# 937
::std::swap(((this->_M_impl)._M_end_of_storage), ((__x._M_impl)._M_end_of_storage)); 
# 939
_Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(), (__x._M_get_Bit_allocator())); 
# 941
} 
# 945
static void swap(reference __x, reference __y) noexcept 
# 946
{ 
# 947
bool __tmp = __x; 
# 948
(__x = __y); 
# 949
(__y = __tmp); 
# 950
} 
# 954
iterator insert(const_iterator __position, const bool &__x = ((bool)0)) 
# 958
{ 
# 959
const difference_type __n = (__position - (this->begin())); 
# 960
if (((((this->_M_impl)._M_finish)._M_p) != ((this->_M_impl)._M_end_addr())) && (__position == (this->end()))) { 
# 962
(*(((this->_M_impl)._M_finish)++)) = __x; } else { 
# 964
_M_insert_aux(__position._M_const_cast(), __x); }  
# 965
return ((this->begin()) + __n); 
# 966
} 
# 969
template< class _InputIterator, class 
# 970
 = ::std::_RequireInputIter< _InputIterator> > iterator 
# 972
insert(const_iterator __position, _InputIterator 
# 973
__first, _InputIterator __last) 
# 974
{ 
# 975
difference_type __offset = __position - cbegin(); 
# 976
_M_insert_dispatch(__position._M_const_cast(), __first, __last, ::std::__false_type()); 
# 978
return ((this->begin()) + __offset); 
# 979
} 
# 993 "/usr/include/c++/5/bits/stl_bvector.h" 3
iterator insert(const_iterator __position, size_type __n, const bool &__x) 
# 994
{ 
# 995
difference_type __offset = __position - cbegin(); 
# 996
_M_fill_insert(__position._M_const_cast(), __n, __x); 
# 997
return ((this->begin()) + __offset); 
# 998
} 
# 1007
iterator insert(const_iterator __p, ::std::initializer_list< bool>  __l) 
# 1008
{ return (this->insert(__p, __l.begin(), __l.end())); } 
# 1012
void pop_back() 
# 1013
{ --((this->_M_impl)._M_finish); } 
# 1017
iterator erase(const_iterator __position) 
# 1021
{ return this->_M_erase(__position._M_const_cast()); } 
# 1025
iterator erase(const_iterator __first, const_iterator __last) 
# 1029
{ return this->_M_erase(__first._M_const_cast(), __last._M_const_cast()); } 
# 1032
void resize(size_type __new_size, bool __x = ((bool)0)) 
# 1033
{ 
# 1034
if (__new_size < size()) { 
# 1035
_M_erase_at_end(((this->begin()) + ((difference_type)__new_size))); } else { 
# 1037
insert(this->end(), __new_size - size(), __x); }  
# 1038
} 
# 1042
void shrink_to_fit() 
# 1043
{ _M_shrink_to_fit(); } 
# 1047
void flip() noexcept 
# 1048
{ 
# 1049
::std::_Bit_type *const __end = ((this->_M_impl)._M_end_addr()); 
# 1050
for (::std::_Bit_type *__p = ((((this->_M_impl)._M_start)._M_p)); __p != __end; ++__p) { 
# 1051
(*__p) = (~(*__p)); }  
# 1052
} 
# 1055
void clear() noexcept 
# 1056
{ _M_erase_at_end(this->begin()); } 
# 1059
template< class ..._Args> void 
# 1061
emplace_back(_Args &&...__args) 
# 1062
{ push_back(bool(__args...)); } 
# 1064
template< class ..._Args> iterator 
# 1066
emplace(const_iterator __pos, _Args &&...__args) 
# 1067
{ return insert(__pos, bool(__args...)); } 
# 1073
protected: iterator _M_copy_aligned(const_iterator __first, const_iterator __last, iterator 
# 1074
__result) 
# 1075
{ 
# 1076
::std::_Bit_type *__q = std::copy(__first._M_p, __last._M_p, __result._M_p); 
# 1077
return std::copy(const_iterator(__last._M_p, 0), __last, iterator(__q, 0)); 
# 1079
} 
# 1082
void _M_initialize(size_type __n) 
# 1083
{ 
# 1084
_Bit_pointer __q = (this->_M_allocate(__n)); 
# 1085
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__n)); 
# 1086
((this->_M_impl)._M_start) = iterator(::std::__addressof(*__q), 0); 
# 1087
((this->_M_impl)._M_finish) = (((this->_M_impl)._M_start) + ((difference_type)__n)); 
# 1088
} 
# 1091
void _M_reallocate(size_type __n); 
# 1095
bool _M_shrink_to_fit(); 
# 1102
template< class _Integer> void 
# 1104
_M_initialize_dispatch(_Integer __n, _Integer __x, ::std::__true_type) 
# 1105
{ 
# 1106
_M_initialize(static_cast< size_type>(__n)); 
# 1107
::std::fill((((this->_M_impl)._M_start)._M_p), ((this->_M_impl)._M_end_addr()), (__x) ? ~0 : 0); 
# 1109
} 
# 1111
template< class _InputIterator> void 
# 1113
_M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1115
{ _M_initialize_range(__first, __last, ::std::__iterator_category(__first)); 
# 1116
} 
# 1118
template< class _InputIterator> void 
# 1120
_M_initialize_range(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag) 
# 1122
{ 
# 1123
for (; __first != __last; ++__first) { 
# 1124
push_back(*__first); }  
# 1125
} 
# 1127
template< class _ForwardIterator> void 
# 1129
_M_initialize_range(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag) 
# 1131
{ 
# 1132
const size_type __n = ::std::distance(__first, __last); 
# 1133
_M_initialize(__n); 
# 1134
::std::copy(__first, __last, ((this->_M_impl)._M_start)); 
# 1135
} 
# 1139
template< class _Integer> void 
# 1141
_M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type) 
# 1142
{ _M_fill_assign(__n, __val); } 
# 1144
template< class _InputIterator> void 
# 1146
_M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1148
{ _M_assign_aux(__first, __last, ::std::__iterator_category(__first)); } 
# 1151
void _M_fill_assign(::std::size_t __n, bool __x) 
# 1152
{ 
# 1153
if (__n > size()) 
# 1154
{ 
# 1155
::std::fill((((this->_M_impl)._M_start)._M_p), ((this->_M_impl)._M_end_addr()), __x ? ~0 : 0); 
# 1157
insert(this->end(), __n - size(), __x); 
# 1158
} else 
# 1160
{ 
# 1161
_M_erase_at_end(((this->begin()) + __n)); 
# 1162
::std::fill((((this->_M_impl)._M_start)._M_p), ((this->_M_impl)._M_end_addr()), __x ? ~0 : 0); 
# 1164
}  
# 1165
} 
# 1167
template< class _InputIterator> void 
# 1169
_M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag) 
# 1171
{ 
# 1172
iterator __cur = this->begin(); 
# 1173
for (; (__first != __last) && (__cur != (this->end())); (++__cur), (++__first)) { 
# 1174
(*__cur) = (*__first); }  
# 1175
if (__first == __last) { 
# 1176
_M_erase_at_end(__cur); } else { 
# 1178
insert(this->end(), __first, __last); }  
# 1179
} 
# 1181
template< class _ForwardIterator> void 
# 1183
_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag) 
# 1185
{ 
# 1186
const size_type __len = ::std::distance(__first, __last); 
# 1187
if (__len < size()) { 
# 1188
_M_erase_at_end(::std::copy(__first, __last, this->begin())); } else 
# 1190
{ 
# 1191
_ForwardIterator __mid = __first; 
# 1192
::std::advance(__mid, size()); 
# 1193
::std::copy(__first, __mid, this->begin()); 
# 1194
insert(this->end(), __mid, __last); 
# 1195
}  
# 1196
} 
# 1202
template< class _Integer> void 
# 1204
_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, ::std::__true_type) 
# 1206
{ _M_fill_insert(__pos, __n, __x); } 
# 1208
template< class _InputIterator> void 
# 1210
_M_insert_dispatch(iterator __pos, _InputIterator 
# 1211
__first, _InputIterator __last, ::std::__false_type) 
# 1213
{ _M_insert_range(__pos, __first, __last, ::std::__iterator_category(__first)); 
# 1214
} 
# 1217
void _M_fill_insert(iterator __position, size_type __n, bool __x); 
# 1219
template< class _InputIterator> void 
# 1221
_M_insert_range(iterator __pos, _InputIterator __first, _InputIterator 
# 1222
__last, ::std::input_iterator_tag) 
# 1223
{ 
# 1224
for (; __first != __last; ++__first) 
# 1225
{ 
# 1226
__pos = insert(__pos, *__first); 
# 1227
(++__pos); 
# 1228
}  
# 1229
} 
# 1231
template< class _ForwardIterator> void _M_insert_range(iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag); 
# 1237
void _M_insert_aux(iterator __position, bool __x); 
# 1240
size_type _M_check_len(size_type __n, const char *__s) const 
# 1241
{ 
# 1242
if ((max_size() - size()) < __n) { 
# 1243
__throw_length_error(__s); }  
# 1245
const size_type __len = size() + ::std::max(size(), __n); 
# 1246
return ((__len < size()) || (__len > max_size())) ? max_size() : __len; 
# 1247
} 
# 1250
void _M_erase_at_end(iterator __pos) 
# 1251
{ ((this->_M_impl)._M_finish) = __pos; } 
# 1254
iterator _M_erase(iterator __pos); 
# 1257
iterator _M_erase(iterator __first, iterator __last); 
# 1258
}; 
# 1261
}
# 1267
namespace std __attribute((__visibility__("default"))) { 
# 1273
template< class _Alloc> 
# 1274
struct hash< vector< bool, _Alloc> >  : public __hash_base< unsigned long, vector< bool, _Alloc> >  { 
# 1278
::std::size_t operator()(const vector< bool, _Alloc>  &) const noexcept; 
# 1279
}; 
# 1282
}
# 59 "/usr/include/c++/5/bits/vector.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 63
template< class _Tp, class _Alloc> void 
# 66
vector< _Tp, _Alloc> ::reserve(size_type __n) 
# 67
{ 
# 68
if (__n > this->max_size()) { 
# 69
__throw_length_error("vector::reserve"); }  
# 70
if (this->capacity() < __n) 
# 71
{ 
# 72
const size_type __old_size = size(); 
# 73
pointer __tmp = _M_allocate_and_copy(__n, ::std::__make_move_if_noexcept_iterator(((this->_M_impl)._M_start)), ::std::__make_move_if_noexcept_iterator(((this->_M_impl)._M_finish))); 
# 76
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 78
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 81
((this->_M_impl)._M_start) = __tmp; 
# 82
((this->_M_impl)._M_finish) = (__tmp + __old_size); 
# 83
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __n); 
# 84
}  
# 85
} 
# 88
template< class _Tp, class _Alloc> 
# 89
template< class ..._Args> void 
# 92
vector< _Tp, _Alloc> ::emplace_back(_Args &&...__args) 
# 93
{ 
# 94
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) 
# 95
{ 
# 96
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), ::std::forward< _Args> (__args)...); 
# 98
++((this->_M_impl)._M_finish); 
# 99
} else { 
# 101
_M_emplace_back_aux(::std::forward< _Args> (__args)...); }  
# 102
} 
# 105
template< class _Tp, class _Alloc> typename vector< _Tp, _Alloc> ::iterator 
# 109
vector< _Tp, _Alloc> ::insert(const_iterator __position, const value_type &__x) 
# 113
{ 
# 114
const size_type __n = __position - this->begin(); 
# 115
if ((((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) && (__position == this->end())) 
# 117
{ 
# 118
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), __x); 
# 119
++((this->_M_impl)._M_finish); 
# 120
} else 
# 122
{ 
# 124
const auto __pos = this->begin() + (__position - cbegin()); 
# 125
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) 
# 126
{ 
# 127
_Tp __x_copy = __x; 
# 128
_M_insert_aux(__pos, ::std::move(__x_copy)); 
# 129
} else { 
# 131
_M_insert_aux(__pos, __x); }  
# 135
}  
# 136
return ((iterator)(((this->_M_impl)._M_start) + __n)); 
# 137
} 
# 139
template< class _Tp, class _Alloc> typename vector< _Tp, _Alloc> ::iterator 
# 142
vector< _Tp, _Alloc> ::_M_erase(iterator __position) 
# 143
{ 
# 144
if ((__position + 1) != this->end()) { 
# 145
::std::move(__position + 1, this->end(), __position); }  
# 146
--((this->_M_impl)._M_finish); 
# 147
_Alloc_traits::destroy((this->_M_impl), ((this->_M_impl)._M_finish)); 
# 148
return __position; 
# 149
} 
# 151
template< class _Tp, class _Alloc> typename vector< _Tp, _Alloc> ::iterator 
# 154
vector< _Tp, _Alloc> ::_M_erase(iterator __first, iterator __last) 
# 155
{ 
# 156
if (__first != __last) 
# 157
{ 
# 158
if (__last != this->end()) { 
# 159
::std::move(__last, this->end(), __first); }  
# 160
_M_erase_at_end((__first.base()) + (this->end() - __last)); 
# 161
}  
# 162
return __first; 
# 163
} 
# 165
template< class _Tp, class _Alloc> vector< _Tp, _Alloc>  &
# 168
vector< _Tp, _Alloc> ::operator=(const vector &__x) 
# 169
{ 
# 170
if ((&__x) != this) 
# 171
{ 
# 173
if (_Alloc_traits::_S_propagate_on_copy_assign()) 
# 174
{ 
# 175
if ((!_Alloc_traits::_S_always_equal()) && (_M_get_Tp_allocator() != (__x._M_get_Tp_allocator()))) 
# 177
{ 
# 179
this->clear(); 
# 180
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 183
((this->_M_impl)._M_start) = nullptr; 
# 184
((this->_M_impl)._M_finish) = nullptr; 
# 185
((this->_M_impl)._M_end_of_storage) = nullptr; 
# 186
}  
# 187
::std::__alloc_on_copy(_M_get_Tp_allocator(), (__x._M_get_Tp_allocator())); 
# 189
}  
# 191
const size_type __xlen = (__x.size()); 
# 192
if (__xlen > capacity()) 
# 193
{ 
# 194
pointer __tmp = _M_allocate_and_copy(__xlen, (__x.begin()), (__x.end())); 
# 196
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 198
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 201
((this->_M_impl)._M_start) = __tmp; 
# 202
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __xlen); 
# 203
} else { 
# 204
if (size() >= __xlen) 
# 205
{ 
# 206
::std::_Destroy(::std::copy((__x.begin()), (__x.end()), this->begin()), this->end(), _M_get_Tp_allocator()); 
# 208
} else 
# 210
{ 
# 211
::std::copy(((__x._M_impl)._M_start), ((__x._M_impl)._M_start) + size(), ((this->_M_impl)._M_start)); 
# 213
::std::__uninitialized_copy_a(((__x._M_impl)._M_start) + size(), ((__x._M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 217
}  }  
# 218
((this->_M_impl)._M_finish) = (((this->_M_impl)._M_start) + __xlen); 
# 219
}  
# 220
return *this; 
# 221
} 
# 223
template< class _Tp, class _Alloc> void 
# 226
vector< _Tp, _Alloc> ::_M_fill_assign(::std::size_t __n, const value_type &__val) 
# 227
{ 
# 228
if (__n > capacity()) 
# 229
{ 
# 230
vector __tmp(__n, __val, _M_get_Tp_allocator()); 
# 231
((__tmp._M_impl)._M_swap_data((this->_M_impl))); 
# 232
} else { 
# 233
if (__n > size()) 
# 234
{ 
# 235
::std::fill(this->begin(), this->end(), __val); 
# 236
((this->_M_impl)._M_finish) = ::std::__uninitialized_fill_n_a(((this->_M_impl)._M_finish), __n - size(), __val, _M_get_Tp_allocator()); 
# 240
} else { 
# 242
_M_erase_at_end(::std::fill_n(((this->_M_impl)._M_start), __n, __val)); }  }  
# 243
} 
# 245
template< class _Tp, class _Alloc> 
# 246
template< class _InputIterator> void 
# 249
vector< _Tp, _Alloc> ::_M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag) 
# 251
{ 
# 252
pointer __cur(((this->_M_impl)._M_start)); 
# 253
for (; (__first != __last) && (__cur != ((this->_M_impl)._M_finish)); (++__cur), (++__first)) { 
# 255
(*__cur) = (*__first); }  
# 256
if (__first == __last) { 
# 257
_M_erase_at_end(__cur); } else { 
# 259
insert(this->end(), __first, __last); }  
# 260
} 
# 262
template< class _Tp, class _Alloc> 
# 263
template< class _ForwardIterator> void 
# 266
vector< _Tp, _Alloc> ::_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag) 
# 268
{ 
# 269
const size_type __len = ::std::distance(__first, __last); 
# 271
if (__len > capacity()) 
# 272
{ 
# 273
pointer __tmp(_M_allocate_and_copy(__len, __first, __last)); 
# 274
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 276
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 279
((this->_M_impl)._M_start) = __tmp; 
# 280
((this->_M_impl)._M_finish) = (((this->_M_impl)._M_start) + __len); 
# 281
((this->_M_impl)._M_end_of_storage) = ((this->_M_impl)._M_finish); 
# 282
} else { 
# 283
if (size() >= __len) { 
# 284
_M_erase_at_end(::std::copy(__first, __last, ((this->_M_impl)._M_start))); } else 
# 286
{ 
# 287
_ForwardIterator __mid = __first; 
# 288
::std::advance(__mid, size()); 
# 289
::std::copy(__first, __mid, ((this->_M_impl)._M_start)); 
# 290
((this->_M_impl)._M_finish) = ::std::__uninitialized_copy_a(__mid, __last, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 294
}  }  
# 295
} 
# 298
template< class _Tp, class _Alloc> 
# 299
template< class ..._Args> typename vector< _Tp, _Alloc> ::iterator 
# 302
vector< _Tp, _Alloc> ::emplace(const_iterator __position, _Args &&...__args) 
# 303
{ 
# 304
const size_type __n = __position - this->begin(); 
# 305
if ((((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) && (__position == this->end())) 
# 307
{ 
# 308
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), ::std::forward< _Args> (__args)...); 
# 310
++((this->_M_impl)._M_finish); 
# 311
} else { 
# 313
_M_insert_aux(this->begin() + (__position - cbegin()), ::std::forward< _Args> (__args)...); }  
# 315
return ((iterator)(((this->_M_impl)._M_start) + __n)); 
# 316
} 
# 318
template< class _Tp, class _Alloc> 
# 319
template< class ..._Args> void 
# 322
vector< _Tp, _Alloc> ::_M_insert_aux(iterator __position, _Args &&...__args) 
# 329
{ 
# 330
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) 
# 331
{ 
# 332
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), ::std::move(*(((this->_M_impl)._M_finish) - 1))); 
# 335
++((this->_M_impl)._M_finish); 
# 339
::std::move_backward((__position.base()), ((this->_M_impl)._M_finish) - 2, ((this->_M_impl)._M_finish) - 1); 
# 345
(*__position) = (_Tp(::std::forward< _Args> (__args)...)); 
# 347
} else 
# 349
{ 
# 350
const size_type __len = _M_check_len((size_type)1, "vector::_M_insert_aux"); 
# 352
const size_type __elems_before = __position - this->begin(); 
# 353
pointer __new_start((this->_M_allocate(__len))); 
# 354
pointer __new_finish(__new_start); 
# 355
try 
# 356
{ 
# 361
_Alloc_traits::construct((this->_M_impl), __new_start + __elems_before, ::std::forward< _Args> (__args)...); 
# 368
__new_finish = pointer(); 
# 370
__new_finish = ::std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), (__position.base()), __new_start, _M_get_Tp_allocator()); 
# 375
++__new_finish; 
# 377
__new_finish = ::std::__uninitialized_move_if_noexcept_a((__position.base()), ((this->_M_impl)._M_finish), __new_finish, _M_get_Tp_allocator()); 
# 381
} 
# 382
catch (...) 
# 383
{ 
# 384
if (!__new_finish) { 
# 385
_Alloc_traits::destroy((this->_M_impl), __new_start + __elems_before); } else { 
# 388
::std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); }  
# 389
_M_deallocate(__new_start, __len); 
# 390
throw; 
# 391
}  
# 392
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 394
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 397
((this->_M_impl)._M_start) = __new_start; 
# 398
((this->_M_impl)._M_finish) = __new_finish; 
# 399
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 400
}  
# 401
} 
# 404
template< class _Tp, class _Alloc> 
# 405
template< class ..._Args> void 
# 408
vector< _Tp, _Alloc> ::_M_emplace_back_aux(_Args &&...__args) 
# 409
{ 
# 410
const size_type __len = _M_check_len((size_type)1, "vector::_M_emplace_back_aux"); 
# 412
pointer __new_start((this->_M_allocate(__len))); 
# 413
pointer __new_finish(__new_start); 
# 414
try 
# 415
{ 
# 416
_Alloc_traits::construct((this->_M_impl), __new_start + size(), ::std::forward< _Args> (__args)...); 
# 418
__new_finish = pointer(); 
# 420
__new_finish = ::std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), __new_start, _M_get_Tp_allocator()); 
# 425
++__new_finish; 
# 426
} 
# 427
catch (...) 
# 428
{ 
# 429
if (!__new_finish) { 
# 430
_Alloc_traits::destroy((this->_M_impl), __new_start + size()); } else { 
# 432
::std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); }  
# 433
_M_deallocate(__new_start, __len); 
# 434
throw; 
# 435
}  
# 436
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 438
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 441
((this->_M_impl)._M_start) = __new_start; 
# 442
((this->_M_impl)._M_finish) = __new_finish; 
# 443
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 444
} 
# 447
template< class _Tp, class _Alloc> void 
# 450
vector< _Tp, _Alloc> ::_M_fill_insert(iterator __position, size_type __n, const value_type &__x) 
# 451
{ 
# 452
if (__n != (0)) 
# 453
{ 
# 454
if (((size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_finish))) >= __n) 
# 456
{ 
# 457
value_type __x_copy = __x; 
# 458
const size_type __elems_after = this->end() - __position; 
# 459
pointer __old_finish(((this->_M_impl)._M_finish)); 
# 460
if (__elems_after > __n) 
# 461
{ 
# 462
::std::__uninitialized_move_a(((this->_M_impl)._M_finish) - __n, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 466
((this->_M_impl)._M_finish) += __n; 
# 467
::std::move_backward((__position.base()), __old_finish - __n, __old_finish); 
# 469
::std::fill((__position.base()), (__position.base()) + __n, __x_copy); 
# 471
} else 
# 473
{ 
# 474
((this->_M_impl)._M_finish) = ::std::__uninitialized_fill_n_a(((this->_M_impl)._M_finish), __n - __elems_after, __x_copy, _M_get_Tp_allocator()); 
# 479
::std::__uninitialized_move_a((__position.base()), __old_finish, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 482
((this->_M_impl)._M_finish) += __elems_after; 
# 483
::std::fill((__position.base()), __old_finish, __x_copy); 
# 484
}  
# 485
} else 
# 487
{ 
# 488
const size_type __len = _M_check_len(__n, "vector::_M_fill_insert"); 
# 490
const size_type __elems_before = __position - this->begin(); 
# 491
pointer __new_start((this->_M_allocate(__len))); 
# 492
pointer __new_finish(__new_start); 
# 493
try 
# 494
{ 
# 496
::std::__uninitialized_fill_n_a(__new_start + __elems_before, __n, __x, _M_get_Tp_allocator()); 
# 499
__new_finish = pointer(); 
# 501
__new_finish = ::std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), (__position.base()), __new_start, _M_get_Tp_allocator()); 
# 506
__new_finish += __n; 
# 508
__new_finish = ::std::__uninitialized_move_if_noexcept_a((__position.base()), ((this->_M_impl)._M_finish), __new_finish, _M_get_Tp_allocator()); 
# 512
} 
# 513
catch (...) 
# 514
{ 
# 515
if (!__new_finish) { 
# 516
::std::_Destroy(__new_start + __elems_before, (__new_start + __elems_before) + __n, _M_get_Tp_allocator()); } else { 
# 520
::std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); }  
# 522
_M_deallocate(__new_start, __len); 
# 523
throw; 
# 524
}  
# 525
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 527
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 530
((this->_M_impl)._M_start) = __new_start; 
# 531
((this->_M_impl)._M_finish) = __new_finish; 
# 532
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 533
}  
# 534
}  
# 535
} 
# 538
template< class _Tp, class _Alloc> void 
# 541
vector< _Tp, _Alloc> ::_M_default_append(size_type __n) 
# 542
{ 
# 543
if (__n != (0)) 
# 544
{ 
# 545
if (((size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_finish))) >= __n) 
# 547
{ 
# 548
((this->_M_impl)._M_finish) = ::std::__uninitialized_default_n_a(((this->_M_impl)._M_finish), __n, _M_get_Tp_allocator()); 
# 551
} else 
# 553
{ 
# 554
const size_type __len = _M_check_len(__n, "vector::_M_default_append"); 
# 556
const size_type __old_size = this->size(); 
# 557
pointer __new_start((this->_M_allocate(__len))); 
# 558
pointer __new_finish(__new_start); 
# 559
try 
# 560
{ 
# 561
__new_finish = ::std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), __new_start, _M_get_Tp_allocator()); 
# 565
__new_finish = ::std::__uninitialized_default_n_a(__new_finish, __n, _M_get_Tp_allocator()); 
# 568
} 
# 569
catch (...) 
# 570
{ 
# 571
::std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); 
# 573
_M_deallocate(__new_start, __len); 
# 574
throw; 
# 575
}  
# 576
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 578
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 581
((this->_M_impl)._M_start) = __new_start; 
# 582
((this->_M_impl)._M_finish) = __new_finish; 
# 583
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 584
}  
# 585
}  
# 586
} 
# 588
template< class _Tp, class _Alloc> bool 
# 591
vector< _Tp, _Alloc> ::_M_shrink_to_fit() 
# 592
{ 
# 593
if (capacity() == size()) { 
# 594
return false; }  
# 595
return std::__shrink_to_fit_aux< vector> ::_S_do_it(*this); 
# 596
} 
# 599
template< class _Tp, class _Alloc> 
# 600
template< class _InputIterator> void 
# 603
vector< _Tp, _Alloc> ::_M_range_insert(iterator __pos, _InputIterator __first, _InputIterator 
# 604
__last, ::std::input_iterator_tag) 
# 605
{ 
# 606
for (; __first != __last; ++__first) 
# 607
{ 
# 608
__pos = insert(__pos, *__first); 
# 609
++__pos; 
# 610
}  
# 611
} 
# 613
template< class _Tp, class _Alloc> 
# 614
template< class _ForwardIterator> void 
# 617
vector< _Tp, _Alloc> ::_M_range_insert(iterator __position, _ForwardIterator __first, _ForwardIterator 
# 618
__last, ::std::forward_iterator_tag) 
# 619
{ 
# 620
if (__first != __last) 
# 621
{ 
# 622
const size_type __n = ::std::distance(__first, __last); 
# 623
if (((size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_finish))) >= __n) 
# 625
{ 
# 626
const size_type __elems_after = this->end() - __position; 
# 627
pointer __old_finish(((this->_M_impl)._M_finish)); 
# 628
if (__elems_after > __n) 
# 629
{ 
# 630
::std::__uninitialized_move_a(((this->_M_impl)._M_finish) - __n, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 634
((this->_M_impl)._M_finish) += __n; 
# 635
::std::move_backward((__position.base()), __old_finish - __n, __old_finish); 
# 637
::std::copy(__first, __last, __position); 
# 638
} else 
# 640
{ 
# 641
_ForwardIterator __mid = __first; 
# 642
::std::advance(__mid, __elems_after); 
# 643
::std::__uninitialized_copy_a(__mid, __last, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 646
((this->_M_impl)._M_finish) += (__n - __elems_after); 
# 647
::std::__uninitialized_move_a((__position.base()), __old_finish, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 651
((this->_M_impl)._M_finish) += __elems_after; 
# 652
::std::copy(__first, __mid, __position); 
# 653
}  
# 654
} else 
# 656
{ 
# 657
const size_type __len = _M_check_len(__n, "vector::_M_range_insert"); 
# 659
pointer __new_start((this->_M_allocate(__len))); 
# 660
pointer __new_finish(__new_start); 
# 661
try 
# 662
{ 
# 663
__new_finish = ::std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), (__position.base()), __new_start, _M_get_Tp_allocator()); 
# 667
__new_finish = ::std::__uninitialized_copy_a(__first, __last, __new_finish, _M_get_Tp_allocator()); 
# 671
__new_finish = ::std::__uninitialized_move_if_noexcept_a((__position.base()), ((this->_M_impl)._M_finish), __new_finish, _M_get_Tp_allocator()); 
# 675
} 
# 676
catch (...) 
# 677
{ 
# 678
::std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); 
# 680
_M_deallocate(__new_start, __len); 
# 681
throw; 
# 682
}  
# 683
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 685
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 688
((this->_M_impl)._M_start) = __new_start; 
# 689
((this->_M_impl)._M_finish) = __new_finish; 
# 690
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 691
}  
# 692
}  
# 693
} 
# 697
template< class _Alloc> void 
# 700
vector< bool, _Alloc> ::_M_reallocate(size_type __n) 
# 701
{ 
# 702
_Bit_pointer __q = (this->_M_allocate(__n)); 
# 703
iterator __start(::std::__addressof(*__q), 0); 
# 704
((this->_M_impl)._M_finish) = _M_copy_aligned(this->begin(), this->end(), __start); 
# 705
(this->_M_deallocate()); 
# 706
((this->_M_impl)._M_start) = __start; 
# 707
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__n)); 
# 708
} 
# 710
template< class _Alloc> void 
# 713
vector< bool, _Alloc> ::_M_fill_insert(iterator __position, size_type __n, bool __x) 
# 714
{ 
# 715
if (__n == (0)) { 
# 716
return; }  
# 717
if ((capacity() - size()) >= __n) 
# 718
{ 
# 719
::std::copy_backward(__position, this->end(), ((this->_M_impl)._M_finish) + ((difference_type)__n)); 
# 721
std::fill(__position, (__position + ((difference_type)__n)), __x); 
# 722
((this->_M_impl)._M_finish) += ((difference_type)__n); 
# 723
} else 
# 725
{ 
# 726
const size_type __len = _M_check_len(__n, "vector<bool>::_M_fill_insert"); 
# 728
_Bit_pointer __q = (this->_M_allocate(__len)); 
# 729
iterator __start(::std::__addressof(*__q), 0); 
# 730
iterator __i = _M_copy_aligned(this->begin(), __position, __start); 
# 731
std::fill(__i, (__i + ((difference_type)__n)), __x); 
# 732
((this->_M_impl)._M_finish) = ::std::copy(__position, this->end(), (__i + ((difference_type)__n))); 
# 734
(this->_M_deallocate()); 
# 735
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__len)); 
# 736
((this->_M_impl)._M_start) = __start; 
# 737
}  
# 738
} 
# 740
template< class _Alloc> 
# 741
template< class _ForwardIterator> void 
# 744
vector< bool, _Alloc> ::_M_insert_range(iterator __position, _ForwardIterator __first, _ForwardIterator 
# 745
__last, ::std::forward_iterator_tag) 
# 746
{ 
# 747
if (__first != __last) 
# 748
{ 
# 749
size_type __n = ::std::distance(__first, __last); 
# 750
if ((capacity() - size()) >= __n) 
# 751
{ 
# 752
::std::copy_backward(__position, this->end(), ((this->_M_impl)._M_finish) + ((difference_type)__n)); 
# 755
::std::copy(__first, __last, __position); 
# 756
((this->_M_impl)._M_finish) += ((difference_type)__n); 
# 757
} else 
# 759
{ 
# 760
const size_type __len = _M_check_len(__n, "vector<bool>::_M_insert_range"); 
# 762
_Bit_pointer __q = (this->_M_allocate(__len)); 
# 763
iterator __start(::std::__addressof(*__q), 0); 
# 764
iterator __i = _M_copy_aligned(this->begin(), __position, __start); 
# 765
__i = ::std::copy(__first, __last, __i); 
# 766
((this->_M_impl)._M_finish) = ::std::copy(__position, this->end(), __i); 
# 767
(this->_M_deallocate()); 
# 768
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__len)); 
# 769
((this->_M_impl)._M_start) = __start; 
# 770
}  
# 771
}  
# 772
} 
# 774
template< class _Alloc> void 
# 777
vector< bool, _Alloc> ::_M_insert_aux(iterator __position, bool __x) 
# 778
{ 
# 779
if ((((this->_M_impl)._M_finish)._M_p) != ((this->_M_impl)._M_end_addr())) 
# 780
{ 
# 781
::std::copy_backward(__position, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish) + 1); 
# 783
(((*__position)) = __x); 
# 784
++((this->_M_impl)._M_finish); 
# 785
} else 
# 787
{ 
# 788
const size_type __len = _M_check_len((size_type)1, "vector<bool>::_M_insert_aux"); 
# 790
_Bit_pointer __q = (this->_M_allocate(__len)); 
# 791
iterator __start(::std::__addressof(*__q), 0); 
# 792
iterator __i = _M_copy_aligned(this->begin(), __position, __start); 
# 793
(((*(__i++))) = __x); 
# 794
((this->_M_impl)._M_finish) = ::std::copy(__position, this->end(), __i); 
# 795
(this->_M_deallocate()); 
# 796
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__len)); 
# 797
((this->_M_impl)._M_start) = __start; 
# 798
}  
# 799
} 
# 801
template< class _Alloc> typename vector< bool, _Alloc> ::iterator 
# 804
vector< bool, _Alloc> ::_M_erase(iterator __position) 
# 805
{ 
# 806
if ((((__position + (1))) != (this->end()))) { 
# 807
::std::copy((__position + (1)), this->end(), __position); }  
# 808
--((this->_M_impl)._M_finish); 
# 809
return __position; 
# 810
} 
# 812
template< class _Alloc> typename vector< bool, _Alloc> ::iterator 
# 815
vector< bool, _Alloc> ::_M_erase(iterator __first, iterator __last) 
# 816
{ 
# 817
if ((__first != __last)) { 
# 818
_M_erase_at_end(::std::copy(__last, this->end(), __first)); }  
# 819
return __first; 
# 820
} 
# 823
template< class _Alloc> bool 
# 826
vector< bool, _Alloc> ::_M_shrink_to_fit() 
# 827
{ 
# 828
if ((capacity() - size()) < ((int)_S_word_bit)) { 
# 829
return false; }  
# 830
try 
# 831
{ 
# 832
_M_reallocate(size()); 
# 833
return true; 
# 834
} 
# 835
catch (...) 
# 836
{ return false; }  
# 837
} 
# 841
}
# 845
namespace std __attribute((__visibility__("default"))) { 
# 849
template< class _Alloc> size_t 
# 852
hash< vector< bool, _Alloc> > ::operator()(const vector< bool, _Alloc>  &__b) const noexcept 
# 853
{ 
# 854
::std::size_t __hash = (0); 
# 855
using ::std::_S_word_bit;
# 856
using ::std::_Bit_type;
# 858
const ::std::size_t __words = (__b.size()) / _S_word_bit; 
# 859
if (__words) 
# 860
{ 
# 861
const ::std::size_t __clength = (__words * sizeof(::std::_Bit_type)); 
# 862
__hash = ::std::_Hash_impl::hash((((__b._M_impl)._M_start)._M_p), __clength); 
# 863
}  
# 865
const ::std::size_t __extrabits = (__b.size()) % _S_word_bit; 
# 866
if (__extrabits) 
# 867
{ 
# 868
::std::_Bit_type __hiword = *(((__b._M_impl)._M_finish)._M_p); 
# 869
__hiword &= (~((~(static_cast< ::std::_Bit_type>(0))) << __extrabits)); 
# 871
const ::std::size_t __clength = (((__extrabits + (8)) - (1)) / (8)); 
# 873
if (__words) { 
# 874
__hash = std::_Hash_impl::hash(&__hiword, __clength, __hash); } else { 
# 876
__hash = std::_Hash_impl::hash(&__hiword, __clength); }  
# 877
}  
# 879
return __hash; 
# 880
} 
# 883
}
# 62 "/usr/include/c++/5/bits/stl_tempbuf.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 83 "/usr/include/c++/5/bits/stl_tempbuf.h" 3
template< class _Tp> pair< _Tp *, long>  
# 85
get_temporary_buffer(ptrdiff_t __len) noexcept 
# 86
{ 
# 87
const ptrdiff_t __max = (__gnu_cxx::__numeric_traits_integer< long> ::__max / sizeof(_Tp)); 
# 89
if (__len > __max) { 
# 90
__len = __max; }  
# 92
while (__len > (0)) 
# 93
{ 
# 94
_Tp *__tmp = static_cast< _Tp *>(::operator new(__len * sizeof(_Tp), std::nothrow)); 
# 96
if (__tmp != 0) { 
# 97
return pair< _Tp *, long> (__tmp, __len); }  
# 98
__len /= (2); 
# 99
}  
# 100
return pair< _Tp *, long> (static_cast< _Tp *>(0), 0); 
# 101
} 
# 110 "/usr/include/c++/5/bits/stl_tempbuf.h" 3
template< class _Tp> inline void 
# 112
return_temporary_buffer(_Tp *__p) 
# 113
{ ::operator delete(__p, std::nothrow); } 
# 121
template< class _ForwardIterator, class _Tp> 
# 122
class _Temporary_buffer { 
# 128
public: typedef _Tp value_type; 
# 129
typedef value_type *pointer; 
# 130
typedef pointer iterator; 
# 131
typedef ptrdiff_t size_type; 
# 134
protected: size_type _M_original_len; 
# 135
size_type _M_len; 
# 136
pointer _M_buffer; 
# 141
public: size_type size() const 
# 142
{ return _M_len; } 
# 146
size_type requested_size() const 
# 147
{ return _M_original_len; } 
# 151
iterator begin() 
# 152
{ return _M_buffer; } 
# 156
iterator end() 
# 157
{ return (_M_buffer) + (_M_len); } 
# 163
_Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last); 
# 165
~_Temporary_buffer() 
# 166
{ 
# 167
std::_Destroy(_M_buffer, (_M_buffer) + (_M_len)); 
# 168
std::return_temporary_buffer(_M_buffer); 
# 169
} 
# 173
private: _Temporary_buffer(const _Temporary_buffer &); 
# 176
void operator=(const _Temporary_buffer &); 
# 177
}; 
# 180
template< bool > 
# 181
struct __uninitialized_construct_buf_dispatch { 
# 183
template< class _Pointer, class _ForwardIterator> static void 
# 185
__ucr(_Pointer __first, _Pointer __last, _ForwardIterator 
# 186
__seed) 
# 187
{ 
# 188
if (__first == __last) { 
# 189
return; }  
# 191
_Pointer __cur = __first; 
# 192
try 
# 193
{ 
# 194
std::_Construct(std::__addressof(*__first), std::move(*__seed)); 
# 196
_Pointer __prev = __cur; 
# 197
++__cur; 
# 198
for (; __cur != __last; (++__cur), (++__prev)) { 
# 199
std::_Construct(std::__addressof(*__cur), std::move(*__prev)); }  
# 201
(*__seed) = std::move(*__prev); 
# 202
} 
# 203
catch (...) 
# 204
{ 
# 205
std::_Destroy(__first, __cur); 
# 206
throw; 
# 207
}  
# 208
} 
# 209
}; 
# 212
template<> struct __uninitialized_construct_buf_dispatch< true>  { 
# 214
template< class _Pointer, class _ForwardIterator> static void 
# 216
__ucr(_Pointer, _Pointer, _ForwardIterator) { } 
# 217
}; 
# 229 "/usr/include/c++/5/bits/stl_tempbuf.h" 3
template< class _Pointer, class _ForwardIterator> inline void 
# 231
__uninitialized_construct_buf(_Pointer __first, _Pointer __last, _ForwardIterator 
# 232
__seed) 
# 233
{ 
# 235
typedef typename iterator_traits< _Pointer> ::value_type _ValueType; 
# 237
std::__uninitialized_construct_buf_dispatch< __has_trivial_constructor(typename iterator_traits< _Pointer> ::value_type)> ::__ucr(__first, __last, __seed); 
# 240
} 
# 242
template< class _ForwardIterator, class _Tp> 
# 244
_Temporary_buffer< _ForwardIterator, _Tp> ::_Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) : _M_original_len(std::distance(__first, __last)), _M_len((0)), _M_buffer((0)) 
# 247
{ 
# 248
try 
# 249
{ 
# 250
pair< _Tp *, long>  __p(std::get_temporary_buffer< value_type> (_M_original_len)); 
# 252
(_M_buffer) = (__p.first); 
# 253
(_M_len) = (__p.second); 
# 254
if (_M_buffer) { 
# 255
std::__uninitialized_construct_buf(_M_buffer, (_M_buffer) + (_M_len), __first); }  
# 257
} 
# 258
catch (...) 
# 259
{ 
# 260
std::return_temporary_buffer(_M_buffer); 
# 261
(_M_buffer) = 0; 
# 262
(_M_len) = (0); 
# 263
throw; 
# 264
}  
# 265
} 
# 268
}
# 59 "/usr/include/c++/5/bits/stl_raw_storage_iter.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 67
template< class _OutputIterator, class _Tp> 
# 68
class raw_storage_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 72
protected: _OutputIterator _M_iter; 
# 76
public: explicit raw_storage_iterator(_OutputIterator __x) : _M_iter(__x) 
# 77
{ } 
# 80
raw_storage_iterator &operator*() { return *this; } 
# 83
raw_storage_iterator &operator=(const _Tp &__element) 
# 84
{ 
# 85
std::_Construct(std::__addressof(*(_M_iter)), __element); 
# 86
return *this; 
# 87
} 
# 90
raw_storage_iterator &operator++() 
# 91
{ 
# 92
++(_M_iter); 
# 93
return *this; 
# 94
} 
# 97
raw_storage_iterator operator++(int) 
# 98
{ 
# 99
raw_storage_iterator __tmp = *this; 
# 100
++(_M_iter); 
# 101
return __tmp; 
# 102
} 
# 103
}; 
# 106
}
# 39 "/usr/include/c++/5/typeinfo" 3
#pragma GCC visibility push ( default )
# 41
extern "C++" {
# 43
namespace __cxxabiv1 { 
# 45
class __class_type_info; 
# 46
}
# 80 "/usr/include/c++/5/typeinfo" 3
namespace std { 
# 88
class type_info { 
# 95
public: virtual ~type_info(); 
# 99
const char *name() const noexcept 
# 100
{ return (((__name)[0]) == ('*')) ? (__name) + 1 : (__name); } 
# 115 "/usr/include/c++/5/typeinfo" 3
bool before(const type_info &__arg) const noexcept 
# 116
{ return ((((__name)[0]) == ('*')) && (((__arg.__name)[0]) == ('*'))) ? (__name) < (__arg.__name) : (__builtin_strcmp(__name, __arg.__name) < 0); 
# 118
} 
# 120
bool operator==(const type_info &__arg) const noexcept 
# 121
{ 
# 122
return ((__name) == (__arg.__name)) || ((((__name)[0]) != ('*')) && (__builtin_strcmp(__name, __arg.__name) == 0)); 
# 125
} 
# 136 "/usr/include/c++/5/typeinfo" 3
bool operator!=(const type_info &__arg) const noexcept 
# 137
{ return !this->operator==(__arg); } 
# 140
size_t hash_code() const noexcept 
# 141
{ 
# 143
return _Hash_bytes(this->name(), __builtin_strlen(this->name()), static_cast< size_t>(3339675911UL)); 
# 148
} 
# 152
virtual bool __is_pointer_p() const; 
# 155
virtual bool __is_function_p() const; 
# 163
virtual bool __do_catch(const type_info * __thr_type, void ** __thr_obj, unsigned __outer) const; 
# 167
virtual bool __do_upcast(const __cxxabiv1::__class_type_info * __target, void ** __obj_ptr) const; 
# 171
protected: const char *__name; 
# 173
explicit type_info(const char *__n) : __name(__n) { } 
# 177
private: type_info &operator=(const type_info &); 
# 178
type_info(const type_info &); 
# 179
}; 
# 187
class bad_cast : public exception { 
# 190
public: bad_cast() noexcept { } 
# 194
virtual ~bad_cast() noexcept; 
# 197
virtual const char *what() const noexcept; 
# 198
}; 
# 204
class bad_typeid : public exception { 
# 207
public: bad_typeid() noexcept { } 
# 211
virtual ~bad_typeid() noexcept; 
# 214
virtual const char *what() const noexcept; 
# 215
}; 
# 216
}
# 218
}
# 220
#pragma GCC visibility pop
# 40 "/usr/include/c++/5/ext/concurrence.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 49
enum _Lock_policy { _S_single, _S_mutex, _S_atomic}; 
# 53
static const _Lock_policy __default_lock_policy = _S_atomic; 
# 67 "/usr/include/c++/5/ext/concurrence.h" 3
class __concurrence_lock_error : public std::exception { 
# 71
public: virtual const char *what() const throw() 
# 72
{ return "__gnu_cxx::__concurrence_lock_error"; } 
# 73
}; 
# 75
class __concurrence_unlock_error : public std::exception { 
# 79
public: virtual const char *what() const throw() 
# 80
{ return "__gnu_cxx::__concurrence_unlock_error"; } 
# 81
}; 
# 83
class __concurrence_broadcast_error : public std::exception { 
# 87
public: virtual const char *what() const throw() 
# 88
{ return "__gnu_cxx::__concurrence_broadcast_error"; } 
# 89
}; 
# 91
class __concurrence_wait_error : public std::exception { 
# 95
public: virtual const char *what() const throw() 
# 96
{ return "__gnu_cxx::__concurrence_wait_error"; } 
# 97
}; 
# 101
inline void __throw_concurrence_lock_error() 
# 102
{ throw __concurrence_lock_error(); } 
# 105
inline void __throw_concurrence_unlock_error() 
# 106
{ throw __concurrence_unlock_error(); } 
# 110
inline void __throw_concurrence_broadcast_error() 
# 111
{ throw __concurrence_broadcast_error(); } 
# 114
inline void __throw_concurrence_wait_error() 
# 115
{ throw __concurrence_wait_error(); } 
# 118
class __mutex { 
# 122
__gthread_mutex_t _M_mutex = {{0, (0), 0, (0), 0, 0, {(0), (0)}}}; 
# 127
__mutex(const __mutex &); 
# 128
__mutex &operator=(const __mutex &); 
# 131
public: __mutex() 
# 132
{ 
# 137
} 
# 147 "/usr/include/c++/5/ext/concurrence.h" 3
void lock() 
# 148
{ 
# 150
if (__gthread_active_p()) 
# 151
{ 
# 152
if (__gthread_mutex_lock(&(_M_mutex)) != 0) { 
# 153
__throw_concurrence_lock_error(); }  
# 154
}  
# 156
} 
# 158
void unlock() 
# 159
{ 
# 161
if (__gthread_active_p()) 
# 162
{ 
# 163
if (__gthread_mutex_unlock(&(_M_mutex)) != 0) { 
# 164
__throw_concurrence_unlock_error(); }  
# 165
}  
# 167
} 
# 169
__gthread_mutex_t *gthread_mutex() 
# 170
{ return &(_M_mutex); } 
# 171
}; 
# 173
class __recursive_mutex { 
# 177
__gthread_recursive_mutex_t _M_mutex = {{0, (0), 0, (0), (PTHREAD_MUTEX_RECURSIVE_NP), 0, {(0), (0)}}}; 
# 182
__recursive_mutex(const __recursive_mutex &); 
# 183
__recursive_mutex &operator=(const __recursive_mutex &); 
# 186
public: __recursive_mutex() 
# 187
{ 
# 192
} 
# 202 "/usr/include/c++/5/ext/concurrence.h" 3
void lock() 
# 203
{ 
# 205
if (__gthread_active_p()) 
# 206
{ 
# 207
if (__gthread_recursive_mutex_lock(&(_M_mutex)) != 0) { 
# 208
__throw_concurrence_lock_error(); }  
# 209
}  
# 211
} 
# 213
void unlock() 
# 214
{ 
# 216
if (__gthread_active_p()) 
# 217
{ 
# 218
if (__gthread_recursive_mutex_unlock(&(_M_mutex)) != 0) { 
# 219
__throw_concurrence_unlock_error(); }  
# 220
}  
# 222
} 
# 224
__gthread_recursive_mutex_t *gthread_recursive_mutex() 
# 225
{ return &(_M_mutex); } 
# 226
}; 
# 231
class __scoped_lock { 
# 234
public: typedef __mutex __mutex_type; 
# 237
private: __mutex_type &_M_device; 
# 239
__scoped_lock(const __scoped_lock &); 
# 240
__scoped_lock &operator=(const __scoped_lock &); 
# 243
public: explicit __scoped_lock(__mutex_type &__name) : _M_device(__name) 
# 244
{ (_M_device).lock(); } 
# 246
~__scoped_lock() throw() 
# 247
{ (_M_device).unlock(); } 
# 248
}; 
# 251
class __cond { 
# 255
__gthread_cond_t _M_cond = {{0, (0), (0), (0), (0), ((void *)0), (0), (0)}}; 
# 260
__cond(const __cond &); 
# 261
__cond &operator=(const __cond &); 
# 264
public: __cond() 
# 265
{ 
# 270
} 
# 280 "/usr/include/c++/5/ext/concurrence.h" 3
void broadcast() 
# 281
{ 
# 283
if (__gthread_active_p()) 
# 284
{ 
# 285
if (__gthread_cond_broadcast(&(_M_cond)) != 0) { 
# 286
__throw_concurrence_broadcast_error(); }  
# 287
}  
# 289
} 
# 291
void wait(__mutex *mutex) 
# 292
{ 
# 294
{ 
# 295
if (__gthread_cond_wait(&(_M_cond), mutex->gthread_mutex()) != 0) { 
# 296
__throw_concurrence_wait_error(); }  
# 297
} 
# 299
} 
# 301
void wait_recursive(__recursive_mutex *mutex) 
# 302
{ 
# 304
{ 
# 305
if (__gthread_cond_wait_recursive(&(_M_cond), mutex->gthread_recursive_mutex()) != 0) { 
# 308
__throw_concurrence_wait_error(); }  
# 309
} 
# 311
} 
# 312
}; 
# 316
}
# 34 "/usr/include/c++/5/bits/uses_allocator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 39
struct allocator_arg_t { }; 
# 41
constexpr allocator_arg_t allocator_arg = allocator_arg_t(); 
# 43
template< class _Tp, class _Alloc, class  = __void_t< > > 
# 44
struct __uses_allocator_helper : public false_type { 
# 45
}; 
# 47
template< class _Tp, class _Alloc> 
# 48
struct __uses_allocator_helper< _Tp, _Alloc, __void_t< typename _Tp::allocator_type> >  : public is_convertible< _Alloc, typename _Tp::allocator_type> ::type { 
# 51
}; 
# 54
template< class _Tp, class _Alloc> 
# 55
struct uses_allocator : public __uses_allocator_helper< _Tp, _Alloc> ::type { 
# 57
}; 
# 59
struct __uses_alloc_base { }; 
# 61
struct __uses_alloc0 : public __uses_alloc_base { 
# 63
struct _Sink { void operator=(const void *) { } } _M_a; 
# 64
}; 
# 66
template< class _Alloc> 
# 67
struct __uses_alloc1 : public __uses_alloc_base { const _Alloc *_M_a; }; 
# 69
template< class _Alloc> 
# 70
struct __uses_alloc2 : public __uses_alloc_base { const _Alloc *_M_a; }; 
# 72
template< bool , class _Tp, class _Alloc, class ..._Args> struct __uses_alloc; 
# 75
template< class _Tp, class _Alloc, class ..._Args> 
# 76
struct __uses_alloc< true, _Tp, _Alloc, _Args...>  : public conditional< is_constructible< _Tp, allocator_arg_t, _Alloc, _Args...> ::value, __uses_alloc1< _Alloc> , __uses_alloc2< _Alloc> > ::type { 
# 81
}; 
# 83
template< class _Tp, class _Alloc, class ..._Args> 
# 84
struct __uses_alloc< false, _Tp, _Alloc, _Args...>  : public __uses_alloc0 { 
# 85
}; 
# 87
template< class _Tp, class _Alloc, class ..._Args> using __uses_alloc_t = __uses_alloc< uses_allocator< _Tp, _Alloc> ::value, _Tp, _Alloc, _Args...> ; 
# 91
template< class _Tp, class _Alloc, class ..._Args> inline __uses_alloc_t< _Tp, _Alloc, _Args...>  
# 93
__use_alloc(const _Alloc &__a) 
# 94
{ 
# 95
__uses_alloc_t< _Tp, _Alloc, _Args...>  __ret; 
# 96
(__ret._M_a) = (&__a); 
# 97
return __ret; 
# 98
} 
# 101
}
# 67 "/usr/include/c++/5/bits/stl_relops.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 69
namespace rel_ops { 
# 85 "/usr/include/c++/5/bits/stl_relops.h" 3
template< class _Tp> inline bool 
# 87
operator!=(const _Tp &__x, const _Tp &__y) 
# 88
{ return !(__x == __y); } 
# 98 "/usr/include/c++/5/bits/stl_relops.h" 3
template< class _Tp> inline bool 
# 100
operator>(const _Tp &__x, const _Tp &__y) 
# 101
{ return __y < __x; } 
# 111 "/usr/include/c++/5/bits/stl_relops.h" 3
template< class _Tp> inline bool 
# 113
operator<=(const _Tp &__x, const _Tp &__y) 
# 114
{ return !(__y < __x); } 
# 124 "/usr/include/c++/5/bits/stl_relops.h" 3
template< class _Tp> inline bool 
# 126
operator>=(const _Tp &__x, const _Tp &__y) 
# 127
{ return !(__x < __y); } 
# 130
}
# 132
}
# 77 "/usr/include/c++/5/utility" 3
namespace std __attribute((__visibility__("default"))) { 
# 81
template< class _Tp> class tuple_size; 
# 84
template< size_t _Int, class _Tp> class tuple_element; 
# 90
template< class _Tp1, class _Tp2> 
# 91
struct tuple_size< pair< _Tp1, _Tp2> >  : public integral_constant< unsigned long, 2UL>  { 
# 92
}; 
# 95
template< class _Tp1, class _Tp2> 
# 96
struct tuple_element< 0, pair< _Tp1, _Tp2> >  { 
# 97
typedef _Tp1 type; }; 
# 100
template< class _Tp1, class _Tp2> 
# 101
struct tuple_element< 1, pair< _Tp1, _Tp2> >  { 
# 102
typedef _Tp2 type; }; 
# 104
template< size_t _Int> struct __pair_get; 
# 108
template<> struct __pair_get< 0UL>  { 
# 110
template< class _Tp1, class _Tp2> static constexpr _Tp1 &
# 112
__get(pair< _Tp1, _Tp2>  &__pair) noexcept 
# 113
{ return __pair.first; } 
# 115
template< class _Tp1, class _Tp2> static constexpr _Tp1 &&
# 117
__move_get(pair< _Tp1, _Tp2>  &&__pair) noexcept 
# 118
{ return std::forward< _Tp1> ((__pair.first)); } 
# 120
template< class _Tp1, class _Tp2> static constexpr const _Tp1 &
# 122
__const_get(const pair< _Tp1, _Tp2>  &__pair) noexcept 
# 123
{ return __pair.first; } 
# 124
}; 
# 127
template<> struct __pair_get< 1UL>  { 
# 129
template< class _Tp1, class _Tp2> static constexpr _Tp2 &
# 131
__get(pair< _Tp1, _Tp2>  &__pair) noexcept 
# 132
{ return __pair.second; } 
# 134
template< class _Tp1, class _Tp2> static constexpr _Tp2 &&
# 136
__move_get(pair< _Tp1, _Tp2>  &&__pair) noexcept 
# 137
{ return std::forward< _Tp2> ((__pair.second)); } 
# 139
template< class _Tp1, class _Tp2> static constexpr const _Tp2 &
# 141
__const_get(const pair< _Tp1, _Tp2>  &__pair) noexcept 
# 142
{ return __pair.second; } 
# 143
}; 
# 145
template< size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element< _Int, pair< _Tp1, _Tp2> > ::type &
# 147
get(pair< _Tp1, _Tp2>  &__in) noexcept 
# 148
{ return __pair_get< _Int> ::__get(__in); } 
# 150
template< size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element< _Int, pair< _Tp1, _Tp2> > ::type &&
# 152
get(pair< _Tp1, _Tp2>  &&__in) noexcept 
# 153
{ return __pair_get< _Int> ::__move_get(std::move(__in)); } 
# 155
template< size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element< _Int, pair< _Tp1, _Tp2> > ::type &
# 157
get(const pair< _Tp1, _Tp2>  &__in) noexcept 
# 158
{ return __pair_get< _Int> ::__const_get(__in); } 
# 205 "/usr/include/c++/5/utility" 3
template< size_t ..._Indexes> 
# 206
struct _Index_tuple { 
# 208
typedef std::_Index_tuple< _Indexes..., sizeof...(_Indexes)>  __next; 
# 209
}; 
# 212
template< size_t _Num> 
# 213
struct _Build_index_tuple { 
# 215
typedef typename std::_Build_index_tuple< _Num - (1)> ::__type::__next __type; 
# 216
}; 
# 219
template<> struct _Build_index_tuple< 0UL>  { 
# 221
typedef _Index_tuple< >  __type; 
# 222
}; 
# 268 "/usr/include/c++/5/utility" 3
}
# 42 "/usr/include/c++/5/array" 3
namespace std __attribute((__visibility__("default"))) { 
# 46
template< class _Tp, size_t _Nm> 
# 47
struct __array_traits { 
# 49
typedef _Tp _Type[_Nm]; 
# 52
static constexpr _Tp &_S_ref(const _Type &__t, size_t __n) noexcept 
# 53
{ return const_cast< _Tp &>((__t)[__n]); } 
# 56
static constexpr _Tp *_S_ptr(const _Type &__t) noexcept 
# 57
{ return const_cast< _Tp *>(__t); } 
# 58
}; 
# 60
template< class _Tp> 
# 61
struct __array_traits< _Tp, 0>  { 
# 63
struct _Type { }; 
# 66
static constexpr _Tp &_S_ref(const _Type &, size_t) noexcept 
# 67
{ return *(static_cast< _Tp *>(nullptr)); } 
# 70
static constexpr _Tp *_S_ptr(const _Type &) noexcept 
# 71
{ return nullptr; } 
# 72
}; 
# 88 "/usr/include/c++/5/array" 3
template< class _Tp, size_t _Nm> 
# 89
struct array { 
# 91
typedef _Tp value_type; 
# 92
typedef value_type *pointer; 
# 93
typedef const value_type *const_pointer; 
# 94
typedef value_type &reference; 
# 95
typedef const value_type &const_reference; 
# 96
typedef value_type *iterator; 
# 97
typedef const value_type *const_iterator; 
# 98
typedef size_t size_type; 
# 99
typedef ptrdiff_t difference_type; 
# 100
typedef std::reverse_iterator< _Tp *>  reverse_iterator; 
# 101
typedef std::reverse_iterator< const _Tp *>  const_reverse_iterator; 
# 104
typedef __array_traits< _Tp, _Nm>  _AT_Type; 
# 105
typename __array_traits< _Tp, _Nm> ::_Type _M_elems; 
# 111
void fill(const value_type &__u) 
# 112
{ std::fill_n(this->begin(), size(), __u); } 
# 115
void swap(array &__other) noexcept(noexcept(swap(std::declval< _Tp &> (), std::declval< _Tp &> ()))) 
# 117
{ std::swap_ranges(this->begin(), this->end(), (__other.begin())); } 
# 121
iterator begin() noexcept 
# 122
{ return (iterator)this->data(); } 
# 125
const_iterator begin() const noexcept 
# 126
{ return (const_iterator)this->data(); } 
# 129
iterator end() noexcept 
# 130
{ return (iterator)(this->data() + _Nm); } 
# 133
const_iterator end() const noexcept 
# 134
{ return (const_iterator)(this->data() + _Nm); } 
# 137
reverse_iterator rbegin() noexcept 
# 138
{ return ((reverse_iterator)(this->end())); } 
# 141
const_reverse_iterator rbegin() const noexcept 
# 142
{ return ((const_reverse_iterator)(this->end())); } 
# 145
reverse_iterator rend() noexcept 
# 146
{ return ((reverse_iterator)(this->begin())); } 
# 149
const_reverse_iterator rend() const noexcept 
# 150
{ return ((const_reverse_iterator)(this->begin())); } 
# 153
const_iterator cbegin() const noexcept 
# 154
{ return (const_iterator)this->data(); } 
# 157
const_iterator cend() const noexcept 
# 158
{ return (const_iterator)(this->data() + _Nm); } 
# 161
const_reverse_iterator crbegin() const noexcept 
# 162
{ return ((const_reverse_iterator)(this->end())); } 
# 165
const_reverse_iterator crend() const noexcept 
# 166
{ return ((const_reverse_iterator)(this->begin())); } 
# 170
constexpr size_type size() const noexcept { return _Nm; } 
# 173
constexpr size_type max_size() const noexcept { return _Nm; } 
# 176
constexpr bool empty() const noexcept { return size() == 0; } 
# 180
reference operator[](size_type __n) noexcept 
# 181
{ return _AT_Type::_S_ref(_M_elems, __n); } 
# 184
constexpr const_reference operator[](size_type __n) const noexcept 
# 185
{ return _AT_Type::_S_ref(_M_elems, __n); } 
# 188
reference at(size_type __n) 
# 189
{ 
# 190
if (__n >= _Nm) { 
# 191
std::__throw_out_of_range_fmt("array::at: __n (which is %zu) >= _Nm (which is %zu)", __n, _Nm); }  
# 194
return _AT_Type::_S_ref(_M_elems, __n); 
# 195
} 
# 198
constexpr const_reference at(size_type __n) const 
# 199
{ 
# 202
return (__n < _Nm) ? _AT_Type::_S_ref(_M_elems, __n) : (std::__throw_out_of_range_fmt("array::at: __n (which is %zu) >= _Nm (which is %zu)", __n, _Nm), _AT_Type::_S_ref(_M_elems, 0)); 
# 207
} 
# 210
reference front() noexcept 
# 211
{ return *this->begin(); } 
# 214
constexpr const_reference front() const noexcept 
# 215
{ return _AT_Type::_S_ref(_M_elems, 0); } 
# 218
reference back() noexcept 
# 219
{ return (_Nm) ? *(this->end() - 1) : (*this->end()); } 
# 222
constexpr const_reference back() const noexcept 
# 223
{ 
# 224
return (_Nm) ? _AT_Type::_S_ref(_M_elems, _Nm - (1)) : _AT_Type::_S_ref(_M_elems, 0); 
# 226
} 
# 229
pointer data() noexcept 
# 230
{ return _AT_Type::_S_ptr(_M_elems); } 
# 233
const_pointer data() const noexcept 
# 234
{ return _AT_Type::_S_ptr(_M_elems); } 
# 235
}; 
# 238
template< class _Tp, size_t _Nm> inline bool 
# 240
operator==(const array< _Tp, _Nm>  &__one, const array< _Tp, _Nm>  &__two) 
# 241
{ return std::equal((__one.begin()), (__one.end()), (__two.begin())); } 
# 243
template< class _Tp, size_t _Nm> inline bool 
# 245
operator!=(const array< _Tp, _Nm>  &__one, const array< _Tp, _Nm>  &__two) 
# 246
{ return !(__one == __two); } 
# 248
template< class _Tp, size_t _Nm> inline bool 
# 250
operator<(const array< _Tp, _Nm>  &__a, const array< _Tp, _Nm>  &__b) 
# 251
{ 
# 252
return std::lexicographical_compare((__a.begin()), (__a.end()), (__b.begin()), (__b.end())); 
# 254
} 
# 256
template< class _Tp, size_t _Nm> inline bool 
# 258
operator>(const array< _Tp, _Nm>  &__one, const array< _Tp, _Nm>  &__two) 
# 259
{ return __two < __one; } 
# 261
template< class _Tp, size_t _Nm> inline bool 
# 263
operator<=(const array< _Tp, _Nm>  &__one, const array< _Tp, _Nm>  &__two) 
# 264
{ return !(__one > __two); } 
# 266
template< class _Tp, size_t _Nm> inline bool 
# 268
operator>=(const array< _Tp, _Nm>  &__one, const array< _Tp, _Nm>  &__two) 
# 269
{ return !(__one < __two); } 
# 272
template< class _Tp, size_t _Nm> inline void 
# 274
swap(array< _Tp, _Nm>  &__one, array< _Tp, _Nm>  &__two) noexcept(noexcept((__one.swap(__two)))) 
# 276
{ (__one.swap(__two)); } 
# 278
template< size_t _Int, class _Tp, size_t _Nm> constexpr _Tp &
# 280
get(array< _Tp, _Nm>  &__arr) noexcept 
# 281
{ 
# 282
static_assert((_Int < _Nm), "index is out of bounds");
# 283
return std::__array_traits< _Tp, _Nm> ::_S_ref((__arr._M_elems), _Int); 
# 285
} 
# 287
template< size_t _Int, class _Tp, size_t _Nm> constexpr _Tp &&
# 289
get(array< _Tp, _Nm>  &&__arr) noexcept 
# 290
{ 
# 291
static_assert((_Int < _Nm), "index is out of bounds");
# 292
return std::move(std::get< _Int> (__arr)); 
# 293
} 
# 295
template< size_t _Int, class _Tp, size_t _Nm> constexpr const _Tp &
# 297
get(const array< _Tp, _Nm>  &__arr) noexcept 
# 298
{ 
# 299
static_assert((_Int < _Nm), "index is out of bounds");
# 300
return std::__array_traits< _Tp, _Nm> ::_S_ref((__arr._M_elems), _Int); 
# 302
} 
# 305
}
# 307
namespace std __attribute((__visibility__("default"))) { 
# 314
template< class _Tp> class tuple_size; 
# 318
template< class _Tp, size_t _Nm> 
# 319
struct tuple_size< array< _Tp, _Nm> >  : public integral_constant< unsigned long, _Nm>  { 
# 320
}; 
# 323
template< size_t _Int, class _Tp> class tuple_element; 
# 327
template< size_t _Int, class _Tp, size_t _Nm> 
# 328
struct tuple_element< _Int, array< _Tp, _Nm> >  { 
# 330
static_assert((_Int < _Nm), "index is out of bounds");
# 331
typedef _Tp type; 
# 332
}; 
# 335
}
# 42 "/usr/include/c++/5/tuple" 3
namespace std __attribute((__visibility__("default"))) { 
# 51
template< size_t _Idx, class _Head, bool _IsEmptyNotFinal> struct _Head_base; 
# 54
template< size_t _Idx, class _Head> 
# 55
struct _Head_base< _Idx, _Head, true>  : public _Head { 
# 58
constexpr _Head_base() : _Head() 
# 59
{ } 
# 61
constexpr _Head_base(const _Head &__h) : _Head(__h) 
# 62
{ } 
# 64
constexpr _Head_base(const ::std::_Head_base< _Idx, _Head, true>  &) = default;
# 65
constexpr _Head_base(::std::_Head_base< _Idx, _Head, true>  &&) = default;
# 67
template< class _UHead> constexpr 
# 68
_Head_base(_UHead &&__h) : _Head(::std::forward< _UHead> (__h)) 
# 69
{ } 
# 71
_Head_base(::std::allocator_arg_t, ::std::__uses_alloc0) : _Head() 
# 72
{ } 
# 74
template< class _Alloc> 
# 75
_Head_base(::std::allocator_arg_t, __uses_alloc1< _Alloc>  __a) : _Head(allocator_arg, *(__a._M_a)) 
# 76
{ } 
# 78
template< class _Alloc> 
# 79
_Head_base(::std::allocator_arg_t, __uses_alloc2< _Alloc>  __a) : _Head(*(__a._M_a)) 
# 80
{ } 
# 82
template< class _UHead> 
# 83
_Head_base(::std::__uses_alloc0, _UHead &&__uhead) : _Head(::std::forward< _UHead> (__uhead)) 
# 84
{ } 
# 86
template< class _Alloc, class _UHead> 
# 87
_Head_base(__uses_alloc1< _Alloc>  __a, _UHead &&__uhead) : _Head(allocator_arg, *(__a._M_a), ::std::forward< _UHead> (__uhead)) 
# 88
{ } 
# 90
template< class _Alloc, class _UHead> 
# 91
_Head_base(__uses_alloc2< _Alloc>  __a, _UHead &&__uhead) : _Head(::std::forward< _UHead> (__uhead), *(__a._M_a)) 
# 92
{ } 
# 95
static constexpr _Head &_M_head(::std::_Head_base< _Idx, _Head, true>  &__b) noexcept { return __b; } 
# 98
static constexpr const _Head &_M_head(const ::std::_Head_base< _Idx, _Head, true>  &__b) noexcept { return __b; } 
# 99
}; 
# 101
template< size_t _Idx, class _Head> 
# 102
struct _Head_base< _Idx, _Head, false>  { 
# 104
constexpr _Head_base() : _M_head_impl() 
# 105
{ } 
# 107
constexpr _Head_base(const _Head &__h) : _M_head_impl(__h) 
# 108
{ } 
# 110
constexpr _Head_base(const std::_Head_base< _Idx, _Head, false>  &) = default;
# 111
constexpr _Head_base(std::_Head_base< _Idx, _Head, false>  &&) = default;
# 113
template< class _UHead> constexpr 
# 114
_Head_base(_UHead &&__h) : _M_head_impl(std::forward< _UHead> (__h)) 
# 115
{ } 
# 117
_Head_base(allocator_arg_t, __uses_alloc0) : _M_head_impl() 
# 118
{ } 
# 120
template< class _Alloc> 
# 121
_Head_base(allocator_arg_t, __uses_alloc1< _Alloc>  __a) : _M_head_impl(allocator_arg, *(__a._M_a)) 
# 122
{ } 
# 124
template< class _Alloc> 
# 125
_Head_base(allocator_arg_t, __uses_alloc2< _Alloc>  __a) : _M_head_impl(*(__a._M_a)) 
# 126
{ } 
# 128
template< class _UHead> 
# 129
_Head_base(__uses_alloc0, _UHead &&__uhead) : _M_head_impl(std::forward< _UHead> (__uhead)) 
# 130
{ } 
# 132
template< class _Alloc, class _UHead> 
# 133
_Head_base(__uses_alloc1< _Alloc>  __a, _UHead &&__uhead) : _M_head_impl(allocator_arg, *(__a._M_a), std::forward< _UHead> (__uhead)) 
# 135
{ } 
# 137
template< class _Alloc, class _UHead> 
# 138
_Head_base(__uses_alloc2< _Alloc>  __a, _UHead &&__uhead) : _M_head_impl(std::forward< _UHead> (__uhead), *(__a._M_a)) 
# 139
{ } 
# 142
static constexpr _Head &_M_head(std::_Head_base< _Idx, _Head, false>  &__b) noexcept { return __b._M_head_impl; } 
# 145
static constexpr const _Head &_M_head(const std::_Head_base< _Idx, _Head, false>  &__b) noexcept { return __b._M_head_impl; } 
# 147
_Head _M_head_impl; 
# 148
}; 
# 158 "/usr/include/c++/5/tuple" 3
template< size_t _Idx, class ..._Elements> struct _Tuple_impl; 
# 161
template< class _Tp> 
# 162
struct __is_empty_non_tuple : public is_empty< _Tp>  { }; 
# 165
template< class _El0, class ..._El> 
# 166
struct __is_empty_non_tuple< tuple< _El0, _El...> >  : public false_type { }; 
# 169
template< class _Tp> using __empty_not_final = typename conditional< __is_final(_Tp), integral_constant< bool, false> , __is_empty_non_tuple< _Tp> > ::type; 
# 179
template< size_t _Idx, class _Head, class ..._Tail> 
# 180
struct _Tuple_impl< _Idx, _Head, _Tail...>  : public _Tuple_impl< _Idx + (1), _Tail...> , private _Head_base< _Idx, _Head, conditional< __is_final(_Head), integral_constant< bool, false> , __is_empty_non_tuple< _Head> > ::type::value>  { 
# 184
template< ::std::size_t , class ...> friend struct _Tuple_impl; 
# 186
typedef ::std::_Tuple_impl< _Idx + (1), _Tail...>  _Inherited; 
# 187
typedef _Head_base< _Idx, _Head, conditional< __is_final(_Head), ::std::integral_constant< bool, false> , __is_empty_non_tuple< _Head> > ::type::value>  _Base; 
# 190
static constexpr _Head &_M_head(::std::_Tuple_impl< _Idx, _Head, _Tail...>  &__t) noexcept { return _Base::_M_head(__t); } 
# 193
static constexpr const _Head &_M_head(const ::std::_Tuple_impl< _Idx, _Head, _Tail...>  &__t) noexcept { return _Base::_M_head(__t); } 
# 196
static constexpr _Inherited &_M_tail(::std::_Tuple_impl< _Idx, _Head, _Tail...>  &__t) noexcept { return __t; } 
# 199
static constexpr const _Inherited &_M_tail(const ::std::_Tuple_impl< _Idx, _Head, _Tail...>  &__t) noexcept { return __t; } 
# 201
constexpr _Tuple_impl() : _Inherited(), _Base() 
# 202
{ } 
# 205
constexpr explicit _Tuple_impl(const _Head &__head, const _Tail &...__tail) : _Inherited(__tail...), _Base(__head) 
# 206
{ } 
# 208
template< class _UHead, class ..._UTail, class  = typename enable_if< sizeof...(_Tail) == sizeof...(_UTail)> ::type> constexpr explicit 
# 211
_Tuple_impl(_UHead &&__head, _UTail &&...__tail) : _Inherited(::std::forward< _UTail> (__tail)...), _Base(::std::forward< _UHead> (__head)) 
# 213
{ } 
# 215
constexpr _Tuple_impl(const ::std::_Tuple_impl< _Idx, _Head, _Tail...>  &) = default;
# 218
constexpr _Tuple_impl(::std::_Tuple_impl< _Idx, _Head, _Tail...>  &&__in) noexcept(__and_< is_nothrow_move_constructible< _Head> , is_nothrow_move_constructible< ::std::_Tuple_impl< _Idx + (1), _Tail...> > > ::value) : _Inherited(::std::move(_M_tail(__in))), _Base(::std::forward< _Head> (_M_head(__in))) 
# 222
{ } 
# 224
template< class ..._UElements> constexpr 
# 225
_Tuple_impl(const ::std::_Tuple_impl< _Idx, _UElements...>  &__in) : _Inherited(_Tuple_impl< _Idx, _UElements...> ::_M_tail(__in)), _Base(_Tuple_impl< _Idx, _UElements...> ::_M_head(__in)) 
# 227
{ } 
# 229
template< class _UHead, class ..._UTails> constexpr 
# 230
_Tuple_impl(::std::_Tuple_impl< _Idx, _UHead, _UTails...>  &&__in) : _Inherited(::std::move(_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_tail(__in))), _Base(::std::forward< _UHead> (_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_head(__in))) 
# 234
{ } 
# 236
template< class _Alloc> 
# 237
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a) : _Inherited(__tag, __a), _Base(__tag, __use_alloc< _Head> (__a)) 
# 239
{ } 
# 241
template< class _Alloc> 
# 242
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, const _Head &
# 243
__head, const _Tail &...__tail) : _Inherited(__tag, __a, __tail...), _Base(__use_alloc< _Head, _Alloc, _Head> (__a), __head) 
# 245
{ } 
# 247
template< class _Alloc, class _UHead, class ..._UTail, class 
# 248
 = typename enable_if< sizeof...(_Tail) == sizeof...(_UTail)> ::type> 
# 250
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, _UHead &&
# 251
__head, _UTail &&...__tail) : _Inherited(__tag, __a, ::std::forward< _UTail> (__tail)...), _Base(__use_alloc< _Head, _Alloc, _UHead> (__a), ::std::forward< _UHead> (__head)) 
# 254
{ } 
# 256
template< class _Alloc> 
# 257
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::_Tuple_impl< _Idx, _Head, _Tail...>  &
# 258
__in) : _Inherited(__tag, __a, _M_tail(__in)), _Base(__use_alloc< _Head, _Alloc, _Head> (__a), _M_head(__in)) 
# 260
{ } 
# 262
template< class _Alloc> 
# 263
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::_Tuple_impl< _Idx, _Head, _Tail...>  &&
# 264
__in) : _Inherited(__tag, __a, ::std::move(_M_tail(__in))), _Base(__use_alloc< _Head, _Alloc, _Head> (__a), ::std::forward< _Head> (_M_head(__in))) 
# 267
{ } 
# 269
template< class _Alloc, class ..._UElements> 
# 270
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::_Tuple_impl< _Idx, _UElements...>  &
# 271
__in) : _Inherited(__tag, __a, _Tuple_impl< _Idx, _UElements...> ::_M_tail(__in)), _Base(__use_alloc< _Head, _Alloc, _Head> (__a), _Tuple_impl< _Idx, _UElements...> ::_M_head(__in)) 
# 275
{ } 
# 277
template< class _Alloc, class _UHead, class ..._UTails> 
# 278
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::_Tuple_impl< _Idx, _UHead, _UTails...>  &&
# 279
__in) : _Inherited(__tag, __a, ::std::move(_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_tail(__in))), _Base(__use_alloc< _Head, _Alloc, _UHead> (__a), ::std::forward< _UHead> (_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_head(__in))) 
# 284
{ } 
# 287
::std::_Tuple_impl< _Idx, _Head, _Tail...>  &operator=(const ::std::_Tuple_impl< _Idx, _Head, _Tail...>  &__in) 
# 288
{ 
# 289
_M_head(*this) = _M_head(__in); 
# 290
_M_tail(*this) = _M_tail(__in); 
# 291
return *this; 
# 292
} 
# 295
::std::_Tuple_impl< _Idx, _Head, _Tail...>  &operator=(::std::_Tuple_impl< _Idx, _Head, _Tail...>  &&__in) noexcept(__and_< is_nothrow_move_assignable< _Head> , is_nothrow_move_assignable< ::std::_Tuple_impl< _Idx + (1), _Tail...> > > ::value) 
# 298
{ 
# 299
_M_head(*this) = ::std::forward< _Head> (_M_head(__in)); 
# 300
_M_tail(*this) = ::std::move(_M_tail(__in)); 
# 301
return *this; 
# 302
} 
# 304
template< class ..._UElements> ::std::_Tuple_impl< _Idx, _Head, _Tail...>  &
# 306
operator=(const ::std::_Tuple_impl< _Idx, _UElements...>  &__in) 
# 307
{ 
# 308
_M_head(*this) = _Tuple_impl< _Idx, _UElements...> ::_M_head(__in); 
# 309
_M_tail(*this) = _Tuple_impl< _Idx, _UElements...> ::_M_tail(__in); 
# 310
return *this; 
# 311
} 
# 313
template< class _UHead, class ..._UTails> ::std::_Tuple_impl< _Idx, _Head, _Tail...>  &
# 315
operator=(::std::_Tuple_impl< _Idx, _UHead, _UTails...>  &&__in) 
# 316
{ 
# 317
_M_head(*this) = ::std::forward< _UHead> (_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_head(__in)); 
# 319
_M_tail(*this) = ::std::move(_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_tail(__in)); 
# 321
return *this; 
# 322
} 
# 326
protected: void _M_swap(::std::_Tuple_impl< _Idx, _Head, _Tail...>  &__in) noexcept(noexcept(swap(::std::declval< _Head &> (), ::std::declval< _Head &> ())) && noexcept((_M_tail(__in)._M_swap(_M_tail(__in))))) 
# 330
{ 
# 331
using ::std::swap;
# 332
swap(_M_head(*this), _M_head(__in)); 
# 333
_Inherited::_M_swap(_M_tail(__in)); 
# 334
} 
# 335
}; 
# 338
template< size_t _Idx, class _Head> 
# 339
struct _Tuple_impl< _Idx, _Head>  : private _Head_base< _Idx, _Head, conditional< __is_final(_Head), integral_constant< bool, false> , __is_empty_non_tuple< _Head> > ::type::value>  { 
# 342
template< ::std::size_t , class ...> friend struct _Tuple_impl; 
# 344
typedef _Head_base< _Idx, _Head, conditional< __is_final(_Head), ::std::integral_constant< bool, false> , __is_empty_non_tuple< _Head> > ::type::value>  _Base; 
# 347
static constexpr _Head &_M_head(::std::_Tuple_impl< _Idx, _Head>  &__t) noexcept { return _Base::_M_head(__t); } 
# 350
static constexpr const _Head &_M_head(const ::std::_Tuple_impl< _Idx, _Head>  &__t) noexcept { return _Base::_M_head(__t); } 
# 352
constexpr _Tuple_impl() : _Base() 
# 353
{ } 
# 356
constexpr explicit _Tuple_impl(const _Head &__head) : _Base(__head) 
# 357
{ } 
# 359
template< class _UHead> constexpr explicit 
# 361
_Tuple_impl(_UHead &&__head) : _Base(::std::forward< _UHead> (__head)) 
# 362
{ } 
# 364
constexpr _Tuple_impl(const ::std::_Tuple_impl< _Idx, _Head>  &) = default;
# 367
constexpr _Tuple_impl(::std::_Tuple_impl< _Idx, _Head>  &&__in) noexcept(is_nothrow_move_constructible< _Head> ::value) : _Base(::std::forward< _Head> (_M_head(__in))) 
# 369
{ } 
# 371
template< class _UHead> constexpr 
# 372
_Tuple_impl(const ::std::_Tuple_impl< _Idx, _UHead>  &__in) : _Base(_Tuple_impl< _Idx, _UHead> ::_M_head(__in)) 
# 373
{ } 
# 375
template< class _UHead> constexpr 
# 376
_Tuple_impl(::std::_Tuple_impl< _Idx, _UHead>  &&__in) : _Base(::std::forward< _UHead> (_Tuple_impl< _Idx, _UHead> ::_M_head(__in))) 
# 378
{ } 
# 380
template< class _Alloc> 
# 381
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a) : _Base(__tag, __use_alloc< _Head> (__a)) 
# 382
{ } 
# 384
template< class _Alloc> 
# 385
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, const _Head &
# 386
__head) : _Base(__use_alloc< _Head, _Alloc, _Head> (__a), __head) 
# 387
{ } 
# 389
template< class _Alloc, class _UHead> 
# 390
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, _UHead &&
# 391
__head) : _Base(__use_alloc< _Head, _Alloc, _UHead> (__a), ::std::forward< _UHead> (__head)) 
# 393
{ } 
# 395
template< class _Alloc> 
# 396
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::_Tuple_impl< _Idx, _Head>  &
# 397
__in) : _Base(__use_alloc< _Head, _Alloc, _Head> (__a), _M_head(__in)) 
# 398
{ } 
# 400
template< class _Alloc> 
# 401
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::_Tuple_impl< _Idx, _Head>  &&
# 402
__in) : _Base(__use_alloc< _Head, _Alloc, _Head> (__a), ::std::forward< _Head> (_M_head(__in))) 
# 404
{ } 
# 406
template< class _Alloc, class _UHead> 
# 407
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::_Tuple_impl< _Idx, _UHead>  &
# 408
__in) : _Base(__use_alloc< _Head, _Alloc, _Head> (__a), _Tuple_impl< _Idx, _UHead> ::_M_head(__in)) 
# 410
{ } 
# 412
template< class _Alloc, class _UHead> 
# 413
_Tuple_impl(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::_Tuple_impl< _Idx, _UHead>  &&
# 414
__in) : _Base(__use_alloc< _Head, _Alloc, _UHead> (__a), ::std::forward< _UHead> (_Tuple_impl< _Idx, _UHead> ::_M_head(__in))) 
# 417
{ } 
# 420
::std::_Tuple_impl< _Idx, _Head>  &operator=(const ::std::_Tuple_impl< _Idx, _Head>  &__in) 
# 421
{ 
# 422
_M_head(*this) = _M_head(__in); 
# 423
return *this; 
# 424
} 
# 427
::std::_Tuple_impl< _Idx, _Head>  &operator=(::std::_Tuple_impl< _Idx, _Head>  &&__in) noexcept(is_nothrow_move_assignable< _Head> ::value) 
# 429
{ 
# 430
_M_head(*this) = ::std::forward< _Head> (_M_head(__in)); 
# 431
return *this; 
# 432
} 
# 434
template< class _UHead> ::std::_Tuple_impl< _Idx, _Head>  &
# 436
operator=(const ::std::_Tuple_impl< _Idx, _UHead>  &__in) 
# 437
{ 
# 438
_M_head(*this) = _Tuple_impl< _Idx, _UHead> ::_M_head(__in); 
# 439
return *this; 
# 440
} 
# 442
template< class _UHead> ::std::_Tuple_impl< _Idx, _Head>  &
# 444
operator=(::std::_Tuple_impl< _Idx, _UHead>  &&__in) 
# 445
{ 
# 446
_M_head(*this) = ::std::forward< _UHead> (_Tuple_impl< _Idx, _UHead> ::_M_head(__in)); 
# 448
return *this; 
# 449
} 
# 453
protected: void _M_swap(::std::_Tuple_impl< _Idx, _Head>  &__in) noexcept(noexcept(swap(::std::declval< _Head &> (), ::std::declval< _Head &> ()))) 
# 455
{ 
# 456
using ::std::swap;
# 457
swap(_M_head(*this), _M_head(__in)); 
# 458
} 
# 459
}; 
# 462
template< class ..._Elements> 
# 463
class tuple : public _Tuple_impl< 0UL, _Elements...>  { 
# 465
typedef _Tuple_impl< 0UL, _Elements...>  _Inherited; 
# 468
public: constexpr tuple() : _Inherited() 
# 469
{ } 
# 472
constexpr explicit tuple(const _Elements &...__elements) : _Inherited(__elements...) 
# 473
{ } 
# 475
template< class ..._UElements, class  = typename enable_if< __and_< is_convertible< _UElements, _Elements> ...> ::value> ::type> constexpr explicit 
# 479
tuple(_UElements &&...__elements) : _Inherited(::std::forward< _UElements> (__elements)...) 
# 480
{ } 
# 482
constexpr tuple(const tuple &) = default;
# 484
constexpr tuple(tuple &&) = default;
# 486
template< class ..._UElements, class  = typename enable_if< __and_< is_convertible< const _UElements &, _Elements> ...> ::value> ::type> constexpr 
# 489
tuple(const ::std::tuple< _UElements...>  &__in) : _Inherited(static_cast< const _Tuple_impl< 0UL, _UElements...>  &>(__in)) 
# 491
{ } 
# 493
template< class ..._UElements, class  = typename enable_if< __and_< is_convertible< _UElements, _Elements> ...> ::value> ::type> constexpr 
# 496
tuple(::std::tuple< _UElements...>  &&__in) : _Inherited(static_cast< _Tuple_impl< 0UL, _UElements...>  &&>(__in)) 
# 497
{ } 
# 501
template< class _Alloc> 
# 502
tuple(::std::allocator_arg_t __tag, const _Alloc &__a) : _Inherited(__tag, __a) 
# 503
{ } 
# 505
template< class _Alloc> 
# 506
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const _Elements &...
# 507
__elements) : _Inherited(__tag, __a, __elements...) 
# 508
{ } 
# 510
template< class _Alloc, class ..._UElements, class  = typename enable_if< sizeof...(_UElements) == sizeof...(_Elements)> ::type> 
# 513
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, _UElements &&...
# 514
__elements) : _Inherited(__tag, __a, ::std::forward< _UElements> (__elements)...) 
# 516
{ } 
# 518
template< class _Alloc> 
# 519
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const tuple &__in) : _Inherited(__tag, __a, static_cast< const _Inherited &>(__in)) 
# 520
{ } 
# 522
template< class _Alloc> 
# 523
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, tuple &&__in) : _Inherited(__tag, __a, static_cast< _Inherited &&>(__in)) 
# 524
{ } 
# 526
template< class _Alloc, class ..._UElements, class  = typename enable_if< sizeof...(_UElements) == sizeof...(_Elements)> ::type> 
# 529
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::tuple< _UElements...>  &
# 530
__in) : _Inherited(__tag, __a, static_cast< const _Tuple_impl< 0UL, _UElements...>  &>(__in)) 
# 533
{ } 
# 535
template< class _Alloc, class ..._UElements, class  = typename enable_if< sizeof...(_UElements) == sizeof...(_Elements)> ::type> 
# 538
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::tuple< _UElements...>  &&
# 539
__in) : _Inherited(__tag, __a, static_cast< _Tuple_impl< 0UL, _UElements...>  &&>(__in)) 
# 542
{ } 
# 545
tuple &operator=(const tuple &__in) 
# 546
{ 
# 547
(static_cast< _Inherited &>(*this)) = __in; 
# 548
return *this; 
# 549
} 
# 552
tuple &operator=(tuple &&__in) noexcept(is_nothrow_move_assignable< _Tuple_impl< 0UL, _Elements...> > ::value) 
# 554
{ 
# 555
(static_cast< _Inherited &>(*this)) = ::std::move(__in); 
# 556
return *this; 
# 557
} 
# 559
template< class ..._UElements, class  = typename enable_if< sizeof...(_UElements) == sizeof...(_Elements)> ::type> tuple &
# 563
operator=(const ::std::tuple< _UElements...>  &__in) 
# 564
{ 
# 565
(static_cast< _Inherited &>(*this)) = __in; 
# 566
return *this; 
# 567
} 
# 569
template< class ..._UElements, class  = typename enable_if< sizeof...(_UElements) == sizeof...(_Elements)> ::type> tuple &
# 573
operator=(::std::tuple< _UElements...>  &&__in) 
# 574
{ 
# 575
(static_cast< _Inherited &>(*this)) = ::std::move(__in); 
# 576
return *this; 
# 577
} 
# 580
void swap(tuple &__in) noexcept(noexcept((__in._M_swap(__in)))) 
# 582
{ _Inherited::_M_swap(__in); } 
# 583
}; 
# 587
template<> class tuple< >  { 
# 590
public: void swap(std::tuple< >  &) noexcept { } 
# 591
}; 
# 595
template< class _T1, class _T2> 
# 596
class tuple< _T1, _T2>  : public _Tuple_impl< 0UL, _T1, _T2>  { 
# 598
typedef _Tuple_impl< 0UL, _T1, _T2>  _Inherited; 
# 601
public: constexpr tuple() : _Inherited() 
# 602
{ } 
# 605
constexpr explicit tuple(const _T1 &__a1, const _T2 &__a2) : _Inherited(__a1, __a2) 
# 606
{ } 
# 608
template< class _U1, class _U2, class  = typename enable_if< __and_< is_convertible< _U1, _T1> , is_convertible< _U2, _T2> > ::value> ::type> constexpr explicit 
# 612
tuple(_U1 &&__a1, _U2 &&__a2) : _Inherited(::std::forward< _U1> (__a1), ::std::forward< _U2> (__a2)) 
# 613
{ } 
# 615
constexpr tuple(const ::std::tuple< _T1, _T2>  &) = default;
# 617
constexpr tuple(::std::tuple< _T1, _T2>  &&) = default;
# 619
template< class _U1, class _U2, class  = typename enable_if< __and_< is_convertible< const _U1 &, _T1> , is_convertible< const _U2 &, _T2> > ::value> ::type> constexpr 
# 622
tuple(const ::std::tuple< _U1, _U2>  &__in) : _Inherited(static_cast< const _Tuple_impl< 0UL, _U1, _U2>  &>(__in)) 
# 623
{ } 
# 625
template< class _U1, class _U2, class  = typename enable_if< __and_< is_convertible< _U1, _T1> , is_convertible< _U2, _T2> > ::value> ::type> constexpr 
# 628
tuple(::std::tuple< _U1, _U2>  &&__in) : _Inherited(static_cast< _Tuple_impl< 0UL, _U1, _U2>  &&>(__in)) 
# 629
{ } 
# 631
template< class _U1, class _U2, class  = typename enable_if< __and_< is_convertible< const _U1 &, _T1> , is_convertible< const _U2 &, _T2> > ::value> ::type> constexpr 
# 634
tuple(const pair< _U1, _U2>  &__in) : _Inherited((__in.first), (__in.second)) 
# 635
{ } 
# 637
template< class _U1, class _U2, class  = typename enable_if< __and_< is_convertible< _U1, _T1> , is_convertible< _U2, _T2> > ::value> ::type> constexpr 
# 640
tuple(pair< _U1, _U2>  &&__in) : _Inherited(::std::forward< _U1> ((__in.first)), ::std::forward< _U2> ((__in.second))) 
# 642
{ } 
# 646
template< class _Alloc> 
# 647
tuple(::std::allocator_arg_t __tag, const _Alloc &__a) : _Inherited(__tag, __a) 
# 648
{ } 
# 650
template< class _Alloc> 
# 651
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const _T1 &
# 652
__a1, const _T2 &__a2) : _Inherited(__tag, __a, __a1, __a2) 
# 653
{ } 
# 655
template< class _Alloc, class _U1, class _U2> 
# 656
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, _U1 &&__a1, _U2 &&__a2) : _Inherited(__tag, __a, ::std::forward< _U1> (__a1), ::std::forward< _U2> (__a2)) 
# 658
{ } 
# 660
template< class _Alloc> 
# 661
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::tuple< _T1, _T2>  &__in) : _Inherited(__tag, __a, static_cast< const _Inherited &>(__in)) 
# 662
{ } 
# 664
template< class _Alloc> 
# 665
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::tuple< _T1, _T2>  &&__in) : _Inherited(__tag, __a, static_cast< _Inherited &&>(__in)) 
# 666
{ } 
# 668
template< class _Alloc, class _U1, class _U2> 
# 669
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const ::std::tuple< _U1, _U2>  &
# 670
__in) : _Inherited(__tag, __a, static_cast< const _Tuple_impl< 0UL, _U1, _U2>  &>(__in)) 
# 673
{ } 
# 675
template< class _Alloc, class _U1, class _U2> 
# 676
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, ::std::tuple< _U1, _U2>  &&__in) : _Inherited(__tag, __a, static_cast< _Tuple_impl< 0UL, _U1, _U2>  &&>(__in)) 
# 678
{ } 
# 680
template< class _Alloc, class _U1, class _U2> 
# 681
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, const pair< _U1, _U2>  &
# 682
__in) : _Inherited(__tag, __a, (__in.first), (__in.second)) 
# 683
{ } 
# 685
template< class _Alloc, class _U1, class _U2> 
# 686
tuple(::std::allocator_arg_t __tag, const _Alloc &__a, pair< _U1, _U2>  &&__in) : _Inherited(__tag, __a, ::std::forward< _U1> ((__in.first)), ::std::forward< _U2> ((__in.second))) 
# 688
{ } 
# 691
::std::tuple< _T1, _T2>  &operator=(const ::std::tuple< _T1, _T2>  &__in) 
# 692
{ 
# 693
(static_cast< _Inherited &>(*this)) = __in; 
# 694
return *this; 
# 695
} 
# 698
::std::tuple< _T1, _T2>  &operator=(::std::tuple< _T1, _T2>  &&__in) noexcept(is_nothrow_move_assignable< _Tuple_impl< 0UL, _T1, _T2> > ::value) 
# 700
{ 
# 701
(static_cast< _Inherited &>(*this)) = ::std::move(__in); 
# 702
return *this; 
# 703
} 
# 705
template< class _U1, class _U2> ::std::tuple< _T1, _T2>  &
# 707
operator=(const ::std::tuple< _U1, _U2>  &__in) 
# 708
{ 
# 709
(static_cast< _Inherited &>(*this)) = __in; 
# 710
return *this; 
# 711
} 
# 713
template< class _U1, class _U2> ::std::tuple< _T1, _T2>  &
# 715
operator=(::std::tuple< _U1, _U2>  &&__in) 
# 716
{ 
# 717
(static_cast< _Inherited &>(*this)) = ::std::move(__in); 
# 718
return *this; 
# 719
} 
# 721
template< class _U1, class _U2> ::std::tuple< _T1, _T2>  &
# 723
operator=(const pair< _U1, _U2>  &__in) 
# 724
{ 
# 725
(this->_M_head(*this)) = (__in.first); 
# 726
((this->_M_tail(*this))._M_head(*this)) = (__in.second); 
# 727
return *this; 
# 728
} 
# 730
template< class _U1, class _U2> ::std::tuple< _T1, _T2>  &
# 732
operator=(pair< _U1, _U2>  &&__in) 
# 733
{ 
# 734
(this->_M_head(*this)) = ::std::forward< _U1> ((__in.first)); 
# 735
((this->_M_tail(*this))._M_head(*this)) = ::std::forward< _U2> ((__in.second)); 
# 736
return *this; 
# 737
} 
# 740
void swap(::std::tuple< _T1, _T2>  &__in) noexcept(noexcept((__in._M_swap(__in)))) 
# 742
{ _Inherited::_M_swap(__in); } 
# 743
}; 
# 747
template< size_t __i, class _Tp> class tuple_element; 
# 754
template< size_t __i, class _Head, class ..._Tail> 
# 755
struct tuple_element< __i, tuple< _Head, _Tail...> >  : public tuple_element< __i - (1), tuple< _Tail...> >  { 
# 756
}; 
# 761
template< class _Head, class ..._Tail> 
# 762
struct tuple_element< 0, tuple< _Head, _Tail...> >  { 
# 764
typedef _Head type; 
# 765
}; 
# 768
template< size_t __i, class _Tp> using __tuple_element_t = typename tuple_element< __i, _Tp> ::type; 
# 771
template< size_t __i, class _Tp> 
# 772
struct tuple_element< __i, const _Tp>  { 
# 774
typedef typename add_const< __tuple_element_t< __i, _Tp> > ::type type; 
# 775
}; 
# 777
template< size_t __i, class _Tp> 
# 778
struct tuple_element< __i, volatile _Tp>  { 
# 780
typedef typename add_volatile< __tuple_element_t< __i, _Tp> > ::type type; 
# 781
}; 
# 783
template< size_t __i, class _Tp> 
# 784
struct tuple_element< __i, const volatile _Tp>  { 
# 786
typedef typename add_cv< __tuple_element_t< __i, _Tp> > ::type type; 
# 787
}; 
# 797 "/usr/include/c++/5/tuple" 3
template< class _Tp> class tuple_size; 
# 802
template< class _Tp> 
# 803
struct tuple_size< const _Tp>  : public integral_constant< unsigned long, tuple_size< _Tp> ::value>  { 
# 804
}; 
# 806
template< class _Tp> 
# 807
struct tuple_size< volatile _Tp>  : public integral_constant< unsigned long, tuple_size< _Tp> ::value>  { 
# 808
}; 
# 810
template< class _Tp> 
# 811
struct tuple_size< const volatile _Tp>  : public integral_constant< unsigned long, tuple_size< _Tp> ::value>  { 
# 812
}; 
# 815
template< class ..._Elements> 
# 816
struct tuple_size< tuple< _Elements...> >  : public integral_constant< unsigned long, sizeof...(_Elements)>  { 
# 817
}; 
# 819
template< size_t __i, class _Head, class ..._Tail> constexpr _Head &
# 821
__get_helper(_Tuple_impl< __i, _Head, _Tail...>  &__t) noexcept 
# 822
{ return _Tuple_impl< __i, _Head, _Tail...> ::_M_head(__t); } 
# 824
template< size_t __i, class _Head, class ..._Tail> constexpr const _Head &
# 826
__get_helper(const _Tuple_impl< __i, _Head, _Tail...>  &__t) noexcept 
# 827
{ return _Tuple_impl< __i, _Head, _Tail...> ::_M_head(__t); } 
# 830
template< size_t __i, class ..._Elements> constexpr __tuple_element_t< __i, tuple< _Elements...> >  &
# 832
get(tuple< _Elements...>  &__t) noexcept 
# 833
{ return std::__get_helper< __i> (__t); } 
# 836
template< size_t __i, class ..._Elements> constexpr const __tuple_element_t< __i, tuple< _Elements...> >  &
# 838
get(const tuple< _Elements...>  &__t) noexcept 
# 839
{ return std::__get_helper< __i> (__t); } 
# 842
template< size_t __i, class ..._Elements> constexpr __tuple_element_t< __i, tuple< _Elements...> >  &&
# 844
get(tuple< _Elements...>  &&__t) noexcept 
# 845
{ 
# 846
typedef __tuple_element_t< __i, tuple< _Elements...> >  __element_type; 
# 847
return std::forward< __tuple_element_t< __i, tuple< _Elements...> >  &&> (std::get< __i> (__t)); 
# 848
} 
# 884 "/usr/include/c++/5/tuple" 3
template< class _Tp, class _Up, size_t __i, size_t __size> 
# 885
struct __tuple_compare { 
# 888
static constexpr bool __eq(const _Tp &__t, const _Up &__u) 
# 889
{ 
# 890
return ((bool)(std::get< __i> (__t) == std::get< __i> (__u))) && __tuple_compare< _Tp, _Up, __i + (1), __size> ::__eq(__t, __u); 
# 892
} 
# 895
static constexpr bool __less(const _Tp &__t, const _Up &__u) 
# 896
{ 
# 897
return ((bool)(std::get< __i> (__t) < std::get< __i> (__u))) || ((!((bool)(std::get< __i> (__u) < std::get< __i> (__t)))) && __tuple_compare< _Tp, _Up, __i + (1), __size> ::__less(__t, __u)); 
# 900
} 
# 901
}; 
# 903
template< class _Tp, class _Up, size_t __size> 
# 904
struct __tuple_compare< _Tp, _Up, __size, __size>  { 
# 907
static constexpr bool __eq(const _Tp &, const _Up &) { return true; } 
# 910
static constexpr bool __less(const _Tp &, const _Up &) { return false; } 
# 911
}; 
# 913
template< class ..._TElements, class ..._UElements> constexpr bool 
# 915
operator==(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 916
__u) 
# 917
{ 
# 918
static_assert((sizeof...(_TElements) == sizeof...(_UElements)), "tuple objects can only be compared if they have equal sizes.");
# 920
using __compare = __tuple_compare< tuple< _TElements...> , tuple< _UElements...> , 0UL, sizeof...(_TElements)> ; 
# 923
return __compare::__eq(__t, __u); 
# 924
} 
# 926
template< class ..._TElements, class ..._UElements> constexpr bool 
# 928
operator<(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 929
__u) 
# 930
{ 
# 931
static_assert((sizeof...(_TElements) == sizeof...(_UElements)), "tuple objects can only be compared if they have equal sizes.");
# 933
using __compare = __tuple_compare< tuple< _TElements...> , tuple< _UElements...> , 0UL, sizeof...(_TElements)> ; 
# 936
return __compare::__less(__t, __u); 
# 937
} 
# 939
template< class ..._TElements, class ..._UElements> constexpr bool 
# 941
operator!=(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 942
__u) 
# 943
{ return !(__t == __u); } 
# 945
template< class ..._TElements, class ..._UElements> constexpr bool 
# 947
operator>(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 948
__u) 
# 949
{ return __u < __t; } 
# 951
template< class ..._TElements, class ..._UElements> constexpr bool 
# 953
operator<=(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 954
__u) 
# 955
{ return !(__u < __t); } 
# 957
template< class ..._TElements, class ..._UElements> constexpr bool 
# 959
operator>=(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 960
__u) 
# 961
{ return !(__t < __u); } 
# 964
template< class ..._Elements> constexpr tuple< typename __decay_and_strip< _Elements> ::__type...>  
# 966
make_tuple(_Elements &&...__args) 
# 967
{ 
# 969
typedef tuple< typename __decay_and_strip< _Elements> ::__type...>  __result_type; 
# 970
return __result_type(std::forward< _Elements> (__args)...); 
# 971
} 
# 973
template< class ..._Elements> tuple< _Elements &&...>  
# 975
forward_as_tuple(_Elements &&...__args) noexcept 
# 976
{ return tuple< _Elements &&...> (std::forward< _Elements> (__args)...); } 
# 978
template< class > 
# 979
struct __is_tuple_like_impl : public false_type { 
# 980
}; 
# 982
template< class ..._Tps> 
# 983
struct __is_tuple_like_impl< tuple< _Tps...> >  : public true_type { 
# 984
}; 
# 986
template< class _T1, class _T2> 
# 987
struct __is_tuple_like_impl< pair< _T1, _T2> >  : public true_type { 
# 988
}; 
# 990
template< class _Tp, size_t _Nm> 
# 991
struct __is_tuple_like_impl< array< _Tp, _Nm> >  : public true_type { 
# 992
}; 
# 995
template< class _Tp> 
# 996
struct __is_tuple_like : public __is_tuple_like_impl< typename remove_cv< typename remove_reference< _Tp> ::type> ::type> ::type { 
# 999
}; 
# 1001
template< size_t , class , class , size_t > struct __make_tuple_impl; 
# 1004
template< size_t _Idx, class _Tuple, class ..._Tp, size_t _Nm> 
# 1005
struct __make_tuple_impl< _Idx, tuple< _Tp...> , _Tuple, _Nm>  : public __make_tuple_impl< _Idx + (1), tuple< _Tp..., __tuple_element_t< _Idx, _Tuple> > , _Tuple, _Nm>  { 
# 1009
}; 
# 1011
template< size_t _Nm, class _Tuple, class ..._Tp> 
# 1012
struct __make_tuple_impl< _Nm, tuple< _Tp...> , _Tuple, _Nm>  { 
# 1014
typedef tuple< _Tp...>  __type; 
# 1015
}; 
# 1017
template< class _Tuple> 
# 1018
struct __do_make_tuple : public __make_tuple_impl< 0UL, tuple< > , _Tuple, tuple_size< _Tuple> ::value>  { 
# 1020
}; 
# 1023
template< class _Tuple> 
# 1024
struct __make_tuple : public __do_make_tuple< typename remove_cv< typename remove_reference< _Tuple> ::type> ::type>  { 
# 1027
}; 
# 1030
template< class ...> struct __combine_tuples; 
# 1034
template<> struct __combine_tuples< >  { 
# 1036
typedef tuple< >  __type; 
# 1037
}; 
# 1039
template< class ..._Ts> 
# 1040
struct __combine_tuples< tuple< _Ts...> >  { 
# 1042
typedef tuple< _Ts...>  __type; 
# 1043
}; 
# 1045
template< class ..._T1s, class ..._T2s, class ..._Rem> 
# 1046
struct __combine_tuples< tuple< _T1s...> , tuple< _T2s...> , _Rem...>  { 
# 1049
typedef typename std::__combine_tuples< tuple< _T1s..., _T2s...> , _Rem...> ::__type __type; 
# 1050
}; 
# 1053
template< class ..._Tpls> 
# 1054
struct __tuple_cat_result { 
# 1057
typedef typename __combine_tuples< typename __make_tuple< _Tpls> ::__type...> ::__type __type; 
# 1058
}; 
# 1062
template< class ...> struct __make_1st_indices; 
# 1066
template<> struct __make_1st_indices< >  { 
# 1068
typedef _Index_tuple< >  __type; 
# 1069
}; 
# 1071
template< class _Tp, class ..._Tpls> 
# 1072
struct __make_1st_indices< _Tp, _Tpls...>  { 
# 1075
typedef typename _Build_index_tuple< tuple_size< typename remove_reference< _Tp> ::type> ::value> ::__type __type; 
# 1076
}; 
# 1081
template< class _Ret, class _Indices, class ..._Tpls> struct __tuple_concater; 
# 1084
template< class _Ret, size_t ..._Is, class _Tp, class ..._Tpls> 
# 1085
struct __tuple_concater< _Ret, _Index_tuple< _Is...> , _Tp, _Tpls...>  { 
# 1087
template< class ..._Us> static constexpr _Ret 
# 1089
_S_do(_Tp &&__tp, _Tpls &&...__tps, _Us &&...__us) 
# 1090
{ 
# 1091
typedef typename __make_1st_indices< _Tpls...> ::__type __idx; 
# 1092
typedef std::__tuple_concater< _Ret, typename __make_1st_indices< _Tpls...> ::__type, _Tpls...>  __next; 
# 1093
return __next::_S_do(std::forward< _Tpls> (__tps)..., std::forward< _Us> (__us)..., std::get< _Is> (std::forward< _Tp> (__tp))...); 
# 1096
} 
# 1097
}; 
# 1099
template< class _Ret> 
# 1100
struct __tuple_concater< _Ret, _Index_tuple< > >  { 
# 1102
template< class ..._Us> static constexpr _Ret 
# 1104
_S_do(_Us &&...__us) 
# 1105
{ 
# 1106
return _Ret(std::forward< _Us> (__us)...); 
# 1107
} 
# 1108
}; 
# 1111
template< class ..._Tpls, class  = typename enable_if< __and_< __is_tuple_like< _Tpls> ...> ::value> ::type> constexpr auto 
# 1114
tuple_cat(_Tpls &&...__tpls)->typename __tuple_cat_result< _Tpls...> ::__type 
# 1116
{ 
# 1117
typedef typename __tuple_cat_result< _Tpls...> ::__type __ret; 
# 1118
typedef typename __make_1st_indices< _Tpls...> ::__type __idx; 
# 1119
typedef __tuple_concater< typename __tuple_cat_result< _Tpls...> ::__type, typename __make_1st_indices< _Tpls...> ::__type, _Tpls...>  __concater; 
# 1120
return __concater::_S_do(std::forward< _Tpls> (__tpls)...); 
# 1121
} 
# 1124
template< class ..._Elements> inline tuple< _Elements &...>  
# 1126
tie(_Elements &...__args) noexcept 
# 1127
{ return tuple< _Elements &...> (__args...); } 
# 1130
template< class ..._Elements> inline void 
# 1132
swap(tuple< _Elements...>  &__x, tuple< _Elements...>  &__y) noexcept(noexcept((__x.swap(__y)))) 
# 1134
{ (__x.swap(__y)); } 
# 1138
struct _Swallow_assign { 
# 1140
template< class _Tp> const _Swallow_assign &
# 1142
operator=(const _Tp &) const 
# 1143
{ return *this; } 
# 1144
}; 
# 1146
const _Swallow_assign ignore{}; 
# 1149
template< class ..._Types, class _Alloc> 
# 1150
struct uses_allocator< tuple< _Types...> , _Alloc>  : public true_type { }; 
# 1153
template< class _T1, class _T2> 
# 1154
template< class ..._Args1, class ..._Args2> inline 
# 1157
pair< _T1, _T2> ::pair(piecewise_construct_t, tuple< _Args1...>  
# 1158
__first, tuple< _Args2...>  __second) : pair(__first, __second, typename _Build_index_tuple< sizeof...(_Args1)> ::__type(), typename _Build_index_tuple< sizeof...(_Args2)> ::__type()) 
# 1162
{ } 
# 1164
template< class _T1, class _T2> 
# 1165
template< class ..._Args1, size_t ..._Indexes1, class ...
# 1166
_Args2, size_t ..._Indexes2> inline 
# 1169
pair< _T1, _T2> ::pair(tuple< _Args1...>  &__tuple1, tuple< _Args2...>  &__tuple2, _Index_tuple< _Indexes1...> , _Index_tuple< _Indexes2...> ) : first(std::forward< _Args1> (std::get< _Indexes1> (__tuple1))...), second(std::forward< _Args2> (std::get< _Indexes2> (__tuple2))...) 
# 1173
{ } 
# 1178
}
# 60 "/usr/include/c++/5/functional" 3
namespace std __attribute((__visibility__("default"))) { 
# 64
template< class _MemberPointer> class _Mem_fn; 
# 66
template< class _Tp, class _Class> inline _Mem_fn< _Tp (_Class::*)>  mem_fn(_Tp (_Class::*)) noexcept; 
# 71
template< class _Functor, class  = __void_t< > > 
# 72
struct _Maybe_get_result_type { 
# 73
}; 
# 75
template< class _Functor> 
# 76
struct _Maybe_get_result_type< _Functor, __void_t< typename _Functor::result_type> >  { 
# 78
typedef typename _Functor::result_type result_type; }; 
# 84
template< class _Functor> 
# 85
struct _Weak_result_type_impl : public _Maybe_get_result_type< _Functor>  { 
# 87
}; 
# 90
template< class _Res, class ..._ArgTypes> 
# 91
struct _Weak_result_type_impl< _Res (_ArgTypes ...)>  { 
# 92
typedef _Res result_type; }; 
# 94
template< class _Res, class ..._ArgTypes> 
# 95
struct _Weak_result_type_impl< _Res (_ArgTypes ..., ...)>  { 
# 96
typedef _Res result_type; }; 
# 98
template< class _Res, class ..._ArgTypes> 
# 99
struct _Weak_result_type_impl< _Res (_ArgTypes ...) const>  { 
# 100
typedef _Res result_type; }; 
# 102
template< class _Res, class ..._ArgTypes> 
# 103
struct _Weak_result_type_impl< _Res (_ArgTypes ..., ...) const>  { 
# 104
typedef _Res result_type; }; 
# 106
template< class _Res, class ..._ArgTypes> 
# 107
struct _Weak_result_type_impl< _Res (_ArgTypes ...) volatile>  { 
# 108
typedef _Res result_type; }; 
# 110
template< class _Res, class ..._ArgTypes> 
# 111
struct _Weak_result_type_impl< _Res (_ArgTypes ..., ...) volatile>  { 
# 112
typedef _Res result_type; }; 
# 114
template< class _Res, class ..._ArgTypes> 
# 115
struct _Weak_result_type_impl< _Res (_ArgTypes ...) const volatile>  { 
# 116
typedef _Res result_type; }; 
# 118
template< class _Res, class ..._ArgTypes> 
# 119
struct _Weak_result_type_impl< _Res (_ArgTypes ..., ...) const volatile>  { 
# 120
typedef _Res result_type; }; 
# 123
template< class _Res, class ..._ArgTypes> 
# 124
struct _Weak_result_type_impl< _Res (&)(_ArgTypes ...)>  { 
# 125
typedef _Res result_type; }; 
# 127
template< class _Res, class ..._ArgTypes> 
# 128
struct _Weak_result_type_impl< _Res (&)(_ArgTypes ..., ...)>  { 
# 129
typedef _Res result_type; }; 
# 132
template< class _Res, class ..._ArgTypes> 
# 133
struct _Weak_result_type_impl< _Res (*)(_ArgTypes ...)>  { 
# 134
typedef _Res result_type; }; 
# 136
template< class _Res, class ..._ArgTypes> 
# 137
struct _Weak_result_type_impl< _Res (*)(_ArgTypes ..., ...)>  { 
# 138
typedef _Res result_type; }; 
# 141
template< class _Res, class _Class, class ..._ArgTypes> 
# 142
struct _Weak_result_type_impl< _Res (_Class::*)(_ArgTypes ...)>  { 
# 143
typedef _Res result_type; }; 
# 145
template< class _Res, class _Class, class ..._ArgTypes> 
# 146
struct _Weak_result_type_impl< _Res (_Class::*)(_ArgTypes ..., ...)>  { 
# 147
typedef _Res result_type; }; 
# 150
template< class _Res, class _Class, class ..._ArgTypes> 
# 151
struct _Weak_result_type_impl< _Res (_Class::*)(_ArgTypes ...) const>  { 
# 152
typedef _Res result_type; }; 
# 154
template< class _Res, class _Class, class ..._ArgTypes> 
# 155
struct _Weak_result_type_impl< _Res (_Class::*)(_ArgTypes ..., ...) const>  { 
# 156
typedef _Res result_type; }; 
# 159
template< class _Res, class _Class, class ..._ArgTypes> 
# 160
struct _Weak_result_type_impl< _Res (_Class::*)(_ArgTypes ...) volatile>  { 
# 161
typedef _Res result_type; }; 
# 163
template< class _Res, class _Class, class ..._ArgTypes> 
# 164
struct _Weak_result_type_impl< _Res (_Class::*)(_ArgTypes ..., ...) volatile>  { 
# 165
typedef _Res result_type; }; 
# 168
template< class _Res, class _Class, class ..._ArgTypes> 
# 169
struct _Weak_result_type_impl< _Res (_Class::*)(_ArgTypes ...) const volatile>  { 
# 171
typedef _Res result_type; }; 
# 173
template< class _Res, class _Class, class ..._ArgTypes> 
# 174
struct _Weak_result_type_impl< _Res (_Class::*)(_ArgTypes ..., ...) const volatile>  { 
# 176
typedef _Res result_type; }; 
# 182
template< class _Functor> 
# 183
struct _Weak_result_type : public _Weak_result_type_impl< typename remove_cv< _Functor> ::type>  { 
# 185
}; 
# 191
template< class _Functor, class ..._Args> inline typename enable_if< (!is_member_pointer< _Functor> ::value) && (!is_function< _Functor> ::value) && (!is_function< typename remove_pointer< _Functor> ::type> ::value), typename result_of< _Functor &(_Args && ...)> ::type> ::type 
# 199
__invoke(_Functor &__f, _Args &&...__args) 
# 200
{ 
# 201
return __f(std::forward< _Args> (__args)...); 
# 202
} 
# 204
template< class _Functor, class ..._Args> inline typename enable_if< is_member_pointer< _Functor> ::value && (!is_function< _Functor> ::value) && (!is_function< typename remove_pointer< _Functor> ::type> ::value), typename result_of< _Functor (_Args && ...)> ::type> ::type 
# 212
__invoke(_Functor &__f, _Args &&...__args) 
# 213
{ 
# 214
return std::mem_fn(__f)(std::forward< _Args> (__args)...); 
# 215
} 
# 218
template< class _Functor, class ..._Args> inline typename enable_if< is_pointer< _Functor> ::value && is_function< typename remove_pointer< _Functor> ::type> ::value, typename result_of< _Functor (_Args && ...)> ::type> ::type 
# 225
__invoke(_Functor __f, _Args &&...__args) 
# 226
{ 
# 227
return __f(std::forward< _Args> (__args)...); 
# 228
} 
# 235
template< bool _Unary, bool _Binary, class _Tp> struct _Reference_wrapper_base_impl; 
# 239
template< class _Tp> 
# 240
struct _Reference_wrapper_base_impl< false, false, _Tp>  : public _Weak_result_type< _Tp>  { 
# 242
}; 
# 245
template< class _Tp> 
# 246
struct _Reference_wrapper_base_impl< true, false, _Tp>  : public _Weak_result_type< _Tp>  { 
# 249
typedef typename _Tp::argument_type argument_type; 
# 250
}; 
# 253
template< class _Tp> 
# 254
struct _Reference_wrapper_base_impl< false, true, _Tp>  : public _Weak_result_type< _Tp>  { 
# 257
typedef typename _Tp::first_argument_type first_argument_type; 
# 258
typedef typename _Tp::second_argument_type second_argument_type; 
# 259
}; 
# 262
template< class _Tp> 
# 263
struct _Reference_wrapper_base_impl< true, true, _Tp>  : public _Weak_result_type< _Tp>  { 
# 266
typedef typename _Tp::argument_type argument_type; 
# 267
typedef typename _Tp::first_argument_type first_argument_type; 
# 268
typedef typename _Tp::second_argument_type second_argument_type; 
# 269
}; 
# 271
template< class _Tp, class  = __void_t< > > struct __has_argument_type : public false_type { }; template< class _Tp> struct __has_argument_type< _Tp, __void_t< typename _Tp::argument_type> >  : public true_type { }; 
# 272
template< class _Tp, class  = __void_t< > > struct __has_first_argument_type : public false_type { }; template< class _Tp> struct __has_first_argument_type< _Tp, __void_t< typename _Tp::first_argument_type> >  : public true_type { }; 
# 273
template< class _Tp, class  = __void_t< > > struct __has_second_argument_type : public false_type { }; template< class _Tp> struct __has_second_argument_type< _Tp, __void_t< typename _Tp::second_argument_type> >  : public true_type { }; 
# 281
template< class _Tp> 
# 282
struct _Reference_wrapper_base : public _Reference_wrapper_base_impl< __has_argument_type< _Tp> ::value, __has_first_argument_type< _Tp> ::value && __has_second_argument_type< _Tp> ::value, _Tp>  { 
# 288
}; 
# 291
template< class _Res, class _T1> 
# 292
struct _Reference_wrapper_base< _Res (_T1)>  : public unary_function< _T1, _Res>  { 
# 294
}; 
# 296
template< class _Res, class _T1> 
# 297
struct _Reference_wrapper_base< _Res (_T1) const>  : public unary_function< _T1, _Res>  { 
# 299
}; 
# 301
template< class _Res, class _T1> 
# 302
struct _Reference_wrapper_base< _Res (_T1) volatile>  : public unary_function< _T1, _Res>  { 
# 304
}; 
# 306
template< class _Res, class _T1> 
# 307
struct _Reference_wrapper_base< _Res (_T1) const volatile>  : public unary_function< _T1, _Res>  { 
# 309
}; 
# 312
template< class _Res, class _T1, class _T2> 
# 313
struct _Reference_wrapper_base< _Res (_T1, _T2)>  : public binary_function< _T1, _T2, _Res>  { 
# 315
}; 
# 317
template< class _Res, class _T1, class _T2> 
# 318
struct _Reference_wrapper_base< _Res (_T1, _T2) const>  : public binary_function< _T1, _T2, _Res>  { 
# 320
}; 
# 322
template< class _Res, class _T1, class _T2> 
# 323
struct _Reference_wrapper_base< _Res (_T1, _T2) volatile>  : public binary_function< _T1, _T2, _Res>  { 
# 325
}; 
# 327
template< class _Res, class _T1, class _T2> 
# 328
struct _Reference_wrapper_base< _Res (_T1, _T2) const volatile>  : public binary_function< _T1, _T2, _Res>  { 
# 330
}; 
# 333
template< class _Res, class _T1> 
# 334
struct _Reference_wrapper_base< _Res (*)(_T1)>  : public unary_function< _T1, _Res>  { 
# 336
}; 
# 339
template< class _Res, class _T1, class _T2> 
# 340
struct _Reference_wrapper_base< _Res (*)(_T1, _T2)>  : public binary_function< _T1, _T2, _Res>  { 
# 342
}; 
# 345
template< class _Res, class _T1> 
# 346
struct _Reference_wrapper_base< _Res (_T1::*)(void)>  : public unary_function< _T1 *, _Res>  { 
# 348
}; 
# 351
template< class _Res, class _T1, class _T2> 
# 352
struct _Reference_wrapper_base< _Res (_T1::*)(_T2)>  : public binary_function< _T1 *, _T2, _Res>  { 
# 354
}; 
# 357
template< class _Res, class _T1> 
# 358
struct _Reference_wrapper_base< _Res (_T1::*)(void) const>  : public unary_function< const _T1 *, _Res>  { 
# 360
}; 
# 363
template< class _Res, class _T1, class _T2> 
# 364
struct _Reference_wrapper_base< _Res (_T1::*)(_T2) const>  : public binary_function< const _T1 *, _T2, _Res>  { 
# 366
}; 
# 369
template< class _Res, class _T1> 
# 370
struct _Reference_wrapper_base< _Res (_T1::*)(void) volatile>  : public unary_function< volatile _T1 *, _Res>  { 
# 372
}; 
# 375
template< class _Res, class _T1, class _T2> 
# 376
struct _Reference_wrapper_base< _Res (_T1::*)(_T2) volatile>  : public binary_function< volatile _T1 *, _T2, _Res>  { 
# 378
}; 
# 381
template< class _Res, class _T1> 
# 382
struct _Reference_wrapper_base< _Res (_T1::*)(void) const volatile>  : public unary_function< const volatile _T1 *, _Res>  { 
# 384
}; 
# 387
template< class _Res, class _T1, class _T2> 
# 388
struct _Reference_wrapper_base< _Res (_T1::*)(_T2) const volatile>  : public binary_function< const volatile _T1 *, _T2, _Res>  { 
# 390
}; 
# 397
template< class _Tp> 
# 398
class reference_wrapper : public _Reference_wrapper_base< typename remove_cv< _Tp> ::type>  { 
# 401
_Tp *_M_data; 
# 404
public: typedef _Tp type; 
# 406
reference_wrapper(_Tp &__indata) noexcept : _M_data(::std::__addressof(__indata)) 
# 408
{ } 
# 410
reference_wrapper(_Tp &&) = delete;
# 412
reference_wrapper(const reference_wrapper &) = default;
# 415
reference_wrapper &operator=(const reference_wrapper &) = default;
# 417
operator _Tp &() const noexcept 
# 418
{ return this->get(); } 
# 421
_Tp &get() const noexcept 
# 422
{ return *(_M_data); } 
# 424
template< class ..._Args> typename result_of< _Tp &(_Args && ...)> ::type 
# 426
operator()(_Args &&...__args) const 
# 427
{ 
# 428
return __invoke(get(), ::std::forward< _Args> (__args)...); 
# 429
} 
# 430
}; 
# 434
template< class _Tp> inline reference_wrapper< _Tp>  
# 436
ref(_Tp &__t) noexcept 
# 437
{ return ((reference_wrapper< _Tp> )(__t)); } 
# 440
template< class _Tp> inline reference_wrapper< const _Tp>  
# 442
cref(const _Tp &__t) noexcept 
# 443
{ return ((reference_wrapper< const _Tp> )(__t)); } 
# 445
template < typename _Tp >
    void ref ( const _Tp && ) = delete;
# 448
template < typename _Tp >
    void cref ( const _Tp && ) = delete;
# 452
template< class _Tp> inline reference_wrapper< _Tp>  
# 454
ref(reference_wrapper< _Tp>  __t) noexcept 
# 455
{ return ref((__t.get())); } 
# 458
template< class _Tp> inline reference_wrapper< const _Tp>  
# 460
cref(reference_wrapper< _Tp>  __t) noexcept 
# 461
{ return cref((__t.get())); } 
# 465
template< class ..._Types> 
# 466
struct _Pack : public integral_constant< unsigned long, sizeof...(_Types)>  { 
# 467
}; 
# 469
template< class _From, class _To, bool  = _From::value == _To::value> 
# 470
struct _AllConvertible : public false_type { 
# 471
}; 
# 473
template< class ..._From, class ..._To> 
# 474
struct _AllConvertible< _Pack< _From...> , _Pack< _To...> , true>  : public __and_< is_convertible< _From, _To> ...>  { 
# 476
}; 
# 478
template< class _Tp1, class _Tp2> using _NotSame = __not_< is_same< typename decay< _Tp1> ::type, typename decay< _Tp2> ::type> > ; 
# 487
template< class _Res, class ..._ArgTypes> 
# 488
struct _Maybe_unary_or_binary_function { }; 
# 491
template< class _Res, class _T1> 
# 492
struct _Maybe_unary_or_binary_function< _Res, _T1>  : public unary_function< _T1, _Res>  { 
# 493
}; 
# 496
template< class _Res, class _T1, class _T2> 
# 497
struct _Maybe_unary_or_binary_function< _Res, _T1, _T2>  : public binary_function< _T1, _T2, _Res>  { 
# 498
}; 
# 500
template< class _Signature> struct _Mem_fn_traits; 
# 503
template< class _Res, class _Class, class ..._ArgTypes> 
# 504
struct _Mem_fn_traits_base { 
# 506
using __result_type = _Res; 
# 507
using __class_type = _Class; 
# 508
using __arg_types = _Pack< _ArgTypes...> ; 
# 509
using __maybe_type = _Maybe_unary_or_binary_function< _Res, _Class *, _ArgTypes...> ; 
# 511
using __arity = integral_constant< unsigned long, sizeof...(_ArgTypes)> ; 
# 512
}; 
# 540 "/usr/include/c++/5/functional" 3
template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...)>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...); using __lvalue = ::std::true_type; using __rvalue = ::std::true_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...)>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...); using __lvalue = ::std::true_type; using __rvalue = ::std::true_type; using __vararg = ::std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) const; using __lvalue = ::std::true_type; using __rvalue = ::std::true_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) const; using __lvalue = ::std::true_type; using __rvalue = ::std::true_type; using __vararg = ::std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) volatile>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) volatile; using __lvalue = ::std::true_type; using __rvalue = ::std::true_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) volatile>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) volatile; using __lvalue = ::std::true_type; using __rvalue = ::std::true_type; using __vararg = ::std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const volatile>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) const volatile; using __lvalue = ::std::true_type; using __rvalue = ::std::true_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const volatile>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) const volatile; using __lvalue = ::std::true_type; using __rvalue = ::std::true_type; using __vararg = ::std::true_type; }; 
# 541
template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) &>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) &; using __lvalue = ::std::true_type; using __rvalue = ::std::false_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) &>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) &; using __lvalue = ::std::true_type; using __rvalue = ::std::false_type; using __vararg = ::std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const &>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) const &; using __lvalue = ::std::true_type; using __rvalue = ::std::false_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const &>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) const &; using __lvalue = ::std::true_type; using __rvalue = ::std::false_type; using __vararg = ::std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) volatile &>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) volatile &; using __lvalue = ::std::true_type; using __rvalue = ::std::false_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) volatile &>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) volatile &; using __lvalue = ::std::true_type; using __rvalue = ::std::false_type; using __vararg = ::std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const volatile &>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) const volatile &; using __lvalue = ::std::true_type; using __rvalue = ::std::false_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const volatile &>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) const volatile &; using __lvalue = ::std::true_type; using __rvalue = ::std::false_type; using __vararg = ::std::true_type; }; 
# 542
template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) &&>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) &&; using __lvalue = ::std::false_type; using __rvalue = ::std::true_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) &&>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) &&; using __lvalue = ::std::false_type; using __rvalue = ::std::true_type; using __vararg = ::std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const &&>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) const &&; using __lvalue = ::std::false_type; using __rvalue = ::std::true_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const &&>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) const &&; using __lvalue = ::std::false_type; using __rvalue = ::std::true_type; using __vararg = ::std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) volatile &&>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) volatile &&; using __lvalue = ::std::false_type; using __rvalue = ::std::true_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) volatile &&>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) volatile &&; using __lvalue = ::std::false_type; using __rvalue = ::std::true_type; using __vararg = ::std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const volatile &&>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ...) const volatile &&; using __lvalue = ::std::false_type; using __rvalue = ::std::true_type; using __vararg = ::std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const volatile &&>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __pmf_type = _Res (_Class::*)(_ArgTypes ..., ...) const volatile &&; using __lvalue = ::std::false_type; using __rvalue = ::std::true_type; using __vararg = ::std::true_type; }; 
# 547
template< class _MemFunPtr, bool 
# 548
__is_mem_fn = is_member_function_pointer< _MemFunPtr> ::value> 
# 549
class _Mem_fn_base : public _Mem_fn_traits< _MemFunPtr> ::__maybe_type { 
# 552
using _Traits = _Mem_fn_traits< _MemFunPtr> ; 
# 554
using _Class = typename _Mem_fn_traits< _MemFunPtr> ::__class_type; 
# 555
using _ArgTypes = typename _Mem_fn_traits< _MemFunPtr> ::__arg_types; 
# 556
using _Pmf = typename _Mem_fn_traits< _MemFunPtr> ::__pmf_type; 
# 558
using _Arity = typename _Mem_fn_traits< _MemFunPtr> ::__arity; 
# 559
using _Varargs = typename _Mem_fn_traits< _MemFunPtr> ::__vararg; 
# 561
template< class _Func, class ..._BoundArgs> friend struct _Bind_check_arity; 
# 566
template< class _Args> using _CheckArgs = typename conditional< _Mem_fn_traits< _MemFunPtr> ::__vararg::value, ::std::__bool_constant< _Args::value >= _Mem_fn_traits< _MemFunPtr> ::__arg_types::value> , _AllConvertible< _Args, typename _Mem_fn_traits< _MemFunPtr> ::__arg_types> > ::type; 
# 573
public: using result_type = typename _Mem_fn_traits< _MemFunPtr> ::__result_type; 
# 575
explicit _Mem_fn_base(_Pmf __pmf) : _M_pmf(__pmf) { } 
# 578
template< class ..._Args, class _Req = ::std::_Require< typename _Mem_fn_traits< _MemFunPtr> ::__lvalue, _CheckArgs< _Pack< _Args...> > > > result_type 
# 582
operator()(_Class &__object, _Args &&...__args) const 
# 583
{ return (__object.*(_M_pmf))(::std::forward< _Args> (__args)...); } 
# 585
template< class ..._Args, class _Req = ::std::_Require< typename _Mem_fn_traits< _MemFunPtr> ::__rvalue, _CheckArgs< _Pack< _Args...> > > > result_type 
# 589
operator()(_Class &&__object, _Args &&...__args) const 
# 590
{ 
# 591
return (::std::move(__object).*(_M_pmf))(::std::forward< _Args> (__args)...); 
# 592
} 
# 595
template< class ..._Args, class _Req = ::std::_Require< typename _Mem_fn_traits< _MemFunPtr> ::__lvalue, _CheckArgs< _Pack< _Args...> > > > result_type 
# 599
operator()(_Class *__object, _Args &&...__args) const 
# 600
{ return (__object->*(_M_pmf))(::std::forward< _Args> (__args)...); } 
# 603
template< class _Tp, class ..._Args, class _Req = ::std::_Require< ::std::_NotSame< typename _Mem_fn_traits< _MemFunPtr> ::__class_type, _Tp> , ::std::_NotSame< typename _Mem_fn_traits< _MemFunPtr> ::__class_type *, _Tp> , _CheckArgs< _Pack< _Args...> > > > result_type 
# 607
operator()(_Tp &&__object, _Args &&...__args) const 
# 608
{ 
# 609
return _M_call(::std::forward< _Tp> (__object), &__object, ::std::forward< _Args> (__args)...); 
# 611
} 
# 614
template< class _Tp, class ..._Args, class _Req = ::std::_Require< is_base_of< typename _Mem_fn_traits< _MemFunPtr> ::__class_type, _Tp> , typename _Mem_fn_traits< _MemFunPtr> ::__lvalue, _CheckArgs< _Pack< _Args...> > > > result_type 
# 618
operator()(reference_wrapper< _Tp>  __ref, _Args &&...__args) const 
# 619
{ return operator()((__ref.get()), ::std::forward< _Args> (__args)...); } 
# 624
private: 
# 622
template< class _Tp, class ..._Args> result_type 
# 624
_M_call(_Tp &&__object, const volatile _Class *, _Args &&...
# 625
__args) const 
# 626
{ 
# 627
return (::std::forward< _Tp> (__object).*(_M_pmf))(::std::forward< _Args> (__args)...); 
# 629
} 
# 631
template< class _Tp, class ..._Args> result_type 
# 633
_M_call(_Tp &&__ptr, const volatile void *, _Args &&...__args) const 
# 634
{ return ((*__ptr).*(_M_pmf))(::std::forward< _Args> (__args)...); } 
# 636
_Pmf _M_pmf; 
# 637
}; 
# 640
template< class _Res, class _Class> 
# 641
class _Mem_fn_base< _Res (_Class::*), false>  { 
# 643
using __pm_type = _Res (_Class::*); 
# 648
template< class _Tp> auto 
# 650
_M_call(_Tp &&__object, const _Class *) const noexcept->__decltype((std::forward< _Tp> (__object).*std::declval< __pm_type &> ())) 
# 652
{ return std::forward< _Tp> (__object).*(_M_pm); } 
# 654
template< class _Tp, class _Up> auto 
# 656
_M_call(_Tp &&__object, _Up *const *) const noexcept->__decltype(((*std::forward< _Tp> (__object)).*std::declval< __pm_type &> ())) 
# 658
{ return (*std::forward< _Tp> (__object)).*(_M_pm); } 
# 660
template< class _Tp> auto 
# 662
_M_call(_Tp &&__ptr, const volatile void *) const noexcept(noexcept(((*__ptr).*std::declval< __pm_type &> ())))->__decltype(((*__ptr).*std::declval< __pm_type &> ())) 
# 665
{ return (*__ptr).*(_M_pm); } 
# 667
using _Arity = integral_constant< unsigned long, 0UL> ; 
# 668
using _Varargs = false_type; 
# 670
template< class _Func, class ..._BoundArgs> friend struct _Bind_check_arity; 
# 675
public: explicit _Mem_fn_base(_Res (_Class::*__pm)) noexcept : _M_pm(__pm) { } 
# 679
_Res &operator()(_Class &__object) const noexcept 
# 680
{ return __object.*(_M_pm); } 
# 683
const _Res &operator()(const _Class &__object) const noexcept 
# 684
{ return __object.*(_M_pm); } 
# 687
_Res &&operator()(_Class &&__object) const noexcept 
# 688
{ return std::forward< _Class> (__object).*(_M_pm); } 
# 691
const _Res &&operator()(const _Class &&__object) const noexcept 
# 692
{ return std::forward< const _Class> (__object).*(_M_pm); } 
# 696
_Res &operator()(_Class *__object) const noexcept 
# 697
{ return __object->*(_M_pm); } 
# 700
const _Res &operator()(const _Class *__object) const noexcept 
# 701
{ return __object->*(_M_pm); } 
# 704
template< class _Tp, class _Req = _Require< _NotSame< _Class *, _Tp> > > auto 
# 706
operator()(_Tp &&__unknown) const noexcept(noexcept((std::declval< std::_Mem_fn_base< _Res (_Class::*), false>  *> ()->_M_call(std::forward< _Tp> (__unknown), &__unknown))))->__decltype(((this->_M_call(std::forward< _Tp> (__unknown), &__unknown)))) 
# 710
{ return _M_call(std::forward< _Tp> (__unknown), &__unknown); } 
# 712
template< class _Tp, class _Req = _Require< is_base_of< _Class, _Tp> > > auto 
# 714
operator()(reference_wrapper< _Tp>  __ref) const noexcept(noexcept(std::declval< std::_Mem_fn_base< _Res (_Class::*), false>  &> ()((__ref.get()))))->__decltype(((*this)((__ref.get())))) 
# 717
{ return (*this)((__ref.get())); } 
# 720
private: _Res (_Class::*_M_pm); 
# 721
}; 
# 723
template< class _Res, class _Class> 
# 724
struct _Mem_fn< _Res (_Class::*)>  : public _Mem_fn_base< _Res (_Class::*)>  { 
# 727
using ::std::_Mem_fn_base< _Res (_Class::*)> ::_Mem_fn_base;
# 728
}; 
# 737 "/usr/include/c++/5/functional" 3
template< class _Tp, class _Class> inline _Mem_fn< _Tp (_Class::*)>  
# 739
mem_fn(_Tp (_Class::*__pm)) noexcept 
# 740
{ 
# 741
return ((_Mem_fn< _Tp (_Class::*)> )(__pm)); 
# 742
} 
# 750
template< class _Tp> 
# 751
struct is_bind_expression : public false_type { 
# 752
}; 
# 759
template< class _Tp> 
# 760
struct is_placeholder : public integral_constant< int, 0>  { 
# 762
}; 
# 767
template< int _Num> struct _Placeholder { }; 
# 775
namespace placeholders { 
# 782
extern const _Placeholder< 1>  _1; 
# 783
extern const _Placeholder< 2>  _2; 
# 784
extern const _Placeholder< 3>  _3; 
# 785
extern const _Placeholder< 4>  _4; 
# 786
extern const _Placeholder< 5>  _5; 
# 787
extern const _Placeholder< 6>  _6; 
# 788
extern const _Placeholder< 7>  _7; 
# 789
extern const _Placeholder< 8>  _8; 
# 790
extern const _Placeholder< 9>  _9; 
# 791
extern const _Placeholder< 10>  _10; 
# 792
extern const _Placeholder< 11>  _11; 
# 793
extern const _Placeholder< 12>  _12; 
# 794
extern const _Placeholder< 13>  _13; 
# 795
extern const _Placeholder< 14>  _14; 
# 796
extern const _Placeholder< 15>  _15; 
# 797
extern const _Placeholder< 16>  _16; 
# 798
extern const _Placeholder< 17>  _17; 
# 799
extern const _Placeholder< 18>  _18; 
# 800
extern const _Placeholder< 19>  _19; 
# 801
extern const _Placeholder< 20>  _20; 
# 802
extern const _Placeholder< 21>  _21; 
# 803
extern const _Placeholder< 22>  _22; 
# 804
extern const _Placeholder< 23>  _23; 
# 805
extern const _Placeholder< 24>  _24; 
# 806
extern const _Placeholder< 25>  _25; 
# 807
extern const _Placeholder< 26>  _26; 
# 808
extern const _Placeholder< 27>  _27; 
# 809
extern const _Placeholder< 28>  _28; 
# 810
extern const _Placeholder< 29>  _29; 
# 812
}
# 821
template< int _Num> 
# 822
struct is_placeholder< _Placeholder< _Num> >  : public integral_constant< int, _Num>  { 
# 824
}; 
# 826
template< int _Num> 
# 827
struct is_placeholder< const _Placeholder< _Num> >  : public integral_constant< int, _Num>  { 
# 829
}; 
# 835
struct _No_tuple_element; 
# 842
template< size_t __i, class _Tuple, bool _IsSafe> 
# 843
struct _Safe_tuple_element_impl : public tuple_element< __i, _Tuple>  { 
# 844
}; 
# 851
template< size_t __i, class _Tuple> 
# 852
struct _Safe_tuple_element_impl< __i, _Tuple, false>  { 
# 854
typedef _No_tuple_element type; 
# 855
}; 
# 861
template< size_t __i, class _Tuple> 
# 862
struct _Safe_tuple_element : public _Safe_tuple_element_impl< __i, _Tuple, __i < tuple_size< _Tuple> ::value>  { 
# 865
}; 
# 878 "/usr/include/c++/5/functional" 3
template< class _Arg, bool 
# 879
_IsBindExp = is_bind_expression< _Arg> ::value, bool 
# 880
_IsPlaceholder = (is_placeholder< _Arg> ::value > 0)> class _Mu; 
# 887
template< class _Tp> 
# 888
class _Mu< reference_wrapper< _Tp> , false, false>  { 
# 891
public: typedef _Tp &result_type; 
# 897
template< class _CVRef, class _Tuple> result_type 
# 899
operator()(_CVRef &__arg, _Tuple &) const volatile 
# 900
{ return (__arg.get()); } 
# 901
}; 
# 908
template< class _Arg> 
# 909
class _Mu< _Arg, true, false>  { 
# 914
public: 
# 912
template< class _CVArg, class ..._Args> auto 
# 914
operator()(_CVArg &__arg, tuple< _Args...>  &
# 915
__tuple) const volatile->__decltype((__arg(declval< _Args> ()...))) 
# 917
{ 
# 920
typedef typename _Build_index_tuple< sizeof...(_Args)> ::__type _Indexes; 
# 921
return (this->__call(__arg, __tuple, _Indexes())); 
# 922
} 
# 929
private: 
# 927
template< class _CVArg, class ..._Args, size_t ..._Indexes> auto 
# 929
__call(_CVArg &__arg, tuple< _Args...>  &__tuple, const _Index_tuple< _Indexes...>  &) const volatile->__decltype((__arg(declval< _Args> ()...))) 
# 932
{ 
# 933
return __arg(std::forward< _Args> (std::get< _Indexes> (__tuple))...); 
# 934
} 
# 935
}; 
# 942
template< class _Arg> 
# 943
class _Mu< _Arg, false, true>  { 
# 946
public: template< class _Signature> class result; 
# 948
template< class _CVMu, class _CVArg, class _Tuple> 
# 949
class result< _CVMu (_CVArg, _Tuple)>  { 
# 956
typedef typename _Safe_tuple_element< is_placeholder< _Arg> ::value - 1, _Tuple> ::type __base_type; 
# 959
public: typedef typename add_rvalue_reference< typename _Safe_tuple_element< is_placeholder< _Arg> ::value - 1, _Tuple> ::type> ::type type; 
# 960
}; 
# 962
template< class _Tuple> typename result< std::_Mu< _Arg, false, true>  (_Arg, _Tuple)> ::type 
# 964
operator()(const volatile _Arg &, _Tuple &__tuple) const volatile 
# 965
{ 
# 966
return std::forward< typename result< std::_Mu< _Arg, false, true>  (_Arg, _Tuple)> ::type> (std::get< is_placeholder< _Arg> ::value - 1> (__tuple)); 
# 968
} 
# 969
}; 
# 976
template< class _Arg> 
# 977
class _Mu< _Arg, false, false>  { 
# 980
public: template< class _Signature> struct result; 
# 982
template< class _CVMu, class _CVArg, class _Tuple> 
# 983
struct result< _CVMu (_CVArg, _Tuple)>  { 
# 985
typedef typename add_lvalue_reference< _CVArg> ::type type; 
# 986
}; 
# 989
template< class _CVArg, class _Tuple> _CVArg &&
# 991
operator()(_CVArg &&__arg, _Tuple &) const volatile 
# 992
{ return std::forward< _CVArg> (__arg); } 
# 993
}; 
# 1000
template< class _Tp> 
# 1001
struct _Maybe_wrap_member_pointer { 
# 1003
typedef _Tp type; 
# 1006
static const _Tp &__do_wrap(const _Tp &__x) 
# 1007
{ return __x; } 
# 1010
static _Tp &&__do_wrap(_Tp &&__x) 
# 1011
{ return static_cast< _Tp &&>(__x); } 
# 1012
}; 
# 1019
template< class _Tp, class _Class> 
# 1020
struct _Maybe_wrap_member_pointer< _Tp (_Class::*)>  { 
# 1022
typedef _Mem_fn< _Tp (_Class::*)>  type; 
# 1025
static type __do_wrap(_Tp (_Class::*__pm)) 
# 1026
{ return ((type)(__pm)); } 
# 1027
}; 
# 1034
template<> struct _Maybe_wrap_member_pointer< void>  { 
# 1036
typedef void type; 
# 1037
}; 
# 1040
template< size_t _Ind, class ..._Tp> inline auto 
# 1042
__volget(volatile tuple< _Tp...>  &__tuple)->volatile __tuple_element_t< _Ind, tuple< _Tp...> >  & 
# 1044
{ return std::get< _Ind> (const_cast< tuple< _Tp...>  &>(__tuple)); } 
# 1047
template< size_t _Ind, class ..._Tp> inline auto 
# 1049
__volget(const volatile tuple< _Tp...>  &__tuple)->const volatile __tuple_element_t< _Ind, tuple< _Tp...> >  & 
# 1051
{ return std::get< _Ind> (const_cast< const tuple< _Tp...>  &>(__tuple)); } 
# 1054
template< class _Signature> struct _Bind; 
# 1057
template< class _Functor, class ..._Bound_args> 
# 1058
class _Bind< _Functor (_Bound_args ...)>  : public _Weak_result_type< _Functor>  { 
# 1061
typedef ::std::_Bind< _Functor (_Bound_args ...)>  __self_type; 
# 1063
typedef typename _Build_index_tuple< sizeof...(_Bound_args)> ::__type _Bound_indexes; 
# 1065
_Functor _M_f; 
# 1066
tuple< _Bound_args...>  _M_bound_args; 
# 1069
template< class _Result, class ..._Args, ::std::size_t ..._Indexes> _Result 
# 1071
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) 
# 1072
{ 
# 1073
return (_M_f)(_Mu< _Bound_args> ()(::std::get< _Indexes> (_M_bound_args), __args)...); 
# 1075
} 
# 1078
template< class _Result, class ..._Args, ::std::size_t ..._Indexes> _Result 
# 1080
__call_c(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) const 
# 1081
{ 
# 1082
return (_M_f)(_Mu< _Bound_args> ()(::std::get< _Indexes> (_M_bound_args), __args)...); 
# 1084
} 
# 1087
template< class _Result, class ..._Args, ::std::size_t ..._Indexes> _Result 
# 1089
__call_v(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) volatile 
# 1091
{ 
# 1092
return (_M_f)(_Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 1094
} 
# 1097
template< class _Result, class ..._Args, ::std::size_t ..._Indexes> _Result 
# 1099
__call_c_v(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) const volatile 
# 1101
{ 
# 1102
return (_M_f)(_Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 1104
} 
# 1108
public: 
# 1107
template< class ..._Args> explicit 
# 1108
_Bind(const _Functor &__f, _Args &&...__args) : _M_f(__f), _M_bound_args(::std::forward< _Args> (__args)...) 
# 1110
{ } 
# 1112
template< class ..._Args> explicit 
# 1113
_Bind(_Functor &&__f, _Args &&...__args) : _M_f(::std::move(__f)), _M_bound_args(::std::forward< _Args> (__args)...) 
# 1115
{ } 
# 1117
_Bind(const ::std::_Bind< _Functor (_Bound_args ...)>  &) = default;
# 1119
_Bind(::std::_Bind< _Functor (_Bound_args ...)>  &&__b) : _M_f(::std::move((__b._M_f))), _M_bound_args(::std::move((__b._M_bound_args))) 
# 1121
{ } 
# 1124
template< class ..._Args, class _Result = __decltype((::std::declval< _Functor &> ()(_Mu< _Bound_args> ()(::std::declval< _Bound_args &> (), ::std::declval< tuple< _Args...>  &> ())...)))> _Result 
# 1129
operator()(_Args &&...__args) 
# 1130
{ 
# 1131
return (this->template __call< _Result> (::std::forward_as_tuple(::std::forward< _Args> (__args)...), _Bound_indexes())); 
# 1134
} 
# 1137
template< class ..._Args, class _Result = __decltype((::std::declval< typename enable_if< sizeof...(_Args) >= (0), typename add_const< _Functor> ::type &> ::type> ()(_Mu< _Bound_args> ()(::std::declval< const _Bound_args &> (), ::std::declval< tuple< _Args...>  &> ())...)))> _Result 
# 1143
operator()(_Args &&...__args) const 
# 1144
{ 
# 1145
return (this->template __call_c< _Result> (::std::forward_as_tuple(::std::forward< _Args> (__args)...), _Bound_indexes())); 
# 1148
} 
# 1151
template< class ..._Args, class _Result = __decltype((::std::declval< typename enable_if< sizeof...(_Args) >= (0), typename add_volatile< _Functor> ::type &> ::type> ()(_Mu< _Bound_args> ()(::std::declval< volatile _Bound_args &> (), ::std::declval< tuple< _Args...>  &> ())...)))> _Result 
# 1157
operator()(_Args &&...__args) volatile 
# 1158
{ 
# 1159
return (this->template __call_v< _Result> (::std::forward_as_tuple(::std::forward< _Args> (__args)...), _Bound_indexes())); 
# 1162
} 
# 1165
template< class ..._Args, class _Result = __decltype((::std::declval< typename enable_if< sizeof...(_Args) >= (0), typename add_cv< _Functor> ::type &> ::type> ()(_Mu< _Bound_args> ()(::std::declval< const volatile _Bound_args &> (), ::std::declval< tuple< _Args...>  &> ())...)))> _Result 
# 1171
operator()(_Args &&...__args) const volatile 
# 1172
{ 
# 1173
return (this->template __call_c_v< _Result> (::std::forward_as_tuple(::std::forward< _Args> (__args)...), _Bound_indexes())); 
# 1176
} 
# 1177
}; 
# 1180
template< class _Result, class _Signature> struct _Bind_result; 
# 1183
template< class _Result, class _Functor, class ..._Bound_args> 
# 1184
class _Bind_result< _Result, _Functor (_Bound_args ...)>  { 
# 1186
typedef std::_Bind_result< _Result, _Functor (_Bound_args ...)>  __self_type; 
# 1188
typedef typename _Build_index_tuple< sizeof...(_Bound_args)> ::__type _Bound_indexes; 
# 1190
_Functor _M_f; 
# 1191
tuple< _Bound_args...>  _M_bound_args; 
# 1194
template< class _Res> 
# 1195
struct __enable_if_void : public enable_if< is_void< _Res> ::value, int>  { }; 
# 1196
template< class _Res> 
# 1197
struct __disable_if_void : public enable_if< !is_void< _Res> ::value, int>  { }; 
# 1200
template< class _Res, class ..._Args, size_t ..._Indexes> _Result 
# 1202
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> , typename __disable_if_void< _Res> ::type = 0) 
# 1204
{ 
# 1205
return (_M_f)(_Mu< _Bound_args> ()(std::get< _Indexes> (_M_bound_args), __args)...); 
# 1207
} 
# 1210
template< class _Res, class ..._Args, size_t ..._Indexes> void 
# 1212
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> , typename __enable_if_void< _Res> ::type = 0) 
# 1214
{ 
# 1215
(_M_f)(_Mu< _Bound_args> ()(std::get< _Indexes> (_M_bound_args), __args)...); 
# 1217
} 
# 1220
template< class _Res, class ..._Args, size_t ..._Indexes> _Result 
# 1222
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> , typename __disable_if_void< _Res> ::type = 0) const 
# 1224
{ 
# 1225
return (_M_f)(_Mu< _Bound_args> ()(std::get< _Indexes> (_M_bound_args), __args)...); 
# 1227
} 
# 1230
template< class _Res, class ..._Args, size_t ..._Indexes> void 
# 1232
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> , typename __enable_if_void< _Res> ::type = 0) const 
# 1234
{ 
# 1235
(_M_f)(_Mu< _Bound_args> ()(std::get< _Indexes> (_M_bound_args), __args)...); 
# 1237
} 
# 1240
template< class _Res, class ..._Args, size_t ..._Indexes> _Result 
# 1242
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> , typename __disable_if_void< _Res> ::type = 0) volatile 
# 1244
{ 
# 1245
return (_M_f)(_Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 1247
} 
# 1250
template< class _Res, class ..._Args, size_t ..._Indexes> void 
# 1252
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> , typename __enable_if_void< _Res> ::type = 0) volatile 
# 1254
{ 
# 1255
(_M_f)(_Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 1257
} 
# 1260
template< class _Res, class ..._Args, size_t ..._Indexes> _Result 
# 1262
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> , typename __disable_if_void< _Res> ::type = 0) const volatile 
# 1264
{ 
# 1265
return (_M_f)(_Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 1267
} 
# 1270
template< class _Res, class ..._Args, size_t ..._Indexes> void 
# 1272
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> , typename __enable_if_void< _Res> ::type = 0) const volatile 
# 1275
{ 
# 1276
(_M_f)(_Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 1278
} 
# 1281
public: typedef _Result result_type; 
# 1283
template< class ..._Args> explicit 
# 1284
_Bind_result(const _Functor &__f, _Args &&...__args) : _M_f(__f), _M_bound_args(std::forward< _Args> (__args)...) 
# 1286
{ } 
# 1288
template< class ..._Args> explicit 
# 1289
_Bind_result(_Functor &&__f, _Args &&...__args) : _M_f(std::move(__f)), _M_bound_args(std::forward< _Args> (__args)...) 
# 1291
{ } 
# 1293
_Bind_result(const std::_Bind_result< _Result, _Functor (_Bound_args ...)>  &) = default;
# 1295
_Bind_result(std::_Bind_result< _Result, _Functor (_Bound_args ...)>  &&__b) : _M_f(std::move((__b._M_f))), _M_bound_args(std::move((__b._M_bound_args))) 
# 1297
{ } 
# 1300
template< class ..._Args> result_type 
# 1302
operator()(_Args &&...__args) 
# 1303
{ 
# 1304
return (this->template __call< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes())); 
# 1307
} 
# 1310
template< class ..._Args> result_type 
# 1312
operator()(_Args &&...__args) const 
# 1313
{ 
# 1314
return (this->template __call< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes())); 
# 1317
} 
# 1320
template< class ..._Args> result_type 
# 1322
operator()(_Args &&...__args) volatile 
# 1323
{ 
# 1324
return (this->template __call< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes())); 
# 1327
} 
# 1330
template< class ..._Args> result_type 
# 1332
operator()(_Args &&...__args) const volatile 
# 1333
{ 
# 1334
return (this->template __call< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes())); 
# 1337
} 
# 1338
}; 
# 1344
template< class _Signature> 
# 1345
struct is_bind_expression< _Bind< _Signature> >  : public true_type { 
# 1346
}; 
# 1352
template< class _Signature> 
# 1353
struct is_bind_expression< const _Bind< _Signature> >  : public true_type { 
# 1354
}; 
# 1360
template< class _Signature> 
# 1361
struct is_bind_expression< volatile _Bind< _Signature> >  : public true_type { 
# 1362
}; 
# 1368
template< class _Signature> 
# 1369
struct is_bind_expression< const volatile _Bind< _Signature> >  : public true_type { 
# 1370
}; 
# 1376
template< class _Result, class _Signature> 
# 1377
struct is_bind_expression< _Bind_result< _Result, _Signature> >  : public true_type { 
# 1378
}; 
# 1384
template< class _Result, class _Signature> 
# 1385
struct is_bind_expression< const _Bind_result< _Result, _Signature> >  : public true_type { 
# 1386
}; 
# 1392
template< class _Result, class _Signature> 
# 1393
struct is_bind_expression< volatile _Bind_result< _Result, _Signature> >  : public true_type { 
# 1394
}; 
# 1400
template< class _Result, class _Signature> 
# 1401
struct is_bind_expression< const volatile _Bind_result< _Result, _Signature> >  : public true_type { 
# 1402
}; 
# 1404
template< class _Func, class ..._BoundArgs> 
# 1405
struct _Bind_check_arity { }; 
# 1407
template< class _Ret, class ..._Args, class ..._BoundArgs> 
# 1408
struct _Bind_check_arity< _Ret (*)(_Args ...), _BoundArgs...>  { 
# 1410
static_assert((sizeof...(_BoundArgs) == sizeof...(_Args)), "Wrong number of arguments for function");
# 1412
}; 
# 1414
template< class _Ret, class ..._Args, class ..._BoundArgs> 
# 1415
struct _Bind_check_arity< _Ret (*)(_Args ..., ...), _BoundArgs...>  { 
# 1417
static_assert((sizeof...(_BoundArgs) >= sizeof...(_Args)), "Wrong number of arguments for function");
# 1419
}; 
# 1421
template< class _Tp, class _Class, class ..._BoundArgs> 
# 1422
struct _Bind_check_arity< _Tp (_Class::*), _BoundArgs...>  { 
# 1424
using _Arity = typename _Mem_fn< _Tp (_Class::*)> ::_Arity; 
# 1425
using _Varargs = typename _Mem_fn< _Tp (_Class::*)> ::_Varargs; 
# 1426
static_assert(((_Varargs::value) ? sizeof...(_BoundArgs) >= (_Arity::value + 1) : (sizeof...(_BoundArgs) == (_Arity::value + 1))), "Wrong number of arguments for pointer-to-member");
# 1430
}; 
# 1435
template< class _Tp, class _Tp2 = typename decay< _Tp> ::type> using __is_socketlike = __or_< is_integral< _Tp2> , is_enum< _Tp2> > ; 
# 1438
template< bool _SocketLike, class _Func, class ..._BoundArgs> 
# 1439
struct _Bind_helper : public _Bind_check_arity< typename decay< _Func> ::type, _BoundArgs...>  { 
# 1443
typedef _Maybe_wrap_member_pointer< typename decay< _Func> ::type>  __maybe_type; 
# 1444
typedef typename _Maybe_wrap_member_pointer< typename decay< _Func> ::type> ::type __func_type; 
# 1445
typedef _Bind< typename _Maybe_wrap_member_pointer< typename decay< _Func> ::type> ::type (typename decay< _BoundArgs> ::type ...)>  type; 
# 1446
}; 
# 1451
template< class _Func, class ..._BoundArgs> 
# 1452
struct _Bind_helper< true, _Func, _BoundArgs...>  { 
# 1453
}; 
# 1459
template< class _Func, class ..._BoundArgs> inline typename _Bind_helper< __or_< is_integral< typename decay< _Func> ::type> , is_enum< typename decay< _Func> ::type> > ::value, _Func, _BoundArgs...> ::type 
# 1462
bind(_Func &&__f, _BoundArgs &&...__args) 
# 1463
{ 
# 1464
typedef _Bind_helper< false, _Func, _BoundArgs...>  __helper_type; 
# 1465
typedef typename _Bind_helper< false, _Func, _BoundArgs...> ::__maybe_type __maybe_type; 
# 1466
typedef typename _Bind_helper< false, _Func, _BoundArgs...> ::type __result_type; 
# 1467
return __result_type(__maybe_type::__do_wrap(std::forward< _Func> (__f)), std::forward< _BoundArgs> (__args)...); 
# 1469
} 
# 1471
template< class _Result, class _Func, class ..._BoundArgs> 
# 1472
struct _Bindres_helper : public _Bind_check_arity< typename decay< _Func> ::type, _BoundArgs...>  { 
# 1476
typedef _Maybe_wrap_member_pointer< typename decay< _Func> ::type>  __maybe_type; 
# 1477
typedef typename _Maybe_wrap_member_pointer< typename decay< _Func> ::type> ::type __functor_type; 
# 1480
typedef _Bind_result< _Result, typename _Maybe_wrap_member_pointer< typename decay< _Func> ::type> ::type (typename decay< _BoundArgs> ::type ...)>  type; 
# 1481
}; 
# 1487
template< class _Result, class _Func, class ..._BoundArgs> inline typename _Bindres_helper< _Result, _Func, _BoundArgs...> ::type 
# 1490
bind(_Func &&__f, _BoundArgs &&...__args) 
# 1491
{ 
# 1492
typedef _Bindres_helper< _Result, _Func, _BoundArgs...>  __helper_type; 
# 1493
typedef typename _Bindres_helper< _Result, _Func, _BoundArgs...> ::__maybe_type __maybe_type; 
# 1494
typedef typename _Bindres_helper< _Result, _Func, _BoundArgs...> ::type __result_type; 
# 1495
return __result_type(__maybe_type::__do_wrap(std::forward< _Func> (__f)), std::forward< _BoundArgs> (__args)...); 
# 1497
} 
# 1499
template< class _Signature> struct _Bind_simple; 
# 1502
template< class _Callable, class ..._Args> 
# 1503
struct _Bind_simple< _Callable (_Args ...)>  { 
# 1505
typedef typename result_of< _Callable (_Args ...)> ::type result_type; 
# 1507
template< class _Tp, class ..._Up> explicit 
# 1509
_Bind_simple(_Tp &&__f, _Up &&...__args) : _M_bound(std::forward< _Tp> (__f), std::forward< _Up> (__args)...) 
# 1511
{ } 
# 1513
_Bind_simple(const std::_Bind_simple< _Callable (_Args ...)>  &) = default;
# 1514
_Bind_simple(std::_Bind_simple< _Callable (_Args ...)>  &&) = default;
# 1517
result_type operator()() 
# 1518
{ 
# 1519
typedef typename _Build_index_tuple< sizeof...(_Args)> ::__type _Indices; 
# 1520
return _M_invoke(_Indices()); 
# 1521
} 
# 1526
private: 
# 1524
template< size_t ..._Indices> typename result_of< _Callable (_Args ...)> ::type 
# 1526
_M_invoke(_Index_tuple< _Indices...> ) 
# 1527
{ 
# 1530
return std::forward< _Callable> (std::get< 0> (_M_bound))(std::forward< _Args> (std::get< _Indices + (1)> (_M_bound))...); 
# 1532
} 
# 1534
tuple< _Callable, _Args...>  _M_bound; 
# 1535
}; 
# 1537
template< class _Func, class ..._BoundArgs> 
# 1538
struct _Bind_simple_helper : public _Bind_check_arity< typename decay< _Func> ::type, _BoundArgs...>  { 
# 1542
typedef _Maybe_wrap_member_pointer< typename decay< _Func> ::type>  __maybe_type; 
# 1543
typedef typename _Maybe_wrap_member_pointer< typename decay< _Func> ::type> ::type __func_type; 
# 1545
typedef _Bind_simple< typename _Maybe_wrap_member_pointer< typename decay< _Func> ::type> ::type (typename decay< _BoundArgs> ::type ...)>  __type; 
# 1546
}; 
# 1550
template< class _Callable, class ..._Args> typename _Bind_simple_helper< _Callable, _Args...> ::__type 
# 1552
__bind_simple(_Callable &&__callable, _Args &&...__args) 
# 1553
{ 
# 1554
typedef _Bind_simple_helper< _Callable, _Args...>  __helper_type; 
# 1555
typedef typename _Bind_simple_helper< _Callable, _Args...> ::__maybe_type __maybe_type; 
# 1556
typedef typename _Bind_simple_helper< _Callable, _Args...> ::__type __result_type; 
# 1557
return __result_type(__maybe_type::__do_wrap(std::forward< _Callable> (__callable)), std::forward< _Args> (__args)...); 
# 1560
} 
# 1567
class bad_function_call : public exception { 
# 1570
public: virtual ~bad_function_call() noexcept; 
# 1572
virtual const char *what() const noexcept; 
# 1573
}; 
# 1581
template< class _Tp> 
# 1582
struct __is_location_invariant : public is_trivially_copyable< _Tp> ::type { 
# 1584
}; 
# 1586
class _Undefined_class; 
# 1588
union _Nocopy_types { 
# 1590
void *_M_object; 
# 1591
const void *_M_const_object; 
# 1592
void (*_M_function_pointer)(void); 
# 1593
void (_Undefined_class::*_M_member_pointer)(void); 
# 1594
}; 
# 1596
union _Any_data { 
# 1598
void *_M_access() { return &((_M_pod_data)[0]); } 
# 1599
const void *_M_access() const { return &((_M_pod_data)[0]); } 
# 1601
template< class _Tp> _Tp &
# 1603
_M_access() 
# 1604
{ return *(static_cast< _Tp *>(this->_M_access())); } 
# 1606
template< class _Tp> const _Tp &
# 1608
_M_access() const 
# 1609
{ return *(static_cast< const _Tp *>(this->_M_access())); } 
# 1611
_Nocopy_types _M_unused; 
# 1612
char _M_pod_data[sizeof(_Nocopy_types)]; 
# 1613
}; 
# 1615
enum _Manager_operation { 
# 1617
__get_type_info, 
# 1618
__get_functor_ptr, 
# 1619
__clone_functor, 
# 1620
__destroy_functor
# 1621
}; 
# 1625
template< class _Tp> 
# 1626
struct _Simple_type_wrapper { 
# 1628
_Simple_type_wrapper(_Tp __value) : __value(__value) { } 
# 1630
_Tp __value; 
# 1631
}; 
# 1633
template< class _Tp> 
# 1634
struct __is_location_invariant< _Simple_type_wrapper< _Tp> >  : public __is_location_invariant< _Tp>  { 
# 1636
}; 
# 1640
template< class _Functor> inline _Functor &
# 1642
__callable_functor(_Functor &__f) 
# 1643
{ return __f; } 
# 1645
template< class _Member, class _Class> inline _Mem_fn< _Member (_Class::*)>  
# 1647
__callable_functor(_Member (_Class::*&__p)) 
# 1648
{ return std::mem_fn(__p); } 
# 1650
template< class _Member, class _Class> inline _Mem_fn< _Member (_Class::*)>  
# 1652
__callable_functor(_Member (_Class::*const &__p)) 
# 1653
{ return std::mem_fn(__p); } 
# 1655
template< class _Member, class _Class> inline _Mem_fn< _Member (_Class::*)>  
# 1657
__callable_functor(_Member (_Class::*volatile &__p)) 
# 1658
{ return std::mem_fn(__p); } 
# 1660
template< class _Member, class _Class> inline _Mem_fn< _Member (_Class::*)>  
# 1662
__callable_functor(_Member (_Class::*const volatile &__p)) 
# 1663
{ return std::mem_fn(__p); } 
# 1665
template< class _Signature> class function; 
# 1669
class _Function_base { 
# 1672
public: static const size_t _M_max_size = sizeof(_Nocopy_types); 
# 1673
static const size_t _M_max_align = __alignof__(_Nocopy_types); 
# 1675
template< class _Functor> 
# 1676
class _Base_manager { 
# 1679
protected: static const bool __stored_locally = (__is_location_invariant< _Functor> ::value && (sizeof(_Functor) <= _M_max_size) && (__alignof__(_Functor) <= _M_max_align) && ((_M_max_align % __alignof__(_Functor)) == (0))); 
# 1685
typedef integral_constant< bool, __stored_locally>  _Local_storage; 
# 1689
static _Functor *_M_get_pointer(const _Any_data &__source) 
# 1690
{ 
# 1691
const _Functor *__ptr = __stored_locally ? std::__addressof((__source.template _M_access< _Functor> ())) : (__source.template _M_access< _Functor *> ()); 
# 1694
return const_cast< _Functor *>(__ptr); 
# 1695
} 
# 1700
static void _M_clone(_Any_data &__dest, const _Any_data &__source, true_type) 
# 1701
{ 
# 1702
new (__dest._M_access()) (_Functor)((__source.template _M_access< _Functor> ())); 
# 1703
} 
# 1708
static void _M_clone(_Any_data &__dest, const _Any_data &__source, false_type) 
# 1709
{ 
# 1710
(__dest.template _M_access< _Functor *> ()) = (new (_Functor)(*(__source.template _M_access< _Functor *> ()))); 
# 1712
} 
# 1717
static void _M_destroy(_Any_data &__victim, true_type) 
# 1718
{ 
# 1719
((__victim.template _M_access< _Functor> ()).~_Functor()); 
# 1720
} 
# 1724
static void _M_destroy(_Any_data &__victim, false_type) 
# 1725
{ 
# 1726
delete (__victim.template _M_access< _Functor *> ()); 
# 1727
} 
# 1731
public: static bool _M_manager(_Any_data &__dest, const _Any_data &__source, _Manager_operation 
# 1732
__op) 
# 1733
{ 
# 1734
switch (__op) 
# 1735
{ 
# 1737
case __get_type_info:  
# 1738
__dest.template _M_access< const type_info *> () = (&typeid(_Functor)); 
# 1739
break; 
# 1741
case __get_functor_ptr:  
# 1742
(__dest.template _M_access< _Functor *> ()) = (_M_get_pointer)(__source); 
# 1743
break; 
# 1745
case __clone_functor:  
# 1746
_M_clone(__dest, __source, _Local_storage()); 
# 1747
break; 
# 1749
case __destroy_functor:  
# 1750
_M_destroy(__dest, _Local_storage()); 
# 1751
break; 
# 1752
}  
# 1753
return false; 
# 1754
} 
# 1757
static void _M_init_functor(_Any_data &__functor, _Functor &&__f) 
# 1758
{ _M_init_functor(__functor, std::move(__f), _Local_storage()); } 
# 1760
template< class _Signature> static bool 
# 1762
_M_not_empty_function(const function< _Signature>  &__f) 
# 1763
{ return static_cast< bool>(__f); } 
# 1765
template< class _Tp> static bool 
# 1767
_M_not_empty_function(_Tp *const &__fp) 
# 1768
{ return __fp; } 
# 1770
template< class _Class, class _Tp> static bool 
# 1772
_M_not_empty_function(_Tp (_Class::*const &__mp)) 
# 1773
{ return __mp; } 
# 1775
template< class _Tp> static bool 
# 1777
_M_not_empty_function(const _Tp &) 
# 1778
{ return true; } 
# 1782
private: static void _M_init_functor(_Any_data &__functor, _Functor &&__f, true_type) 
# 1783
{ new (__functor._M_access()) (_Functor)(std::move(__f)); } 
# 1786
static void _M_init_functor(_Any_data &__functor, _Functor &&__f, false_type) 
# 1787
{ (__functor.template _M_access< _Functor *> ()) = (new (_Functor)(std::move(__f))); } 
# 1788
}; 
# 1790
template< class _Functor> 
# 1791
class _Ref_manager : public _Base_manager< _Functor *>  { 
# 1793
typedef typename ::std::_Function_base::template _Base_manager< _Functor *>  _Base; 
# 1797
public: static bool _M_manager(::std::_Any_data &__dest, const ::std::_Any_data &__source, ::std::_Manager_operation 
# 1798
__op) 
# 1799
{ 
# 1800
switch (__op) 
# 1801
{ 
# 1803
case __get_type_info:  
# 1804
__dest.template _M_access< const ::std::type_info *> () = (&typeid(_Functor)); 
# 1805
break; 
# 1807
case __get_functor_ptr:  
# 1808
(__dest.template _M_access< _Functor *> ()) = (*_Base::_M_get_pointer(__source)); 
# 1809
return is_const< _Functor> ::value; 
# 1810
break; 
# 1812
default:  
# 1813
_Base::_M_manager(__dest, __source, __op); 
# 1814
}  
# 1815
return false; 
# 1816
} 
# 1819
static void _M_init_functor(::std::_Any_data &__functor, reference_wrapper< _Functor>  __f) 
# 1820
{ 
# 1821
_Base::_M_init_functor(__functor, ::std::__addressof((__f.get()))); 
# 1822
} 
# 1823
}; 
# 1825
_Function_base() : _M_manager((nullptr)) { } 
# 1827
~_Function_base() 
# 1828
{ 
# 1829
if (_M_manager) { 
# 1830
(_M_manager)(_M_functor, _M_functor, __destroy_functor); }  
# 1831
} 
# 1834
bool _M_empty() const { return !(_M_manager); } 
# 1836
typedef bool (*_Manager_type)(_Any_data &, const _Any_data &, _Manager_operation); 
# 1839
_Any_data _M_functor; 
# 1840
_Manager_type _M_manager; 
# 1841
}; 
# 1843
template< class _Signature, class _Functor> class _Function_handler; 
# 1846
template< class _Res, class _Functor, class ..._ArgTypes> 
# 1847
class _Function_handler< _Res (_ArgTypes ...), _Functor>  : public _Function_base::_Base_manager< _Functor>  { 
# 1850
typedef typename ::std::_Function_base::template _Base_manager< _Functor>  _Base; 
# 1854
public: static _Res _M_invoke(const ::std::_Any_data &__functor, _ArgTypes &&...__args) 
# 1855
{ 
# 1856
return (*_Base::_M_get_pointer(__functor))(::std::forward< _ArgTypes> (__args)...); 
# 1858
} 
# 1859
}; 
# 1861
template< class _Functor, class ..._ArgTypes> 
# 1862
class _Function_handler< void (_ArgTypes ...), _Functor>  : public _Function_base::_Base_manager< _Functor>  { 
# 1865
typedef typename ::std::_Function_base::template _Base_manager< _Functor>  _Base; 
# 1869
public: static void _M_invoke(const ::std::_Any_data &__functor, _ArgTypes &&...__args) 
# 1870
{ 
# 1871
(*_Base::_M_get_pointer(__functor))(::std::forward< _ArgTypes> (__args)...); 
# 1873
} 
# 1874
}; 
# 1876
template< class _Res, class _Functor, class ..._ArgTypes> 
# 1877
class _Function_handler< _Res (_ArgTypes ...), reference_wrapper< _Functor> >  : public _Function_base::_Ref_manager< _Functor>  { 
# 1880
typedef typename ::std::_Function_base::template _Ref_manager< _Functor>  _Base; 
# 1884
public: static _Res _M_invoke(const ::std::_Any_data &__functor, _ArgTypes &&...__args) 
# 1885
{ 
# 1886
return ::std::__callable_functor(*(*_Base::_M_get_pointer(__functor)))(::std::forward< _ArgTypes> (__args)...); 
# 1888
} 
# 1889
}; 
# 1891
template< class _Functor, class ..._ArgTypes> 
# 1892
class _Function_handler< void (_ArgTypes ...), reference_wrapper< _Functor> >  : public _Function_base::_Ref_manager< _Functor>  { 
# 1895
typedef typename ::std::_Function_base::template _Ref_manager< _Functor>  _Base; 
# 1899
public: static void _M_invoke(const ::std::_Any_data &__functor, _ArgTypes &&...__args) 
# 1900
{ 
# 1901
::std::__callable_functor(*(*_Base::_M_get_pointer(__functor)))(::std::forward< _ArgTypes> (__args)...); 
# 1903
} 
# 1904
}; 
# 1906
template< class _Class, class _Member, class _Res, class ...
# 1907
_ArgTypes> 
# 1908
class _Function_handler< _Res (_ArgTypes ...), _Member (_Class::*)>  : public _Function_handler< void (_ArgTypes ...), _Member (_Class::*)>  { 
# 1912
typedef ::std::_Function_handler< void (_ArgTypes ...), _Member (_Class::*)>  _Base; 
# 1916
public: static _Res _M_invoke(const ::std::_Any_data &__functor, _ArgTypes &&...__args) 
# 1917
{ 
# 1918
return ::std::mem_fn((_Base::_M_get_pointer(__functor)->__value))(::std::forward< _ArgTypes> (__args)...); 
# 1920
} 
# 1921
}; 
# 1923
template< class _Class, class _Member, class ..._ArgTypes> 
# 1924
class _Function_handler< void (_ArgTypes ...), _Member (_Class::*)>  : public _Function_base::_Base_manager< _Simple_type_wrapper< _Member (_Class::*)> >  { 
# 1928
typedef _Member (_Class::*_Functor); 
# 1929
typedef _Simple_type_wrapper< _Member (_Class::*)>  _Wrapper; 
# 1930
typedef typename ::std::_Function_base::template _Base_manager< _Simple_type_wrapper< _Member (_Class::*)> >  _Base; 
# 1934
public: static bool _M_manager(::std::_Any_data &__dest, const ::std::_Any_data &__source, ::std::_Manager_operation 
# 1935
__op) 
# 1936
{ 
# 1937
switch (__op) 
# 1938
{ 
# 1940
case __get_type_info:  
# 1941
__dest.template _M_access< const ::std::type_info *> () = (&typeid(_Member (_Class::*))); 
# 1942
break; 
# 1944
case __get_functor_ptr:  
# 1945
(__dest.template _M_access< _Functor *> ()) = (&(_Base::_M_get_pointer(__source)->__value)); 
# 1947
break; 
# 1949
default:  
# 1950
_Base::_M_manager(__dest, __source, __op); 
# 1951
}  
# 1952
return false; 
# 1953
} 
# 1956
static void _M_invoke(const ::std::_Any_data &__functor, _ArgTypes &&...__args) 
# 1957
{ 
# 1958
::std::mem_fn((_Base::_M_get_pointer(__functor)->__value))(::std::forward< _ArgTypes> (__args)...); 
# 1960
} 
# 1961
}; 
# 1963
template< class _From, class _To> using __check_func_return_type = __or_< is_void< _To> , is_convertible< _From, _To> > ; 
# 1973
template< class _Res, class ..._ArgTypes> 
# 1974
class function< _Res (_ArgTypes ...)>  : public _Maybe_unary_or_binary_function< _Res, _ArgTypes...> , private _Function_base { 
# 1978
typedef _Res _Signature_type(_ArgTypes ...); 
# 1980
template< class _Func, class 
# 1981
_Res2 = typename result_of< _Func (_ArgTypes ...)> ::type> 
# 1982
struct _Callable : public ::std::__check_func_return_type< _Res2, _Res>  { }; 
# 1986
template< class _Tp> 
# 1987
struct _Callable< ::std::function< _Res (_ArgTypes ...)> , _Tp>  : public ::std::false_type { }; 
# 1989
template< class _Cond, class _Tp> using _Requires = typename enable_if< _Cond::value, _Tp> ::type; 
# 1993
public: typedef _Res result_type; 
# 2001
function() noexcept : ::std::_Function_base() 
# 2002
{ } 
# 2008
function(::std::nullptr_t) noexcept : ::std::_Function_base() 
# 2009
{ } 
# 2019 "/usr/include/c++/5/functional" 3
function(const ::std::function< _Res (_ArgTypes ...)>  & __x); 
# 2028 "/usr/include/c++/5/functional" 3
function(::std::function< _Res (_ArgTypes ...)>  &&__x) : ::std::_Function_base() 
# 2029
{ 
# 2030
(__x.swap(*this)); 
# 2031
} 
# 2051 "/usr/include/c++/5/functional" 3
template< class _Functor, class 
# 2052
 = _Requires< __not_< is_same< _Functor, ::std::function< _Res (_ArgTypes ...)> > > , void> , class 
# 2053
 = _Requires< _Callable< _Functor> , void> > 
# 2051
function(_Functor); 
# 2069 "/usr/include/c++/5/functional" 3
::std::function< _Res (_ArgTypes ...)>  &operator=(const ::std::function< _Res (_ArgTypes ...)>  &__x) 
# 2070
{ 
# 2071
(((::std::function< _Res (_ArgTypes ...)> )(__x)).swap(*this)); 
# 2072
return *this; 
# 2073
} 
# 2087 "/usr/include/c++/5/functional" 3
::std::function< _Res (_ArgTypes ...)>  &operator=(::std::function< _Res (_ArgTypes ...)>  &&__x) 
# 2088
{ 
# 2089
(((::std::function< _Res (_ArgTypes ...)> )(::std::move(__x))).swap(*this)); 
# 2090
return *this; 
# 2091
} 
# 2101 "/usr/include/c++/5/functional" 3
::std::function< _Res (_ArgTypes ...)>  &operator=(::std::nullptr_t) noexcept 
# 2102
{ 
# 2103
if (_M_manager) 
# 2104
{ 
# 2105
(_M_manager)(_M_functor, _M_functor, __destroy_functor); 
# 2106
(_M_manager) = (nullptr); 
# 2107
(_M_invoker) = nullptr; 
# 2108
}  
# 2109
return *this; 
# 2110
} 
# 2128 "/usr/include/c++/5/functional" 3
template< class _Functor> _Requires< _Callable< typename decay< _Functor> ::type> , ::std::function< _Res (_ArgTypes ...)>  &>  
# 2130
operator=(_Functor &&__f) 
# 2131
{ 
# 2132
(((::std::function< _Res (_ArgTypes ...)> )(::std::forward< _Functor> (__f))).swap(*this)); 
# 2133
return *this; 
# 2134
} 
# 2137
template< class _Functor> ::std::function< _Res (_ArgTypes ...)>  &
# 2139
operator=(reference_wrapper< _Functor>  __f) noexcept 
# 2140
{ 
# 2141
(((::std::function< _Res (_ArgTypes ...)> )(__f)).swap(*this)); 
# 2142
return *this; 
# 2143
} 
# 2154 "/usr/include/c++/5/functional" 3
void swap(::std::function< _Res (_ArgTypes ...)>  &__x) 
# 2155
{ 
# 2156
::std::swap(_M_functor, (__x._M_functor)); 
# 2157
::std::swap(_M_manager, (__x._M_manager)); 
# 2158
::std::swap(_M_invoker, (__x._M_invoker)); 
# 2159
} 
# 2182 "/usr/include/c++/5/functional" 3
explicit operator bool() const noexcept 
# 2183
{ return !this->::std::_Function_base::_M_empty(); } 
# 2195 "/usr/include/c++/5/functional" 3
_Res operator()(_ArgTypes ...__args) const; 
# 2208 "/usr/include/c++/5/functional" 3
const ::std::type_info &target_type() const noexcept; 
# 2219 "/usr/include/c++/5/functional" 3
template< class _Functor> _Functor *target() noexcept; 
# 2222
template< class _Functor> const _Functor *target() const noexcept; 
# 2226
private: using _Invoker_type = _Res (*)(const ::std::_Any_data &, _ArgTypes && ...); 
# 2227
_Invoker_type _M_invoker; 
# 2228
}; 
# 2231
template< class _Res, class ..._ArgTypes> 
# 2233
function< _Res (_ArgTypes ...)> ::function(const ::std::function< _Res (_ArgTypes ...)>  &__x) : ::std::_Function_base() 
# 2235
{ 
# 2236
if (static_cast< bool>(__x)) 
# 2237
{ 
# 2238
(__x._M_manager(_M_functor, (__x._M_functor), __clone_functor)); 
# 2239
(_M_invoker) = (__x._M_invoker); 
# 2240
(_M_manager) = (__x._M_manager); 
# 2241
}  
# 2242
} 
# 2244
template< class _Res, class ..._ArgTypes> 
# 2245
template< class _Functor, class , class > 
# 2247
function< _Res (_ArgTypes ...)> ::function(_Functor __f) : ::std::_Function_base() 
# 2249
{ 
# 2250
typedef _Function_handler< _Res (_ArgTypes ...), _Functor>  _My_handler; 
# 2252
if (_My_handler::_M_not_empty_function(__f)) 
# 2253
{ 
# 2254
_My_handler::_M_init_functor(_M_functor, ::std::move(__f)); 
# 2255
(_M_invoker) = (&_My_handler::_M_invoke); 
# 2256
(_M_manager) = (&_My_handler::_M_manager); 
# 2257
}  
# 2258
} 
# 2260
template< class _Res, class ..._ArgTypes> _Res 
# 2263
function< _Res (_ArgTypes ...)> ::operator()(_ArgTypes ...__args) const 
# 2264
{ 
# 2265
if (this->::std::_Function_base::_M_empty()) { 
# 2266
__throw_bad_function_call(); }  
# 2267
return (_M_invoker)(_M_functor, ::std::forward< _ArgTypes> (__args)...); 
# 2268
} 
# 2271
template< class _Res, class ..._ArgTypes> const type_info &
# 2274
function< _Res (_ArgTypes ...)> ::target_type() const noexcept 
# 2275
{ 
# 2276
if (_M_manager) 
# 2277
{ 
# 2278
::std::_Any_data __typeinfo_result; 
# 2279
(_M_manager)(__typeinfo_result, _M_functor, __get_type_info); 
# 2280
return *__typeinfo_result.template _M_access< const ::std::type_info *> (); 
# 2281
} else { 
# 2283
return typeid(void); }  
# 2284
} 
# 2286
template< class _Res, class ..._ArgTypes> 
# 2287
template< class _Functor> _Functor *
# 2290
function< _Res (_ArgTypes ...)> ::target() noexcept 
# 2291
{ 
# 2292
if ((typeid(_Functor) == target_type()) && (_M_manager)) 
# 2293
{ 
# 2294
::std::_Any_data __ptr; 
# 2295
if ((_M_manager)(__ptr, _M_functor, __get_functor_ptr) && (!is_const< _Functor> ::value)) { 
# 2297
return 0; } else { 
# 2299
return (__ptr.template _M_access< _Functor *> ()); }  
# 2300
} else { 
# 2302
return 0; }  
# 2303
} 
# 2305
template< class _Res, class ..._ArgTypes> 
# 2306
template< class _Functor> const _Functor *
# 2309
function< _Res (_ArgTypes ...)> ::target() const noexcept 
# 2310
{ 
# 2311
if ((typeid(_Functor) == target_type()) && (_M_manager)) 
# 2312
{ 
# 2313
::std::_Any_data __ptr; 
# 2314
(_M_manager)(__ptr, _M_functor, __get_functor_ptr); 
# 2315
return (__ptr.template _M_access< const _Functor *> ()); 
# 2316
} else { 
# 2318
return 0; }  
# 2319
} 
# 2331 "/usr/include/c++/5/functional" 3
template< class _Res, class ..._Args> inline bool 
# 2333
operator==(const function< _Res (_Args ...)>  &__f, nullptr_t) noexcept 
# 2334
{ return !(static_cast< bool>(__f)); } 
# 2337
template< class _Res, class ..._Args> inline bool 
# 2339
operator==(nullptr_t, const function< _Res (_Args ...)>  &__f) noexcept 
# 2340
{ return !(static_cast< bool>(__f)); } 
# 2349 "/usr/include/c++/5/functional" 3
template< class _Res, class ..._Args> inline bool 
# 2351
operator!=(const function< _Res (_Args ...)>  &__f, nullptr_t) noexcept 
# 2352
{ return static_cast< bool>(__f); } 
# 2355
template< class _Res, class ..._Args> inline bool 
# 2357
operator!=(nullptr_t, const function< _Res (_Args ...)>  &__f) noexcept 
# 2358
{ return static_cast< bool>(__f); } 
# 2367 "/usr/include/c++/5/functional" 3
template< class _Res, class ..._Args> inline void 
# 2369
swap(function< _Res (_Args ...)>  &__x, function< _Res (_Args ...)>  &__y) 
# 2370
{ (__x.swap(__y)); } 
# 2373
}
# 39 "/usr/include/c++/5/bits/unique_ptr.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 49
template< class > class auto_ptr; 
# 53
template< class _Tp> 
# 54
struct default_delete { 
# 57
constexpr default_delete() noexcept = default;
# 64
template< class _Up, class  = typename enable_if< is_convertible< _Up *, _Tp *> ::value> ::type> 
# 66
default_delete(const std::default_delete< _Up>  &) noexcept { } 
# 70
void operator()(_Tp *__ptr) const 
# 71
{ 
# 72
static_assert((!is_void< _Tp> ::value), "can\'t delete pointer to incomplete type");
# 74
static_assert((sizeof(_Tp) > (0)), "can\'t delete pointer to incomplete type");
# 76
delete __ptr; 
# 77
} 
# 78
}; 
# 83
template< class _Tp> 
# 84
struct default_delete< _Tp []>  { 
# 88
private: 
# 87
template< class _Up> using __remove_cv = typename remove_cv< _Up> ::type; 
# 91
template< class _Up> using __is_derived_Tp = __and_< is_base_of< _Tp, _Up> , __not_< is_same< __remove_cv< _Tp> , __remove_cv< _Up> > > > ; 
# 98
public: constexpr default_delete() noexcept = default;
# 109 "/usr/include/c++/5/bits/unique_ptr.h" 3
template< class _Up, class  = typename enable_if< !__and_< is_base_of< _Tp, _Up> , __not_< is_same< __remove_cv< _Tp> , __remove_cv< _Up> > > > ::value> ::type> 
# 111
default_delete(const std::default_delete< _Up []>  &) noexcept { } 
# 115
void operator()(_Tp *__ptr) const 
# 116
{ 
# 117
static_assert((sizeof(_Tp) > (0)), "can\'t delete pointer to incomplete type");
# 119
delete [] __ptr; 
# 120
} 
# 122
template < typename _Up >
 typename enable_if < __is_derived_Tp < _Up > :: value > :: type
 operator ( ) ( _Up * ) const = delete;
# 125
}; 
# 128
template< class _Tp, class _Dp = default_delete< _Tp> > 
# 129
class unique_ptr { 
# 132
class _Pointer { 
# 134
template< class _Up> static typename _Up::pointer __test(typename _Up::pointer *); 
# 137
template< class _Up> static _Tp *__test(...); 
# 140
typedef typename remove_reference< _Dp> ::type _Del; 
# 143
public: typedef __decltype((__test< _Del> (0))) type; 
# 144
}; 
# 146
typedef tuple< typename _Pointer::type, _Dp>  __tuple_type; 
# 147
__tuple_type _M_t; 
# 150
public: typedef typename _Pointer::type pointer; 
# 151
typedef _Tp element_type; 
# 152
typedef _Dp deleter_type; 
# 157
constexpr unique_ptr() noexcept : _M_t() 
# 159
{ static_assert((!is_pointer< _Dp> ::value), "constructed with null function pointer deleter");
# 160
} 
# 169
explicit unique_ptr(pointer __p) noexcept : _M_t(__p, deleter_type()) 
# 171
{ static_assert((!is_pointer< _Dp> ::value), "constructed with null function pointer deleter");
# 172
} 
# 181 "/usr/include/c++/5/bits/unique_ptr.h" 3
unique_ptr(pointer __p, typename conditional< is_reference< _Dp> ::value, _Dp, const _Dp &> ::type 
# 183
__d) noexcept : _M_t(__p, __d) 
# 184
{ } 
# 193 "/usr/include/c++/5/bits/unique_ptr.h" 3
unique_ptr(pointer __p, typename remove_reference< _Dp> ::type &&
# 194
__d) noexcept : _M_t(std::move(__p), std::move(__d)) 
# 196
{ static_assert((!std::is_reference< _Dp> ::value), "rvalue deleter bound to reference");
# 197
} 
# 200
constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { } 
# 205
unique_ptr(unique_ptr &&__u) noexcept : _M_t((__u.release()), std::forward< deleter_type> ((__u.get_deleter()))) 
# 206
{ } 
# 214
template< class _Up, class _Ep, class  = _Require< is_convertible< typename std::unique_ptr< _Up, _Ep> ::pointer, typename _Pointer::type> , __not_< is_array< _Up> > , typename conditional< is_reference< _Dp> ::value, is_same< _Ep, _Dp> , is_convertible< _Ep, _Dp> > ::type> > 
# 220
unique_ptr(std::unique_ptr< _Up, _Ep>  &&__u) noexcept : _M_t((__u.release()), std::forward< _Ep> ((__u.get_deleter()))) 
# 222
{ } 
# 226
template< class _Up, class  = _Require< is_convertible< _Up *, _Tp *> , is_same< _Dp, default_delete< _Tp> > > > inline unique_ptr(auto_ptr< _Up>  && __u) noexcept; 
# 232
~unique_ptr() noexcept 
# 233
{ 
# 234
auto &__ptr = std::get< 0> (_M_t); 
# 235
if (__ptr != nullptr) { 
# 236
this->get_deleter()(__ptr); }  
# 237
__ptr = pointer(); 
# 238
} 
# 249 "/usr/include/c++/5/bits/unique_ptr.h" 3
unique_ptr &operator=(unique_ptr &&__u) noexcept 
# 250
{ 
# 251
reset((__u.release())); 
# 252
this->get_deleter() = std::forward< deleter_type> ((__u.get_deleter())); 
# 253
return *this; 
# 254
} 
# 263 "/usr/include/c++/5/bits/unique_ptr.h" 3
template< class _Up, class _Ep> typename enable_if< __and_< is_convertible< typename std::unique_ptr< _Up, _Ep> ::pointer, typename _Pointer::type> , __not_< is_array< _Up> > > ::value, unique_ptr &> ::type 
# 269
operator=(std::unique_ptr< _Up, _Ep>  &&__u) noexcept 
# 270
{ 
# 271
reset((__u.release())); 
# 272
this->get_deleter() = std::forward< _Ep> ((__u.get_deleter())); 
# 273
return *this; 
# 274
} 
# 278
unique_ptr &operator=(nullptr_t) noexcept 
# 279
{ 
# 280
reset(); 
# 281
return *this; 
# 282
} 
# 288
typename add_lvalue_reference< _Tp> ::type operator*() const 
# 289
{ 
# 290
; 
# 291
return *get(); 
# 292
} 
# 296
pointer operator->() const noexcept 
# 297
{ 
# 298
; 
# 299
return get(); 
# 300
} 
# 304
pointer get() const noexcept 
# 305
{ return std::get< 0> (_M_t); } 
# 309
deleter_type &get_deleter() noexcept 
# 310
{ return std::get< 1> (_M_t); } 
# 314
const deleter_type &get_deleter() const noexcept 
# 315
{ return std::get< 1> (_M_t); } 
# 318
explicit operator bool() const noexcept 
# 319
{ return (get() == pointer()) ? false : true; } 
# 325
pointer release() noexcept 
# 326
{ 
# 327
pointer __p = get(); 
# 328
std::get< 0> (_M_t) = pointer(); 
# 329
return __p; 
# 330
} 
# 339
void reset(pointer __p = pointer()) noexcept 
# 340
{ 
# 341
using std::swap;
# 342
swap(std::get< 0> (_M_t), __p); 
# 343
if (__p != pointer()) { 
# 344
this->get_deleter()(__p); }  
# 345
} 
# 349
void swap(unique_ptr &__u) noexcept 
# 350
{ 
# 351
using std::swap;
# 352
swap(_M_t, (__u._M_t)); 
# 353
} 
# 356
unique_ptr(const unique_ptr &) = delete;
# 357
unique_ptr &operator=(const unique_ptr &) = delete;
# 358
}; 
# 364
template< class _Tp, class _Dp> 
# 365
class unique_ptr< _Tp [], _Dp>  { 
# 368
class _Pointer { 
# 370
template< class _Up> static typename _Up::pointer __test(typename _Up::pointer *); 
# 373
template< class _Up> static _Tp *__test(...); 
# 376
typedef typename remove_reference< _Dp> ::type _Del; 
# 379
public: typedef __decltype((__test< _Del> (0))) type; 
# 380
}; 
# 382
typedef tuple< typename _Pointer::type, _Dp>  __tuple_type; 
# 383
__tuple_type _M_t; 
# 385
template< class _Up> using __remove_cv = typename remove_cv< _Up> ::type; 
# 389
template< class _Up> using __is_derived_Tp = __and_< is_base_of< _Tp, _Up> , __not_< is_same< __remove_cv< _Tp> , __remove_cv< _Up> > > > ; 
# 394
template< class _Up, class _Ep, class 
# 395
_Tp_pointer = typename _Pointer::type, class 
# 396
_Up_pointer = typename std::unique_ptr< _Up, _Ep> ::pointer> using __safe_conversion = __and_< is_convertible< _Up_pointer, _Tp_pointer> , is_array< _Up> , __or_< __not_< is_pointer< _Up_pointer> > , __not_< is_pointer< _Tp_pointer> > , __not_< __is_derived_Tp< typename remove_extent< _Up> ::type> > > > ; 
# 407
public: typedef typename _Pointer::type pointer; 
# 408
typedef _Tp element_type; 
# 409
typedef _Dp deleter_type; 
# 414
constexpr unique_ptr() noexcept : _M_t() 
# 416
{ static_assert((!std::is_pointer< _Dp> ::value), "constructed with null function pointer deleter");
# 417
} 
# 426
explicit unique_ptr(pointer __p) noexcept : _M_t(__p, deleter_type()) 
# 428
{ static_assert((!is_pointer< _Dp> ::value), "constructed with null function pointer deleter");
# 429
} 
# 432
template < typename _Up, typename = _Require < is_pointer < pointer >,
        is_convertible < _Up *, pointer >, __is_derived_Tp < _Up > > >
 explicit
 unique_ptr ( _Up * __p ) = delete;
# 444 "/usr/include/c++/5/bits/unique_ptr.h" 3
unique_ptr(pointer __p, typename conditional< is_reference< _Dp> ::value, _Dp, const _Dp &> ::type 
# 446
__d) noexcept : _M_t(__p, __d) 
# 447
{ } 
# 456 "/usr/include/c++/5/bits/unique_ptr.h" 3
unique_ptr(pointer __p, typename remove_reference< _Dp> ::type &&
# 457
__d) noexcept : _M_t(std::move(__p), std::move(__d)) 
# 459
{ static_assert((!is_reference< _Dp> ::value), "rvalue deleter bound to reference");
# 460
} 
# 463
unique_ptr(std::unique_ptr< _Tp [], _Dp>  &&__u) noexcept : _M_t((__u.release()), std::forward< deleter_type> ((__u.get_deleter()))) 
# 464
{ } 
# 467
constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { } 
# 469
template< class _Up, class _Ep, class 
# 470
 = _Require< __safe_conversion< _Up, _Ep, typename _Pointer::type, typename std::unique_ptr< _Up, _Ep> ::pointer> , typename conditional< is_reference< _Dp> ::value, is_same< _Ep, _Dp> , is_convertible< _Ep, _Dp> > ::type> > 
# 475
unique_ptr(std::unique_ptr< _Up, _Ep>  &&__u) noexcept : _M_t((__u.release()), std::forward< _Ep> ((__u.get_deleter()))) 
# 477
{ } 
# 480
~unique_ptr() 
# 481
{ 
# 482
auto &__ptr = std::get< 0> (_M_t); 
# 483
if (__ptr != nullptr) { 
# 484
this->get_deleter()(__ptr); }  
# 485
__ptr = pointer(); 
# 486
} 
# 497 "/usr/include/c++/5/bits/unique_ptr.h" 3
std::unique_ptr< _Tp [], _Dp>  &operator=(std::unique_ptr< _Tp [], _Dp>  &&__u) noexcept 
# 498
{ 
# 499
reset((__u.release())); 
# 500
this->get_deleter() = std::forward< deleter_type> ((__u.get_deleter())); 
# 501
return *this; 
# 502
} 
# 511 "/usr/include/c++/5/bits/unique_ptr.h" 3
template< class _Up, class _Ep> typename enable_if< __and_< is_convertible< typename std::unique_ptr< _Up, _Ep> ::pointer, typename _Pointer::type> , is_array< _Up> , __or_< __not_< is_pointer< typename std::unique_ptr< _Up, _Ep> ::pointer> > , __not_< is_pointer< typename _Pointer::type> > , __not_< __is_derived_Tp< typename remove_extent< _Up> ::type> > > > ::value, std::unique_ptr< _Tp [], _Dp>  &> ::type 
# 514
operator=(std::unique_ptr< _Up, _Ep>  &&__u) noexcept 
# 515
{ 
# 516
reset((__u.release())); 
# 517
this->get_deleter() = std::forward< _Ep> ((__u.get_deleter())); 
# 518
return *this; 
# 519
} 
# 523
std::unique_ptr< _Tp [], _Dp>  &operator=(nullptr_t) noexcept 
# 524
{ 
# 525
reset(); 
# 526
return *this; 
# 527
} 
# 533
typename add_lvalue_reference< _Tp> ::type operator[](size_t __i) const 
# 534
{ 
# 535
; 
# 536
return get()[__i]; 
# 537
} 
# 541
pointer get() const noexcept 
# 542
{ return std::get< 0> (_M_t); } 
# 546
deleter_type &get_deleter() noexcept 
# 547
{ return std::get< 1> (_M_t); } 
# 551
const deleter_type &get_deleter() const noexcept 
# 552
{ return std::get< 1> (_M_t); } 
# 555
explicit operator bool() const noexcept 
# 556
{ return (get() == pointer()) ? false : true; } 
# 562
pointer release() noexcept 
# 563
{ 
# 564
pointer __p = get(); 
# 565
std::get< 0> (_M_t) = pointer(); 
# 566
return __p; 
# 567
} 
# 576
void reset(pointer __p = pointer()) noexcept 
# 577
{ 
# 578
using std::swap;
# 579
swap(std::get< 0> (_M_t), __p); 
# 580
if (__p != nullptr) { 
# 581
this->get_deleter()(__p); }  
# 582
} 
# 585
template < typename _Up, typename = _Require < is_pointer < pointer >,
        is_convertible < _Up *, pointer >, __is_derived_Tp < _Up > > >
 void reset ( _Up * ) = delete;
# 591
void swap(std::unique_ptr< _Tp [], _Dp>  &__u) noexcept 
# 592
{ 
# 593
using std::swap;
# 594
swap(_M_t, (__u._M_t)); 
# 595
} 
# 598
unique_ptr(const std::unique_ptr< _Tp [], _Dp>  &) = delete;
# 599
std::unique_ptr< _Tp [], _Dp>  &operator=(const std::unique_ptr< _Tp [], _Dp>  &) = delete;
# 602
template < typename _Up, typename = _Require < is_pointer < pointer >,
        is_convertible < _Up *, pointer >, __is_derived_Tp < _Up > > >
 unique_ptr ( _Up *, typename
     conditional < is_reference < deleter_type > :: value,
     deleter_type, const deleter_type & > :: type ) = delete;
# 609
template < typename _Up, typename = _Require < is_pointer < pointer >,
        is_convertible < _Up *, pointer >, __is_derived_Tp < _Up > > >
 unique_ptr ( _Up *, typename
     remove_reference < deleter_type > :: type && ) = delete;
# 613
}; 
# 615
template< class _Tp, class _Dp> inline void 
# 617
swap(unique_ptr< _Tp, _Dp>  &__x, unique_ptr< _Tp, _Dp>  &
# 618
__y) noexcept 
# 619
{ (__x.swap(__y)); } 
# 621
template< class _Tp, class _Dp, class 
# 622
_Up, class _Ep> inline bool 
# 624
operator==(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 625
__y) 
# 626
{ return (__x.get()) == (__y.get()); } 
# 628
template< class _Tp, class _Dp> inline bool 
# 630
operator==(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) noexcept 
# 631
{ return !__x; } 
# 633
template< class _Tp, class _Dp> inline bool 
# 635
operator==(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) noexcept 
# 636
{ return !__x; } 
# 638
template< class _Tp, class _Dp, class 
# 639
_Up, class _Ep> inline bool 
# 641
operator!=(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 642
__y) 
# 643
{ return (__x.get()) != (__y.get()); } 
# 645
template< class _Tp, class _Dp> inline bool 
# 647
operator!=(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) noexcept 
# 648
{ return (bool)__x; } 
# 650
template< class _Tp, class _Dp> inline bool 
# 652
operator!=(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) noexcept 
# 653
{ return (bool)__x; } 
# 655
template< class _Tp, class _Dp, class 
# 656
_Up, class _Ep> inline bool 
# 658
operator<(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 659
__y) 
# 660
{ 
# 663
typedef typename common_type< typename unique_ptr< _Tp, _Dp> ::pointer, typename unique_ptr< _Up, _Ep> ::pointer> ::type _CT; 
# 664
return less< typename common_type< typename unique_ptr< _Tp, _Dp> ::pointer, typename unique_ptr< _Up, _Ep> ::pointer> ::type> ()((__x.get()), (__y.get())); 
# 665
} 
# 667
template< class _Tp, class _Dp> inline bool 
# 669
operator<(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) 
# 670
{ return less< typename unique_ptr< _Tp, _Dp> ::pointer> ()((__x.get()), nullptr); 
# 671
} 
# 673
template< class _Tp, class _Dp> inline bool 
# 675
operator<(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) 
# 676
{ return less< typename unique_ptr< _Tp, _Dp> ::pointer> ()(nullptr, (__x.get())); 
# 677
} 
# 679
template< class _Tp, class _Dp, class 
# 680
_Up, class _Ep> inline bool 
# 682
operator<=(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 683
__y) 
# 684
{ return !(__y < __x); } 
# 686
template< class _Tp, class _Dp> inline bool 
# 688
operator<=(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) 
# 689
{ return !(nullptr < __x); } 
# 691
template< class _Tp, class _Dp> inline bool 
# 693
operator<=(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) 
# 694
{ return !(__x < nullptr); } 
# 696
template< class _Tp, class _Dp, class 
# 697
_Up, class _Ep> inline bool 
# 699
operator>(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 700
__y) 
# 701
{ return __y < __x; } 
# 703
template< class _Tp, class _Dp> inline bool 
# 705
operator>(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) 
# 706
{ return less< typename unique_ptr< _Tp, _Dp> ::pointer> ()(nullptr, (__x.get())); 
# 707
} 
# 709
template< class _Tp, class _Dp> inline bool 
# 711
operator>(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) 
# 712
{ return less< typename unique_ptr< _Tp, _Dp> ::pointer> ()((__x.get()), nullptr); 
# 713
} 
# 715
template< class _Tp, class _Dp, class 
# 716
_Up, class _Ep> inline bool 
# 718
operator>=(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 719
__y) 
# 720
{ return !(__x < __y); } 
# 722
template< class _Tp, class _Dp> inline bool 
# 724
operator>=(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) 
# 725
{ return !(__x < nullptr); } 
# 727
template< class _Tp, class _Dp> inline bool 
# 729
operator>=(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) 
# 730
{ return !(nullptr < __x); } 
# 733
template< class _Tp, class _Dp> 
# 734
struct hash< unique_ptr< _Tp, _Dp> >  : public __hash_base< unsigned long, unique_ptr< _Tp, _Dp> >  { 
# 738
::std::size_t operator()(const unique_ptr< _Tp, _Dp>  &__u) const noexcept 
# 739
{ 
# 740
typedef unique_ptr< _Tp, _Dp>  _UP; 
# 741
return ::std::hash< typename unique_ptr< _Tp, _Dp> ::pointer> ()((__u.get())); 
# 742
} 
# 743
}; 
# 782 "/usr/include/c++/5/bits/unique_ptr.h" 3
}
# 40 "/usr/include/c++/5/bits/allocated_ptr.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _Alloc> 
# 46
struct __allocated_ptr { 
# 48
using pointer = typename allocator_traits< _Alloc> ::pointer; 
# 49
using value_type = typename allocator_traits< _Alloc> ::value_type; 
# 52
__allocated_ptr(_Alloc &__a, pointer __ptr) noexcept : _M_alloc((&__a)), _M_ptr(__ptr) 
# 54
{ } 
# 57
template< class _Ptr, class 
# 58
_Req = _Require< is_same< _Ptr, typename allocator_traits< _Alloc> ::value_type *> > > 
# 59
__allocated_ptr(_Alloc &__a, _Ptr __ptr) : _M_alloc((&__a)), _M_ptr(pointer_traits< typename allocator_traits< _Alloc> ::pointer> ::pointer_to(*__ptr)) 
# 61
{ } 
# 64
__allocated_ptr(__allocated_ptr &&__gd) noexcept : _M_alloc(((__gd._M_alloc))), _M_ptr((__gd._M_ptr)) 
# 66
{ (__gd._M_ptr) = nullptr; } 
# 69
~__allocated_ptr() 
# 70
{ 
# 71
if ((_M_ptr) != nullptr) { 
# 72
std::allocator_traits< _Alloc> ::deallocate(*(_M_alloc), _M_ptr, 1); }  
# 73
} 
# 77
__allocated_ptr &operator=(nullptr_t) noexcept 
# 78
{ 
# 79
(_M_ptr) = nullptr; 
# 80
return *this; 
# 81
} 
# 84
value_type *get() { return _S_raw_ptr(_M_ptr); } 
# 87
private: value_type *_S_raw_ptr(value_type *__ptr) { return __ptr; } 
# 89
template< class _Ptr> auto 
# 90
_S_raw_ptr(_Ptr __ptr)->__decltype((_S_raw_ptr((__ptr.operator->())))) 
# 91
{ return _S_raw_ptr((__ptr.operator->())); } 
# 93
_Alloc *_M_alloc; 
# 94
pointer _M_ptr; 
# 95
}; 
# 98
template< class _Alloc> __allocated_ptr< _Alloc>  
# 100
__allocate_guarded(_Alloc &__a) 
# 101
{ 
# 102
return {__a, std::allocator_traits< _Alloc> ::allocate(__a, 1)}; 
# 103
} 
# 106
}
# 40 "/usr/include/c++/5/ext/aligned_buffer.h" 3
namespace __gnu_cxx { 
# 46
template< class _Tp> 
# 47
struct __aligned_membuf { 
# 52
struct _Tp2 { _Tp _M_t; }; 
# 54
alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)]; 
# 56
__aligned_membuf() = default;
# 59
__aligned_membuf(std::nullptr_t) { } 
# 62
void *_M_addr() noexcept 
# 63
{ return static_cast< void *>(&(_M_storage)); } 
# 66
const void *_M_addr() const noexcept 
# 67
{ return static_cast< const void *>(&(_M_storage)); } 
# 70
_Tp *_M_ptr() noexcept 
# 71
{ return static_cast< _Tp *>(this->_M_addr()); } 
# 74
const _Tp *_M_ptr() const noexcept 
# 75
{ return static_cast< const _Tp *>(this->_M_addr()); } 
# 76
}; 
# 83
template< class _Tp> 
# 84
struct __aligned_buffer : public std::aligned_storage< sizeof(_Tp), std::alignment_of< _Tp> ::value>  { 
# 89
typename ::std::aligned_storage< sizeof(_Tp), ::std::alignment_of< _Tp> ::value> ::type _M_storage; 
# 91
__aligned_buffer() = default;
# 94
__aligned_buffer(::std::nullptr_t) { } 
# 97
void *_M_addr() noexcept 
# 98
{ 
# 99
return static_cast< void *>(&(_M_storage)); 
# 100
} 
# 103
const void *_M_addr() const noexcept 
# 104
{ 
# 105
return static_cast< const void *>(&(_M_storage)); 
# 106
} 
# 109
_Tp *_M_ptr() noexcept 
# 110
{ return static_cast< _Tp *>(this->_M_addr()); } 
# 113
const _Tp *_M_ptr() const noexcept 
# 114
{ return static_cast< const _Tp *>(this->_M_addr()); } 
# 115
}; 
# 117
}
# 55 "/usr/include/c++/5/bits/shared_ptr_base.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 60
template< class > class auto_ptr; 
# 67
class bad_weak_ptr : public exception { 
# 71
public: virtual const char *what() const noexcept; 
# 73
virtual ~bad_weak_ptr() noexcept; 
# 74
}; 
# 78
inline void __throw_bad_weak_ptr() 
# 79
{ throw bad_weak_ptr(); } 
# 81
using __gnu_cxx::_Lock_policy;
# 82
using __gnu_cxx::__default_lock_policy;
# 83
using __gnu_cxx::_S_single;
# 84
using __gnu_cxx::_S_mutex;
# 85
using __gnu_cxx::_S_atomic;
# 88
template< __gnu_cxx::_Lock_policy _Lp> 
# 89
class _Mutex_base { 
# 93
protected: enum { _S_need_barriers}; 
# 94
}; 
# 97
template<> class _Mutex_base< __gnu_cxx::_S_mutex>  : public __gnu_cxx::__mutex { 
# 104
protected: enum { _S_need_barriers = 1}; 
# 105
}; 
# 107
template< __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> 
# 108
class _Sp_counted_base : public _Mutex_base< _Lp>  { 
# 112
public: _Sp_counted_base() noexcept : _M_use_count(1), _M_weak_count(1) 
# 113
{ } 
# 116
virtual ~_Sp_counted_base() noexcept 
# 117
{ } 
# 122
virtual void _M_dispose() noexcept = 0; 
# 126
virtual void _M_destroy() noexcept 
# 127
{ delete this; } 
# 130
virtual void *_M_get_deleter(const ::std::type_info &) noexcept = 0; 
# 133
void _M_add_ref_copy() 
# 134
{ __gnu_cxx::__atomic_add_dispatch(&(_M_use_count), 1); } 
# 137
void _M_add_ref_lock(); 
# 140
bool _M_add_ref_lock_nothrow(); 
# 143
void _M_release() noexcept 
# 144
{ 
# 146
; 
# 147
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_use_count), -1) == 1) 
# 148
{ 
# 149
; 
# 150
_M_dispose(); 
# 155
if (_Mutex_base< _Lp> ::_S_need_barriers) 
# 156
{ 
# 157
__atomic_thread_fence(2); 
# 158
__atomic_thread_fence(3); 
# 159
}  
# 162
; 
# 163
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_weak_count), -1) == 1) 
# 165
{ 
# 166
; 
# 167
_M_destroy(); 
# 168
}  
# 169
}  
# 170
} 
# 173
void _M_weak_add_ref() noexcept 
# 174
{ __gnu_cxx::__atomic_add_dispatch(&(_M_weak_count), 1); } 
# 177
void _M_weak_release() noexcept 
# 178
{ 
# 180
; 
# 181
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_weak_count), -1) == 1) 
# 182
{ 
# 183
; 
# 184
if (_Mutex_base< _Lp> ::_S_need_barriers) 
# 185
{ 
# 188
__atomic_thread_fence(2); 
# 189
__atomic_thread_fence(3); 
# 190
}  
# 191
_M_destroy(); 
# 192
}  
# 193
} 
# 196
long _M_get_use_count() const noexcept 
# 197
{ 
# 200
return __atomic_load_n(&(_M_use_count), 0); 
# 201
} 
# 204
private: _Sp_counted_base(const _Sp_counted_base &) = delete;
# 205
_Sp_counted_base &operator=(const _Sp_counted_base &) = delete;
# 207
::_Atomic_word _M_use_count; 
# 208
::_Atomic_word _M_weak_count; 
# 209
}; 
# 214
template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_add_ref_lock() 
# 215
{ 
# 216
if ((_M_use_count) == 0) { 
# 217
__throw_bad_weak_ptr(); }  
# 218
++(_M_use_count); 
# 219
} 
# 224
template<> inline void _Sp_counted_base< __gnu_cxx::_S_mutex> ::_M_add_ref_lock() 
# 225
{ 
# 226
__gnu_cxx::__scoped_lock sentry(*this); 
# 227
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_use_count), 1) == 0) 
# 228
{ 
# 229
(_M_use_count) = 0; 
# 230
__throw_bad_weak_ptr(); 
# 231
}  
# 232
} 
# 237
template<> inline void _Sp_counted_base< __gnu_cxx::_S_atomic> ::_M_add_ref_lock() 
# 238
{ 
# 240
_Atomic_word __count = this->_M_get_use_count(); 
# 241
do 
# 242
{ 
# 243
if (__count == 0) { 
# 244
__throw_bad_weak_ptr(); }  
# 247
} 
# 248
while (!__atomic_compare_exchange_n(&(_M_use_count), &__count, __count + 1, true, 4, 0)); 
# 251
} 
# 256
template<> inline bool _Sp_counted_base< __gnu_cxx::_S_single> ::_M_add_ref_lock_nothrow() 
# 257
{ 
# 258
if ((_M_use_count) == 0) { 
# 259
return false; }  
# 260
++(_M_use_count); 
# 261
return true; 
# 262
} 
# 267
template<> inline bool _Sp_counted_base< __gnu_cxx::_S_mutex> ::_M_add_ref_lock_nothrow() 
# 268
{ 
# 269
__gnu_cxx::__scoped_lock sentry(*this); 
# 270
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_use_count), 1) == 0) 
# 271
{ 
# 272
(_M_use_count) = 0; 
# 273
return false; 
# 274
}  
# 275
return true; 
# 276
} 
# 281
template<> inline bool _Sp_counted_base< __gnu_cxx::_S_atomic> ::_M_add_ref_lock_nothrow() 
# 282
{ 
# 284
_Atomic_word __count = this->_M_get_use_count(); 
# 285
do 
# 286
{ 
# 287
if (__count == 0) { 
# 288
return false; }  
# 291
} 
# 292
while (!__atomic_compare_exchange_n(&(_M_use_count), &__count, __count + 1, true, 4, 0)); 
# 295
return true; 
# 296
} 
# 300
template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_add_ref_copy() 
# 301
{ ++(_M_use_count); } 
# 305
template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_release() noexcept 
# 306
{ 
# 307
if ((--(_M_use_count)) == 0) 
# 308
{ 
# 309
this->_M_dispose(); 
# 310
if ((--(_M_weak_count)) == 0) { 
# 311
this->_M_destroy(); }  
# 312
}  
# 313
} 
# 317
template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_weak_add_ref() noexcept 
# 318
{ ++(_M_weak_count); } 
# 322
template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_weak_release() noexcept 
# 323
{ 
# 324
if ((--(_M_weak_count)) == 0) { 
# 325
this->_M_destroy(); }  
# 326
} 
# 330
template<> inline long _Sp_counted_base< __gnu_cxx::_S_single> ::_M_get_use_count() const noexcept 
# 331
{ return _M_use_count; } 
# 335
template< class _Tp, __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> class __shared_ptr; 
# 338
template< class _Tp, __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> class __weak_ptr; 
# 341
template< class _Tp, __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> class __enable_shared_from_this; 
# 344
template< class _Tp> class shared_ptr; 
# 347
template< class _Tp> class weak_ptr; 
# 350
template< class _Tp> struct owner_less; 
# 353
template< class _Tp> class enable_shared_from_this; 
# 356
template< __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> class __weak_count; 
# 359
template< __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> class __shared_count; 
# 364
template< class _Ptr, __gnu_cxx::_Lock_policy _Lp> 
# 365
class _Sp_counted_ptr final : public _Sp_counted_base< _Lp>  { 
# 369
public: explicit _Sp_counted_ptr(_Ptr __p) noexcept : _M_ptr(__p) 
# 370
{ } 
# 373
virtual void _M_dispose() noexcept 
# 374
{ delete (_M_ptr); } 
# 377
virtual void _M_destroy() noexcept 
# 378
{ delete this; } 
# 381
virtual void *_M_get_deleter(const ::std::type_info &) noexcept 
# 382
{ return nullptr; } 
# 384
_Sp_counted_ptr(const _Sp_counted_ptr &) = delete;
# 385
_Sp_counted_ptr &operator=(const _Sp_counted_ptr &) = delete;
# 388
private: _Ptr _M_ptr; 
# 389
}; 
# 393
template<> inline void _Sp_counted_ptr< nullptr_t, __gnu_cxx::_S_single> ::_M_dispose() noexcept { } 
# 397
template<> inline void _Sp_counted_ptr< nullptr_t, __gnu_cxx::_S_mutex> ::_M_dispose() noexcept { } 
# 401
template<> inline void _Sp_counted_ptr< nullptr_t, __gnu_cxx::_S_atomic> ::_M_dispose() noexcept { } 
# 403
template< int _Nm, class _Tp, bool 
# 404
__use_ebo = (!__is_final(_Tp)) && __is_empty(_Tp)> struct _Sp_ebo_helper; 
# 408
template< int _Nm, class _Tp> 
# 409
struct _Sp_ebo_helper< _Nm, _Tp, true>  : private _Tp { 
# 411
explicit _Sp_ebo_helper(const _Tp &__tp) : _Tp(__tp) { } 
# 414
static _Tp &_S_get(::std::_Sp_ebo_helper< _Nm, _Tp, true>  &__eboh) { return static_cast< _Tp &>(__eboh); } 
# 415
}; 
# 418
template< int _Nm, class _Tp> 
# 419
struct _Sp_ebo_helper< _Nm, _Tp, false>  { 
# 421
explicit _Sp_ebo_helper(const _Tp &__tp) : _M_tp(__tp) { } 
# 424
static _Tp &_S_get(std::_Sp_ebo_helper< _Nm, _Tp, false>  &__eboh) 
# 425
{ return __eboh._M_tp; } 
# 428
private: _Tp _M_tp; 
# 429
}; 
# 432
template< class _Ptr, class _Deleter, class _Alloc, __gnu_cxx::_Lock_policy _Lp> 
# 433
class _Sp_counted_deleter final : public _Sp_counted_base< _Lp>  { 
# 435
class _Impl : private _Sp_ebo_helper< 0, _Deleter> , private _Sp_ebo_helper< 1, _Alloc>  { 
# 437
typedef _Sp_ebo_helper< 0, _Deleter>  _Del_base; 
# 438
typedef _Sp_ebo_helper< 1, _Alloc>  _Alloc_base; 
# 441
public: _Impl(_Ptr __p, _Deleter __d, const _Alloc &__a) noexcept : _Del_base(__d), _Alloc_base(__a), _M_ptr(__p) 
# 443
{ } 
# 445
_Deleter &_M_del() noexcept { return _Del_base::_S_get(*this); } 
# 446
_Alloc &_M_alloc() noexcept { return _Alloc_base::_S_get(*this); } 
# 448
_Ptr _M_ptr; 
# 449
}; 
# 452
public: using __allocator_type = ::std::__alloc_rebind< _Alloc, _Sp_counted_deleter> ; 
# 455
_Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept : _M_impl(__p, __d, _Alloc()) 
# 456
{ } 
# 459
_Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc &__a) noexcept : _M_impl(__p, __d, __a) 
# 460
{ } 
# 462
~_Sp_counted_deleter() noexcept { } 
# 465
virtual void _M_dispose() noexcept 
# 466
{ ((_M_impl)._M_del())(((_M_impl)._M_ptr)); } 
# 469
virtual void _M_destroy() noexcept 
# 470
{ 
# 471
__allocator_type __a(((_M_impl)._M_alloc())); 
# 472
__allocated_ptr< ::std::__alloc_rebind< _Alloc, _Sp_counted_deleter> >  __guard_ptr{__a, this}; 
# 473
(this->~_Sp_counted_deleter()); 
# 474
} 
# 477
virtual void *_M_get_deleter(const ::std::type_info &__ti) noexcept 
# 478
{ 
# 482
return (__ti == (typeid(_Deleter))) ? ::std::__addressof(((_M_impl)._M_del())) : nullptr; 
# 488
} 
# 491
private: _Impl _M_impl; 
# 492
}; 
# 496
struct _Sp_make_shared_tag { }; 
# 498
template< class _Tp, class _Alloc, __gnu_cxx::_Lock_policy _Lp> 
# 499
class _Sp_counted_ptr_inplace final : public _Sp_counted_base< _Lp>  { 
# 501
class _Impl : private _Sp_ebo_helper< 0, _Alloc>  { 
# 503
typedef _Sp_ebo_helper< 0, _Alloc>  _A_base; 
# 506
public: explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { } 
# 508
_Alloc &_M_alloc() noexcept { return _A_base::_S_get(*this); } 
# 510
::__gnu_cxx::__aligned_buffer< _Tp>  _M_storage; 
# 511
}; 
# 514
public: using __allocator_type = ::std::__alloc_rebind< _Alloc, _Sp_counted_ptr_inplace> ; 
# 516
template< class ..._Args> 
# 517
_Sp_counted_ptr_inplace(_Alloc __a, _Args &&...__args) : _M_impl(__a) 
# 519
{ 
# 522
allocator_traits< _Alloc> ::construct(__a, _M_ptr(), ::std::forward< _Args> (__args)...); 
# 524
} 
# 526
~_Sp_counted_ptr_inplace() noexcept { } 
# 529
virtual void _M_dispose() noexcept 
# 530
{ 
# 531
allocator_traits< _Alloc> ::destroy(((_M_impl)._M_alloc()), _M_ptr()); 
# 532
} 
# 536
virtual void _M_destroy() noexcept 
# 537
{ 
# 538
__allocator_type __a(((_M_impl)._M_alloc())); 
# 539
__allocated_ptr< ::std::__alloc_rebind< _Alloc, _Sp_counted_ptr_inplace> >  __guard_ptr{__a, this}; 
# 540
(this->~_Sp_counted_ptr_inplace()); 
# 541
} 
# 545
virtual void *_M_get_deleter(const ::std::type_info &__ti) noexcept 
# 546
{ 
# 548
if ((__ti == (typeid(::std::_Sp_make_shared_tag)))) { 
# 549
return const_cast< typename remove_cv< _Tp> ::type *>(_M_ptr()); }  
# 551
return nullptr; 
# 552
} 
# 555
private: _Tp *_M_ptr() noexcept { return (((_M_impl)._M_storage)._M_ptr()); } 
# 557
_Impl _M_impl; 
# 558
}; 
# 561
template< __gnu_cxx::_Lock_policy _Lp> 
# 562
class __shared_count { 
# 565
public: constexpr __shared_count() noexcept : _M_pi((0)) 
# 566
{ } 
# 568
template< class _Ptr> explicit 
# 570
__shared_count(_Ptr __p) : _M_pi((0)) 
# 571
{ 
# 572
try 
# 573
{ 
# 574
(_M_pi) = (new _Sp_counted_ptr< _Ptr, _Lp> (__p)); 
# 575
} 
# 576
catch (...) 
# 577
{ 
# 578
delete __p; 
# 579
throw; 
# 580
}  
# 581
} 
# 583
template< class _Ptr, class _Deleter> 
# 584
__shared_count(_Ptr __p, _Deleter __d) : __shared_count(__p, std::move(__d), allocator< void> ()) 
# 586
{ } 
# 588
template< class _Ptr, class _Deleter, class _Alloc> 
# 589
__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi((0)) 
# 590
{ 
# 591
typedef _Sp_counted_deleter< _Ptr, _Deleter, _Alloc, _Lp>  _Sp_cd_type; 
# 592
try 
# 593
{ 
# 594
typename _Sp_counted_deleter< _Ptr, _Deleter, _Alloc, _Lp> ::__allocator_type __a2(__a); 
# 595
auto __guard = std::__allocate_guarded(__a2); 
# 596
_Sp_cd_type *__mem = (__guard.get()); 
# 597
::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a)); 
# 598
(_M_pi) = __mem; 
# 599
__guard = nullptr; 
# 600
} 
# 601
catch (...) 
# 602
{ 
# 603
__d(__p); 
# 604
throw; 
# 605
}  
# 606
} 
# 608
template< class _Tp, class _Alloc, class ..._Args> 
# 609
__shared_count(_Sp_make_shared_tag, _Tp *, const _Alloc &__a, _Args &&...
# 610
__args) : _M_pi((0)) 
# 612
{ 
# 613
typedef _Sp_counted_ptr_inplace< _Tp, _Alloc, _Lp>  _Sp_cp_type; 
# 614
typename _Sp_counted_ptr_inplace< _Tp, _Alloc, _Lp> ::__allocator_type __a2(__a); 
# 615
auto __guard = std::__allocate_guarded(__a2); 
# 616
_Sp_cp_type *__mem = (__guard.get()); 
# 617
::new (__mem) _Sp_cp_type(std::move(__a), std::forward< _Args> (__args)...); 
# 619
(_M_pi) = __mem; 
# 620
__guard = nullptr; 
# 621
} 
# 625
template< class _Tp> inline explicit __shared_count(auto_ptr< _Tp>  && __r); 
# 631
template< class _Tp, class _Del> explicit 
# 633
__shared_count(unique_ptr< _Tp, _Del>  &&__r) : _M_pi((0)) 
# 634
{ 
# 635
using _Ptr = typename unique_ptr< _Tp, _Del> ::pointer; 
# 636
using _Del2 = typename conditional< is_reference< _Del> ::value, reference_wrapper< typename remove_reference< _Del> ::type> , _Del> ::type; 
# 639
using _Sp_cd_type = _Sp_counted_deleter< typename unique_ptr< _Tp, _Del> ::pointer, typename conditional< is_reference< _Del> ::value, reference_wrapper< typename remove_reference< _Del> ::type> , _Del> ::type, allocator< void> , _Lp> ; 
# 641
using _Alloc = allocator< _Sp_counted_deleter< typename unique_ptr< _Tp, _Del> ::pointer, typename conditional< is_reference< _Del> ::value, reference_wrapper< typename remove_reference< _Del> ::type> , _Del> ::type, allocator< void> , _Lp> > ; 
# 642
using _Alloc_traits = allocator_traits< allocator< _Sp_counted_deleter< typename unique_ptr< _Tp, _Del> ::pointer, typename conditional< is_reference< _Del> ::value, reference_wrapper< typename remove_reference< _Del> ::type> , _Del> ::type, allocator< void> , _Lp> > > ; 
# 643
_Alloc __a; 
# 644
_Sp_cd_type *__mem = _Alloc_traits::allocate(__a, 1); 
# 645
_Alloc_traits::construct(__a, __mem, (__r.release()), (__r.get_deleter())); 
# 647
(_M_pi) = __mem; 
# 648
} 
# 651
inline explicit __shared_count(const __weak_count< _Lp>  & __r); 
# 654
inline explicit __shared_count(const __weak_count< _Lp>  & __r, nothrow_t); 
# 656
~__shared_count() noexcept 
# 657
{ 
# 658
if ((_M_pi) != nullptr) { 
# 659
((_M_pi)->_M_release()); }  
# 660
} 
# 662
__shared_count(const __shared_count &__r) noexcept : _M_pi(((__r._M_pi))) 
# 664
{ 
# 665
if ((_M_pi) != 0) { 
# 666
((_M_pi)->_M_add_ref_copy()); }  
# 667
} 
# 670
__shared_count &operator=(const __shared_count &__r) noexcept 
# 671
{ 
# 672
_Sp_counted_base< _Lp>  *__tmp = ((__r._M_pi)); 
# 673
if (__tmp != (_M_pi)) 
# 674
{ 
# 675
if (__tmp != 0) { 
# 676
(__tmp->_M_add_ref_copy()); }  
# 677
if ((_M_pi) != 0) { 
# 678
((_M_pi)->_M_release()); }  
# 679
(_M_pi) = __tmp; 
# 680
}  
# 681
return *this; 
# 682
} 
# 685
void _M_swap(__shared_count &__r) noexcept 
# 686
{ 
# 687
_Sp_counted_base< _Lp>  *__tmp = ((__r._M_pi)); 
# 688
(__r._M_pi) = (_M_pi); 
# 689
(_M_pi) = __tmp; 
# 690
} 
# 693
long _M_get_use_count() const noexcept 
# 694
{ return ((_M_pi) != 0) ? ((_M_pi)->_M_get_use_count()) : 0; } 
# 697
bool _M_unique() const noexcept 
# 698
{ return this->_M_get_use_count() == (1); } 
# 701
void *_M_get_deleter(const type_info &__ti) const noexcept 
# 702
{ return (_M_pi) ? ((_M_pi)->_M_get_deleter(__ti)) : nullptr; } 
# 705
bool _M_less(const __shared_count &__rhs) const noexcept 
# 706
{ return less< _Sp_counted_base< _Lp>  *> ()(this->_M_pi, (__rhs._M_pi)); } 
# 709
bool _M_less(const __weak_count< _Lp>  &__rhs) const noexcept 
# 710
{ return less< _Sp_counted_base< _Lp>  *> ()(this->_M_pi, (__rhs._M_pi)); } 
# 714
friend inline bool operator==(const __shared_count &__a, const __shared_count &__b) noexcept 
# 715
{ return (__a._M_pi) == (__b._M_pi); } 
# 718
friend class __weak_count< _Lp> ; 
# 720
private: _Sp_counted_base< _Lp>  *_M_pi; 
# 721
}; 
# 724
template< __gnu_cxx::_Lock_policy _Lp> 
# 725
class __weak_count { 
# 728
public: constexpr __weak_count() noexcept : _M_pi((nullptr)) 
# 729
{ } 
# 731
__weak_count(const __shared_count< _Lp>  &__r) noexcept : _M_pi(((__r._M_pi))) 
# 733
{ 
# 734
if ((_M_pi) != nullptr) { 
# 735
((_M_pi)->_M_weak_add_ref()); }  
# 736
} 
# 738
__weak_count(const __weak_count &__r) noexcept : _M_pi(((__r._M_pi))) 
# 740
{ 
# 741
if ((_M_pi) != nullptr) { 
# 742
((_M_pi)->_M_weak_add_ref()); }  
# 743
} 
# 745
__weak_count(__weak_count &&__r) noexcept : _M_pi(((__r._M_pi))) 
# 747
{ (__r._M_pi) = nullptr; } 
# 749
~__weak_count() noexcept 
# 750
{ 
# 751
if ((_M_pi) != nullptr) { 
# 752
((_M_pi)->_M_weak_release()); }  
# 753
} 
# 756
__weak_count &operator=(const __shared_count< _Lp>  &__r) noexcept 
# 757
{ 
# 758
_Sp_counted_base< _Lp>  *__tmp = ((__r._M_pi)); 
# 759
if (__tmp != nullptr) { 
# 760
(__tmp->_M_weak_add_ref()); }  
# 761
if ((_M_pi) != nullptr) { 
# 762
((_M_pi)->_M_weak_release()); }  
# 763
(_M_pi) = __tmp; 
# 764
return *this; 
# 765
} 
# 768
__weak_count &operator=(const __weak_count &__r) noexcept 
# 769
{ 
# 770
_Sp_counted_base< _Lp>  *__tmp = ((__r._M_pi)); 
# 771
if (__tmp != nullptr) { 
# 772
(__tmp->_M_weak_add_ref()); }  
# 773
if ((_M_pi) != nullptr) { 
# 774
((_M_pi)->_M_weak_release()); }  
# 775
(_M_pi) = __tmp; 
# 776
return *this; 
# 777
} 
# 780
__weak_count &operator=(__weak_count &&__r) noexcept 
# 781
{ 
# 782
if ((_M_pi) != nullptr) { 
# 783
((_M_pi)->_M_weak_release()); }  
# 784
(_M_pi) = (__r._M_pi); 
# 785
(__r._M_pi) = nullptr; 
# 786
return *this; 
# 787
} 
# 790
void _M_swap(__weak_count &__r) noexcept 
# 791
{ 
# 792
_Sp_counted_base< _Lp>  *__tmp = ((__r._M_pi)); 
# 793
(__r._M_pi) = (_M_pi); 
# 794
(_M_pi) = __tmp; 
# 795
} 
# 798
long _M_get_use_count() const noexcept 
# 799
{ return ((_M_pi) != nullptr) ? ((_M_pi)->_M_get_use_count()) : 0; } 
# 802
bool _M_less(const __weak_count &__rhs) const noexcept 
# 803
{ return less< _Sp_counted_base< _Lp>  *> ()(this->_M_pi, (__rhs._M_pi)); } 
# 806
bool _M_less(const __shared_count< _Lp>  &__rhs) const noexcept 
# 807
{ return less< _Sp_counted_base< _Lp>  *> ()(this->_M_pi, (__rhs._M_pi)); } 
# 811
friend inline bool operator==(const __weak_count &__a, const __weak_count &__b) noexcept 
# 812
{ return (__a._M_pi) == (__b._M_pi); } 
# 815
friend class __shared_count< _Lp> ; 
# 817
private: _Sp_counted_base< _Lp>  *_M_pi; 
# 818
}; 
# 821
template< __gnu_cxx::_Lock_policy _Lp> inline 
# 823
__shared_count< _Lp> ::__shared_count(const __weak_count< _Lp>  &__r) : _M_pi(((__r._M_pi))) 
# 825
{ 
# 826
if ((_M_pi) != nullptr) { 
# 827
((_M_pi)->_M_add_ref_lock()); } else { 
# 829
__throw_bad_weak_ptr(); }  
# 830
} 
# 833
template< __gnu_cxx::_Lock_policy _Lp> inline 
# 836
__shared_count< _Lp> ::__shared_count(const __weak_count< _Lp>  &__r, nothrow_t) : _M_pi(((__r._M_pi))) 
# 838
{ 
# 839
if ((_M_pi) != nullptr) { 
# 840
if (!((_M_pi)->_M_add_ref_lock_nothrow())) { 
# 841
(_M_pi) = nullptr; }  }  
# 842
} 
# 847
template< __gnu_cxx::_Lock_policy _Lp, class _Tp1, class _Tp2> inline void __enable_shared_from_this_helper(const __shared_count< _Lp>  &, const __enable_shared_from_this< _Tp1, _Lp>  *, const _Tp2 *) noexcept; 
# 854
template< class _Tp1, class _Tp2> inline void __enable_shared_from_this_helper(const __shared_count< __gnu_cxx::_S_atomic>  &, const enable_shared_from_this< _Tp1>  *, const _Tp2 *) noexcept; 
# 860
template< __gnu_cxx::_Lock_policy _Lp> inline void 
# 862
__enable_shared_from_this_helper(const __shared_count< _Lp>  &, ...) noexcept 
# 863
{ } 
# 866
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 867
class __shared_ptr { 
# 869
template< class _Ptr> using _Convertible = typename enable_if< is_convertible< _Ptr, _Tp *> ::value> ::type; 
# 874
public: typedef _Tp element_type; 
# 876
constexpr __shared_ptr() noexcept : _M_ptr((0)), _M_refcount() 
# 878
{ } 
# 880
template< class _Tp1> explicit 
# 881
__shared_ptr(_Tp1 *__p) : _M_ptr(__p), _M_refcount(__p) 
# 883
{ 
# 885
static_assert((!is_void< _Tp1> ::value), "incomplete type");
# 886
static_assert((sizeof(_Tp1) > (0)), "incomplete type");
# 887
__enable_shared_from_this_helper(_M_refcount, __p, __p); 
# 888
} 
# 890
template< class _Tp1, class _Deleter> 
# 891
__shared_ptr(_Tp1 *__p, _Deleter __d) : _M_ptr(__p), _M_refcount(__p, __d) 
# 893
{ 
# 896
__enable_shared_from_this_helper(_M_refcount, __p, __p); 
# 897
} 
# 899
template< class _Tp1, class _Deleter, class _Alloc> 
# 900
__shared_ptr(_Tp1 *__p, _Deleter __d, _Alloc __a) : _M_ptr(__p), _M_refcount(__p, __d, std::move(__a)) 
# 902
{ 
# 905
__enable_shared_from_this_helper(_M_refcount, __p, __p); 
# 906
} 
# 908
template< class _Deleter> 
# 909
__shared_ptr(nullptr_t __p, _Deleter __d) : _M_ptr((0)), _M_refcount(__p, __d) 
# 911
{ } 
# 913
template< class _Deleter, class _Alloc> 
# 914
__shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a) : _M_ptr((0)), _M_refcount(__p, __d, std::move(__a)) 
# 916
{ } 
# 918
template< class _Tp1> 
# 919
__shared_ptr(const std::__shared_ptr< _Tp1, _Lp>  &__r, _Tp *__p) noexcept : _M_ptr(__p), _M_refcount((__r._M_refcount)) 
# 921
{ } 
# 923
__shared_ptr(const __shared_ptr &) noexcept = default;
# 924
__shared_ptr &operator=(const __shared_ptr &) noexcept = default;
# 925
~__shared_ptr() = default;
# 927
template< class _Tp1, class  = _Convertible< _Tp1 *> > 
# 928
__shared_ptr(const std::__shared_ptr< _Tp1, _Lp>  &__r) noexcept : _M_ptr(((__r._M_ptr))), _M_refcount((__r._M_refcount)) 
# 930
{ } 
# 932
__shared_ptr(__shared_ptr &&__r) noexcept : _M_ptr(((__r._M_ptr))), _M_refcount() 
# 934
{ 
# 935
((_M_refcount)._M_swap((__r._M_refcount))); 
# 936
(__r._M_ptr) = 0; 
# 937
} 
# 939
template< class _Tp1, class  = _Convertible< _Tp1 *> > 
# 940
__shared_ptr(std::__shared_ptr< _Tp1, _Lp>  &&__r) noexcept : _M_ptr(((__r._M_ptr))), _M_refcount() 
# 942
{ 
# 943
((_M_refcount)._M_swap((__r._M_refcount))); 
# 944
(__r._M_ptr) = 0; 
# 945
} 
# 947
template< class _Tp1> explicit 
# 948
__shared_ptr(const __weak_ptr< _Tp1, _Lp>  &__r) : _M_refcount((__r._M_refcount)) 
# 950
{ 
# 955
(_M_ptr) = (__r._M_ptr); 
# 956
} 
# 959
template< class _Tp1, class _Del, class 
# 960
 = _Convertible< typename unique_ptr< _Tp1, _Del> ::pointer> > 
# 961
__shared_ptr(unique_ptr< _Tp1, _Del>  &&__r) : _M_ptr((__r.get())), _M_refcount() 
# 963
{ 
# 965
auto __raw = _S_raw_ptr((__r.get())); 
# 966
(_M_refcount) = ((__shared_count< _Lp> )(std::move(__r))); 
# 967
__enable_shared_from_this_helper(_M_refcount, __raw, __raw); 
# 968
} 
# 972
template< class _Tp1> inline __shared_ptr(auto_ptr< _Tp1>  && __r); 
# 976
constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { } 
# 978
template< class _Tp1> __shared_ptr &
# 980
operator=(const std::__shared_ptr< _Tp1, _Lp>  &__r) noexcept 
# 981
{ 
# 982
(_M_ptr) = (__r._M_ptr); 
# 983
(_M_refcount) = (__r._M_refcount); 
# 984
return *this; 
# 985
} 
# 988
template< class _Tp1> __shared_ptr &
# 990
operator=(auto_ptr< _Tp1>  &&__r) 
# 991
{ 
# 992
(((__shared_ptr)(std::move(__r))).swap(*this)); 
# 993
return *this; 
# 994
} 
# 998
__shared_ptr &operator=(__shared_ptr &&__r) noexcept 
# 999
{ 
# 1000
(((__shared_ptr)(std::move(__r))).swap(*this)); 
# 1001
return *this; 
# 1002
} 
# 1004
template< class _Tp1> __shared_ptr &
# 1006
operator=(std::__shared_ptr< _Tp1, _Lp>  &&__r) noexcept 
# 1007
{ 
# 1008
(((__shared_ptr)(std::move(__r))).swap(*this)); 
# 1009
return *this; 
# 1010
} 
# 1012
template< class _Tp1, class _Del> __shared_ptr &
# 1014
operator=(unique_ptr< _Tp1, _Del>  &&__r) 
# 1015
{ 
# 1016
(((__shared_ptr)(std::move(__r))).swap(*this)); 
# 1017
return *this; 
# 1018
} 
# 1021
void reset() noexcept 
# 1022
{ (__shared_ptr().swap(*this)); } 
# 1024
template< class _Tp1> void 
# 1026
reset(_Tp1 *__p) 
# 1027
{ 
# 1029
; 
# 1030
(((__shared_ptr)(__p)).swap(*this)); 
# 1031
} 
# 1033
template< class _Tp1, class _Deleter> void 
# 1035
reset(_Tp1 *__p, _Deleter __d) 
# 1036
{ (__shared_ptr(__p, __d).swap(*this)); } 
# 1038
template< class _Tp1, class _Deleter, class _Alloc> void 
# 1040
reset(_Tp1 *__p, _Deleter __d, _Alloc __a) 
# 1041
{ (__shared_ptr(__p, __d, std::move(__a)).swap(*this)); } 
# 1045
typename add_lvalue_reference< _Tp> ::type operator*() const noexcept 
# 1046
{ 
# 1047
; 
# 1048
return *(_M_ptr); 
# 1049
} 
# 1052
_Tp *operator->() const noexcept 
# 1053
{ 
# 1054
; 
# 1055
return _M_ptr; 
# 1056
} 
# 1059
_Tp *get() const noexcept 
# 1060
{ return _M_ptr; } 
# 1062
explicit operator bool() const 
# 1063
{ return ((_M_ptr) == 0) ? false : true; } 
# 1066
bool unique() const noexcept 
# 1067
{ return ((_M_refcount)._M_unique()); } 
# 1070
long use_count() const noexcept 
# 1071
{ return ((_M_refcount)._M_get_use_count()); } 
# 1074
void swap(__shared_ptr &__other) noexcept 
# 1075
{ 
# 1076
std::swap(_M_ptr, (__other._M_ptr)); 
# 1077
((_M_refcount)._M_swap((__other._M_refcount))); 
# 1078
} 
# 1080
template< class _Tp1> bool 
# 1082
owner_before(const std::__shared_ptr< _Tp1, _Lp>  &__rhs) const 
# 1083
{ return ((_M_refcount)._M_less((__rhs._M_refcount))); } 
# 1085
template< class _Tp1> bool 
# 1087
owner_before(const __weak_ptr< _Tp1, _Lp>  &__rhs) const 
# 1088
{ return ((_M_refcount)._M_less((__rhs._M_refcount))); } 
# 1094
protected: 
# 1093
template< class _Alloc, class ..._Args> 
# 1094
__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc &__a, _Args &&...
# 1095
__args) : _M_ptr(), _M_refcount(__tag, (_Tp *)0, __a, std::forward< _Args> (__args)...) 
# 1098
{ 
# 1101
void *__p = ((_M_refcount)._M_get_deleter(typeid(_Sp_make_shared_tag))); 
# 1102
(_M_ptr) = (static_cast< _Tp *>(__p)); 
# 1103
__enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr); 
# 1104
} 
# 1139 "/usr/include/c++/5/bits/shared_ptr_base.h" 3
template< class _Tp1, __gnu_cxx::_Lock_policy _Lp1, class _Alloc, class ...
# 1140
_Args> friend std::__shared_ptr< _Tp1, _Lp1>  
# 1139
__allocate_shared(const _Alloc & __a, _Args && ...__args); 
# 1146
__shared_ptr(const __weak_ptr< _Tp, _Lp>  &__r, nothrow_t) : _M_refcount((__r._M_refcount), std::nothrow) 
# 1148
{ 
# 1149
(_M_ptr) = ((((_M_refcount)._M_get_use_count())) ? __r._M_ptr : nullptr); 
# 1150
} 
# 1152
friend class __weak_ptr< _Tp, _Lp> ; 
# 1156
private: void *_M_get_deleter(const type_info &__ti) const noexcept 
# 1157
{ return ((_M_refcount)._M_get_deleter(__ti)); } 
# 1159
template< class _Tp1> static _Tp1 *
# 1161
_S_raw_ptr(_Tp1 *__ptr) 
# 1162
{ return __ptr; } 
# 1164
template< class _Tp1> static auto 
# 1166
_S_raw_ptr(_Tp1 __ptr)->__decltype((std::__addressof(*__ptr))) 
# 1167
{ return std::__addressof(*__ptr); } 
# 1169
template< class _Tp1, __gnu_cxx::_Lock_policy _Lp1> friend class __shared_ptr; 
# 1170
template< class _Tp1, __gnu_cxx::_Lock_policy _Lp1> friend class __weak_ptr; 
# 1172
template< class _Del, class _Tp1, __gnu_cxx::_Lock_policy _Lp1> friend _Del *get_deleter(const std::__shared_ptr< _Tp1, _Lp1>  &) noexcept; 
# 1175
_Tp *_M_ptr; 
# 1176
__shared_count< _Lp>  _M_refcount; 
# 1177
}; 
# 1181
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1183
operator==(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1184
__b) noexcept 
# 1185
{ return (__a.get()) == (__b.get()); } 
# 1187
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1189
operator==(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1190
{ return !__a; } 
# 1192
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1194
operator==(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1195
{ return !__a; } 
# 1197
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1199
operator!=(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1200
__b) noexcept 
# 1201
{ return (__a.get()) != (__b.get()); } 
# 1203
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1205
operator!=(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1206
{ return (bool)__a; } 
# 1208
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1210
operator!=(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1211
{ return (bool)__a; } 
# 1213
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1215
operator<(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1216
__b) noexcept 
# 1217
{ 
# 1218
typedef typename common_type< _Tp1 *, _Tp2 *> ::type _CT; 
# 1219
return less< typename common_type< _Tp1 *, _Tp2 *> ::type> ()((__a.get()), (__b.get())); 
# 1220
} 
# 1222
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1224
operator<(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1225
{ return less< _Tp *> ()((__a.get()), nullptr); } 
# 1227
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1229
operator<(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1230
{ return less< _Tp *> ()(nullptr, (__a.get())); } 
# 1232
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1234
operator<=(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1235
__b) noexcept 
# 1236
{ return !(__b < __a); } 
# 1238
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1240
operator<=(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1241
{ return !(nullptr < __a); } 
# 1243
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1245
operator<=(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1246
{ return !(__a < nullptr); } 
# 1248
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1250
operator>(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1251
__b) noexcept 
# 1252
{ return __b < __a; } 
# 1254
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1256
operator>(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1257
{ return less< _Tp *> ()(nullptr, (__a.get())); } 
# 1259
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1261
operator>(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1262
{ return less< _Tp *> ()((__a.get()), nullptr); } 
# 1264
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1266
operator>=(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1267
__b) noexcept 
# 1268
{ return !(__a < __b); } 
# 1270
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1272
operator>=(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1273
{ return !(__a < nullptr); } 
# 1275
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1277
operator>=(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1278
{ return !(nullptr < __a); } 
# 1280
template< class _Sp> 
# 1281
struct _Sp_less : public binary_function< _Sp, _Sp, bool>  { 
# 1284
bool operator()(const _Sp &__lhs, const _Sp &__rhs) const noexcept 
# 1285
{ 
# 1286
typedef typename _Sp::element_type element_type; 
# 1287
return less< typename _Sp::element_type *> ()((__lhs.get()), (__rhs.get())); 
# 1288
} 
# 1289
}; 
# 1291
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1292
struct less< __shared_ptr< _Tp, _Lp> >  : public _Sp_less< __shared_ptr< _Tp, _Lp> >  { 
# 1294
}; 
# 1297
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline void 
# 1299
swap(__shared_ptr< _Tp, _Lp>  &__a, __shared_ptr< _Tp, _Lp>  &__b) noexcept 
# 1300
{ (__a.swap(__b)); } 
# 1309 "/usr/include/c++/5/bits/shared_ptr_base.h" 3
template< class _Tp, class _Tp1, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 1311
static_pointer_cast(const __shared_ptr< _Tp1, _Lp>  &__r) noexcept 
# 1312
{ return __shared_ptr< _Tp, _Lp> (__r, static_cast< _Tp *>((__r.get()))); } 
# 1319
template< class _Tp, class _Tp1, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 1321
const_pointer_cast(const __shared_ptr< _Tp1, _Lp>  &__r) noexcept 
# 1322
{ return __shared_ptr< _Tp, _Lp> (__r, const_cast< _Tp *>((__r.get()))); } 
# 1329
template< class _Tp, class _Tp1, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 1331
dynamic_pointer_cast(const __shared_ptr< _Tp1, _Lp>  &__r) noexcept 
# 1332
{ 
# 1333
if (_Tp *__p = dynamic_cast< _Tp *>((__r.get()))) { 
# 1334
return __shared_ptr< _Tp, _Lp> (__r, __p); }  
# 1335
return __shared_ptr< _Tp, _Lp> (); 
# 1336
} 
# 1339
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1340
class __weak_ptr { 
# 1342
template< class _Ptr> using _Convertible = typename enable_if< is_convertible< _Ptr, _Tp *> ::value> ::type; 
# 1347
public: typedef _Tp element_type; 
# 1349
constexpr __weak_ptr() noexcept : _M_ptr((nullptr)), _M_refcount() 
# 1351
{ } 
# 1353
__weak_ptr(const __weak_ptr &) noexcept = default;
# 1355
~__weak_ptr() = default;
# 1371 "/usr/include/c++/5/bits/shared_ptr_base.h" 3
template< class _Tp1, class  = _Convertible< _Tp1 *> > 
# 1372
__weak_ptr(const std::__weak_ptr< _Tp1, _Lp>  &__r) noexcept : _M_refcount((__r._M_refcount)) 
# 1374
{ (_M_ptr) = ((__r.lock()).get()); } 
# 1376
template< class _Tp1, class  = _Convertible< _Tp1 *> > 
# 1377
__weak_ptr(const __shared_ptr< _Tp1, _Lp>  &__r) noexcept : _M_ptr(((__r._M_ptr))), _M_refcount((__r._M_refcount)) 
# 1379
{ } 
# 1381
__weak_ptr(__weak_ptr &&__r) noexcept : _M_ptr(((__r._M_ptr))), _M_refcount(std::move((__r._M_refcount))) 
# 1383
{ (__r._M_ptr) = nullptr; } 
# 1385
template< class _Tp1, class  = _Convertible< _Tp1 *> > 
# 1386
__weak_ptr(std::__weak_ptr< _Tp1, _Lp>  &&__r) noexcept : _M_ptr(((__r.lock()).get())), _M_refcount(std::move((__r._M_refcount))) 
# 1388
{ (__r._M_ptr) = nullptr; } 
# 1391
__weak_ptr &operator=(const __weak_ptr & __r) noexcept = default;
# 1393
template< class _Tp1> __weak_ptr &
# 1395
operator=(const std::__weak_ptr< _Tp1, _Lp>  &__r) noexcept 
# 1396
{ 
# 1397
(_M_ptr) = ((__r.lock()).get()); 
# 1398
(_M_refcount) = (__r._M_refcount); 
# 1399
return *this; 
# 1400
} 
# 1402
template< class _Tp1> __weak_ptr &
# 1404
operator=(const __shared_ptr< _Tp1, _Lp>  &__r) noexcept 
# 1405
{ 
# 1406
(_M_ptr) = (__r._M_ptr); 
# 1407
(_M_refcount) = (__r._M_refcount); 
# 1408
return *this; 
# 1409
} 
# 1412
__weak_ptr &operator=(__weak_ptr &&__r) noexcept 
# 1413
{ 
# 1414
(_M_ptr) = (__r._M_ptr); 
# 1415
(_M_refcount) = std::move((__r._M_refcount)); 
# 1416
(__r._M_ptr) = nullptr; 
# 1417
return *this; 
# 1418
} 
# 1420
template< class _Tp1> __weak_ptr &
# 1422
operator=(std::__weak_ptr< _Tp1, _Lp>  &&__r) noexcept 
# 1423
{ 
# 1424
(_M_ptr) = ((__r.lock()).get()); 
# 1425
(_M_refcount) = std::move((__r._M_refcount)); 
# 1426
(__r._M_ptr) = nullptr; 
# 1427
return *this; 
# 1428
} 
# 1431
__shared_ptr< _Tp, _Lp>  lock() const noexcept 
# 1432
{ return __shared_ptr< _Tp, _Lp> (*this, std::nothrow); } 
# 1435
long use_count() const noexcept 
# 1436
{ return ((_M_refcount)._M_get_use_count()); } 
# 1439
bool expired() const noexcept 
# 1440
{ return ((_M_refcount)._M_get_use_count()) == 0; } 
# 1442
template< class _Tp1> bool 
# 1444
owner_before(const __shared_ptr< _Tp1, _Lp>  &__rhs) const 
# 1445
{ return ((_M_refcount)._M_less((__rhs._M_refcount))); } 
# 1447
template< class _Tp1> bool 
# 1449
owner_before(const std::__weak_ptr< _Tp1, _Lp>  &__rhs) const 
# 1450
{ return ((_M_refcount)._M_less((__rhs._M_refcount))); } 
# 1453
void reset() noexcept 
# 1454
{ (__weak_ptr().swap(*this)); } 
# 1457
void swap(__weak_ptr &__s) noexcept 
# 1458
{ 
# 1459
std::swap(_M_ptr, (__s._M_ptr)); 
# 1460
((_M_refcount)._M_swap((__s._M_refcount))); 
# 1461
} 
# 1466
private: void _M_assign(_Tp *__ptr, const __shared_count< _Lp>  &__refcount) noexcept 
# 1467
{ 
# 1468
(_M_ptr) = __ptr; 
# 1469
(_M_refcount) = __refcount; 
# 1470
} 
# 1472
template< class _Tp1, __gnu_cxx::_Lock_policy _Lp1> friend class __shared_ptr; 
# 1473
template< class _Tp1, __gnu_cxx::_Lock_policy _Lp1> friend class __weak_ptr; 
# 1474
friend class __enable_shared_from_this< _Tp, _Lp> ; 
# 1475
friend class enable_shared_from_this< _Tp> ; 
# 1477
_Tp *_M_ptr; 
# 1478
__weak_count< _Lp>  _M_refcount; 
# 1479
}; 
# 1482
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline void 
# 1484
swap(__weak_ptr< _Tp, _Lp>  &__a, __weak_ptr< _Tp, _Lp>  &__b) noexcept 
# 1485
{ (__a.swap(__b)); } 
# 1487
template< class _Tp, class _Tp1> 
# 1488
struct _Sp_owner_less : public binary_function< _Tp, _Tp, bool>  { 
# 1491
bool operator()(const _Tp &__lhs, const _Tp &__rhs) const 
# 1492
{ return (__lhs.owner_before(__rhs)); } 
# 1495
bool operator()(const _Tp &__lhs, const _Tp1 &__rhs) const 
# 1496
{ return (__lhs.owner_before(__rhs)); } 
# 1499
bool operator()(const _Tp1 &__lhs, const _Tp &__rhs) const 
# 1500
{ return (__lhs.owner_before(__rhs)); } 
# 1501
}; 
# 1503
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1504
struct owner_less< __shared_ptr< _Tp, _Lp> >  : public _Sp_owner_less< __shared_ptr< _Tp, _Lp> , __weak_ptr< _Tp, _Lp> >  { 
# 1506
}; 
# 1508
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1509
struct owner_less< __weak_ptr< _Tp, _Lp> >  : public _Sp_owner_less< __weak_ptr< _Tp, _Lp> , __shared_ptr< _Tp, _Lp> >  { 
# 1511
}; 
# 1514
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1515
class __enable_shared_from_this { 
# 1518
protected: constexpr __enable_shared_from_this() noexcept { } 
# 1520
__enable_shared_from_this(const __enable_shared_from_this &) noexcept { } 
# 1523
__enable_shared_from_this &operator=(const __enable_shared_from_this &) noexcept 
# 1524
{ return *this; } 
# 1526
~__enable_shared_from_this() { } 
# 1530
public: __shared_ptr< _Tp, _Lp>  shared_from_this() 
# 1531
{ return ((__shared_ptr< _Tp, _Lp> )(this->_M_weak_this)); } 
# 1534
__shared_ptr< const _Tp, _Lp>  shared_from_this() const 
# 1535
{ return ((__shared_ptr< const _Tp, _Lp> )(this->_M_weak_this)); } 
# 1540
private: 
# 1538
template< class _Tp1> void 
# 1540
_M_weak_assign(_Tp1 *__p, const __shared_count< _Lp>  &__n) const noexcept 
# 1541
{ ((_M_weak_this)._M_assign(__p, __n)); } 
# 1543
template< __gnu_cxx::_Lock_policy _Lp1, class _Tp1, class _Tp2> friend void __enable_shared_from_this_helper(const __shared_count< _Lp1>  &, const std::__enable_shared_from_this< _Tp1, _Lp1>  *, const _Tp2 *) noexcept; 
# 1549
mutable __weak_ptr< _Tp, _Lp>  _M_weak_this; 
# 1550
}; 
# 1552
template< __gnu_cxx::_Lock_policy _Lp1, class _Tp1, class _Tp2> inline void 
# 1554
__enable_shared_from_this_helper(const __shared_count< _Lp1>  &__pn, const __enable_shared_from_this< _Tp1, _Lp1>  *
# 1556
__pe, const _Tp2 *
# 1557
__px) noexcept 
# 1558
{ 
# 1559
if (__pe != nullptr) { 
# 1560
(__pe->_M_weak_assign(const_cast< _Tp2 *>(__px), __pn)); }  
# 1561
} 
# 1563
template< class _Tp, __gnu_cxx::_Lock_policy _Lp, class _Alloc, class ..._Args> inline __shared_ptr< _Tp, _Lp>  
# 1565
__allocate_shared(const _Alloc &__a, _Args &&...__args) 
# 1566
{ 
# 1567
return __shared_ptr< _Tp, _Lp> (_Sp_make_shared_tag(), __a, std::forward< _Args> (__args)...); 
# 1569
} 
# 1571
template< class _Tp, __gnu_cxx::_Lock_policy _Lp, class ..._Args> inline __shared_ptr< _Tp, _Lp>  
# 1573
__make_shared(_Args &&...__args) 
# 1574
{ 
# 1575
typedef typename remove_const< _Tp> ::type _Tp_nc; 
# 1576
return std::__allocate_shared< _Tp, _Lp> (allocator< typename remove_const< _Tp> ::type> (), std::forward< _Args> (__args)...); 
# 1578
} 
# 1581
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1582
struct hash< __shared_ptr< _Tp, _Lp> >  : public __hash_base< unsigned long, __shared_ptr< _Tp, _Lp> >  { 
# 1586
::std::size_t operator()(const __shared_ptr< _Tp, _Lp>  &__s) const noexcept 
# 1587
{ return ::std::hash< _Tp *> ()((__s.get())); } 
# 1588
}; 
# 1591
}
# 54 "/usr/include/c++/5/bits/shared_ptr.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 64
template< class _Ch, class _Tr, class _Tp, __gnu_cxx::_Lock_policy _Lp> inline basic_ostream< _Ch, _Tr>  &
# 66
operator<<(basic_ostream< _Ch, _Tr>  &__os, const __shared_ptr< _Tp, _Lp>  &
# 67
__p) 
# 68
{ 
# 69
__os << (__p.get()); 
# 70
return __os; 
# 71
} 
# 74
template< class _Del, class _Tp, __gnu_cxx::_Lock_policy _Lp> inline _Del *
# 76
get_deleter(const __shared_ptr< _Tp, _Lp>  &__p) noexcept 
# 77
{ 
# 79
return static_cast< _Del *>((__p._M_get_deleter(typeid(_Del)))); 
# 83
} 
# 92 "/usr/include/c++/5/bits/shared_ptr.h" 3
template< class _Tp> 
# 93
class shared_ptr : public __shared_ptr< _Tp, __gnu_cxx::_S_atomic>  { 
# 95
template< class _Ptr> using _Convertible = typename enable_if< is_convertible< _Ptr, _Tp *> ::value> ::type; 
# 104
public: constexpr shared_ptr() noexcept : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> () 
# 105
{ } 
# 107
shared_ptr(const shared_ptr &) noexcept = default;
# 115
template< class _Tp1> explicit 
# 116
shared_ptr(_Tp1 *__p) : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__p) 
# 117
{ } 
# 132 "/usr/include/c++/5/bits/shared_ptr.h" 3
template< class _Tp1, class _Deleter> 
# 133
shared_ptr(_Tp1 *__p, _Deleter __d) : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__p, __d) 
# 134
{ } 
# 149 "/usr/include/c++/5/bits/shared_ptr.h" 3
template< class _Deleter> 
# 150
shared_ptr(::std::nullptr_t __p, _Deleter __d) : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__p, __d) 
# 151
{ } 
# 168 "/usr/include/c++/5/bits/shared_ptr.h" 3
template< class _Tp1, class _Deleter, class _Alloc> 
# 169
shared_ptr(_Tp1 *__p, _Deleter __d, _Alloc __a) : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__p, __d, ::std::move(__a)) 
# 170
{ } 
# 187 "/usr/include/c++/5/bits/shared_ptr.h" 3
template< class _Deleter, class _Alloc> 
# 188
shared_ptr(::std::nullptr_t __p, _Deleter __d, _Alloc __a) : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__p, __d, ::std::move(__a)) 
# 189
{ } 
# 209 "/usr/include/c++/5/bits/shared_ptr.h" 3
template< class _Tp1> 
# 210
shared_ptr(const ::std::shared_ptr< _Tp1>  &__r, _Tp *__p) noexcept : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__r, __p) 
# 211
{ } 
# 220 "/usr/include/c++/5/bits/shared_ptr.h" 3
template< class _Tp1, class  = _Convertible< _Tp1 *> > 
# 221
shared_ptr(const ::std::shared_ptr< _Tp1>  &__r) noexcept : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__r) 
# 222
{ } 
# 229
shared_ptr(shared_ptr &&__r) noexcept : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (::std::move(__r)) 
# 230
{ } 
# 237
template< class _Tp1, class  = _Convertible< _Tp1 *> > 
# 238
shared_ptr(::std::shared_ptr< _Tp1>  &&__r) noexcept : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (::std::move(__r)) 
# 239
{ } 
# 249 "/usr/include/c++/5/bits/shared_ptr.h" 3
template< class _Tp1> explicit 
# 250
shared_ptr(const weak_ptr< _Tp1>  &__r) : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__r) 
# 251
{ } 
# 254
template< class _Tp1> inline shared_ptr(auto_ptr< _Tp1>  && __r); 
# 260
template< class _Tp1, class _Del, class 
# 261
 = _Convertible< typename unique_ptr< _Tp1, _Del> ::pointer> > 
# 262
shared_ptr(unique_ptr< _Tp1, _Del>  &&__r) : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (::std::move(__r)) 
# 263
{ } 
# 269
constexpr shared_ptr(::std::nullptr_t) noexcept : shared_ptr() { } 
# 271
shared_ptr &operator=(const shared_ptr &) noexcept = default;
# 273
template< class _Tp1> shared_ptr &
# 275
operator=(const ::std::shared_ptr< _Tp1>  &__r) noexcept 
# 276
{ 
# 277
(this->::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> ::operator=(__r)); 
# 278
return *this; 
# 279
} 
# 282
template< class _Tp1> shared_ptr &
# 284
operator=(auto_ptr< _Tp1>  &&__r) 
# 285
{ 
# 286
(this->::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> ::operator=(::std::move(__r))); 
# 287
return *this; 
# 288
} 
# 292
shared_ptr &operator=(shared_ptr &&__r) noexcept 
# 293
{ 
# 294
(this->::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> ::operator=(::std::move(__r))); 
# 295
return *this; 
# 296
} 
# 298
template< class _Tp1> shared_ptr &
# 300
operator=(::std::shared_ptr< _Tp1>  &&__r) noexcept 
# 301
{ 
# 302
(this->::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> ::operator=(::std::move(__r))); 
# 303
return *this; 
# 304
} 
# 306
template< class _Tp1, class _Del> shared_ptr &
# 308
operator=(unique_ptr< _Tp1, _Del>  &&__r) 
# 309
{ 
# 310
(this->::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> ::operator=(::std::move(__r))); 
# 311
return *this; 
# 312
} 
# 317
private: 
# 316
template< class _Alloc, class ..._Args> 
# 317
shared_ptr(::std::_Sp_make_shared_tag __tag, const _Alloc &__a, _Args &&...
# 318
__args) : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__tag, __a, ::std::forward< _Args> (__args)...) 
# 320
{ } 
# 322
template< class _Tp1, class _Alloc, class ..._Args> friend ::std::shared_ptr< _Tp1>  allocate_shared(const _Alloc & __a, _Args && ...__args); 
# 327
shared_ptr(const weak_ptr< _Tp>  &__r, ::std::nothrow_t) : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__r, std::nothrow) 
# 328
{ } 
# 330
friend class weak_ptr< _Tp> ; 
# 331
}; 
# 334
template< class _Tp1, class _Tp2> inline bool 
# 336
operator==(const shared_ptr< _Tp1>  &__a, const shared_ptr< _Tp2>  &
# 337
__b) noexcept 
# 338
{ return (__a.get()) == (__b.get()); } 
# 340
template< class _Tp> inline bool 
# 342
operator==(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 343
{ return !__a; } 
# 345
template< class _Tp> inline bool 
# 347
operator==(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 348
{ return !__a; } 
# 350
template< class _Tp1, class _Tp2> inline bool 
# 352
operator!=(const shared_ptr< _Tp1>  &__a, const shared_ptr< _Tp2>  &
# 353
__b) noexcept 
# 354
{ return (__a.get()) != (__b.get()); } 
# 356
template< class _Tp> inline bool 
# 358
operator!=(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 359
{ return (bool)__a; } 
# 361
template< class _Tp> inline bool 
# 363
operator!=(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 364
{ return (bool)__a; } 
# 366
template< class _Tp1, class _Tp2> inline bool 
# 368
operator<(const shared_ptr< _Tp1>  &__a, const shared_ptr< _Tp2>  &
# 369
__b) noexcept 
# 370
{ 
# 371
typedef typename common_type< _Tp1 *, _Tp2 *> ::type _CT; 
# 372
return less< typename common_type< _Tp1 *, _Tp2 *> ::type> ()((__a.get()), (__b.get())); 
# 373
} 
# 375
template< class _Tp> inline bool 
# 377
operator<(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 378
{ return less< _Tp *> ()((__a.get()), nullptr); } 
# 380
template< class _Tp> inline bool 
# 382
operator<(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 383
{ return less< _Tp *> ()(nullptr, (__a.get())); } 
# 385
template< class _Tp1, class _Tp2> inline bool 
# 387
operator<=(const shared_ptr< _Tp1>  &__a, const shared_ptr< _Tp2>  &
# 388
__b) noexcept 
# 389
{ return !(__b < __a); } 
# 391
template< class _Tp> inline bool 
# 393
operator<=(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 394
{ return !(nullptr < __a); } 
# 396
template< class _Tp> inline bool 
# 398
operator<=(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 399
{ return !(__a < nullptr); } 
# 401
template< class _Tp1, class _Tp2> inline bool 
# 403
operator>(const shared_ptr< _Tp1>  &__a, const shared_ptr< _Tp2>  &
# 404
__b) noexcept 
# 405
{ return __b < __a; } 
# 407
template< class _Tp> inline bool 
# 409
operator>(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 410
{ return less< _Tp *> ()(nullptr, (__a.get())); } 
# 412
template< class _Tp> inline bool 
# 414
operator>(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 415
{ return less< _Tp *> ()((__a.get()), nullptr); } 
# 417
template< class _Tp1, class _Tp2> inline bool 
# 419
operator>=(const shared_ptr< _Tp1>  &__a, const shared_ptr< _Tp2>  &
# 420
__b) noexcept 
# 421
{ return !(__a < __b); } 
# 423
template< class _Tp> inline bool 
# 425
operator>=(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 426
{ return !(__a < nullptr); } 
# 428
template< class _Tp> inline bool 
# 430
operator>=(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 431
{ return !(nullptr < __a); } 
# 433
template< class _Tp> 
# 434
struct less< shared_ptr< _Tp> >  : public _Sp_less< shared_ptr< _Tp> >  { 
# 435
}; 
# 438
template< class _Tp> inline void 
# 440
swap(shared_ptr< _Tp>  &__a, shared_ptr< _Tp>  &__b) noexcept 
# 441
{ (__a.swap(__b)); } 
# 444
template< class _Tp, class _Tp1> inline shared_ptr< _Tp>  
# 446
static_pointer_cast(const shared_ptr< _Tp1>  &__r) noexcept 
# 447
{ return shared_ptr< _Tp> (__r, static_cast< _Tp *>((__r.get()))); } 
# 449
template< class _Tp, class _Tp1> inline shared_ptr< _Tp>  
# 451
const_pointer_cast(const shared_ptr< _Tp1>  &__r) noexcept 
# 452
{ return shared_ptr< _Tp> (__r, const_cast< _Tp *>((__r.get()))); } 
# 454
template< class _Tp, class _Tp1> inline shared_ptr< _Tp>  
# 456
dynamic_pointer_cast(const shared_ptr< _Tp1>  &__r) noexcept 
# 457
{ 
# 458
if (_Tp *__p = dynamic_cast< _Tp *>((__r.get()))) { 
# 459
return shared_ptr< _Tp> (__r, __p); }  
# 460
return shared_ptr< _Tp> (); 
# 461
} 
# 469
template< class _Tp> 
# 470
class weak_ptr : public __weak_ptr< _Tp, __gnu_cxx::_S_atomic>  { 
# 472
template< class _Ptr> using _Convertible = typename enable_if< is_convertible< _Ptr, _Tp *> ::value> ::type; 
# 477
public: constexpr weak_ptr() noexcept = default;
# 479
template< class _Tp1, class  = _Convertible< _Tp1 *> > 
# 480
weak_ptr(const shared_ptr< _Tp1>  &__r) noexcept : ::std::__weak_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__r) 
# 481
{ } 
# 483
weak_ptr(const weak_ptr &) noexcept = default;
# 485
template< class _Tp1, class  = _Convertible< _Tp1 *> > 
# 486
weak_ptr(const ::std::weak_ptr< _Tp1>  &__r) noexcept : ::std::__weak_ptr< _Tp, ::__gnu_cxx::_S_atomic> (__r) 
# 487
{ } 
# 489
weak_ptr(weak_ptr &&) noexcept = default;
# 491
template< class _Tp1, class  = _Convertible< _Tp1 *> > 
# 492
weak_ptr(::std::weak_ptr< _Tp1>  &&__r) noexcept : ::std::__weak_ptr< _Tp, ::__gnu_cxx::_S_atomic> (::std::move(__r)) 
# 493
{ } 
# 496
weak_ptr &operator=(const weak_ptr & __r) noexcept = default;
# 498
template< class _Tp1> weak_ptr &
# 500
operator=(const ::std::weak_ptr< _Tp1>  &__r) noexcept 
# 501
{ 
# 502
(this->::std::__weak_ptr< _Tp, ::__gnu_cxx::_S_atomic> ::operator=(__r)); 
# 503
return *this; 
# 504
} 
# 506
template< class _Tp1> weak_ptr &
# 508
operator=(const shared_ptr< _Tp1>  &__r) noexcept 
# 509
{ 
# 510
(this->::std::__weak_ptr< _Tp, ::__gnu_cxx::_S_atomic> ::operator=(__r)); 
# 511
return *this; 
# 512
} 
# 515
weak_ptr &operator=(weak_ptr && __r) noexcept = default;
# 517
template< class _Tp1> weak_ptr &
# 519
operator=(::std::weak_ptr< _Tp1>  &&__r) noexcept 
# 520
{ 
# 521
(this->::std::__weak_ptr< _Tp, ::__gnu_cxx::_S_atomic> ::operator=(::std::move(__r))); 
# 522
return *this; 
# 523
} 
# 526
shared_ptr< _Tp>  lock() const noexcept 
# 527
{ return shared_ptr< _Tp> (*this, std::nothrow); } 
# 528
}; 
# 531
template< class _Tp> inline void 
# 533
swap(weak_ptr< _Tp>  &__a, weak_ptr< _Tp>  &__b) noexcept 
# 534
{ (__a.swap(__b)); } 
# 538
template< class _Tp> struct owner_less; 
# 542
template< class _Tp> 
# 543
struct owner_less< shared_ptr< _Tp> >  : public _Sp_owner_less< shared_ptr< _Tp> , weak_ptr< _Tp> >  { 
# 545
}; 
# 548
template< class _Tp> 
# 549
struct owner_less< weak_ptr< _Tp> >  : public _Sp_owner_less< weak_ptr< _Tp> , shared_ptr< _Tp> >  { 
# 551
}; 
# 556
template< class _Tp> 
# 557
class enable_shared_from_this { 
# 560
protected: constexpr enable_shared_from_this() noexcept { } 
# 562
enable_shared_from_this(const enable_shared_from_this &) noexcept { } 
# 565
enable_shared_from_this &operator=(const enable_shared_from_this &) noexcept 
# 566
{ return *this; } 
# 568
~enable_shared_from_this() { } 
# 572
public: shared_ptr< _Tp>  shared_from_this() 
# 573
{ return ((shared_ptr< _Tp> )(this->_M_weak_this)); } 
# 576
shared_ptr< const _Tp>  shared_from_this() const 
# 577
{ return ((shared_ptr< const _Tp> )(this->_M_weak_this)); } 
# 582
private: 
# 580
template< class _Tp1> void 
# 582
_M_weak_assign(_Tp1 *__p, const __shared_count< __gnu_cxx::_S_atomic>  &__n) const noexcept 
# 583
{ ((_M_weak_this)._M_assign(__p, __n)); } 
# 585
template< class _Tp1, class _Tp2> friend void __enable_shared_from_this_helper(const __shared_count< __gnu_cxx::_S_atomic>  &, const std::enable_shared_from_this< _Tp1>  *, const _Tp2 *) noexcept; 
# 591
mutable weak_ptr< _Tp>  _M_weak_this; 
# 592
}; 
# 594
template< class _Tp1, class _Tp2> inline void 
# 596
__enable_shared_from_this_helper(const __shared_count< __gnu_cxx::_S_atomic>  &__pn, const enable_shared_from_this< _Tp1>  *
# 598
__pe, const _Tp2 *__px) noexcept 
# 599
{ 
# 600
if (__pe != nullptr) { 
# 601
(__pe->_M_weak_assign(const_cast< _Tp2 *>(__px), __pn)); }  
# 602
} 
# 615 "/usr/include/c++/5/bits/shared_ptr.h" 3
template< class _Tp, class _Alloc, class ..._Args> inline shared_ptr< _Tp>  
# 617
allocate_shared(const _Alloc &__a, _Args &&...__args) 
# 618
{ 
# 619
return shared_ptr< _Tp> (_Sp_make_shared_tag(), __a, std::forward< _Args> (__args)...); 
# 621
} 
# 630 "/usr/include/c++/5/bits/shared_ptr.h" 3
template< class _Tp, class ..._Args> inline shared_ptr< _Tp>  
# 632
make_shared(_Args &&...__args) 
# 633
{ 
# 634
typedef typename remove_const< _Tp> ::type _Tp_nc; 
# 635
return std::allocate_shared< _Tp> (allocator< typename remove_const< _Tp> ::type> (), std::forward< _Args> (__args)...); 
# 637
} 
# 640
template< class _Tp> 
# 641
struct hash< shared_ptr< _Tp> >  : public __hash_base< unsigned long, shared_ptr< _Tp> >  { 
# 645
::std::size_t operator()(const shared_ptr< _Tp>  &__s) const noexcept 
# 646
{ return ::std::hash< _Tp *> ()((__s.get())); } 
# 647
}; 
# 652
}
# 43 "/usr/include/c++/5/bits/atomic_base.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 63 "/usr/include/c++/5/bits/atomic_base.h" 3
typedef 
# 55
enum memory_order { 
# 57
memory_order_relaxed, 
# 58
memory_order_consume, 
# 59
memory_order_acquire, 
# 60
memory_order_release, 
# 61
memory_order_acq_rel, 
# 62
memory_order_seq_cst
# 63
} memory_order; 
# 65
enum __memory_order_modifier { 
# 67
__memory_order_mask = 65535U, 
# 68
__memory_order_modifier_mask = 4294901760U, 
# 69
__memory_order_hle_acquire = 65536U, 
# 70
__memory_order_hle_release = 131072U
# 71
}; 
# 74
constexpr memory_order operator|(memory_order __m, __memory_order_modifier __mod) 
# 75
{ 
# 76
return (memory_order)(__m | ((int)__mod)); 
# 77
} 
# 80
constexpr memory_order operator&(memory_order __m, __memory_order_modifier __mod) 
# 81
{ 
# 82
return (memory_order)(__m & ((int)__mod)); 
# 83
} 
# 87
constexpr memory_order __cmpexch_failure_order2(memory_order __m) noexcept 
# 88
{ 
# 89
return (__m == (memory_order_acq_rel)) ? memory_order_acquire : ((__m == (memory_order_release)) ? memory_order_relaxed : __m); 
# 91
} 
# 94
constexpr memory_order __cmpexch_failure_order(memory_order __m) noexcept 
# 95
{ 
# 96
return (memory_order)((__cmpexch_failure_order2((__m & (__memory_order_mask)))) | ((__m & (__memory_order_modifier_mask)))); 
# 98
} 
# 100
__attribute((__always_inline__)) inline void 
# 101
atomic_thread_fence(memory_order __m) noexcept 
# 102
{ __atomic_thread_fence(__m); } 
# 104
__attribute((__always_inline__)) inline void 
# 105
atomic_signal_fence(memory_order __m) noexcept 
# 106
{ __atomic_signal_fence(__m); } 
# 109
template< class _Tp> inline _Tp 
# 111
kill_dependency(_Tp __y) noexcept 
# 112
{ 
# 113
_Tp __ret(__y); 
# 114
return __ret; 
# 115
} 
# 119
template< class _IntTp> struct __atomic_base; 
# 125
template< class _Tp> struct atomic; 
# 128
template< class _Tp> struct atomic< _Tp *> ; 
# 133
typedef bool __atomic_flag_data_type; 
# 148 "/usr/include/c++/5/bits/atomic_base.h" 3
extern "C" {
# 150
struct __atomic_flag_base { 
# 152
__atomic_flag_data_type _M_i; 
# 153
}; 
# 155
}
# 160
struct atomic_flag : public __atomic_flag_base { 
# 162
atomic_flag() noexcept = default;
# 163
~atomic_flag() noexcept = default;
# 164
atomic_flag(const atomic_flag &) = delete;
# 165
atomic_flag &operator=(const atomic_flag &) = delete;
# 166
atomic_flag &operator=(const atomic_flag &) volatile = delete;
# 169
constexpr atomic_flag(bool __i) noexcept : __atomic_flag_base{_S_init(__i)} 
# 171
{ } 
# 173
__attribute((__always_inline__)) bool 
# 174
test_and_set(memory_order __m = memory_order_seq_cst) noexcept 
# 175
{ 
# 176
return __atomic_test_and_set(&(_M_i), __m); 
# 177
} 
# 179
__attribute((__always_inline__)) bool 
# 180
test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept 
# 181
{ 
# 182
return __atomic_test_and_set(&(_M_i), __m); 
# 183
} 
# 185
__attribute((__always_inline__)) void 
# 186
clear(memory_order __m = memory_order_seq_cst) noexcept 
# 187
{ 
# 188
memory_order __b = (__m & (__memory_order_mask)); 
# 189
; 
# 190
; 
# 191
; 
# 193
__atomic_clear(&(_M_i), __m); 
# 194
} 
# 196
__attribute((__always_inline__)) void 
# 197
clear(memory_order __m = memory_order_seq_cst) volatile noexcept 
# 198
{ 
# 199
memory_order __b = (__m & (__memory_order_mask)); 
# 200
; 
# 201
; 
# 202
; 
# 204
__atomic_clear(&(_M_i), __m); 
# 205
} 
# 209
private: static constexpr __atomic_flag_data_type _S_init(bool __i) 
# 210
{ return __i ? 1 : 0; } 
# 211
}; 
# 237 "/usr/include/c++/5/bits/atomic_base.h" 3
template< class _ITp> 
# 238
struct __atomic_base { 
# 241
private: typedef _ITp __int_type; 
# 243
static constexpr int _S_alignment = ((sizeof(_ITp) > __alignof__(_ITp)) ? sizeof(_ITp) : __alignof__(_ITp)); 
# 246
alignas(_S_alignment) __int_type _M_i; 
# 249
public: __atomic_base() noexcept = default;
# 250
~__atomic_base() noexcept = default;
# 251
__atomic_base(const __atomic_base &) = delete;
# 252
__atomic_base &operator=(const __atomic_base &) = delete;
# 253
__atomic_base &operator=(const __atomic_base &) volatile = delete;
# 256
constexpr __atomic_base(__int_type __i) noexcept : _M_i(__i) { } 
# 258
operator __int_type() const noexcept 
# 259
{ return load(); } 
# 261
operator __int_type() const volatile noexcept 
# 262
{ return load(); } 
# 265
__int_type operator=(__int_type __i) noexcept 
# 266
{ 
# 267
store(__i); 
# 268
return __i; 
# 269
} 
# 272
__int_type operator=(__int_type __i) volatile noexcept 
# 273
{ 
# 274
store(__i); 
# 275
return __i; 
# 276
} 
# 279
__int_type operator++(int) noexcept 
# 280
{ return fetch_add(1); } 
# 283
__int_type operator++(int) volatile noexcept 
# 284
{ return fetch_add(1); } 
# 287
__int_type operator--(int) noexcept 
# 288
{ return fetch_sub(1); } 
# 291
__int_type operator--(int) volatile noexcept 
# 292
{ return fetch_sub(1); } 
# 295
__int_type operator++() noexcept 
# 296
{ return __atomic_add_fetch(&(_M_i), 1, memory_order_seq_cst); } 
# 299
__int_type operator++() volatile noexcept 
# 300
{ return __atomic_add_fetch(&(_M_i), 1, memory_order_seq_cst); } 
# 303
__int_type operator--() noexcept 
# 304
{ return __atomic_sub_fetch(&(_M_i), 1, memory_order_seq_cst); } 
# 307
__int_type operator--() volatile noexcept 
# 308
{ return __atomic_sub_fetch(&(_M_i), 1, memory_order_seq_cst); } 
# 311
__int_type operator+=(__int_type __i) noexcept 
# 312
{ return __atomic_add_fetch(&(_M_i), __i, memory_order_seq_cst); } 
# 315
__int_type operator+=(__int_type __i) volatile noexcept 
# 316
{ return __atomic_add_fetch(&(_M_i), __i, memory_order_seq_cst); } 
# 319
__int_type operator-=(__int_type __i) noexcept 
# 320
{ return __atomic_sub_fetch(&(_M_i), __i, memory_order_seq_cst); } 
# 323
__int_type operator-=(__int_type __i) volatile noexcept 
# 324
{ return __atomic_sub_fetch(&(_M_i), __i, memory_order_seq_cst); } 
# 327
__int_type operator&=(__int_type __i) noexcept 
# 328
{ return __atomic_and_fetch(&(_M_i), __i, memory_order_seq_cst); } 
# 331
__int_type operator&=(__int_type __i) volatile noexcept 
# 332
{ return __atomic_and_fetch(&(_M_i), __i, memory_order_seq_cst); } 
# 335
__int_type operator|=(__int_type __i) noexcept 
# 336
{ return __atomic_or_fetch(&(_M_i), __i, memory_order_seq_cst); } 
# 339
__int_type operator|=(__int_type __i) volatile noexcept 
# 340
{ return __atomic_or_fetch(&(_M_i), __i, memory_order_seq_cst); } 
# 343
__int_type operator^=(__int_type __i) noexcept 
# 344
{ return __atomic_xor_fetch(&(_M_i), __i, memory_order_seq_cst); } 
# 347
__int_type operator^=(__int_type __i) volatile noexcept 
# 348
{ return __atomic_xor_fetch(&(_M_i), __i, memory_order_seq_cst); } 
# 351
bool is_lock_free() const noexcept 
# 352
{ 
# 354
return __atomic_is_lock_free(sizeof((_M_i)), reinterpret_cast< void *>(-__alignof__((_M_i)))); 
# 356
} 
# 359
bool is_lock_free() const volatile noexcept 
# 360
{ 
# 362
return __atomic_is_lock_free(sizeof((_M_i)), reinterpret_cast< void *>(-__alignof__((_M_i)))); 
# 364
} 
# 366
__attribute((__always_inline__)) void 
# 367
store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept 
# 368
{ 
# 369
memory_order __b = (__m & (__memory_order_mask)); 
# 370
; 
# 371
; 
# 372
; 
# 374
__atomic_store_n(&(_M_i), __i, __m); 
# 375
} 
# 377
__attribute((__always_inline__)) void 
# 378
store(__int_type __i, memory_order 
# 379
__m = memory_order_seq_cst) volatile noexcept 
# 380
{ 
# 381
memory_order __b = (__m & (__memory_order_mask)); 
# 382
; 
# 383
; 
# 384
; 
# 386
__atomic_store_n(&(_M_i), __i, __m); 
# 387
} 
# 389
__attribute((__always_inline__)) __int_type 
# 390
load(memory_order __m = memory_order_seq_cst) const noexcept 
# 391
{ 
# 392
memory_order __b = (__m & (__memory_order_mask)); 
# 393
; 
# 394
; 
# 396
return __atomic_load_n(&(_M_i), __m); 
# 397
} 
# 399
__attribute((__always_inline__)) __int_type 
# 400
load(memory_order __m = memory_order_seq_cst) const volatile noexcept 
# 401
{ 
# 402
memory_order __b = (__m & (__memory_order_mask)); 
# 403
; 
# 404
; 
# 406
return __atomic_load_n(&(_M_i), __m); 
# 407
} 
# 409
__attribute((__always_inline__)) __int_type 
# 410
exchange(__int_type __i, memory_order 
# 411
__m = memory_order_seq_cst) noexcept 
# 412
{ 
# 413
return __atomic_exchange_n(&(_M_i), __i, __m); 
# 414
} 
# 417
__attribute((__always_inline__)) __int_type 
# 418
exchange(__int_type __i, memory_order 
# 419
__m = memory_order_seq_cst) volatile noexcept 
# 420
{ 
# 421
return __atomic_exchange_n(&(_M_i), __i, __m); 
# 422
} 
# 424
__attribute((__always_inline__)) bool 
# 425
compare_exchange_weak(__int_type &__i1, __int_type __i2, memory_order 
# 426
__m1, memory_order __m2) noexcept 
# 427
{ 
# 428
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 429
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 430
; 
# 431
; 
# 432
; 
# 434
return __atomic_compare_exchange_n(&(_M_i), &__i1, __i2, 1, __m1, __m2); 
# 435
} 
# 437
__attribute((__always_inline__)) bool 
# 438
compare_exchange_weak(__int_type &__i1, __int_type __i2, memory_order 
# 439
__m1, memory_order 
# 440
__m2) volatile noexcept 
# 441
{ 
# 442
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 443
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 444
; 
# 445
; 
# 446
; 
# 448
return __atomic_compare_exchange_n(&(_M_i), &__i1, __i2, 1, __m1, __m2); 
# 449
} 
# 451
__attribute((__always_inline__)) bool 
# 452
compare_exchange_weak(__int_type &__i1, __int_type __i2, memory_order 
# 453
__m = memory_order_seq_cst) noexcept 
# 454
{ 
# 455
return compare_exchange_weak(__i1, __i2, __m, __cmpexch_failure_order(__m)); 
# 457
} 
# 459
__attribute((__always_inline__)) bool 
# 460
compare_exchange_weak(__int_type &__i1, __int_type __i2, memory_order 
# 461
__m = memory_order_seq_cst) volatile noexcept 
# 462
{ 
# 463
return compare_exchange_weak(__i1, __i2, __m, __cmpexch_failure_order(__m)); 
# 465
} 
# 467
__attribute((__always_inline__)) bool 
# 468
compare_exchange_strong(__int_type &__i1, __int_type __i2, memory_order 
# 469
__m1, memory_order __m2) noexcept 
# 470
{ 
# 471
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 472
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 473
; 
# 474
; 
# 475
; 
# 477
return __atomic_compare_exchange_n(&(_M_i), &__i1, __i2, 0, __m1, __m2); 
# 478
} 
# 480
__attribute((__always_inline__)) bool 
# 481
compare_exchange_strong(__int_type &__i1, __int_type __i2, memory_order 
# 482
__m1, memory_order 
# 483
__m2) volatile noexcept 
# 484
{ 
# 485
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 486
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 488
; 
# 489
; 
# 490
; 
# 492
return __atomic_compare_exchange_n(&(_M_i), &__i1, __i2, 0, __m1, __m2); 
# 493
} 
# 495
__attribute((__always_inline__)) bool 
# 496
compare_exchange_strong(__int_type &__i1, __int_type __i2, memory_order 
# 497
__m = memory_order_seq_cst) noexcept 
# 498
{ 
# 499
return compare_exchange_strong(__i1, __i2, __m, __cmpexch_failure_order(__m)); 
# 501
} 
# 503
__attribute((__always_inline__)) bool 
# 504
compare_exchange_strong(__int_type &__i1, __int_type __i2, memory_order 
# 505
__m = memory_order_seq_cst) volatile noexcept 
# 506
{ 
# 507
return compare_exchange_strong(__i1, __i2, __m, __cmpexch_failure_order(__m)); 
# 509
} 
# 511
__attribute((__always_inline__)) __int_type 
# 512
fetch_add(__int_type __i, memory_order 
# 513
__m = memory_order_seq_cst) noexcept 
# 514
{ return __atomic_fetch_add(&(_M_i), __i, __m); } 
# 516
__attribute((__always_inline__)) __int_type 
# 517
fetch_add(__int_type __i, memory_order 
# 518
__m = memory_order_seq_cst) volatile noexcept 
# 519
{ return __atomic_fetch_add(&(_M_i), __i, __m); } 
# 521
__attribute((__always_inline__)) __int_type 
# 522
fetch_sub(__int_type __i, memory_order 
# 523
__m = memory_order_seq_cst) noexcept 
# 524
{ return __atomic_fetch_sub(&(_M_i), __i, __m); } 
# 526
__attribute((__always_inline__)) __int_type 
# 527
fetch_sub(__int_type __i, memory_order 
# 528
__m = memory_order_seq_cst) volatile noexcept 
# 529
{ return __atomic_fetch_sub(&(_M_i), __i, __m); } 
# 531
__attribute((__always_inline__)) __int_type 
# 532
fetch_and(__int_type __i, memory_order 
# 533
__m = memory_order_seq_cst) noexcept 
# 534
{ return __atomic_fetch_and(&(_M_i), __i, __m); } 
# 536
__attribute((__always_inline__)) __int_type 
# 537
fetch_and(__int_type __i, memory_order 
# 538
__m = memory_order_seq_cst) volatile noexcept 
# 539
{ return __atomic_fetch_and(&(_M_i), __i, __m); } 
# 541
__attribute((__always_inline__)) __int_type 
# 542
fetch_or(__int_type __i, memory_order 
# 543
__m = memory_order_seq_cst) noexcept 
# 544
{ return __atomic_fetch_or(&(_M_i), __i, __m); } 
# 546
__attribute((__always_inline__)) __int_type 
# 547
fetch_or(__int_type __i, memory_order 
# 548
__m = memory_order_seq_cst) volatile noexcept 
# 549
{ return __atomic_fetch_or(&(_M_i), __i, __m); } 
# 551
__attribute((__always_inline__)) __int_type 
# 552
fetch_xor(__int_type __i, memory_order 
# 553
__m = memory_order_seq_cst) noexcept 
# 554
{ return __atomic_fetch_xor(&(_M_i), __i, __m); } 
# 556
__attribute((__always_inline__)) __int_type 
# 557
fetch_xor(__int_type __i, memory_order 
# 558
__m = memory_order_seq_cst) volatile noexcept 
# 559
{ return __atomic_fetch_xor(&(_M_i), __i, __m); } 
# 560
}; 
# 564
template< class _PTp> 
# 565
struct __atomic_base< _PTp *>  { 
# 568
private: typedef _PTp *__pointer_type; 
# 570
__pointer_type _M_p; 
# 574
constexpr ptrdiff_t _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); } 
# 577
constexpr ptrdiff_t _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); } 
# 580
public: __atomic_base() noexcept = default;
# 581
~__atomic_base() noexcept = default;
# 582
__atomic_base(const std::__atomic_base< _PTp *>  &) = delete;
# 583
std::__atomic_base< _PTp *>  &operator=(const std::__atomic_base< _PTp *>  &) = delete;
# 584
std::__atomic_base< _PTp *>  &operator=(const std::__atomic_base< _PTp *>  &) volatile = delete;
# 587
constexpr __atomic_base(__pointer_type __p) noexcept : _M_p(__p) { } 
# 589
operator __pointer_type() const noexcept 
# 590
{ return load(); } 
# 592
operator __pointer_type() const volatile noexcept 
# 593
{ return load(); } 
# 596
__pointer_type operator=(__pointer_type __p) noexcept 
# 597
{ 
# 598
store(__p); 
# 599
return __p; 
# 600
} 
# 603
__pointer_type operator=(__pointer_type __p) volatile noexcept 
# 604
{ 
# 605
store(__p); 
# 606
return __p; 
# 607
} 
# 610
__pointer_type operator++(int) noexcept 
# 611
{ return fetch_add(1); } 
# 614
__pointer_type operator++(int) volatile noexcept 
# 615
{ return fetch_add(1); } 
# 618
__pointer_type operator--(int) noexcept 
# 619
{ return fetch_sub(1); } 
# 622
__pointer_type operator--(int) volatile noexcept 
# 623
{ return fetch_sub(1); } 
# 626
__pointer_type operator++() noexcept 
# 627
{ return __atomic_add_fetch(&(_M_p), this->_M_type_size(1), memory_order_seq_cst); 
# 628
} 
# 631
__pointer_type operator++() volatile noexcept 
# 632
{ return __atomic_add_fetch(&(_M_p), this->_M_type_size(1), memory_order_seq_cst); 
# 633
} 
# 636
__pointer_type operator--() noexcept 
# 637
{ return __atomic_sub_fetch(&(_M_p), this->_M_type_size(1), memory_order_seq_cst); 
# 638
} 
# 641
__pointer_type operator--() volatile noexcept 
# 642
{ return __atomic_sub_fetch(&(_M_p), this->_M_type_size(1), memory_order_seq_cst); 
# 643
} 
# 646
__pointer_type operator+=(ptrdiff_t __d) noexcept 
# 647
{ return __atomic_add_fetch(&(_M_p), this->_M_type_size(__d), memory_order_seq_cst); 
# 648
} 
# 651
__pointer_type operator+=(ptrdiff_t __d) volatile noexcept 
# 652
{ return __atomic_add_fetch(&(_M_p), this->_M_type_size(__d), memory_order_seq_cst); 
# 653
} 
# 656
__pointer_type operator-=(ptrdiff_t __d) noexcept 
# 657
{ return __atomic_sub_fetch(&(_M_p), this->_M_type_size(__d), memory_order_seq_cst); 
# 658
} 
# 661
__pointer_type operator-=(ptrdiff_t __d) volatile noexcept 
# 662
{ return __atomic_sub_fetch(&(_M_p), this->_M_type_size(__d), memory_order_seq_cst); 
# 663
} 
# 666
bool is_lock_free() const noexcept 
# 667
{ 
# 669
return __atomic_is_lock_free(sizeof((_M_p)), reinterpret_cast< void *>(-__alignof__((_M_p)))); 
# 671
} 
# 674
bool is_lock_free() const volatile noexcept 
# 675
{ 
# 677
return __atomic_is_lock_free(sizeof((_M_p)), reinterpret_cast< void *>(-__alignof__((_M_p)))); 
# 679
} 
# 681
__attribute((__always_inline__)) void 
# 682
store(__pointer_type __p, memory_order 
# 683
__m = memory_order_seq_cst) noexcept 
# 684
{ 
# 685
memory_order __b = (__m & (__memory_order_mask)); 
# 687
; 
# 688
; 
# 689
; 
# 691
__atomic_store_n(&(_M_p), __p, __m); 
# 692
} 
# 694
__attribute((__always_inline__)) void 
# 695
store(__pointer_type __p, memory_order 
# 696
__m = memory_order_seq_cst) volatile noexcept 
# 697
{ 
# 698
memory_order __b = (__m & (__memory_order_mask)); 
# 699
; 
# 700
; 
# 701
; 
# 703
__atomic_store_n(&(_M_p), __p, __m); 
# 704
} 
# 706
__attribute((__always_inline__)) __pointer_type 
# 707
load(memory_order __m = memory_order_seq_cst) const noexcept 
# 708
{ 
# 709
memory_order __b = (__m & (__memory_order_mask)); 
# 710
; 
# 711
; 
# 713
return __atomic_load_n(&(_M_p), __m); 
# 714
} 
# 716
__attribute((__always_inline__)) __pointer_type 
# 717
load(memory_order __m = memory_order_seq_cst) const volatile noexcept 
# 718
{ 
# 719
memory_order __b = (__m & (__memory_order_mask)); 
# 720
; 
# 721
; 
# 723
return __atomic_load_n(&(_M_p), __m); 
# 724
} 
# 726
__attribute((__always_inline__)) __pointer_type 
# 727
exchange(__pointer_type __p, memory_order 
# 728
__m = memory_order_seq_cst) noexcept 
# 729
{ 
# 730
return __atomic_exchange_n(&(_M_p), __p, __m); 
# 731
} 
# 734
__attribute((__always_inline__)) __pointer_type 
# 735
exchange(__pointer_type __p, memory_order 
# 736
__m = memory_order_seq_cst) volatile noexcept 
# 737
{ 
# 738
return __atomic_exchange_n(&(_M_p), __p, __m); 
# 739
} 
# 741
__attribute((__always_inline__)) bool 
# 742
compare_exchange_strong(__pointer_type &__p1, __pointer_type __p2, memory_order 
# 743
__m1, memory_order 
# 744
__m2) noexcept 
# 745
{ 
# 746
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 747
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 748
; 
# 749
; 
# 750
; 
# 752
return __atomic_compare_exchange_n(&(_M_p), &__p1, __p2, 0, __m1, __m2); 
# 753
} 
# 755
__attribute((__always_inline__)) bool 
# 756
compare_exchange_strong(__pointer_type &__p1, __pointer_type __p2, memory_order 
# 757
__m1, memory_order 
# 758
__m2) volatile noexcept 
# 759
{ 
# 760
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 761
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 763
; 
# 764
; 
# 765
; 
# 767
return __atomic_compare_exchange_n(&(_M_p), &__p1, __p2, 0, __m1, __m2); 
# 768
} 
# 770
__attribute((__always_inline__)) __pointer_type 
# 771
fetch_add(ptrdiff_t __d, memory_order 
# 772
__m = memory_order_seq_cst) noexcept 
# 773
{ return __atomic_fetch_add(&(_M_p), this->_M_type_size(__d), __m); } 
# 775
__attribute((__always_inline__)) __pointer_type 
# 776
fetch_add(ptrdiff_t __d, memory_order 
# 777
__m = memory_order_seq_cst) volatile noexcept 
# 778
{ return __atomic_fetch_add(&(_M_p), this->_M_type_size(__d), __m); } 
# 780
__attribute((__always_inline__)) __pointer_type 
# 781
fetch_sub(ptrdiff_t __d, memory_order 
# 782
__m = memory_order_seq_cst) noexcept 
# 783
{ return __atomic_fetch_sub(&(_M_p), this->_M_type_size(__d), __m); } 
# 785
__attribute((__always_inline__)) __pointer_type 
# 786
fetch_sub(ptrdiff_t __d, memory_order 
# 787
__m = memory_order_seq_cst) volatile noexcept 
# 788
{ return __atomic_fetch_sub(&(_M_p), this->_M_type_size(__d), __m); } 
# 789
}; 
# 794
}
# 35 "/usr/include/c++/5/bits/shared_ptr_atomic.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 44
struct _Sp_locker { 
# 46
_Sp_locker(const _Sp_locker &) = delete;
# 47
_Sp_locker &operator=(const _Sp_locker &) = delete;
# 51
explicit _Sp_locker(const void *) noexcept; 
# 52
_Sp_locker(const void *, const void *) noexcept; 
# 53
~_Sp_locker(); 
# 56
private: unsigned char _M_key1; 
# 57
unsigned char _M_key2; 
# 61
}; 
# 69
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 71
atomic_is_lock_free(const __shared_ptr< _Tp, _Lp>  *__p) 
# 72
{ 
# 74
return __gthread_active_p() == 0; 
# 78
} 
# 80
template< class _Tp> inline bool 
# 82
atomic_is_lock_free(const shared_ptr< _Tp>  *__p) 
# 83
{ return std::atomic_is_lock_free< _Tp, __gnu_cxx::__default_lock_policy> (__p); } 
# 96 "/usr/include/c++/5/bits/shared_ptr_atomic.h" 3
template< class _Tp> inline shared_ptr< _Tp>  
# 98
atomic_load_explicit(const shared_ptr< _Tp>  *__p, memory_order) 
# 99
{ 
# 100
_Sp_locker __lock{__p}; 
# 101
return *__p; 
# 102
} 
# 104
template< class _Tp> inline shared_ptr< _Tp>  
# 106
atomic_load(const shared_ptr< _Tp>  *__p) 
# 107
{ return std::atomic_load_explicit(__p, memory_order_seq_cst); } 
# 109
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 111
atomic_load_explicit(const __shared_ptr< _Tp, _Lp>  *__p, memory_order) 
# 112
{ 
# 113
_Sp_locker __lock{__p}; 
# 114
return *__p; 
# 115
} 
# 117
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 119
atomic_load(const __shared_ptr< _Tp, _Lp>  *__p) 
# 120
{ return std::atomic_load_explicit(__p, memory_order_seq_cst); } 
# 132 "/usr/include/c++/5/bits/shared_ptr_atomic.h" 3
template< class _Tp> inline void 
# 134
atomic_store_explicit(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  __r, memory_order) 
# 136
{ 
# 137
_Sp_locker __lock{__p}; 
# 138
(__p->swap(__r)); 
# 139
} 
# 141
template< class _Tp> inline void 
# 143
atomic_store(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  __r) 
# 144
{ std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); } 
# 146
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline void 
# 148
atomic_store_explicit(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  
# 149
__r, memory_order) 
# 151
{ 
# 152
_Sp_locker __lock{__p}; 
# 153
(__p->swap(__r)); 
# 154
} 
# 156
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline void 
# 158
atomic_store(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  __r) 
# 159
{ std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); } 
# 169 "/usr/include/c++/5/bits/shared_ptr_atomic.h" 3
template< class _Tp> inline shared_ptr< _Tp>  
# 171
atomic_exchange_explicit(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  __r, memory_order) 
# 173
{ 
# 174
_Sp_locker __lock{__p}; 
# 175
(__p->swap(__r)); 
# 176
return __r; 
# 177
} 
# 179
template< class _Tp> inline shared_ptr< _Tp>  
# 181
atomic_exchange(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  __r) 
# 182
{ 
# 183
return std::atomic_exchange_explicit(__p, std::move(__r), memory_order_seq_cst); 
# 185
} 
# 187
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 189
atomic_exchange_explicit(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  
# 190
__r, memory_order) 
# 192
{ 
# 193
_Sp_locker __lock{__p}; 
# 194
(__p->swap(__r)); 
# 195
return __r; 
# 196
} 
# 198
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 200
atomic_exchange(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  __r) 
# 201
{ 
# 202
return std::atomic_exchange_explicit(__p, std::move(__r), memory_order_seq_cst); 
# 204
} 
# 218 "/usr/include/c++/5/bits/shared_ptr_atomic.h" 3
template< class _Tp> bool 
# 220
atomic_compare_exchange_strong_explicit(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  *
# 221
__v, shared_ptr< _Tp>  
# 222
__w, memory_order, memory_order) 
# 225
{ 
# 226
shared_ptr< _Tp>  __x; 
# 227
_Sp_locker __lock{__p, __v}; 
# 228
owner_less< shared_ptr< _Tp> >  __less; 
# 229
if (((*__p) == (*__v)) && (!__less(*__p, *__v)) && (!__less(*__v, *__p))) 
# 230
{ 
# 231
__x = std::move(*__p); 
# 232
(*__p) = std::move(__w); 
# 233
return true; 
# 234
}  
# 235
__x = std::move(*__v); 
# 236
(*__v) = (*__p); 
# 237
return false; 
# 238
} 
# 240
template< class _Tp> inline bool 
# 242
atomic_compare_exchange_strong(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  *__v, shared_ptr< _Tp>  
# 243
__w) 
# 244
{ 
# 245
return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst); 
# 247
} 
# 249
template< class _Tp> inline bool 
# 251
atomic_compare_exchange_weak_explicit(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  *
# 252
__v, shared_ptr< _Tp>  
# 253
__w, memory_order 
# 254
__success, memory_order 
# 255
__failure) 
# 256
{ 
# 257
return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), __success, __failure); 
# 259
} 
# 261
template< class _Tp> inline bool 
# 263
atomic_compare_exchange_weak(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  *__v, shared_ptr< _Tp>  
# 264
__w) 
# 265
{ 
# 266
return std::atomic_compare_exchange_weak_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst); 
# 268
} 
# 270
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> bool 
# 272
atomic_compare_exchange_strong_explicit(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  *
# 273
__v, __shared_ptr< _Tp, _Lp>  
# 274
__w, memory_order, memory_order) 
# 277
{ 
# 278
__shared_ptr< _Tp, _Lp>  __x; 
# 279
_Sp_locker __lock{__p, __v}; 
# 280
owner_less< __shared_ptr< _Tp, _Lp> >  __less; 
# 281
if (((*__p) == (*__v)) && (!__less(*__p, *__v)) && (!__less(*__v, *__p))) 
# 282
{ 
# 283
__x = std::move(*__p); 
# 284
(*__p) = std::move(__w); 
# 285
return true; 
# 286
}  
# 287
__x = std::move(*__v); 
# 288
(*__v) = (*__p); 
# 289
return false; 
# 290
} 
# 292
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 294
atomic_compare_exchange_strong(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  *
# 295
__v, __shared_ptr< _Tp, _Lp>  
# 296
__w) 
# 297
{ 
# 298
return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst); 
# 300
} 
# 302
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 304
atomic_compare_exchange_weak_explicit(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  *
# 305
__v, __shared_ptr< _Tp, _Lp>  
# 306
__w, memory_order 
# 307
__success, memory_order 
# 308
__failure) 
# 309
{ 
# 310
return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), __success, __failure); 
# 312
} 
# 314
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 316
atomic_compare_exchange_weak(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  *
# 317
__v, __shared_ptr< _Tp, _Lp>  
# 318
__w) 
# 319
{ 
# 320
return std::atomic_compare_exchange_weak_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst); 
# 322
} 
# 328
}
# 36 "/usr/include/c++/5/backward/auto_ptr.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 47 "/usr/include/c++/5/backward/auto_ptr.h" 3
template< class _Tp1> 
# 48
struct auto_ptr_ref { 
# 50
_Tp1 *_M_ptr; 
# 53
explicit auto_ptr_ref(_Tp1 *__p) : _M_ptr(__p) { } 
# 54
} __attribute((__deprecated__)); 
# 86 "/usr/include/c++/5/backward/auto_ptr.h" 3
template< class _Tp> 
# 87
class auto_ptr { 
# 90
_Tp *_M_ptr; 
# 94
public: typedef _Tp element_type; 
# 103
explicit auto_ptr(element_type *__p = 0) throw() : _M_ptr(__p) { } 
# 112 "/usr/include/c++/5/backward/auto_ptr.h" 3
auto_ptr(auto_ptr &__a) throw() : _M_ptr((__a.release())) { } 
# 124 "/usr/include/c++/5/backward/auto_ptr.h" 3
template< class _Tp1> 
# 125
auto_ptr(std::auto_ptr< _Tp1>  &__a) throw() : _M_ptr((__a.release())) { } 
# 136 "/usr/include/c++/5/backward/auto_ptr.h" 3
auto_ptr &operator=(auto_ptr &__a) throw() 
# 137
{ 
# 138
reset((__a.release())); 
# 139
return *this; 
# 140
} 
# 152 "/usr/include/c++/5/backward/auto_ptr.h" 3
template< class _Tp1> auto_ptr &
# 154
operator=(std::auto_ptr< _Tp1>  &__a) throw() 
# 155
{ 
# 156
reset((__a.release())); 
# 157
return *this; 
# 158
} 
# 170 "/usr/include/c++/5/backward/auto_ptr.h" 3
~auto_ptr() { delete (_M_ptr); } 
# 181 "/usr/include/c++/5/backward/auto_ptr.h" 3
element_type &operator*() const throw() 
# 182
{ 
# 183
; 
# 184
return *(_M_ptr); 
# 185
} 
# 194
element_type *operator->() const throw() 
# 195
{ 
# 196
; 
# 197
return _M_ptr; 
# 198
} 
# 211 "/usr/include/c++/5/backward/auto_ptr.h" 3
element_type *get() const throw() { return _M_ptr; } 
# 225 "/usr/include/c++/5/backward/auto_ptr.h" 3
element_type *release() throw() 
# 226
{ 
# 227
element_type *__tmp = _M_ptr; 
# 228
(_M_ptr) = 0; 
# 229
return __tmp; 
# 230
} 
# 240 "/usr/include/c++/5/backward/auto_ptr.h" 3
void reset(element_type *__p = 0) throw() 
# 241
{ 
# 242
if (__p != (_M_ptr)) 
# 243
{ 
# 244
delete (_M_ptr); 
# 245
(_M_ptr) = __p; 
# 246
}  
# 247
} 
# 260 "/usr/include/c++/5/backward/auto_ptr.h" 3
auto_ptr(auto_ptr_ref< _Tp>  __ref) throw() : _M_ptr(((__ref._M_ptr))) 
# 261
{ } 
# 264
auto_ptr &operator=(auto_ptr_ref< _Tp>  __ref) throw() 
# 265
{ 
# 266
if ((__ref._M_ptr) != this->get()) 
# 267
{ 
# 268
delete (_M_ptr); 
# 269
(_M_ptr) = (__ref._M_ptr); 
# 270
}  
# 271
return *this; 
# 272
} 
# 274
template< class _Tp1> 
# 275
operator auto_ptr_ref< _Tp1> () throw() 
# 276
{ return ((auto_ptr_ref< _Tp1> )(this->release())); } 
# 278
template< class _Tp1> 
# 279
operator std::auto_ptr< _Tp1> () throw() 
# 280
{ return ((std::auto_ptr< _Tp1> )(this->release())); } 
# 281
} __attribute((__deprecated__)); 
# 286
template<> class auto_ptr< void>  { 
# 289
public: typedef void element_type; 
# 290
} __attribute((__deprecated__)); 
# 293
template< __gnu_cxx::_Lock_policy _Lp> 
# 294
template< class _Tp> inline 
# 296
__shared_count< _Lp> ::__shared_count(auto_ptr< _Tp>  &&__r) : _M_pi(new _Sp_counted_ptr< _Tp *, _Lp> ((__r.get()))) 
# 298
{ (__r.release()); } 
# 300
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 301
template< class _Tp1> inline 
# 303
__shared_ptr< _Tp, _Lp> ::__shared_ptr(auto_ptr< _Tp1>  &&__r) : _M_ptr((__r.get())), _M_refcount() 
# 305
{ 
# 307
static_assert((sizeof(_Tp1) > (0)), "incomplete type");
# 308
_Tp1 *__tmp = (__r.get()); 
# 309
(_M_refcount) = ((__shared_count< _Lp> )(std::move(__r))); 
# 310
__enable_shared_from_this_helper(_M_refcount, __tmp, __tmp); 
# 311
} 
# 313
template< class _Tp> 
# 314
template< class _Tp1> inline 
# 316
shared_ptr< _Tp> ::shared_ptr(auto_ptr< _Tp1>  &&__r) : ::std::__shared_ptr< _Tp, ::__gnu_cxx::_S_atomic> (::std::move(__r)) 
# 317
{ } 
# 319
template< class _Tp, class _Dp> 
# 320
template< class _Up, class > inline 
# 322
unique_ptr< _Tp, _Dp> ::unique_ptr(auto_ptr< _Up>  &&__u) noexcept : _M_t((__u.release()), deleter_type()) 
# 323
{ } 
# 327
}
# 94 "/usr/include/c++/5/memory" 3
namespace std __attribute((__visibility__("default"))) { 
# 115 "/usr/include/c++/5/memory" 3
inline void *align(size_t __align, size_t __size, void *&__ptr, size_t &__space) noexcept 
# 116
{ 
# 117
const auto __intptr = reinterpret_cast< uintptr_t>(__ptr); 
# 118
const auto __aligned = ((__intptr - (1U)) + __align) & (-__align); 
# 119
const auto __diff = __aligned - __intptr; 
# 120
if ((__size + __diff) > __space) { 
# 121
return nullptr; } else 
# 123
{ 
# 124
__space -= __diff; 
# 125
return __ptr = (reinterpret_cast< void *>(__aligned)); 
# 126
}  
# 127
} 
# 130
}
# 37 "/usr/include/c++/5/bits/stream_iterator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 47
template< class _Tp, class _CharT = char, class 
# 48
_Traits = char_traits< _CharT> , class _Dist = ptrdiff_t> 
# 49
class istream_iterator : public iterator< input_iterator_tag, _Tp, _Dist, const _Tp *, const _Tp &>  { 
# 53
public: typedef _CharT char_type; 
# 54
typedef _Traits traits_type; 
# 55
typedef basic_istream< _CharT, _Traits>  istream_type; 
# 58
private: istream_type *_M_stream; 
# 59
_Tp _M_value; 
# 60
bool _M_ok; 
# 64
public: constexpr istream_iterator() : _M_stream((0)), _M_value(), _M_ok(false) 
# 65
{ } 
# 68
istream_iterator(istream_type &__s) : _M_stream((&__s)) 
# 70
{ _M_read(); } 
# 72
istream_iterator(const istream_iterator &__obj) : _M_stream(((__obj._M_stream))), _M_value((__obj._M_value)), _M_ok(((__obj._M_ok))) 
# 75
{ } 
# 78
const _Tp &operator*() const 
# 79
{ 
# 82
; 
# 83
return _M_value; 
# 84
} 
# 87
const _Tp *operator->() const { return &operator*(); } 
# 90
istream_iterator &operator++() 
# 91
{ 
# 94
; 
# 95
_M_read(); 
# 96
return *this; 
# 97
} 
# 100
istream_iterator operator++(int) 
# 101
{ 
# 104
; 
# 105
istream_iterator __tmp = *this; 
# 106
_M_read(); 
# 107
return __tmp; 
# 108
} 
# 111
bool _M_equal(const istream_iterator &__x) const 
# 112
{ return ((_M_ok) == (__x._M_ok)) && ((!(_M_ok)) || ((_M_stream) == (__x._M_stream))); } 
# 116
private: void _M_read() 
# 117
{ 
# 118
(_M_ok) = (((_M_stream) && (*(_M_stream))) ? true : false); 
# 119
if (_M_ok) 
# 120
{ 
# 121
(*(_M_stream)) >> (_M_value); 
# 122
(_M_ok) = ((*(_M_stream)) ? true : false); 
# 123
}  
# 124
} 
# 125
}; 
# 128
template< class _Tp, class _CharT, class _Traits, class _Dist> inline bool 
# 130
operator==(const istream_iterator< _Tp, _CharT, _Traits, _Dist>  &__x, const istream_iterator< _Tp, _CharT, _Traits, _Dist>  &
# 131
__y) 
# 132
{ return (__x._M_equal(__y)); } 
# 135
template< class _Tp, class _CharT, class _Traits, class _Dist> inline bool 
# 137
operator!=(const istream_iterator< _Tp, _CharT, _Traits, _Dist>  &__x, const istream_iterator< _Tp, _CharT, _Traits, _Dist>  &
# 138
__y) 
# 139
{ return !(__x._M_equal(__y)); } 
# 152 "/usr/include/c++/5/bits/stream_iterator.h" 3
template< class _Tp, class _CharT = char, class 
# 153
_Traits = char_traits< _CharT> > 
# 154
class ostream_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 160
public: typedef _CharT char_type; 
# 161
typedef _Traits traits_type; 
# 162
typedef basic_ostream< _CharT, _Traits>  ostream_type; 
# 166
private: ostream_type *_M_stream; 
# 167
const _CharT *_M_string; 
# 171
public: ostream_iterator(ostream_type &__s) : _M_stream((&__s)), _M_string((0)) { } 
# 183 "/usr/include/c++/5/bits/stream_iterator.h" 3
ostream_iterator(ostream_type &__s, const _CharT *__c) : _M_stream((&__s)), _M_string(__c) 
# 184
{ } 
# 187
ostream_iterator(const ostream_iterator &__obj) : _M_stream(((__obj._M_stream))), _M_string(((__obj._M_string))) 
# 188
{ } 
# 193
ostream_iterator &operator=(const _Tp &__value) 
# 194
{ 
# 197
; 
# 198
(*(_M_stream)) << __value; 
# 199
if (_M_string) { (*(_M_stream)) << (_M_string); }  
# 200
return *this; 
# 201
} 
# 204
ostream_iterator &operator*() 
# 205
{ return *this; } 
# 208
ostream_iterator &operator++() 
# 209
{ return *this; } 
# 212
ostream_iterator &operator++(int) 
# 213
{ return *this; } 
# 214
}; 
# 219
}
# 41 "/usr/include/c++/5/sstream" 3
namespace std __attribute((__visibility__("default"))) { 
# 44
inline namespace __cxx11 { 
# 64 "/usr/include/c++/5/sstream" 3
template< class _CharT, class _Traits, class _Alloc> 
# 65
class basic_stringbuf : public basic_streambuf< _CharT, _Traits>  { 
# 67
struct __xfer_bufptrs; 
# 70
public: typedef _CharT char_type; 
# 71
typedef _Traits traits_type; 
# 74
typedef _Alloc allocator_type; 
# 75
typedef typename _Traits::int_type int_type; 
# 76
typedef typename _Traits::pos_type pos_type; 
# 77
typedef typename _Traits::off_type off_type; 
# 79
typedef ::std::basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 80
typedef basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 81
typedef typename basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 85
protected: ::std::ios_base::openmode _M_mode; 
# 88
__string_type _M_string; 
# 100 "/usr/include/c++/5/sstream" 3
public: explicit basic_stringbuf(::std::ios_base::openmode __mode = (::std::ios_base::in | ::std::ios_base::out)) : __streambuf_type(), _M_mode(__mode), _M_string() 
# 102
{ } 
# 113 "/usr/include/c++/5/sstream" 3
explicit basic_stringbuf(const __string_type &__str, ::std::ios_base::openmode 
# 114
__mode = (::std::ios_base::in | ::std::ios_base::out)) : __streambuf_type(), _M_mode(), _M_string((__str.data()), (__str.size())) 
# 116
{ _M_stringbuf_init(__mode); } 
# 119
basic_stringbuf(const basic_stringbuf &) = delete;
# 121
basic_stringbuf(basic_stringbuf &&__rhs) : basic_stringbuf(::std::move(__rhs), __xfer_bufptrs(__rhs, this)) 
# 123
{ (__rhs._M_sync(const_cast< char_type *>(((__rhs._M_string).data())), 0, 0)); } 
# 128
basic_stringbuf &operator=(const basic_stringbuf &) = delete;
# 131
basic_stringbuf &operator=(basic_stringbuf &&__rhs) 
# 132
{ 
# 133
__xfer_bufptrs __st{__rhs, this}; 
# 134
const __streambuf_type &__base = __rhs; 
# 135
::std::basic_streambuf< _CharT, _Traits> ::operator=(__base); 
# 136
(this->pubimbue((__rhs.getloc()))); 
# 137
(_M_mode) = (__rhs._M_mode); 
# 138
(_M_string) = ::std::move((__rhs._M_string)); 
# 139
(__rhs._M_sync(const_cast< char_type *>(((__rhs._M_string).data())), 0, 0)); 
# 140
return *this; 
# 141
} 
# 144
void swap(basic_stringbuf &__rhs) 
# 145
{ 
# 146
__xfer_bufptrs __l_st{*this, ::std::__addressof(__rhs)}; 
# 147
__xfer_bufptrs __r_st{__rhs, this}; 
# 148
__streambuf_type &__base = __rhs; 
# 149
__streambuf_type::swap(__base); 
# 150
(__rhs.pubimbue((this->pubimbue((__rhs.getloc()))))); 
# 151
::std::swap(_M_mode, (__rhs._M_mode)); 
# 152
::std::swap(_M_string, (__rhs._M_string)); 
# 153
} 
# 166 "/usr/include/c++/5/sstream" 3
__string_type str() const 
# 167
{ 
# 168
__string_type __ret; 
# 169
if ((this->pptr())) 
# 170
{ 
# 172
if ((this->pptr()) > (this->egptr())) { 
# 173
__ret = __string_type((this->pbase()), (this->pptr())); } else { 
# 175
__ret = __string_type((this->pbase()), (this->egptr())); }  
# 176
} else { 
# 178
__ret = (_M_string); }  
# 179
return __ret; 
# 180
} 
# 190 "/usr/include/c++/5/sstream" 3
void str(const __string_type &__s) 
# 191
{ 
# 194
((_M_string).assign((__s.data()), (__s.size()))); 
# 195
_M_stringbuf_init(_M_mode); 
# 196
} 
# 201
protected: void _M_stringbuf_init(::std::ios_base::openmode __mode) 
# 202
{ 
# 203
(_M_mode) = __mode; 
# 204
__size_type __len = (0); 
# 205
if (((_M_mode) & ((::std::ios_base::ate | ::std::ios_base::app)))) { 
# 206
__len = ((_M_string).size()); }  
# 207
_M_sync(const_cast< char_type *>(((_M_string).data())), 0, __len); 
# 208
} 
# 211
virtual ::std::streamsize showmanyc() 
# 212
{ 
# 213
::std::streamsize __ret = (-1); 
# 214
if (((_M_mode) & ::std::ios_base::in)) 
# 215
{ 
# 216
_M_update_egptr(); 
# 217
__ret = ((this->egptr()) - (this->gptr())); 
# 218
}  
# 219
return __ret; 
# 220
} 
# 223
virtual int_type underflow(); 
# 226
virtual int_type pbackfail(int_type __c = traits_type::eof()); 
# 229
virtual int_type overflow(int_type __c = traits_type::eof()); 
# 243 "/usr/include/c++/5/sstream" 3
virtual __streambuf_type *setbuf(char_type *__s, ::std::streamsize __n) 
# 244
{ 
# 245
if (__s && (__n >= (0))) 
# 246
{ 
# 253
((_M_string).clear()); 
# 256
_M_sync(__s, __n, 0); 
# 257
}  
# 258
return this; 
# 259
} 
# 262
virtual pos_type seekoff(off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode = (::std::ios_base::in | ::std::ios_base::out)); 
# 266
virtual pos_type seekpos(pos_type __sp, ::std::ios_base::openmode __mode = (::std::ios_base::in | ::std::ios_base::out)); 
# 273
void _M_sync(char_type * __base, __size_type __i, __size_type __o); 
# 278
void _M_update_egptr() 
# 279
{ 
# 280
const bool __testin = ((_M_mode) & ::std::ios_base::in); 
# 281
if ((this->pptr()) && ((this->pptr()) > (this->egptr()))) 
# 282
{ 
# 283
if (__testin) { 
# 284
(this->setg((this->eback()), (this->gptr()), (this->pptr()))); } else { 
# 286
(this->setg((this->pptr()), (this->pptr()), (this->pptr()))); }  
# 287
}  
# 288
} 
# 293
void _M_pbump(char_type * __pbeg, char_type * __pend, off_type __off); 
# 300
private: struct __xfer_bufptrs { 
# 302
__xfer_bufptrs(const basic_stringbuf &__from, basic_stringbuf *__to) : _M_to{__to}, _M_goff{(-1), (-1), (-1)}, _M_poff{(-1), (-1), (-1)} 
# 304
{ 
# 305
const _CharT *__str = ((__from._M_string).data()); 
# 306
if ((__from.eback())) 
# 307
{ 
# 308
((_M_goff)[0]) = ((__from.eback()) - __str); 
# 309
((_M_goff)[1]) = ((__from.gptr()) - __str); 
# 310
((_M_goff)[2]) = ((__from.egptr()) - __str); 
# 311
}  
# 312
if ((__from.pbase())) 
# 313
{ 
# 314
((_M_poff)[0]) = ((__from.pbase()) - __str); 
# 315
((_M_poff)[1]) = ((__from.pptr()) - (__from.pbase())); 
# 316
((_M_poff)[2]) = ((__from.epptr()) - __str); 
# 317
}  
# 318
} 
# 320
~__xfer_bufptrs() 
# 321
{ 
# 322
char_type *__str = const_cast< char_type *>((((_M_to)->_M_string).data())); 
# 323
if (((_M_goff)[0]) != (-1)) { 
# 324
((_M_to)->setg(__str + ((_M_goff)[0]), __str + ((_M_goff)[1]), __str + ((_M_goff)[2]))); }  
# 325
if (((_M_poff)[0]) != (-1)) { 
# 326
(_M_to)->_M_pbump(__str + ((_M_poff)[0]), __str + ((_M_poff)[2]), (_M_poff)[1]); }  
# 327
} 
# 329
basic_stringbuf *_M_to; 
# 330
off_type _M_goff[3]; 
# 331
off_type _M_poff[3]; 
# 332
}; 
# 343 "/usr/include/c++/5/sstream" 3
basic_stringbuf(basic_stringbuf &&__rhs, __xfer_bufptrs &&) : __streambuf_type(static_cast< const __streambuf_type &>(__rhs)), _M_mode(((__rhs._M_mode))), _M_string(::std::move((__rhs._M_string))) 
# 346
{ } 
# 348
}; 
# 366 "/usr/include/c++/5/sstream" 3
template< class _CharT, class _Traits, class _Alloc> 
# 367
class basic_istringstream : public basic_istream< _CharT, _Traits>  { 
# 371
public: typedef _CharT char_type; 
# 372
typedef _Traits traits_type; 
# 375
typedef _Alloc allocator_type; 
# 376
typedef typename _Traits::int_type int_type; 
# 377
typedef typename _Traits::pos_type pos_type; 
# 378
typedef typename _Traits::off_type off_type; 
# 381
typedef basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 382
typedef basic_stringbuf< _CharT, _Traits, _Alloc>  __stringbuf_type; 
# 383
typedef ::std::basic_istream< _CharT, _Traits>  __istream_type; 
# 386
private: __stringbuf_type _M_stringbuf; 
# 403 "/usr/include/c++/5/sstream" 3
public: explicit basic_istringstream(::std::ios_base::openmode __mode = ios_base::in) : __istream_type(), _M_stringbuf((__mode | ::std::ios_base::in)) 
# 405
{ (this->init(&(_M_stringbuf))); } 
# 421 "/usr/include/c++/5/sstream" 3
explicit basic_istringstream(const __string_type &__str, ::std::ios_base::openmode 
# 422
__mode = ios_base::in) : __istream_type(), _M_stringbuf(__str, (__mode | ::std::ios_base::in)) 
# 424
{ (this->init(&(_M_stringbuf))); } 
# 432
~basic_istringstream() 
# 433
{ } 
# 436
basic_istringstream(const basic_istringstream &) = delete;
# 438
basic_istringstream(basic_istringstream &&__rhs) : __istream_type(::std::move(__rhs)), _M_stringbuf(::std::move((__rhs._M_stringbuf))) 
# 441
{ __istream_type::set_rdbuf(&(_M_stringbuf)); } 
# 446
basic_istringstream &operator=(const basic_istringstream &) = delete;
# 449
basic_istringstream &operator=(basic_istringstream &&__rhs) 
# 450
{ 
# 451
::std::basic_istream< _CharT, _Traits> ::operator=(::std::move(__rhs)); 
# 452
(_M_stringbuf) = ::std::move((__rhs._M_stringbuf)); 
# 453
return *this; 
# 454
} 
# 457
void swap(basic_istringstream &__rhs) 
# 458
{ 
# 459
__istream_type::swap(__rhs); 
# 460
((_M_stringbuf).swap((__rhs._M_stringbuf))); 
# 461
} 
# 472 "/usr/include/c++/5/sstream" 3
__stringbuf_type *rdbuf() const 
# 473
{ return const_cast< __stringbuf_type *>(&(_M_stringbuf)); } 
# 480
__string_type str() const 
# 481
{ return ((_M_stringbuf).str()); } 
# 490
void str(const __string_type &__s) 
# 491
{ ((_M_stringbuf).str(__s)); } 
# 492
}; 
# 510 "/usr/include/c++/5/sstream" 3
template< class _CharT, class _Traits, class _Alloc> 
# 511
class basic_ostringstream : public basic_ostream< _CharT, _Traits>  { 
# 515
public: typedef _CharT char_type; 
# 516
typedef _Traits traits_type; 
# 519
typedef _Alloc allocator_type; 
# 520
typedef typename _Traits::int_type int_type; 
# 521
typedef typename _Traits::pos_type pos_type; 
# 522
typedef typename _Traits::off_type off_type; 
# 525
typedef basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 526
typedef basic_stringbuf< _CharT, _Traits, _Alloc>  __stringbuf_type; 
# 527
typedef ::std::basic_ostream< _CharT, _Traits>  __ostream_type; 
# 530
private: __stringbuf_type _M_stringbuf; 
# 547 "/usr/include/c++/5/sstream" 3
public: explicit basic_ostringstream(::std::ios_base::openmode __mode = ios_base::out) : __ostream_type(), _M_stringbuf((__mode | ::std::ios_base::out)) 
# 549
{ (this->init(&(_M_stringbuf))); } 
# 565 "/usr/include/c++/5/sstream" 3
explicit basic_ostringstream(const __string_type &__str, ::std::ios_base::openmode 
# 566
__mode = ios_base::out) : __ostream_type(), _M_stringbuf(__str, (__mode | ::std::ios_base::out)) 
# 568
{ (this->init(&(_M_stringbuf))); } 
# 576
~basic_ostringstream() 
# 577
{ } 
# 580
basic_ostringstream(const basic_ostringstream &) = delete;
# 582
basic_ostringstream(basic_ostringstream &&__rhs) : __ostream_type(::std::move(__rhs)), _M_stringbuf(::std::move((__rhs._M_stringbuf))) 
# 585
{ __ostream_type::set_rdbuf(&(_M_stringbuf)); } 
# 590
basic_ostringstream &operator=(const basic_ostringstream &) = delete;
# 593
basic_ostringstream &operator=(basic_ostringstream &&__rhs) 
# 594
{ 
# 595
::std::basic_ostream< _CharT, _Traits> ::operator=(::std::move(__rhs)); 
# 596
(_M_stringbuf) = ::std::move((__rhs._M_stringbuf)); 
# 597
return *this; 
# 598
} 
# 601
void swap(basic_ostringstream &__rhs) 
# 602
{ 
# 603
__ostream_type::swap(__rhs); 
# 604
((_M_stringbuf).swap((__rhs._M_stringbuf))); 
# 605
} 
# 616 "/usr/include/c++/5/sstream" 3
__stringbuf_type *rdbuf() const 
# 617
{ return const_cast< __stringbuf_type *>(&(_M_stringbuf)); } 
# 624
__string_type str() const 
# 625
{ return ((_M_stringbuf).str()); } 
# 634
void str(const __string_type &__s) 
# 635
{ ((_M_stringbuf).str(__s)); } 
# 636
}; 
# 654 "/usr/include/c++/5/sstream" 3
template< class _CharT, class _Traits, class _Alloc> 
# 655
class basic_stringstream : public basic_iostream< _CharT, _Traits>  { 
# 659
public: typedef _CharT char_type; 
# 660
typedef _Traits traits_type; 
# 663
typedef _Alloc allocator_type; 
# 664
typedef typename _Traits::int_type int_type; 
# 665
typedef typename _Traits::pos_type pos_type; 
# 666
typedef typename _Traits::off_type off_type; 
# 669
typedef basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 670
typedef basic_stringbuf< _CharT, _Traits, _Alloc>  __stringbuf_type; 
# 671
typedef ::std::basic_iostream< _CharT, _Traits>  __iostream_type; 
# 674
private: __stringbuf_type _M_stringbuf; 
# 690 "/usr/include/c++/5/sstream" 3
public: explicit basic_stringstream(::std::ios_base::openmode __m = (::std::ios_base::out | ::std::ios_base::in)) : __iostream_type(), _M_stringbuf(__m) 
# 692
{ (this->init(&(_M_stringbuf))); } 
# 706 "/usr/include/c++/5/sstream" 3
explicit basic_stringstream(const __string_type &__str, ::std::ios_base::openmode 
# 707
__m = (::std::ios_base::out | ::std::ios_base::in)) : __iostream_type(), _M_stringbuf(__str, __m) 
# 709
{ (this->init(&(_M_stringbuf))); } 
# 717
~basic_stringstream() 
# 718
{ } 
# 721
basic_stringstream(const basic_stringstream &) = delete;
# 723
basic_stringstream(basic_stringstream &&__rhs) : __iostream_type(::std::move(__rhs)), _M_stringbuf(::std::move((__rhs._M_stringbuf))) 
# 726
{ __iostream_type::set_rdbuf(&(_M_stringbuf)); } 
# 731
basic_stringstream &operator=(const basic_stringstream &) = delete;
# 734
basic_stringstream &operator=(basic_stringstream &&__rhs) 
# 735
{ 
# 736
::std::basic_iostream< _CharT, _Traits> ::operator=(::std::move(__rhs)); 
# 737
(_M_stringbuf) = ::std::move((__rhs._M_stringbuf)); 
# 738
return *this; 
# 739
} 
# 742
void swap(basic_stringstream &__rhs) 
# 743
{ 
# 744
__iostream_type::swap(__rhs); 
# 745
((_M_stringbuf).swap((__rhs._M_stringbuf))); 
# 746
} 
# 757 "/usr/include/c++/5/sstream" 3
__stringbuf_type *rdbuf() const 
# 758
{ return const_cast< __stringbuf_type *>(&(_M_stringbuf)); } 
# 765
__string_type str() const 
# 766
{ return ((_M_stringbuf).str()); } 
# 775
void str(const __string_type &__s) 
# 776
{ ((_M_stringbuf).str(__s)); } 
# 777
}; 
# 781
template< class _CharT, class _Traits, class _Allocator> inline void 
# 783
swap(basic_stringbuf< _CharT, _Traits, _Allocator>  &__x, basic_stringbuf< _CharT, _Traits, _Allocator>  &
# 784
__y) 
# 785
{ (__x.swap(__y)); } 
# 788
template< class _CharT, class _Traits, class _Allocator> inline void 
# 790
swap(basic_istringstream< _CharT, _Traits, _Allocator>  &__x, basic_istringstream< _CharT, _Traits, _Allocator>  &
# 791
__y) 
# 792
{ (__x.swap(__y)); } 
# 795
template< class _CharT, class _Traits, class _Allocator> inline void 
# 797
swap(basic_ostringstream< _CharT, _Traits, _Allocator>  &__x, basic_ostringstream< _CharT, _Traits, _Allocator>  &
# 798
__y) 
# 799
{ (__x.swap(__y)); } 
# 802
template< class _CharT, class _Traits, class _Allocator> inline void 
# 804
swap(basic_stringstream< _CharT, _Traits, _Allocator>  &__x, basic_stringstream< _CharT, _Traits, _Allocator>  &
# 805
__y) 
# 806
{ (__x.swap(__y)); } 
# 809
}
# 811
}
# 39 "/usr/include/c++/5/bits/sstream.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::int_type 
# 46
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::pbackfail(int_type __c) 
# 47
{ 
# 48
int_type __ret = traits_type::eof(); 
# 49
if ((this->eback()) < (this->gptr())) 
# 50
{ 
# 53
const bool __testeof = traits_type::eq_int_type(__c, __ret); 
# 54
if (!__testeof) 
# 55
{ 
# 56
const bool __testeq = traits_type::eq(traits_type::to_char_type(__c), (this->gptr())[-1]); 
# 59
const bool __testout = ((this->_M_mode) & ::std::ios_base::out); 
# 60
if (__testeq || __testout) 
# 61
{ 
# 62
(this->gbump(-1)); 
# 63
if (!__testeq) { 
# 64
(*(this->gptr())) = traits_type::to_char_type(__c); }  
# 65
__ret = __c; 
# 66
}  
# 67
} else 
# 69
{ 
# 70
(this->gbump(-1)); 
# 71
__ret = traits_type::not_eof(__c); 
# 72
}  
# 73
}  
# 74
return __ret; 
# 75
} 
# 77
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::int_type 
# 80
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::overflow(int_type __c) 
# 81
{ 
# 82
const bool __testout = ((this->_M_mode) & ::std::ios_base::out); 
# 83
if (__builtin_expect(!__testout, false)) { 
# 84
return traits_type::eof(); }  
# 86
const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof()); 
# 87
if (__builtin_expect(__testeof, false)) { 
# 88
return traits_type::not_eof(__c); }  
# 90
const __size_type __capacity = ((_M_string).capacity()); 
# 91
const __size_type __max_size = ((_M_string).max_size()); 
# 92
const bool __testput = (this->pptr()) < (this->epptr()); 
# 93
if (__builtin_expect((!__testput) && (__capacity == __max_size), false)) { 
# 94
return traits_type::eof(); }  
# 98
const char_type __conv = traits_type::to_char_type(__c); 
# 99
if (!__testput) 
# 100
{ 
# 110 "/usr/include/c++/5/bits/sstream.tcc" 3
const __size_type __opt_len = ::std::max((__size_type)(2 * __capacity), (__size_type)512); 
# 112
const __size_type __len = ::std::min(__opt_len, __max_size); 
# 113
__string_type __tmp; 
# 114
(__tmp.reserve(__len)); 
# 115
if ((this->pbase())) { 
# 116
(__tmp.assign((this->pbase()), (this->epptr()) - (this->pbase()))); }  
# 117
(__tmp.push_back(__conv)); 
# 118
((_M_string).swap(__tmp)); 
# 119
_M_sync(const_cast< char_type *>(((_M_string).data())), (this->gptr()) - (this->eback()), (this->pptr()) - (this->pbase())); 
# 121
} else { 
# 123
(*(this->pptr())) = __conv; }  
# 124
(this->pbump(1)); 
# 125
return __c; 
# 126
} 
# 128
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::int_type 
# 131
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::underflow() 
# 132
{ 
# 133
int_type __ret = traits_type::eof(); 
# 134
const bool __testin = ((this->_M_mode) & ::std::ios_base::in); 
# 135
if (__testin) 
# 136
{ 
# 138
_M_update_egptr(); 
# 140
if ((this->gptr()) < (this->egptr())) { 
# 141
__ret = traits_type::to_int_type(*(this->gptr())); }  
# 142
}  
# 143
return __ret; 
# 144
} 
# 146
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::pos_type 
# 149
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::seekoff(off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode) 
# 150
{ 
# 151
pos_type __ret = ((pos_type)((off_type)(-1))); 
# 152
bool __testin = ((((::std::ios_base::in & (this->_M_mode))) & __mode)) != 0; 
# 153
bool __testout = ((((::std::ios_base::out & (this->_M_mode))) & __mode)) != 0; 
# 154
const bool __testboth = __testin && __testout && (__way != ::std::ios_base::cur); 
# 155
__testin &= (!((__mode & ::std::ios_base::out))); 
# 156
__testout &= (!((__mode & ::std::ios_base::in))); 
# 160
const char_type *__beg = __testin ? (this->eback()) : (this->pbase()); 
# 161
if ((__beg || (!__off)) && ((__testin || __testout) || __testboth)) 
# 162
{ 
# 163
_M_update_egptr(); 
# 165
off_type __newoffi = __off; 
# 166
off_type __newoffo = __newoffi; 
# 167
if (__way == ::std::ios_base::cur) 
# 168
{ 
# 169
__newoffi += ((this->gptr()) - __beg); 
# 170
__newoffo += ((this->pptr()) - __beg); 
# 171
} else { 
# 172
if (__way == ::std::ios_base::end) { 
# 173
__newoffo = (__newoffi += ((this->egptr()) - __beg)); }  }  
# 175
if ((__testin || __testboth) && (__newoffi >= 0) && (((this->egptr()) - __beg) >= __newoffi)) 
# 178
{ 
# 179
(this->setg((this->eback()), (this->eback()) + __newoffi, (this->egptr()))); 
# 181
__ret = ((pos_type)__newoffi); 
# 182
}  
# 183
if ((__testout || __testboth) && (__newoffo >= 0) && (((this->egptr()) - __beg) >= __newoffo)) 
# 186
{ 
# 187
_M_pbump((this->pbase()), (this->epptr()), __newoffo); 
# 188
__ret = ((pos_type)__newoffo); 
# 189
}  
# 190
}  
# 191
return __ret; 
# 192
} 
# 194
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::pos_type 
# 197
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::seekpos(pos_type __sp, ::std::ios_base::openmode __mode) 
# 198
{ 
# 199
pos_type __ret = ((pos_type)((off_type)(-1))); 
# 200
const bool __testin = ((((::std::ios_base::in & (this->_M_mode))) & __mode)) != 0; 
# 201
const bool __testout = ((((::std::ios_base::out & (this->_M_mode))) & __mode)) != 0; 
# 203
const char_type *__beg = __testin ? (this->eback()) : (this->pbase()); 
# 204
if ((__beg || (!((off_type)__sp))) && (__testin || __testout)) 
# 205
{ 
# 206
_M_update_egptr(); 
# 208
const off_type __pos(__sp); 
# 209
const bool __testpos = (0 <= __pos) && (__pos <= ((this->egptr()) - __beg)); 
# 211
if (__testpos) 
# 212
{ 
# 213
if (__testin) { 
# 214
(this->setg((this->eback()), (this->eback()) + __pos, (this->egptr()))); }  
# 216
if (__testout) { 
# 217
_M_pbump((this->pbase()), (this->epptr()), __pos); }  
# 218
__ret = __sp; 
# 219
}  
# 220
}  
# 221
return __ret; 
# 222
} 
# 224
template< class _CharT, class _Traits, class _Alloc> void 
# 227
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::_M_sync(char_type *__base, __size_type __i, __size_type __o) 
# 228
{ 
# 229
const bool __testin = ((_M_mode) & ::std::ios_base::in); 
# 230
const bool __testout = ((_M_mode) & ::std::ios_base::out); 
# 231
char_type *__endg = __base + ((_M_string).size()); 
# 232
char_type *__endp = __base + ((_M_string).capacity()); 
# 234
if (__base != ((_M_string).data())) 
# 235
{ 
# 237
__endg += __i; 
# 238
__i = 0; 
# 239
__endp = __endg; 
# 240
}  
# 242
if (__testin) { 
# 243
(this->setg(__base, __base + __i, __endg)); }  
# 244
if (__testout) 
# 245
{ 
# 246
_M_pbump(__base, __endp, __o); 
# 250
if (!__testin) { 
# 251
(this->setg(__endg, __endg, __endg)); }  
# 252
}  
# 253
} 
# 255
template< class _CharT, class _Traits, class _Alloc> void 
# 258
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::_M_pbump(char_type *__pbeg, char_type *__pend, off_type __off) 
# 259
{ 
# 260
(this->setp(__pbeg, __pend)); 
# 261
while (__off > __gnu_cxx::__numeric_traits< int> ::__max) 
# 262
{ 
# 263
(this->pbump(__gnu_cxx::__numeric_traits< int> ::__max)); 
# 264
__off -= __gnu_cxx::__numeric_traits< int> ::__max; 
# 265
}  
# 266
(this->pbump(__off)); 
# 267
} 
# 272
extern template class __cxx11::basic_stringbuf< char, char_traits< char> , allocator< char> > ;
# 273
extern template class __cxx11::basic_istringstream< char, char_traits< char> , allocator< char> > ;
# 274
extern template class __cxx11::basic_ostringstream< char, char_traits< char> , allocator< char> > ;
# 275
extern template class __cxx11::basic_stringstream< char, char_traits< char> , allocator< char> > ;
# 278
extern template class __cxx11::basic_stringbuf< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > ;
# 279
extern template class __cxx11::basic_istringstream< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > ;
# 280
extern template class __cxx11::basic_ostringstream< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > ;
# 281
extern template class __cxx11::basic_stringstream< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > ;
# 286
}
# 43 "/usr/include/c++/5/ratio" 3
namespace std __attribute((__visibility__("default"))) { 
# 55 "/usr/include/c++/5/ratio" 3
template< intmax_t _Pn> 
# 56
struct __static_sign : public integral_constant< long, (_Pn < (0)) ? -1 : 1>  { 
# 58
}; 
# 60
template< intmax_t _Pn> 
# 61
struct __static_abs : public integral_constant< long, _Pn * __static_sign< _Pn> ::value>  { 
# 63
}; 
# 65
template< intmax_t _Pn, intmax_t _Qn> 
# 66
struct __static_gcd : public __static_gcd< _Qn, _Pn % _Qn>  { 
# 68
}; 
# 70
template< intmax_t _Pn> 
# 71
struct __static_gcd< _Pn, 0>  : public integral_constant< long, __static_abs< _Pn> ::value>  { 
# 73
}; 
# 75
template< intmax_t _Qn> 
# 76
struct __static_gcd< 0, _Qn>  : public integral_constant< long, __static_abs< _Qn> ::value>  { 
# 78
}; 
# 86
template< intmax_t _Pn, intmax_t _Qn> 
# 87
struct __safe_multiply { 
# 90
private: static const uintmax_t __c = (((uintmax_t)1) << (sizeof(intmax_t) * (4))); 
# 92
static const uintmax_t __a0 = (__static_abs< _Pn> ::value % __c); 
# 93
static const uintmax_t __a1 = (__static_abs< _Pn> ::value / __c); 
# 94
static const uintmax_t __b0 = (__static_abs< _Qn> ::value % __c); 
# 95
static const uintmax_t __b1 = (__static_abs< _Qn> ::value / __c); 
# 97
static_assert(((__a1 == (0)) || (__b1 == (0))), "overflow in multiplication");
# 99
static_assert((((__a0 * __b1) + (__b0 * __a1)) < (__c >> 1)), "overflow in multiplication");
# 101
static_assert(((__b0 * __a0) <= (9223372036854775807L)), "overflow in multiplication");
# 103
static_assert(((((__a0 * __b1) + (__b0 * __a1)) * __c) <= ((9223372036854775807L) - (__b0 * __a0))), "overflow in multiplication");
# 108
public: static const intmax_t value = (_Pn * _Qn); 
# 109
}; 
# 113
template< uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2> 
# 114
struct __big_less : public integral_constant< bool, (__hi1 < __hi2) || ((__hi1 == __hi2) && (__lo1 < __lo2))>  { 
# 117
}; 
# 119
template< uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2> 
# 120
struct __big_add { 
# 122
static constexpr uintmax_t __lo = (__lo1 + __lo2); 
# 123
static constexpr uintmax_t __hi = ((__hi1 + __hi2) + ((__lo1 + __lo2) < __lo1)); 
# 125
}; 
# 128
template< uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2> 
# 129
struct __big_sub { 
# 131
static_assert((!__big_less< __hi1, __lo1, __hi2, __lo2> ::value), "Internal library error");
# 133
static constexpr uintmax_t __lo = (__lo1 - __lo2); 
# 134
static constexpr uintmax_t __hi = ((__hi1 - __hi2) - (__lo1 < __lo2)); 
# 136
}; 
# 139
template< uintmax_t __x, uintmax_t __y> 
# 140
struct __big_mul { 
# 143
private: static constexpr uintmax_t __c = (((uintmax_t)1) << (sizeof(intmax_t) * (4))); 
# 144
static constexpr uintmax_t __x0 = (__x % __c); 
# 145
static constexpr uintmax_t __x1 = (__x / __c); 
# 146
static constexpr uintmax_t __y0 = (__y % __c); 
# 147
static constexpr uintmax_t __y1 = (__y / __c); 
# 148
static constexpr uintmax_t __x0y0 = (__x0 * __y0); 
# 149
static constexpr uintmax_t __x0y1 = (__x0 * __y1); 
# 150
static constexpr uintmax_t __x1y0 = (__x1 * __y0); 
# 151
static constexpr uintmax_t __x1y1 = (__x1 * __y1); 
# 152
static constexpr uintmax_t __mix = (__x0y1 + __x1y0); 
# 153
static constexpr uintmax_t __mix_lo = (__mix * __c); 
# 154
static constexpr uintmax_t __mix_hi = ((__mix / __c) + ((__mix < __x0y1) ? __c : (0))); 
# 156
typedef __big_add< __mix_hi, __mix_lo, __x1y1, __x0y0>  _Res; 
# 158
public: static constexpr uintmax_t __hi = (_Res::__hi); 
# 159
static constexpr uintmax_t __lo = (_Res::__lo); 
# 160
}; 
# 164
template< uintmax_t __n1, uintmax_t __n0, uintmax_t __d> 
# 165
struct __big_div_impl { 
# 168
static_assert((__d >= (((uintmax_t)1) << ((sizeof(intmax_t) * (8)) - (1)))), "Internal library error");
# 170
static_assert((__n1 < __d), "Internal library error");
# 171
private: static constexpr uintmax_t __c = (((uintmax_t)1) << (sizeof(intmax_t) * (4))); 
# 172
static constexpr uintmax_t __d1 = (__d / __c); 
# 173
static constexpr uintmax_t __d0 = (__d % __c); 
# 175
static constexpr uintmax_t __q1x = (__n1 / __d1); 
# 176
static constexpr uintmax_t __r1x = (__n1 % __d1); 
# 177
static constexpr uintmax_t __m = (__q1x * __d0); 
# 178
static constexpr uintmax_t __r1y = ((__r1x * __c) + (__n0 / __c)); 
# 179
static constexpr uintmax_t __r1z = (__r1y + __d); 
# 180
static constexpr uintmax_t __r1 = (((__r1y < __m) ? ((__r1z >= __d) && (__r1z < __m)) ? __r1z + __d : __r1z : __r1y) - __m); 
# 183
static constexpr uintmax_t __q1 = (__q1x - ((__r1y < __m) ? ((__r1z >= __d) && (__r1z < __m)) ? 2 : 1 : 0)); 
# 186
static constexpr uintmax_t __q0x = (__r1 / __d1); 
# 187
static constexpr uintmax_t __r0x = (__r1 % __d1); 
# 188
static constexpr uintmax_t __n = (__q0x * __d0); 
# 189
static constexpr uintmax_t __r0y = ((__r0x * __c) + (__n0 % __c)); 
# 190
static constexpr uintmax_t __r0z = (__r0y + __d); 
# 191
static constexpr uintmax_t __r0 = (((__r0y < __n) ? ((__r0z >= __d) && (__r0z < __n)) ? __r0z + __d : __r0z : __r0y) - __n); 
# 194
static constexpr uintmax_t __q0 = (__q0x - ((__r0y < __n) ? ((__r0z >= __d) && (__r0z < __n)) ? 2 : 1 : 0)); 
# 199
public: static constexpr uintmax_t __quot = ((__q1 * __c) + __q0); 
# 200
static constexpr uintmax_t __rem = __r0; 
# 203
private: typedef __big_mul< __quot, __d>  _Prod; 
# 204
typedef __big_add< __big_mul< __quot, __d> ::__hi, __big_mul< __quot, __d> ::__lo, 0UL, __rem>  _Sum; 
# 205
static_assert(((_Sum::__hi == __n1) && (_Sum::__lo == __n0)), "Internal library error");
# 207
}; 
# 209
template< uintmax_t __n1, uintmax_t __n0, uintmax_t __d> 
# 210
struct __big_div { 
# 213
static_assert((__d != (0)), "Internal library error");
# 214
static_assert((sizeof(uintmax_t) == sizeof(unsigned long long)), "This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzill" "a/");
# 218
private: static constexpr int __shift = __builtin_clzll(__d); 
# 219
static constexpr int __coshift_ = ((sizeof(uintmax_t) * (8)) - __shift); 
# 220
static constexpr int __coshift = ((__shift != 0) ? __coshift_ : 0); 
# 221
static constexpr uintmax_t __c1 = (((uintmax_t)1) << __shift); 
# 222
static constexpr uintmax_t __c2 = (((uintmax_t)1) << __coshift); 
# 223
static constexpr uintmax_t __new_d = (__d * __c1); 
# 224
static constexpr uintmax_t __new_n0 = (__n0 * __c1); 
# 225
static constexpr uintmax_t __n1_shifted = ((__n1 % __d) * __c1); 
# 226
static constexpr uintmax_t __n0_top = ((__shift != 0) ? __n0 / __c2 : (0)); 
# 227
static constexpr uintmax_t __new_n1 = (__n1_shifted + __n0_top); 
# 228
typedef __big_div_impl< __new_n1, __new_n0, __new_d>  _Res; 
# 231
public: static constexpr uintmax_t __quot_hi = (__n1 / __d); 
# 232
static constexpr uintmax_t __quot_lo = (_Res::__quot); 
# 233
static constexpr uintmax_t __rem = (_Res::__rem / __c1); 
# 236
private: typedef __big_mul< __quot_lo, __d>  _P0; 
# 237
typedef __big_mul< __quot_hi, __d>  _P1; 
# 238
typedef __big_add< __big_mul< __quot_lo, __d> ::__hi, __big_mul< __quot_lo, __d> ::__lo, __big_mul< __quot_hi, __d> ::__lo, __rem>  _Sum; 
# 240
static_assert((_P1::__hi == 0), "Internal library error");
# 241
static_assert((_Sum::__hi >= _P0::__hi), "Internal library error");
# 243
static_assert(((_Sum::__hi == __n1) && (_Sum::__lo == __n0)), "Internal library error");
# 245
static_assert((__rem < __d), "Internal library error");
# 246
}; 
# 262 "/usr/include/c++/5/ratio" 3
template< intmax_t _Num, intmax_t _Den = 1L> 
# 263
struct ratio { 
# 265
static_assert((_Den != (0)), "denominator cannot be zero");
# 266
static_assert(((_Num >= (-9223372036854775807L)) && (_Den >= (-9223372036854775807L))), "out of range");
# 270
static constexpr intmax_t num = ((_Num * __static_sign< _Den> ::value) / __static_gcd< _Num, _Den> ::value); 
# 273
static constexpr intmax_t den = (__static_abs< _Den> ::value / __static_gcd< _Num, _Den> ::value); 
# 276
typedef std::ratio< num, den>  type; 
# 277
}; 
# 279
template< intmax_t _Num, intmax_t _Den> constexpr intmax_t 
# 280
ratio< _Num, _Den> ::num; 
# 282
template< intmax_t _Num, intmax_t _Den> constexpr intmax_t 
# 283
ratio< _Num, _Den> ::den; 
# 285
template< class _R1, class _R2> 
# 286
struct __ratio_multiply { 
# 289
private: static const intmax_t __gcd1 = (__static_gcd< _R1::num, _R2::den> ::value); 
# 291
static const intmax_t __gcd2 = (__static_gcd< _R2::num, _R1::den> ::value); 
# 299
public: typedef ratio< __safe_multiply< _R1::num / __gcd1, _R2::num / __gcd2> ::value, __safe_multiply< _R1::den / __gcd2, _R2::den / __gcd1> ::value>  type; 
# 301
static constexpr intmax_t num = (type::num); 
# 302
static constexpr intmax_t den = (type::den); 
# 303
}; 
# 305
template< class _R1, class _R2> constexpr intmax_t 
# 306
__ratio_multiply< _R1, _R2> ::num; 
# 308
template< class _R1, class _R2> constexpr intmax_t 
# 309
__ratio_multiply< _R1, _R2> ::den; 
# 312
template< class _R1, class _R2> using ratio_multiply = typename __ratio_multiply< _R1, _R2> ::type; 
# 315
template< class _R1, class _R2> 
# 316
struct __ratio_divide { 
# 318
static_assert((_R2::num != 0), "division by 0");
# 322
typedef typename __ratio_multiply< _R1, ratio< _R2::den, _R2::num> > ::type type; 
# 324
static constexpr intmax_t num = (type::num); 
# 325
static constexpr intmax_t den = (type::den); 
# 326
}; 
# 328
template< class _R1, class _R2> constexpr intmax_t 
# 329
__ratio_divide< _R1, _R2> ::num; 
# 331
template< class _R1, class _R2> constexpr intmax_t 
# 332
__ratio_divide< _R1, _R2> ::den; 
# 335
template< class _R1, class _R2> using ratio_divide = typename __ratio_divide< _R1, _R2> ::type; 
# 339
template< class _R1, class _R2> 
# 340
struct ratio_equal : public integral_constant< bool, (_R1::num == _R2::num) && (_R1::den == _R2::den)>  { 
# 342
}; 
# 345
template< class _R1, class _R2> 
# 346
struct ratio_not_equal : public integral_constant< bool, !ratio_equal< _R1, _R2> ::value>  { 
# 348
}; 
# 351
template< class _R1, class _R2, class 
# 352
_Left = __big_mul< _R1::num, _R2::den> , class 
# 353
_Right = __big_mul< _R2::num, _R1::den> > 
# 354
struct __ratio_less_impl_1 : public integral_constant< bool, __big_less< _Left::__hi, _Left::__lo, _Right::__hi, _Right::__lo> ::value>  { 
# 357
}; 
# 359
template< class _R1, class _R2, bool 
# 360
 = ((_R1::num == 0) || (_R2::num == 0)) || (__static_sign< _R1::num> ::value != __static_sign< _R2::num> ::value), bool 
# 363
 = (__static_sign< _R1::num> ::value == (-1)) && (__static_sign< _R2::num> ::value == (-1))> 
# 365
struct __ratio_less_impl : public __ratio_less_impl_1< _R1, _R2> ::type { 
# 367
}; 
# 369
template< class _R1, class _R2> 
# 370
struct __ratio_less_impl< _R1, _R2, true, false>  : public integral_constant< bool, _R1::num < _R2::num>  { 
# 372
}; 
# 374
template< class _R1, class _R2> 
# 375
struct __ratio_less_impl< _R1, _R2, false, true>  : public __ratio_less_impl_1< ratio< -_R2::num, _R2::den> , ratio< -_R1::num, _R1::den> > ::type { 
# 378
}; 
# 381
template< class _R1, class _R2> 
# 382
struct ratio_less : public __ratio_less_impl< _R1, _R2> ::type { 
# 384
}; 
# 387
template< class _R1, class _R2> 
# 388
struct ratio_less_equal : public integral_constant< bool, !ratio_less< _R2, _R1> ::value>  { 
# 390
}; 
# 393
template< class _R1, class _R2> 
# 394
struct ratio_greater : public integral_constant< bool, ratio_less< _R2, _R1> ::value>  { 
# 396
}; 
# 399
template< class _R1, class _R2> 
# 400
struct ratio_greater_equal : public integral_constant< bool, !ratio_less< _R1, _R2> ::value>  { 
# 402
}; 
# 404
template< class _R1, class _R2, bool 
# 405
 = _R1::num >= 0, bool 
# 406
 = _R2::num >= 0, bool 
# 407
 = ratio_less< ratio< __static_abs< _R1::num> ::value, _R1::den> , ratio< __static_abs< _R2::num> ::value, _R2::den> > ::value> 
# 409
struct __ratio_add_impl { 
# 414
private: typedef typename std::__ratio_add_impl< ratio< -_R1::num, _R1::den> , ratio< -_R2::num, _R2::den> > ::type __t; 
# 416
public: typedef ratio< -std::__ratio_add_impl< ratio< -_R1::num, _R1::den> , ratio< -_R2::num, _R2::den> > ::type::num, std::__ratio_add_impl< ratio< -_R1::num, _R1::den> , ratio< -_R2::num, _R2::den> > ::type::den>  type; 
# 417
}; 
# 420
template< class _R1, class _R2, bool __b> 
# 421
struct __ratio_add_impl< _R1, _R2, true, true, __b>  { 
# 424
private: static constexpr uintmax_t __g = (__static_gcd< _R1::den, _R2::den> ::value); 
# 425
static constexpr uintmax_t __d2 = (_R2::den / __g); 
# 426
typedef __big_mul< _R1::den, __d2>  __d; 
# 427
typedef __big_mul< _R1::num, _R2::den / __g>  __x; 
# 428
typedef __big_mul< _R2::num, _R1::den / __g>  __y; 
# 429
typedef __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo>  __n; 
# 430
static_assert((__n::__hi >= __x::__hi), "Internal library error");
# 431
typedef __big_div< __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__hi, __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__lo, __g>  __ng; 
# 432
static constexpr uintmax_t __g2 = (__static_gcd< __big_div< __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__hi, __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__lo, __g> ::__rem, __g> ::value); 
# 433
typedef __big_div< __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__hi, __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__lo, __g2>  __n_final; 
# 434
static_assert((__n_final::__rem == 0), "Internal library error");
# 435
static_assert(((__n_final::__quot_hi == 0) && (__n_final::__quot_lo <= 9223372036854775807L)), "overflow in addition");
# 437
typedef __big_mul< _R1::den / __g2, __d2>  __d_final; 
# 438
static_assert(((__d_final::__hi == 0) && (__d_final::__lo <= 9223372036854775807L)), "overflow in addition");
# 441
public: typedef ratio< __big_div< __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__hi, __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__lo, __g2> ::__quot_lo, __big_mul< _R1::den / __g2, __d2> ::__lo>  type; 
# 442
}; 
# 444
template< class _R1, class _R2> 
# 445
struct __ratio_add_impl< _R1, _R2, false, true, true>  : public __ratio_add_impl< _R2, _R1>  { 
# 447
}; 
# 450
template< class _R1, class _R2> 
# 451
struct __ratio_add_impl< _R1, _R2, true, false, false>  { 
# 454
private: static constexpr uintmax_t __g = (__static_gcd< _R1::den, _R2::den> ::value); 
# 455
static constexpr uintmax_t __d2 = (_R2::den / __g); 
# 456
typedef __big_mul< _R1::den, __d2>  __d; 
# 457
typedef __big_mul< _R1::num, _R2::den / __g>  __x; 
# 458
typedef __big_mul< -_R2::num, _R1::den / __g>  __y; 
# 459
typedef __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo>  __n; 
# 460
typedef __big_div< __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__hi, __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__lo, __g>  __ng; 
# 461
static constexpr uintmax_t __g2 = (__static_gcd< __big_div< __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__hi, __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__lo, __g> ::__rem, __g> ::value); 
# 462
typedef __big_div< __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__hi, __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__lo, __g2>  __n_final; 
# 463
static_assert((__n_final::__rem == 0), "Internal library error");
# 464
static_assert(((__n_final::__quot_hi == 0) && (__n_final::__quot_lo <= 9223372036854775807L)), "overflow in addition");
# 466
typedef __big_mul< _R1::den / __g2, __d2>  __d_final; 
# 467
static_assert(((__d_final::__hi == 0) && (__d_final::__lo <= 9223372036854775807L)), "overflow in addition");
# 470
public: typedef ratio< __big_div< __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__hi, __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__lo, __g2> ::__quot_lo, __big_mul< _R1::den / __g2, __d2> ::__lo>  type; 
# 471
}; 
# 473
template< class _R1, class _R2> 
# 474
struct __ratio_add { 
# 476
typedef typename __ratio_add_impl< _R1, _R2> ::type type; 
# 477
static constexpr intmax_t num = (type::num); 
# 478
static constexpr intmax_t den = (type::den); 
# 479
}; 
# 481
template< class _R1, class _R2> constexpr intmax_t 
# 482
__ratio_add< _R1, _R2> ::num; 
# 484
template< class _R1, class _R2> constexpr intmax_t 
# 485
__ratio_add< _R1, _R2> ::den; 
# 488
template< class _R1, class _R2> using ratio_add = typename __ratio_add< _R1, _R2> ::type; 
# 491
template< class _R1, class _R2> 
# 492
struct __ratio_subtract { 
# 496
typedef typename __ratio_add< _R1, ratio< -_R2::num, _R2::den> > ::type type; 
# 498
static constexpr intmax_t num = (type::num); 
# 499
static constexpr intmax_t den = (type::den); 
# 500
}; 
# 502
template< class _R1, class _R2> constexpr intmax_t 
# 503
__ratio_subtract< _R1, _R2> ::num; 
# 505
template< class _R1, class _R2> constexpr intmax_t 
# 506
__ratio_subtract< _R1, _R2> ::den; 
# 509
template< class _R1, class _R2> using ratio_subtract = typename __ratio_subtract< _R1, _R2> ::type; 
# 513
typedef ratio< 1L, 1000000000000000000L>  atto; 
# 514
typedef ratio< 1L, 1000000000000000L>  femto; 
# 515
typedef ratio< 1L, 1000000000000L>  pico; 
# 516
typedef ratio< 1L, 1000000000L>  nano; 
# 517
typedef ratio< 1L, 1000000L>  micro; 
# 518
typedef ratio< 1L, 1000L>  milli; 
# 519
typedef ratio< 1L, 100L>  centi; 
# 520
typedef ratio< 1L, 10L>  deci; 
# 521
typedef ratio< 10L, 1L>  deca; 
# 522
typedef ratio< 100L, 1L>  hecto; 
# 523
typedef ratio< 1000L, 1L>  kilo; 
# 524
typedef ratio< 1000000L, 1L>  mega; 
# 525
typedef ratio< 1000000000L, 1L>  giga; 
# 526
typedef ratio< 1000000000000L, 1L>  tera; 
# 527
typedef ratio< 1000000000000000L, 1L>  peta; 
# 528
typedef ratio< 1000000000000000000L, 1L>  exa; 
# 532
}
# 158 "/usr/include/c++/5/limits" 3
namespace std __attribute((__visibility__("default"))) { 
# 167
enum float_round_style { 
# 169
round_indeterminate = (-1), 
# 170
round_toward_zero = 0, 
# 171
round_to_nearest, 
# 172
round_toward_infinity, 
# 173
round_toward_neg_infinity
# 174
}; 
# 182
enum float_denorm_style { 
# 185
denorm_indeterminate = (-1), 
# 187
denorm_absent = 0, 
# 189
denorm_present
# 190
}; 
# 202 "/usr/include/c++/5/limits" 3
struct __numeric_limits_base { 
# 206
static constexpr bool is_specialized = false; 
# 211
static constexpr int digits = 0; 
# 214
static constexpr int digits10 = 0; 
# 219
static constexpr int max_digits10 = 0; 
# 223
static constexpr bool is_signed = false; 
# 226
static constexpr bool is_integer = false; 
# 231
static constexpr bool is_exact = false; 
# 235
static constexpr int radix = 0; 
# 239
static constexpr int min_exponent = 0; 
# 243
static constexpr int min_exponent10 = 0; 
# 248
static constexpr int max_exponent = 0; 
# 252
static constexpr int max_exponent10 = 0; 
# 255
static constexpr bool has_infinity = false; 
# 259
static constexpr bool has_quiet_NaN = false; 
# 263
static constexpr bool has_signaling_NaN = false; 
# 266
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 270
static constexpr bool has_denorm_loss = false; 
# 274
static constexpr bool is_iec559 = false; 
# 279
static constexpr bool is_bounded = false; 
# 288 "/usr/include/c++/5/limits" 3
static constexpr bool is_modulo = false; 
# 291
static constexpr bool traps = false; 
# 294
static constexpr bool tinyness_before = false; 
# 299
static constexpr float_round_style round_style = round_toward_zero; 
# 301
}; 
# 314 "/usr/include/c++/5/limits" 3
template< class _Tp> 
# 315
struct numeric_limits : public __numeric_limits_base { 
# 320
static constexpr _Tp min() noexcept { return _Tp(); } 
# 324
static constexpr _Tp max() noexcept { return _Tp(); } 
# 330
static constexpr _Tp lowest() noexcept { return _Tp(); } 
# 336
static constexpr _Tp epsilon() noexcept { return _Tp(); } 
# 340
static constexpr _Tp round_error() noexcept { return _Tp(); } 
# 344
static constexpr _Tp infinity() noexcept { return _Tp(); } 
# 349
static constexpr _Tp quiet_NaN() noexcept { return _Tp(); } 
# 354
static constexpr _Tp signaling_NaN() noexcept { return _Tp(); } 
# 360
static constexpr _Tp denorm_min() noexcept { return _Tp(); } 
# 361
}; 
# 364
template< class _Tp> 
# 365
struct numeric_limits< const _Tp>  : public numeric_limits< _Tp>  { 
# 366
}; 
# 368
template< class _Tp> 
# 369
struct numeric_limits< volatile _Tp>  : public numeric_limits< _Tp>  { 
# 370
}; 
# 372
template< class _Tp> 
# 373
struct numeric_limits< const volatile _Tp>  : public numeric_limits< _Tp>  { 
# 374
}; 
# 382
template<> struct numeric_limits< bool>  { 
# 384
static constexpr bool is_specialized = true; 
# 387
static constexpr bool min() noexcept { return false; } 
# 390
static constexpr bool max() noexcept { return true; } 
# 394
static constexpr bool lowest() noexcept { return min(); } 
# 396
static constexpr int digits = 1; 
# 397
static constexpr int digits10 = 0; 
# 399
static constexpr int max_digits10 = 0; 
# 401
static constexpr bool is_signed = false; 
# 402
static constexpr bool is_integer = true; 
# 403
static constexpr bool is_exact = true; 
# 404
static constexpr int radix = 2; 
# 407
static constexpr bool epsilon() noexcept { return false; } 
# 410
static constexpr bool round_error() noexcept { return false; } 
# 412
static constexpr int min_exponent = 0; 
# 413
static constexpr int min_exponent10 = 0; 
# 414
static constexpr int max_exponent = 0; 
# 415
static constexpr int max_exponent10 = 0; 
# 417
static constexpr bool has_infinity = false; 
# 418
static constexpr bool has_quiet_NaN = false; 
# 419
static constexpr bool has_signaling_NaN = false; 
# 420
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 422
static constexpr bool has_denorm_loss = false; 
# 425
static constexpr bool infinity() noexcept { return false; } 
# 428
static constexpr bool quiet_NaN() noexcept { return false; } 
# 431
static constexpr bool signaling_NaN() noexcept { return false; } 
# 434
static constexpr bool denorm_min() noexcept { return false; } 
# 436
static constexpr bool is_iec559 = false; 
# 437
static constexpr bool is_bounded = true; 
# 438
static constexpr bool is_modulo = false; 
# 443
static constexpr bool traps = true; 
# 444
static constexpr bool tinyness_before = false; 
# 445
static constexpr float_round_style round_style = round_toward_zero; 
# 447
}; 
# 451
template<> struct numeric_limits< char>  { 
# 453
static constexpr bool is_specialized = true; 
# 456
static constexpr char min() noexcept { return (((char)(-1)) < 0) ? (-((((char)(-1)) < 0) ? (((((char)1) << (((sizeof(char) * (8)) - (((char)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((char)0)))) - 1 : ((char)0); } 
# 459
static constexpr char max() noexcept { return (((char)(-1)) < 0) ? (((((char)1) << (((sizeof(char) * (8)) - (((char)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((char)0)); } 
# 463
static constexpr char lowest() noexcept { return min(); } 
# 466
static constexpr int digits = ((sizeof(char) * (8)) - (((char)(-1)) < 0)); 
# 467
static constexpr int digits10 = ((((sizeof(char) * (8)) - (((char)(-1)) < 0)) * (643L)) / (2136)); 
# 469
static constexpr int max_digits10 = 0; 
# 471
static constexpr bool is_signed = (((char)(-1)) < 0); 
# 472
static constexpr bool is_integer = true; 
# 473
static constexpr bool is_exact = true; 
# 474
static constexpr int radix = 2; 
# 477
static constexpr char epsilon() noexcept { return 0; } 
# 480
static constexpr char round_error() noexcept { return 0; } 
# 482
static constexpr int min_exponent = 0; 
# 483
static constexpr int min_exponent10 = 0; 
# 484
static constexpr int max_exponent = 0; 
# 485
static constexpr int max_exponent10 = 0; 
# 487
static constexpr bool has_infinity = false; 
# 488
static constexpr bool has_quiet_NaN = false; 
# 489
static constexpr bool has_signaling_NaN = false; 
# 490
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 492
static constexpr bool has_denorm_loss = false; 
# 495
static constexpr char infinity() noexcept { return ((char)0); } 
# 498
static constexpr char quiet_NaN() noexcept { return ((char)0); } 
# 501
static constexpr char signaling_NaN() noexcept { return ((char)0); } 
# 504
static constexpr char denorm_min() noexcept { return static_cast< char>(0); } 
# 506
static constexpr bool is_iec559 = false; 
# 507
static constexpr bool is_bounded = true; 
# 508
static constexpr bool is_modulo = (!is_signed); 
# 510
static constexpr bool traps = true; 
# 511
static constexpr bool tinyness_before = false; 
# 512
static constexpr float_round_style round_style = round_toward_zero; 
# 514
}; 
# 518
template<> struct numeric_limits< signed char>  { 
# 520
static constexpr bool is_specialized = true; 
# 523
static constexpr signed char min() noexcept { return (-127) - 1; } 
# 526
static constexpr signed char max() noexcept { return 127; } 
# 530
static constexpr signed char lowest() noexcept { return min(); } 
# 533
static constexpr int digits = ((sizeof(signed char) * (8)) - (((signed char)(-1)) < 0)); 
# 534
static constexpr int digits10 = ((((sizeof(signed char) * (8)) - (((signed char)(-1)) < 0)) * (643L)) / (2136)); 
# 537
static constexpr int max_digits10 = 0; 
# 539
static constexpr bool is_signed = true; 
# 540
static constexpr bool is_integer = true; 
# 541
static constexpr bool is_exact = true; 
# 542
static constexpr int radix = 2; 
# 545
static constexpr signed char epsilon() noexcept { return 0; } 
# 548
static constexpr signed char round_error() noexcept { return 0; } 
# 550
static constexpr int min_exponent = 0; 
# 551
static constexpr int min_exponent10 = 0; 
# 552
static constexpr int max_exponent = 0; 
# 553
static constexpr int max_exponent10 = 0; 
# 555
static constexpr bool has_infinity = false; 
# 556
static constexpr bool has_quiet_NaN = false; 
# 557
static constexpr bool has_signaling_NaN = false; 
# 558
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 560
static constexpr bool has_denorm_loss = false; 
# 563
static constexpr signed char infinity() noexcept { return static_cast< signed char>(0); } 
# 566
static constexpr signed char quiet_NaN() noexcept { return static_cast< signed char>(0); } 
# 569
static constexpr signed char signaling_NaN() noexcept 
# 570
{ return static_cast< signed char>(0); } 
# 573
static constexpr signed char denorm_min() noexcept 
# 574
{ return static_cast< signed char>(0); } 
# 576
static constexpr bool is_iec559 = false; 
# 577
static constexpr bool is_bounded = true; 
# 578
static constexpr bool is_modulo = false; 
# 580
static constexpr bool traps = true; 
# 581
static constexpr bool tinyness_before = false; 
# 582
static constexpr float_round_style round_style = round_toward_zero; 
# 584
}; 
# 588
template<> struct numeric_limits< unsigned char>  { 
# 590
static constexpr bool is_specialized = true; 
# 593
static constexpr unsigned char min() noexcept { return 0; } 
# 596
static constexpr unsigned char max() noexcept { return ((127) * 2U) + (1); } 
# 600
static constexpr unsigned char lowest() noexcept { return min(); } 
# 603
static constexpr int digits = ((sizeof(unsigned char) * (8)) - (((unsigned char)(-1)) < 0)); 
# 605
static constexpr int digits10 = ((((sizeof(unsigned char) * (8)) - (((unsigned char)(-1)) < 0)) * (643L)) / (2136)); 
# 608
static constexpr int max_digits10 = 0; 
# 610
static constexpr bool is_signed = false; 
# 611
static constexpr bool is_integer = true; 
# 612
static constexpr bool is_exact = true; 
# 613
static constexpr int radix = 2; 
# 616
static constexpr unsigned char epsilon() noexcept { return 0; } 
# 619
static constexpr unsigned char round_error() noexcept { return 0; } 
# 621
static constexpr int min_exponent = 0; 
# 622
static constexpr int min_exponent10 = 0; 
# 623
static constexpr int max_exponent = 0; 
# 624
static constexpr int max_exponent10 = 0; 
# 626
static constexpr bool has_infinity = false; 
# 627
static constexpr bool has_quiet_NaN = false; 
# 628
static constexpr bool has_signaling_NaN = false; 
# 629
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 631
static constexpr bool has_denorm_loss = false; 
# 634
static constexpr unsigned char infinity() noexcept 
# 635
{ return static_cast< unsigned char>(0); } 
# 638
static constexpr unsigned char quiet_NaN() noexcept 
# 639
{ return static_cast< unsigned char>(0); } 
# 642
static constexpr unsigned char signaling_NaN() noexcept 
# 643
{ return static_cast< unsigned char>(0); } 
# 646
static constexpr unsigned char denorm_min() noexcept 
# 647
{ return static_cast< unsigned char>(0); } 
# 649
static constexpr bool is_iec559 = false; 
# 650
static constexpr bool is_bounded = true; 
# 651
static constexpr bool is_modulo = true; 
# 653
static constexpr bool traps = true; 
# 654
static constexpr bool tinyness_before = false; 
# 655
static constexpr float_round_style round_style = round_toward_zero; 
# 657
}; 
# 661
template<> struct numeric_limits< wchar_t>  { 
# 663
static constexpr bool is_specialized = true; 
# 666
static constexpr wchar_t min() noexcept { return (((wchar_t)(-1)) < 0) ? (-((((wchar_t)(-1)) < 0) ? (((((wchar_t)1) << (((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((wchar_t)0)))) - 1 : ((wchar_t)0); } 
# 669
static constexpr wchar_t max() noexcept { return (((wchar_t)(-1)) < 0) ? (((((wchar_t)1) << (((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((wchar_t)0)); } 
# 673
static constexpr wchar_t lowest() noexcept { return min(); } 
# 676
static constexpr int digits = ((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)); 
# 677
static constexpr int digits10 = ((((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)) * (643L)) / (2136)); 
# 680
static constexpr int max_digits10 = 0; 
# 682
static constexpr bool is_signed = (((wchar_t)(-1)) < 0); 
# 683
static constexpr bool is_integer = true; 
# 684
static constexpr bool is_exact = true; 
# 685
static constexpr int radix = 2; 
# 688
static constexpr wchar_t epsilon() noexcept { return 0; } 
# 691
static constexpr wchar_t round_error() noexcept { return 0; } 
# 693
static constexpr int min_exponent = 0; 
# 694
static constexpr int min_exponent10 = 0; 
# 695
static constexpr int max_exponent = 0; 
# 696
static constexpr int max_exponent10 = 0; 
# 698
static constexpr bool has_infinity = false; 
# 699
static constexpr bool has_quiet_NaN = false; 
# 700
static constexpr bool has_signaling_NaN = false; 
# 701
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 703
static constexpr bool has_denorm_loss = false; 
# 706
static constexpr wchar_t infinity() noexcept { return ((wchar_t)0); } 
# 709
static constexpr wchar_t quiet_NaN() noexcept { return ((wchar_t)0); } 
# 712
static constexpr wchar_t signaling_NaN() noexcept { return ((wchar_t)0); } 
# 715
static constexpr wchar_t denorm_min() noexcept { return ((wchar_t)0); } 
# 717
static constexpr bool is_iec559 = false; 
# 718
static constexpr bool is_bounded = true; 
# 719
static constexpr bool is_modulo = (!is_signed); 
# 721
static constexpr bool traps = true; 
# 722
static constexpr bool tinyness_before = false; 
# 723
static constexpr float_round_style round_style = round_toward_zero; 
# 725
}; 
# 730
template<> struct numeric_limits< char16_t>  { 
# 732
static constexpr bool is_specialized = true; 
# 735
static constexpr char16_t min() noexcept { return (((char16_t)(-1)) < 0) ? (-((((char16_t)(-1)) < 0) ? (((((char16_t)1) << (((sizeof(char16_t) * (8)) - (((char16_t)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((char16_t)0)))) - 1 : ((char16_t)0); } 
# 738
static constexpr char16_t max() noexcept { return (((char16_t)(-1)) < 0) ? (((((char16_t)1) << (((sizeof(char16_t) * (8)) - (((char16_t)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((char16_t)0)); } 
# 741
static constexpr char16_t lowest() noexcept { return min(); } 
# 743
static constexpr int digits = ((sizeof(char16_t) * (8)) - (((char16_t)(-1)) < 0)); 
# 744
static constexpr int digits10 = ((((sizeof(char16_t) * (8)) - (((char16_t)(-1)) < 0)) * (643L)) / (2136)); 
# 745
static constexpr int max_digits10 = 0; 
# 746
static constexpr bool is_signed = (((char16_t)(-1)) < 0); 
# 747
static constexpr bool is_integer = true; 
# 748
static constexpr bool is_exact = true; 
# 749
static constexpr int radix = 2; 
# 752
static constexpr char16_t epsilon() noexcept { return 0; } 
# 755
static constexpr char16_t round_error() noexcept { return 0; } 
# 757
static constexpr int min_exponent = 0; 
# 758
static constexpr int min_exponent10 = 0; 
# 759
static constexpr int max_exponent = 0; 
# 760
static constexpr int max_exponent10 = 0; 
# 762
static constexpr bool has_infinity = false; 
# 763
static constexpr bool has_quiet_NaN = false; 
# 764
static constexpr bool has_signaling_NaN = false; 
# 765
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 766
static constexpr bool has_denorm_loss = false; 
# 769
static constexpr char16_t infinity() noexcept { return ((char16_t)0); } 
# 772
static constexpr char16_t quiet_NaN() noexcept { return ((char16_t)0); } 
# 775
static constexpr char16_t signaling_NaN() noexcept { return ((char16_t)0); } 
# 778
static constexpr char16_t denorm_min() noexcept { return ((char16_t)0); } 
# 780
static constexpr bool is_iec559 = false; 
# 781
static constexpr bool is_bounded = true; 
# 782
static constexpr bool is_modulo = (!is_signed); 
# 784
static constexpr bool traps = true; 
# 785
static constexpr bool tinyness_before = false; 
# 786
static constexpr float_round_style round_style = round_toward_zero; 
# 787
}; 
# 791
template<> struct numeric_limits< char32_t>  { 
# 793
static constexpr bool is_specialized = true; 
# 796
static constexpr char32_t min() noexcept { return (((char32_t)(-1)) < (0)) ? (-((((char32_t)(-1)) < (0)) ? (((((char32_t)1) << (((sizeof(char32_t) * (8)) - (((char32_t)(-1)) < (0))) - (1))) - (1)) << 1) + (1) : (~((char32_t)0)))) - (1) : ((char32_t)0); } 
# 799
static constexpr char32_t max() noexcept { return (((char32_t)(-1)) < (0)) ? (((((char32_t)1) << (((sizeof(char32_t) * (8)) - (((char32_t)(-1)) < (0))) - (1))) - (1)) << 1) + (1) : (~((char32_t)0)); } 
# 802
static constexpr char32_t lowest() noexcept { return min(); } 
# 804
static constexpr int digits = ((sizeof(char32_t) * (8)) - (((char32_t)(-1)) < (0))); 
# 805
static constexpr int digits10 = ((((sizeof(char32_t) * (8)) - (((char32_t)(-1)) < (0))) * (643L)) / (2136)); 
# 806
static constexpr int max_digits10 = 0; 
# 807
static constexpr bool is_signed = (((char32_t)(-1)) < (0)); 
# 808
static constexpr bool is_integer = true; 
# 809
static constexpr bool is_exact = true; 
# 810
static constexpr int radix = 2; 
# 813
static constexpr char32_t epsilon() noexcept { return 0; } 
# 816
static constexpr char32_t round_error() noexcept { return 0; } 
# 818
static constexpr int min_exponent = 0; 
# 819
static constexpr int min_exponent10 = 0; 
# 820
static constexpr int max_exponent = 0; 
# 821
static constexpr int max_exponent10 = 0; 
# 823
static constexpr bool has_infinity = false; 
# 824
static constexpr bool has_quiet_NaN = false; 
# 825
static constexpr bool has_signaling_NaN = false; 
# 826
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 827
static constexpr bool has_denorm_loss = false; 
# 830
static constexpr char32_t infinity() noexcept { return ((char32_t)0); } 
# 833
static constexpr char32_t quiet_NaN() noexcept { return ((char32_t)0); } 
# 836
static constexpr char32_t signaling_NaN() noexcept { return ((char32_t)0); } 
# 839
static constexpr char32_t denorm_min() noexcept { return ((char32_t)0); } 
# 841
static constexpr bool is_iec559 = false; 
# 842
static constexpr bool is_bounded = true; 
# 843
static constexpr bool is_modulo = (!is_signed); 
# 845
static constexpr bool traps = true; 
# 846
static constexpr bool tinyness_before = false; 
# 847
static constexpr float_round_style round_style = round_toward_zero; 
# 848
}; 
# 853
template<> struct numeric_limits< short>  { 
# 855
static constexpr bool is_specialized = true; 
# 858
static constexpr short min() noexcept { return (-32767) - 1; } 
# 861
static constexpr short max() noexcept { return 32767; } 
# 865
static constexpr short lowest() noexcept { return min(); } 
# 868
static constexpr int digits = ((sizeof(short) * (8)) - (((short)(-1)) < 0)); 
# 869
static constexpr int digits10 = ((((sizeof(short) * (8)) - (((short)(-1)) < 0)) * (643L)) / (2136)); 
# 871
static constexpr int max_digits10 = 0; 
# 873
static constexpr bool is_signed = true; 
# 874
static constexpr bool is_integer = true; 
# 875
static constexpr bool is_exact = true; 
# 876
static constexpr int radix = 2; 
# 879
static constexpr short epsilon() noexcept { return 0; } 
# 882
static constexpr short round_error() noexcept { return 0; } 
# 884
static constexpr int min_exponent = 0; 
# 885
static constexpr int min_exponent10 = 0; 
# 886
static constexpr int max_exponent = 0; 
# 887
static constexpr int max_exponent10 = 0; 
# 889
static constexpr bool has_infinity = false; 
# 890
static constexpr bool has_quiet_NaN = false; 
# 891
static constexpr bool has_signaling_NaN = false; 
# 892
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 894
static constexpr bool has_denorm_loss = false; 
# 897
static constexpr short infinity() noexcept { return ((short)0); } 
# 900
static constexpr short quiet_NaN() noexcept { return ((short)0); } 
# 903
static constexpr short signaling_NaN() noexcept { return ((short)0); } 
# 906
static constexpr short denorm_min() noexcept { return ((short)0); } 
# 908
static constexpr bool is_iec559 = false; 
# 909
static constexpr bool is_bounded = true; 
# 910
static constexpr bool is_modulo = false; 
# 912
static constexpr bool traps = true; 
# 913
static constexpr bool tinyness_before = false; 
# 914
static constexpr float_round_style round_style = round_toward_zero; 
# 916
}; 
# 920
template<> struct numeric_limits< unsigned short>  { 
# 922
static constexpr bool is_specialized = true; 
# 925
static constexpr unsigned short min() noexcept { return 0; } 
# 928
static constexpr unsigned short max() noexcept { return ((32767) * 2U) + (1); } 
# 932
static constexpr unsigned short lowest() noexcept { return min(); } 
# 935
static constexpr int digits = ((sizeof(unsigned short) * (8)) - (((unsigned short)(-1)) < 0)); 
# 937
static constexpr int digits10 = ((((sizeof(unsigned short) * (8)) - (((unsigned short)(-1)) < 0)) * (643L)) / (2136)); 
# 940
static constexpr int max_digits10 = 0; 
# 942
static constexpr bool is_signed = false; 
# 943
static constexpr bool is_integer = true; 
# 944
static constexpr bool is_exact = true; 
# 945
static constexpr int radix = 2; 
# 948
static constexpr unsigned short epsilon() noexcept { return 0; } 
# 951
static constexpr unsigned short round_error() noexcept { return 0; } 
# 953
static constexpr int min_exponent = 0; 
# 954
static constexpr int min_exponent10 = 0; 
# 955
static constexpr int max_exponent = 0; 
# 956
static constexpr int max_exponent10 = 0; 
# 958
static constexpr bool has_infinity = false; 
# 959
static constexpr bool has_quiet_NaN = false; 
# 960
static constexpr bool has_signaling_NaN = false; 
# 961
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 963
static constexpr bool has_denorm_loss = false; 
# 966
static constexpr unsigned short infinity() noexcept 
# 967
{ return static_cast< unsigned short>(0); } 
# 970
static constexpr unsigned short quiet_NaN() noexcept 
# 971
{ return static_cast< unsigned short>(0); } 
# 974
static constexpr unsigned short signaling_NaN() noexcept 
# 975
{ return static_cast< unsigned short>(0); } 
# 978
static constexpr unsigned short denorm_min() noexcept 
# 979
{ return static_cast< unsigned short>(0); } 
# 981
static constexpr bool is_iec559 = false; 
# 982
static constexpr bool is_bounded = true; 
# 983
static constexpr bool is_modulo = true; 
# 985
static constexpr bool traps = true; 
# 986
static constexpr bool tinyness_before = false; 
# 987
static constexpr float_round_style round_style = round_toward_zero; 
# 989
}; 
# 993
template<> struct numeric_limits< int>  { 
# 995
static constexpr bool is_specialized = true; 
# 998
static constexpr int min() noexcept { return (-2147483647) - 1; } 
# 1001
static constexpr int max() noexcept { return 2147483647; } 
# 1005
static constexpr int lowest() noexcept { return min(); } 
# 1008
static constexpr int digits = ((sizeof(int) * (8)) - (((int)(-1)) < 0)); 
# 1009
static constexpr int digits10 = ((((sizeof(int) * (8)) - (((int)(-1)) < 0)) * (643L)) / (2136)); 
# 1011
static constexpr int max_digits10 = 0; 
# 1013
static constexpr bool is_signed = true; 
# 1014
static constexpr bool is_integer = true; 
# 1015
static constexpr bool is_exact = true; 
# 1016
static constexpr int radix = 2; 
# 1019
static constexpr int epsilon() noexcept { return 0; } 
# 1022
static constexpr int round_error() noexcept { return 0; } 
# 1024
static constexpr int min_exponent = 0; 
# 1025
static constexpr int min_exponent10 = 0; 
# 1026
static constexpr int max_exponent = 0; 
# 1027
static constexpr int max_exponent10 = 0; 
# 1029
static constexpr bool has_infinity = false; 
# 1030
static constexpr bool has_quiet_NaN = false; 
# 1031
static constexpr bool has_signaling_NaN = false; 
# 1032
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1034
static constexpr bool has_denorm_loss = false; 
# 1037
static constexpr int infinity() noexcept { return static_cast< int>(0); } 
# 1040
static constexpr int quiet_NaN() noexcept { return static_cast< int>(0); } 
# 1043
static constexpr int signaling_NaN() noexcept { return static_cast< int>(0); } 
# 1046
static constexpr int denorm_min() noexcept { return static_cast< int>(0); } 
# 1048
static constexpr bool is_iec559 = false; 
# 1049
static constexpr bool is_bounded = true; 
# 1050
static constexpr bool is_modulo = false; 
# 1052
static constexpr bool traps = true; 
# 1053
static constexpr bool tinyness_before = false; 
# 1054
static constexpr float_round_style round_style = round_toward_zero; 
# 1056
}; 
# 1060
template<> struct numeric_limits< unsigned>  { 
# 1062
static constexpr bool is_specialized = true; 
# 1065
static constexpr unsigned min() noexcept { return 0; } 
# 1068
static constexpr unsigned max() noexcept { return ((2147483647) * 2U) + (1); } 
# 1072
static constexpr unsigned lowest() noexcept { return min(); } 
# 1075
static constexpr int digits = ((sizeof(unsigned) * (8)) - (((unsigned)(-1)) < (0))); 
# 1077
static constexpr int digits10 = ((((sizeof(unsigned) * (8)) - (((unsigned)(-1)) < (0))) * (643L)) / (2136)); 
# 1080
static constexpr int max_digits10 = 0; 
# 1082
static constexpr bool is_signed = false; 
# 1083
static constexpr bool is_integer = true; 
# 1084
static constexpr bool is_exact = true; 
# 1085
static constexpr int radix = 2; 
# 1088
static constexpr unsigned epsilon() noexcept { return 0; } 
# 1091
static constexpr unsigned round_error() noexcept { return 0; } 
# 1093
static constexpr int min_exponent = 0; 
# 1094
static constexpr int min_exponent10 = 0; 
# 1095
static constexpr int max_exponent = 0; 
# 1096
static constexpr int max_exponent10 = 0; 
# 1098
static constexpr bool has_infinity = false; 
# 1099
static constexpr bool has_quiet_NaN = false; 
# 1100
static constexpr bool has_signaling_NaN = false; 
# 1101
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1103
static constexpr bool has_denorm_loss = false; 
# 1106
static constexpr unsigned infinity() noexcept { return static_cast< unsigned>(0); } 
# 1109
static constexpr unsigned quiet_NaN() noexcept 
# 1110
{ return static_cast< unsigned>(0); } 
# 1113
static constexpr unsigned signaling_NaN() noexcept 
# 1114
{ return static_cast< unsigned>(0); } 
# 1117
static constexpr unsigned denorm_min() noexcept 
# 1118
{ return static_cast< unsigned>(0); } 
# 1120
static constexpr bool is_iec559 = false; 
# 1121
static constexpr bool is_bounded = true; 
# 1122
static constexpr bool is_modulo = true; 
# 1124
static constexpr bool traps = true; 
# 1125
static constexpr bool tinyness_before = false; 
# 1126
static constexpr float_round_style round_style = round_toward_zero; 
# 1128
}; 
# 1132
template<> struct numeric_limits< long>  { 
# 1134
static constexpr bool is_specialized = true; 
# 1137
static constexpr long min() noexcept { return (-9223372036854775807L) - (1); } 
# 1140
static constexpr long max() noexcept { return 9223372036854775807L; } 
# 1144
static constexpr long lowest() noexcept { return min(); } 
# 1147
static constexpr int digits = ((sizeof(long) * (8)) - (((long)(-1)) < (0))); 
# 1148
static constexpr int digits10 = ((((sizeof(long) * (8)) - (((long)(-1)) < (0))) * (643L)) / (2136)); 
# 1150
static constexpr int max_digits10 = 0; 
# 1152
static constexpr bool is_signed = true; 
# 1153
static constexpr bool is_integer = true; 
# 1154
static constexpr bool is_exact = true; 
# 1155
static constexpr int radix = 2; 
# 1158
static constexpr long epsilon() noexcept { return 0; } 
# 1161
static constexpr long round_error() noexcept { return 0; } 
# 1163
static constexpr int min_exponent = 0; 
# 1164
static constexpr int min_exponent10 = 0; 
# 1165
static constexpr int max_exponent = 0; 
# 1166
static constexpr int max_exponent10 = 0; 
# 1168
static constexpr bool has_infinity = false; 
# 1169
static constexpr bool has_quiet_NaN = false; 
# 1170
static constexpr bool has_signaling_NaN = false; 
# 1171
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1173
static constexpr bool has_denorm_loss = false; 
# 1176
static constexpr long infinity() noexcept { return static_cast< long>(0); } 
# 1179
static constexpr long quiet_NaN() noexcept { return static_cast< long>(0); } 
# 1182
static constexpr long signaling_NaN() noexcept { return static_cast< long>(0); } 
# 1185
static constexpr long denorm_min() noexcept { return static_cast< long>(0); } 
# 1187
static constexpr bool is_iec559 = false; 
# 1188
static constexpr bool is_bounded = true; 
# 1189
static constexpr bool is_modulo = false; 
# 1191
static constexpr bool traps = true; 
# 1192
static constexpr bool tinyness_before = false; 
# 1193
static constexpr float_round_style round_style = round_toward_zero; 
# 1195
}; 
# 1199
template<> struct numeric_limits< unsigned long>  { 
# 1201
static constexpr bool is_specialized = true; 
# 1204
static constexpr unsigned long min() noexcept { return 0; } 
# 1207
static constexpr unsigned long max() noexcept { return ((9223372036854775807L) * 2UL) + (1); } 
# 1211
static constexpr unsigned long lowest() noexcept { return min(); } 
# 1214
static constexpr int digits = ((sizeof(unsigned long) * (8)) - (((unsigned long)(-1)) < (0))); 
# 1216
static constexpr int digits10 = ((((sizeof(unsigned long) * (8)) - (((unsigned long)(-1)) < (0))) * (643L)) / (2136)); 
# 1219
static constexpr int max_digits10 = 0; 
# 1221
static constexpr bool is_signed = false; 
# 1222
static constexpr bool is_integer = true; 
# 1223
static constexpr bool is_exact = true; 
# 1224
static constexpr int radix = 2; 
# 1227
static constexpr unsigned long epsilon() noexcept { return 0; } 
# 1230
static constexpr unsigned long round_error() noexcept { return 0; } 
# 1232
static constexpr int min_exponent = 0; 
# 1233
static constexpr int min_exponent10 = 0; 
# 1234
static constexpr int max_exponent = 0; 
# 1235
static constexpr int max_exponent10 = 0; 
# 1237
static constexpr bool has_infinity = false; 
# 1238
static constexpr bool has_quiet_NaN = false; 
# 1239
static constexpr bool has_signaling_NaN = false; 
# 1240
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1242
static constexpr bool has_denorm_loss = false; 
# 1245
static constexpr unsigned long infinity() noexcept 
# 1246
{ return static_cast< unsigned long>(0); } 
# 1249
static constexpr unsigned long quiet_NaN() noexcept 
# 1250
{ return static_cast< unsigned long>(0); } 
# 1253
static constexpr unsigned long signaling_NaN() noexcept 
# 1254
{ return static_cast< unsigned long>(0); } 
# 1257
static constexpr unsigned long denorm_min() noexcept 
# 1258
{ return static_cast< unsigned long>(0); } 
# 1260
static constexpr bool is_iec559 = false; 
# 1261
static constexpr bool is_bounded = true; 
# 1262
static constexpr bool is_modulo = true; 
# 1264
static constexpr bool traps = true; 
# 1265
static constexpr bool tinyness_before = false; 
# 1266
static constexpr float_round_style round_style = round_toward_zero; 
# 1268
}; 
# 1272
template<> struct numeric_limits< long long>  { 
# 1274
static constexpr bool is_specialized = true; 
# 1277
static constexpr long long min() noexcept { return (-9223372036854775807LL) - (1); } 
# 1280
static constexpr long long max() noexcept { return 9223372036854775807LL; } 
# 1284
static constexpr long long lowest() noexcept { return min(); } 
# 1287
static constexpr int digits = ((sizeof(long long) * (8)) - (((long long)(-1)) < (0))); 
# 1289
static constexpr int digits10 = ((((sizeof(long long) * (8)) - (((long long)(-1)) < (0))) * (643L)) / (2136)); 
# 1292
static constexpr int max_digits10 = 0; 
# 1294
static constexpr bool is_signed = true; 
# 1295
static constexpr bool is_integer = true; 
# 1296
static constexpr bool is_exact = true; 
# 1297
static constexpr int radix = 2; 
# 1300
static constexpr long long epsilon() noexcept { return 0; } 
# 1303
static constexpr long long round_error() noexcept { return 0; } 
# 1305
static constexpr int min_exponent = 0; 
# 1306
static constexpr int min_exponent10 = 0; 
# 1307
static constexpr int max_exponent = 0; 
# 1308
static constexpr int max_exponent10 = 0; 
# 1310
static constexpr bool has_infinity = false; 
# 1311
static constexpr bool has_quiet_NaN = false; 
# 1312
static constexpr bool has_signaling_NaN = false; 
# 1313
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1315
static constexpr bool has_denorm_loss = false; 
# 1318
static constexpr long long infinity() noexcept { return static_cast< long long>(0); } 
# 1321
static constexpr long long quiet_NaN() noexcept { return static_cast< long long>(0); } 
# 1324
static constexpr long long signaling_NaN() noexcept 
# 1325
{ return static_cast< long long>(0); } 
# 1328
static constexpr long long denorm_min() noexcept { return static_cast< long long>(0); } 
# 1330
static constexpr bool is_iec559 = false; 
# 1331
static constexpr bool is_bounded = true; 
# 1332
static constexpr bool is_modulo = false; 
# 1334
static constexpr bool traps = true; 
# 1335
static constexpr bool tinyness_before = false; 
# 1336
static constexpr float_round_style round_style = round_toward_zero; 
# 1338
}; 
# 1342
template<> struct numeric_limits< unsigned long long>  { 
# 1344
static constexpr bool is_specialized = true; 
# 1347
static constexpr unsigned long long min() noexcept { return 0; } 
# 1350
static constexpr unsigned long long max() noexcept { return ((9223372036854775807LL) * 2ULL) + (1); } 
# 1354
static constexpr unsigned long long lowest() noexcept { return min(); } 
# 1357
static constexpr int digits = ((sizeof(unsigned long long) * (8)) - (((unsigned long long)(-1)) < (0))); 
# 1359
static constexpr int digits10 = ((((sizeof(unsigned long long) * (8)) - (((unsigned long long)(-1)) < (0))) * (643L)) / (2136)); 
# 1362
static constexpr int max_digits10 = 0; 
# 1364
static constexpr bool is_signed = false; 
# 1365
static constexpr bool is_integer = true; 
# 1366
static constexpr bool is_exact = true; 
# 1367
static constexpr int radix = 2; 
# 1370
static constexpr unsigned long long epsilon() noexcept { return 0; } 
# 1373
static constexpr unsigned long long round_error() noexcept { return 0; } 
# 1375
static constexpr int min_exponent = 0; 
# 1376
static constexpr int min_exponent10 = 0; 
# 1377
static constexpr int max_exponent = 0; 
# 1378
static constexpr int max_exponent10 = 0; 
# 1380
static constexpr bool has_infinity = false; 
# 1381
static constexpr bool has_quiet_NaN = false; 
# 1382
static constexpr bool has_signaling_NaN = false; 
# 1383
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1385
static constexpr bool has_denorm_loss = false; 
# 1388
static constexpr unsigned long long infinity() noexcept 
# 1389
{ return static_cast< unsigned long long>(0); } 
# 1392
static constexpr unsigned long long quiet_NaN() noexcept 
# 1393
{ return static_cast< unsigned long long>(0); } 
# 1396
static constexpr unsigned long long signaling_NaN() noexcept 
# 1397
{ return static_cast< unsigned long long>(0); } 
# 1400
static constexpr unsigned long long denorm_min() noexcept 
# 1401
{ return static_cast< unsigned long long>(0); } 
# 1403
static constexpr bool is_iec559 = false; 
# 1404
static constexpr bool is_bounded = true; 
# 1405
static constexpr bool is_modulo = true; 
# 1407
static constexpr bool traps = true; 
# 1408
static constexpr bool tinyness_before = false; 
# 1409
static constexpr float_round_style round_style = round_toward_zero; 
# 1411
}; 
# 1593 "/usr/include/c++/5/limits" 3
template<> struct numeric_limits< float>  { 
# 1595
static constexpr bool is_specialized = true; 
# 1598
static constexpr float min() noexcept { return (1.175494351e-38F); } 
# 1601
static constexpr float max() noexcept { return (3.402823466e+38F); } 
# 1605
static constexpr float lowest() noexcept { return -(3.402823466e+38F); } 
# 1608
static constexpr int digits = 24; 
# 1609
static constexpr int digits10 = 6; 
# 1611
static constexpr int max_digits10 = ((2) + (((24) * 643L) / (2136))); 
# 1614
static constexpr bool is_signed = true; 
# 1615
static constexpr bool is_integer = false; 
# 1616
static constexpr bool is_exact = false; 
# 1617
static constexpr int radix = 2; 
# 1620
static constexpr float epsilon() noexcept { return (1.192092896e-07F); } 
# 1623
static constexpr float round_error() noexcept { return (0.5F); } 
# 1625
static constexpr int min_exponent = (-125); 
# 1626
static constexpr int min_exponent10 = (-37); 
# 1627
static constexpr int max_exponent = 128; 
# 1628
static constexpr int max_exponent10 = 38; 
# 1630
static constexpr bool has_infinity = (1); 
# 1631
static constexpr bool has_quiet_NaN = (1); 
# 1632
static constexpr bool has_signaling_NaN = has_quiet_NaN; 
# 1633
static constexpr float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 
# 1635
static constexpr bool has_denorm_loss = false; 
# 1639
static constexpr float infinity() noexcept { return __builtin_huge_valf(); } 
# 1642
static constexpr float quiet_NaN() noexcept { return __builtin_nanf(""); } 
# 1645
static constexpr float signaling_NaN() noexcept { return __builtin_nansf(""); } 
# 1648
static constexpr float denorm_min() noexcept { return (1.401298464e-45F); } 
# 1650
static constexpr bool is_iec559 = (has_infinity && has_quiet_NaN && (has_denorm == (denorm_present))); 
# 1652
static constexpr bool is_bounded = true; 
# 1653
static constexpr bool is_modulo = false; 
# 1655
static constexpr bool traps = false; 
# 1656
static constexpr bool tinyness_before = false; 
# 1658
static constexpr float_round_style round_style = round_to_nearest; 
# 1660
}; 
# 1668
template<> struct numeric_limits< double>  { 
# 1670
static constexpr bool is_specialized = true; 
# 1673
static constexpr double min() noexcept { return (double)(2.225073858507201383e-308L); } 
# 1676
static constexpr double max() noexcept { return (double)(1.797693134862315708e+308L); } 
# 1680
static constexpr double lowest() noexcept { return -((double)(1.797693134862315708e+308L)); } 
# 1683
static constexpr int digits = 53; 
# 1684
static constexpr int digits10 = 15; 
# 1686
static constexpr int max_digits10 = ((2) + (((53) * 643L) / (2136))); 
# 1689
static constexpr bool is_signed = true; 
# 1690
static constexpr bool is_integer = false; 
# 1691
static constexpr bool is_exact = false; 
# 1692
static constexpr int radix = 2; 
# 1695
static constexpr double epsilon() noexcept { return (double)(2.220446049250313081e-16L); } 
# 1698
static constexpr double round_error() noexcept { return (0.5); } 
# 1700
static constexpr int min_exponent = (-1021); 
# 1701
static constexpr int min_exponent10 = (-307); 
# 1702
static constexpr int max_exponent = 1024; 
# 1703
static constexpr int max_exponent10 = 308; 
# 1705
static constexpr bool has_infinity = (1); 
# 1706
static constexpr bool has_quiet_NaN = (1); 
# 1707
static constexpr bool has_signaling_NaN = has_quiet_NaN; 
# 1708
static constexpr float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 
# 1710
static constexpr bool has_denorm_loss = false; 
# 1714
static constexpr double infinity() noexcept { return __builtin_huge_val(); } 
# 1717
static constexpr double quiet_NaN() noexcept { return __builtin_nan(""); } 
# 1720
static constexpr double signaling_NaN() noexcept { return __builtin_nans(""); } 
# 1723
static constexpr double denorm_min() noexcept { return (double)(4.940656458412465442e-324L); } 
# 1725
static constexpr bool is_iec559 = (has_infinity && has_quiet_NaN && (has_denorm == (denorm_present))); 
# 1727
static constexpr bool is_bounded = true; 
# 1728
static constexpr bool is_modulo = false; 
# 1730
static constexpr bool traps = false; 
# 1731
static constexpr bool tinyness_before = false; 
# 1733
static constexpr float_round_style round_style = round_to_nearest; 
# 1735
}; 
# 1743
template<> struct numeric_limits< long double>  { 
# 1745
static constexpr bool is_specialized = true; 
# 1748
static constexpr long double min() noexcept { return (0.0L); } 
# 1751
static constexpr long double max() noexcept { return ((__builtin_huge_vall())); } 
# 1755
static constexpr long double lowest() noexcept { return -((__builtin_huge_vall())); } 
# 1758
static constexpr int digits = 113; 
# 1759
static constexpr int digits10 = 33; 
# 1761
static constexpr int max_digits10 = ((2) + (((113) * 643L) / (2136))); 
# 1764
static constexpr bool is_signed = true; 
# 1765
static constexpr bool is_integer = false; 
# 1766
static constexpr bool is_exact = false; 
# 1767
static constexpr int radix = 2; 
# 1770
static constexpr long double epsilon() noexcept { return (1.925929944387235853e-34L); } 
# 1773
static constexpr long double round_error() noexcept { return (0.5L); } 
# 1775
static constexpr int min_exponent = (-16381); 
# 1776
static constexpr int min_exponent10 = (-4931); 
# 1777
static constexpr int max_exponent = 16384; 
# 1778
static constexpr int max_exponent10 = 4932; 
# 1780
static constexpr bool has_infinity = (1); 
# 1781
static constexpr bool has_quiet_NaN = (1); 
# 1782
static constexpr bool has_signaling_NaN = has_quiet_NaN; 
# 1783
static constexpr float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 
# 1785
static constexpr bool has_denorm_loss = false; 
# 1789
static constexpr long double infinity() noexcept { return __builtin_huge_vall(); } 
# 1792
static constexpr long double quiet_NaN() noexcept { return __builtin_nanl(""); } 
# 1795
static constexpr long double signaling_NaN() noexcept { return __builtin_nansl(""); } 
# 1798
static constexpr long double denorm_min() noexcept { return (0.0L); } 
# 1800
static constexpr bool is_iec559 = (has_infinity && has_quiet_NaN && (has_denorm == (denorm_present))); 
# 1802
static constexpr bool is_bounded = true; 
# 1803
static constexpr bool is_modulo = false; 
# 1805
static constexpr bool traps = false; 
# 1806
static constexpr bool tinyness_before = false; 
# 1808
static constexpr float_round_style round_style = round_to_nearest; 
# 1810
}; 
# 1817
}
# 58 "/usr/include/c++/5/ctime" 3
namespace std { 
# 60
using ::clock_t;
# 61
using ::time_t;
# 62
using ::tm;
# 64
using ::clock;
# 65
using ::difftime;
# 66
using ::mktime;
# 67
using ::time;
# 68
using ::asctime;
# 69
using ::ctime;
# 70
using ::gmtime;
# 71
using ::localtime;
# 72
using ::strftime;
# 73
}
# 46 "/usr/include/c++/5/chrono" 3
namespace std __attribute((__visibility__("default"))) { 
# 59 "/usr/include/c++/5/chrono" 3
namespace chrono { 
# 63
template< class _Rep, class _Period = ratio< 1> > struct duration; 
# 66
template< class _Clock, class _Dur = typename _Clock::duration> struct time_point; 
# 70
}
# 76
template< class _CT, class _Period1, class _Period2> 
# 77
struct __duration_common_type_wrapper { 
# 80
private: typedef __static_gcd< _Period1::num, _Period2::num>  __gcd_num; 
# 81
typedef __static_gcd< _Period1::den, _Period2::den>  __gcd_den; 
# 82
typedef typename _CT::type __cr; 
# 84
typedef ratio< __static_gcd< _Period1::num, _Period2::num> ::value, (_Period1::den / __static_gcd< _Period1::den, _Period2::den> ::value) * _Period2::den>  __r; 
# 86
public: typedef __success_type< chrono::duration< typename _CT::type, ratio< __static_gcd< _Period1::num, _Period2::num> ::value, (_Period1::den / __static_gcd< _Period1::den, _Period2::den> ::value) * _Period2::den> > >  type; 
# 87
}; 
# 89
template< class _Period1, class _Period2> 
# 90
struct __duration_common_type_wrapper< __failure_type, _Period1, _Period2>  { 
# 91
typedef __failure_type type; }; 
# 93
template< class _Rep1, class _Period1, class _Rep2, class _Period2> 
# 94
struct common_type< chrono::duration< _Rep1, _Period1> , chrono::duration< _Rep2, _Period2> >  : public __duration_common_type_wrapper< typename __member_type_wrapper< common_type< _Rep1, _Rep2> > ::type, _Period1, _Period2> ::type { 
# 98
}; 
# 102
template< class _CT, class _Clock> 
# 103
struct __timepoint_common_type_wrapper { 
# 106
typedef __success_type< chrono::time_point< _Clock, typename _CT::type> >  type; 
# 107
}; 
# 109
template< class _Clock> 
# 110
struct __timepoint_common_type_wrapper< __failure_type, _Clock>  { 
# 111
typedef __failure_type type; }; 
# 113
template< class _Clock, class _Duration1, class _Duration2> 
# 114
struct common_type< chrono::time_point< _Clock, _Duration1> , chrono::time_point< _Clock, _Duration2> >  : public __timepoint_common_type_wrapper< typename __member_type_wrapper< common_type< _Duration1, _Duration2> > ::type, _Clock> ::type { 
# 118
}; 
# 122
namespace chrono { 
# 127
template< class _ToDur, class _CF, class _CR, bool 
# 128
_NumIsOne = false, bool _DenIsOne = false> 
# 129
struct __duration_cast_impl { 
# 131
template< class _Rep, class _Period> static constexpr _ToDur 
# 133
__cast(const duration< _Rep, _Period>  &__d) 
# 134
{ 
# 135
typedef typename _ToDur::rep __to_rep; 
# 136
return (_ToDur)(static_cast< __to_rep>(((static_cast< _CR>((__d.count()))) * (static_cast< _CR>(_CF::num))) / (static_cast< _CR>(_CF::den)))); 
# 139
} 
# 140
}; 
# 142
template< class _ToDur, class _CF, class _CR> 
# 143
struct __duration_cast_impl< _ToDur, _CF, _CR, true, true>  { 
# 145
template< class _Rep, class _Period> static constexpr _ToDur 
# 147
__cast(const duration< _Rep, _Period>  &__d) 
# 148
{ 
# 149
typedef typename _ToDur::rep __to_rep; 
# 150
return (_ToDur)(static_cast< __to_rep>((__d.count()))); 
# 151
} 
# 152
}; 
# 154
template< class _ToDur, class _CF, class _CR> 
# 155
struct __duration_cast_impl< _ToDur, _CF, _CR, true, false>  { 
# 157
template< class _Rep, class _Period> static constexpr _ToDur 
# 159
__cast(const duration< _Rep, _Period>  &__d) 
# 160
{ 
# 161
typedef typename _ToDur::rep __to_rep; 
# 162
return (_ToDur)(static_cast< __to_rep>((static_cast< _CR>((__d.count()))) / (static_cast< _CR>(_CF::den)))); 
# 164
} 
# 165
}; 
# 167
template< class _ToDur, class _CF, class _CR> 
# 168
struct __duration_cast_impl< _ToDur, _CF, _CR, false, true>  { 
# 170
template< class _Rep, class _Period> static constexpr _ToDur 
# 172
__cast(const duration< _Rep, _Period>  &__d) 
# 173
{ 
# 174
typedef typename _ToDur::rep __to_rep; 
# 175
return (_ToDur)(static_cast< __to_rep>((static_cast< _CR>((__d.count()))) * (static_cast< _CR>(_CF::num)))); 
# 177
} 
# 178
}; 
# 180
template< class _Tp> 
# 181
struct __is_duration : public false_type { 
# 183
}; 
# 185
template< class _Rep, class _Period> 
# 186
struct __is_duration< duration< _Rep, _Period> >  : public true_type { 
# 188
}; 
# 191
template< class _ToDur, class _Rep, class _Period> constexpr typename enable_if< __is_duration< _ToDur> ::value, _ToDur> ::type 
# 194
duration_cast(const duration< _Rep, _Period>  &__d) 
# 195
{ 
# 196
typedef typename _ToDur::period __to_period; 
# 197
typedef typename _ToDur::rep __to_rep; 
# 198
typedef ratio_divide< _Period, typename _ToDur::period>  __cf; 
# 200
typedef typename common_type< typename _ToDur::rep, _Rep, long> ::type __cr; 
# 202
typedef __duration_cast_impl< _ToDur, ratio_divide< _Period, typename _ToDur::period> , typename common_type< typename _ToDur::rep, _Rep, long> ::type, __ratio_divide< _Period, typename _ToDur::period> ::type::num == 1, __ratio_divide< _Period, typename _ToDur::period> ::type::den == 1>  __dc; 
# 203
return __dc::__cast(__d); 
# 204
} 
# 207
template< class _Rep> 
# 208
struct treat_as_floating_point : public is_floating_point< _Rep>  { 
# 210
}; 
# 213
template< class _Rep> 
# 214
struct duration_values { 
# 217
static constexpr _Rep zero() 
# 218
{ return (_Rep)0; } 
# 221
static constexpr _Rep max() 
# 222
{ return numeric_limits< _Rep> ::max(); } 
# 225
static constexpr _Rep min() 
# 226
{ return numeric_limits< _Rep> ::lowest(); } 
# 227
}; 
# 229
template< class _Tp> 
# 230
struct __is_ratio : public false_type { 
# 232
}; 
# 234
template< intmax_t _Num, intmax_t _Den> 
# 235
struct __is_ratio< ratio< _Num, _Den> >  : public true_type { 
# 237
}; 
# 240
template< class _Rep, class _Period> 
# 241
struct duration { 
# 243
typedef _Rep rep; 
# 244
typedef _Period period; 
# 246
static_assert((!__is_duration< _Rep> ::value), "rep cannot be a duration");
# 247
static_assert((__is_ratio< _Period> ::value), "period must be a specialization of ratio");
# 249
static_assert((_Period::num > 0), "period must be positive");
# 252
constexpr duration() = default;
# 257
duration(const duration &) = default;
# 259
template< class _Rep2, class  = typename enable_if< is_convertible< _Rep2, _Rep> ::value && (treat_as_floating_point< _Rep> ::value || (!treat_as_floating_point< _Rep2> ::value))> ::type> constexpr explicit 
# 263
duration(const _Rep2 &__rep) : __r(static_cast< rep>(__rep)) 
# 264
{ } 
# 266
template< class _Rep2, class _Period2, class  = typename enable_if< treat_as_floating_point< _Rep> ::value || ((__ratio_divide< _Period2, _Period> ::type::den == 1) && (!treat_as_floating_point< _Rep2> ::value))> ::type> constexpr 
# 270
duration(const chrono::duration< _Rep2, _Period2>  &__d) : __r((duration_cast< duration> (__d).count())) 
# 271
{ } 
# 273
~duration() = default;
# 274
duration &operator=(const duration &) = default;
# 278
constexpr rep count() const 
# 279
{ return __r; } 
# 283
constexpr duration operator+() const 
# 284
{ return *this; } 
# 287
constexpr duration operator-() const 
# 288
{ return ((duration)(-(__r))); } 
# 291
duration &operator++() 
# 292
{ 
# 293
++(__r); 
# 294
return *this; 
# 295
} 
# 298
duration operator++(int) 
# 299
{ return ((duration)((__r)++)); } 
# 302
duration &operator--() 
# 303
{ 
# 304
--(__r); 
# 305
return *this; 
# 306
} 
# 309
duration operator--(int) 
# 310
{ return ((duration)((__r)--)); } 
# 313
duration &operator+=(const duration &__d) 
# 314
{ 
# 315
(__r) += (__d.count()); 
# 316
return *this; 
# 317
} 
# 320
duration &operator-=(const duration &__d) 
# 321
{ 
# 322
(__r) -= (__d.count()); 
# 323
return *this; 
# 324
} 
# 327
duration &operator*=(const rep &__rhs) 
# 328
{ 
# 329
(__r) *= __rhs; 
# 330
return *this; 
# 331
} 
# 334
duration &operator/=(const rep &__rhs) 
# 335
{ 
# 336
(__r) /= __rhs; 
# 337
return *this; 
# 338
} 
# 341
template< class _Rep2 = rep> typename enable_if< !treat_as_floating_point< _Rep2> ::value, duration &> ::type 
# 344
operator%=(const rep &__rhs) 
# 345
{ 
# 346
(__r) %= __rhs; 
# 347
return *this; 
# 348
} 
# 350
template< class _Rep2 = rep> typename enable_if< !treat_as_floating_point< _Rep2> ::value, duration &> ::type 
# 353
operator%=(const duration &__d) 
# 354
{ 
# 355
(__r) %= (__d.count()); 
# 356
return *this; 
# 357
} 
# 361
static constexpr duration zero() 
# 362
{ return ((duration)(duration_values< _Rep> ::zero())); } 
# 365
static constexpr duration min() 
# 366
{ return ((duration)(duration_values< _Rep> ::min())); } 
# 369
static constexpr duration max() 
# 370
{ return ((duration)(duration_values< _Rep> ::max())); } 
# 373
private: rep __r; 
# 374
}; 
# 376
template< class _Rep1, class _Period1, class 
# 377
_Rep2, class _Period2> constexpr typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type 
# 380
operator+(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 381
__rhs) 
# 382
{ 
# 383
typedef duration< _Rep1, _Period1>  __dur1; 
# 384
typedef duration< _Rep2, _Period2>  __dur2; 
# 385
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __cd; 
# 386
return (__cd)((((__cd)__lhs).count()) + (((__cd)__rhs).count())); 
# 387
} 
# 389
template< class _Rep1, class _Period1, class 
# 390
_Rep2, class _Period2> constexpr typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type 
# 393
operator-(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 394
__rhs) 
# 395
{ 
# 396
typedef duration< _Rep1, _Period1>  __dur1; 
# 397
typedef duration< _Rep2, _Period2>  __dur2; 
# 398
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __cd; 
# 399
return (__cd)((((__cd)__lhs).count()) - (((__cd)__rhs).count())); 
# 400
} 
# 402
template< class _Rep1, class _Rep2, bool  = is_convertible< _Rep2, typename common_type< _Rep1, _Rep2> ::type> ::value> 
# 405
struct __common_rep_type { }; 
# 407
template< class _Rep1, class _Rep2> 
# 408
struct __common_rep_type< _Rep1, _Rep2, true>  { 
# 409
typedef typename common_type< _Rep1, _Rep2> ::type type; }; 
# 411
template< class _Rep1, class _Period, class _Rep2> constexpr duration< typename __common_rep_type< _Rep1, _Rep2> ::type, _Period>  
# 414
operator*(const duration< _Rep1, _Period>  &__d, const _Rep2 &__s) 
# 415
{ 
# 417
typedef duration< typename common_type< _Rep1, _Rep2> ::type, _Period>  __cd; 
# 418
return ((__cd)((((__cd)(__d)).count()) * __s)); 
# 419
} 
# 421
template< class _Rep1, class _Rep2, class _Period> constexpr duration< typename __common_rep_type< _Rep2, _Rep1> ::type, _Period>  
# 424
operator*(const _Rep1 &__s, const duration< _Rep2, _Period>  &__d) 
# 425
{ return __d * __s; } 
# 427
template< class _Rep1, class _Period, class _Rep2> constexpr duration< typename __common_rep_type< _Rep1, typename enable_if< !__is_duration< _Rep2> ::value, _Rep2> ::type> ::type, _Period>  
# 430
operator/(const duration< _Rep1, _Period>  &__d, const _Rep2 &__s) 
# 431
{ 
# 433
typedef duration< typename common_type< _Rep1, _Rep2> ::type, _Period>  __cd; 
# 434
return ((__cd)((((__cd)(__d)).count()) / __s)); 
# 435
} 
# 437
template< class _Rep1, class _Period1, class 
# 438
_Rep2, class _Period2> constexpr typename common_type< _Rep1, _Rep2> ::type 
# 440
operator/(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 441
__rhs) 
# 442
{ 
# 443
typedef duration< _Rep1, _Period1>  __dur1; 
# 444
typedef duration< _Rep2, _Period2>  __dur2; 
# 445
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __cd; 
# 446
return (((__cd)__lhs).count()) / (((__cd)__rhs).count()); 
# 447
} 
# 450
template< class _Rep1, class _Period, class _Rep2> constexpr duration< typename __common_rep_type< _Rep1, typename enable_if< !__is_duration< _Rep2> ::value, _Rep2> ::type> ::type, _Period>  
# 453
operator%(const duration< _Rep1, _Period>  &__d, const _Rep2 &__s) 
# 454
{ 
# 456
typedef duration< typename common_type< _Rep1, _Rep2> ::type, _Period>  __cd; 
# 457
return ((__cd)((((__cd)(__d)).count()) % __s)); 
# 458
} 
# 460
template< class _Rep1, class _Period1, class 
# 461
_Rep2, class _Period2> constexpr typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type 
# 464
operator%(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 465
__rhs) 
# 466
{ 
# 467
typedef duration< _Rep1, _Period1>  __dur1; 
# 468
typedef duration< _Rep2, _Period2>  __dur2; 
# 469
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __cd; 
# 470
return (__cd)((((__cd)__lhs).count()) % (((__cd)__rhs).count())); 
# 471
} 
# 474
template< class _Rep1, class _Period1, class 
# 475
_Rep2, class _Period2> constexpr bool 
# 477
operator==(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 478
__rhs) 
# 479
{ 
# 480
typedef duration< _Rep1, _Period1>  __dur1; 
# 481
typedef duration< _Rep2, _Period2>  __dur2; 
# 482
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __ct; 
# 483
return (((__ct)__lhs).count()) == (((__ct)__rhs).count()); 
# 484
} 
# 486
template< class _Rep1, class _Period1, class 
# 487
_Rep2, class _Period2> constexpr bool 
# 489
operator<(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 490
__rhs) 
# 491
{ 
# 492
typedef duration< _Rep1, _Period1>  __dur1; 
# 493
typedef duration< _Rep2, _Period2>  __dur2; 
# 494
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __ct; 
# 495
return (((__ct)__lhs).count()) < (((__ct)__rhs).count()); 
# 496
} 
# 498
template< class _Rep1, class _Period1, class 
# 499
_Rep2, class _Period2> constexpr bool 
# 501
operator!=(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 502
__rhs) 
# 503
{ return !(__lhs == __rhs); } 
# 505
template< class _Rep1, class _Period1, class 
# 506
_Rep2, class _Period2> constexpr bool 
# 508
operator<=(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 509
__rhs) 
# 510
{ return !(__rhs < __lhs); } 
# 512
template< class _Rep1, class _Period1, class 
# 513
_Rep2, class _Period2> constexpr bool 
# 515
operator>(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 516
__rhs) 
# 517
{ return __rhs < __lhs; } 
# 519
template< class _Rep1, class _Period1, class 
# 520
_Rep2, class _Period2> constexpr bool 
# 522
operator>=(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 523
__rhs) 
# 524
{ return !(__lhs < __rhs); } 
# 527
typedef duration< long, ratio< 1L, 1000000000L> >  nanoseconds; 
# 530
typedef duration< long, ratio< 1L, 1000000L> >  microseconds; 
# 533
typedef duration< long, ratio< 1L, 1000L> >  milliseconds; 
# 536
typedef duration< long, ratio< 1L> >  seconds; 
# 539
typedef duration< long, ratio< 60L> >  minutes; 
# 542
typedef duration< long, ratio< 3600L> >  hours; 
# 545
template< class _Clock, class _Dur> 
# 546
struct time_point { 
# 548
typedef _Clock clock; 
# 549
typedef _Dur duration; 
# 550
typedef typename _Dur::rep rep; 
# 551
typedef typename _Dur::period period; 
# 553
constexpr time_point() : __d(duration::zero()) 
# 554
{ } 
# 556
constexpr explicit time_point(const duration &__dur) : __d(__dur) 
# 558
{ } 
# 561
template< class _Dur2> constexpr 
# 562
time_point(const chrono::time_point< _Clock, _Dur2>  &__t) : __d((__t.time_since_epoch())) 
# 564
{ } 
# 568
constexpr duration time_since_epoch() const 
# 569
{ return __d; } 
# 573
time_point &operator+=(const duration &__dur) 
# 574
{ 
# 575
(__d) += __dur; 
# 576
return *this; 
# 577
} 
# 580
time_point &operator-=(const duration &__dur) 
# 581
{ 
# 582
(__d) -= __dur; 
# 583
return *this; 
# 584
} 
# 588
static constexpr time_point min() 
# 589
{ return ((time_point)(duration::min())); } 
# 592
static constexpr time_point max() 
# 593
{ return ((time_point)(duration::max())); } 
# 596
private: duration __d; 
# 597
}; 
# 600
template< class _ToDur, class _Clock, class _Dur> constexpr typename enable_if< __is_duration< _ToDur> ::value, time_point< _Clock, _ToDur> > ::type 
# 603
time_point_cast(const time_point< _Clock, _Dur>  &__t) 
# 604
{ 
# 605
typedef time_point< _Clock, _ToDur>  __time_point; 
# 606
return ((__time_point)(duration_cast< _ToDur> ((__t.time_since_epoch())))); 
# 607
} 
# 609
template< class _Clock, class _Dur1, class 
# 610
_Rep2, class _Period2> constexpr time_point< _Clock, typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type>  
# 613
operator+(const time_point< _Clock, _Dur1>  &__lhs, const duration< _Rep2, _Period2>  &
# 614
__rhs) 
# 615
{ 
# 616
typedef duration< _Rep2, _Period2>  __dur2; 
# 617
typedef typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type __ct; 
# 618
typedef time_point< _Clock, typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type>  __time_point; 
# 619
return ((__time_point)((__lhs.time_since_epoch()) + __rhs)); 
# 620
} 
# 622
template< class _Rep1, class _Period1, class 
# 623
_Clock, class _Dur2> constexpr time_point< _Clock, typename common_type< duration< _Rep1, _Period1> , _Dur2> ::type>  
# 626
operator+(const duration< _Rep1, _Period1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 627
__rhs) 
# 628
{ 
# 629
typedef duration< _Rep1, _Period1>  __dur1; 
# 630
typedef typename common_type< duration< _Rep1, _Period1> , _Dur2> ::type __ct; 
# 631
typedef time_point< _Clock, typename common_type< duration< _Rep1, _Period1> , _Dur2> ::type>  __time_point; 
# 632
return ((__time_point)((__rhs.time_since_epoch()) + __lhs)); 
# 633
} 
# 635
template< class _Clock, class _Dur1, class 
# 636
_Rep2, class _Period2> constexpr time_point< _Clock, typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type>  
# 639
operator-(const time_point< _Clock, _Dur1>  &__lhs, const duration< _Rep2, _Period2>  &
# 640
__rhs) 
# 641
{ 
# 642
typedef duration< _Rep2, _Period2>  __dur2; 
# 643
typedef typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type __ct; 
# 644
typedef time_point< _Clock, typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type>  __time_point; 
# 645
return ((__time_point)((__lhs.time_since_epoch()) - __rhs)); 
# 646
} 
# 648
template< class _Clock, class _Dur1, class _Dur2> constexpr typename common_type< _Dur1, _Dur2> ::type 
# 650
operator-(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 651
__rhs) 
# 652
{ return (__lhs.time_since_epoch()) - (__rhs.time_since_epoch()); } 
# 654
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 656
operator==(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 657
__rhs) 
# 658
{ return (__lhs.time_since_epoch()) == (__rhs.time_since_epoch()); } 
# 660
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 662
operator!=(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 663
__rhs) 
# 664
{ return !(__lhs == __rhs); } 
# 666
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 668
operator<(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 669
__rhs) 
# 670
{ return (__lhs.time_since_epoch()) < (__rhs.time_since_epoch()); } 
# 672
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 674
operator<=(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 675
__rhs) 
# 676
{ return !(__rhs < __lhs); } 
# 678
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 680
operator>(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 681
__rhs) 
# 682
{ return __rhs < __lhs; } 
# 684
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 686
operator>=(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 687
__rhs) 
# 688
{ return !(__lhs < __rhs); } 
# 709 "/usr/include/c++/5/chrono" 3
inline namespace _V2 { 
# 716
struct system_clock { 
# 718
typedef nanoseconds duration; 
# 719
typedef chrono::duration< long, ratio< 1L, 1000000000L> > ::rep rep; 
# 720
typedef chrono::duration< long, ratio< 1L, 1000000000L> > ::period period; 
# 721
typedef chrono::time_point< system_clock, chrono::duration< long, ratio< 1L, 1000000000L> > >  time_point; 
# 723
static_assert((((system_clock::duration::min()) < (system_clock::duration::zero()))), "a clock\'s minimum duration cannot be less than its epoch");
# 727
static constexpr bool is_steady = false; 
# 730
static time_point now() noexcept; 
# 734
static time_t to_time_t(const time_point &__t) noexcept 
# 735
{ 
# 736
return (time_t)duration_cast< chrono::duration< long, ratio< 1L> > > (__t.time_since_epoch()).count(); 
# 738
} 
# 741
static time_point from_time_t(time_t __t) noexcept 
# 742
{ 
# 743
typedef chrono::time_point< system_clock, chrono::duration< long, ratio< 1L> > >  __from; 
# 744
return time_point_cast< chrono::duration< long, ratio< 1L, 1000000000L> > > (((__from)(((seconds)(__t))))); 
# 746
} 
# 747
}; 
# 755
struct steady_clock { 
# 757
typedef nanoseconds duration; 
# 758
typedef chrono::duration< long, ratio< 1L, 1000000000L> > ::rep rep; 
# 759
typedef chrono::duration< long, ratio< 1L, 1000000000L> > ::period period; 
# 760
typedef chrono::time_point< steady_clock, chrono::duration< long, ratio< 1L, 1000000000L> > >  time_point; 
# 762
static constexpr bool is_steady = true; 
# 765
static time_point now() noexcept; 
# 766
}; 
# 776 "/usr/include/c++/5/chrono" 3
using high_resolution_clock = system_clock; 
# 778
}
# 781
}
# 881 "/usr/include/c++/5/chrono" 3
}
# 25 "/usr/local/include/librealsense2/hpp/rs_types.hpp" 3
struct rs2_frame_callback { 
# 27
virtual void on_frame(rs2_frame * f) = 0; 
# 28
virtual void release() = 0; 
# 29
virtual ~rs2_frame_callback() { } 
# 30
}; 
# 32
struct rs2_frame_processor_callback { 
# 34
virtual void on_frame(rs2_frame * f, rs2_source * source) = 0; 
# 35
virtual void release() = 0; 
# 36
virtual ~rs2_frame_processor_callback() { } 
# 37
}; 
# 39
struct rs2_notifications_callback { 
# 41
virtual void on_notification(rs2_notification * n) = 0; 
# 42
virtual void release() = 0; 
# 43
virtual ~rs2_notifications_callback() { } 
# 44
}; 
# 46
struct rs2_log_callback { 
# 48
virtual void on_event(rs2_log_severity severity, const char * message) = 0; 
# 49
virtual void release() = 0; 
# 50
virtual ~rs2_log_callback() { } 
# 51
}; 
# 53
struct rs2_devices_changed_callback { 
# 55
virtual void on_devices_changed(rs2_device_list * removed, rs2_device_list * added) = 0; 
# 56
virtual void release() = 0; 
# 57
virtual ~rs2_devices_changed_callback() { } 
# 58
}; 
# 60
struct rs2_playback_status_changed_callback { 
# 62
virtual void on_playback_status_changed(rs2_playback_status status) = 0; 
# 63
virtual void release() = 0; 
# 64
virtual ~rs2_playback_status_changed_callback() { } 
# 65
}; 
# 67
namespace rs2 { 
# 69
class error : public std::runtime_error { 
# 71
std::__cxx11::string function, args; 
# 72
rs2_exception_type type; 
# 74
public: explicit error(rs2_error *err) : std::runtime_error(rs2_get_error_message(err)) 
# 75
{ 
# 76
((function) = ((((nullptr) != rs2_get_failed_function(err)) ? rs2_get_failed_function(err) : std::__cxx11::string()))); 
# 77
((args) = ((((nullptr) != rs2_get_failed_args(err)) ? rs2_get_failed_args(err) : std::__cxx11::string()))); 
# 78
(type) = rs2_get_librealsense_exception_type(err); 
# 79
rs2_free_error(err); 
# 80
} 
# 82
explicit error(const std::__cxx11::string &message) : std::runtime_error(message.c_str()) 
# 83
{ 
# 84
((function) = ("")); 
# 85
((args) = ("")); 
# 86
(type) = RS2_EXCEPTION_TYPE_UNKNOWN; 
# 87
} 
# 89
const std::__cxx11::string &get_failed_function() const 
# 90
{ 
# 91
return function; 
# 92
} 
# 94
const std::__cxx11::string &get_failed_args() const 
# 95
{ 
# 96
return args; 
# 97
} 
# 99
rs2_exception_type get_type() const { return type; } 
# 101
static inline void handle(rs2_error * e); 
# 102
}; 
# 111 "/usr/local/include/librealsense2/hpp/rs_types.hpp" 3
class recoverable_error : public error { public: explicit recoverable_error(rs2_error *e) noexcept : error(e) { } }; 
# 112
class unrecoverable_error : public error { public: explicit unrecoverable_error(rs2_error *e) noexcept : error(e) { } }; 
# 113
class camera_disconnected_error : public unrecoverable_error { public: explicit camera_disconnected_error(rs2_error *e) noexcept : unrecoverable_error(e) { } }; 
# 114
class backend_error : public unrecoverable_error { public: explicit backend_error(rs2_error *e) noexcept : unrecoverable_error(e) { } }; 
# 115
class device_in_recovery_mode_error : public unrecoverable_error { public: explicit device_in_recovery_mode_error(rs2_error *e) noexcept : unrecoverable_error(e) { } }; 
# 116
class invalid_value_error : public recoverable_error { public: explicit invalid_value_error(rs2_error *e) noexcept : recoverable_error(e) { } }; 
# 117
class wrong_api_call_sequence_error : public recoverable_error { public: explicit wrong_api_call_sequence_error(rs2_error *e) noexcept : recoverable_error(e) { } }; 
# 118
class not_implemented_error : public recoverable_error { public: explicit not_implemented_error(rs2_error *e) noexcept : recoverable_error(e) { } }; 
# 121
inline void error::handle(rs2_error *e) 
# 122
{ 
# 123
if (e) 
# 124
{ 
# 125
auto h = rs2_get_librealsense_exception_type(e); 
# 126
switch (h) { 
# 127
case RS2_EXCEPTION_TYPE_CAMERA_DISCONNECTED:  
# 128
throw ((camera_disconnected_error)(e)); 
# 129
case RS2_EXCEPTION_TYPE_BACKEND:  
# 130
throw ((backend_error)(e)); 
# 131
case RS2_EXCEPTION_TYPE_INVALID_VALUE:  
# 132
throw ((invalid_value_error)(e)); 
# 133
case RS2_EXCEPTION_TYPE_WRONG_API_CALL_SEQUENCE:  
# 134
throw ((wrong_api_call_sequence_error)(e)); 
# 135
case RS2_EXCEPTION_TYPE_NOT_IMPLEMENTED:  
# 136
throw ((not_implemented_error)(e)); 
# 137
case RS2_EXCEPTION_TYPE_DEVICE_IN_RECOVERY_MODE:  
# 138
throw ((device_in_recovery_mode_error)(e)); 
# 139
default:  
# 140
throw ((error)(e)); 
# 141
}  
# 142
}  
# 143
} 
# 145
class context; 
# 146
class device; 
# 147
class device_list; 
# 148
class syncer; 
# 149
class device_base; 
# 150
class roi_sensor; 
# 151
class frame; 
# 153
struct option_range { 
# 155
float min; 
# 156
float max; 
# 157
float def; 
# 158
float step; 
# 159
}; 
# 161
struct region_of_interest { 
# 163
int min_x; 
# 164
int min_y; 
# 165
int max_x; 
# 166
int max_y; 
# 167
}; 
# 168
}
# 9 "/usr/local/include/librealsense2/hpp/rs_frame.hpp" 3
namespace rs2 { 
# 11
class frame_source; 
# 12
class frame_queue; 
# 13
class syncer; 
# 14
class processing_block; 
# 15
class pointcloud; 
# 16
class sensor; 
# 17
class frame; 
# 18
class pipeline_profile; 
# 19
class points; 
# 21
class stream_profile { 
# 27
public: stream_profile() : _profile((nullptr)) { } 
# 33
int stream_index() const { return _index; } 
# 38
rs2_stream stream_type() const { return _type; } 
# 43
rs2_format format() const { return _format; } 
# 48
int fps() const { return _framerate; } 
# 53
int unique_id() const { return _uid; } 
# 62 "/usr/local/include/librealsense2/hpp/rs_frame.hpp" 3
stream_profile clone(rs2_stream type, int index, rs2_format format) const 
# 63
{ 
# 64
rs2_error *e = (nullptr); 
# 65
auto ref = rs2_clone_stream_profile(_profile, type, index, format, &e); 
# 66
error::handle(e); 
# 67
stream_profile res(ref); 
# 68
((res._clone) = std::shared_ptr< rs2_stream_profile> (ref, [](rs2_stream_profile *r) { rs2_delete_stream_profile(r); } )); 
# 70
return res; 
# 71
} 
# 78
bool operator==(const stream_profile &rhs) 
# 79
{ 
# 80
return (this->stream_index() == rhs.stream_index()) && ((this->stream_type()) == (rhs.stream_type())) && ((this->format()) == (rhs.format())) && (this->fps() == rhs.fps()); 
# 84
} 
# 90
template< class T> bool 
# 91
is() const 
# 92
{ 
# 93
T extension(*this); 
# 94
return extension; 
# 95
} 
# 101
template< class T> T 
# 102
as() const 
# 103
{ 
# 104
T extension(*this); 
# 105
return extension; 
# 106
} 
# 112
std::__cxx11::string stream_name() const 
# 113
{ 
# 114
std::stringstream ss; 
# 115
(ss << (rs2_stream_to_string(this->stream_type()))); 
# 116
if (this->stream_index() != 0) { (((ss << (" "))) << (this->stream_index())); }  
# 117
return ss.str(); 
# 118
} 
# 124
bool is_default() const { return _default; } 
# 130
operator bool() const { return (_profile) != (nullptr); } 
# 136
const rs2_stream_profile *get() const { return _profile; } 
# 147 "/usr/local/include/librealsense2/hpp/rs_frame.hpp" 3
rs2_extrinsics get_extrinsics_to(const stream_profile &to) const 
# 148
{ 
# 149
rs2_error *e = (nullptr); 
# 150
rs2_extrinsics res; 
# 151
rs2_get_extrinsics(this->get(), to.get(), &res, &e); 
# 152
error::handle(e); 
# 153
return res; 
# 154
} 
# 161
void register_extrinsics_to(const stream_profile &to, rs2_extrinsics extrinsics) 
# 162
{ 
# 163
rs2_error *e = (nullptr); 
# 164
rs2_register_extrinsics(this->get(), to.get(), extrinsics, &e); 
# 165
error::handle(e); 
# 166
} 
# 168
bool is_cloned() { return (bool)(_clone); } 
# 169
explicit stream_profile(const rs2_stream_profile *profile) : _profile(profile) 
# 170
{ 
# 171
rs2_error *e = (nullptr); 
# 172
rs2_get_stream_profile_data(_profile, &(_type), &(_format), &(_index), &(_uid), &(_framerate), &e); 
# 173
error::handle(e); 
# 175
(_default) = (!(!(rs2_is_stream_profile_default(_profile, &e)))); 
# 176
error::handle(e); 
# 178
} 
# 179
operator const rs2_stream_profile *() { return _profile; } 
# 180
explicit operator std::shared_ptr< rs2_stream_profile> () { return _clone; } 
# 183
friend class sensor; 
# 184
friend class frame; 
# 185
friend class pipeline_profile; 
# 186
friend class software_sensor; 
# 188
protected: const rs2_stream_profile *_profile; 
# 189
std::shared_ptr< rs2_stream_profile>  _clone; 
# 191
int _index = 0; 
# 192
int _uid = 0; 
# 193
int _framerate = 0; 
# 194
rs2_format _format = RS2_FORMAT_ANY; 
# 195
rs2_stream _type = RS2_STREAM_ANY; 
# 197
bool _default = false; 
# 198
}; 
# 200
class video_stream_profile : public stream_profile { 
# 207
public: explicit video_stream_profile(const stream_profile &sp) : stream_profile(sp) 
# 209
{ 
# 210
rs2_error *e = (nullptr); 
# 211
if ((rs2_stream_profile_is(sp.get(), RS2_EXTENSION_VIDEO_PROFILE, &e) == 0) && (!e)) 
# 212
{ 
# 213
(_profile) = (nullptr); 
# 214
}  
# 215
error::handle(e); 
# 217
if (_profile) 
# 218
{ 
# 219
rs2_get_video_stream_resolution(_profile, &(_width), &(_height), &e); 
# 220
error::handle(e); 
# 221
}  
# 222
} 
# 224
int width() const 
# 225
{ 
# 226
return _width; 
# 227
} 
# 229
int height() const 
# 230
{ 
# 231
return _height; 
# 232
} 
# 237
rs2_intrinsics get_intrinsics() const 
# 238
{ 
# 239
rs2_error *e = (nullptr); 
# 240
rs2_intrinsics intr; 
# 241
rs2_get_video_stream_intrinsics(_profile, &intr, &e); 
# 242
error::handle(e); 
# 243
return intr; 
# 244
} 
# 247
private: int _width = 0; 
# 248
int _height = 0; 
# 249
}; 
# 252
class motion_stream_profile : public stream_profile { 
# 259
public: explicit motion_stream_profile(const stream_profile &sp) : stream_profile(sp) 
# 261
{ 
# 262
rs2_error *e = (nullptr); 
# 263
if ((rs2_stream_profile_is(sp.get(), RS2_EXTENSION_MOTION_PROFILE, &e) == 0) && (!e)) 
# 264
{ 
# 265
(_profile) = (nullptr); 
# 266
}  
# 267
error::handle(e); 
# 268
} 
# 274
rs2_motion_device_intrinsic get_motion_intrinsics() const 
# 276
{ 
# 277
rs2_error *e = (nullptr); 
# 278
rs2_motion_device_intrinsic intrin; 
# 279
rs2_get_motion_intrinsics(_profile, &intrin, &e); 
# 280
error::handle(e); 
# 281
return intrin; 
# 282
} 
# 283
}; 
# 289
class filter_interface { 
# 292
public: virtual frame process(class frame frame) const = 0; 
# 293
virtual ~filter_interface() = default;
# 294
}; 
# 296
class frame { 
# 302
public: frame() : frame_ref((nullptr)) { } 
# 307
frame(rs2_frame *ref) : frame_ref(ref) 
# 308
{ 
# 326 "/usr/local/include/librealsense2/hpp/rs_frame.hpp" 3
} 
# 331
frame(frame &&other) noexcept : frame_ref(other.frame_ref) 
# 332
{ 
# 333
(other.frame_ref) = (nullptr); 
# 338
} 
# 343
frame &operator=(frame other) 
# 344
{ 
# 345
this->swap(other); 
# 346
return *this; 
# 347
} 
# 353
frame(const frame &other) : frame_ref(other.frame_ref) 
# 355
{ 
# 356
if (frame_ref) { this->add_ref(); }  
# 361
} 
# 366
void swap(frame &other) 
# 367
{ 
# 368
std::swap(frame_ref, other.frame_ref); 
# 374
} 
# 379
~frame() 
# 380
{ 
# 381
if (frame_ref) 
# 382
{ 
# 383
rs2_release_frame(frame_ref); 
# 384
}  
# 385
} 
# 390
void keep() { rs2_keep_frame(frame_ref); } 
# 396
operator bool() const { return (frame_ref) != (nullptr); } 
# 402
double get_timestamp() const 
# 403
{ 
# 404
rs2_error *e = (nullptr); 
# 405
auto r = rs2_get_frame_timestamp(frame_ref, &e); 
# 406
error::handle(e); 
# 407
return r; 
# 408
} 
# 413
rs2_timestamp_domain get_frame_timestamp_domain() const 
# 414
{ 
# 415
rs2_error *e = (nullptr); 
# 416
auto r = rs2_get_frame_timestamp_domain(frame_ref, &e); 
# 417
error::handle(e); 
# 418
return r; 
# 419
} 
# 425
rs2_metadata_type get_frame_metadata(rs2_frame_metadata_value frame_metadata) const 
# 426
{ 
# 427
rs2_error *e = (nullptr); 
# 428
auto r = rs2_get_frame_metadata(frame_ref, frame_metadata, &e); 
# 429
error::handle(e); 
# 430
return r; 
# 431
} 
# 437
bool supports_frame_metadata(rs2_frame_metadata_value frame_metadata) const 
# 438
{ 
# 439
rs2_error *e = (nullptr); 
# 440
auto r = rs2_supports_frame_metadata(frame_ref, frame_metadata, &e); 
# 441
error::handle(e); 
# 442
return r != 0; 
# 443
} 
# 449
unsigned long long get_frame_number() const 
# 450
{ 
# 451
rs2_error *e = (nullptr); 
# 452
auto r = rs2_get_frame_number(frame_ref, &e); 
# 453
error::handle(e); 
# 454
return r; 
# 455
} 
# 461
const void *get_data() const 
# 462
{ 
# 463
rs2_error *e = (nullptr); 
# 464
auto r = rs2_get_frame_data(frame_ref, &e); 
# 465
error::handle(e); 
# 466
return r; 
# 467
} 
# 473
stream_profile get_profile() const 
# 474
{ 
# 475
rs2_error *e = (nullptr); 
# 476
auto s = rs2_get_frame_stream_profile(frame_ref, &e); 
# 477
error::handle(e); 
# 478
return ((stream_profile)(s)); 
# 479
} 
# 485
template< class T> bool 
# 486
is() const 
# 487
{ 
# 488
T extension(*this); 
# 489
return extension; 
# 490
} 
# 495
template< class T> T 
# 496
as() const 
# 497
{ 
# 498
T extension(*this); 
# 499
return extension; 
# 500
} 
# 506
rs2_frame *get() const { return frame_ref; } 
# 507
explicit operator rs2_frame *() { return frame_ref; } 
# 509
frame apply_filter(filter_interface &filter) 
# 510
{ 
# 511
return filter.process(*this); 
# 512
} 
# 520
protected: void add_ref() const 
# 521
{ 
# 522
rs2_error *e = (nullptr); 
# 523
rs2_frame_add_ref(frame_ref, &e); 
# 524
error::handle(e); 
# 525
} 
# 527
void reset() 
# 528
{ 
# 529
if (frame_ref) 
# 530
{ 
# 531
rs2_release_frame(frame_ref); 
# 532
}  
# 533
(frame_ref) = (nullptr); 
# 534
} 
# 537
friend class frame_source; 
# 538
friend class frame_queue; 
# 539
friend class syncer; 
# 540
friend class processing_block; 
# 541
friend class pointcloud; 
# 542
friend class points; 
# 544
private: rs2_frame *frame_ref; 
# 550
}; 
# 552
class video_frame : public frame { 
# 559
public: video_frame(const frame &f) : frame(f) 
# 561
{ 
# 562
rs2_error *e = (nullptr); 
# 563
if ((!f) || ((rs2_is_frame_extendable_to(f.get(), RS2_EXTENSION_VIDEO_FRAME, &e) == 0) && (!e))) 
# 564
{ 
# 565
this->reset(); 
# 566
}  
# 567
error::handle(e); 
# 568
} 
# 575
int get_width() const 
# 576
{ 
# 577
rs2_error *e = (nullptr); 
# 578
auto r = rs2_get_frame_width(this->get(), &e); 
# 579
error::handle(e); 
# 580
return r; 
# 581
} 
# 587
int get_height() const 
# 588
{ 
# 589
rs2_error *e = (nullptr); 
# 590
auto r = rs2_get_frame_height(this->get(), &e); 
# 591
error::handle(e); 
# 592
return r; 
# 593
} 
# 599
int get_stride_in_bytes() const 
# 600
{ 
# 601
rs2_error *e = (nullptr); 
# 602
auto r = rs2_get_frame_stride_in_bytes(this->get(), &e); 
# 603
error::handle(e); 
# 604
return r; 
# 605
} 
# 611
int get_bits_per_pixel() const 
# 612
{ 
# 613
rs2_error *e = (nullptr); 
# 614
auto r = rs2_get_frame_bits_per_pixel(this->get(), &e); 
# 615
error::handle(e); 
# 616
return r; 
# 617
} 
# 623
int get_bytes_per_pixel() const { return this->get_bits_per_pixel() / 8; } 
# 624
}; 
# 626
struct vertex { 
# 627
float x, y, z; 
# 628
operator const float *() const { return &(x); } 
# 629
}; 
# 630
struct texture_coordinate { 
# 631
float u, v; 
# 632
operator const float *() const { return &(u); } 
# 633
}; 
# 635
class points : public frame { 
# 641
public: points() : frame(), _size((0)) { } 
# 647
points(const frame &f) : frame(f), _size((0)) 
# 649
{ 
# 650
rs2_error *e = (nullptr); 
# 651
if ((!f) || ((rs2_is_frame_extendable_to(f.get(), RS2_EXTENSION_POINTS, &e) == 0) && (!e))) 
# 652
{ 
# 653
this->reset(); 
# 654
}  
# 655
error::handle(e); 
# 657
if (this->get()) 
# 658
{ 
# 659
(_size) = (rs2_get_frame_points_count(this->get(), &e)); 
# 660
error::handle(e); 
# 661
}  
# 662
} 
# 667
const vertex *get_vertices() const 
# 668
{ 
# 669
rs2_error *e = (nullptr); 
# 670
auto res = rs2_get_frame_vertices(this->get(), &e); 
# 671
error::handle(e); 
# 672
return (const vertex *)res; 
# 673
} 
# 680
void export_to_ply(const std::__cxx11::string &fname, video_frame texture) 
# 681
{ 
# 682
rs2_frame *ptr = (nullptr); 
# 683
std::swap(texture.frame_ref, ptr); 
# 684
rs2_error *e = (nullptr); 
# 685
rs2_export_to_ply(this->get(), fname.c_str(), ptr, &e); 
# 686
error::handle(e); 
# 687
} 
# 692
const texture_coordinate *get_texture_coordinates() const 
# 693
{ 
# 694
rs2_error *e = (nullptr); 
# 695
auto res = rs2_get_frame_texture_coordinates(this->get(), &e); 
# 696
error::handle(e); 
# 697
return (const texture_coordinate *)res; 
# 698
} 
# 700
size_t size() const 
# 701
{ 
# 702
return _size; 
# 703
} 
# 706
private: size_t _size; 
# 707
}; 
# 709
class depth_frame : public video_frame { 
# 716
public: depth_frame(const frame &f) : video_frame(f) 
# 718
{ 
# 719
rs2_error *e = (nullptr); 
# 720
if ((!f) || ((rs2_is_frame_extendable_to(f.get(), RS2_EXTENSION_DEPTH_FRAME, &e) == 0) && (!e))) 
# 721
{ 
# 722
this->reset(); 
# 723
}  
# 724
error::handle(e); 
# 725
} 
# 733
float get_distance(int x, int y) const 
# 734
{ 
# 735
rs2_error *e = (nullptr); 
# 736
auto r = rs2_depth_frame_get_distance(this->get(), x, y, &e); 
# 737
error::handle(e); 
# 738
return r; 
# 739
} 
# 740
}; 
# 742
class disparity_frame : public depth_frame { 
# 749
public: disparity_frame(const frame &f) : depth_frame(f) 
# 751
{ 
# 752
rs2_error *e = (nullptr); 
# 753
if ((!f) || ((rs2_is_frame_extendable_to(f.get(), RS2_EXTENSION_DISPARITY_FRAME, &e) == 0) && (!e))) 
# 754
{ 
# 755
this->reset(); 
# 756
}  
# 757
error::handle(e); 
# 758
} 
# 763
float get_baseline() const 
# 764
{ 
# 765
rs2_error *e = (nullptr); 
# 766
auto r = rs2_depth_stereo_frame_get_baseline(this->get(), &e); 
# 767
error::handle(e); 
# 768
return r; 
# 769
} 
# 770
}; 
# 772
class motion_frame : public frame { 
# 779
public: motion_frame(const frame &f) : frame(f) 
# 781
{ 
# 782
rs2_error *e = (nullptr); 
# 783
if ((!f) || ((rs2_is_frame_extendable_to(f.get(), RS2_EXTENSION_MOTION_FRAME, &e) == 0) && (!e))) 
# 784
{ 
# 785
this->reset(); 
# 786
}  
# 787
error::handle(e); 
# 788
} 
# 793
rs2_vector get_motion_data() const 
# 794
{ 
# 795
auto data = reinterpret_cast< const float *>(this->get_data()); 
# 796
return rs2_vector{data[0], data[1], data[2]}; 
# 797
} 
# 798
}; 
# 800
class pose_frame : public frame { 
# 807
public: pose_frame(const frame &f) : frame(f) 
# 809
{ 
# 810
rs2_error *e = (nullptr); 
# 811
if ((!f) || ((rs2_is_frame_extendable_to(f.get(), RS2_EXTENSION_POSE_FRAME, &e) == 0) && (!e))) 
# 812
{ 
# 813
this->reset(); 
# 814
}  
# 815
error::handle(e); 
# 816
} 
# 821
rs2_pose get_pose_data() 
# 822
{ 
# 823
rs2_pose pose_data; 
# 824
rs2_error *e = (nullptr); 
# 825
rs2_pose_frame_get_pose_data(this->get(), &pose_data, &e); 
# 826
error::handle(e); 
# 827
return pose_data; 
# 828
} 
# 829
}; 
# 831
class frameset : public frame { 
# 837
public: frameset() : _size((0)) { } 
# 842
frameset(const frame &f) : frame(f), _size((0)) 
# 844
{ 
# 845
rs2_error *e = (nullptr); 
# 846
if ((!f) || ((rs2_is_frame_extendable_to(f.get(), RS2_EXTENSION_COMPOSITE_FRAME, &e) == 0) && (!e))) 
# 847
{ 
# 848
this->reset(); 
# 850
}  
# 851
error::handle(e); 
# 853
if (this->get()) 
# 854
{ 
# 855
(_size) = (rs2_embedded_frames_count(this->get(), &e)); 
# 856
error::handle(e); 
# 857
}  
# 858
} 
# 866
frame first_or_default(rs2_stream s, rs2_format f = RS2_FORMAT_ANY) const 
# 867
{ 
# 868
frame result; 
# 869
this->foreach([&result, s, f](frame frm) { 
# 870
if ((!(result)) && (((frm.get_profile()).stream_type()) == (s)) && (((f) == (RS2_FORMAT_ANY)) || ((f) == ((frm.get_profile()).format())))) 
# 871
{ 
# 872
((result) = (std::move(frm))); 
# 873
}  
# 874
} ); 
# 875
return result; 
# 876
} 
# 883
frame first(rs2_stream s, rs2_format f = RS2_FORMAT_ANY) const 
# 884
{ 
# 885
auto frm = this->first_or_default(s, f); 
# 886
if (!frm) { throw ((error)("Frame of requested stream type was not found!")); }  
# 887
return frm; 
# 888
} 
# 894
depth_frame get_depth_frame() const 
# 895
{ 
# 896
auto f = this->first_or_default(RS2_STREAM_DEPTH, RS2_FORMAT_Z16); 
# 897
return f.as< depth_frame> (); 
# 898
} 
# 903
video_frame get_color_frame() const 
# 904
{ 
# 905
auto f = this->first_or_default(RS2_STREAM_COLOR); 
# 907
if (!f) 
# 908
{ 
# 909
auto ir = this->first_or_default(RS2_STREAM_INFRARED); 
# 910
if (ir && (((ir.get_profile()).format()) == (RS2_FORMAT_RGB8))) { 
# 911
(f = ir); }  
# 912
}  
# 913
return f; 
# 914
} 
# 920
video_frame get_infrared_frame(const size_t index = 0) const 
# 921
{ 
# 922
frame f; 
# 923
if (!index) 
# 924
{ 
# 925
(f = (this->first_or_default(RS2_STREAM_INFRARED))); 
# 926
} else 
# 928
{ 
# 929
this->foreach([&f, index](const frame &frm) { 
# 930
if ((((frm.get_profile()).stream_type()) == (RS2_STREAM_INFRARED)) && (((frm.get_profile()).stream_index()) == (index))) { 
# 931
((f) = frm); }  
# 932
} ); 
# 933
}  
# 934
return f; 
# 935
} 
# 940
size_t size() const 
# 941
{ 
# 942
return _size; 
# 943
} 
# 949
template< class T> void 
# 950
foreach(T action) const 
# 951
{ 
# 952
rs2_error *e = (nullptr); 
# 953
auto count = this->size(); 
# 954
for (size_t i = (0); i < count; i++) 
# 955
{ 
# 956
auto fref = rs2_extract_frame(this->get(), (int)i, &e); 
# 957
error::handle(e); 
# 959
action(((frame)(fref))); 
# 960
}  
# 961
} 
# 967
frame operator[](size_t index) const 
# 968
{ 
# 969
rs2_error *e = (nullptr); 
# 970
if (index < this->size()) 
# 971
{ 
# 972
auto fref = rs2_extract_frame(this->get(), (int)index, &e); 
# 973
error::handle(e); 
# 974
return ((frame)(fref)); 
# 975
}  
# 977
throw ((error)("Requested index is out of range!")); 
# 978
} 
# 980
class iterator : public std::iterator< std::forward_iterator_tag, frame>  { 
# 983
public: iterator(const frameset *owner, size_t index = 0) : _index(index), _owner(owner) { } 
# 984
frameset::iterator &operator++() { ++(_index); return *this; } 
# 985
bool operator==(const frameset::iterator &other) const { return (_index) == (other._index); } 
# 986
bool operator!=(const frameset::iterator &other) const { return !((*this) == other); } 
# 988
frame operator*() { return (*(_owner))[_index]; } 
# 990
private: size_t _index = (0); 
# 991
const frameset *_owner; 
# 992
}; 
# 994
iterator begin() const { return ((iterator)(this)); } 
# 995
iterator end() const { return iterator(this, this->size()); } 
# 997
private: size_t _size; 
# 998
}; 
# 999
}
# 10 "/usr/local/include/librealsense2/hpp/rs_sensor.hpp" 3
namespace rs2 { 
# 13
class notification { 
# 16
public: notification(rs2_notification *nt) 
# 17
{ 
# 18
rs2_error *e = (nullptr); 
# 19
((_description) = (rs2_get_notification_description(nt, &e))); 
# 20
error::handle(e); 
# 21
(_timestamp) = rs2_get_notification_timestamp(nt, &e); 
# 22
error::handle(e); 
# 23
(_severity) = rs2_get_notification_severity(nt, &e); 
# 24
error::handle(e); 
# 25
(_category) = rs2_get_notification_category(nt, &e); 
# 26
error::handle(e); 
# 27
((_serialized_data) = (rs2_get_notification_serialized_data(nt, &e))); 
# 28
error::handle(e); 
# 29
} 
# 31
notification() = default;
# 37
rs2_notification_category get_category() const 
# 38
{ 
# 39
return _category; 
# 40
} 
# 45
std::__cxx11::string get_description() const 
# 46
{ 
# 47
return _description; 
# 48
} 
# 54
double get_timestamp() const 
# 55
{ 
# 56
return _timestamp; 
# 57
} 
# 63
rs2_log_severity get_severity() const 
# 64
{ 
# 65
return _severity; 
# 66
} 
# 72
std::__cxx11::string get_serialized_data() const 
# 73
{ 
# 74
return _serialized_data; 
# 75
} 
# 78
private: std::__cxx11::string _description; 
# 79
double _timestamp = (-1); 
# 80
rs2_log_severity _severity = RS2_LOG_SEVERITY_COUNT; 
# 81
rs2_notification_category _category = RS2_NOTIFICATION_CATEGORY_COUNT; 
# 82
std::__cxx11::string _serialized_data; 
# 83
}; 
# 85
template< class T> 
# 86
class notifications_callback : public rs2_notifications_callback { 
# 88
T on_notification_function; 
# 90
public: explicit notifications_callback(T on_notification) : on_notification_function(on_notification) { } 
# 92
virtual void on_notification(rs2_notification *_notification) override 
# 93
{ 
# 94
(on_notification_function)(notification{_notification}); 
# 95
} 
# 97
virtual void release() override { delete this; } 
# 98
}; 
# 100
template< class T> 
# 101
class frame_callback : public rs2_frame_callback { 
# 103
T on_frame_function; 
# 105
public: explicit frame_callback(T on_frame) : on_frame_function(on_frame) { } 
# 107
virtual void on_frame(rs2_frame *fref) override 
# 108
{ 
# 109
(on_frame_function)(frame{fref}); 
# 110
} 
# 112
virtual void release() override { delete this; } 
# 113
}; 
# 115
class options { 
# 123
public: bool supports(rs2_option option) const 
# 124
{ 
# 125
rs2_error *e = (nullptr); 
# 126
auto res = rs2_supports_option(_options, option, &e); 
# 127
error::handle(e); 
# 128
return res > 0; 
# 129
} 
# 136
const char *get_option_description(rs2_option option) const 
# 137
{ 
# 138
rs2_error *e = (nullptr); 
# 139
auto res = rs2_get_option_description(_options, option, &e); 
# 140
error::handle(e); 
# 141
return res; 
# 142
} 
# 150
const char *get_option_value_description(rs2_option option, float val) const 
# 151
{ 
# 152
rs2_error *e = (nullptr); 
# 153
auto res = rs2_get_option_value_description(_options, option, val, &e); 
# 154
error::handle(e); 
# 155
return res; 
# 156
} 
# 163
float get_option(rs2_option option) const 
# 164
{ 
# 165
rs2_error *e = (nullptr); 
# 166
auto res = rs2_get_option(_options, option, &e); 
# 167
error::handle(e); 
# 168
return res; 
# 169
} 
# 175
option_range get_option_range(rs2_option option) const 
# 176
{ 
# 177
option_range result; 
# 178
rs2_error *e = (nullptr); 
# 179
rs2_get_option_range(_options, option, &(result.min), &(result.max), &(result.step), &(result.def), &e); 
# 181
error::handle(e); 
# 182
return result; 
# 183
} 
# 190
void set_option(rs2_option option, float value) const 
# 191
{ 
# 192
rs2_error *e = (nullptr); 
# 193
rs2_set_option(_options, option, value, &e); 
# 194
error::handle(e); 
# 195
} 
# 202
bool is_option_read_only(rs2_option option) const 
# 203
{ 
# 204
rs2_error *e = (nullptr); 
# 205
auto res = rs2_is_option_read_only(_options, option, &e); 
# 206
error::handle(e); 
# 207
return res > 0; 
# 208
} 
# 210
options &operator=(const options &other) 
# 211
{ 
# 212
(_options) = (other._options); 
# 213
return *this; 
# 214
} 
# 216
options(const options &other) : _options(other._options) { } 
# 218
virtual ~options() = default;
# 220
protected: explicit options(rs2_options *o = 0) : _options(o) { } 
# 222
template< class T> options &
# 223
operator=(const T &dev) 
# 224
{ 
# 225
(_options) = ((rs2_options *)(dev.get())); 
# 226
return *this; 
# 227
} 
# 231
private: rs2_options *_options; 
# 232
}; 
# 234
class sensor : public options { 
# 238
public: using options::supports;
# 243
void open(const stream_profile &profile) const 
# 244
{ 
# 245
rs2_error *e = (nullptr); 
# 246
rs2_open((_sensor).get(), profile.get(), &e); 
# 249
error::handle(e); 
# 250
} 
# 257
bool supports(rs2_camera_info info) const 
# 258
{ 
# 259
rs2_error *e = (nullptr); 
# 260
auto is_supported = rs2_supports_sensor_info((_sensor).get(), info, &e); 
# 261
error::handle(e); 
# 262
return is_supported > 0; 
# 263
} 
# 270
const char *get_info(rs2_camera_info info) const 
# 271
{ 
# 272
rs2_error *e = (nullptr); 
# 273
auto result = rs2_get_sensor_info((_sensor).get(), info, &e); 
# 274
error::handle(e); 
# 275
return result; 
# 276
} 
# 283
void open(const std::vector< stream_profile>  &profiles) const 
# 284
{ 
# 285
rs2_error *e = (nullptr); 
# 287
std::vector< const rs2_stream_profile *>  profs; 
# 288
profs.reserve(profiles.size()); 
# 289
for (auto &p : profiles) 
# 290
{ 
# 291
profs.push_back(p.get()); 
# 292
}  
# 294
rs2_open_multiple((_sensor).get(), profs.data(), static_cast< int>(profiles.size()), &e); 
# 298
error::handle(e); 
# 299
} 
# 305
void close() const 
# 306
{ 
# 307
rs2_error *e = (nullptr); 
# 308
rs2_close((_sensor).get(), &e); 
# 309
error::handle(e); 
# 310
} 
# 316
template< class T> void 
# 317
start(T callback) const 
# 318
{ 
# 319
rs2_error *e = (nullptr); 
# 320
rs2_start_cpp((_sensor).get(), new frame_callback< T> (std::move(callback)), &e); 
# 321
error::handle(e); 
# 322
} 
# 327
void stop() const 
# 328
{ 
# 329
rs2_error *e = (nullptr); 
# 330
rs2_stop((_sensor).get(), &e); 
# 331
error::handle(e); 
# 332
} 
# 338
template< class T> void 
# 339
set_notifications_callback(T callback) const 
# 340
{ 
# 341
rs2_error *e = (nullptr); 
# 342
rs2_set_notifications_callback_cpp((_sensor).get(), new notifications_callback< T> (std::move(callback)), &e); 
# 344
error::handle(e); 
# 345
} 
# 352
std::vector< stream_profile>  get_stream_profiles() const 
# 353
{ 
# 354
std::vector< stream_profile>  results{}; 
# 356
rs2_error *e = (nullptr); 
# 357
std::shared_ptr< rs2_stream_profile_list>  list(rs2_get_stream_profiles((_sensor).get(), &e), rs2_delete_stream_profiles_list); 
# 360
error::handle(e); 
# 362
auto size = rs2_get_stream_profiles_count(list.get(), &e); 
# 363
error::handle(e); 
# 365
for (auto i = 0; i < size; i++) 
# 366
{ 
# 367
stream_profile profile(rs2_get_stream_profile(list.get(), i, &e)); 
# 368
error::handle(e); 
# 369
results.push_back(profile); 
# 370
}  
# 372
return results; 
# 373
} 
# 375
sensor &operator=(const std::shared_ptr< rs2_sensor>  other) 
# 376
{ 
# 377
this->options::operator=(other); 
# 378
(_sensor).reset(); 
# 379
((_sensor) = other); 
# 380
return *this; 
# 381
} 
# 383
sensor &operator=(const sensor &other) 
# 384
{ 
# 385
((*this) = (nullptr)); 
# 386
this->options::operator=(other._sensor); 
# 387
((_sensor) = (other._sensor)); 
# 388
return *this; 
# 389
} 
# 390
sensor() : _sensor(nullptr) { } 
# 392
operator bool() const 
# 393
{ 
# 394
return ((_sensor) != (nullptr)); 
# 395
} 
# 397
const std::shared_ptr< rs2_sensor>  &get() const 
# 398
{ 
# 399
return _sensor; 
# 400
} 
# 402
template< class T> bool 
# 403
is() const 
# 404
{ 
# 405
T extension(*this); 
# 406
return extension; 
# 407
} 
# 409
template< class T> T 
# 410
as() const 
# 411
{ 
# 412
T extension(*this); 
# 413
return extension; 
# 414
} 
# 416
explicit sensor(std::shared_ptr< rs2_sensor>  dev) : options((rs2_options *)dev.get()), _sensor(dev) 
# 418
{ 
# 419
} 
# 420
explicit operator std::shared_ptr< rs2_sensor> () { return _sensor; } 
# 423
friend class context; 
# 424
friend class device_list; 
# 425
friend class device; 
# 426
friend class device_base; 
# 427
friend class roi_sensor; 
# 429
protected: std::shared_ptr< rs2_sensor>  _sensor; 
# 432
}; 
# 434
inline bool operator==(const sensor &lhs, const sensor &rhs) 
# 435
{ 
# 436
if (!(lhs.supports(RS2_CAMERA_INFO_NAME) && lhs.supports(RS2_CAMERA_INFO_SERIAL_NUMBER) && rhs.supports(RS2_CAMERA_INFO_NAME) && rhs.supports(RS2_CAMERA_INFO_SERIAL_NUMBER))) { 
# 438
return false; }  
# 440
return ((((std::__cxx11::string)(lhs.get_info(RS2_CAMERA_INFO_NAME))) == (rhs.get_info(RS2_CAMERA_INFO_NAME)))) && ((((std::__cxx11::string)(lhs.get_info(RS2_CAMERA_INFO_SERIAL_NUMBER))) == (rhs.get_info(RS2_CAMERA_INFO_SERIAL_NUMBER)))); 
# 442
} 
# 444
class roi_sensor : public sensor { 
# 447
public: roi_sensor(sensor s) : sensor(s.get()) 
# 449
{ 
# 450
rs2_error *e = (nullptr); 
# 451
if ((rs2_is_sensor_extendable_to((_sensor).get(), RS2_EXTENSION_ROI, &e) == 0) && (!e)) 
# 452
{ 
# 453
(_sensor).reset(); 
# 454
}  
# 455
error::handle(e); 
# 456
} 
# 458
void set_region_of_interest(const region_of_interest &roi) 
# 459
{ 
# 460
rs2_error *e = (nullptr); 
# 461
rs2_set_region_of_interest((_sensor).get(), roi.min_x, roi.min_y, roi.max_x, roi.max_y, &e); 
# 462
error::handle(e); 
# 463
} 
# 465
region_of_interest get_region_of_interest() const 
# 466
{ 
# 467
region_of_interest roi{}; 
# 468
rs2_error *e = (nullptr); 
# 469
rs2_get_region_of_interest((_sensor).get(), &(roi.min_x), &(roi.min_y), &(roi.max_x), &(roi.max_y), &e); 
# 470
error::handle(e); 
# 471
return roi; 
# 472
} 
# 474
operator bool() const { return (_sensor).get() != (nullptr); } 
# 475
}; 
# 477
class depth_sensor : public sensor { 
# 480
public: depth_sensor(sensor s) : sensor(s.get()) 
# 482
{ 
# 483
rs2_error *e = (nullptr); 
# 484
if ((rs2_is_sensor_extendable_to((_sensor).get(), RS2_EXTENSION_DEPTH_SENSOR, &e) == 0) && (!e)) 
# 485
{ 
# 486
(_sensor).reset(); 
# 487
}  
# 488
error::handle(e); 
# 489
} 
# 494
float get_depth_scale() const 
# 495
{ 
# 496
rs2_error *e = (nullptr); 
# 497
auto res = rs2_get_depth_scale((_sensor).get(), &e); 
# 498
error::handle(e); 
# 499
return res; 
# 500
} 
# 502
operator bool() const { return (_sensor).get() != (nullptr); } 
# 503
explicit depth_sensor(std::shared_ptr< rs2_sensor>  dev) : depth_sensor(((sensor)(dev))) { } 
# 504
}; 
# 506
class depth_stereo_sensor : public depth_sensor { 
# 509
public: depth_stereo_sensor(sensor s) : depth_sensor(s) 
# 510
{ 
# 511
rs2_error *e = (nullptr); 
# 512
if ((_sensor) && (rs2_is_sensor_extendable_to((_sensor).get(), RS2_EXTENSION_DEPTH_STEREO_SENSOR, &e) == 0) && (!e)) 
# 513
{ 
# 514
(_sensor).reset(); 
# 515
}  
# 516
error::handle(e); 
# 517
} 
# 522
float get_stereo_baseline() const 
# 523
{ 
# 524
rs2_error *e = (nullptr); 
# 525
auto res = rs2_get_depth_scale((_sensor).get(), &e); 
# 526
error::handle(e); 
# 527
return res; 
# 528
} 
# 530
operator bool() const { return (_sensor).get() != (nullptr); } 
# 531
}; 
# 532
}
# 11 "/usr/local/include/librealsense2/hpp/rs_device.hpp" 3
namespace rs2 { 
# 13
class context; 
# 14
class device_list; 
# 15
class pipeline_profile; 
# 16
class device_hub; 
# 18
class device { 
# 25
public: std::vector< sensor>  query_sensors() const 
# 26
{ 
# 27
rs2_error *e = (nullptr); 
# 28
std::shared_ptr< rs2_sensor_list>  list(rs2_query_sensors((_dev).get(), &e), rs2_delete_sensor_list); 
# 31
error::handle(e); 
# 33
auto size = rs2_get_sensors_count(list.get(), &e); 
# 34
error::handle(e); 
# 36
std::vector< sensor>  results; 
# 37
for (auto i = 0; i < size; i++) 
# 38
{ 
# 39
std::shared_ptr< rs2_sensor>  dev(rs2_create_sensor(list.get(), i, &e), rs2_delete_sensor); 
# 42
error::handle(e); 
# 44
sensor rs2_dev(dev); 
# 45
results.push_back(rs2_dev); 
# 46
}  
# 48
return results; 
# 49
} 
# 51
template< class T> T 
# 52
first() const 
# 53
{ 
# 54
for (auto &&s : this->query_sensors()) 
# 55
{ 
# 56
if (auto t = (s.template as< T> ())) { return t; }  
# 57
}  
# 58
throw ((error)("Could not find requested sensor type!")); 
# 59
} 
# 66
bool supports(rs2_camera_info info) const 
# 67
{ 
# 68
rs2_error *e = (nullptr); 
# 69
auto is_supported = rs2_supports_device_info((_dev).get(), info, &e); 
# 70
error::handle(e); 
# 71
return is_supported > 0; 
# 72
} 
# 79
const char *get_info(rs2_camera_info info) const 
# 80
{ 
# 81
rs2_error *e = (nullptr); 
# 82
auto result = rs2_get_device_info((_dev).get(), info, &e); 
# 83
error::handle(e); 
# 84
return result; 
# 85
} 
# 90
void hardware_reset() 
# 91
{ 
# 92
rs2_error *e = (nullptr); 
# 94
rs2_hardware_reset((_dev).get(), &e); 
# 95
error::handle(e); 
# 96
} 
# 98
device &operator=(const std::shared_ptr< rs2_device>  dev) 
# 99
{ 
# 100
(_dev).reset(); 
# 101
((_dev) = dev); 
# 102
return *this; 
# 103
} 
# 104
device &operator=(const device &dev) 
# 105
{ 
# 106
((*this) = (nullptr)); 
# 107
((_dev) = (dev._dev)); 
# 108
return *this; 
# 109
} 
# 110
device() : _dev(nullptr) { } 
# 112
operator bool() const 
# 113
{ 
# 114
return ((_dev) != (nullptr)); 
# 115
} 
# 116
const std::shared_ptr< rs2_device>  &get() const 
# 117
{ 
# 118
return _dev; 
# 119
} 
# 121
template< class T> bool 
# 122
is() const 
# 123
{ 
# 124
T extension(*this); 
# 125
return extension; 
# 126
} 
# 128
template< class T> T 
# 129
as() const 
# 130
{ 
# 131
T extension(*this); 
# 132
return extension; 
# 133
} 
# 134
virtual ~device() 
# 135
{ 
# 136
} 
# 138
explicit operator std::shared_ptr< rs2_device> () { return _dev; } 
# 139
explicit device(std::shared_ptr< rs2_device>  dev) : _dev(dev) { } 
# 141
friend class context; 
# 142
friend class device_list; 
# 143
friend class pipeline_profile; 
# 144
friend class device_hub; 
# 146
protected: std::shared_ptr< rs2_device>  _dev; 
# 148
}; 
# 150
class debug_protocol : public device { 
# 153
public: debug_protocol(device d) : device(d.get()) 
# 155
{ 
# 156
rs2_error *e = (nullptr); 
# 157
if ((rs2_is_device_extendable_to((_dev).get(), RS2_EXTENSION_DEBUG, &e) == 0) && (!e)) 
# 158
{ 
# 159
(_dev).reset(); 
# 160
}  
# 161
error::handle(e); 
# 162
} 
# 164
std::vector< unsigned char>  send_and_receive_raw_data(const std::vector< unsigned char>  &input) const 
# 165
{ 
# 166
std::vector< unsigned char>  results; 
# 168
rs2_error *e = (nullptr); 
# 169
std::shared_ptr< const rs2_raw_data_buffer>  list(rs2_send_and_receive_raw_data((_dev).get(), (void *)input.data(), (uint32_t)input.size(), &e), rs2_delete_raw_data); 
# 172
error::handle(e); 
# 174
auto size = rs2_get_raw_data_size(list.get(), &e); 
# 175
error::handle(e); 
# 177
auto start = rs2_get_raw_data(list.get(), &e); 
# 179
results.insert(results.begin(), start, start + size); 
# 181
return results; 
# 182
} 
# 183
}; 
# 185
class device_list { 
# 188
public: explicit device_list(std::shared_ptr< rs2_device_list>  list) : _list(move(list)) 
# 189
{ } 
# 191
device_list() : _list(nullptr) 
# 192
{ } 
# 194
operator std::vector< device> () const 
# 195
{ 
# 196
std::vector< device>  res; 
# 197
for (auto &&dev : *this) { res.push_back(dev); }  
# 198
return res; 
# 199
} 
# 201
bool contains(const device &dev) const 
# 202
{ 
# 203
rs2_error *e = (nullptr); 
# 204
auto res = !(!(rs2_device_list_contains((_list).get(), dev.get().get(), &e))); 
# 205
error::handle(e); 
# 206
return res; 
# 207
} 
# 209
device_list &operator=(std::shared_ptr< rs2_device_list>  list) 
# 210
{ 
# 211
((_list) = (move(list))); 
# 212
return *this; 
# 213
} 
# 215
device operator[](uint32_t index) const 
# 216
{ 
# 217
rs2_error *e = (nullptr); 
# 218
std::shared_ptr< rs2_device>  dev(rs2_create_device((_list).get(), index, &e), rs2_delete_device); 
# 221
error::handle(e); 
# 223
return ((device)(dev)); 
# 224
} 
# 226
uint32_t size() const 
# 227
{ 
# 228
rs2_error *e = (nullptr); 
# 229
auto size = rs2_get_device_count((_list).get(), &e); 
# 230
error::handle(e); 
# 231
return size; 
# 232
} 
# 234
device front() const { return std::move((*this)[0]); } 
# 235
device back() const 
# 236
{ 
# 237
return std::move((*this)[this->size() - (1)]); 
# 238
} 
# 240
class device_list_iterator { 
# 242
device_list_iterator(const rs2::device_list &
# 243
device_list, ::uint32_t 
# 244
uint32_t) : _list(device_list), _index(uint32_t) 
# 247
{ 
# 248
} 
# 251
public: device operator*() const 
# 252
{ 
# 253
return (_list)[_index]; 
# 254
} 
# 255
bool operator!=(const device_list_iterator &other) const 
# 256
{ 
# 257
return ((other._index) != (_index)) || ((&(other._list)) != (&(_list))); 
# 258
} 
# 259
bool operator==(const device_list_iterator &other) const 
# 260
{ 
# 261
return !((*this) != other); 
# 262
} 
# 263
device_list_iterator &operator++() 
# 264
{ 
# 265
(_index)++; 
# 266
return *this; 
# 267
} 
# 269
friend class device_list; 
# 270
private: const device_list &_list; 
# 271
uint32_t _index; 
# 272
}; 
# 274
device_list_iterator begin() const 
# 275
{ 
# 276
return device_list_iterator(*this, 0); 
# 277
} 
# 278
device_list_iterator end() const 
# 279
{ 
# 280
return device_list_iterator(*this, this->size()); 
# 281
} 
# 282
const rs2_device_list *get_list() const 
# 283
{ 
# 284
return (_list).get(); 
# 285
} 
# 287
operator std::shared_ptr< rs2_device_list> () { return _list; } 
# 290
private: std::shared_ptr< rs2_device_list>  _list; 
# 291
}; 
# 293
class tm2 : public device { 
# 296
public: tm2(device d) : device(d.get()) 
# 298
{ 
# 299
rs2_error *e = (nullptr); 
# 300
if ((rs2_is_device_extendable_to((_dev).get(), RS2_EXTENSION_TM2, &e) == 0) && (!e)) 
# 301
{ 
# 302
(_dev).reset(); 
# 303
}  
# 304
error::handle(e); 
# 305
} 
# 311
void enable_loopback(const std::__cxx11::string &from_file) 
# 312
{ 
# 313
rs2_error *e = (nullptr); 
# 314
rs2_loopback_enable((_dev).get(), from_file.c_str(), &e); 
# 315
error::handle(e); 
# 316
} 
# 321
void disable_loopback() 
# 322
{ 
# 323
rs2_error *e = (nullptr); 
# 324
rs2_loopback_disable((_dev).get(), &e); 
# 325
error::handle(e); 
# 326
} 
# 332
bool is_loopback_enabled() const 
# 333
{ 
# 334
rs2_error *e = (nullptr); 
# 335
int is_enabled = rs2_loopback_is_enabled((_dev).get(), &e); 
# 336
error::handle(e); 
# 337
return is_enabled != 0; 
# 338
} 
# 344
void connect_controller(const std::array< unsigned char, 6UL>  &mac_addr) 
# 345
{ 
# 346
rs2_error *e = (nullptr); 
# 347
rs2_connect_tm2_controller((_dev).get(), mac_addr.data(), &e); 
# 348
error::handle(e); 
# 349
} 
# 355
void disconnect_controller(int id) 
# 356
{ 
# 357
rs2_error *e = (nullptr); 
# 358
rs2_disconnect_tm2_controller((_dev).get(), id, &e); 
# 359
error::handle(e); 
# 360
} 
# 361
}; 
# 362
}
# 10 "/usr/local/include/librealsense2/hpp/rs_record_playback.hpp" 3
namespace rs2 { 
# 12
template< class T> 
# 13
class status_changed_callback : public rs2_playback_status_changed_callback { 
# 15
T on_status_changed_function; 
# 17
public: explicit status_changed_callback(T on_status_changed) : on_status_changed_function(on_status_changed) { } 
# 19
virtual void on_playback_status_changed(rs2_playback_status status) override 
# 20
{ 
# 21
(on_status_changed_function)(status); 
# 22
} 
# 24
virtual void release() override { delete this; } 
# 25
}; 
# 27
class playback : public device { 
# 30
public: playback(device d) : playback(d.get()) { } 
# 37
void pause() 
# 38
{ 
# 39
rs2_error *e = (nullptr); 
# 40
rs2_playback_device_pause((_dev).get(), &e); 
# 41
error::handle(e); 
# 42
} 
# 48
void resume() 
# 49
{ 
# 50
rs2_error *e = (nullptr); 
# 51
rs2_playback_device_resume((_dev).get(), &e); 
# 52
error::handle(e); 
# 53
} 
# 59
std::__cxx11::string file_name() const 
# 60
{ 
# 61
return m_file; 
# 62
} 
# 68
uint64_t get_position() const 
# 69
{ 
# 70
rs2_error *e = (nullptr); 
# 71
uint64_t pos = rs2_playback_get_position((_dev).get(), &e); 
# 72
error::handle(e); 
# 73
return pos; 
# 74
} 
# 80
std::chrono::nanoseconds get_duration() const 
# 81
{ 
# 82
rs2_error *e = (nullptr); 
# 83
std::chrono::nanoseconds duration(rs2_playback_get_duration((_dev).get(), &e)); 
# 84
error::handle(e); 
# 85
return duration; 
# 86
} 
# 92
void seek(std::chrono::nanoseconds time) 
# 93
{ 
# 94
rs2_error *e = (nullptr); 
# 95
rs2_playback_seek((_dev).get(), time.count(), &e); 
# 96
error::handle(e); 
# 97
} 
# 103
bool is_real_time() const 
# 104
{ 
# 105
rs2_error *e = (nullptr); 
# 106
bool real_time = rs2_playback_device_is_real_time((_dev).get(), &e) != 0; 
# 107
error::handle(e); 
# 108
return real_time; 
# 109
} 
# 122 "/usr/local/include/librealsense2/hpp/rs_record_playback.hpp" 3
void set_real_time(bool real_time) const 
# 123
{ 
# 124
rs2_error *e = (nullptr); 
# 125
rs2_playback_device_set_real_time((_dev).get(), real_time ? 1 : 0, &e); 
# 126
error::handle(e); 
# 127
} 
# 133
void set_playback_speed(float speed) const 
# 134
{ 
# 135
rs2_error *e = (nullptr); 
# 136
rs2_playback_device_set_playback_speed((_dev).get(), speed, &e); 
# 137
error::handle(e); 
# 138
} 
# 152 "/usr/local/include/librealsense2/hpp/rs_record_playback.hpp" 3
template< class T> void 
# 153
set_status_changed_callback(T callback) 
# 154
{ 
# 155
rs2_error *e = (nullptr); 
# 156
rs2_playback_device_set_status_changed_callback((_dev).get(), new status_changed_callback< T> (std::move(callback)), &e); 
# 157
error::handle(e); 
# 158
} 
# 164
rs2_playback_status current_status() const 
# 165
{ 
# 166
rs2_error *e = (nullptr); 
# 167
rs2_playback_status sts = rs2_playback_device_get_current_status((_dev).get(), &e); 
# 168
error::handle(e); 
# 169
return sts; 
# 170
} 
# 176
void stop() 
# 177
{ 
# 178
rs2_error *e = (nullptr); 
# 179
rs2_playback_device_stop((_dev).get(), &e); 
# 180
error::handle(e); 
# 181
} 
# 183
friend class context; 
# 184
protected: explicit playback(std::shared_ptr< rs2_device>  dev) : device(dev) 
# 185
{ 
# 186
rs2_error *e = (nullptr); 
# 187
if ((rs2_is_device_extendable_to((_dev).get(), RS2_EXTENSION_PLAYBACK, &e) == 0) && (!e)) 
# 188
{ 
# 189
(_dev).reset(); 
# 190
}  
# 191
error::handle(e); 
# 193
if ((_dev)) 
# 194
{ 
# 195
e = (nullptr); 
# 196
((m_file) = (rs2_playback_device_get_file_path((_dev).get(), &e))); 
# 197
error::handle(e); 
# 198
}  
# 199
} 
# 201
private: std::__cxx11::string m_file; 
# 202
}; 
# 203
class recorder : public device { 
# 206
public: recorder(device d) : recorder(d.get()) { } 
# 213
recorder(const std::__cxx11::string &file, device dev) 
# 214
{ 
# 215
rs2_error *e = (nullptr); 
# 216
((_dev) = std::shared_ptr< rs2_device> (rs2_create_record_device(dev.get().get(), file.c_str(), &e), rs2_delete_device)); 
# 219
rs2::error::handle(e); 
# 220
} 
# 228
recorder(const std::__cxx11::string &file, device dev, bool compression_enabled) 
# 229
{ 
# 230
rs2_error *e = (nullptr); 
# 231
((_dev) = std::shared_ptr< rs2_device> (rs2_create_record_device_ex(dev.get().get(), file.c_str(), compression_enabled, &e), rs2_delete_device)); 
# 234
rs2::error::handle(e); 
# 235
} 
# 241
void pause() 
# 242
{ 
# 243
rs2_error *e = (nullptr); 
# 244
rs2_record_device_pause((_dev).get(), &e); 
# 245
error::handle(e); 
# 246
} 
# 251
void resume() 
# 252
{ 
# 253
rs2_error *e = (nullptr); 
# 254
rs2_record_device_resume((_dev).get(), &e); 
# 255
error::handle(e); 
# 256
} 
# 262
std::__cxx11::string filename() const 
# 263
{ 
# 264
rs2_error *e = (nullptr); 
# 265
std::__cxx11::string filename = rs2_record_device_filename((_dev).get(), &e); 
# 266
error::handle(e); 
# 267
return filename; 
# 268
} 
# 270
protected: explicit recorder(std::shared_ptr< rs2_device>  dev) : device(dev) 
# 271
{ 
# 272
rs2_error *e = (nullptr); 
# 273
if ((rs2_is_device_extendable_to((_dev).get(), RS2_EXTENSION_RECORD, &e) == 0) && (!e)) 
# 274
{ 
# 275
(_dev).reset(); 
# 276
}  
# 277
error::handle(e); 
# 278
} 
# 279
}; 
# 280
}
# 11 "/usr/local/include/librealsense2/hpp/rs_processing.hpp" 3
namespace rs2 { 
# 17
class frame_source { 
# 32 "/usr/local/include/librealsense2/hpp/rs_processing.hpp" 3
public: frame allocate_video_frame(const stream_profile &profile, const frame &
# 33
original, int 
# 34
new_bpp = 0, int 
# 35
new_width = 0, int 
# 36
new_height = 0, int 
# 37
new_stride = 0, rs2_extension 
# 38
frame_type = RS2_EXTENSION_VIDEO_FRAME) const 
# 39
{ 
# 40
rs2_error *e = (nullptr); 
# 41
auto result = rs2_allocate_synthetic_video_frame(_source, profile.get(), original.get(), new_bpp, new_width, new_height, new_stride, frame_type, &e); 
# 43
error::handle(e); 
# 44
return result; 
# 45
} 
# 47
frame allocate_points(const stream_profile &profile, const frame &
# 48
original) const 
# 49
{ 
# 50
rs2_error *e = (nullptr); 
# 51
auto result = rs2_allocate_points(_source, profile.get(), original.get(), &e); 
# 52
error::handle(e); 
# 53
return result; 
# 54
} 
# 62
frame allocate_composite_frame(std::vector< frame>  frames) const 
# 63
{ 
# 64
rs2_error *e = (nullptr); 
# 66
std::vector< rs2_frame *>  refs(frames.size(), (rs2_frame *)nullptr); 
# 67
for (size_t i = (0); i < frames.size(); i++) { 
# 68
std::swap(refs[i], frames[i].frame_ref); }  
# 70
auto result = rs2_allocate_composite_frame(_source, refs.data(), (int)refs.size(), &e); 
# 71
error::handle(e); 
# 72
return result; 
# 73
} 
# 79
void frame_ready(frame result) const 
# 80
{ 
# 81
rs2_error *e = (nullptr); 
# 82
rs2_synthetic_frame_ready(_source, result.get(), &e); 
# 83
error::handle(e); 
# 84
(result.frame_ref) = (nullptr); 
# 85
} 
# 87
rs2_source *_source; 
# 89
template< class T> friend class frame_processor_callback; 
# 92
private: frame_source(rs2_source *source) : _source(source) { } 
# 93
frame_source(const frame_source &) = delete;
# 95
}; 
# 97
template< class T> 
# 98
class frame_processor_callback : public rs2_frame_processor_callback { 
# 100
T on_frame_function; 
# 102
public: explicit frame_processor_callback(T on_frame) : on_frame_function(on_frame) { } 
# 104
virtual void on_frame(rs2_frame *f, rs2_source *source) override 
# 105
{ 
# 106
frame_source src(source); 
# 107
frame frm(f); 
# 108
(on_frame_function)(std::move(frm), src); 
# 109
} 
# 111
virtual void release() override { delete this; } 
# 112
}; 
# 114
class frame_queue { 
# 122
public: explicit frame_queue(unsigned capacity) : _capacity(capacity) 
# 123
{ 
# 124
rs2_error *e = (nullptr); 
# 125
((_queue) = std::shared_ptr< rs2_frame_queue> (rs2_create_frame_queue(capacity, &e), rs2_delete_frame_queue)); 
# 128
error::handle(e); 
# 129
} 
# 131
frame_queue() : frame_queue(1) { } 
# 137
void enqueue(frame f) const 
# 138
{ 
# 139
rs2_enqueue_frame(f.frame_ref, (_queue).get()); 
# 140
(f.frame_ref) = (nullptr); 
# 141
} 
# 147
frame wait_for_frame(unsigned timeout_ms = 5000) const 
# 148
{ 
# 149
rs2_error *e = (nullptr); 
# 150
auto frame_ref = rs2_wait_for_frame((_queue).get(), timeout_ms, &e); 
# 151
error::handle(e); 
# 152
return {frame_ref}; 
# 153
} 
# 160
template< class T> typename std::enable_if< std::is_base_of< frame, T> ::value, bool> ::type 
# 161
poll_for_frame(T *output) const 
# 162
{ 
# 163
rs2_error *e = (nullptr); 
# 164
rs2_frame *frame_ref = (nullptr); 
# 165
auto res = rs2_poll_for_frame((_queue).get(), &frame_ref, &e); 
# 166
error::handle(e); 
# 167
frame f{frame_ref}; 
# 168
if (res) { (*output) = f; }  
# 169
return res > 0; 
# 170
} 
# 172
template< class T> typename std::enable_if< std::is_base_of< frame, T> ::value, bool> ::type 
# 173
try_wait_for_frame(T *output, unsigned timeout_ms = 5000) const 
# 174
{ 
# 175
rs2_error *e = (nullptr); 
# 176
rs2_frame *frame_ref = (nullptr); 
# 177
auto res = rs2_try_wait_for_frame((_queue).get(), timeout_ms, &frame_ref, &e); 
# 178
error::handle(e); 
# 179
frame f{frame_ref}; 
# 180
if (res) { (*output) = f; }  
# 181
return res > 0; 
# 182
} 
# 186
void operator()(frame f) const 
# 187
{ 
# 188
this->enqueue(std::move(f)); 
# 189
} 
# 194
size_t capacity() const { return _capacity; } 
# 197
private: std::shared_ptr< rs2_frame_queue>  _queue; 
# 198
size_t _capacity; 
# 199
}; 
# 204
class processing_block : public options { 
# 213
public: 
# 212
template< class S> void 
# 213
start(S on_frame) 
# 214
{ 
# 215
rs2_error *e = (nullptr); 
# 216
rs2_start_processing(this->get(), new frame_callback< S> (on_frame), &e); 
# 217
error::handle(e); 
# 218
} 
# 225
template< class S> S &
# 226
operator>>(S &on_frame) 
# 227
{ 
# 228
start(on_frame); 
# 229
return on_frame; 
# 230
} 
# 236
void invoke(frame f) const 
# 237
{ 
# 238
rs2_frame *ptr = (nullptr); 
# 239
std::swap(f.frame_ref, ptr); 
# 241
rs2_error *e = (nullptr); 
# 242
rs2_process_frame(this->get(), ptr, &e); 
# 243
error::handle(e); 
# 244
} 
# 250
processing_block(std::shared_ptr< rs2_processing_block>  block) : options((rs2_options *)block.get()), _block(block) 
# 252
{ 
# 253
} 
# 260
template< class S> 
# 261
processing_block(S processing_function) 
# 262
{ 
# 263
rs2_error *e = (nullptr); 
# 264
((_block) = std::shared_ptr< rs2_processing_block> (rs2_create_processing_block(new frame_processor_callback< S> (processing_function), &e), rs2_delete_processing_block)); 
# 267
this->options::operator=(_block); 
# 268
error::handle(e); 
# 269
} 
# 271
operator rs2_options *() const { return (rs2_options *)this->get(); } 
# 272
rs2_processing_block *get() const { return (_block).get(); } 
# 275
protected: void register_simple_option(rs2_option option_id, option_range range) { 
# 276
rs2_error *e = (nullptr); 
# 277
rs2_processing_block_register_simple_option((_block).get(), option_id, range.min, range.max, range.step, range.def, &e); 
# 279
error::handle(e); 
# 280
} 
# 281
std::shared_ptr< rs2_processing_block>  _block; 
# 282
}; 
# 287
class filter : public processing_block, public filter_interface { 
# 296
public: virtual frame process(class frame frame) const override 
# 297
{ 
# 298
this->invoke(frame); 
# 299
rs2::frame f; 
# 300
if (!(_queue).poll_for_frame(&f)) { 
# 301
throw ((std::runtime_error)("Error occured during execution of the processing block! See the log for more info")); }  
# 302
return f; 
# 303
} 
# 310
filter(std::shared_ptr< rs2_processing_block>  block, int queue_size = 1) : processing_block(block), _queue(queue_size) 
# 313
{ 
# 314
this->start(_queue); 
# 315
} 
# 322
template< class S> 
# 323
filter(S processing_function, int queue_size = 1) : processing_block(processing_function), _queue(queue_size) 
# 326
{ 
# 327
this->start(_queue); 
# 328
} 
# 330
frame_queue get_queue() { return _queue; } 
# 331
rs2_processing_block *get() const { return (_block).get(); } 
# 334
protected: frame_queue _queue; 
# 335
}; 
# 340
class pointcloud : public filter { 
# 346
public: pointcloud() : filter(this->init(), 1) { } 
# 348
pointcloud(rs2_stream stream, int index = 0) : filter(this->init(), 1) 
# 349
{ 
# 350
this->set_option(RS2_OPTION_STREAM_FILTER, (float)stream); 
# 351
this->set_option(RS2_OPTION_STREAM_INDEX_FILTER, (float)index); 
# 352
} 
# 359
points calculate(frame depth) 
# 360
{ 
# 361
auto res = this->process(depth); 
# 362
if ((res.as< points> ())) { 
# 363
return res; }  
# 365
if (auto set = res.as< frameset> ()) 
# 366
{ 
# 367
for (auto f : set) 
# 368
{ 
# 369
if ((f.as< points> ())) { 
# 370
return f; }  
# 371
}  
# 372
}  
# 373
throw ((std::runtime_error)("Error occured during execution of the processing block! See the log for more info")); 
# 374
} 
# 380
void map_to(frame mapped) 
# 381
{ 
# 382
this->set_option(RS2_OPTION_STREAM_FILTER, (float)(mapped.get_profile()).stream_type()); 
# 383
this->set_option(RS2_OPTION_STREAM_FORMAT_FILTER, (float)(mapped.get_profile()).format()); 
# 384
this->set_option(RS2_OPTION_STREAM_INDEX_FILTER, (float)(mapped.get_profile()).stream_index()); 
# 385
this->invoke(mapped); 
# 386
} 
# 389
protected: pointcloud(std::shared_ptr< rs2_processing_block>  block) : filter(block, 1) { } 
# 392
friend class context; 
# 394
private: std::shared_ptr< rs2_processing_block>  init() 
# 395
{ 
# 396
rs2_error *e = (nullptr); 
# 398
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_pointcloud(&e), rs2_delete_processing_block); 
# 402
error::handle(e); 
# 406
return block; 
# 407
} 
# 408
}; 
# 410
class yuy_decoder : public filter { 
# 421 "/usr/local/include/librealsense2/hpp/rs_processing.hpp" 3
public: yuy_decoder() : filter(this->init(), 1) { } 
# 424
protected: yuy_decoder(std::shared_ptr< rs2_processing_block>  block) : filter(block, 1) { } 
# 427
private: std::shared_ptr< rs2_processing_block>  init() 
# 428
{ 
# 429
rs2_error *e = (nullptr); 
# 430
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_yuy_decoder(&e), rs2_delete_processing_block); 
# 433
error::handle(e); 
# 435
return block; 
# 436
} 
# 437
}; 
# 439
class threshold_filter : public filter { 
# 447
public: threshold_filter(float min_dist = (0.150000006F), float max_dist = (4.0F)) : filter(this->init(), 1) 
# 449
{ 
# 450
this->set_option(RS2_OPTION_MIN_DISTANCE, min_dist); 
# 451
this->set_option(RS2_OPTION_MAX_DISTANCE, max_dist); 
# 452
} 
# 455
protected: threshold_filter(std::shared_ptr< rs2_processing_block>  block) : filter(block, 1) { } 
# 458
private: std::shared_ptr< rs2_processing_block>  init() 
# 459
{ 
# 460
rs2_error *e = (nullptr); 
# 461
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_threshold(&e), rs2_delete_processing_block); 
# 464
error::handle(e); 
# 466
return block; 
# 467
} 
# 468
}; 
# 471
class asynchronous_syncer : public processing_block { 
# 477
public: asynchronous_syncer() : processing_block(this->init()) { } 
# 480
private: std::shared_ptr< rs2_processing_block>  init() 
# 481
{ 
# 482
rs2_error *e = (nullptr); 
# 483
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_sync_processing_block(&e), rs2_delete_processing_block); 
# 487
error::handle(e); 
# 488
return block; 
# 489
} 
# 490
}; 
# 492
class syncer { 
# 498
public: syncer(int queue_size = 1) : _results(queue_size) 
# 500
{ 
# 501
(_sync).start(_results); 
# 502
} 
# 509
frameset wait_for_frames(unsigned timeout_ms = 5000) const 
# 510
{ 
# 511
return ((frameset)((_results).wait_for_frame(timeout_ms))); 
# 512
} 
# 519
bool poll_for_frames(frameset *fs) const 
# 520
{ 
# 521
frame result; 
# 522
if ((_results).poll_for_frame(&result)) 
# 523
{ 
# 524
((*fs) = ((frameset)(result))); 
# 525
return true; 
# 526
}  
# 527
return false; 
# 528
} 
# 536
bool try_wait_for_frames(frameset *fs, unsigned timeout_ms = 5000) const 
# 537
{ 
# 538
frame result; 
# 539
if ((_results).try_wait_for_frame(&result, timeout_ms)) 
# 540
{ 
# 541
((*fs) = ((frameset)(result))); 
# 542
return true; 
# 543
}  
# 544
return false; 
# 545
} 
# 547
void operator()(frame f) const 
# 548
{ 
# 549
(_sync).invoke(std::move(f)); 
# 550
} 
# 552
private: asynchronous_syncer _sync; 
# 553
frame_queue _results; 
# 554
}; 
# 559
class align : public filter { 
# 571 "/usr/local/include/librealsense2/hpp/rs_processing.hpp" 3
public: align(rs2_stream align_to) : filter(this->init(align_to), 1) { } 
# 579
frameset process(frameset frames) 
# 580
{ 
# 581
return this->filter::process(frames); 
# 582
} 
# 585
friend class context; 
# 586
private: std::shared_ptr< rs2_processing_block>  init(rs2_stream align_to) 
# 587
{ 
# 588
rs2_error *e = (nullptr); 
# 589
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_align(align_to, &e), rs2_delete_processing_block); 
# 592
error::handle(e); 
# 594
return block; 
# 595
} 
# 596
}; 
# 598
class colorizer : public filter { 
# 605
public: colorizer() : filter(this->init(), 1) { } 
# 620 "/usr/local/include/librealsense2/hpp/rs_processing.hpp" 3
colorizer(float color_scheme) : filter(this->init(), 1) 
# 621
{ 
# 622
this->set_option(RS2_OPTION_COLOR_SCHEME, (float)color_scheme); 
# 623
} 
# 629
video_frame colorize(frame depth) const 
# 630
{ 
# 631
return this->process(depth); 
# 632
} 
# 635
protected: colorizer(std::shared_ptr< rs2_processing_block>  block) : filter(block, 1) { } 
# 638
private: std::shared_ptr< rs2_processing_block>  init() 
# 639
{ 
# 640
rs2_error *e = (nullptr); 
# 641
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_colorizer(&e), rs2_delete_processing_block); 
# 644
error::handle(e); 
# 649
return block; 
# 650
} 
# 651
}; 
# 653
class decimation_filter : public filter { 
# 660
public: decimation_filter() : filter(this->init(), 1) { } 
# 666
decimation_filter(float magnitude) : filter(this->init(), 1) 
# 667
{ 
# 668
this->set_option(RS2_OPTION_FILTER_MAGNITUDE, magnitude); 
# 669
} 
# 672
friend class context; 
# 674
private: std::shared_ptr< rs2_processing_block>  init() 
# 675
{ 
# 676
rs2_error *e = (nullptr); 
# 677
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_decimation_filter_block(&e), rs2_delete_processing_block); 
# 680
error::handle(e); 
# 685
return block; 
# 686
} 
# 687
}; 
# 689
class temporal_filter : public filter { 
# 698
public: temporal_filter() : filter(this->init(), 1) { } 
# 716 "/usr/local/include/librealsense2/hpp/rs_processing.hpp" 3
temporal_filter(float smooth_alpha, float smooth_delta, int persistence_control) : filter(this->init(), 1) 
# 717
{ 
# 718
this->set_option(RS2_OPTION_HOLES_FILL, (float)persistence_control); 
# 719
this->set_option(RS2_OPTION_FILTER_SMOOTH_ALPHA, (float)smooth_alpha); 
# 720
this->set_option(RS2_OPTION_FILTER_SMOOTH_DELTA, (float)smooth_delta); 
# 721
} 
# 724
friend class context; 
# 726
private: std::shared_ptr< rs2_processing_block>  init() 
# 727
{ 
# 728
rs2_error *e = (nullptr); 
# 729
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_temporal_filter_block(&e), rs2_delete_processing_block); 
# 732
error::handle(e); 
# 737
return block; 
# 738
} 
# 739
}; 
# 741
class spatial_filter : public filter { 
# 751
public: spatial_filter() : filter(this->init(), 1) { } 
# 762 "/usr/local/include/librealsense2/hpp/rs_processing.hpp" 3
spatial_filter(float smooth_alpha, float smooth_delta, float magnitude, float hole_fill) : filter(this->init(), 1) 
# 763
{ 
# 764
this->set_option(RS2_OPTION_FILTER_SMOOTH_ALPHA, (float)smooth_alpha); 
# 765
this->set_option(RS2_OPTION_FILTER_SMOOTH_DELTA, (float)smooth_delta); 
# 766
this->set_option(RS2_OPTION_FILTER_MAGNITUDE, magnitude); 
# 767
this->set_option(RS2_OPTION_HOLES_FILL, hole_fill); 
# 768
} 
# 771
friend class context; 
# 773
private: std::shared_ptr< rs2_processing_block>  init() 
# 774
{ 
# 775
rs2_error *e = (nullptr); 
# 776
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_spatial_filter_block(&e), rs2_delete_processing_block); 
# 779
error::handle(e); 
# 784
return block; 
# 785
} 
# 786
}; 
# 788
class disparity_transform : public filter { 
# 795
public: disparity_transform(bool transform_to_disparity = true) : filter(this->init(transform_to_disparity), 1) { } 
# 798
friend class context; 
# 799
private: std::shared_ptr< rs2_processing_block>  init(bool transform_to_disparity) 
# 800
{ 
# 801
rs2_error *e = (nullptr); 
# 802
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_disparity_transform_block((uint8_t)transform_to_disparity, &e), rs2_delete_processing_block); 
# 805
error::handle(e); 
# 810
return block; 
# 811
} 
# 812
}; 
# 814
class hole_filling_filter : public filter { 
# 821
public: hole_filling_filter() : filter(this->init(), 1) { } 
# 831 "/usr/local/include/librealsense2/hpp/rs_processing.hpp" 3
hole_filling_filter(int mode) : filter(this->init(), 1) 
# 832
{ 
# 833
this->set_option(RS2_OPTION_HOLES_FILL, (float)mode); 
# 834
} 
# 837
friend class context; 
# 839
private: std::shared_ptr< rs2_processing_block>  init() 
# 840
{ 
# 841
rs2_error *e = (nullptr); 
# 842
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_hole_filling_filter_block(&e), rs2_delete_processing_block); 
# 845
error::handle(e); 
# 850
return block; 
# 851
} 
# 852
}; 
# 854
class rates_printer : public filter { 
# 861
public: rates_printer() : filter(this->init(), 1) { } 
# 864
friend class context; 
# 866
private: std::shared_ptr< rs2_processing_block>  init() 
# 867
{ 
# 868
rs2_error *e = (nullptr); 
# 869
auto block = std::shared_ptr< rs2_processing_block> (rs2_create_rates_printer_block(&e), rs2_delete_processing_block); 
# 872
error::handle(e); 
# 874
return block; 
# 875
} 
# 876
}; 
# 877
}
# 11 "/usr/local/include/librealsense2/hpp/rs_context.hpp" 3
namespace rs2 { 
# 13
class event_information { 
# 16
public: event_information(device_list removed, device_list added) : _removed(removed), _added(added) 
# 17
{ } 
# 23
bool was_removed(const device &dev) const 
# 24
{ 
# 25
rs2_error *e = (nullptr); 
# 27
if (!dev) { 
# 28
return false; }  
# 30
auto res = rs2_device_list_contains((_removed).get_list(), dev.get().get(), &e); 
# 31
error::handle(e); 
# 33
return res > 0; 
# 34
} 
# 40
bool was_added(const device &dev) const 
# 41
{ 
# 42
rs2_error *e = (nullptr); 
# 44
if (!dev) { 
# 45
return false; }  
# 47
auto res = rs2_device_list_contains((_added).get_list(), dev.get().get(), &e); 
# 48
error::handle(e); 
# 50
return res > 0; 
# 51
} 
# 57
device_list get_new_devices() const 
# 58
{ 
# 59
return _added; 
# 60
} 
# 63
private: device_list _removed; 
# 64
device_list _added; 
# 65
}; 
# 67
template< class T> 
# 68
class devices_changed_callback : public rs2_devices_changed_callback { 
# 70
T _callback; 
# 73
public: explicit devices_changed_callback(T callback) : _callback(callback) { } 
# 75
virtual void on_devices_changed(rs2_device_list *removed, rs2_device_list *added) override 
# 76
{ 
# 77
std::shared_ptr< rs2_device_list>  old(removed, rs2_delete_device_list); 
# 78
std::shared_ptr< rs2_device_list>  news(added, rs2_delete_device_list); 
# 81
event_information info(((device_list)(old)), ((device_list)(news))); 
# 82
(_callback)(info); 
# 83
} 
# 85
virtual void release() override { delete this; } 
# 86
}; 
# 88
class pipeline; 
# 89
class device_hub; 
# 95
class context { 
# 98
public: context() 
# 99
{ 
# 100
rs2_error *e = (nullptr); 
# 101
((_context) = std::shared_ptr< rs2_context> (rs2_create_context(((2 * 10000) + (18 * 100)) + 1, &e), rs2_delete_context)); 
# 104
error::handle(e); 
# 105
} 
# 111
device_list query_devices() const 
# 112
{ 
# 113
rs2_error *e = (nullptr); 
# 114
std::shared_ptr< rs2_device_list>  list(rs2_query_devices((_context).get(), &e), rs2_delete_device_list); 
# 117
error::handle(e); 
# 119
return ((device_list)(list)); 
# 120
} 
# 126
device_list query_devices(int mask) const 
# 127
{ 
# 128
rs2_error *e = (nullptr); 
# 129
std::shared_ptr< rs2_device_list>  list(rs2_query_devices_ex((_context).get(), mask, &e), rs2_delete_device_list); 
# 132
error::handle(e); 
# 134
return ((device_list)(list)); 
# 135
} 
# 141
std::vector< sensor>  query_all_sensors() const 
# 142
{ 
# 143
std::vector< sensor>  results; 
# 144
for (auto &&dev : this->query_devices()) 
# 145
{ 
# 146
auto sensors = dev.query_sensors(); 
# 147
std::copy(sensors.begin(), sensors.end(), std::back_inserter(results)); 
# 148
}  
# 149
return results; 
# 150
} 
# 153
device get_sensor_parent(const sensor &s) const 
# 154
{ 
# 155
rs2_error *e = (nullptr); 
# 156
std::shared_ptr< rs2_device>  dev(rs2_create_device_from_sensor((s._sensor).get(), &e), rs2_delete_device); 
# 159
error::handle(e); 
# 160
return device{dev}; 
# 161
} 
# 167
template< class T> void 
# 168
set_devices_changed_callback(T callback) 
# 169
{ 
# 170
rs2_error *e = (nullptr); 
# 171
rs2_set_devices_changed_callback_cpp((_context).get(), new devices_changed_callback< T> (std::move(callback)), &e); 
# 173
error::handle(e); 
# 174
} 
# 183 "/usr/local/include/librealsense2/hpp/rs_context.hpp" 3
playback load_device(const std::__cxx11::string &file) 
# 184
{ 
# 185
rs2_error *e = (nullptr); 
# 186
auto device = std::shared_ptr< rs2_device> (rs2_context_add_device((_context).get(), file.c_str(), &e), rs2_delete_device); 
# 189
rs2::error::handle(e); 
# 191
return playback{device}; 
# 192
} 
# 194
void unload_device(const std::__cxx11::string &file) 
# 195
{ 
# 196
rs2_error *e = (nullptr); 
# 197
rs2_context_remove_device((_context).get(), file.c_str(), &e); 
# 198
rs2::error::handle(e); 
# 199
} 
# 201
context(std::shared_ptr< rs2_context>  ctx) : _context(ctx) 
# 203
{ } 
# 204
explicit operator std::shared_ptr< rs2_context> () { return _context; } 
# 206
friend class pipeline; 
# 207
friend class device_hub; 
# 209
protected: std::shared_ptr< rs2_context>  _context; 
# 210
}; 
# 215
class device_hub { 
# 218
public: explicit device_hub(context ctx) 
# 219
{ 
# 220
rs2_error *e = (nullptr); 
# 221
((_device_hub) = std::shared_ptr< rs2_device_hub> (rs2_create_device_hub((ctx._context).get(), &e), rs2_delete_device_hub)); 
# 224
error::handle(e); 
# 225
} 
# 231
device wait_for_device() const 
# 232
{ 
# 233
rs2_error *e = (nullptr); 
# 234
std::shared_ptr< rs2_device>  dev(rs2_device_hub_wait_for_device((_device_hub).get(), &e), rs2_delete_device); 
# 238
error::handle(e); 
# 240
return ((device)(dev)); 
# 242
} 
# 247
bool is_connected(const device &dev) const 
# 248
{ 
# 249
rs2_error *e = (nullptr); 
# 250
auto res = rs2_device_hub_is_device_connected((_device_hub).get(), (dev._dev).get(), &e); 
# 251
error::handle(e); 
# 253
return (res > 0) ? true : false; 
# 255
} 
# 257
explicit operator std::shared_ptr< rs2_device_hub> () { return _device_hub; } 
# 258
explicit device_hub(std::shared_ptr< rs2_device_hub>  hub) : _device_hub(std::move(hub)) { } 
# 260
private: std::shared_ptr< rs2_device_hub>  _device_hub; 
# 261
}; 
# 263
}
# 11 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
namespace rs2 { 
# 18
class pipeline_profile { 
# 22
public: pipeline_profile() : _pipeline_profile(nullptr) { } 
# 29
std::vector< stream_profile>  get_streams() const 
# 30
{ 
# 31
std::vector< stream_profile>  results; 
# 33
rs2_error *e = (nullptr); 
# 34
std::shared_ptr< rs2_stream_profile_list>  list(rs2_pipeline_profile_get_streams((_pipeline_profile).get(), &e), rs2_delete_stream_profiles_list); 
# 37
error::handle(e); 
# 39
auto size = rs2_get_stream_profiles_count(list.get(), &e); 
# 40
error::handle(e); 
# 42
for (auto i = 0; i < size; i++) 
# 43
{ 
# 44
stream_profile profile(rs2_get_stream_profile(list.get(), i, &e)); 
# 45
error::handle(e); 
# 46
results.push_back(profile); 
# 47
}  
# 49
return results; 
# 50
} 
# 60 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
stream_profile get_stream(rs2_stream stream_type, int stream_index = -1) const 
# 61
{ 
# 62
for (auto &&s : this->get_streams()) 
# 63
{ 
# 64
if (((s.stream_type()) == stream_type) && ((stream_index == (-1)) || (s.stream_index() == stream_index))) 
# 65
{ 
# 66
return s; 
# 67
}  
# 68
}  
# 69
throw ((std::runtime_error)("Profile does not contain the requested stream")); 
# 70
} 
# 83 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
device get_device() const 
# 84
{ 
# 85
rs2_error *e = (nullptr); 
# 86
std::shared_ptr< rs2_device>  dev(rs2_pipeline_profile_get_device((_pipeline_profile).get(), &e), rs2_delete_device); 
# 90
error::handle(e); 
# 92
return ((device)(dev)); 
# 93
} 
# 100
operator bool() const 
# 101
{ 
# 102
return ((_pipeline_profile) != (nullptr)); 
# 103
} 
# 105
explicit operator std::shared_ptr< rs2_pipeline_profile> () { return _pipeline_profile; } 
# 106
pipeline_profile(std::shared_ptr< rs2_pipeline_profile>  profile) : _pipeline_profile(profile) 
# 107
{ } 
# 110
private: std::shared_ptr< rs2_pipeline_profile>  _pipeline_profile; 
# 111
friend class config; 
# 112
friend class pipeline; 
# 113
}; 
# 115
class pipeline; 
# 124 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
class config { 
# 127
public: config() 
# 128
{ 
# 129
rs2_error *e = (nullptr); 
# 130
((_config) = std::shared_ptr< rs2_config> (rs2_create_config(&e), rs2_delete_config)); 
# 133
error::handle(e); 
# 134
} 
# 156 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
void enable_stream(rs2_stream stream_type, int stream_index, int width, int height, rs2_format format = RS2_FORMAT_ANY, int framerate = 0) 
# 157
{ 
# 158
rs2_error *e = (nullptr); 
# 159
rs2_config_enable_stream((_config).get(), stream_type, stream_index, width, height, format, framerate, &e); 
# 160
error::handle(e); 
# 161
} 
# 164
void enable_stream(rs2_stream stream_type, int stream_index = -1) 
# 165
{ 
# 166
this->enable_stream(stream_type, stream_index, 0, 0, RS2_FORMAT_ANY, 0); 
# 167
} 
# 170
void enable_stream(rs2_stream stream_type, int width, int height, rs2_format format = RS2_FORMAT_ANY, int framerate = 0) 
# 171
{ 
# 172
this->enable_stream(stream_type, -1, width, height, format, framerate); 
# 173
} 
# 176
void enable_stream(rs2_stream stream_type, rs2_format format, int framerate = 0) 
# 177
{ 
# 178
this->enable_stream(stream_type, -1, 0, 0, format, framerate); 
# 179
} 
# 182
void enable_stream(rs2_stream stream_type, int stream_index, rs2_format format, int framerate = 0) 
# 183
{ 
# 184
this->enable_stream(stream_type, stream_index, 0, 0, format, framerate); 
# 185
} 
# 193
void enable_all_streams() 
# 194
{ 
# 195
rs2_error *e = (nullptr); 
# 196
rs2_config_enable_all_stream((_config).get(), &e); 
# 197
error::handle(e); 
# 198
} 
# 208 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
void enable_device(const std::__cxx11::string &serial) 
# 209
{ 
# 210
rs2_error *e = (nullptr); 
# 211
rs2_config_enable_device((_config).get(), serial.c_str(), &e); 
# 212
error::handle(e); 
# 213
} 
# 223 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
void enable_device_from_file(const std::__cxx11::string &file_name, bool repeat_playback = true) 
# 224
{ 
# 225
rs2_error *e = (nullptr); 
# 226
rs2_config_enable_device_from_file_repeat_option((_config).get(), file_name.c_str(), repeat_playback, &e); 
# 227
error::handle(e); 
# 228
} 
# 237 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
void enable_record_to_file(const std::__cxx11::string &file_name) 
# 238
{ 
# 239
rs2_error *e = (nullptr); 
# 240
rs2_config_enable_record_to_file((_config).get(), file_name.c_str(), &e); 
# 241
error::handle(e); 
# 242
} 
# 251 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
void disable_stream(rs2_stream stream, int index = -1) 
# 252
{ 
# 253
rs2_error *e = (nullptr); 
# 254
rs2_config_disable_indexed_stream((_config).get(), stream, index, &e); 
# 255
error::handle(e); 
# 256
} 
# 263
void disable_all_streams() 
# 264
{ 
# 265
rs2_error *e = (nullptr); 
# 266
rs2_config_disable_all_streams((_config).get(), &e); 
# 267
error::handle(e); 
# 268
} 
# 288 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
pipeline_profile resolve(std::shared_ptr< rs2_pipeline>  p) const 
# 289
{ 
# 290
rs2_error *e = (nullptr); 
# 291
auto profile = std::shared_ptr< rs2_pipeline_profile> (rs2_config_resolve((_config).get(), p.get(), &e), rs2_delete_pipeline_profile); 
# 295
error::handle(e); 
# 296
return ((pipeline_profile)(profile)); 
# 297
} 
# 306 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
bool can_resolve(std::shared_ptr< rs2_pipeline>  p) const 
# 307
{ 
# 308
rs2_error *e = (nullptr); 
# 309
int res = rs2_config_can_resolve((_config).get(), p.get(), &e); 
# 310
error::handle(e); 
# 311
return res != 0; 
# 312
} 
# 314
std::shared_ptr< rs2_config>  get() const 
# 315
{ 
# 316
return _config; 
# 317
} 
# 318
explicit operator std::shared_ptr< rs2_config> () const 
# 319
{ 
# 320
return _config; 
# 321
} 
# 323
config(std::shared_ptr< rs2_config>  cfg) : _config(cfg) { } 
# 325
private: std::shared_ptr< rs2_config>  _config; 
# 326
}; 
# 336 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
class pipeline { 
# 346
public: pipeline(context ctx = context()) 
# 347
{ 
# 348
rs2_error *e = (nullptr); 
# 349
((_pipeline) = std::shared_ptr< rs2_pipeline> (rs2_create_pipeline((ctx._context).get(), &e), rs2_delete_pipeline)); 
# 352
error::handle(e); 
# 353
} 
# 366 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
pipeline_profile start() 
# 367
{ 
# 368
rs2_error *e = (nullptr); 
# 369
auto p = std::shared_ptr< rs2_pipeline_profile> (rs2_pipeline_start((_pipeline).get(), &e), rs2_delete_pipeline_profile); 
# 373
error::handle(e); 
# 374
return ((pipeline_profile)(p)); 
# 375
} 
# 395 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
pipeline_profile start(const class config &config) 
# 396
{ 
# 397
rs2_error *e = (nullptr); 
# 398
auto p = std::shared_ptr< rs2_pipeline_profile> (rs2_pipeline_start_with_config((_pipeline).get(), (config.get()).get(), &e), rs2_delete_pipeline_profile); 
# 402
error::handle(e); 
# 403
return ((pipeline_profile)(p)); 
# 404
} 
# 415 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
template< class S> pipeline_profile 
# 416
start(S callback) 
# 417
{ 
# 418
rs2_error *e = (nullptr); 
# 419
auto p = std::shared_ptr< rs2_pipeline_profile> (rs2_pipeline_start_with_callback_cpp((_pipeline).get(), new frame_callback< S> (callback), &e), rs2_delete_pipeline_profile); 
# 423
error::handle(e); 
# 424
return ((pipeline_profile)(p)); 
# 425
} 
# 443 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
template< class S> pipeline_profile 
# 444
start(const class config &config, S callback) 
# 445
{ 
# 446
rs2_error *e = (nullptr); 
# 447
auto p = std::shared_ptr< rs2_pipeline_profile> (rs2_pipeline_start_with_config_and_callback_cpp((_pipeline).get(), (config.get()).get(), new frame_callback< S> (callback), &e), rs2_delete_pipeline_profile); 
# 451
error::handle(e); 
# 452
return ((pipeline_profile)(p)); 
# 453
} 
# 462 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
void stop() 
# 463
{ 
# 464
rs2_error *e = (nullptr); 
# 465
rs2_pipeline_stop((_pipeline).get(), &e); 
# 466
error::handle(e); 
# 467
} 
# 484 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
frameset wait_for_frames(unsigned timeout_ms = 5000) const 
# 485
{ 
# 486
rs2_error *e = (nullptr); 
# 487
frame f(rs2_pipeline_wait_for_frames((_pipeline).get(), timeout_ms, &e)); 
# 488
error::handle(e); 
# 490
return ((frameset)(f)); 
# 491
} 
# 507 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
bool poll_for_frames(frameset *f) const 
# 508
{ 
# 509
if (!f) 
# 510
{ 
# 511
throw ((std::invalid_argument)("null frameset")); 
# 512
}  
# 513
rs2_error *e = (nullptr); 
# 514
rs2_frame *frame_ref = (nullptr); 
# 515
auto res = rs2_pipeline_poll_for_frames((_pipeline).get(), &frame_ref, &e); 
# 516
error::handle(e); 
# 518
if (res) { ((*f) = ((frameset)(((frame)(frame_ref))))); }  
# 519
return res > 0; 
# 520
} 
# 522
bool try_wait_for_frames(frameset *f, unsigned timeout_ms = 5000) const 
# 523
{ 
# 524
if (!f) 
# 525
{ 
# 526
throw ((std::invalid_argument)("null frameset")); 
# 527
}  
# 528
rs2_error *e = (nullptr); 
# 529
rs2_frame *frame_ref = (nullptr); 
# 530
auto res = rs2_pipeline_try_wait_for_frames((_pipeline).get(), &frame_ref, timeout_ms, &e); 
# 531
error::handle(e); 
# 532
if (res) { ((*f) = ((frameset)(((frame)(frame_ref))))); }  
# 533
return res > 0; 
# 534
} 
# 545 "/usr/local/include/librealsense2/hpp/rs_pipeline.hpp" 3
pipeline_profile get_active_profile() const 
# 546
{ 
# 547
rs2_error *e = (nullptr); 
# 548
auto p = std::shared_ptr< rs2_pipeline_profile> (rs2_pipeline_get_active_profile((_pipeline).get(), &e), rs2_delete_pipeline_profile); 
# 552
error::handle(e); 
# 553
return ((pipeline_profile)(p)); 
# 554
} 
# 556
operator std::shared_ptr< rs2_pipeline> () const 
# 557
{ 
# 558
return _pipeline; 
# 559
} 
# 560
explicit pipeline(std::shared_ptr< rs2_pipeline>  ptr) : _pipeline(ptr) { } 
# 563
private: std::shared_ptr< rs2_pipeline>  _pipeline; 
# 564
friend class config; 
# 565
}; 
# 566
}
# 17 "/usr/local/include/librealsense2/rs.hpp" 3
namespace rs2 { 
# 19
inline void log_to_console(rs2_log_severity min_severity) 
# 20
{ 
# 21
rs2_error *e = (nullptr); 
# 22
rs2_log_to_console(min_severity, &e); 
# 23
error::handle(e); 
# 24
} 
# 26
inline void log_to_file(rs2_log_severity min_severity, const char *file_path = 0) 
# 27
{ 
# 28
rs2_error *e = (nullptr); 
# 29
rs2_log_to_file(min_severity, file_path, &e); 
# 30
error::handle(e); 
# 31
} 
# 33
inline void log(rs2_log_severity severity, const char *message) 
# 34
{ 
# 35
rs2_error *e = (nullptr); 
# 36
rs2_log(severity, message, &e); 
# 37
error::handle(e); 
# 38
} 
# 39
}
# 41
inline std::ostream &operator<<(std::ostream &o, rs2_stream stream) { return (o << (rs2_stream_to_string(stream))); } 
# 42
inline std::ostream &operator<<(std::ostream &o, rs2_format format) { return (o << (rs2_format_to_string(format))); } 
# 43
inline std::ostream &operator<<(std::ostream &o, rs2_distortion distortion) { return (o << (rs2_distortion_to_string(distortion))); } 
# 44
inline std::ostream &operator<<(std::ostream &o, rs2_option option) { return (o << (rs2_option_to_string(option))); } 
# 45
inline std::ostream &operator<<(std::ostream &o, rs2_log_severity severity) { return (o << (rs2_log_severity_to_string(severity))); } 
# 46
inline std::ostream &operator<<(std::ostream &o, rs2_camera_info camera_info) { return (o << (rs2_camera_info_to_string(camera_info))); } 
# 47
inline std::ostream &operator<<(std::ostream &o, rs2_frame_metadata_value metadata) { return (o << (rs2_frame_metadata_to_string(metadata))); } 
# 48
inline std::ostream &operator<<(std::ostream &o, rs2_timestamp_domain domain) { return (o << (rs2_timestamp_domain_to_string(domain))); } 
# 49
inline std::ostream &operator<<(std::ostream &o, rs2_notification_category notificaton) { return (o << (rs2_notification_category_to_string(notificaton))); } 
# 50
inline std::ostream &operator<<(std::ostream &o, rs2_sr300_visual_preset preset) { return (o << (rs2_sr300_visual_preset_to_string(preset))); } 
# 51
inline std::ostream &operator<<(std::ostream &o, rs2_exception_type exception_type) { return (o << (rs2_exception_type_to_string(exception_type))); } 
# 52
inline std::ostream &operator<<(std::ostream &o, rs2_playback_status status) { return (o << (rs2_playback_status_to_string(status))); } 
# 66 "/usr/include/assert.h" 3
extern "C" {
# 69
extern void __assert_fail(const char * __assertion, const char * __file, unsigned __line, const char * __function) throw()
# 71
 __attribute((__noreturn__)); 
# 74
extern void __assert_perror_fail(int __errnum, const char * __file, unsigned __line, const char * __function) throw()
# 76
 __attribute((__noreturn__)); 
# 81
extern void __assert(const char * __assertion, const char * __file, int __line) throw()
# 82
 __attribute((__noreturn__)); 
# 85
}
# 18 "/usr/local/include/librealsense2/rsutil.h" 3
static void rs2_project_point_to_pixel(float pixel[2], const rs2_intrinsics *intrin, const float point[3]) 
# 19
{ 
# 22
float x = (point[0]) / (point[2]), y = (point[1]) / (point[2]); 
# 24
if ((intrin->model) == (RS2_DISTORTION_MODIFIED_BROWN_CONRADY)) 
# 25
{ 
# 27
float r2 = (x * x) + (y * y); 
# 28
float f = (((1) + (((intrin->coeffs)[0]) * r2)) + ((((intrin->coeffs)[1]) * r2) * r2)) + (((((intrin->coeffs)[4]) * r2) * r2) * r2); 
# 29
x *= f; 
# 30
y *= f; 
# 31
float dx = (x + ((((2) * ((intrin->coeffs)[2])) * x) * y)) + (((intrin->coeffs)[3]) * (r2 + (((2) * x) * x))); 
# 32
float dy = (y + ((((2) * ((intrin->coeffs)[3])) * x) * y)) + (((intrin->coeffs)[2]) * (r2 + (((2) * y) * y))); 
# 33
x = dx; 
# 34
y = dy; 
# 35
}  
# 36
if ((intrin->model) == (RS2_DISTORTION_FTHETA)) 
# 37
{ 
# 38
float r = sqrtf((x * x) + (y * y)); 
# 39
float rd = (float)(((1.0F) / ((intrin->coeffs)[0])) * atan(((2) * r) * tan(((intrin->coeffs)[0]) / (2.0F)))); 
# 40
x *= (rd / r); 
# 41
y *= (rd / r); 
# 42
}  
# 44
(pixel[0]) = ((x * (intrin->fx)) + (intrin->ppx)); 
# 45
(pixel[1]) = ((y * (intrin->fy)) + (intrin->ppy)); 
# 46
} 
# 49
static void rs2_deproject_pixel_to_point(float point[3], const rs2_intrinsics *intrin, const float pixel[2], float depth) 
# 50
{ 
# 51
((intrin->model) != (RS2_DISTORTION_MODIFIED_BROWN_CONRADY)) ? static_cast< void>(0) : __assert_fail("intrin->model != RS2_DISTORTION_MODIFIED_BROWN_CONRADY", "/usr/local/include/librealsense2/rsutil.h", 51, __PRETTY_FUNCTION__); 
# 52
((intrin->model) != (RS2_DISTORTION_FTHETA)) ? static_cast< void>(0) : __assert_fail("intrin->model != RS2_DISTORTION_FTHETA", "/usr/local/include/librealsense2/rsutil.h", 52, __PRETTY_FUNCTION__); 
# 55
float x = ((pixel[0]) - (intrin->ppx)) / (intrin->fx); 
# 56
float y = ((pixel[1]) - (intrin->ppy)) / (intrin->fy); 
# 57
if ((intrin->model) == (RS2_DISTORTION_INVERSE_BROWN_CONRADY)) 
# 58
{ 
# 59
float r2 = (x * x) + (y * y); 
# 60
float f = (((1) + (((intrin->coeffs)[0]) * r2)) + ((((intrin->coeffs)[1]) * r2) * r2)) + (((((intrin->coeffs)[4]) * r2) * r2) * r2); 
# 61
float ux = ((x * f) + ((((2) * ((intrin->coeffs)[2])) * x) * y)) + (((intrin->coeffs)[3]) * (r2 + (((2) * x) * x))); 
# 62
float uy = ((y * f) + ((((2) * ((intrin->coeffs)[3])) * x) * y)) + (((intrin->coeffs)[2]) * (r2 + (((2) * y) * y))); 
# 63
x = ux; 
# 64
y = uy; 
# 65
}  
# 66
(point[0]) = (depth * x); 
# 67
(point[1]) = (depth * y); 
# 68
(point[2]) = depth; 
# 69
} 
# 72
static void rs2_transform_point_to_point(float to_point[3], const rs2_extrinsics *extrin, const float from_point[3]) 
# 73
{ 
# 74
(to_point[0]) = ((((((extrin->rotation)[0]) * (from_point[0])) + (((extrin->rotation)[3]) * (from_point[1]))) + (((extrin->rotation)[6]) * (from_point[2]))) + ((extrin->translation)[0])); 
# 75
(to_point[1]) = ((((((extrin->rotation)[1]) * (from_point[0])) + (((extrin->rotation)[4]) * (from_point[1]))) + (((extrin->rotation)[7]) * (from_point[2]))) + ((extrin->translation)[1])); 
# 76
(to_point[2]) = ((((((extrin->rotation)[2]) * (from_point[0])) + (((extrin->rotation)[5]) * (from_point[1]))) + (((extrin->rotation)[8]) * (from_point[2]))) + ((extrin->translation)[2])); 
# 77
} 
# 80
static void rs2_fov(const rs2_intrinsics *intrin, float to_fov[2]) 
# 81
{ 
# 82
(to_fov[0]) = ((atan2f((intrin->ppx) + (0.5F), intrin->fx) + atan2f((intrin->width) - ((intrin->ppx) + (0.5F)), intrin->fx)) * (57.29578018F)); 
# 83
(to_fov[1]) = ((atan2f((intrin->ppy) + (0.5F), intrin->fy) + atan2f((intrin->height) - ((intrin->ppy) + (0.5F)), intrin->fy)) * (57.29578018F)); 
# 84
} 
# 86
static void next_pixel_in_line(float curr[2], const float start[2], const float end[2]) 
# 87
{ 
# 88
float line_slope = ((end[1]) - (start[1])) / ((end[0]) - (start[0])); 
# 89
if (abs((end[0]) - (curr[0])) > abs((end[1]) - (curr[1]))) 
# 90
{ 
# 91
(curr[0]) = (((end[0]) > (curr[0])) ? (curr[0]) + (1) : ((curr[0]) - (1))); 
# 92
(curr[1]) = ((end[1]) - (line_slope * ((end[0]) - (curr[0])))); 
# 93
} else 
# 95
{ 
# 96
(curr[1]) = (((end[1]) > (curr[1])) ? (curr[1]) + (1) : ((curr[1]) - (1))); 
# 97
(curr[0]) = ((end[0]) - (((end[1]) + (curr[1])) / line_slope)); 
# 98
}  
# 99
} 
# 101
static bool is_pixel_in_line(const float curr[2], const float start[2], const float end[2]) 
# 102
{ 
# 103
return ((((end[0]) >= (start[0])) && ((end[0]) >= (curr[0])) && ((curr[0]) >= (start[0]))) || (((end[0]) <= (start[0])) && ((end[0]) <= (curr[0])) && ((curr[0]) <= (start[0])))) && ((((end[1]) >= (start[1])) && ((end[1]) >= (curr[1])) && ((curr[1]) >= (start[1]))) || (((end[1]) <= (start[1])) && ((end[1]) <= (curr[1])) && ((curr[1]) <= (start[1])))); 
# 105
} 
# 107
static void adjust_2D_point_to_boundary(float p[2], int width, int height) 
# 108
{ 
# 109
if ((p[0]) < (0)) { (p[0]) = (0); }  
# 110
if ((p[0]) > width) { (p[0]) = ((float)width); }  
# 111
if ((p[1]) < (0)) { (p[1]) = (0); }  
# 112
if ((p[1]) > height) { (p[1]) = ((float)height); }  
# 113
} 
# 116
static void rs2_project_color_pixel_to_depth_pixel(float to_pixel[2], const uint16_t *
# 117
data, float depth_scale, float 
# 118
depth_min, float depth_max, const rs2_intrinsics *
# 119
depth_intrin, const rs2_intrinsics *
# 120
color_intrin, const rs2_extrinsics *
# 121
color_to_depth, const rs2_extrinsics *
# 122
depth_to_color, const float 
# 123
from_pixel[2]) 
# 124
{ 
# 126
float start_pixel[2] = {(0)}, min_point[3] = {(0)}, min_transformed_point[3] = {(0)}; 
# 127
rs2_deproject_pixel_to_point(min_point, color_intrin, from_pixel, depth_min); 
# 128
rs2_transform_point_to_point(min_transformed_point, color_to_depth, min_point); 
# 129
rs2_project_point_to_pixel(start_pixel, depth_intrin, min_transformed_point); 
# 130
adjust_2D_point_to_boundary(start_pixel, depth_intrin->width, depth_intrin->height); 
# 133
float end_pixel[2] = {(0)}, max_point[3] = {(0)}, max_transformed_point[3] = {(0)}; 
# 134
rs2_deproject_pixel_to_point(max_point, color_intrin, from_pixel, depth_max); 
# 135
rs2_transform_point_to_point(max_transformed_point, color_to_depth, max_point); 
# 136
rs2_project_point_to_pixel(end_pixel, depth_intrin, max_transformed_point); 
# 137
adjust_2D_point_to_boundary(end_pixel, depth_intrin->width, depth_intrin->height); 
# 140
float min_dist = (-1); 
# 141
for (float p[2] = {(start_pixel)[0], (start_pixel)[1]}; is_pixel_in_line(p, start_pixel, end_pixel); next_pixel_in_line(p, start_pixel, end_pixel)) { 
# 142
{ 
# 143
float depth = depth_scale * (data[(((int)((p)[1])) * (depth_intrin->width)) + ((int)((p)[0]))]); 
# 144
if (depth == (0)) { 
# 145
continue; }  
# 147
float projected_pixel[2] = {(0)}, point[3] = {(0)}, transformed_point[3] = {(0)}; 
# 148
rs2_deproject_pixel_to_point(point, depth_intrin, p, depth); 
# 149
rs2_transform_point_to_point(transformed_point, depth_to_color, point); 
# 150
rs2_project_point_to_pixel(projected_pixel, color_intrin, transformed_point); 
# 152
float new_dist = pow(((projected_pixel)[1]) - (from_pixel[1]), 2) + pow(((projected_pixel)[0]) - (from_pixel[0]), 2); 
# 153
if ((new_dist < min_dist) || (min_dist < (0))) 
# 154
{ 
# 155
min_dist = new_dist; 
# 156
(to_pixel[0]) = ((p)[0]); 
# 157
(to_pixel[1]) = ((p)[1]); 
# 158
}  
# 159
} }  
# 160
} 
# 48 "/usr/include/c++/5/cstddef" 3
namespace std { 
# 51
using ::max_align_t;
# 52
}
# 35 "/usr/include/opencv2/core/hal/interface.h" 3
extern "C" { typedef uint32_t uint; }
# 44 "/usr/include/opencv2/core/hal/interface.h" 3
typedef signed char schar; 
# 47
typedef unsigned char uchar; 
# 48
extern "C" { typedef unsigned short ushort; }
# 57 "/usr/include/opencv2/core/hal/interface.h" 3
typedef int64_t int64; 
# 58
typedef uint64_t uint64; 
# 163 "/usr/include/opencv2/core/cvdef.h" 3
enum CpuFeatures { 
# 164
CPU_MMX = 1, 
# 165
CPU_SSE, 
# 166
CPU_SSE2, 
# 167
CPU_SSE3, 
# 168
CPU_SSSE3, 
# 169
CPU_SSE4_1, 
# 170
CPU_SSE4_2, 
# 171
CPU_POPCNT, 
# 172
CPU_FP16, 
# 173
CPU_AVX, 
# 174
CPU_AVX2, 
# 175
CPU_FMA3, 
# 177
CPU_AVX_512F, 
# 178
CPU_AVX_512BW, 
# 179
CPU_AVX_512CD, 
# 180
CPU_AVX_512DQ, 
# 181
CPU_AVX_512ER, 
# 182
CPU_AVX_512IFMA512, 
# 183
CPU_AVX_512PF, 
# 184
CPU_AVX_512VBMI, 
# 185
CPU_AVX_512VL, 
# 187
CPU_NEON = 100, 
# 189
CPU_VSX = 200
# 190
}; 
# 221 "/usr/include/opencv2/core/cvdef.h" 3
typedef 
# 208
union Cv16suf { 
# 210
short i; 
# 214
struct _fp16Format { 
# 216
unsigned significand:10; 
# 217
unsigned exponent:5; 
# 218
unsigned sign:1; 
# 219
} fmt; 
# 221
} Cv16suf; 
# 235
typedef 
# 223
union Cv32suf { 
# 225
int i; 
# 226
unsigned u; 
# 227
float f; 
# 228
struct _fp32Format { 
# 230
unsigned significand:23; 
# 231
unsigned exponent:8; 
# 232
unsigned sign:1; 
# 233
} fmt; 
# 235
} Cv32suf; 
# 243
typedef 
# 237
union Cv64suf { 
# 239
int64 i; 
# 240
uint64 u; 
# 241
double f; 
# 243
} Cv64suf; 
# 42 "/usr/include/c++/5/bits/algorithmfwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 194 "/usr/include/c++/5/bits/algorithmfwd.h" 3
template< class _IIter, class _Predicate> inline bool all_of(_IIter, _IIter, _Predicate); 
# 198
template< class _IIter, class _Predicate> inline bool any_of(_IIter, _IIter, _Predicate); 
# 203
template< class _FIter, class _Tp> bool binary_search(_FIter, _FIter, const _Tp &); 
# 207
template< class _FIter, class _Tp, class _Compare> bool binary_search(_FIter, _FIter, const _Tp &, _Compare); 
# 211
template< class _IIter, class _OIter> inline _OIter copy(_IIter, _IIter, _OIter); 
# 215
template< class _BIter1, class _BIter2> inline _BIter2 copy_backward(_BIter1, _BIter1, _BIter2); 
# 220
template< class _IIter, class _OIter, class _Predicate> _OIter copy_if(_IIter, _IIter, _OIter, _Predicate); 
# 224
template< class _IIter, class _Size, class _OIter> inline _OIter copy_n(_IIter, _Size, _OIter); 
# 232
template< class _FIter, class _Tp> inline pair< _FIter, _FIter>  equal_range(_FIter, _FIter, const _Tp &); 
# 236
template< class _FIter, class _Tp, class _Compare> inline pair< _FIter, _FIter>  equal_range(_FIter, _FIter, const _Tp &, _Compare); 
# 240
template< class _FIter, class _Tp> inline void fill(_FIter, _FIter, const _Tp &); 
# 244
template< class _OIter, class _Size, class _Tp> inline _OIter fill_n(_OIter, _Size, const _Tp &); 
# 250
template< class _FIter1, class _FIter2> inline _FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2); 
# 254
template< class _FIter1, class _FIter2, class _BinaryPredicate> inline _FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate); 
# 262
template< class _IIter, class _Predicate> inline _IIter find_if_not(_IIter, _IIter, _Predicate); 
# 271
template< class _IIter1, class _IIter2> inline bool includes(_IIter1, _IIter1, _IIter2, _IIter2); 
# 275
template< class _IIter1, class _IIter2, class _Compare> inline bool includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare); 
# 279
template< class _BIter> inline void inplace_merge(_BIter, _BIter, _BIter); 
# 283
template< class _BIter, class _Compare> inline void inplace_merge(_BIter, _BIter, _BIter, _Compare); 
# 288
template< class _RAIter> inline bool is_heap(_RAIter, _RAIter); 
# 292
template< class _RAIter, class _Compare> inline bool is_heap(_RAIter, _RAIter, _Compare); 
# 296
template< class _RAIter> inline _RAIter is_heap_until(_RAIter, _RAIter); 
# 300
template< class _RAIter, class _Compare> inline _RAIter is_heap_until(_RAIter, _RAIter, _Compare); 
# 304
template< class _IIter, class _Predicate> inline bool is_partitioned(_IIter, _IIter, _Predicate); 
# 308
template< class _FIter1, class _FIter2> inline bool is_permutation(_FIter1, _FIter1, _FIter2); 
# 312
template< class _FIter1, class _FIter2, class 
# 313
_BinaryPredicate> inline bool 
# 312
is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate); 
# 317
template< class _FIter> inline bool is_sorted(_FIter, _FIter); 
# 321
template< class _FIter, class _Compare> inline bool is_sorted(_FIter, _FIter, _Compare); 
# 325
template< class _FIter> inline _FIter is_sorted_until(_FIter, _FIter); 
# 329
template< class _FIter, class _Compare> inline _FIter is_sorted_until(_FIter, _FIter, _Compare); 
# 334
template< class _FIter1, class _FIter2> inline void iter_swap(_FIter1, _FIter2); 
# 338
template< class _FIter, class _Tp> inline _FIter lower_bound(_FIter, _FIter, const _Tp &); 
# 342
template< class _FIter, class _Tp, class _Compare> inline _FIter lower_bound(_FIter, _FIter, const _Tp &, _Compare); 
# 346
template< class _RAIter> inline void make_heap(_RAIter, _RAIter); 
# 350
template< class _RAIter, class _Compare> inline void make_heap(_RAIter, _RAIter, _Compare); 
# 354
template< class _Tp> inline const _Tp &max(const _Tp &, const _Tp &); 
# 359
template< class _Tp, class _Compare> inline const _Tp &max(const _Tp &, const _Tp &, _Compare); 
# 367
template< class _Tp> inline const _Tp &min(const _Tp &, const _Tp &); 
# 372
template< class _Tp, class _Compare> inline const _Tp &min(const _Tp &, const _Tp &, _Compare); 
# 380
template< class _Tp> inline pair< const _Tp &, const _Tp &>  minmax(const _Tp &, const _Tp &); 
# 385
template< class _Tp, class _Compare> inline pair< const _Tp &, const _Tp &>  minmax(const _Tp &, const _Tp &, _Compare); 
# 390
template< class _FIter> inline pair< _FIter, _FIter>  minmax_element(_FIter, _FIter); 
# 395
template< class _FIter, class _Compare> inline pair< _FIter, _FIter>  minmax_element(_FIter, _FIter, _Compare); 
# 400
template< class _Tp> inline _Tp min(initializer_list< _Tp> ); 
# 405
template< class _Tp, class _Compare> inline _Tp min(initializer_list< _Tp> , _Compare); 
# 410
template< class _Tp> inline _Tp max(initializer_list< _Tp> ); 
# 415
template< class _Tp, class _Compare> inline _Tp max(initializer_list< _Tp> , _Compare); 
# 420
template< class _Tp> inline pair< _Tp, _Tp>  minmax(initializer_list< _Tp> ); 
# 425
template< class _Tp, class _Compare> inline pair< _Tp, _Tp>  minmax(initializer_list< _Tp> , _Compare); 
# 433
template< class _BIter> inline bool next_permutation(_BIter, _BIter); 
# 437
template< class _BIter, class _Compare> inline bool next_permutation(_BIter, _BIter, _Compare); 
# 442
template< class _IIter, class _Predicate> inline bool none_of(_IIter, _IIter, _Predicate); 
# 450
template< class _IIter, class _RAIter> inline _RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter); 
# 454
template< class _IIter, class _RAIter, class _Compare> inline _RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare); 
# 461
template< class _IIter, class _OIter1, class 
# 462
_OIter2, class _Predicate> pair< _OIter1, _OIter2>  
# 461
partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate); 
# 466
template< class _FIter, class _Predicate> _FIter partition_point(_FIter, _FIter, _Predicate); 
# 471
template< class _RAIter> inline void pop_heap(_RAIter, _RAIter); 
# 475
template< class _RAIter, class _Compare> inline void pop_heap(_RAIter, _RAIter, _Compare); 
# 479
template< class _BIter> inline bool prev_permutation(_BIter, _BIter); 
# 483
template< class _BIter, class _Compare> inline bool prev_permutation(_BIter, _BIter, _Compare); 
# 487
template< class _RAIter> inline void push_heap(_RAIter, _RAIter); 
# 491
template< class _RAIter, class _Compare> inline void push_heap(_RAIter, _RAIter, _Compare); 
# 497
template< class _FIter, class _Tp> inline _FIter remove(_FIter, _FIter, const _Tp &); 
# 501
template< class _FIter, class _Predicate> inline _FIter remove_if(_FIter, _FIter, _Predicate); 
# 505
template< class _IIter, class _OIter, class _Tp> inline _OIter remove_copy(_IIter, _IIter, _OIter, const _Tp &); 
# 509
template< class _IIter, class _OIter, class _Predicate> inline _OIter remove_copy_if(_IIter, _IIter, _OIter, _Predicate); 
# 515
template< class _IIter, class _OIter, class _Tp> inline _OIter replace_copy(_IIter, _IIter, _OIter, const _Tp &, const _Tp &); 
# 519
template< class _Iter, class _OIter, class _Predicate, class _Tp> inline _OIter replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp &); 
# 525
template< class _BIter> inline void reverse(_BIter, _BIter); 
# 529
template< class _BIter, class _OIter> _OIter reverse_copy(_BIter, _BIter, _OIter); 
# 533
inline namespace _V2 { 
# 535
template< class _FIter> inline _FIter rotate(_FIter, _FIter, _FIter); 
# 538
}
# 540
template< class _FIter, class _OIter> inline _OIter rotate_copy(_FIter, _FIter, _FIter, _OIter); 
# 552 "/usr/include/c++/5/bits/algorithmfwd.h" 3
template< class _RAIter, class _UGenerator> void shuffle(_RAIter, _RAIter, _UGenerator &&); 
# 557
template< class _RAIter> inline void sort_heap(_RAIter, _RAIter); 
# 561
template< class _RAIter, class _Compare> inline void sort_heap(_RAIter, _RAIter, _Compare); 
# 565
template< class _BIter, class _Predicate> inline _BIter stable_partition(_BIter, _BIter, _Predicate); 
# 569
template< class _Tp> inline void swap(_Tp &, _Tp &) noexcept(__and_< is_nothrow_move_constructible< _Tp> , is_nothrow_move_assignable< _Tp> > ::value); 
# 578
template< class _Tp, size_t _Nm> inline void swap(_Tp (& __a)[_Nm], _Tp (& __b)[_Nm]) noexcept(noexcept(swap(*(__a), *(__b)))); 
# 586
template< class _FIter1, class _FIter2> _FIter2 swap_ranges(_FIter1, _FIter1, _FIter2); 
# 592
template< class _FIter> inline _FIter unique(_FIter, _FIter); 
# 596
template< class _FIter, class _BinaryPredicate> inline _FIter unique(_FIter, _FIter, _BinaryPredicate); 
# 602
template< class _FIter, class _Tp> inline _FIter upper_bound(_FIter, _FIter, const _Tp &); 
# 606
template< class _FIter, class _Tp, class _Compare> inline _FIter upper_bound(_FIter, _FIter, const _Tp &, _Compare); 
# 614
template< class _FIter> inline _FIter adjacent_find(_FIter, _FIter); 
# 618
template< class _FIter, class _BinaryPredicate> inline _FIter adjacent_find(_FIter, _FIter, _BinaryPredicate); 
# 622
template< class _IIter, class _Tp> inline typename iterator_traits< _IIter> ::difference_type count(_IIter, _IIter, const _Tp &); 
# 626
template< class _IIter, class _Predicate> inline typename iterator_traits< _IIter> ::difference_type count_if(_IIter, _IIter, _Predicate); 
# 630
template< class _IIter1, class _IIter2> inline bool equal(_IIter1, _IIter1, _IIter2); 
# 634
template< class _IIter1, class _IIter2, class _BinaryPredicate> inline bool equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate); 
# 638
template< class _IIter, class _Tp> inline _IIter find(_IIter, _IIter, const _Tp &); 
# 642
template< class _FIter1, class _FIter2> _FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2); 
# 646
template< class _FIter1, class _FIter2, class _BinaryPredicate> _FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate); 
# 650
template< class _IIter, class _Predicate> inline _IIter find_if(_IIter, _IIter, _Predicate); 
# 654
template< class _IIter, class _Funct> _Funct for_each(_IIter, _IIter, _Funct); 
# 658
template< class _FIter, class _Generator> void generate(_FIter, _FIter, _Generator); 
# 662
template< class _OIter, class _Size, class _Generator> _OIter generate_n(_OIter, _Size, _Generator); 
# 666
template< class _IIter1, class _IIter2> inline bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2); 
# 670
template< class _IIter1, class _IIter2, class _Compare> inline bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare); 
# 674
template< class _FIter> inline _FIter max_element(_FIter, _FIter); 
# 679
template< class _FIter, class _Compare> inline _FIter max_element(_FIter, _FIter, _Compare); 
# 684
template< class _IIter1, class _IIter2, class _OIter> inline _OIter merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter); 
# 688
template< class _IIter1, class _IIter2, class _OIter, class 
# 689
_Compare> inline _OIter 
# 688
merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare); 
# 693
template< class _FIter> inline _FIter min_element(_FIter, _FIter); 
# 698
template< class _FIter, class _Compare> inline _FIter min_element(_FIter, _FIter, _Compare); 
# 703
template< class _IIter1, class _IIter2> inline pair< _IIter1, _IIter2>  mismatch(_IIter1, _IIter1, _IIter2); 
# 707
template< class _IIter1, class _IIter2, class _BinaryPredicate> inline pair< _IIter1, _IIter2>  mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate); 
# 711
template< class _RAIter> inline void nth_element(_RAIter, _RAIter, _RAIter); 
# 715
template< class _RAIter, class _Compare> inline void nth_element(_RAIter, _RAIter, _RAIter, _Compare); 
# 719
template< class _RAIter> inline void partial_sort(_RAIter, _RAIter, _RAIter); 
# 723
template< class _RAIter, class _Compare> inline void partial_sort(_RAIter, _RAIter, _RAIter, _Compare); 
# 727
template< class _BIter, class _Predicate> inline _BIter partition(_BIter, _BIter, _Predicate); 
# 731
template< class _RAIter> inline void random_shuffle(_RAIter, _RAIter); 
# 735
template< class _RAIter, class _Generator> void random_shuffle(_RAIter, _RAIter, _Generator &&); 
# 744
template< class _FIter, class _Tp> void replace(_FIter, _FIter, const _Tp &, const _Tp &); 
# 748
template< class _FIter, class _Predicate, class _Tp> void replace_if(_FIter, _FIter, _Predicate, const _Tp &); 
# 752
template< class _FIter1, class _FIter2> inline _FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2); 
# 756
template< class _FIter1, class _FIter2, class _BinaryPredicate> inline _FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate); 
# 760
template< class _FIter, class _Size, class _Tp> inline _FIter search_n(_FIter, _FIter, _Size, const _Tp &); 
# 764
template< class _FIter, class _Size, class _Tp, class 
# 765
_BinaryPredicate> inline _FIter 
# 764
search_n(_FIter, _FIter, _Size, const _Tp &, _BinaryPredicate); 
# 769
template< class _IIter1, class _IIter2, class _OIter> inline _OIter set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter); 
# 773
template< class _IIter1, class _IIter2, class _OIter, class 
# 774
_Compare> inline _OIter 
# 773
set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare); 
# 778
template< class _IIter1, class _IIter2, class _OIter> inline _OIter set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter); 
# 782
template< class _IIter1, class _IIter2, class _OIter, class 
# 783
_Compare> inline _OIter 
# 782
set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare); 
# 787
template< class _IIter1, class _IIter2, class _OIter> inline _OIter set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter); 
# 791
template< class _IIter1, class _IIter2, class _OIter, class 
# 792
_Compare> inline _OIter 
# 791
set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare); 
# 797
template< class _IIter1, class _IIter2, class _OIter> inline _OIter set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter); 
# 801
template< class _IIter1, class _IIter2, class _OIter, class 
# 802
_Compare> inline _OIter 
# 801
set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare); 
# 806
template< class _RAIter> inline void sort(_RAIter, _RAIter); 
# 810
template< class _RAIter, class _Compare> inline void sort(_RAIter, _RAIter, _Compare); 
# 814
template< class _RAIter> inline void stable_sort(_RAIter, _RAIter); 
# 818
template< class _RAIter, class _Compare> inline void stable_sort(_RAIter, _RAIter, _Compare); 
# 822
template< class _IIter, class _OIter, class _UnaryOperation> _OIter transform(_IIter, _IIter, _OIter, _UnaryOperation); 
# 826
template< class _IIter1, class _IIter2, class _OIter, class 
# 827
_BinaryOperation> _OIter 
# 826
transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation); 
# 831
template< class _IIter, class _OIter> inline _OIter unique_copy(_IIter, _IIter, _OIter); 
# 835
template< class _IIter, class _OIter, class _BinaryPredicate> inline _OIter unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate); 
# 840
}
# 62 "/usr/include/c++/5/bits/stl_heap.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
template< class _RandomAccessIterator, class _Distance, class 
# 72
_Compare> _Distance 
# 74
__is_heap_until(_RandomAccessIterator __first, _Distance __n, _Compare 
# 75
__comp) 
# 76
{ 
# 77
_Distance __parent = (0); 
# 78
for (_Distance __child = (1); __child < __n; ++__child) 
# 79
{ 
# 80
if (__comp(__first + __parent, __first + __child)) { 
# 81
return __child; }  
# 82
if ((__child & 1) == 0) { 
# 83
++__parent; }  
# 84
}  
# 85
return __n; 
# 86
} 
# 90
template< class _RandomAccessIterator, class _Distance> inline bool 
# 92
__is_heap(_RandomAccessIterator __first, _Distance __n) 
# 93
{ 
# 94
return std::__is_heap_until(__first, __n, __gnu_cxx::__ops::__iter_less_iter()) == __n; 
# 96
} 
# 98
template< class _RandomAccessIterator, class _Compare, class 
# 99
_Distance> inline bool 
# 101
__is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n) 
# 102
{ 
# 103
return std::__is_heap_until(__first, __n, __gnu_cxx::__ops::__iter_comp_iter(__comp)) == __n; 
# 105
} 
# 107
template< class _RandomAccessIterator> inline bool 
# 109
__is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 110
{ return std::__is_heap(__first, std::distance(__first, __last)); } 
# 112
template< class _RandomAccessIterator, class _Compare> inline bool 
# 114
__is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 115
__comp) 
# 116
{ return std::__is_heap(__first, __comp, std::distance(__first, __last)); } 
# 121
template< class _RandomAccessIterator, class _Distance, class _Tp, class 
# 122
_Compare> void 
# 124
__push_heap(_RandomAccessIterator __first, _Distance 
# 125
__holeIndex, _Distance __topIndex, _Tp __value, _Compare 
# 126
__comp) 
# 127
{ 
# 128
_Distance __parent = (__holeIndex - 1) / 2; 
# 129
while ((__holeIndex > __topIndex) && __comp(__first + __parent, __value)) 
# 130
{ 
# 131
(*(__first + __holeIndex)) = std::move(*(__first + __parent)); 
# 132
__holeIndex = __parent; 
# 133
__parent = ((__holeIndex - 1) / 2); 
# 134
}  
# 135
(*(__first + __holeIndex)) = std::move(__value); 
# 136
} 
# 148 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline void 
# 150
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 151
{ 
# 153
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 155
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 161
; 
# 162
; 
# 164
_ValueType __value = std::move(*(__last - 1)); 
# 165
std::__push_heap(__first, (_DistanceType)((__last - __first) - 1), (_DistanceType)0, std::move(__value), __gnu_cxx::__ops::__iter_less_val()); 
# 168
} 
# 182 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 184
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 185
__comp) 
# 186
{ 
# 188
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 190
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 195
; 
# 196
; 
# 198
_ValueType __value = std::move(*(__last - 1)); 
# 199
std::__push_heap(__first, (_DistanceType)((__last - __first) - 1), (_DistanceType)0, std::move(__value), __gnu_cxx::__ops::__iter_comp_val(__comp)); 
# 202
} 
# 204
template< class _RandomAccessIterator, class _Distance, class 
# 205
_Tp, class _Compare> void 
# 207
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance 
# 208
__len, _Tp __value, _Compare __comp) 
# 209
{ 
# 210
const _Distance __topIndex = __holeIndex; 
# 211
_Distance __secondChild = __holeIndex; 
# 212
while (__secondChild < ((__len - 1) / 2)) 
# 213
{ 
# 214
__secondChild = (2 * (__secondChild + 1)); 
# 215
if (__comp(__first + __secondChild, __first + (__secondChild - 1))) { 
# 217
__secondChild--; }  
# 218
(*(__first + __holeIndex)) = std::move(*(__first + __secondChild)); 
# 219
__holeIndex = __secondChild; 
# 220
}  
# 221
if (((__len & 1) == 0) && (__secondChild == ((__len - 2) / 2))) 
# 222
{ 
# 223
__secondChild = (2 * (__secondChild + 1)); 
# 224
(*(__first + __holeIndex)) = std::move(*(__first + (__secondChild - 1))); 
# 226
__holeIndex = (__secondChild - 1); 
# 227
}  
# 228
std::__push_heap(__first, __holeIndex, __topIndex, std::move(__value), __gnu_cxx::__ops::__iter_comp_val(__comp)); 
# 231
} 
# 233
template< class _RandomAccessIterator, class _Compare> inline void 
# 235
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator 
# 236
__result, _Compare __comp) 
# 237
{ 
# 239
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 241
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 243
_ValueType __value = std::move(*__result); 
# 244
(*__result) = std::move(*__first); 
# 245
std::__adjust_heap(__first, (_DistanceType)0, (_DistanceType)(__last - __first), std::move(__value), __comp); 
# 248
} 
# 261 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline void 
# 263
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 264
{ 
# 266
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 272
; 
# 273
; 
# 274
; 
# 276
if ((__last - __first) > 1) 
# 277
{ 
# 278
--__last; 
# 279
std::__pop_heap(__first, __last, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 281
}  
# 282
} 
# 295 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 297
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator 
# 298
__last, _Compare __comp) 
# 299
{ 
# 303
; 
# 304
; 
# 305
; 
# 307
if ((__last - __first) > 1) 
# 308
{ 
# 309
--__last; 
# 310
std::__pop_heap(__first, __last, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 312
}  
# 313
} 
# 315
template< class _RandomAccessIterator, class _Compare> void 
# 317
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 318
__comp) 
# 319
{ 
# 321
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 323
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 325
if ((__last - __first) < 2) { 
# 326
return; }  
# 328
const _DistanceType __len = __last - __first; 
# 329
_DistanceType __parent = (__len - 2) / 2; 
# 330
while (true) 
# 331
{ 
# 332
_ValueType __value = std::move(*(__first + __parent)); 
# 333
std::__adjust_heap(__first, __parent, __len, std::move(__value), __comp); 
# 335
if (__parent == 0) { 
# 336
return; }  
# 337
__parent--; 
# 338
}  
# 339
} 
# 349 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline void 
# 351
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 352
{ 
# 358
; 
# 360
std::__make_heap(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 362
} 
# 374 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 376
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 377
__comp) 
# 378
{ 
# 382
; 
# 384
std::__make_heap(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 386
} 
# 388
template< class _RandomAccessIterator, class _Compare> void 
# 390
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 391
__comp) 
# 392
{ 
# 393
while ((__last - __first) > 1) 
# 394
{ 
# 395
--__last; 
# 396
std::__pop_heap(__first, __last, __last, __comp); 
# 397
}  
# 398
} 
# 408 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline void 
# 410
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 411
{ 
# 417
; 
# 418
; 
# 420
std::__sort_heap(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 422
} 
# 434 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 436
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 437
__comp) 
# 438
{ 
# 442
; 
# 443
; 
# 445
std::__sort_heap(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 447
} 
# 460 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline _RandomAccessIterator 
# 462
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 463
{ 
# 469
; 
# 471
return __first + std::__is_heap_until(__first, std::distance(__first, __last), __gnu_cxx::__ops::__iter_less_iter()); 
# 474
} 
# 487 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline _RandomAccessIterator 
# 489
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 490
__comp) 
# 491
{ 
# 495
; 
# 497
return __first + std::__is_heap_until(__first, std::distance(__first, __last), __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 500
} 
# 509 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline bool 
# 511
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 512
{ return std::is_heap_until(__first, __last) == __last; } 
# 522 "/usr/include/c++/5/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline bool 
# 524
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 525
__comp) 
# 526
{ return std::is_heap_until(__first, __last, __comp) == __last; } 
# 530
}
# 37 "/usr/include/c++/5/bits/uniform_int_dist.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
namespace __detail { 
# 44
template< class _Tp> inline bool 
# 46
_Power_of_2(_Tp __x) 
# 47
{ 
# 48
return ((__x - 1) & __x) == 0; 
# 49
} 
# 50
}
# 60 "/usr/include/c++/5/bits/uniform_int_dist.h" 3
template< class _IntType = int> 
# 61
class uniform_int_distribution { 
# 63
static_assert((std::is_integral< _IntType> ::value), "template argument not an integral type");
# 68
public: typedef _IntType result_type; 
# 70
struct param_type { 
# 72
typedef uniform_int_distribution distribution_type; 
# 75
explicit param_type(_IntType __a = 0, _IntType 
# 76
__b = std::numeric_limits< _IntType> ::max()) : _M_a(__a), _M_b(__b) 
# 78
{ 
# 79
; 
# 80
} 
# 83
result_type a() const 
# 84
{ return _M_a; } 
# 87
result_type b() const 
# 88
{ return _M_b; } 
# 91
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 92
{ return ((__p1._M_a) == (__p2._M_a)) && ((__p1._M_b) == (__p2._M_b)); } 
# 95
private: _IntType _M_a; 
# 96
_IntType _M_b; 
# 97
}; 
# 104
explicit uniform_int_distribution(_IntType __a = 0, _IntType 
# 105
__b = std::numeric_limits< _IntType> ::max()) : _M_param(__a, __b) 
# 107
{ } 
# 110
explicit uniform_int_distribution(const param_type &__p) : _M_param(__p) 
# 112
{ } 
# 120
void reset() { } 
# 123
result_type a() const 
# 124
{ return ((_M_param).a()); } 
# 127
result_type b() const 
# 128
{ return ((_M_param).b()); } 
# 134
param_type param() const 
# 135
{ return _M_param; } 
# 142
void param(const param_type &__param) 
# 143
{ (_M_param) = __param; } 
# 149
result_type min() const 
# 150
{ return this->a(); } 
# 156
result_type max() const 
# 157
{ return this->b(); } 
# 162
template< class _UniformRandomNumberGenerator> result_type 
# 164
operator()(_UniformRandomNumberGenerator &__urng) 
# 165
{ return (this->operator()(__urng, _M_param)); } 
# 167
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 172
template< class _ForwardIterator, class 
# 173
_UniformRandomNumberGenerator> void 
# 175
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 176
__urng) 
# 177
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 179
template< class _ForwardIterator, class 
# 180
_UniformRandomNumberGenerator> void 
# 182
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 183
__urng, const param_type &
# 184
__p) 
# 185
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 187
template< class _UniformRandomNumberGenerator> void 
# 189
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 190
__urng, const param_type &
# 191
__p) 
# 192
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 199
friend inline bool operator==(const uniform_int_distribution &__d1, const uniform_int_distribution &
# 200
__d2) 
# 201
{ return (__d1._M_param) == (__d2._M_param); } 
# 204
private: template< class _ForwardIterator, class 
# 205
_UniformRandomNumberGenerator> void 
# 204
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 211
param_type _M_param; 
# 212
}; 
# 214
template< class _IntType> 
# 215
template< class _UniformRandomNumberGenerator> typename uniform_int_distribution< _IntType> ::result_type 
# 218
uniform_int_distribution< _IntType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 219
__param) 
# 220
{ 
# 222
typedef typename _UniformRandomNumberGenerator::result_type _Gresult_type; 
# 223
typedef typename make_unsigned< _IntType> ::type __utype; 
# 225
typedef typename common_type< typename _UniformRandomNumberGenerator::result_type, typename make_unsigned< _IntType> ::type> ::type __uctype; 
# 227
const __uctype __urngmin = (__urng.min()); 
# 228
const __uctype __urngmax = (__urng.max()); 
# 229
const __uctype __urngrange = __urngmax - __urngmin; 
# 230
const __uctype __urange = ((__uctype)(__param.b())) - ((__uctype)(__param.a())); 
# 233
__uctype __ret; 
# 235
if (__urngrange > __urange) 
# 236
{ 
# 238
const __uctype __uerange = __urange + 1; 
# 239
const __uctype __scaling = __urngrange / __uerange; 
# 240
const __uctype __past = __uerange * __scaling; 
# 241
do { 
# 242
__ret = (((__uctype)__urng()) - __urngmin); } 
# 243
while (__ret >= __past); 
# 244
__ret /= __scaling; 
# 245
} else { 
# 246
if (__urngrange < __urange) 
# 247
{ 
# 263 "/usr/include/c++/5/bits/uniform_int_dist.h" 3
__uctype __tmp; 
# 264
do 
# 265
{ 
# 266
const __uctype __uerngrange = __urngrange + 1; 
# 267
__tmp = (__uerngrange * operator()(__urng, param_type(0, __urange / __uerngrange))); 
# 269
__ret = (__tmp + (((__uctype)__urng()) - __urngmin)); 
# 270
} 
# 271
while ((__ret > __urange) || (__ret < __tmp)); 
# 272
} else { 
# 274
__ret = (((__uctype)__urng()) - __urngmin); }  }  
# 276
return __ret + (__param.a()); 
# 277
} 
# 280
template< class _IntType> 
# 281
template< class _ForwardIterator, class 
# 282
_UniformRandomNumberGenerator> void 
# 285
uniform_int_distribution< _IntType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 286
__urng, const param_type &
# 287
__param) 
# 288
{ 
# 291
typedef typename _UniformRandomNumberGenerator::result_type _Gresult_type; 
# 292
typedef typename make_unsigned< _IntType> ::type __utype; 
# 294
typedef typename common_type< typename _UniformRandomNumberGenerator::result_type, typename make_unsigned< _IntType> ::type> ::type __uctype; 
# 296
const __uctype __urngmin = (__urng.min()); 
# 297
const __uctype __urngmax = (__urng.max()); 
# 298
const __uctype __urngrange = __urngmax - __urngmin; 
# 299
const __uctype __urange = ((__uctype)(__param.b())) - ((__uctype)(__param.a())); 
# 302
__uctype __ret; 
# 304
if (__urngrange > __urange) 
# 305
{ 
# 306
if (__detail::_Power_of_2(__urngrange + 1) && __detail::_Power_of_2(__urange + 1)) 
# 308
{ 
# 309
while (__f != __t) 
# 310
{ 
# 311
__ret = (((__uctype)__urng()) - __urngmin); 
# 312
(*(__f++)) = ((__ret & __urange) + (__param.a())); 
# 313
}  
# 314
} else 
# 316
{ 
# 318
const __uctype __uerange = __urange + 1; 
# 319
const __uctype __scaling = __urngrange / __uerange; 
# 320
const __uctype __past = __uerange * __scaling; 
# 321
while (__f != __t) 
# 322
{ 
# 323
do { 
# 324
__ret = (((__uctype)__urng()) - __urngmin); } 
# 325
while (__ret >= __past); 
# 326
(*(__f++)) = ((__ret / __scaling) + (__param.a())); 
# 327
}  
# 328
}  
# 329
} else { 
# 330
if (__urngrange < __urange) 
# 331
{ 
# 347 "/usr/include/c++/5/bits/uniform_int_dist.h" 3
__uctype __tmp; 
# 348
while (__f != __t) 
# 349
{ 
# 350
do 
# 351
{ 
# 352
const __uctype __uerngrange = __urngrange + 1; 
# 353
__tmp = (__uerngrange * operator()(__urng, param_type(0, __urange / __uerngrange))); 
# 355
__ret = (__tmp + (((__uctype)__urng()) - __urngmin)); 
# 356
} 
# 357
while ((__ret > __urange) || (__ret < __tmp)); 
# 358
(*(__f++)) = __ret; 
# 359
}  
# 360
} else { 
# 362
while (__f != __t) { 
# 363
(*(__f++)) = ((((__uctype)__urng()) - __urngmin) + (__param.a())); }  }  }  
# 364
} 
# 367
}
# 37 "/usr/include/c++/5/bits/random.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 56 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, size_t __bits, class 
# 57
_UniformRandomNumberGenerator> _RealType 
# 56
generate_canonical(_UniformRandomNumberGenerator & __g); 
# 66
namespace __detail { 
# 70
template< class _UIntType, size_t __w, bool 
# 71
 = __w < (static_cast< size_t>(std::numeric_limits< _UIntType> ::digits))> 
# 73
struct _Shift { 
# 74
static const _UIntType __value = (0); }; 
# 76
template< class _UIntType, size_t __w> 
# 77
struct _Shift< _UIntType, __w, true>  { 
# 78
static const _UIntType __value = (((_UIntType)1) << __w); }; 
# 80
template< int __s, int 
# 81
__which = ((((__s) <= ((8) * sizeof(int))) + ((__s) <= ((8) * sizeof(long)))) + ((__s) <= ((8) * sizeof(long long)))) + (__s <= 128)> 
# 86
struct _Select_uint_least_t { 
# 88
static_assert((__which < 0), "sorry, would be too much trouble for a slow result");
# 90
}; 
# 92
template< int __s> 
# 93
struct _Select_uint_least_t< __s, 4>  { 
# 94
typedef unsigned type; }; 
# 96
template< int __s> 
# 97
struct _Select_uint_least_t< __s, 3>  { 
# 98
typedef unsigned long type; }; 
# 100
template< int __s> 
# 101
struct _Select_uint_least_t< __s, 2>  { 
# 102
typedef unsigned long long type; }; 
# 105
template< int __s> 
# 106
struct _Select_uint_least_t< __s, 1>  { 
# 107
typedef __uint128_t type; }; 
# 111
template< class _Tp, _Tp __m, _Tp __a, _Tp __c, bool 
# 112
__big_enough = (!(__m & (__m - 1))) || (((((_Tp)(-1)) - __c) / __a) >= (__m - 1)), bool 
# 114
__schrage_ok = (__m % __a) < (__m / __a)> 
# 115
struct _Mod { 
# 118
typedef typename _Select_uint_least_t< (std::__lg(__a) + std::__lg(__m)) + 2> ::type _Tp2; 
# 120
static _Tp __calc(_Tp __x) 
# 121
{ return static_cast< _Tp>(((((_Tp2)__a) * __x) + __c) % __m); } 
# 122
}; 
# 125
template< class _Tp, _Tp __m, _Tp __a, _Tp __c> 
# 126
struct _Mod< _Tp, __m, __a, __c, false, true>  { 
# 129
static _Tp __calc(_Tp __x); 
# 130
}; 
# 135
template< class _Tp, _Tp __m, _Tp __a, _Tp __c, bool __s> 
# 136
struct _Mod< _Tp, __m, __a, __c, true, __s>  { 
# 139
static _Tp __calc(_Tp __x) 
# 140
{ 
# 141
_Tp __res = (__a * __x) + __c; 
# 142
if (__m) { 
# 143
__res %= __m; }  
# 144
return __res; 
# 145
} 
# 146
}; 
# 148
template< class _Tp, _Tp __m, _Tp __a = 1, _Tp __c = 0> inline _Tp 
# 150
__mod(_Tp __x) 
# 151
{ return _Mod< _Tp, __m, __a, __c> ::__calc(__x); } 
# 157
template< class _Engine, class _DInputType> 
# 158
struct _Adaptor { 
# 160
static_assert((std::is_floating_point< _DInputType> ::value), "template argument not a floating point type");
# 164
_Adaptor(_Engine &__g) : _M_g(__g) 
# 165
{ } 
# 168
_DInputType min() const 
# 169
{ return (_DInputType)0; } 
# 172
_DInputType max() const 
# 173
{ return (_DInputType)1; } 
# 181
_DInputType operator()() 
# 182
{ 
# 183
return std::generate_canonical< _DInputType, numeric_limits< _DInputType> ::digits, _Engine> (_M_g); 
# 186
} 
# 189
private: _Engine &_M_g; 
# 190
}; 
# 193
}
# 235 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> 
# 236
class linear_congruential_engine { 
# 238
static_assert((std::is_unsigned< _UIntType> ::value), "template argument substituting _UIntType not an unsigned integral type");
# 240
static_assert(((__m == 0U) || ((__a < __m) && (__c < __m))), "template argument substituting __m out of bounds");
# 245
public: typedef _UIntType result_type; 
# 248
static constexpr result_type multiplier = (__a); 
# 250
static constexpr result_type increment = (__c); 
# 252
static constexpr result_type modulus = (__m); 
# 253
static constexpr result_type default_seed = (1U); 
# 263 "/usr/include/c++/5/bits/random.h" 3
explicit linear_congruential_engine(result_type __s = default_seed) 
# 264
{ seed(__s); } 
# 272
template< class _Sseq, class  = typename enable_if< !is_same< _Sseq, linear_congruential_engine> ::value> ::type> explicit 
# 276
linear_congruential_engine(_Sseq &__q) 
# 277
{ seed(__q); } 
# 286
void seed(result_type __s = default_seed); 
# 295 "/usr/include/c++/5/bits/random.h" 3
template< class _Sseq> typename enable_if< is_class< _Sseq> ::value> ::type seed(_Sseq & __q); 
# 306
static constexpr result_type min() 
# 307
{ return (__c == 0U) ? 1U : 0U; } 
# 313
static constexpr result_type max() 
# 314
{ return __m - 1U; } 
# 320
void discard(unsigned long long __z) 
# 321
{ 
# 322
for (; __z != 0ULL; --__z) { 
# 323
(*this)(); }  
# 324
} 
# 330
result_type operator()() 
# 331
{ 
# 332
(_M_x) = __detail::__mod< _UIntType, __m, __a, __c> (_M_x); 
# 333
return _M_x; 
# 334
} 
# 348 "/usr/include/c++/5/bits/random.h" 3
friend inline bool operator==(const linear_congruential_engine &__lhs, const linear_congruential_engine &
# 349
__rhs) 
# 350
{ return (__lhs._M_x) == (__rhs._M_x); } 
# 360 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType1, _UIntType1 __a1, _UIntType1 __c1, _UIntType1 
# 361
__m1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &
# 360
operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::linear_congruential_engine< _UIntType1, __a1, __c1, __m1>  & __lcr); 
# 380 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType1, _UIntType1 __a1, _UIntType1 __c1, _UIntType1 
# 381
__m1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &
# 380
operator>>(basic_istream< _CharT, _Traits>  & __is, std::linear_congruential_engine< _UIntType1, __a1, __c1, __m1>  & __lcr); 
# 388
private: _UIntType _M_x; 
# 389
}; 
# 402 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> inline bool 
# 404
operator!=(const linear_congruential_engine< _UIntType, __a, __c, __m>  &
# 405
__lhs, const linear_congruential_engine< _UIntType, __a, __c, __m>  &
# 407
__rhs) 
# 408
{ return !(__lhs == __rhs); } 
# 439 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType, size_t __w, size_t 
# 440
__n, size_t __m, size_t __r, _UIntType 
# 441
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 442
__b, size_t __t, _UIntType 
# 443
__c, size_t __l, _UIntType __f> 
# 444
class mersenne_twister_engine { 
# 446
static_assert((std::is_unsigned< _UIntType> ::value), "template argument substituting _UIntType not an unsigned integral type");
# 448
static_assert((((1U) <= __m) && (__m <= __n)), "template argument substituting __m out of bounds");
# 450
static_assert((__r <= __w), "template argument substituting __r out of bound");
# 452
static_assert((__u <= __w), "template argument substituting __u out of bound");
# 454
static_assert((__s <= __w), "template argument substituting __s out of bound");
# 456
static_assert((__t <= __w), "template argument substituting __t out of bound");
# 458
static_assert((__l <= __w), "template argument substituting __l out of bound");
# 460
static_assert((__w <= std::numeric_limits< _UIntType> ::digits), "template argument substituting __w out of bound");
# 462
static_assert((__a <= (__detail::_Shift< _UIntType, __w> ::__value - 1)), "template argument substituting __a out of bound");
# 464
static_assert((__b <= (__detail::_Shift< _UIntType, __w> ::__value - 1)), "template argument substituting __b out of bound");
# 466
static_assert((__c <= (__detail::_Shift< _UIntType, __w> ::__value - 1)), "template argument substituting __c out of bound");
# 468
static_assert((__d <= (__detail::_Shift< _UIntType, __w> ::__value - 1)), "template argument substituting __d out of bound");
# 470
static_assert((__f <= (__detail::_Shift< _UIntType, __w> ::__value - 1)), "template argument substituting __f out of bound");
# 475
public: typedef _UIntType result_type; 
# 478
static constexpr size_t word_size = __w; 
# 479
static constexpr size_t state_size = __n; 
# 480
static constexpr size_t shift_size = __m; 
# 481
static constexpr size_t mask_bits = __r; 
# 482
static constexpr result_type xor_mask = (__a); 
# 483
static constexpr size_t tempering_u = __u; 
# 484
static constexpr result_type tempering_d = (__d); 
# 485
static constexpr size_t tempering_s = __s; 
# 486
static constexpr result_type tempering_b = (__b); 
# 487
static constexpr size_t tempering_t = __t; 
# 488
static constexpr result_type tempering_c = (__c); 
# 489
static constexpr size_t tempering_l = __l; 
# 490
static constexpr result_type initialization_multiplier = (__f); 
# 491
static constexpr result_type default_seed = (5489U); 
# 495
explicit mersenne_twister_engine(result_type __sd = default_seed) 
# 496
{ seed(__sd); } 
# 504
template< class _Sseq, class  = typename enable_if< !is_same< _Sseq, mersenne_twister_engine> ::value> ::type> explicit 
# 508
mersenne_twister_engine(_Sseq &__q) 
# 509
{ seed(__q); } 
# 512
void seed(result_type __sd = default_seed); 
# 514
template< class _Sseq> typename enable_if< is_class< _Sseq> ::value> ::type seed(_Sseq & __q); 
# 522
static constexpr result_type min() 
# 523
{ return 0; } 
# 529
static constexpr result_type max() 
# 530
{ return __detail::_Shift< _UIntType, __w> ::__value - 1; } 
# 536
void discard(unsigned long long __z); 
# 539
result_type operator()(); 
# 554 "/usr/include/c++/5/bits/random.h" 3
friend inline bool operator==(const mersenne_twister_engine &__lhs, const mersenne_twister_engine &
# 555
__rhs) 
# 556
{ return std::equal((__lhs._M_x), (__lhs._M_x) + state_size, (__rhs._M_x)) && ((__lhs._M_p) == (__rhs._M_p)); 
# 557
} 
# 571 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType1, size_t 
# 572
__w1, size_t __n1, size_t 
# 573
__m1, size_t __r1, _UIntType1 
# 574
__a1, size_t __u1, _UIntType1 
# 575
__d1, size_t __s1, _UIntType1 
# 576
__b1, size_t __t1, _UIntType1 
# 577
__c1, size_t __l1, _UIntType1 __f1, class 
# 578
_CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &
# 571
operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::mersenne_twister_engine< _UIntType1, __w1, __n1, __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1, __l1, __f1>  & __x); 
# 597 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType1, size_t 
# 598
__w1, size_t __n1, size_t 
# 599
__m1, size_t __r1, _UIntType1 
# 600
__a1, size_t __u1, _UIntType1 
# 601
__d1, size_t __s1, _UIntType1 
# 602
__b1, size_t __t1, _UIntType1 
# 603
__c1, size_t __l1, _UIntType1 __f1, class 
# 604
_CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &
# 597
operator>>(basic_istream< _CharT, _Traits>  & __is, std::mersenne_twister_engine< _UIntType1, __w1, __n1, __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1, __l1, __f1>  & __x); 
# 612
private: void _M_gen_rand(); 
# 614
_UIntType _M_x[state_size]; 
# 615
size_t _M_p; 
# 616
}; 
# 630 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType, size_t __w, size_t 
# 631
__n, size_t __m, size_t __r, _UIntType 
# 632
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 633
__b, size_t __t, _UIntType 
# 634
__c, size_t __l, _UIntType __f> inline bool 
# 636
operator!=(const mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>  &
# 637
__lhs, const mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>  &
# 639
__rhs) 
# 640
{ return !(__lhs == __rhs); } 
# 658 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType, size_t __w, size_t __s, size_t __r> 
# 659
class subtract_with_carry_engine { 
# 661
static_assert((std::is_unsigned< _UIntType> ::value), "template argument substituting _UIntType not an unsigned integral type");
# 663
static_assert((((0U) < __s) && (__s < __r)), "template argument substituting __s out of bounds");
# 665
static_assert((((0U) < __w) && (__w <= std::numeric_limits< _UIntType> ::digits)), "template argument substituting __w out of bounds");
# 670
public: typedef _UIntType result_type; 
# 673
static constexpr size_t word_size = __w; 
# 674
static constexpr size_t short_lag = __s; 
# 675
static constexpr size_t long_lag = __r; 
# 676
static constexpr result_type default_seed = (19780503U); 
# 683
explicit subtract_with_carry_engine(result_type __sd = default_seed) 
# 684
{ seed(__sd); } 
# 692
template< class _Sseq, class  = typename enable_if< !is_same< _Sseq, subtract_with_carry_engine> ::value> ::type> explicit 
# 696
subtract_with_carry_engine(_Sseq &__q) 
# 697
{ seed(__q); } 
# 712 "/usr/include/c++/5/bits/random.h" 3
void seed(result_type __sd = default_seed); 
# 718
template< class _Sseq> typename enable_if< is_class< _Sseq> ::value> ::type seed(_Sseq & __q); 
# 727
static constexpr result_type min() 
# 728
{ return 0; } 
# 735
static constexpr result_type max() 
# 736
{ return __detail::_Shift< _UIntType, __w> ::__value - 1; } 
# 742
void discard(unsigned long long __z) 
# 743
{ 
# 744
for (; __z != 0ULL; --__z) { 
# 745
(*this)(); }  
# 746
} 
# 752
result_type operator()(); 
# 767 "/usr/include/c++/5/bits/random.h" 3
friend inline bool operator==(const subtract_with_carry_engine &__lhs, const subtract_with_carry_engine &
# 768
__rhs) 
# 769
{ return std::equal((__lhs._M_x), (__lhs._M_x) + long_lag, (__rhs._M_x)) && ((__lhs._M_carry) == (__rhs._M_carry)) && ((__lhs._M_p) == (__rhs._M_p)); 
# 771
} 
# 785 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType1, size_t __w1, size_t __s1, size_t __r1, class 
# 786
_CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &
# 785
operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::subtract_with_carry_engine< _UIntType1, __w1, __s1, __r1>  & __x); 
# 804 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType1, size_t __w1, size_t __s1, size_t __r1, class 
# 805
_CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &
# 804
operator>>(basic_istream< _CharT, _Traits>  & __is, std::subtract_with_carry_engine< _UIntType1, __w1, __s1, __r1>  & __x); 
# 813
private: _UIntType _M_x[long_lag]; 
# 814
_UIntType _M_carry; 
# 815
size_t _M_p; 
# 816
}; 
# 830 "/usr/include/c++/5/bits/random.h" 3
template< class _UIntType, size_t __w, size_t __s, size_t __r> inline bool 
# 832
operator!=(const subtract_with_carry_engine< _UIntType, __w, __s, __r>  &
# 833
__lhs, const subtract_with_carry_engine< _UIntType, __w, __s, __r>  &
# 835
__rhs) 
# 836
{ return !(__lhs == __rhs); } 
# 845 "/usr/include/c++/5/bits/random.h" 3
template< class _RandomNumberEngine, size_t __p, size_t __r> 
# 846
class discard_block_engine { 
# 848
static_assert((((1) <= __r) && (__r <= __p)), "template argument substituting __r out of bounds");
# 853
public: typedef typename _RandomNumberEngine::result_type result_type; 
# 856
static constexpr size_t block_size = __p; 
# 857
static constexpr size_t used_block = __r; 
# 864
discard_block_engine() : _M_b(), _M_n((0)) 
# 865
{ } 
# 874
explicit discard_block_engine(const _RandomNumberEngine &__rng) : _M_b(__rng), _M_n((0)) 
# 875
{ } 
# 884
explicit discard_block_engine(_RandomNumberEngine &&__rng) : _M_b(std::move(__rng)), _M_n((0)) 
# 885
{ } 
# 894
explicit discard_block_engine(result_type __s) : _M_b(__s), _M_n((0)) 
# 895
{ } 
# 902
template< class _Sseq, class  = typename enable_if< (!is_same< _Sseq, discard_block_engine> ::value) && (!is_same< _Sseq, _RandomNumberEngine> ::value)> ::type> explicit 
# 907
discard_block_engine(_Sseq &__q) : _M_b(__q), _M_n((0)) 
# 909
{ } 
# 916
void seed() 
# 917
{ 
# 918
((_M_b).seed()); 
# 919
(_M_n) = (0); 
# 920
} 
# 927
void seed(result_type __s) 
# 928
{ 
# 929
((_M_b).seed(__s)); 
# 930
(_M_n) = (0); 
# 931
} 
# 938
template< class _Sseq> void 
# 940
seed(_Sseq &__q) 
# 941
{ 
# 942
((_M_b).seed(__q)); 
# 943
(_M_n) = (0); 
# 944
} 
# 951
const _RandomNumberEngine &base() const noexcept 
# 952
{ return _M_b; } 
# 958
static constexpr result_type min() 
# 959
{ return _RandomNumberEngine::min(); } 
# 965
static constexpr result_type max() 
# 966
{ return _RandomNumberEngine::max(); } 
# 972
void discard(unsigned long long __z) 
# 973
{ 
# 974
for (; __z != 0ULL; --__z) { 
# 975
(*this)(); }  
# 976
} 
# 982
result_type operator()(); 
# 996 "/usr/include/c++/5/bits/random.h" 3
friend inline bool operator==(const discard_block_engine &__lhs, const discard_block_engine &
# 997
__rhs) 
# 998
{ return ((__lhs._M_b) == (__rhs._M_b)) && ((__lhs._M_n) == (__rhs._M_n)); } 
# 1011 "/usr/include/c++/5/bits/random.h" 3
template< class _RandomNumberEngine1, size_t __p1, size_t __r1, class 
# 1012
_CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &
# 1011
operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::discard_block_engine< _RandomNumberEngine1, __p1, __r1>  & __x); 
# 1029 "/usr/include/c++/5/bits/random.h" 3
template< class _RandomNumberEngine1, size_t __p1, size_t __r1, class 
# 1030
_CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &
# 1029
operator>>(basic_istream< _CharT, _Traits>  & __is, std::discard_block_engine< _RandomNumberEngine1, __p1, __r1>  & __x); 
# 1037
private: _RandomNumberEngine _M_b; 
# 1038
size_t _M_n; 
# 1039
}; 
# 1052 "/usr/include/c++/5/bits/random.h" 3
template< class _RandomNumberEngine, size_t __p, size_t __r> inline bool 
# 1054
operator!=(const discard_block_engine< _RandomNumberEngine, __p, __r>  &
# 1055
__lhs, const discard_block_engine< _RandomNumberEngine, __p, __r>  &
# 1057
__rhs) 
# 1058
{ return !(__lhs == __rhs); } 
# 1065
template< class _RandomNumberEngine, size_t __w, class _UIntType> 
# 1066
class independent_bits_engine { 
# 1068
static_assert((std::is_unsigned< _UIntType> ::value), "template argument substituting _UIntType not an unsigned integral type");
# 1070
static_assert((((0U) < __w) && (__w <= std::numeric_limits< _UIntType> ::digits)), "template argument substituting __w out of bounds");
# 1075
public: typedef _UIntType result_type; 
# 1082
independent_bits_engine() : _M_b() 
# 1083
{ } 
# 1092
explicit independent_bits_engine(const _RandomNumberEngine &__rng) : _M_b(__rng) 
# 1093
{ } 
# 1102
explicit independent_bits_engine(_RandomNumberEngine &&__rng) : _M_b(std::move(__rng)) 
# 1103
{ } 
# 1112
explicit independent_bits_engine(result_type __s) : _M_b(__s) 
# 1113
{ } 
# 1120
template< class _Sseq, class  = typename enable_if< (!is_same< _Sseq, independent_bits_engine> ::value) && (!is_same< _Sseq, _RandomNumberEngine> ::value)> ::type> explicit 
# 1125
independent_bits_engine(_Sseq &__q) : _M_b(__q) 
# 1127
{ } 
# 1134
void seed() 
# 1135
{ ((_M_b).seed()); } 
# 1142
void seed(result_type __s) 
# 1143
{ ((_M_b).seed(__s)); } 
# 1150
template< class _Sseq> void 
# 1152
seed(_Sseq &__q) 
# 1153
{ ((_M_b).seed(__q)); } 
# 1160
const _RandomNumberEngine &base() const noexcept 
# 1161
{ return _M_b; } 
# 1167
static constexpr result_type min() 
# 1168
{ return 0U; } 
# 1174
static constexpr result_type max() 
# 1175
{ return __detail::_Shift< _UIntType, __w> ::__value - 1; } 
# 1181
void discard(unsigned long long __z) 
# 1182
{ 
# 1183
for (; __z != 0ULL; --__z) { 
# 1184
(*this)(); }  
# 1185
} 
# 1191
result_type operator()(); 
# 1206 "/usr/include/c++/5/bits/random.h" 3
friend inline bool operator==(const independent_bits_engine &__lhs, const independent_bits_engine &
# 1207
__rhs) 
# 1208
{ return (__lhs._M_b) == (__rhs._M_b); } 
# 1222 "/usr/include/c++/5/bits/random.h" 3
template< class _CharT, class _Traits> friend inline basic_istream< _CharT, _Traits>  &
# 1224
operator>>(basic_istream< _CharT, _Traits>  &__is, independent_bits_engine &
# 1226
__x) 
# 1227
{ 
# 1228
__is >> (__x._M_b); 
# 1229
return __is; 
# 1230
} 
# 1233
private: _RandomNumberEngine _M_b; 
# 1234
}; 
# 1248 "/usr/include/c++/5/bits/random.h" 3
template< class _RandomNumberEngine, size_t __w, class _UIntType> inline bool 
# 1250
operator!=(const independent_bits_engine< _RandomNumberEngine, __w, _UIntType>  &
# 1251
__lhs, const independent_bits_engine< _RandomNumberEngine, __w, _UIntType>  &
# 1253
__rhs) 
# 1254
{ return !(__lhs == __rhs); } 
# 1266 "/usr/include/c++/5/bits/random.h" 3
template< class _RandomNumberEngine, size_t __w, class _UIntType, class 
# 1267
_CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 1269
operator<<(basic_ostream< _CharT, _Traits>  &__os, const independent_bits_engine< _RandomNumberEngine, __w, _UIntType>  &
# 1271
__x) 
# 1272
{ 
# 1273
__os << (__x.base()); 
# 1274
return __os; 
# 1275
} 
# 1283
template< class _RandomNumberEngine, size_t __k> 
# 1284
class shuffle_order_engine { 
# 1286
static_assert(((1U) <= __k), "template argument substituting __k out of bound");
# 1291
public: typedef typename _RandomNumberEngine::result_type result_type; 
# 1293
static constexpr size_t table_size = __k; 
# 1300
shuffle_order_engine() : _M_b() 
# 1302
{ _M_initialize(); } 
# 1311
explicit shuffle_order_engine(const _RandomNumberEngine &__rng) : _M_b(__rng) 
# 1313
{ _M_initialize(); } 
# 1322
explicit shuffle_order_engine(_RandomNumberEngine &&__rng) : _M_b(std::move(__rng)) 
# 1324
{ _M_initialize(); } 
# 1333
explicit shuffle_order_engine(result_type __s) : _M_b(__s) 
# 1335
{ _M_initialize(); } 
# 1342
template< class _Sseq, class  = typename enable_if< (!is_same< _Sseq, shuffle_order_engine> ::value) && (!is_same< _Sseq, _RandomNumberEngine> ::value)> ::type> explicit 
# 1347
shuffle_order_engine(_Sseq &__q) : _M_b(__q) 
# 1349
{ _M_initialize(); } 
# 1356
void seed() 
# 1357
{ 
# 1358
((_M_b).seed()); 
# 1359
_M_initialize(); 
# 1360
} 
# 1367
void seed(result_type __s) 
# 1368
{ 
# 1369
((_M_b).seed(__s)); 
# 1370
_M_initialize(); 
# 1371
} 
# 1378
template< class _Sseq> void 
# 1380
seed(_Sseq &__q) 
# 1381
{ 
# 1382
((_M_b).seed(__q)); 
# 1383
_M_initialize(); 
# 1384
} 
# 1390
const _RandomNumberEngine &base() const noexcept 
# 1391
{ return _M_b; } 
# 1397
static constexpr result_type min() 
# 1398
{ return _RandomNumberEngine::min(); } 
# 1404
static constexpr result_type max() 
# 1405
{ return _RandomNumberEngine::max(); } 
# 1411
void discard(unsigned long long __z) 
# 1412
{ 
# 1413
for (; __z != 0ULL; --__z) { 
# 1414
(*this)(); }  
# 1415
} 
# 1421
result_type operator()(); 
# 1435 "/usr/include/c++/5/bits/random.h" 3
friend inline bool operator==(const shuffle_order_engine &__lhs, const shuffle_order_engine &
# 1436
__rhs) 
# 1437
{ return ((__lhs._M_b) == (__rhs._M_b)) && std::equal((__lhs._M_v), (__lhs._M_v) + __k, (__rhs._M_v)) && ((__lhs._M_y) == (__rhs._M_y)); 
# 1439
} 
# 1452 "/usr/include/c++/5/bits/random.h" 3
template< class _RandomNumberEngine1, size_t __k1, class 
# 1453
_CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &
# 1452
operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::shuffle_order_engine< _RandomNumberEngine1, __k1>  & __x); 
# 1470 "/usr/include/c++/5/bits/random.h" 3
template< class _RandomNumberEngine1, size_t __k1, class 
# 1471
_CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &
# 1470
operator>>(basic_istream< _CharT, _Traits>  & __is, std::shuffle_order_engine< _RandomNumberEngine1, __k1>  & __x); 
# 1477
private: void _M_initialize() 
# 1478
{ 
# 1479
for (size_t __i = (0); __i < __k; ++__i) { 
# 1480
((_M_v)[__i]) = (_M_b)(); }  
# 1481
(_M_y) = (_M_b)(); 
# 1482
} 
# 1484
_RandomNumberEngine _M_b; 
# 1485
result_type _M_v[__k]; 
# 1486
result_type _M_y; 
# 1487
}; 
# 1500 "/usr/include/c++/5/bits/random.h" 3
template< class _RandomNumberEngine, size_t __k> inline bool 
# 1502
operator!=(const shuffle_order_engine< _RandomNumberEngine, __k>  &
# 1503
__lhs, const shuffle_order_engine< _RandomNumberEngine, __k>  &
# 1505
__rhs) 
# 1506
{ return !(__lhs == __rhs); } 
# 1513
typedef linear_congruential_engine< unsigned long, 16807UL, 0UL, 2147483647UL>  minstd_rand0; 
# 1519
typedef linear_congruential_engine< unsigned long, 48271UL, 0UL, 2147483647UL>  minstd_rand; 
# 1535 "/usr/include/c++/5/bits/random.h" 3
typedef mersenne_twister_engine< unsigned long, 32UL, 624UL, 397UL, 31UL, 2567483615UL, 11UL, 4294967295UL, 7UL, 2636928640UL, 15UL, 4022730752UL, 18UL, 1812433253UL>  mt19937; 
# 1547
typedef mersenne_twister_engine< unsigned long, 64UL, 312UL, 156UL, 31UL, 13043109905998158313UL, 29UL, 6148914691236517205UL, 17UL, 8202884508482404352UL, 37UL, 18444473444759240704UL, 43UL, 6364136223846793005UL>  mt19937_64; 
# 1550
typedef subtract_with_carry_engine< unsigned long, 24UL, 10UL, 24UL>  ranlux24_base; 
# 1553
typedef subtract_with_carry_engine< unsigned long, 48UL, 5UL, 12UL>  ranlux48_base; 
# 1555
typedef discard_block_engine< subtract_with_carry_engine< unsigned long, 24UL, 10UL, 24UL> , 223UL, 23UL>  ranlux24; 
# 1557
typedef discard_block_engine< subtract_with_carry_engine< unsigned long, 48UL, 5UL, 12UL> , 389UL, 11UL>  ranlux48; 
# 1559
typedef shuffle_order_engine< linear_congruential_engine< unsigned long, 16807UL, 0UL, 2147483647UL> , 256UL>  knuth_b; 
# 1561
typedef minstd_rand0 default_random_engine; 
# 1567
class random_device { 
# 1571
public: typedef unsigned result_type; 
# 1578
explicit random_device(const __cxx11::string &__token = "default") 
# 1579
{ 
# 1580
this->_M_init(__token); 
# 1581
} 
# 1583
~random_device() 
# 1584
{ this->_M_fini(); } 
# 1597 "/usr/include/c++/5/bits/random.h" 3
static constexpr result_type min() 
# 1598
{ return std::numeric_limits< unsigned> ::min(); } 
# 1601
static constexpr result_type max() 
# 1602
{ return std::numeric_limits< unsigned> ::max(); } 
# 1605
double entropy() const noexcept 
# 1606
{ return (0.0); } 
# 1609
result_type operator()() 
# 1610
{ 
# 1612
return this->_M_getval(); 
# 1616
} 
# 1619
random_device(const random_device &) = delete;
# 1620
void operator=(const random_device &) = delete;
# 1624
private: void _M_init(const __cxx11::string & __token); 
# 1625
void _M_init_pretr1(const __cxx11::string & __token); 
# 1626
void _M_fini(); 
# 1628
result_type _M_getval(); 
# 1629
result_type _M_getval_pretr1(); 
# 1632
union { 
# 1633
void *_M_file; 
# 1634
mt19937 _M_mt; 
# 1635
}; 
# 1636
}; 
# 1658 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType> inline bool 
# 1660
operator!=(const uniform_int_distribution< _IntType>  &__d1, const uniform_int_distribution< _IntType>  &
# 1661
__d2) 
# 1662
{ return !(__d1 == __d2); } 
# 1674 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  &, const uniform_int_distribution< _IntType>  &); 
# 1688 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  &, uniform_int_distribution< _IntType>  &); 
# 1701 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 1702
class uniform_real_distribution { 
# 1704
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 1709
public: typedef _RealType result_type; 
# 1711
struct param_type { 
# 1713
typedef uniform_real_distribution distribution_type; 
# 1716
explicit param_type(_RealType __a = (_RealType)0, _RealType 
# 1717
__b = (_RealType)1) : _M_a(__a), _M_b(__b) 
# 1719
{ 
# 1720
; 
# 1721
} 
# 1724
result_type a() const 
# 1725
{ return _M_a; } 
# 1728
result_type b() const 
# 1729
{ return _M_b; } 
# 1732
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 1733
{ return ((__p1._M_a) == (__p2._M_a)) && ((__p1._M_b) == (__p2._M_b)); } 
# 1736
private: _RealType _M_a; 
# 1737
_RealType _M_b; 
# 1738
}; 
# 1748
explicit uniform_real_distribution(_RealType __a = (_RealType)0, _RealType 
# 1749
__b = (_RealType)1) : _M_param(__a, __b) 
# 1751
{ } 
# 1754
explicit uniform_real_distribution(const param_type &__p) : _M_param(__p) 
# 1756
{ } 
# 1764
void reset() { } 
# 1767
result_type a() const 
# 1768
{ return ((_M_param).a()); } 
# 1771
result_type b() const 
# 1772
{ return ((_M_param).b()); } 
# 1778
param_type param() const 
# 1779
{ return _M_param; } 
# 1786
void param(const param_type &__param) 
# 1787
{ (_M_param) = __param; } 
# 1793
result_type min() const 
# 1794
{ return this->a(); } 
# 1800
result_type max() const 
# 1801
{ return this->b(); } 
# 1806
template< class _UniformRandomNumberGenerator> result_type 
# 1808
operator()(_UniformRandomNumberGenerator &__urng) 
# 1809
{ return (this->operator()(__urng, _M_param)); } 
# 1811
template< class _UniformRandomNumberGenerator> result_type 
# 1813
operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 1814
__p) 
# 1815
{ 
# 1817
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 1818
return (__aurng() * ((__p.b()) - (__p.a()))) + (__p.a()); 
# 1819
} 
# 1821
template< class _ForwardIterator, class 
# 1822
_UniformRandomNumberGenerator> void 
# 1824
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 1825
__urng) 
# 1826
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 1828
template< class _ForwardIterator, class 
# 1829
_UniformRandomNumberGenerator> void 
# 1831
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 1832
__urng, const param_type &
# 1833
__p) 
# 1834
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 1836
template< class _UniformRandomNumberGenerator> void 
# 1838
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 1839
__urng, const param_type &
# 1840
__p) 
# 1841
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 1848
friend inline bool operator==(const uniform_real_distribution &__d1, const uniform_real_distribution &
# 1849
__d2) 
# 1850
{ return (__d1._M_param) == (__d2._M_param); } 
# 1853
private: template< class _ForwardIterator, class 
# 1854
_UniformRandomNumberGenerator> void 
# 1853
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 1860
param_type _M_param; 
# 1861
}; 
# 1867
template< class _IntType> inline bool 
# 1869
operator!=(const uniform_real_distribution< _IntType>  &__d1, const uniform_real_distribution< _IntType>  &
# 1870
__d2) 
# 1871
{ return !(__d1 == __d2); } 
# 1883 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  &, const uniform_real_distribution< _RealType>  &); 
# 1897 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  &, uniform_real_distribution< _RealType>  &); 
# 1919 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 1920
class normal_distribution { 
# 1922
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 1927
public: typedef _RealType result_type; 
# 1929
struct param_type { 
# 1931
typedef normal_distribution distribution_type; 
# 1934
explicit param_type(_RealType __mean = (_RealType)0, _RealType 
# 1935
__stddev = (_RealType)1) : _M_mean(__mean), _M_stddev(__stddev) 
# 1937
{ 
# 1938
; 
# 1939
} 
# 1942
_RealType mean() const 
# 1943
{ return _M_mean; } 
# 1946
_RealType stddev() const 
# 1947
{ return _M_stddev; } 
# 1950
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 1951
{ return ((__p1._M_mean) == (__p2._M_mean)) && ((__p1._M_stddev) == (__p2._M_stddev)); 
# 1952
} 
# 1955
private: _RealType _M_mean; 
# 1956
_RealType _M_stddev; 
# 1957
}; 
# 1965
explicit normal_distribution(result_type __mean = (result_type)0, result_type 
# 1966
__stddev = (result_type)1) : _M_param(__mean, __stddev), _M_saved_available(false) 
# 1968
{ } 
# 1971
explicit normal_distribution(const param_type &__p) : _M_param(__p), _M_saved_available(false) 
# 1973
{ } 
# 1979
void reset() 
# 1980
{ (_M_saved_available) = false; } 
# 1986
_RealType mean() const 
# 1987
{ return ((_M_param).mean()); } 
# 1993
_RealType stddev() const 
# 1994
{ return ((_M_param).stddev()); } 
# 2000
param_type param() const 
# 2001
{ return _M_param; } 
# 2008
void param(const param_type &__param) 
# 2009
{ (_M_param) = __param; } 
# 2015
result_type min() const 
# 2016
{ return std::numeric_limits< _RealType> ::lowest(); } 
# 2022
result_type max() const 
# 2023
{ return std::numeric_limits< _RealType> ::max(); } 
# 2028
template< class _UniformRandomNumberGenerator> result_type 
# 2030
operator()(_UniformRandomNumberGenerator &__urng) 
# 2031
{ return (this->operator()(__urng, _M_param)); } 
# 2033
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 2038
template< class _ForwardIterator, class 
# 2039
_UniformRandomNumberGenerator> void 
# 2041
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2042
__urng) 
# 2043
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 2045
template< class _ForwardIterator, class 
# 2046
_UniformRandomNumberGenerator> void 
# 2048
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2049
__urng, const param_type &
# 2050
__p) 
# 2051
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 2053
template< class _UniformRandomNumberGenerator> void 
# 2055
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 2056
__urng, const param_type &
# 2057
__p) 
# 2058
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 2065
template< class _RealType1> friend bool operator==(const std::normal_distribution< _RealType1>  & __d1, const std::normal_distribution< _RealType1>  & __d2); 
# 2080 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::normal_distribution< _RealType1>  & __x); 
# 2095 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::normal_distribution< _RealType1>  & __x); 
# 2101
private: template< class _ForwardIterator, class 
# 2102
_UniformRandomNumberGenerator> void 
# 2101
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 2108
param_type _M_param; 
# 2109
result_type _M_saved; 
# 2110
bool _M_saved_available; 
# 2111
}; 
# 2116
template< class _RealType> inline bool 
# 2118
operator!=(const normal_distribution< _RealType>  &__d1, const normal_distribution< _RealType>  &
# 2119
__d2) 
# 2120
{ return !(__d1 == __d2); } 
# 2132 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 2133
class lognormal_distribution { 
# 2135
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 2140
public: typedef _RealType result_type; 
# 2142
struct param_type { 
# 2144
typedef lognormal_distribution distribution_type; 
# 2147
explicit param_type(_RealType __m = (_RealType)0, _RealType 
# 2148
__s = (_RealType)1) : _M_m(__m), _M_s(__s) 
# 2150
{ } 
# 2153
_RealType m() const 
# 2154
{ return _M_m; } 
# 2157
_RealType s() const 
# 2158
{ return _M_s; } 
# 2161
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 2162
{ return ((__p1._M_m) == (__p2._M_m)) && ((__p1._M_s) == (__p2._M_s)); } 
# 2165
private: _RealType _M_m; 
# 2166
_RealType _M_s; 
# 2167
}; 
# 2170
explicit lognormal_distribution(_RealType __m = (_RealType)0, _RealType 
# 2171
__s = (_RealType)1) : _M_param(__m, __s), _M_nd() 
# 2173
{ } 
# 2176
explicit lognormal_distribution(const param_type &__p) : _M_param(__p), _M_nd() 
# 2178
{ } 
# 2184
void reset() 
# 2185
{ ((_M_nd).reset()); } 
# 2191
_RealType m() const 
# 2192
{ return ((_M_param).m()); } 
# 2195
_RealType s() const 
# 2196
{ return ((_M_param).s()); } 
# 2202
param_type param() const 
# 2203
{ return _M_param; } 
# 2210
void param(const param_type &__param) 
# 2211
{ (_M_param) = __param; } 
# 2217
result_type min() const 
# 2218
{ return (result_type)0; } 
# 2224
result_type max() const 
# 2225
{ return std::numeric_limits< _RealType> ::max(); } 
# 2230
template< class _UniformRandomNumberGenerator> result_type 
# 2232
operator()(_UniformRandomNumberGenerator &__urng) 
# 2233
{ return (this->operator()(__urng, _M_param)); } 
# 2235
template< class _UniformRandomNumberGenerator> result_type 
# 2237
operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 2238
__p) 
# 2239
{ return std::exp(((__p.s()) * (_M_nd)(__urng)) + (__p.m())); } 
# 2241
template< class _ForwardIterator, class 
# 2242
_UniformRandomNumberGenerator> void 
# 2244
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2245
__urng) 
# 2246
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 2248
template< class _ForwardIterator, class 
# 2249
_UniformRandomNumberGenerator> void 
# 2251
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2252
__urng, const param_type &
# 2253
__p) 
# 2254
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 2256
template< class _UniformRandomNumberGenerator> void 
# 2258
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 2259
__urng, const param_type &
# 2260
__p) 
# 2261
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 2269
friend inline bool operator==(const lognormal_distribution &__d1, const lognormal_distribution &
# 2270
__d2) 
# 2271
{ return ((__d1._M_param) == (__d2._M_param)) && ((__d1._M_nd) == (__d2._M_nd)); 
# 2272
} 
# 2284 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::lognormal_distribution< _RealType1>  & __x); 
# 2299 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::lognormal_distribution< _RealType1>  & __x); 
# 2305
private: template< class _ForwardIterator, class 
# 2306
_UniformRandomNumberGenerator> void 
# 2305
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 2312
param_type _M_param; 
# 2314
normal_distribution< _RealType>  _M_nd; 
# 2315
}; 
# 2320
template< class _RealType> inline bool 
# 2322
operator!=(const lognormal_distribution< _RealType>  &__d1, const lognormal_distribution< _RealType>  &
# 2323
__d2) 
# 2324
{ return !(__d1 == __d2); } 
# 2336 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 2337
class gamma_distribution { 
# 2339
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 2344
public: typedef _RealType result_type; 
# 2346
struct param_type { 
# 2348
typedef gamma_distribution distribution_type; 
# 2349
friend class gamma_distribution; 
# 2352
explicit param_type(_RealType __alpha_val = (_RealType)1, _RealType 
# 2353
__beta_val = (_RealType)1) : _M_alpha(__alpha_val), _M_beta(__beta_val) 
# 2355
{ 
# 2356
; 
# 2357
_M_initialize(); 
# 2358
} 
# 2361
_RealType alpha() const 
# 2362
{ return _M_alpha; } 
# 2365
_RealType beta() const 
# 2366
{ return _M_beta; } 
# 2369
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 2370
{ return ((__p1._M_alpha) == (__p2._M_alpha)) && ((__p1._M_beta) == (__p2._M_beta)); 
# 2371
} 
# 2375
private: void _M_initialize(); 
# 2377
_RealType _M_alpha; 
# 2378
_RealType _M_beta; 
# 2380
_RealType _M_malpha, _M_a2; 
# 2381
}; 
# 2389
explicit gamma_distribution(_RealType __alpha_val = (_RealType)1, _RealType 
# 2390
__beta_val = (_RealType)1) : _M_param(__alpha_val, __beta_val), _M_nd() 
# 2392
{ } 
# 2395
explicit gamma_distribution(const param_type &__p) : _M_param(__p), _M_nd() 
# 2397
{ } 
# 2403
void reset() 
# 2404
{ ((_M_nd).reset()); } 
# 2410
_RealType alpha() const 
# 2411
{ return ((_M_param).alpha()); } 
# 2417
_RealType beta() const 
# 2418
{ return ((_M_param).beta()); } 
# 2424
param_type param() const 
# 2425
{ return _M_param; } 
# 2432
void param(const param_type &__param) 
# 2433
{ (_M_param) = __param; } 
# 2439
result_type min() const 
# 2440
{ return (result_type)0; } 
# 2446
result_type max() const 
# 2447
{ return std::numeric_limits< _RealType> ::max(); } 
# 2452
template< class _UniformRandomNumberGenerator> result_type 
# 2454
operator()(_UniformRandomNumberGenerator &__urng) 
# 2455
{ return (this->operator()(__urng, _M_param)); } 
# 2457
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 2462
template< class _ForwardIterator, class 
# 2463
_UniformRandomNumberGenerator> void 
# 2465
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2466
__urng) 
# 2467
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 2469
template< class _ForwardIterator, class 
# 2470
_UniformRandomNumberGenerator> void 
# 2472
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2473
__urng, const param_type &
# 2474
__p) 
# 2475
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 2477
template< class _UniformRandomNumberGenerator> void 
# 2479
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 2480
__urng, const param_type &
# 2481
__p) 
# 2482
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 2490
friend inline bool operator==(const gamma_distribution &__d1, const gamma_distribution &
# 2491
__d2) 
# 2492
{ return ((__d1._M_param) == (__d2._M_param)) && ((__d1._M_nd) == (__d2._M_nd)); 
# 2493
} 
# 2505 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::gamma_distribution< _RealType1>  & __x); 
# 2519 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::gamma_distribution< _RealType1>  & __x); 
# 2525
private: template< class _ForwardIterator, class 
# 2526
_UniformRandomNumberGenerator> void 
# 2525
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 2532
param_type _M_param; 
# 2534
normal_distribution< _RealType>  _M_nd; 
# 2535
}; 
# 2540
template< class _RealType> inline bool 
# 2542
operator!=(const gamma_distribution< _RealType>  &__d1, const gamma_distribution< _RealType>  &
# 2543
__d2) 
# 2544
{ return !(__d1 == __d2); } 
# 2553 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 2554
class chi_squared_distribution { 
# 2556
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 2561
public: typedef _RealType result_type; 
# 2563
struct param_type { 
# 2565
typedef chi_squared_distribution distribution_type; 
# 2568
explicit param_type(_RealType __n = (_RealType)1) : _M_n(__n) 
# 2570
{ } 
# 2573
_RealType n() const 
# 2574
{ return _M_n; } 
# 2577
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 2578
{ return (__p1._M_n) == (__p2._M_n); } 
# 2581
private: _RealType _M_n; 
# 2582
}; 
# 2585
explicit chi_squared_distribution(_RealType __n = (_RealType)1) : _M_param(__n), _M_gd(__n / 2) 
# 2587
{ } 
# 2590
explicit chi_squared_distribution(const param_type &__p) : _M_param(__p), _M_gd((__p.n()) / 2) 
# 2592
{ } 
# 2598
void reset() 
# 2599
{ ((_M_gd).reset()); } 
# 2605
_RealType n() const 
# 2606
{ return ((_M_param).n()); } 
# 2612
param_type param() const 
# 2613
{ return _M_param; } 
# 2620
void param(const param_type &__param) 
# 2621
{ (_M_param) = __param; } 
# 2627
result_type min() const 
# 2628
{ return (result_type)0; } 
# 2634
result_type max() const 
# 2635
{ return std::numeric_limits< _RealType> ::max(); } 
# 2640
template< class _UniformRandomNumberGenerator> result_type 
# 2642
operator()(_UniformRandomNumberGenerator &__urng) 
# 2643
{ return 2 * (_M_gd)(__urng); } 
# 2645
template< class _UniformRandomNumberGenerator> result_type 
# 2647
operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 2648
__p) 
# 2649
{ 
# 2651
typedef typename gamma_distribution< _RealType> ::param_type param_type; 
# 2652
return 2 * (_M_gd)(__urng, (param_type)((__p.n()) / 2)); 
# 2653
} 
# 2655
template< class _ForwardIterator, class 
# 2656
_UniformRandomNumberGenerator> void 
# 2658
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2659
__urng) 
# 2660
{ (this->__generate_impl(__f, __t, __urng)); } 
# 2662
template< class _ForwardIterator, class 
# 2663
_UniformRandomNumberGenerator> void 
# 2665
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2666
__urng, const param_type &
# 2667
__p) 
# 2668
{ 
# 2669
typename gamma_distribution< _RealType> ::param_type __p2((__p.n()) / 2); 
# 2670
(this->__generate_impl(__f, __t, __urng, __p2)); } 
# 2672
template< class _UniformRandomNumberGenerator> void 
# 2674
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 2675
__urng) 
# 2676
{ (this->__generate_impl(__f, __t, __urng)); } 
# 2678
template< class _UniformRandomNumberGenerator> void 
# 2680
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 2681
__urng, const param_type &
# 2682
__p) 
# 2683
{ 
# 2684
typename gamma_distribution< _RealType> ::param_type __p2((__p.n()) / 2); 
# 2685
(this->__generate_impl(__f, __t, __urng, __p2)); } 
# 2693
friend inline bool operator==(const chi_squared_distribution &__d1, const chi_squared_distribution &
# 2694
__d2) 
# 2695
{ return ((__d1._M_param) == (__d2._M_param)) && ((__d1._M_gd) == (__d2._M_gd)); } 
# 2707 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::chi_squared_distribution< _RealType1>  & __x); 
# 2722 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::chi_squared_distribution< _RealType1>  & __x); 
# 2728
private: template< class _ForwardIterator, class 
# 2729
_UniformRandomNumberGenerator> void 
# 2728
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng); 
# 2734
template< class _ForwardIterator, class 
# 2735
_UniformRandomNumberGenerator> void 
# 2734
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const typename gamma_distribution< _RealType> ::param_type & __p); 
# 2742
param_type _M_param; 
# 2744
gamma_distribution< _RealType>  _M_gd; 
# 2745
}; 
# 2750
template< class _RealType> inline bool 
# 2752
operator!=(const chi_squared_distribution< _RealType>  &__d1, const chi_squared_distribution< _RealType>  &
# 2753
__d2) 
# 2754
{ return !(__d1 == __d2); } 
# 2763 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 2764
class cauchy_distribution { 
# 2766
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 2771
public: typedef _RealType result_type; 
# 2773
struct param_type { 
# 2775
typedef cauchy_distribution distribution_type; 
# 2778
explicit param_type(_RealType __a = (_RealType)0, _RealType 
# 2779
__b = (_RealType)1) : _M_a(__a), _M_b(__b) 
# 2781
{ } 
# 2784
_RealType a() const 
# 2785
{ return _M_a; } 
# 2788
_RealType b() const 
# 2789
{ return _M_b; } 
# 2792
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 2793
{ return ((__p1._M_a) == (__p2._M_a)) && ((__p1._M_b) == (__p2._M_b)); } 
# 2796
private: _RealType _M_a; 
# 2797
_RealType _M_b; 
# 2798
}; 
# 2801
explicit cauchy_distribution(_RealType __a = (_RealType)0, _RealType 
# 2802
__b = (_RealType)1) : _M_param(__a, __b) 
# 2804
{ } 
# 2807
explicit cauchy_distribution(const param_type &__p) : _M_param(__p) 
# 2809
{ } 
# 2815
void reset() 
# 2816
{ } 
# 2822
_RealType a() const 
# 2823
{ return ((_M_param).a()); } 
# 2826
_RealType b() const 
# 2827
{ return ((_M_param).b()); } 
# 2833
param_type param() const 
# 2834
{ return _M_param; } 
# 2841
void param(const param_type &__param) 
# 2842
{ (_M_param) = __param; } 
# 2848
result_type min() const 
# 2849
{ return std::numeric_limits< _RealType> ::lowest(); } 
# 2855
result_type max() const 
# 2856
{ return std::numeric_limits< _RealType> ::max(); } 
# 2861
template< class _UniformRandomNumberGenerator> result_type 
# 2863
operator()(_UniformRandomNumberGenerator &__urng) 
# 2864
{ return (this->operator()(__urng, _M_param)); } 
# 2866
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 2871
template< class _ForwardIterator, class 
# 2872
_UniformRandomNumberGenerator> void 
# 2874
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2875
__urng) 
# 2876
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 2878
template< class _ForwardIterator, class 
# 2879
_UniformRandomNumberGenerator> void 
# 2881
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2882
__urng, const param_type &
# 2883
__p) 
# 2884
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 2886
template< class _UniformRandomNumberGenerator> void 
# 2888
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 2889
__urng, const param_type &
# 2890
__p) 
# 2891
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 2898
friend inline bool operator==(const cauchy_distribution &__d1, const cauchy_distribution &
# 2899
__d2) 
# 2900
{ return (__d1._M_param) == (__d2._M_param); } 
# 2903
private: template< class _ForwardIterator, class 
# 2904
_UniformRandomNumberGenerator> void 
# 2903
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 2910
param_type _M_param; 
# 2911
}; 
# 2917
template< class _RealType> inline bool 
# 2919
operator!=(const cauchy_distribution< _RealType>  &__d1, const cauchy_distribution< _RealType>  &
# 2920
__d2) 
# 2921
{ return !(__d1 == __d2); } 
# 2933 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const cauchy_distribution< _RealType>  & __x); 
# 2948 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, cauchy_distribution< _RealType>  & __x); 
# 2964 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 2965
class fisher_f_distribution { 
# 2967
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 2972
public: typedef _RealType result_type; 
# 2974
struct param_type { 
# 2976
typedef fisher_f_distribution distribution_type; 
# 2979
explicit param_type(_RealType __m = (_RealType)1, _RealType 
# 2980
__n = (_RealType)1) : _M_m(__m), _M_n(__n) 
# 2982
{ } 
# 2985
_RealType m() const 
# 2986
{ return _M_m; } 
# 2989
_RealType n() const 
# 2990
{ return _M_n; } 
# 2993
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 2994
{ return ((__p1._M_m) == (__p2._M_m)) && ((__p1._M_n) == (__p2._M_n)); } 
# 2997
private: _RealType _M_m; 
# 2998
_RealType _M_n; 
# 2999
}; 
# 3002
explicit fisher_f_distribution(_RealType __m = (_RealType)1, _RealType 
# 3003
__n = (_RealType)1) : _M_param(__m, __n), _M_gd_x(__m / 2), _M_gd_y(__n / 2) 
# 3005
{ } 
# 3008
explicit fisher_f_distribution(const param_type &__p) : _M_param(__p), _M_gd_x((__p.m()) / 2), _M_gd_y((__p.n()) / 2) 
# 3010
{ } 
# 3016
void reset() 
# 3017
{ 
# 3018
((_M_gd_x).reset()); 
# 3019
((_M_gd_y).reset()); 
# 3020
} 
# 3026
_RealType m() const 
# 3027
{ return ((_M_param).m()); } 
# 3030
_RealType n() const 
# 3031
{ return ((_M_param).n()); } 
# 3037
param_type param() const 
# 3038
{ return _M_param; } 
# 3045
void param(const param_type &__param) 
# 3046
{ (_M_param) = __param; } 
# 3052
result_type min() const 
# 3053
{ return (result_type)0; } 
# 3059
result_type max() const 
# 3060
{ return std::numeric_limits< _RealType> ::max(); } 
# 3065
template< class _UniformRandomNumberGenerator> result_type 
# 3067
operator()(_UniformRandomNumberGenerator &__urng) 
# 3068
{ return ((_M_gd_x)(__urng) * n()) / ((_M_gd_y)(__urng) * m()); } 
# 3070
template< class _UniformRandomNumberGenerator> result_type 
# 3072
operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 3073
__p) 
# 3074
{ 
# 3076
typedef typename gamma_distribution< _RealType> ::param_type param_type; 
# 3077
return ((_M_gd_x)(__urng, (param_type)((__p.m()) / 2)) * n()) / ((_M_gd_y)(__urng, (param_type)((__p.n()) / 2)) * m()); 
# 3079
} 
# 3081
template< class _ForwardIterator, class 
# 3082
_UniformRandomNumberGenerator> void 
# 3084
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3085
__urng) 
# 3086
{ (this->__generate_impl(__f, __t, __urng)); } 
# 3088
template< class _ForwardIterator, class 
# 3089
_UniformRandomNumberGenerator> void 
# 3091
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3092
__urng, const param_type &
# 3093
__p) 
# 3094
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 3096
template< class _UniformRandomNumberGenerator> void 
# 3098
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 3099
__urng) 
# 3100
{ (this->__generate_impl(__f, __t, __urng)); } 
# 3102
template< class _UniformRandomNumberGenerator> void 
# 3104
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 3105
__urng, const param_type &
# 3106
__p) 
# 3107
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 3115
friend inline bool operator==(const fisher_f_distribution &__d1, const fisher_f_distribution &
# 3116
__d2) 
# 3117
{ return ((__d1._M_param) == (__d2._M_param)) && ((__d1._M_gd_x) == (__d2._M_gd_x)) && ((__d1._M_gd_y) == (__d2._M_gd_y)); 
# 3119
} 
# 3131 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::fisher_f_distribution< _RealType1>  & __x); 
# 3146 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::fisher_f_distribution< _RealType1>  & __x); 
# 3152
private: template< class _ForwardIterator, class 
# 3153
_UniformRandomNumberGenerator> void 
# 3152
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng); 
# 3158
template< class _ForwardIterator, class 
# 3159
_UniformRandomNumberGenerator> void 
# 3158
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 3165
param_type _M_param; 
# 3167
gamma_distribution< _RealType>  _M_gd_x, _M_gd_y; 
# 3168
}; 
# 3173
template< class _RealType> inline bool 
# 3175
operator!=(const fisher_f_distribution< _RealType>  &__d1, const fisher_f_distribution< _RealType>  &
# 3176
__d2) 
# 3177
{ return !(__d1 == __d2); } 
# 3188 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 3189
class student_t_distribution { 
# 3191
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 3196
public: typedef _RealType result_type; 
# 3198
struct param_type { 
# 3200
typedef student_t_distribution distribution_type; 
# 3203
explicit param_type(_RealType __n = (_RealType)1) : _M_n(__n) 
# 3205
{ } 
# 3208
_RealType n() const 
# 3209
{ return _M_n; } 
# 3212
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 3213
{ return (__p1._M_n) == (__p2._M_n); } 
# 3216
private: _RealType _M_n; 
# 3217
}; 
# 3220
explicit student_t_distribution(_RealType __n = (_RealType)1) : _M_param(__n), _M_nd(), _M_gd(__n / 2, 2) 
# 3222
{ } 
# 3225
explicit student_t_distribution(const param_type &__p) : _M_param(__p), _M_nd(), _M_gd((__p.n()) / 2, 2) 
# 3227
{ } 
# 3233
void reset() 
# 3234
{ 
# 3235
((_M_nd).reset()); 
# 3236
((_M_gd).reset()); 
# 3237
} 
# 3243
_RealType n() const 
# 3244
{ return ((_M_param).n()); } 
# 3250
param_type param() const 
# 3251
{ return _M_param; } 
# 3258
void param(const param_type &__param) 
# 3259
{ (_M_param) = __param; } 
# 3265
result_type min() const 
# 3266
{ return std::numeric_limits< _RealType> ::lowest(); } 
# 3272
result_type max() const 
# 3273
{ return std::numeric_limits< _RealType> ::max(); } 
# 3278
template< class _UniformRandomNumberGenerator> result_type 
# 3280
operator()(_UniformRandomNumberGenerator &__urng) 
# 3281
{ return (_M_nd)(__urng) * std::sqrt(n() / (_M_gd)(__urng)); } 
# 3283
template< class _UniformRandomNumberGenerator> result_type 
# 3285
operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 3286
__p) 
# 3287
{ 
# 3289
typedef typename gamma_distribution< _RealType> ::param_type param_type; 
# 3291
const result_type __g = (_M_gd)(__urng, param_type((__p.n()) / 2, 2)); 
# 3292
return (_M_nd)(__urng) * std::sqrt((__p.n()) / __g); 
# 3293
} 
# 3295
template< class _ForwardIterator, class 
# 3296
_UniformRandomNumberGenerator> void 
# 3298
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3299
__urng) 
# 3300
{ (this->__generate_impl(__f, __t, __urng)); } 
# 3302
template< class _ForwardIterator, class 
# 3303
_UniformRandomNumberGenerator> void 
# 3305
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3306
__urng, const param_type &
# 3307
__p) 
# 3308
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 3310
template< class _UniformRandomNumberGenerator> void 
# 3312
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 3313
__urng) 
# 3314
{ (this->__generate_impl(__f, __t, __urng)); } 
# 3316
template< class _UniformRandomNumberGenerator> void 
# 3318
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 3319
__urng, const param_type &
# 3320
__p) 
# 3321
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 3329
friend inline bool operator==(const student_t_distribution &__d1, const student_t_distribution &
# 3330
__d2) 
# 3331
{ return ((__d1._M_param) == (__d2._M_param)) && ((__d1._M_nd) == (__d2._M_nd)) && ((__d1._M_gd) == (__d2._M_gd)); 
# 3332
} 
# 3344 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::student_t_distribution< _RealType1>  & __x); 
# 3359 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::student_t_distribution< _RealType1>  & __x); 
# 3365
private: template< class _ForwardIterator, class 
# 3366
_UniformRandomNumberGenerator> void 
# 3365
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng); 
# 3370
template< class _ForwardIterator, class 
# 3371
_UniformRandomNumberGenerator> void 
# 3370
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 3377
param_type _M_param; 
# 3379
normal_distribution< _RealType>  _M_nd; 
# 3380
gamma_distribution< _RealType>  _M_gd; 
# 3381
}; 
# 3386
template< class _RealType> inline bool 
# 3388
operator!=(const student_t_distribution< _RealType>  &__d1, const student_t_distribution< _RealType>  &
# 3389
__d2) 
# 3390
{ return !(__d1 == __d2); } 
# 3407 "/usr/include/c++/5/bits/random.h" 3
class bernoulli_distribution { 
# 3411
public: typedef bool result_type; 
# 3413
struct param_type { 
# 3415
typedef bernoulli_distribution distribution_type; 
# 3418
explicit param_type(double __p = (0.5)) : _M_p(__p) 
# 3420
{ 
# 3421
; 
# 3422
} 
# 3425
double p() const 
# 3426
{ return _M_p; } 
# 3429
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 3430
{ return (__p1._M_p) == (__p2._M_p); } 
# 3433
private: double _M_p; 
# 3434
}; 
# 3444
explicit bernoulli_distribution(double __p = (0.5)) : _M_param(__p) 
# 3446
{ } 
# 3449
explicit bernoulli_distribution(const param_type &__p) : _M_param(__p) 
# 3451
{ } 
# 3459
void reset() { } 
# 3465
double p() const 
# 3466
{ return (_M_param).p(); } 
# 3472
param_type param() const 
# 3473
{ return _M_param; } 
# 3480
void param(const param_type &__param) 
# 3481
{ (_M_param) = __param; } 
# 3487
result_type min() const 
# 3488
{ return std::numeric_limits< bool> ::min(); } 
# 3494
result_type max() const 
# 3495
{ return std::numeric_limits< bool> ::max(); } 
# 3500
template< class _UniformRandomNumberGenerator> result_type 
# 3502
operator()(_UniformRandomNumberGenerator &__urng) 
# 3503
{ return (this->operator()(__urng, _M_param)); } 
# 3505
template< class _UniformRandomNumberGenerator> result_type 
# 3507
operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 3508
__p) 
# 3509
{ 
# 3511
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 3512
if ((__aurng() - (__aurng.min())) < (__p.p() * ((__aurng.max()) - (__aurng.min())))) { 
# 3514
return true; }  
# 3515
return false; 
# 3516
} 
# 3518
template< class _ForwardIterator, class 
# 3519
_UniformRandomNumberGenerator> void 
# 3521
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3522
__urng) 
# 3523
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 3525
template< class _ForwardIterator, class 
# 3526
_UniformRandomNumberGenerator> void 
# 3528
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3529
__urng, const param_type &__p) 
# 3530
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 3532
template< class _UniformRandomNumberGenerator> void 
# 3534
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 3535
__urng, const param_type &
# 3536
__p) 
# 3537
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 3544
friend inline bool operator==(const bernoulli_distribution &__d1, const bernoulli_distribution &
# 3545
__d2) 
# 3546
{ return ((__d1._M_param) == (__d2._M_param)); } 
# 3549
private: template< class _ForwardIterator, class 
# 3550
_UniformRandomNumberGenerator> void 
# 3549
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 3556
param_type _M_param; 
# 3557
}; 
# 3564
inline bool operator!=(const bernoulli_distribution &__d1, const bernoulli_distribution &
# 3565
__d2) 
# 3566
{ return !((__d1 == __d2)); } 
# 3578 "/usr/include/c++/5/bits/random.h" 3
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const bernoulli_distribution & __x); 
# 3592 "/usr/include/c++/5/bits/random.h" 3
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 3594
operator>>(basic_istream< _CharT, _Traits>  &__is, bernoulli_distribution &
# 3595
__x) 
# 3596
{ 
# 3597
double __p; 
# 3598
__is >> __p; 
# 3599
__x.param(((bernoulli_distribution::param_type)(__p))); 
# 3600
return __is; 
# 3601
} 
# 3611 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType = int> 
# 3612
class binomial_distribution { 
# 3614
static_assert((std::is_integral< _IntType> ::value), "template argument not an integral type");
# 3619
public: typedef _IntType result_type; 
# 3621
struct param_type { 
# 3623
typedef binomial_distribution distribution_type; 
# 3624
friend class binomial_distribution; 
# 3627
explicit param_type(_IntType __t = (_IntType)1, double __p = (0.5)) : _M_t(__t), _M_p(__p) 
# 3629
{ 
# 3632
; 
# 3633
_M_initialize(); 
# 3634
} 
# 3637
_IntType t() const 
# 3638
{ return _M_t; } 
# 3641
double p() const 
# 3642
{ return _M_p; } 
# 3645
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 3646
{ return ((__p1._M_t) == (__p2._M_t)) && ((__p1._M_p) == (__p2._M_p)); } 
# 3650
private: void _M_initialize(); 
# 3652
_IntType _M_t; 
# 3653
double _M_p; 
# 3655
double _M_q; 
# 3657
double _M_d1, _M_d2, _M_s1, _M_s2, _M_c, 
# 3658
_M_a1, _M_a123, _M_s, _M_lf, _M_lp1p; 
# 3660
bool _M_easy; 
# 3661
}; 
# 3665
explicit binomial_distribution(_IntType __t = (_IntType)1, double 
# 3666
__p = (0.5)) : _M_param(__t, __p), _M_nd() 
# 3668
{ } 
# 3671
explicit binomial_distribution(const param_type &__p) : _M_param(__p), _M_nd() 
# 3673
{ } 
# 3679
void reset() 
# 3680
{ (_M_nd).reset(); } 
# 3686
_IntType t() const 
# 3687
{ return ((_M_param).t()); } 
# 3693
double p() const 
# 3694
{ return ((_M_param).p()); } 
# 3700
param_type param() const 
# 3701
{ return _M_param; } 
# 3708
void param(const param_type &__param) 
# 3709
{ (_M_param) = __param; } 
# 3715
result_type min() const 
# 3716
{ return 0; } 
# 3722
result_type max() const 
# 3723
{ return ((_M_param).t()); } 
# 3728
template< class _UniformRandomNumberGenerator> result_type 
# 3730
operator()(_UniformRandomNumberGenerator &__urng) 
# 3731
{ return (this->operator()(__urng, _M_param)); } 
# 3733
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 3738
template< class _ForwardIterator, class 
# 3739
_UniformRandomNumberGenerator> void 
# 3741
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3742
__urng) 
# 3743
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 3745
template< class _ForwardIterator, class 
# 3746
_UniformRandomNumberGenerator> void 
# 3748
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3749
__urng, const param_type &
# 3750
__p) 
# 3751
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 3753
template< class _UniformRandomNumberGenerator> void 
# 3755
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 3756
__urng, const param_type &
# 3757
__p) 
# 3758
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 3766
friend inline bool operator==(const binomial_distribution &__d1, const binomial_distribution &
# 3767
__d2) 
# 3769
{ return ((__d1._M_param) == (__d2._M_param)) && ((__d1._M_nd) == (__d2._M_nd)); } 
# 3784 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType1, class 
# 3785
_CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &
# 3784
operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::binomial_distribution< _IntType1>  & __x); 
# 3800 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType1, class 
# 3801
_CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &
# 3800
operator>>(basic_istream< _CharT, _Traits>  & __is, std::binomial_distribution< _IntType1>  & __x); 
# 3807
private: template< class _ForwardIterator, class 
# 3808
_UniformRandomNumberGenerator> void 
# 3807
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 3814
template< class _UniformRandomNumberGenerator> result_type _M_waiting(_UniformRandomNumberGenerator & __urng, _IntType __t, double __q); 
# 3819
param_type _M_param; 
# 3822
normal_distribution< double>  _M_nd; 
# 3823
}; 
# 3828
template< class _IntType> inline bool 
# 3830
operator!=(const binomial_distribution< _IntType>  &__d1, const binomial_distribution< _IntType>  &
# 3831
__d2) 
# 3832
{ return !(__d1 == __d2); } 
# 3842 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType = int> 
# 3843
class geometric_distribution { 
# 3845
static_assert((std::is_integral< _IntType> ::value), "template argument not an integral type");
# 3850
public: typedef _IntType result_type; 
# 3852
struct param_type { 
# 3854
typedef geometric_distribution distribution_type; 
# 3855
friend class geometric_distribution; 
# 3858
explicit param_type(double __p = (0.5)) : _M_p(__p) 
# 3860
{ 
# 3861
; 
# 3862
_M_initialize(); 
# 3863
} 
# 3866
double p() const 
# 3867
{ return _M_p; } 
# 3870
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 3871
{ return (__p1._M_p) == (__p2._M_p); } 
# 3875
private: void _M_initialize() 
# 3876
{ (_M_log_1_p) = std::log((1.0) - (_M_p)); } 
# 3878
double _M_p; 
# 3880
double _M_log_1_p; 
# 3881
}; 
# 3885
explicit geometric_distribution(double __p = (0.5)) : _M_param(__p) 
# 3887
{ } 
# 3890
explicit geometric_distribution(const param_type &__p) : _M_param(__p) 
# 3892
{ } 
# 3900
void reset() { } 
# 3906
double p() const 
# 3907
{ return ((_M_param).p()); } 
# 3913
param_type param() const 
# 3914
{ return _M_param; } 
# 3921
void param(const param_type &__param) 
# 3922
{ (_M_param) = __param; } 
# 3928
result_type min() const 
# 3929
{ return 0; } 
# 3935
result_type max() const 
# 3936
{ return std::numeric_limits< _IntType> ::max(); } 
# 3941
template< class _UniformRandomNumberGenerator> result_type 
# 3943
operator()(_UniformRandomNumberGenerator &__urng) 
# 3944
{ return (this->operator()(__urng, _M_param)); } 
# 3946
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 3951
template< class _ForwardIterator, class 
# 3952
_UniformRandomNumberGenerator> void 
# 3954
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3955
__urng) 
# 3956
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 3958
template< class _ForwardIterator, class 
# 3959
_UniformRandomNumberGenerator> void 
# 3961
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3962
__urng, const param_type &
# 3963
__p) 
# 3964
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 3966
template< class _UniformRandomNumberGenerator> void 
# 3968
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 3969
__urng, const param_type &
# 3970
__p) 
# 3971
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 3978
friend inline bool operator==(const geometric_distribution &__d1, const geometric_distribution &
# 3979
__d2) 
# 3980
{ return (__d1._M_param) == (__d2._M_param); } 
# 3983
private: template< class _ForwardIterator, class 
# 3984
_UniformRandomNumberGenerator> void 
# 3983
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 3990
param_type _M_param; 
# 3991
}; 
# 3997
template< class _IntType> inline bool 
# 3999
operator!=(const geometric_distribution< _IntType>  &__d1, const geometric_distribution< _IntType>  &
# 4000
__d2) 
# 4001
{ return !(__d1 == __d2); } 
# 4013 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType, class 
# 4014
_CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 4013
operator<<(basic_ostream< _CharT, _Traits>  & __os, const geometric_distribution< _IntType>  & __x); 
# 4028 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType, class 
# 4029
_CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 4028
operator>>(basic_istream< _CharT, _Traits>  & __is, geometric_distribution< _IntType>  & __x); 
# 4042 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType = int> 
# 4043
class negative_binomial_distribution { 
# 4045
static_assert((std::is_integral< _IntType> ::value), "template argument not an integral type");
# 4050
public: typedef _IntType result_type; 
# 4052
struct param_type { 
# 4054
typedef negative_binomial_distribution distribution_type; 
# 4057
explicit param_type(_IntType __k = 1, double __p = (0.5)) : _M_k(__k), _M_p(__p) 
# 4059
{ 
# 4060
; 
# 4061
} 
# 4064
_IntType k() const 
# 4065
{ return _M_k; } 
# 4068
double p() const 
# 4069
{ return _M_p; } 
# 4072
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 4073
{ return ((__p1._M_k) == (__p2._M_k)) && ((__p1._M_p) == (__p2._M_p)); } 
# 4076
private: _IntType _M_k; 
# 4077
double _M_p; 
# 4078
}; 
# 4081
explicit negative_binomial_distribution(_IntType __k = 1, double __p = (0.5)) : _M_param(__k, __p), _M_gd(__k, ((1.0) - __p) / __p) 
# 4083
{ } 
# 4086
explicit negative_binomial_distribution(const param_type &__p) : _M_param(__p), _M_gd((__p.k()), ((1.0) - (__p.p())) / (__p.p())) 
# 4088
{ } 
# 4094
void reset() 
# 4095
{ (_M_gd).reset(); } 
# 4101
_IntType k() const 
# 4102
{ return ((_M_param).k()); } 
# 4108
double p() const 
# 4109
{ return ((_M_param).p()); } 
# 4115
param_type param() const 
# 4116
{ return _M_param; } 
# 4123
void param(const param_type &__param) 
# 4124
{ (_M_param) = __param; } 
# 4130
result_type min() const 
# 4131
{ return (result_type)0; } 
# 4137
result_type max() const 
# 4138
{ return std::numeric_limits< _IntType> ::max(); } 
# 4143
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng); 
# 4147
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 4152
template< class _ForwardIterator, class 
# 4153
_UniformRandomNumberGenerator> void 
# 4155
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 4156
__urng) 
# 4157
{ (this->__generate_impl(__f, __t, __urng)); } 
# 4159
template< class _ForwardIterator, class 
# 4160
_UniformRandomNumberGenerator> void 
# 4162
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 4163
__urng, const param_type &
# 4164
__p) 
# 4165
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 4167
template< class _UniformRandomNumberGenerator> void 
# 4169
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 4170
__urng) 
# 4171
{ (this->__generate_impl(__f, __t, __urng)); } 
# 4173
template< class _UniformRandomNumberGenerator> void 
# 4175
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 4176
__urng, const param_type &
# 4177
__p) 
# 4178
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 4186
friend inline bool operator==(const negative_binomial_distribution &__d1, const negative_binomial_distribution &
# 4187
__d2) 
# 4188
{ return ((__d1._M_param) == (__d2._M_param)) && ((__d1._M_gd) == (__d2._M_gd)); } 
# 4201 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::negative_binomial_distribution< _IntType1>  & __x); 
# 4216 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::negative_binomial_distribution< _IntType1>  & __x); 
# 4222
private: template< class _ForwardIterator, class 
# 4223
_UniformRandomNumberGenerator> void 
# 4222
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng); 
# 4227
template< class _ForwardIterator, class 
# 4228
_UniformRandomNumberGenerator> void 
# 4227
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 4234
param_type _M_param; 
# 4236
gamma_distribution< double>  _M_gd; 
# 4237
}; 
# 4242
template< class _IntType> inline bool 
# 4244
operator!=(const negative_binomial_distribution< _IntType>  &__d1, const negative_binomial_distribution< _IntType>  &
# 4245
__d2) 
# 4246
{ return !(__d1 == __d2); } 
# 4264 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType = int> 
# 4265
class poisson_distribution { 
# 4267
static_assert((std::is_integral< _IntType> ::value), "template argument not an integral type");
# 4272
public: typedef _IntType result_type; 
# 4274
struct param_type { 
# 4276
typedef poisson_distribution distribution_type; 
# 4277
friend class poisson_distribution; 
# 4280
explicit param_type(double __mean = (1.0)) : _M_mean(__mean) 
# 4282
{ 
# 4283
; 
# 4284
_M_initialize(); 
# 4285
} 
# 4288
double mean() const 
# 4289
{ return _M_mean; } 
# 4292
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 4293
{ return (__p1._M_mean) == (__p2._M_mean); } 
# 4298
private: void _M_initialize(); 
# 4300
double _M_mean; 
# 4302
double _M_lm_thr; 
# 4304
double _M_lfm, _M_sm, _M_d, _M_scx, _M_1cx, _M_c2b, _M_cb; 
# 4306
}; 
# 4310
explicit poisson_distribution(double __mean = (1.0)) : _M_param(__mean), _M_nd() 
# 4312
{ } 
# 4315
explicit poisson_distribution(const param_type &__p) : _M_param(__p), _M_nd() 
# 4317
{ } 
# 4323
void reset() 
# 4324
{ (_M_nd).reset(); } 
# 4330
double mean() const 
# 4331
{ return ((_M_param).mean()); } 
# 4337
param_type param() const 
# 4338
{ return _M_param; } 
# 4345
void param(const param_type &__param) 
# 4346
{ (_M_param) = __param; } 
# 4352
result_type min() const 
# 4353
{ return 0; } 
# 4359
result_type max() const 
# 4360
{ return std::numeric_limits< _IntType> ::max(); } 
# 4365
template< class _UniformRandomNumberGenerator> result_type 
# 4367
operator()(_UniformRandomNumberGenerator &__urng) 
# 4368
{ return (this->operator()(__urng, _M_param)); } 
# 4370
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 4375
template< class _ForwardIterator, class 
# 4376
_UniformRandomNumberGenerator> void 
# 4378
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 4379
__urng) 
# 4380
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 4382
template< class _ForwardIterator, class 
# 4383
_UniformRandomNumberGenerator> void 
# 4385
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 4386
__urng, const param_type &
# 4387
__p) 
# 4388
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 4390
template< class _UniformRandomNumberGenerator> void 
# 4392
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 4393
__urng, const param_type &
# 4394
__p) 
# 4395
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 4403
friend inline bool operator==(const poisson_distribution &__d1, const poisson_distribution &
# 4404
__d2) 
# 4406
{ return ((__d1._M_param) == (__d2._M_param)) && ((__d1._M_nd) == (__d2._M_nd)); } 
# 4421 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::poisson_distribution< _IntType1>  & __x); 
# 4436 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::poisson_distribution< _IntType1>  & __x); 
# 4442
private: template< class _ForwardIterator, class 
# 4443
_UniformRandomNumberGenerator> void 
# 4442
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 4449
param_type _M_param; 
# 4452
normal_distribution< double>  _M_nd; 
# 4453
}; 
# 4458
template< class _IntType> inline bool 
# 4460
operator!=(const poisson_distribution< _IntType>  &__d1, const poisson_distribution< _IntType>  &
# 4461
__d2) 
# 4462
{ return !(__d1 == __d2); } 
# 4480 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 4481
class exponential_distribution { 
# 4483
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 4488
public: typedef _RealType result_type; 
# 4490
struct param_type { 
# 4492
typedef exponential_distribution distribution_type; 
# 4495
explicit param_type(_RealType __lambda = (_RealType)1) : _M_lambda(__lambda) 
# 4497
{ 
# 4498
; 
# 4499
} 
# 4502
_RealType lambda() const 
# 4503
{ return _M_lambda; } 
# 4506
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 4507
{ return (__p1._M_lambda) == (__p2._M_lambda); } 
# 4510
private: _RealType _M_lambda; 
# 4511
}; 
# 4519
explicit exponential_distribution(const result_type &__lambda = (result_type)1) : _M_param(__lambda) 
# 4521
{ } 
# 4524
explicit exponential_distribution(const param_type &__p) : _M_param(__p) 
# 4526
{ } 
# 4534
void reset() { } 
# 4540
_RealType lambda() const 
# 4541
{ return ((_M_param).lambda()); } 
# 4547
param_type param() const 
# 4548
{ return _M_param; } 
# 4555
void param(const param_type &__param) 
# 4556
{ (_M_param) = __param; } 
# 4562
result_type min() const 
# 4563
{ return (result_type)0; } 
# 4569
result_type max() const 
# 4570
{ return std::numeric_limits< _RealType> ::max(); } 
# 4575
template< class _UniformRandomNumberGenerator> result_type 
# 4577
operator()(_UniformRandomNumberGenerator &__urng) 
# 4578
{ return (this->operator()(__urng, _M_param)); } 
# 4580
template< class _UniformRandomNumberGenerator> result_type 
# 4582
operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 4583
__p) 
# 4584
{ 
# 4586
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 4587
return (-std::log(((result_type)1) - __aurng())) / (__p.lambda()); 
# 4588
} 
# 4590
template< class _ForwardIterator, class 
# 4591
_UniformRandomNumberGenerator> void 
# 4593
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 4594
__urng) 
# 4595
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 4597
template< class _ForwardIterator, class 
# 4598
_UniformRandomNumberGenerator> void 
# 4600
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 4601
__urng, const param_type &
# 4602
__p) 
# 4603
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 4605
template< class _UniformRandomNumberGenerator> void 
# 4607
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 4608
__urng, const param_type &
# 4609
__p) 
# 4610
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 4617
friend inline bool operator==(const exponential_distribution &__d1, const exponential_distribution &
# 4618
__d2) 
# 4619
{ return (__d1._M_param) == (__d2._M_param); } 
# 4622
private: template< class _ForwardIterator, class 
# 4623
_UniformRandomNumberGenerator> void 
# 4622
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 4629
param_type _M_param; 
# 4630
}; 
# 4636
template< class _RealType> inline bool 
# 4638
operator!=(const exponential_distribution< _RealType>  &__d1, const exponential_distribution< _RealType>  &
# 4639
__d2) 
# 4640
{ return !(__d1 == __d2); } 
# 4652 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const exponential_distribution< _RealType>  & __x); 
# 4667 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, exponential_distribution< _RealType>  & __x); 
# 4682 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 4683
class weibull_distribution { 
# 4685
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 4690
public: typedef _RealType result_type; 
# 4692
struct param_type { 
# 4694
typedef weibull_distribution distribution_type; 
# 4697
explicit param_type(_RealType __a = (_RealType)1, _RealType 
# 4698
__b = (_RealType)1) : _M_a(__a), _M_b(__b) 
# 4700
{ } 
# 4703
_RealType a() const 
# 4704
{ return _M_a; } 
# 4707
_RealType b() const 
# 4708
{ return _M_b; } 
# 4711
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 4712
{ return ((__p1._M_a) == (__p2._M_a)) && ((__p1._M_b) == (__p2._M_b)); } 
# 4715
private: _RealType _M_a; 
# 4716
_RealType _M_b; 
# 4717
}; 
# 4720
explicit weibull_distribution(_RealType __a = (_RealType)1, _RealType 
# 4721
__b = (_RealType)1) : _M_param(__a, __b) 
# 4723
{ } 
# 4726
explicit weibull_distribution(const param_type &__p) : _M_param(__p) 
# 4728
{ } 
# 4734
void reset() 
# 4735
{ } 
# 4741
_RealType a() const 
# 4742
{ return ((_M_param).a()); } 
# 4748
_RealType b() const 
# 4749
{ return ((_M_param).b()); } 
# 4755
param_type param() const 
# 4756
{ return _M_param; } 
# 4763
void param(const param_type &__param) 
# 4764
{ (_M_param) = __param; } 
# 4770
result_type min() const 
# 4771
{ return (result_type)0; } 
# 4777
result_type max() const 
# 4778
{ return std::numeric_limits< _RealType> ::max(); } 
# 4783
template< class _UniformRandomNumberGenerator> result_type 
# 4785
operator()(_UniformRandomNumberGenerator &__urng) 
# 4786
{ return (this->operator()(__urng, _M_param)); } 
# 4788
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 4793
template< class _ForwardIterator, class 
# 4794
_UniformRandomNumberGenerator> void 
# 4796
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 4797
__urng) 
# 4798
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 4800
template< class _ForwardIterator, class 
# 4801
_UniformRandomNumberGenerator> void 
# 4803
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 4804
__urng, const param_type &
# 4805
__p) 
# 4806
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 4808
template< class _UniformRandomNumberGenerator> void 
# 4810
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 4811
__urng, const param_type &
# 4812
__p) 
# 4813
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 4820
friend inline bool operator==(const weibull_distribution &__d1, const weibull_distribution &
# 4821
__d2) 
# 4822
{ return (__d1._M_param) == (__d2._M_param); } 
# 4825
private: template< class _ForwardIterator, class 
# 4826
_UniformRandomNumberGenerator> void 
# 4825
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 4832
param_type _M_param; 
# 4833
}; 
# 4839
template< class _RealType> inline bool 
# 4841
operator!=(const weibull_distribution< _RealType>  &__d1, const weibull_distribution< _RealType>  &
# 4842
__d2) 
# 4843
{ return !(__d1 == __d2); } 
# 4855 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const weibull_distribution< _RealType>  & __x); 
# 4870 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, weibull_distribution< _RealType>  & __x); 
# 4885 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 4886
class extreme_value_distribution { 
# 4888
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 4893
public: typedef _RealType result_type; 
# 4895
struct param_type { 
# 4897
typedef extreme_value_distribution distribution_type; 
# 4900
explicit param_type(_RealType __a = (_RealType)0, _RealType 
# 4901
__b = (_RealType)1) : _M_a(__a), _M_b(__b) 
# 4903
{ } 
# 4906
_RealType a() const 
# 4907
{ return _M_a; } 
# 4910
_RealType b() const 
# 4911
{ return _M_b; } 
# 4914
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 4915
{ return ((__p1._M_a) == (__p2._M_a)) && ((__p1._M_b) == (__p2._M_b)); } 
# 4918
private: _RealType _M_a; 
# 4919
_RealType _M_b; 
# 4920
}; 
# 4923
explicit extreme_value_distribution(_RealType __a = (_RealType)0, _RealType 
# 4924
__b = (_RealType)1) : _M_param(__a, __b) 
# 4926
{ } 
# 4929
explicit extreme_value_distribution(const param_type &__p) : _M_param(__p) 
# 4931
{ } 
# 4937
void reset() 
# 4938
{ } 
# 4944
_RealType a() const 
# 4945
{ return ((_M_param).a()); } 
# 4951
_RealType b() const 
# 4952
{ return ((_M_param).b()); } 
# 4958
param_type param() const 
# 4959
{ return _M_param; } 
# 4966
void param(const param_type &__param) 
# 4967
{ (_M_param) = __param; } 
# 4973
result_type min() const 
# 4974
{ return std::numeric_limits< _RealType> ::lowest(); } 
# 4980
result_type max() const 
# 4981
{ return std::numeric_limits< _RealType> ::max(); } 
# 4986
template< class _UniformRandomNumberGenerator> result_type 
# 4988
operator()(_UniformRandomNumberGenerator &__urng) 
# 4989
{ return (this->operator()(__urng, _M_param)); } 
# 4991
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 4996
template< class _ForwardIterator, class 
# 4997
_UniformRandomNumberGenerator> void 
# 4999
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 5000
__urng) 
# 5001
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 5003
template< class _ForwardIterator, class 
# 5004
_UniformRandomNumberGenerator> void 
# 5006
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 5007
__urng, const param_type &
# 5008
__p) 
# 5009
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 5011
template< class _UniformRandomNumberGenerator> void 
# 5013
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 5014
__urng, const param_type &
# 5015
__p) 
# 5016
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 5023
friend inline bool operator==(const extreme_value_distribution &__d1, const extreme_value_distribution &
# 5024
__d2) 
# 5025
{ return (__d1._M_param) == (__d2._M_param); } 
# 5028
private: template< class _ForwardIterator, class 
# 5029
_UniformRandomNumberGenerator> void 
# 5028
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 5035
param_type _M_param; 
# 5036
}; 
# 5042
template< class _RealType> inline bool 
# 5044
operator!=(const extreme_value_distribution< _RealType>  &__d1, const extreme_value_distribution< _RealType>  &
# 5045
__d2) 
# 5046
{ return !(__d1 == __d2); } 
# 5058 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const extreme_value_distribution< _RealType>  & __x); 
# 5073 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, extreme_value_distribution< _RealType>  & __x); 
# 5085 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType = int> 
# 5086
class discrete_distribution { 
# 5088
static_assert((std::is_integral< _IntType> ::value), "template argument not an integral type");
# 5093
public: typedef _IntType result_type; 
# 5095
struct param_type { 
# 5097
typedef discrete_distribution distribution_type; 
# 5098
friend class discrete_distribution; 
# 5100
param_type() : _M_prob(), _M_cp() 
# 5102
{ } 
# 5104
template< class _InputIterator> 
# 5105
param_type(_InputIterator __wbegin, _InputIterator 
# 5106
__wend) : _M_prob(__wbegin, __wend), _M_cp() 
# 5108
{ _M_initialize(); } 
# 5110
param_type(initializer_list< double>  __wil) : _M_prob(__wil.begin(), __wil.end()), _M_cp() 
# 5112
{ _M_initialize(); } 
# 5114
template< class _Func> param_type(size_t __nw, double __xmin, double __xmax, _Func __fw); 
# 5119
param_type(const param_type &) = default;
# 5120
param_type &operator=(const param_type &) = default;
# 5123
vector< double>  probabilities() const 
# 5124
{ return ((_M_prob).empty() ? vector< double> (1, (1.0)) : _M_prob); } 
# 5127
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 5128
{ return (__p1._M_prob) == (__p2._M_prob); } 
# 5132
private: void _M_initialize(); 
# 5134
vector< double>  _M_prob; 
# 5135
vector< double>  _M_cp; 
# 5136
}; 
# 5138
discrete_distribution() : _M_param() 
# 5140
{ } 
# 5142
template< class _InputIterator> 
# 5143
discrete_distribution(_InputIterator __wbegin, _InputIterator 
# 5144
__wend) : _M_param(__wbegin, __wend) 
# 5146
{ } 
# 5148
discrete_distribution(initializer_list< double>  __wl) : _M_param(__wl) 
# 5150
{ } 
# 5152
template< class _Func> 
# 5153
discrete_distribution(size_t __nw, double __xmin, double __xmax, _Func 
# 5154
__fw) : _M_param(__nw, __xmin, __xmax, __fw) 
# 5156
{ } 
# 5159
explicit discrete_distribution(const param_type &__p) : _M_param(__p) 
# 5161
{ } 
# 5167
void reset() 
# 5168
{ } 
# 5174
vector< double>  probabilities() const 
# 5175
{ 
# 5176
return ((((_M_param)._M_prob).empty())) ? vector< double> (1, (1.0)) : ((_M_param)._M_prob); 
# 5178
} 
# 5184
param_type param() const 
# 5185
{ return _M_param; } 
# 5192
void param(const param_type &__param) 
# 5193
{ (_M_param) = __param; } 
# 5199
result_type min() const 
# 5200
{ return (result_type)0; } 
# 5206
result_type max() const 
# 5207
{ 
# 5208
return ((((_M_param)._M_prob).empty())) ? (result_type)0 : ((result_type)((((_M_param)._M_prob).size()) - 1)); 
# 5210
} 
# 5215
template< class _UniformRandomNumberGenerator> result_type 
# 5217
operator()(_UniformRandomNumberGenerator &__urng) 
# 5218
{ return (this->operator()(__urng, _M_param)); } 
# 5220
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 5225
template< class _ForwardIterator, class 
# 5226
_UniformRandomNumberGenerator> void 
# 5228
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 5229
__urng) 
# 5230
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 5232
template< class _ForwardIterator, class 
# 5233
_UniformRandomNumberGenerator> void 
# 5235
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 5236
__urng, const param_type &
# 5237
__p) 
# 5238
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 5240
template< class _UniformRandomNumberGenerator> void 
# 5242
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 5243
__urng, const param_type &
# 5244
__p) 
# 5245
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 5252
friend inline bool operator==(const discrete_distribution &__d1, const discrete_distribution &
# 5253
__d2) 
# 5254
{ return (__d1._M_param) == (__d2._M_param); } 
# 5266 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::discrete_distribution< _IntType1>  & __x); 
# 5282 "/usr/include/c++/5/bits/random.h" 3
template< class _IntType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::discrete_distribution< _IntType1>  & __x); 
# 5288
private: template< class _ForwardIterator, class 
# 5289
_UniformRandomNumberGenerator> void 
# 5288
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 5295
param_type _M_param; 
# 5296
}; 
# 5302
template< class _IntType> inline bool 
# 5304
operator!=(const discrete_distribution< _IntType>  &__d1, const discrete_distribution< _IntType>  &
# 5305
__d2) 
# 5306
{ return !(__d1 == __d2); } 
# 5315 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 5316
class piecewise_constant_distribution { 
# 5318
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 5323
public: typedef _RealType result_type; 
# 5325
struct param_type { 
# 5327
typedef piecewise_constant_distribution distribution_type; 
# 5328
friend class piecewise_constant_distribution; 
# 5330
param_type() : _M_int(), _M_den(), _M_cp() 
# 5332
{ } 
# 5334
template< class _InputIteratorB, class _InputIteratorW> param_type(_InputIteratorB __bfirst, _InputIteratorB __bend, _InputIteratorW __wbegin); 
# 5339
template< class _Func> param_type(initializer_list< _RealType>  __bi, _Func __fw); 
# 5342
template< class _Func> param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw); 
# 5347
param_type(const param_type &) = default;
# 5348
param_type &operator=(const param_type &) = default;
# 5351
vector< _RealType>  intervals() const 
# 5352
{ 
# 5353
if (((_M_int).empty())) 
# 5354
{ 
# 5355
vector< _RealType>  __tmp(2); 
# 5356
(__tmp[1]) = ((_RealType)1); 
# 5357
return __tmp; 
# 5358
} else { 
# 5360
return _M_int; }  
# 5361
} 
# 5364
vector< double>  densities() const 
# 5365
{ return ((_M_den).empty() ? vector< double> (1, (1.0)) : _M_den); } 
# 5368
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 5369
{ return ((__p1._M_int) == (__p2._M_int)) && ((__p1._M_den) == (__p2._M_den)); } 
# 5373
private: void _M_initialize(); 
# 5375
vector< _RealType>  _M_int; 
# 5376
vector< double>  _M_den; 
# 5377
vector< double>  _M_cp; 
# 5378
}; 
# 5381
explicit piecewise_constant_distribution() : _M_param() 
# 5383
{ } 
# 5385
template< class _InputIteratorB, class _InputIteratorW> 
# 5386
piecewise_constant_distribution(_InputIteratorB __bfirst, _InputIteratorB 
# 5387
__bend, _InputIteratorW 
# 5388
__wbegin) : _M_param(__bfirst, __bend, __wbegin) 
# 5390
{ } 
# 5392
template< class _Func> 
# 5393
piecewise_constant_distribution(initializer_list< _RealType>  __bl, _Func 
# 5394
__fw) : _M_param(__bl, __fw) 
# 5396
{ } 
# 5398
template< class _Func> 
# 5399
piecewise_constant_distribution(size_t __nw, _RealType 
# 5400
__xmin, _RealType __xmax, _Func 
# 5401
__fw) : _M_param(__nw, __xmin, __xmax, __fw) 
# 5403
{ } 
# 5406
explicit piecewise_constant_distribution(const param_type &__p) : _M_param(__p) 
# 5408
{ } 
# 5414
void reset() 
# 5415
{ } 
# 5421
vector< _RealType>  intervals() const 
# 5422
{ 
# 5423
if ((((_M_param)._M_int).empty())) 
# 5424
{ 
# 5425
vector< _RealType>  __tmp(2); 
# 5426
(__tmp[1]) = ((_RealType)1); 
# 5427
return __tmp; 
# 5428
} else { 
# 5430
return ((_M_param)._M_int); }  
# 5431
} 
# 5437
vector< double>  densities() const 
# 5438
{ 
# 5439
return ((((_M_param)._M_den).empty())) ? vector< double> (1, (1.0)) : ((_M_param)._M_den); 
# 5441
} 
# 5447
param_type param() const 
# 5448
{ return _M_param; } 
# 5455
void param(const param_type &__param) 
# 5456
{ (_M_param) = __param; } 
# 5462
result_type min() const 
# 5463
{ 
# 5464
return ((((_M_param)._M_int).empty())) ? (result_type)0 : (((_M_param)._M_int).front()); 
# 5466
} 
# 5472
result_type max() const 
# 5473
{ 
# 5474
return ((((_M_param)._M_int).empty())) ? (result_type)1 : (((_M_param)._M_int).back()); 
# 5476
} 
# 5481
template< class _UniformRandomNumberGenerator> result_type 
# 5483
operator()(_UniformRandomNumberGenerator &__urng) 
# 5484
{ return (this->operator()(__urng, _M_param)); } 
# 5486
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 5491
template< class _ForwardIterator, class 
# 5492
_UniformRandomNumberGenerator> void 
# 5494
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 5495
__urng) 
# 5496
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 5498
template< class _ForwardIterator, class 
# 5499
_UniformRandomNumberGenerator> void 
# 5501
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 5502
__urng, const param_type &
# 5503
__p) 
# 5504
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 5506
template< class _UniformRandomNumberGenerator> void 
# 5508
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 5509
__urng, const param_type &
# 5510
__p) 
# 5511
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 5518
friend inline bool operator==(const piecewise_constant_distribution &__d1, const piecewise_constant_distribution &
# 5519
__d2) 
# 5520
{ return (__d1._M_param) == (__d2._M_param); } 
# 5533 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::piecewise_constant_distribution< _RealType1>  & __x); 
# 5549 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::piecewise_constant_distribution< _RealType1>  & __x); 
# 5555
private: template< class _ForwardIterator, class 
# 5556
_UniformRandomNumberGenerator> void 
# 5555
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 5562
param_type _M_param; 
# 5563
}; 
# 5569
template< class _RealType> inline bool 
# 5571
operator!=(const piecewise_constant_distribution< _RealType>  &__d1, const piecewise_constant_distribution< _RealType>  &
# 5572
__d2) 
# 5573
{ return !(__d1 == __d2); } 
# 5582 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType = double> 
# 5583
class piecewise_linear_distribution { 
# 5585
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 5590
public: typedef _RealType result_type; 
# 5592
struct param_type { 
# 5594
typedef piecewise_linear_distribution distribution_type; 
# 5595
friend class piecewise_linear_distribution; 
# 5597
param_type() : _M_int(), _M_den(), _M_cp(), _M_m() 
# 5599
{ } 
# 5601
template< class _InputIteratorB, class _InputIteratorW> param_type(_InputIteratorB __bfirst, _InputIteratorB __bend, _InputIteratorW __wbegin); 
# 5606
template< class _Func> param_type(initializer_list< _RealType>  __bl, _Func __fw); 
# 5609
template< class _Func> param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw); 
# 5614
param_type(const param_type &) = default;
# 5615
param_type &operator=(const param_type &) = default;
# 5618
vector< _RealType>  intervals() const 
# 5619
{ 
# 5620
if (((_M_int).empty())) 
# 5621
{ 
# 5622
vector< _RealType>  __tmp(2); 
# 5623
(__tmp[1]) = ((_RealType)1); 
# 5624
return __tmp; 
# 5625
} else { 
# 5627
return _M_int; }  
# 5628
} 
# 5631
vector< double>  densities() const 
# 5632
{ return ((_M_den).empty() ? vector< double> (2, (1.0)) : _M_den); } 
# 5635
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 5636
{ return ((__p1._M_int) == (__p2._M_int)) && ((__p1._M_den) == (__p2._M_den)); 
# 5637
} 
# 5641
private: void _M_initialize(); 
# 5643
vector< _RealType>  _M_int; 
# 5644
vector< double>  _M_den; 
# 5645
vector< double>  _M_cp; 
# 5646
vector< double>  _M_m; 
# 5647
}; 
# 5650
explicit piecewise_linear_distribution() : _M_param() 
# 5652
{ } 
# 5654
template< class _InputIteratorB, class _InputIteratorW> 
# 5655
piecewise_linear_distribution(_InputIteratorB __bfirst, _InputIteratorB 
# 5656
__bend, _InputIteratorW 
# 5657
__wbegin) : _M_param(__bfirst, __bend, __wbegin) 
# 5659
{ } 
# 5661
template< class _Func> 
# 5662
piecewise_linear_distribution(initializer_list< _RealType>  __bl, _Func 
# 5663
__fw) : _M_param(__bl, __fw) 
# 5665
{ } 
# 5667
template< class _Func> 
# 5668
piecewise_linear_distribution(size_t __nw, _RealType 
# 5669
__xmin, _RealType __xmax, _Func 
# 5670
__fw) : _M_param(__nw, __xmin, __xmax, __fw) 
# 5672
{ } 
# 5675
explicit piecewise_linear_distribution(const param_type &__p) : _M_param(__p) 
# 5677
{ } 
# 5683
void reset() 
# 5684
{ } 
# 5690
vector< _RealType>  intervals() const 
# 5691
{ 
# 5692
if ((((_M_param)._M_int).empty())) 
# 5693
{ 
# 5694
vector< _RealType>  __tmp(2); 
# 5695
(__tmp[1]) = ((_RealType)1); 
# 5696
return __tmp; 
# 5697
} else { 
# 5699
return ((_M_param)._M_int); }  
# 5700
} 
# 5707
vector< double>  densities() const 
# 5708
{ 
# 5709
return ((((_M_param)._M_den).empty())) ? vector< double> (2, (1.0)) : ((_M_param)._M_den); 
# 5711
} 
# 5717
param_type param() const 
# 5718
{ return _M_param; } 
# 5725
void param(const param_type &__param) 
# 5726
{ (_M_param) = __param; } 
# 5732
result_type min() const 
# 5733
{ 
# 5734
return ((((_M_param)._M_int).empty())) ? (result_type)0 : (((_M_param)._M_int).front()); 
# 5736
} 
# 5742
result_type max() const 
# 5743
{ 
# 5744
return ((((_M_param)._M_int).empty())) ? (result_type)1 : (((_M_param)._M_int).back()); 
# 5746
} 
# 5751
template< class _UniformRandomNumberGenerator> result_type 
# 5753
operator()(_UniformRandomNumberGenerator &__urng) 
# 5754
{ return (this->operator()(__urng, _M_param)); } 
# 5756
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 5761
template< class _ForwardIterator, class 
# 5762
_UniformRandomNumberGenerator> void 
# 5764
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 5765
__urng) 
# 5766
{ (this->__generate(__f, __t, __urng, _M_param)); } 
# 5768
template< class _ForwardIterator, class 
# 5769
_UniformRandomNumberGenerator> void 
# 5771
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 5772
__urng, const param_type &
# 5773
__p) 
# 5774
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 5776
template< class _UniformRandomNumberGenerator> void 
# 5778
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 5779
__urng, const param_type &
# 5780
__p) 
# 5781
{ (this->__generate_impl(__f, __t, __urng, __p)); } 
# 5788
friend inline bool operator==(const piecewise_linear_distribution &__d1, const piecewise_linear_distribution &
# 5789
__d2) 
# 5790
{ return (__d1._M_param) == (__d2._M_param); } 
# 5803 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __os, const std::piecewise_linear_distribution< _RealType1>  & __x); 
# 5819 "/usr/include/c++/5/bits/random.h" 3
template< class _RealType1, class _CharT, class _Traits> friend basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, std::piecewise_linear_distribution< _RealType1>  & __x); 
# 5825
private: template< class _ForwardIterator, class 
# 5826
_UniformRandomNumberGenerator> void 
# 5825
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 5832
param_type _M_param; 
# 5833
}; 
# 5839
template< class _RealType> inline bool 
# 5841
operator!=(const piecewise_linear_distribution< _RealType>  &__d1, const piecewise_linear_distribution< _RealType>  &
# 5842
__d2) 
# 5843
{ return !(__d1 == __d2); } 
# 5860 "/usr/include/c++/5/bits/random.h" 3
class seed_seq { 
# 5865
public: typedef uint_least32_t result_type; 
# 5868
seed_seq() : _M_v() 
# 5870
{ } 
# 5872
template< class _IntType> seed_seq(initializer_list< _IntType>  il); 
# 5875
template< class _InputIterator> seed_seq(_InputIterator __begin, _InputIterator __end); 
# 5879
template< class _RandomAccessIterator> void generate(_RandomAccessIterator __begin, _RandomAccessIterator __end); 
# 5884
size_t size() const 
# 5885
{ return (_M_v).size(); } 
# 5887
template< class OutputIterator> void 
# 5889
param(OutputIterator __dest) const 
# 5890
{ std::copy((_M_v).begin(), (_M_v).end(), __dest); } 
# 5894
private: vector< unsigned>  _M_v; 
# 5895
}; 
# 5902
}
# 65 "/usr/include/c++/5/bits/stl_numeric.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 80 "/usr/include/c++/5/bits/stl_numeric.h" 3
template< class _ForwardIterator, class _Tp> void 
# 82
iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value) 
# 83
{ 
# 89
; 
# 91
for (; __first != __last; ++__first) 
# 92
{ 
# 93
(*__first) = __value; 
# 94
++__value; 
# 95
}  
# 96
} 
# 99
}
# 103
namespace std __attribute((__visibility__("default"))) { 
# 118 "/usr/include/c++/5/bits/stl_numeric.h" 3
template< class _InputIterator, class _Tp> inline _Tp 
# 120
accumulate(_InputIterator __first, _InputIterator __last, _Tp __init) 
# 121
{ 
# 124
; 
# 126
for (; __first != __last; ++__first) { 
# 127
__init = (__init + (*__first)); }  
# 128
return __init; 
# 129
} 
# 144 "/usr/include/c++/5/bits/stl_numeric.h" 3
template< class _InputIterator, class _Tp, class _BinaryOperation> inline _Tp 
# 146
accumulate(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation 
# 147
__binary_op) 
# 148
{ 
# 151
; 
# 153
for (; __first != __last; ++__first) { 
# 154
__init = __binary_op(__init, *__first); }  
# 155
return __init; 
# 156
} 
# 172 "/usr/include/c++/5/bits/stl_numeric.h" 3
template< class _InputIterator1, class _InputIterator2, class _Tp> inline _Tp 
# 174
inner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 175
__first2, _Tp __init) 
# 176
{ 
# 180
; 
# 182
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 183
__init = (__init + ((*__first1) * (*__first2))); }  
# 184
return __init; 
# 185
} 
# 203 "/usr/include/c++/5/bits/stl_numeric.h" 3
template< class _InputIterator1, class _InputIterator2, class _Tp, class 
# 204
_BinaryOperation1, class _BinaryOperation2> inline _Tp 
# 206
inner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 207
__first2, _Tp __init, _BinaryOperation1 
# 208
__binary_op1, _BinaryOperation2 
# 209
__binary_op2) 
# 210
{ 
# 214
; 
# 216
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 217
__init = __binary_op1(__init, __binary_op2(*__first1, *__first2)); }  
# 218
return __init; 
# 219
} 
# 235 "/usr/include/c++/5/bits/stl_numeric.h" 3
template< class _InputIterator, class _OutputIterator> _OutputIterator 
# 237
partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 238
__result) 
# 239
{ 
# 240
typedef typename iterator_traits< _InputIterator> ::value_type _ValueType; 
# 246
; 
# 248
if (__first == __last) { 
# 249
return __result; }  
# 250
_ValueType __value = *__first; 
# 251
(*__result) = __value; 
# 252
while ((++__first) != __last) 
# 253
{ 
# 254
__value = (__value + (*__first)); 
# 255
(*(++__result)) = __value; 
# 256
}  
# 257
return ++__result; 
# 258
} 
# 275 "/usr/include/c++/5/bits/stl_numeric.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 276
_BinaryOperation> _OutputIterator 
# 278
partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 279
__result, _BinaryOperation __binary_op) 
# 280
{ 
# 281
typedef typename iterator_traits< _InputIterator> ::value_type _ValueType; 
# 287
; 
# 289
if (__first == __last) { 
# 290
return __result; }  
# 291
_ValueType __value = *__first; 
# 292
(*__result) = __value; 
# 293
while ((++__first) != __last) 
# 294
{ 
# 295
__value = __binary_op(__value, *__first); 
# 296
(*(++__result)) = __value; 
# 297
}  
# 298
return ++__result; 
# 299
} 
# 315 "/usr/include/c++/5/bits/stl_numeric.h" 3
template< class _InputIterator, class _OutputIterator> _OutputIterator 
# 317
adjacent_difference(_InputIterator __first, _InputIterator 
# 318
__last, _OutputIterator __result) 
# 319
{ 
# 320
typedef typename iterator_traits< _InputIterator> ::value_type _ValueType; 
# 326
; 
# 328
if (__first == __last) { 
# 329
return __result; }  
# 330
_ValueType __value = *__first; 
# 331
(*__result) = __value; 
# 332
while ((++__first) != __last) 
# 333
{ 
# 334
_ValueType __tmp = *__first; 
# 335
(*(++__result)) = (__tmp - __value); 
# 336
__value = std::move(__tmp); 
# 337
}  
# 338
return ++__result; 
# 339
} 
# 357 "/usr/include/c++/5/bits/stl_numeric.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 358
_BinaryOperation> _OutputIterator 
# 360
adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 361
__result, _BinaryOperation __binary_op) 
# 362
{ 
# 363
typedef typename iterator_traits< _InputIterator> ::value_type _ValueType; 
# 369
; 
# 371
if (__first == __last) { 
# 372
return __result; }  
# 373
_ValueType __value = *__first; 
# 374
(*__result) = __value; 
# 375
while ((++__first) != __last) 
# 376
{ 
# 377
_ValueType __tmp = *__first; 
# 378
(*(++__result)) = __binary_op(__tmp, __value); 
# 379
__value = std::move(__tmp); 
# 380
}  
# 381
return ++__result; 
# 382
} 
# 385
}
# 35 "/usr/include/c++/5/bits/random.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 40
namespace __detail { 
# 50
template< class _Tp, _Tp __m, _Tp __a, _Tp __c> _Tp 
# 53
_Mod< _Tp, __m, __a, __c, false, true> ::__calc(_Tp __x) 
# 54
{ 
# 55
if (__a == 1) { 
# 56
__x %= __m; } else 
# 58
{ 
# 59
static const _Tp __q = (__m / __a); 
# 60
static const _Tp __r = (__m % __a); 
# 62
_Tp __t1 = __a * (__x % __q); 
# 63
_Tp __t2 = __r * (__x / __q); 
# 64
if (__t1 >= __t2) { 
# 65
__x = (__t1 - __t2); } else { 
# 67
__x = ((__m - __t2) + __t1); }  
# 68
}  
# 70
if (__c != 0) 
# 71
{ 
# 72
const _Tp __d = __m - __x; 
# 73
if (__d > __c) { 
# 74
__x += __c; } else { 
# 76
__x = (__c - __d); }  
# 77
}  
# 78
return __x; 
# 79
} 
# 81
template< class _InputIterator, class _OutputIterator, class 
# 82
_Tp> _OutputIterator 
# 84
__normalize(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 85
__result, const _Tp &__factor) 
# 86
{ 
# 87
for (; __first != __last; (++__first), (++__result)) { 
# 88
(*__result) = ((*__first) / __factor); }  
# 89
return __result; 
# 90
} 
# 93
}
# 97
template< class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> constexpr _UIntType 
# 99
linear_congruential_engine< _UIntType, __a, __c, __m> ::multiplier; 
# 101
template< class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> constexpr _UIntType 
# 103
linear_congruential_engine< _UIntType, __a, __c, __m> ::increment; 
# 105
template< class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> constexpr _UIntType 
# 107
linear_congruential_engine< _UIntType, __a, __c, __m> ::modulus; 
# 109
template< class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> constexpr _UIntType 
# 111
linear_congruential_engine< _UIntType, __a, __c, __m> ::default_seed; 
# 117
template< class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> void 
# 120
linear_congruential_engine< _UIntType, __a, __c, __m> ::seed(result_type __s) 
# 121
{ 
# 122
if ((__detail::__mod< _UIntType, __m> (__c) == 0) && (__detail::__mod< _UIntType, __m> (__s) == 0)) { 
# 124
(_M_x) = 1; } else { 
# 126
(_M_x) = __detail::__mod< _UIntType, __m> (__s); }  
# 127
} 
# 132
template< class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> 
# 133
template< class _Sseq> typename enable_if< is_class< _Sseq> ::value> ::type 
# 136
linear_congruential_engine< _UIntType, __a, __c, __m> ::seed(_Sseq &__q) 
# 137
{ 
# 138
const _UIntType __k0 = (__m == 0) ? std::numeric_limits< _UIntType> ::digits : std::__lg(__m); 
# 140
const _UIntType __k = (__k0 + 31) / 32; 
# 141
uint_least32_t __arr[(__k + 3)];   
# 142
(__q.generate((__arr) + 0, (__arr + __k) + 3)); 
# 143
_UIntType __factor = (1U); 
# 144
_UIntType __sum = (0U); 
# 145
for (size_t __j = (0); __j < __k; ++__j) 
# 146
{ 
# 147
__sum += (((__arr)[__j + (3)]) * __factor); 
# 148
__factor *= __detail::_Shift< _UIntType, 32UL> ::__value; 
# 149
}  
# 150
seed(__sum); 
# 151
} 
# 153
template< class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m, class 
# 154
_CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 156
operator<<(basic_ostream< _CharT, _Traits>  &__os, const linear_congruential_engine< _UIntType, __a, __c, __m>  &
# 158
__lcr) 
# 159
{ 
# 160
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 161
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 163
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 164
const _CharT __fill = (__os.fill()); 
# 165
(__os.flags((__ios_base::dec | __ios_base::fixed) | __ios_base::left)); 
# 166
(__os.fill((__os.widen(' ')))); 
# 168
__os << (__lcr._M_x); 
# 170
(__os.flags(__flags)); 
# 171
(__os.fill(__fill)); 
# 172
return __os; 
# 173
} 
# 175
template< class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m, class 
# 176
_CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 178
operator>>(basic_istream< _CharT, _Traits>  &__is, linear_congruential_engine< _UIntType, __a, __c, __m>  &
# 179
__lcr) 
# 180
{ 
# 181
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 182
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 184
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 185
(__is.flags(__ios_base::dec)); 
# 187
__is >> (__lcr._M_x); 
# 189
(__is.flags(__flags)); 
# 190
return __is; 
# 191
} 
# 194
template< class _UIntType, size_t 
# 195
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 196
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 197
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 198
__f> constexpr size_t 
# 201
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::word_size; 
# 203
template< class _UIntType, size_t 
# 204
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 205
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 206
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 207
__f> constexpr size_t 
# 210
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::state_size; 
# 212
template< class _UIntType, size_t 
# 213
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 214
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 215
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 216
__f> constexpr size_t 
# 219
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::shift_size; 
# 221
template< class _UIntType, size_t 
# 222
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 223
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 224
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 225
__f> constexpr size_t 
# 228
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::mask_bits; 
# 230
template< class _UIntType, size_t 
# 231
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 232
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 233
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 234
__f> constexpr _UIntType 
# 237
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::xor_mask; 
# 239
template< class _UIntType, size_t 
# 240
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 241
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 242
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 243
__f> constexpr size_t 
# 246
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::tempering_u; 
# 248
template< class _UIntType, size_t 
# 249
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 250
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 251
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 252
__f> constexpr _UIntType 
# 255
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::tempering_d; 
# 257
template< class _UIntType, size_t 
# 258
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 259
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 260
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 261
__f> constexpr size_t 
# 264
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::tempering_s; 
# 266
template< class _UIntType, size_t 
# 267
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 268
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 269
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 270
__f> constexpr _UIntType 
# 273
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::tempering_b; 
# 275
template< class _UIntType, size_t 
# 276
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 277
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 278
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 279
__f> constexpr size_t 
# 282
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::tempering_t; 
# 284
template< class _UIntType, size_t 
# 285
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 286
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 287
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 288
__f> constexpr _UIntType 
# 291
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::tempering_c; 
# 293
template< class _UIntType, size_t 
# 294
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 295
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 296
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 297
__f> constexpr size_t 
# 300
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::tempering_l; 
# 302
template< class _UIntType, size_t 
# 303
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 304
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 305
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 306
__f> constexpr _UIntType 
# 310
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::initialization_multiplier; 
# 312
template< class _UIntType, size_t 
# 313
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 314
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 315
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 316
__f> constexpr _UIntType 
# 319
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::default_seed; 
# 321
template< class _UIntType, size_t 
# 322
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 323
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 324
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 325
__f> void 
# 329
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::seed(result_type __sd) 
# 330
{ 
# 331
((_M_x)[0]) = __detail::__mod< _UIntType, __detail::_Shift< _UIntType, __w> ::__value> (__sd); 
# 334
for (size_t __i = (1); __i < state_size; ++__i) 
# 335
{ 
# 336
_UIntType __x = (_M_x)[__i - (1)]; 
# 337
__x ^= (__x >> (__w - (2))); 
# 338
__x *= __f; 
# 339
__x += __detail::__mod< _UIntType, __n> (__i); 
# 340
((_M_x)[__i]) = __detail::__mod< _UIntType, __detail::_Shift< _UIntType, __w> ::__value> (__x); 
# 342
}  
# 343
(_M_p) = state_size; 
# 344
} 
# 346
template< class _UIntType, size_t 
# 347
__w, size_t __n, size_t __m, size_t __r, _UIntType 
# 348
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 349
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 350
__f> 
# 351
template< class _Sseq> typename enable_if< is_class< _Sseq> ::value> ::type 
# 355
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::seed(_Sseq &__q) 
# 356
{ 
# 357
const _UIntType __upper_mask = ((~_UIntType()) << __r); 
# 358
const size_t __k = ((__w + (31)) / (32)); 
# 359
uint_least32_t __arr[__n * __k]; 
# 360
(__q.generate((__arr) + 0, (__arr) + (__n * __k))); 
# 362
bool __zero = true; 
# 363
for (size_t __i = (0); __i < state_size; ++__i) 
# 364
{ 
# 365
_UIntType __factor = (1U); 
# 366
_UIntType __sum = (0U); 
# 367
for (size_t __j = (0); __j < __k; ++__j) 
# 368
{ 
# 369
__sum += (((__arr)[(__k * __i) + __j]) * __factor); 
# 370
__factor *= __detail::_Shift< _UIntType, 32UL> ::__value; 
# 371
}  
# 372
((_M_x)[__i]) = __detail::__mod< _UIntType, __detail::_Shift< _UIntType, __w> ::__value> (__sum); 
# 375
if (__zero) 
# 376
{ 
# 377
if (__i == (0)) 
# 378
{ 
# 379
if ((((_M_x)[0]) & __upper_mask) != 0U) { 
# 380
__zero = false; }  
# 381
} else { 
# 382
if (((_M_x)[__i]) != 0U) { 
# 383
__zero = false; }  }  
# 384
}  
# 385
}  
# 386
if (__zero) { 
# 387
((_M_x)[0]) = __detail::_Shift< _UIntType, __w - (1)> ::__value; }  
# 388
(_M_p) = state_size; 
# 389
} 
# 391
template< class _UIntType, size_t __w, size_t 
# 392
__n, size_t __m, size_t __r, _UIntType 
# 393
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 394
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 395
__f> void 
# 399
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::_M_gen_rand() 
# 400
{ 
# 401
const _UIntType __upper_mask = ((~_UIntType()) << __r); 
# 402
const _UIntType __lower_mask = ~__upper_mask; 
# 404
for (size_t __k = (0); __k < (__n - __m); ++__k) 
# 405
{ 
# 406
_UIntType __y = (((_M_x)[__k]) & __upper_mask) | (((_M_x)[__k + (1)]) & __lower_mask); 
# 408
((_M_x)[__k]) = ((((_M_x)[__k + __m]) ^ (__y >> 1)) ^ ((__y & 1) ? __a : 0)); 
# 410
}  
# 412
for (size_t __k = (__n - __m); __k < (__n - (1)); ++__k) 
# 413
{ 
# 414
_UIntType __y = (((_M_x)[__k]) & __upper_mask) | (((_M_x)[__k + (1)]) & __lower_mask); 
# 416
((_M_x)[__k]) = ((((_M_x)[__k + (__m - __n)]) ^ (__y >> 1)) ^ ((__y & 1) ? __a : 0)); 
# 418
}  
# 420
_UIntType __y = (((_M_x)[__n - (1)]) & __upper_mask) | (((_M_x)[0]) & __lower_mask); 
# 422
((_M_x)[__n - (1)]) = ((((_M_x)[__m - (1)]) ^ (__y >> 1)) ^ ((__y & 1) ? __a : 0)); 
# 424
(_M_p) = (0); 
# 425
} 
# 427
template< class _UIntType, size_t __w, size_t 
# 428
__n, size_t __m, size_t __r, _UIntType 
# 429
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 430
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 431
__f> void 
# 435
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::discard(unsigned long long __z) 
# 436
{ 
# 437
while (__z > (state_size - (_M_p))) 
# 438
{ 
# 439
__z -= (state_size - (_M_p)); 
# 440
_M_gen_rand(); 
# 441
}  
# 442
(_M_p) += __z; 
# 443
} 
# 445
template< class _UIntType, size_t __w, size_t 
# 446
__n, size_t __m, size_t __r, _UIntType 
# 447
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 448
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 449
__f> typename mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::result_type 
# 455
mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f> ::operator()() 
# 456
{ 
# 458
if ((_M_p) >= state_size) { 
# 459
_M_gen_rand(); }  
# 462
result_type __z = (_M_x)[(_M_p)++]; 
# 463
__z ^= ((__z >> __u) & __d); 
# 464
__z ^= ((__z << __s) & __b); 
# 465
__z ^= ((__z << __t) & __c); 
# 466
__z ^= (__z >> __l); 
# 468
return __z; 
# 469
} 
# 471
template< class _UIntType, size_t __w, size_t 
# 472
__n, size_t __m, size_t __r, _UIntType 
# 473
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 474
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 475
__f, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 477
operator<<(basic_ostream< _CharT, _Traits>  &__os, const mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>  &
# 479
__x) 
# 480
{ 
# 481
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 482
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 484
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 485
const _CharT __fill = (__os.fill()); 
# 486
const _CharT __space = (__os.widen(' ')); 
# 487
(__os.flags((__ios_base::dec | __ios_base::fixed) | __ios_base::left)); 
# 488
(__os.fill(__space)); 
# 490
for (size_t __i = (0); __i < __n; ++__i) { 
# 491
(__os << ((__x._M_x)[__i])) << __space; }  
# 492
__os << (__x._M_p); 
# 494
(__os.flags(__flags)); 
# 495
(__os.fill(__fill)); 
# 496
return __os; 
# 497
} 
# 499
template< class _UIntType, size_t __w, size_t 
# 500
__n, size_t __m, size_t __r, _UIntType 
# 501
__a, size_t __u, _UIntType __d, size_t __s, _UIntType 
# 502
__b, size_t __t, _UIntType __c, size_t __l, _UIntType 
# 503
__f, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 505
operator>>(basic_istream< _CharT, _Traits>  &__is, mersenne_twister_engine< _UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>  &
# 507
__x) 
# 508
{ 
# 509
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 510
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 512
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 513
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 515
for (size_t __i = (0); __i < __n; ++__i) { 
# 516
__is >> ((__x._M_x)[__i]); }  
# 517
__is >> (__x._M_p); 
# 519
(__is.flags(__flags)); 
# 520
return __is; 
# 521
} 
# 524
template< class _UIntType, size_t __w, size_t __s, size_t __r> constexpr size_t 
# 526
subtract_with_carry_engine< _UIntType, __w, __s, __r> ::word_size; 
# 528
template< class _UIntType, size_t __w, size_t __s, size_t __r> constexpr size_t 
# 530
subtract_with_carry_engine< _UIntType, __w, __s, __r> ::short_lag; 
# 532
template< class _UIntType, size_t __w, size_t __s, size_t __r> constexpr size_t 
# 534
subtract_with_carry_engine< _UIntType, __w, __s, __r> ::long_lag; 
# 536
template< class _UIntType, size_t __w, size_t __s, size_t __r> constexpr _UIntType 
# 538
subtract_with_carry_engine< _UIntType, __w, __s, __r> ::default_seed; 
# 540
template< class _UIntType, size_t __w, size_t __s, size_t __r> void 
# 543
subtract_with_carry_engine< _UIntType, __w, __s, __r> ::seed(result_type __value) 
# 544
{ 
# 546
linear_congruential_engine< _UIntType, 40014U, 0U, 2147483563U>  __lcg((__value == 0U) ? default_seed : __value); 
# 548
const size_t __n = ((__w + (31)) / (32)); 
# 550
for (size_t __i = (0); __i < long_lag; ++__i) 
# 551
{ 
# 552
_UIntType __sum = (0U); 
# 553
_UIntType __factor = (1U); 
# 554
for (size_t __j = (0); __j < __n; ++__j) 
# 555
{ 
# 556
__sum += (__detail::__mod< uint_least32_t, __detail::_Shift< unsigned, 32UL> ::__value> (__lcg()) * __factor); 
# 559
__factor *= __detail::_Shift< _UIntType, 32UL> ::__value; 
# 560
}  
# 561
((_M_x)[__i]) = __detail::__mod< _UIntType, __detail::_Shift< _UIntType, __w> ::__value> (__sum); 
# 563
}  
# 564
(_M_carry) = ((((_M_x)[long_lag - (1)]) == 0) ? 1 : 0); 
# 565
(_M_p) = (0); 
# 566
} 
# 568
template< class _UIntType, size_t __w, size_t __s, size_t __r> 
# 569
template< class _Sseq> typename enable_if< is_class< _Sseq> ::value> ::type 
# 572
subtract_with_carry_engine< _UIntType, __w, __s, __r> ::seed(_Sseq &__q) 
# 573
{ 
# 574
const size_t __k = ((__w + (31)) / (32)); 
# 575
uint_least32_t __arr[__r * __k]; 
# 576
(__q.generate((__arr) + 0, (__arr) + (__r * __k))); 
# 578
for (size_t __i = (0); __i < long_lag; ++__i) 
# 579
{ 
# 580
_UIntType __sum = (0U); 
# 581
_UIntType __factor = (1U); 
# 582
for (size_t __j = (0); __j < __k; ++__j) 
# 583
{ 
# 584
__sum += (((__arr)[(__k * __i) + __j]) * __factor); 
# 585
__factor *= __detail::_Shift< _UIntType, 32UL> ::__value; 
# 586
}  
# 587
((_M_x)[__i]) = __detail::__mod< _UIntType, __detail::_Shift< _UIntType, __w> ::__value> (__sum); 
# 589
}  
# 590
(_M_carry) = ((((_M_x)[long_lag - (1)]) == 0) ? 1 : 0); 
# 591
(_M_p) = (0); 
# 592
} 
# 594
template< class _UIntType, size_t __w, size_t __s, size_t __r> typename subtract_with_carry_engine< _UIntType, __w, __s, __r> ::result_type 
# 598
subtract_with_carry_engine< _UIntType, __w, __s, __r> ::operator()() 
# 599
{ 
# 601
long __ps = (_M_p) - short_lag; 
# 602
if (__ps < (0)) { 
# 603
__ps += long_lag; }  
# 608
_UIntType __xi; 
# 609
if (((_M_x)[__ps]) >= (((_M_x)[_M_p]) + (_M_carry))) 
# 610
{ 
# 611
__xi = ((((_M_x)[__ps]) - ((_M_x)[_M_p])) - (_M_carry)); 
# 612
(_M_carry) = 0; 
# 613
} else 
# 615
{ 
# 616
__xi = (((__detail::_Shift< _UIntType, __w> ::__value - ((_M_x)[_M_p])) - (_M_carry)) + ((_M_x)[__ps])); 
# 618
(_M_carry) = 1; 
# 619
}  
# 620
((_M_x)[_M_p]) = __xi; 
# 623
if ((++(_M_p)) >= long_lag) { 
# 624
(_M_p) = (0); }  
# 626
return __xi; 
# 627
} 
# 629
template< class _UIntType, size_t __w, size_t __s, size_t __r, class 
# 630
_CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 632
operator<<(basic_ostream< _CharT, _Traits>  &__os, const subtract_with_carry_engine< _UIntType, __w, __s, __r>  &
# 634
__x) 
# 635
{ 
# 636
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 637
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 639
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 640
const _CharT __fill = (__os.fill()); 
# 641
const _CharT __space = (__os.widen(' ')); 
# 642
(__os.flags((__ios_base::dec | __ios_base::fixed) | __ios_base::left)); 
# 643
(__os.fill(__space)); 
# 645
for (size_t __i = (0); __i < __r; ++__i) { 
# 646
(__os << ((__x._M_x)[__i])) << __space; }  
# 647
((__os << (__x._M_carry)) << __space) << (__x._M_p); 
# 649
(__os.flags(__flags)); 
# 650
(__os.fill(__fill)); 
# 651
return __os; 
# 652
} 
# 654
template< class _UIntType, size_t __w, size_t __s, size_t __r, class 
# 655
_CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 657
operator>>(basic_istream< _CharT, _Traits>  &__is, subtract_with_carry_engine< _UIntType, __w, __s, __r>  &
# 658
__x) 
# 659
{ 
# 660
typedef basic_ostream< _CharT, _Traits>  __istream_type; 
# 661
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 663
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 664
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 666
for (size_t __i = (0); __i < __r; ++__i) { 
# 667
__is >> ((__x._M_x)[__i]); }  
# 668
__is >> (__x._M_carry); 
# 669
__is >> (__x._M_p); 
# 671
(__is.flags(__flags)); 
# 672
return __is; 
# 673
} 
# 676
template< class _RandomNumberEngine, size_t __p, size_t __r> constexpr size_t 
# 678
discard_block_engine< _RandomNumberEngine, __p, __r> ::block_size; 
# 680
template< class _RandomNumberEngine, size_t __p, size_t __r> constexpr size_t 
# 682
discard_block_engine< _RandomNumberEngine, __p, __r> ::used_block; 
# 684
template< class _RandomNumberEngine, size_t __p, size_t __r> typename discard_block_engine< _RandomNumberEngine, __p, __r> ::result_type 
# 688
discard_block_engine< _RandomNumberEngine, __p, __r> ::operator()() 
# 689
{ 
# 690
if ((_M_n) >= used_block) 
# 691
{ 
# 692
((_M_b).discard(block_size - (_M_n))); 
# 693
(_M_n) = (0); 
# 694
}  
# 695
++(_M_n); 
# 696
return (_M_b)(); 
# 697
} 
# 699
template< class _RandomNumberEngine, size_t __p, size_t __r, class 
# 700
_CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 702
operator<<(basic_ostream< _CharT, _Traits>  &__os, const discard_block_engine< _RandomNumberEngine, __p, __r>  &
# 704
__x) 
# 705
{ 
# 706
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 707
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 709
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 710
const _CharT __fill = (__os.fill()); 
# 711
const _CharT __space = (__os.widen(' ')); 
# 712
(__os.flags((__ios_base::dec | __ios_base::fixed) | __ios_base::left)); 
# 713
(__os.fill(__space)); 
# 715
((__os << (__x.base())) << __space) << (__x._M_n); 
# 717
(__os.flags(__flags)); 
# 718
(__os.fill(__fill)); 
# 719
return __os; 
# 720
} 
# 722
template< class _RandomNumberEngine, size_t __p, size_t __r, class 
# 723
_CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 725
operator>>(basic_istream< _CharT, _Traits>  &__is, discard_block_engine< _RandomNumberEngine, __p, __r>  &
# 726
__x) 
# 727
{ 
# 728
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 729
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 731
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 732
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 734
(__is >> (__x._M_b)) >> (__x._M_n); 
# 736
(__is.flags(__flags)); 
# 737
return __is; 
# 738
} 
# 741
template< class _RandomNumberEngine, size_t __w, class _UIntType> typename independent_bits_engine< _RandomNumberEngine, __w, _UIntType> ::result_type 
# 745
independent_bits_engine< _RandomNumberEngine, __w, _UIntType> ::operator()() 
# 746
{ 
# 747
typedef typename _RandomNumberEngine::result_type _Eresult_type; 
# 748
const _Eresult_type __r = ((((_M_b).max()) - ((_M_b).min())) < std::numeric_limits< typename _RandomNumberEngine::result_type> ::max()) ? (((_M_b).max()) - ((_M_b).min())) + 1 : 0; 
# 751
const unsigned __edig = (std::numeric_limits< typename _RandomNumberEngine::result_type> ::digits); 
# 752
const unsigned __m = (__r) ? std::__lg(__r) : __edig; 
# 755
typedef typename common_type< typename _RandomNumberEngine::result_type, _UIntType> ::type __ctype; 
# 756
const unsigned __cdig = (std::numeric_limits< typename common_type< typename _RandomNumberEngine::result_type, _UIntType> ::type> ::digits); 
# 758
unsigned __n, __n0; 
# 759
__ctype __s0, __s1, __y0, __y1; 
# 761
for (size_t __i = (0); __i < (2); ++__i) 
# 762
{ 
# 763
__n = ((((__w + __m) - (1)) / __m) + __i); 
# 764
__n0 = (__n - (__w % __n)); 
# 765
const unsigned __w0 = __w / __n; 
# 767
__s0 = 0; 
# 768
__s1 = 0; 
# 769
if (__w0 < __cdig) 
# 770
{ 
# 771
__s0 = (((__ctype)1) << __w0); 
# 772
__s1 = (__s0 << 1); 
# 773
}  
# 775
__y0 = 0; 
# 776
__y1 = 0; 
# 777
if (__r) 
# 778
{ 
# 779
__y0 = (__s0 * (__r / __s0)); 
# 780
if (__s1) { 
# 781
__y1 = (__s1 * (__r / __s1)); }  
# 783
if ((__r - __y0) <= (__y0 / __n)) { 
# 784
break; }  
# 785
} else { 
# 787
break; }  
# 788
}  
# 790
result_type __sum = (0); 
# 791
for (size_t __k = (0); __k < __n0; ++__k) 
# 792
{ 
# 793
__ctype __u; 
# 794
do { 
# 795
__u = ((_M_b)() - ((_M_b).min())); } 
# 796
while (__y0 && (__u >= __y0)); 
# 797
__sum = ((__s0 * __sum) + ((__s0) ? __u % __s0 : __u)); 
# 798
}  
# 799
for (size_t __k = __n0; __k < __n; ++__k) 
# 800
{ 
# 801
__ctype __u; 
# 802
do { 
# 803
__u = ((_M_b)() - ((_M_b).min())); } 
# 804
while (__y1 && (__u >= __y1)); 
# 805
__sum = ((__s1 * __sum) + ((__s1) ? __u % __s1 : __u)); 
# 806
}  
# 807
return __sum; 
# 808
} 
# 811
template< class _RandomNumberEngine, size_t __k> constexpr size_t 
# 813
shuffle_order_engine< _RandomNumberEngine, __k> ::table_size; 
# 815
template< class _RandomNumberEngine, size_t __k> typename shuffle_order_engine< _RandomNumberEngine, __k> ::result_type 
# 818
shuffle_order_engine< _RandomNumberEngine, __k> ::operator()() 
# 819
{ 
# 820
size_t __j = __k * (((_M_y) - ((_M_b).min())) / ((((_M_b).max()) - ((_M_b).min())) + (1.0L))); 
# 822
(_M_y) = ((_M_v)[__j]); 
# 823
((_M_v)[__j]) = (_M_b)(); 
# 825
return _M_y; 
# 826
} 
# 828
template< class _RandomNumberEngine, size_t __k, class 
# 829
_CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 831
operator<<(basic_ostream< _CharT, _Traits>  &__os, const shuffle_order_engine< _RandomNumberEngine, __k>  &
# 832
__x) 
# 833
{ 
# 834
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 835
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 837
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 838
const _CharT __fill = (__os.fill()); 
# 839
const _CharT __space = (__os.widen(' ')); 
# 840
(__os.flags((__ios_base::dec | __ios_base::fixed) | __ios_base::left)); 
# 841
(__os.fill(__space)); 
# 843
__os << (__x.base()); 
# 844
for (size_t __i = (0); __i < __k; ++__i) { 
# 845
(__os << __space) << ((__x._M_v)[__i]); }  
# 846
(__os << __space) << (__x._M_y); 
# 848
(__os.flags(__flags)); 
# 849
(__os.fill(__fill)); 
# 850
return __os; 
# 851
} 
# 853
template< class _RandomNumberEngine, size_t __k, class 
# 854
_CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 856
operator>>(basic_istream< _CharT, _Traits>  &__is, shuffle_order_engine< _RandomNumberEngine, __k>  &
# 857
__x) 
# 858
{ 
# 859
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 860
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 862
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 863
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 865
__is >> (__x._M_b); 
# 866
for (size_t __i = (0); __i < __k; ++__i) { 
# 867
__is >> ((__x._M_v)[__i]); }  
# 868
__is >> (__x._M_y); 
# 870
(__is.flags(__flags)); 
# 871
return __is; 
# 872
} 
# 875
template< class _IntType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 877
operator<<(basic_ostream< _CharT, _Traits>  &__os, const uniform_int_distribution< _IntType>  &
# 878
__x) 
# 879
{ 
# 880
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 881
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 883
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 884
const _CharT __fill = (__os.fill()); 
# 885
const _CharT __space = (__os.widen(' ')); 
# 886
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 887
(__os.fill(__space)); 
# 889
((__os << (__x.a())) << __space) << (__x.b()); 
# 891
(__os.flags(__flags)); 
# 892
(__os.fill(__fill)); 
# 893
return __os; 
# 894
} 
# 896
template< class _IntType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 898
operator>>(basic_istream< _CharT, _Traits>  &__is, uniform_int_distribution< _IntType>  &
# 899
__x) 
# 900
{ 
# 901
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 902
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 904
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 905
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 907
_IntType __a, __b; 
# 908
(__is >> __a) >> __b; 
# 909
(__x.param(typename uniform_int_distribution< _IntType> ::param_type(__a, __b))); 
# 912
(__is.flags(__flags)); 
# 913
return __is; 
# 914
} 
# 917
template< class _RealType> 
# 918
template< class _ForwardIterator, class 
# 919
_UniformRandomNumberGenerator> void 
# 922
uniform_real_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 923
__urng, const param_type &
# 924
__p) 
# 925
{ 
# 928
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 929
auto __range = (__p.b()) - (__p.a()); 
# 930
while (__f != __t) { 
# 931
(*(__f++)) = ((__aurng() * __range) + (__p.a())); }  
# 932
} 
# 934
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 936
operator<<(basic_ostream< _CharT, _Traits>  &__os, const uniform_real_distribution< _RealType>  &
# 937
__x) 
# 938
{ 
# 939
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 940
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 942
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 943
const _CharT __fill = (__os.fill()); 
# 944
const streamsize __precision = (__os.precision()); 
# 945
const _CharT __space = (__os.widen(' ')); 
# 946
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 947
(__os.fill(__space)); 
# 948
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 950
((__os << (__x.a())) << __space) << (__x.b()); 
# 952
(__os.flags(__flags)); 
# 953
(__os.fill(__fill)); 
# 954
(__os.precision(__precision)); 
# 955
return __os; 
# 956
} 
# 958
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 960
operator>>(basic_istream< _CharT, _Traits>  &__is, uniform_real_distribution< _RealType>  &
# 961
__x) 
# 962
{ 
# 963
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 964
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 966
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 967
(__is.flags(__ios_base::skipws)); 
# 969
_RealType __a, __b; 
# 970
(__is >> __a) >> __b; 
# 971
(__x.param(typename uniform_real_distribution< _RealType> ::param_type(__a, __b))); 
# 974
(__is.flags(__flags)); 
# 975
return __is; 
# 976
} 
# 979
template< class _ForwardIterator, class 
# 980
_UniformRandomNumberGenerator> void 
# 983
bernoulli_distribution::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 984
__urng, const param_type &
# 985
__p) 
# 986
{ 
# 989
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 990
auto __limit = __p.p() * ((__aurng.max()) - (__aurng.min())); 
# 992
while (__f != __t) { 
# 993
(*(__f++)) = ((__aurng() - (__aurng.min())) < __limit); }  
# 994
} 
# 996
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 998
operator<<(basic_ostream< _CharT, _Traits>  &__os, const bernoulli_distribution &
# 999
__x) 
# 1000
{ 
# 1001
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 1002
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 1004
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 1005
const _CharT __fill = (__os.fill()); 
# 1006
const streamsize __precision = (__os.precision()); 
# 1007
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 1008
(__os.fill((__os.widen(' ')))); 
# 1009
(__os.precision(std::numeric_limits< double> ::max_digits10)); 
# 1011
__os << __x.p(); 
# 1013
(__os.flags(__flags)); 
# 1014
(__os.fill(__fill)); 
# 1015
(__os.precision(__precision)); 
# 1016
return __os; 
# 1017
} 
# 1020
template< class _IntType> 
# 1021
template< class _UniformRandomNumberGenerator> typename geometric_distribution< _IntType> ::result_type 
# 1024
geometric_distribution< _IntType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 1025
__param) 
# 1026
{ 
# 1029
const double __naf = ((1) - std::numeric_limits< double> ::epsilon()) / (2); 
# 1032
const double __thr = std::numeric_limits< _IntType> ::max() + __naf; 
# 1035
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 1037
double __cand; 
# 1038
do { 
# 1039
__cand = std::floor(std::log((1.0) - __aurng()) / (__param._M_log_1_p)); } 
# 1040
while (__cand >= __thr); 
# 1042
return (result_type)(__cand + __naf); 
# 1043
} 
# 1045
template< class _IntType> 
# 1046
template< class _ForwardIterator, class 
# 1047
_UniformRandomNumberGenerator> void 
# 1050
geometric_distribution< _IntType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 1051
__urng, const param_type &
# 1052
__param) 
# 1053
{ 
# 1057
const double __naf = ((1) - std::numeric_limits< double> ::epsilon()) / (2); 
# 1060
const double __thr = std::numeric_limits< _IntType> ::max() + __naf; 
# 1063
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 1065
while (__f != __t) 
# 1066
{ 
# 1067
double __cand; 
# 1068
do { 
# 1069
__cand = std::floor(std::log((1.0) - __aurng()) / (__param._M_log_1_p)); } 
# 1071
while (__cand >= __thr); 
# 1073
(*(__f++)) = (__cand + __naf); 
# 1074
}  
# 1075
} 
# 1077
template< class _IntType, class 
# 1078
_CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 1080
operator<<(basic_ostream< _CharT, _Traits>  &__os, const geometric_distribution< _IntType>  &
# 1081
__x) 
# 1082
{ 
# 1083
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 1084
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 1086
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 1087
const _CharT __fill = (__os.fill()); 
# 1088
const streamsize __precision = (__os.precision()); 
# 1089
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 1090
(__os.fill((__os.widen(' ')))); 
# 1091
(__os.precision(std::numeric_limits< double> ::max_digits10)); 
# 1093
__os << (__x.p()); 
# 1095
(__os.flags(__flags)); 
# 1096
(__os.fill(__fill)); 
# 1097
(__os.precision(__precision)); 
# 1098
return __os; 
# 1099
} 
# 1101
template< class _IntType, class 
# 1102
_CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 1104
operator>>(basic_istream< _CharT, _Traits>  &__is, geometric_distribution< _IntType>  &
# 1105
__x) 
# 1106
{ 
# 1107
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1108
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1110
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 1111
(__is.flags(__ios_base::skipws)); 
# 1113
double __p; 
# 1114
__is >> __p; 
# 1115
(__x.param((typename geometric_distribution< _IntType> ::param_type)__p)); 
# 1117
(__is.flags(__flags)); 
# 1118
return __is; 
# 1119
} 
# 1122
template< class _IntType> 
# 1123
template< class _UniformRandomNumberGenerator> typename negative_binomial_distribution< _IntType> ::result_type 
# 1126
negative_binomial_distribution< _IntType> ::operator()(_UniformRandomNumberGenerator &__urng) 
# 1127
{ 
# 1128
const double __y = (_M_gd)(__urng); 
# 1131
poisson_distribution< _IntType>  __poisson(__y); 
# 1132
return __poisson(__urng); 
# 1133
} 
# 1135
template< class _IntType> 
# 1136
template< class _UniformRandomNumberGenerator> typename negative_binomial_distribution< _IntType> ::result_type 
# 1139
negative_binomial_distribution< _IntType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 1140
__p) 
# 1141
{ 
# 1143
typedef gamma_distribution< double> ::param_type param_type; 
# 1145
const double __y = (_M_gd)(__urng, param_type((__p.k()), ((1.0) - (__p.p())) / (__p.p()))); 
# 1148
poisson_distribution< _IntType>  __poisson(__y); 
# 1149
return __poisson(__urng); 
# 1150
} 
# 1152
template< class _IntType> 
# 1153
template< class _ForwardIterator, class 
# 1154
_UniformRandomNumberGenerator> void 
# 1157
negative_binomial_distribution< _IntType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 1158
__urng) 
# 1159
{ 
# 1161
while (__f != __t) 
# 1162
{ 
# 1163
const double __y = (_M_gd)(__urng); 
# 1166
poisson_distribution< _IntType>  __poisson(__y); 
# 1167
(*(__f++)) = __poisson(__urng); 
# 1168
}  
# 1169
} 
# 1171
template< class _IntType> 
# 1172
template< class _ForwardIterator, class 
# 1173
_UniformRandomNumberGenerator> void 
# 1176
negative_binomial_distribution< _IntType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 1177
__urng, const param_type &
# 1178
__p) 
# 1179
{ 
# 1182
typename gamma_distribution< _IntType> ::param_type __p2((__p.k()), ((1.0) - (__p.p())) / (__p.p())); 
# 1184
while (__f != __t) 
# 1185
{ 
# 1186
const double __y = (_M_gd)(__urng, __p2); 
# 1188
poisson_distribution< _IntType>  __poisson(__y); 
# 1189
(*(__f++)) = __poisson(__urng); 
# 1190
}  
# 1191
} 
# 1193
template< class _IntType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 1195
operator<<(basic_ostream< _CharT, _Traits>  &__os, const negative_binomial_distribution< _IntType>  &
# 1196
__x) 
# 1197
{ 
# 1198
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 1199
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 1201
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 1202
const _CharT __fill = (__os.fill()); 
# 1203
const streamsize __precision = (__os.precision()); 
# 1204
const _CharT __space = (__os.widen(' ')); 
# 1205
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 1206
(__os.fill((__os.widen(' ')))); 
# 1207
(__os.precision(std::numeric_limits< double> ::max_digits10)); 
# 1209
((((__os << (__x.k())) << __space) << (__x.p())) << __space) << (__x._M_gd); 
# 1212
(__os.flags(__flags)); 
# 1213
(__os.fill(__fill)); 
# 1214
(__os.precision(__precision)); 
# 1215
return __os; 
# 1216
} 
# 1218
template< class _IntType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 1220
operator>>(basic_istream< _CharT, _Traits>  &__is, negative_binomial_distribution< _IntType>  &
# 1221
__x) 
# 1222
{ 
# 1223
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1224
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1226
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 1227
(__is.flags(__ios_base::skipws)); 
# 1229
_IntType __k; 
# 1230
double __p; 
# 1231
((__is >> __k) >> __p) >> (__x._M_gd); 
# 1232
(__x.param(typename negative_binomial_distribution< _IntType> ::param_type(__k, __p))); 
# 1235
(__is.flags(__flags)); 
# 1236
return __is; 
# 1237
} 
# 1240
template< class _IntType> void 
# 1243
poisson_distribution< _IntType> ::param_type::_M_initialize() 
# 1244
{ 
# 1246
if ((_M_mean) >= (12)) 
# 1247
{ 
# 1248
const double __m = std::floor(_M_mean); 
# 1249
(_M_lm_thr) = std::log(_M_mean); 
# 1250
(_M_lfm) = std::lgamma(__m + (1)); 
# 1251
(_M_sm) = std::sqrt(__m); 
# 1253
const double __pi_4 = ((0.785398163397448279L)); 
# 1254
const double __dx = std::sqrt(((2) * __m) * std::log(((32) * __m) / __pi_4)); 
# 1256
(_M_d) = std::round(std::max((6.0), std::min(__m, __dx))); 
# 1257
const double __cx = ((2) * __m) + (_M_d); 
# 1258
(_M_scx) = std::sqrt(__cx / (2)); 
# 1259
(_M_1cx) = ((1) / __cx); 
# 1261
(_M_c2b) = (std::sqrt(__pi_4 * __cx) * std::exp(_M_1cx)); 
# 1262
(_M_cb) = ((((2) * __cx) * std::exp(((-(_M_d)) * (_M_1cx)) * ((1) + ((_M_d) / (2))))) / (_M_d)); 
# 1264
} else { 
# 1267
(_M_lm_thr) = std::exp(-(_M_mean)); }  
# 1268
} 
# 1280 "/usr/include/c++/5/bits/random.tcc" 3
template< class _IntType> 
# 1281
template< class _UniformRandomNumberGenerator> typename poisson_distribution< _IntType> ::result_type 
# 1284
poisson_distribution< _IntType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 1285
__param) 
# 1286
{ 
# 1288
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 1290
if ((__param.mean()) >= 12) 
# 1291
{ 
# 1292
double __x; 
# 1295
const double __naf = ((1) - std::numeric_limits< double> ::epsilon()) / (2); 
# 1297
const double __thr = std::numeric_limits< _IntType> ::max() + __naf; 
# 1300
const double __m = std::floor((__param.mean())); 
# 1302
const double __spi_2 = ((1.253314137315500343L)); 
# 1303
const double __c1 = (__param._M_sm) * __spi_2; 
# 1304
const double __c2 = (__param._M_c2b) + __c1; 
# 1305
const double __c3 = (__c2 + (1)); 
# 1306
const double __c4 = (__c3 + (1)); 
# 1308
const double __e178 = ((1.01290304793200181L)); 
# 1309
const double __c5 = (__c4 + __e178); 
# 1310
const double __c = (__param._M_cb) + __c5; 
# 1311
const double __2cx = 2 * (((2) * __m) + (__param._M_d)); 
# 1313
bool __reject = true; 
# 1314
do { 
# 1315
{ 
# 1316
const double __u = __c * __aurng(); 
# 1317
const double __e = -std::log((1.0) - __aurng()); 
# 1319
double __w = (0.0); 
# 1321
if (__u <= __c1) 
# 1322
{ 
# 1323
const double __n = (_M_nd)(__urng); 
# 1324
const double __y = ((-std::abs(__n)) * (__param._M_sm)) - 1; 
# 1325
__x = std::floor(__y); 
# 1326
__w = (((-__n) * __n) / (2)); 
# 1327
if (__x < (-__m)) { 
# 1328
continue; }  
# 1329
} else { 
# 1330
if (__u <= __c2) 
# 1331
{ 
# 1332
const double __n = (_M_nd)(__urng); 
# 1333
const double __y = 1 + (std::abs(__n) * (__param._M_scx)); 
# 1334
__x = std::ceil(__y); 
# 1335
__w = ((__y * ((2) - __y)) * (__param._M_1cx)); 
# 1336
if (__x > (__param._M_d)) { 
# 1337
continue; }  
# 1338
} else { 
# 1339
if (__u <= __c3) { 
# 1342
__x = (-1); } else { 
# 1343
if (__u <= __c4) { 
# 1344
__x = (0); } else { 
# 1345
if (__u <= __c5) { 
# 1346
__x = (1); } else 
# 1348
{ 
# 1349
const double __v = -std::log((1.0) - __aurng()); 
# 1350
const double __y = (__param._M_d) + ((__v * __2cx) / (__param._M_d)); 
# 1352
__x = std::ceil(__y); 
# 1353
__w = (((-(__param._M_d)) * (__param._M_1cx)) * ((1) + (__y / (2)))); 
# 1354
}  }  }  }  }  
# 1356
__reject = (((__w - __e) - (__x * (__param._M_lm_thr))) > ((__param._M_lfm) - std::lgamma((__x + __m) + (1)))); 
# 1359
__reject |= ((__x + __m) >= __thr); 
# 1361
} } while (__reject); 
# 1363
return (result_type)((__x + __m) + __naf); 
# 1364
} else 
# 1367
{ 
# 1368
_IntType __x = (0); 
# 1369
double __prod = (1.0); 
# 1371
do 
# 1372
{ 
# 1373
__prod *= __aurng(); 
# 1374
__x += 1; 
# 1375
} 
# 1376
while (__prod > (__param._M_lm_thr)); 
# 1378
return __x - 1; 
# 1379
}  
# 1380
} 
# 1382
template< class _IntType> 
# 1383
template< class _ForwardIterator, class 
# 1384
_UniformRandomNumberGenerator> void 
# 1387
poisson_distribution< _IntType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 1388
__urng, const param_type &
# 1389
__param) 
# 1390
{ 
# 1393
while (__f != __t) { 
# 1394
(*(__f++)) = (this->operator()(__urng, __param)); }  
# 1395
} 
# 1397
template< class _IntType, class 
# 1398
_CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 1400
operator<<(basic_ostream< _CharT, _Traits>  &__os, const poisson_distribution< _IntType>  &
# 1401
__x) 
# 1402
{ 
# 1403
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 1404
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 1406
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 1407
const _CharT __fill = (__os.fill()); 
# 1408
const streamsize __precision = (__os.precision()); 
# 1409
const _CharT __space = (__os.widen(' ')); 
# 1410
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 1411
(__os.fill(__space)); 
# 1412
(__os.precision(std::numeric_limits< double> ::max_digits10)); 
# 1414
((__os << (__x.mean())) << __space) << (__x._M_nd); 
# 1416
(__os.flags(__flags)); 
# 1417
(__os.fill(__fill)); 
# 1418
(__os.precision(__precision)); 
# 1419
return __os; 
# 1420
} 
# 1422
template< class _IntType, class 
# 1423
_CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 1425
operator>>(basic_istream< _CharT, _Traits>  &__is, poisson_distribution< _IntType>  &
# 1426
__x) 
# 1427
{ 
# 1428
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1429
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1431
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 1432
(__is.flags(__ios_base::skipws)); 
# 1434
double __mean; 
# 1435
(__is >> __mean) >> (__x._M_nd); 
# 1436
(__x.param((typename poisson_distribution< _IntType> ::param_type)__mean)); 
# 1438
(__is.flags(__flags)); 
# 1439
return __is; 
# 1440
} 
# 1443
template< class _IntType> void 
# 1446
binomial_distribution< _IntType> ::param_type::_M_initialize() 
# 1447
{ 
# 1448
const double __p12 = ((_M_p) <= (0.5)) ? _M_p : ((1.0) - (_M_p)); 
# 1450
(_M_easy) = true; 
# 1453
if (((_M_t) * __p12) >= 8) 
# 1454
{ 
# 1455
(_M_easy) = false; 
# 1456
const double __np = std::floor((_M_t) * __p12); 
# 1457
const double __pa = __np / (_M_t); 
# 1458
const double __1p = ((1) - __pa); 
# 1460
const double __pi_4 = ((0.785398163397448279L)); 
# 1461
const double __d1x = std::sqrt((__np * __1p) * std::log(((32) * __np) / (((81) * __pi_4) * __1p))); 
# 1464
(_M_d1) = std::round(std::max((1.0), __d1x)); 
# 1465
const double __d2x = std::sqrt((__np * __1p) * std::log(((32 * (_M_t)) * __1p) / (__pi_4 * __pa))); 
# 1468
(_M_d2) = std::round(std::max((1.0), __d2x)); 
# 1471
const double __spi_2 = ((1.253314137315500343L)); 
# 1472
(_M_s1) = (std::sqrt(__np * __1p) * ((1) + ((_M_d1) / ((4) * __np)))); 
# 1473
(_M_s2) = (std::sqrt(__np * __1p) * (1 + ((_M_d2) / ((4 * (_M_t)) * __1p)))); 
# 1474
(_M_c) = (((2) * (_M_d1)) / __np); 
# 1475
(_M_a1) = ((std::exp(_M_c) * (_M_s1)) * __spi_2); 
# 1476
const double __a12 = (_M_a1) + ((_M_s2) * __spi_2); 
# 1477
const double __s1s = (_M_s1) * (_M_s1); 
# 1478
(_M_a123) = (__a12 + ((((std::exp((_M_d1) / ((_M_t) * __1p)) * 2) * __s1s) / (_M_d1)) * std::exp(((-(_M_d1)) * (_M_d1)) / ((2) * __s1s)))); 
# 1481
const double __s2s = (_M_s2) * (_M_s2); 
# 1482
(_M_s) = ((_M_a123) + ((((2) * __s2s) / (_M_d2)) * std::exp(((-(_M_d2)) * (_M_d2)) / ((2) * __s2s)))); 
# 1484
(_M_lf) = (std::lgamma(__np + (1)) + std::lgamma(((_M_t) - __np) + 1)); 
# 1486
(_M_lp1p) = std::log(__pa / __1p); 
# 1488
(_M_q) = (-std::log((1) - ((__p12 - __pa) / __1p))); 
# 1489
} else { 
# 1492
(_M_q) = (-std::log((1) - __p12)); }  
# 1493
} 
# 1495
template< class _IntType> 
# 1496
template< class _UniformRandomNumberGenerator> typename binomial_distribution< _IntType> ::result_type 
# 1499
binomial_distribution< _IntType> ::_M_waiting(_UniformRandomNumberGenerator &__urng, _IntType 
# 1500
__t, double __q) 
# 1501
{ 
# 1502
_IntType __x = (0); 
# 1503
double __sum = (0.0); 
# 1505
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 1507
do 
# 1508
{ 
# 1509
if (__t == __x) { 
# 1510
return __x; }  
# 1511
const double __e = -std::log((1.0) - __aurng()); 
# 1512
__sum += (__e / (__t - __x)); 
# 1513
__x += 1; 
# 1514
} 
# 1515
while (__sum <= __q); 
# 1517
return __x - 1; 
# 1518
} 
# 1530 "/usr/include/c++/5/bits/random.tcc" 3
template< class _IntType> 
# 1531
template< class _UniformRandomNumberGenerator> typename binomial_distribution< _IntType> ::result_type 
# 1534
binomial_distribution< _IntType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 1535
__param) 
# 1536
{ 
# 1537
result_type __ret; 
# 1538
const _IntType __t = (__param.t()); 
# 1539
const double __p = (__param.p()); 
# 1540
const double __p12 = ((__p <= (0.5)) ? __p : ((1.0) - __p)); 
# 1542
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 1545
if (!(__param._M_easy)) 
# 1546
{ 
# 1547
double __x; 
# 1550
const double __naf = ((1) - std::numeric_limits< double> ::epsilon()) / (2); 
# 1552
const double __thr = std::numeric_limits< _IntType> ::max() + __naf; 
# 1555
const double __np = std::floor(__t * __p12); 
# 1558
const double __spi_2 = ((1.253314137315500343L)); 
# 1559
const double __a1 = ((__param._M_a1)); 
# 1560
const double __a12 = __a1 + ((__param._M_s2) * __spi_2); 
# 1561
const double __a123 = ((__param._M_a123)); 
# 1562
const double __s1s = (__param._M_s1) * (__param._M_s1); 
# 1563
const double __s2s = (__param._M_s2) * (__param._M_s2); 
# 1565
bool __reject; 
# 1566
do 
# 1567
{ 
# 1568
const double __u = (__param._M_s) * __aurng(); 
# 1570
double __v; 
# 1572
if (__u <= __a1) 
# 1573
{ 
# 1574
const double __n = (_M_nd)(__urng); 
# 1575
const double __y = (__param._M_s1) * std::abs(__n); 
# 1576
__reject = (__y >= (__param._M_d1)); 
# 1577
if (!__reject) 
# 1578
{ 
# 1579
const double __e = -std::log((1.0) - __aurng()); 
# 1580
__x = std::floor(__y); 
# 1581
__v = (((-__e) - ((__n * __n) / (2))) + (__param._M_c)); 
# 1582
}  
# 1583
} else { 
# 1584
if (__u <= __a12) 
# 1585
{ 
# 1586
const double __n = (_M_nd)(__urng); 
# 1587
const double __y = (__param._M_s2) * std::abs(__n); 
# 1588
__reject = (__y >= (__param._M_d2)); 
# 1589
if (!__reject) 
# 1590
{ 
# 1591
const double __e = -std::log((1.0) - __aurng()); 
# 1592
__x = std::floor(-__y); 
# 1593
__v = ((-__e) - ((__n * __n) / (2))); 
# 1594
}  
# 1595
} else { 
# 1596
if (__u <= __a123) 
# 1597
{ 
# 1598
const double __e1 = -std::log((1.0) - __aurng()); 
# 1599
const double __e2 = -std::log((1.0) - __aurng()); 
# 1601
const double __y = (__param._M_d1) + ((((2) * __s1s) * __e1) / (__param._M_d1)); 
# 1603
__x = std::floor(__y); 
# 1604
__v = ((-__e2) + ((__param._M_d1) * ((1 / (__t - __np)) - (__y / ((2) * __s1s))))); 
# 1606
__reject = false; 
# 1607
} else 
# 1609
{ 
# 1610
const double __e1 = -std::log((1.0) - __aurng()); 
# 1611
const double __e2 = -std::log((1.0) - __aurng()); 
# 1613
const double __y = (__param._M_d2) + ((((2) * __s2s) * __e1) / (__param._M_d2)); 
# 1615
__x = std::floor(-__y); 
# 1616
__v = ((-__e2) - (((__param._M_d2) * __y) / ((2) * __s2s))); 
# 1617
__reject = false; 
# 1618
}  }  }  
# 1620
__reject = ((__reject || (__x < (-__np))) || (__x > (__t - __np))); 
# 1621
if (!__reject) 
# 1622
{ 
# 1623
const double __lfx = std::lgamma((__np + __x) + (1)) + std::lgamma((__t - (__np + __x)) + 1); 
# 1626
__reject = (__v > (((__param._M_lf) - __lfx) + (__x * (__param._M_lp1p)))); 
# 1628
}  
# 1630
__reject |= ((__x + __np) >= __thr); 
# 1631
} 
# 1632
while (__reject); 
# 1634
__x += (__np + __naf); 
# 1636
const _IntType __z = _M_waiting(__urng, __t - ((_IntType)__x), (__param._M_q)); 
# 1638
__ret = (((_IntType)__x) + __z); 
# 1639
} else { 
# 1642
__ret = _M_waiting(__urng, __t, (__param._M_q)); }  
# 1644
if (__p12 != __p) { 
# 1645
__ret = (__t - __ret); }  
# 1646
return __ret; 
# 1647
} 
# 1649
template< class _IntType> 
# 1650
template< class _ForwardIterator, class 
# 1651
_UniformRandomNumberGenerator> void 
# 1654
binomial_distribution< _IntType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 1655
__urng, const param_type &
# 1656
__param) 
# 1657
{ 
# 1660
while (__f != __t) { 
# 1661
(*(__f++)) = (this->operator()(__urng, __param)); }  
# 1662
} 
# 1664
template< class _IntType, class 
# 1665
_CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 1667
operator<<(basic_ostream< _CharT, _Traits>  &__os, const binomial_distribution< _IntType>  &
# 1668
__x) 
# 1669
{ 
# 1670
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 1671
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 1673
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 1674
const _CharT __fill = (__os.fill()); 
# 1675
const streamsize __precision = (__os.precision()); 
# 1676
const _CharT __space = (__os.widen(' ')); 
# 1677
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 1678
(__os.fill(__space)); 
# 1679
(__os.precision(std::numeric_limits< double> ::max_digits10)); 
# 1681
((((__os << (__x.t())) << __space) << (__x.p())) << __space) << (__x._M_nd); 
# 1684
(__os.flags(__flags)); 
# 1685
(__os.fill(__fill)); 
# 1686
(__os.precision(__precision)); 
# 1687
return __os; 
# 1688
} 
# 1690
template< class _IntType, class 
# 1691
_CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 1693
operator>>(basic_istream< _CharT, _Traits>  &__is, binomial_distribution< _IntType>  &
# 1694
__x) 
# 1695
{ 
# 1696
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1697
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1699
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 1700
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 1702
_IntType __t; 
# 1703
double __p; 
# 1704
((__is >> __t) >> __p) >> (__x._M_nd); 
# 1705
(__x.param(typename binomial_distribution< _IntType> ::param_type(__t, __p))); 
# 1708
(__is.flags(__flags)); 
# 1709
return __is; 
# 1710
} 
# 1713
template< class _RealType> 
# 1714
template< class _ForwardIterator, class 
# 1715
_UniformRandomNumberGenerator> void 
# 1718
exponential_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 1719
__urng, const param_type &
# 1720
__p) 
# 1721
{ 
# 1724
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 1725
while (__f != __t) { 
# 1726
(*(__f++)) = ((-std::log(((result_type)1) - __aurng())) / (__p.lambda())); }  
# 1727
} 
# 1729
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 1731
operator<<(basic_ostream< _CharT, _Traits>  &__os, const exponential_distribution< _RealType>  &
# 1732
__x) 
# 1733
{ 
# 1734
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 1735
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 1737
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 1738
const _CharT __fill = (__os.fill()); 
# 1739
const streamsize __precision = (__os.precision()); 
# 1740
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 1741
(__os.fill((__os.widen(' ')))); 
# 1742
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 1744
__os << (__x.lambda()); 
# 1746
(__os.flags(__flags)); 
# 1747
(__os.fill(__fill)); 
# 1748
(__os.precision(__precision)); 
# 1749
return __os; 
# 1750
} 
# 1752
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 1754
operator>>(basic_istream< _CharT, _Traits>  &__is, exponential_distribution< _RealType>  &
# 1755
__x) 
# 1756
{ 
# 1757
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1758
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1760
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 1761
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 1763
_RealType __lambda; 
# 1764
__is >> __lambda; 
# 1765
(__x.param((typename exponential_distribution< _RealType> ::param_type)__lambda)); 
# 1768
(__is.flags(__flags)); 
# 1769
return __is; 
# 1770
} 
# 1779 "/usr/include/c++/5/bits/random.tcc" 3
template< class _RealType> 
# 1780
template< class _UniformRandomNumberGenerator> typename normal_distribution< _RealType> ::result_type 
# 1783
normal_distribution< _RealType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 1784
__param) 
# 1785
{ 
# 1786
result_type __ret; 
# 1788
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 1790
if (_M_saved_available) 
# 1791
{ 
# 1792
(_M_saved_available) = false; 
# 1793
__ret = (_M_saved); 
# 1794
} else 
# 1796
{ 
# 1797
result_type __x, __y, __r2; 
# 1798
do 
# 1799
{ 
# 1800
__x = ((((result_type)(2.0)) * __aurng()) - (1.0)); 
# 1801
__y = ((((result_type)(2.0)) * __aurng()) - (1.0)); 
# 1802
__r2 = ((__x * __x) + (__y * __y)); 
# 1803
} 
# 1804
while ((__r2 > (1.0)) || (__r2 == (0.0))); 
# 1806
const result_type __mult = std::sqrt(((-2) * std::log(__r2)) / __r2); 
# 1807
(_M_saved) = (__x * __mult); 
# 1808
(_M_saved_available) = true; 
# 1809
__ret = (__y * __mult); 
# 1810
}  
# 1812
__ret = ((__ret * (__param.stddev())) + (__param.mean())); 
# 1813
return __ret; 
# 1814
} 
# 1816
template< class _RealType> 
# 1817
template< class _ForwardIterator, class 
# 1818
_UniformRandomNumberGenerator> void 
# 1821
normal_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 1822
__urng, const param_type &
# 1823
__param) 
# 1824
{ 
# 1827
if (__f == __t) { 
# 1828
return; }  
# 1830
if (_M_saved_available) 
# 1831
{ 
# 1832
(_M_saved_available) = false; 
# 1833
(*(__f++)) = (((_M_saved) * (__param.stddev())) + (__param.mean())); 
# 1835
if (__f == __t) { 
# 1836
return; }  
# 1837
}  
# 1840
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 1842
while ((__f + 1) < __t) 
# 1843
{ 
# 1844
result_type __x, __y, __r2; 
# 1845
do 
# 1846
{ 
# 1847
__x = ((((result_type)(2.0)) * __aurng()) - (1.0)); 
# 1848
__y = ((((result_type)(2.0)) * __aurng()) - (1.0)); 
# 1849
__r2 = ((__x * __x) + (__y * __y)); 
# 1850
} 
# 1851
while ((__r2 > (1.0)) || (__r2 == (0.0))); 
# 1853
const result_type __mult = std::sqrt(((-2) * std::log(__r2)) / __r2); 
# 1854
(*(__f++)) = (((__y * __mult) * (__param.stddev())) + (__param.mean())); 
# 1855
(*(__f++)) = (((__x * __mult) * (__param.stddev())) + (__param.mean())); 
# 1856
}  
# 1858
if (__f != __t) 
# 1859
{ 
# 1860
result_type __x, __y, __r2; 
# 1861
do 
# 1862
{ 
# 1863
__x = ((((result_type)(2.0)) * __aurng()) - (1.0)); 
# 1864
__y = ((((result_type)(2.0)) * __aurng()) - (1.0)); 
# 1865
__r2 = ((__x * __x) + (__y * __y)); 
# 1866
} 
# 1867
while ((__r2 > (1.0)) || (__r2 == (0.0))); 
# 1869
const result_type __mult = std::sqrt(((-2) * std::log(__r2)) / __r2); 
# 1870
(_M_saved) = (__x * __mult); 
# 1871
(_M_saved_available) = true; 
# 1872
(*__f) = (((__y * __mult) * (__param.stddev())) + (__param.mean())); 
# 1873
}  
# 1874
} 
# 1876
template< class _RealType> bool 
# 1878
operator==(const normal_distribution< _RealType>  &__d1, const normal_distribution< _RealType>  &
# 1879
__d2) 
# 1880
{ 
# 1881
if (((__d1._M_param) == (__d2._M_param)) && ((__d1._M_saved_available) == (__d2._M_saved_available))) 
# 1883
{ 
# 1884
if ((__d1._M_saved_available) && ((__d1._M_saved) == (__d2._M_saved))) { 
# 1886
return true; } else { 
# 1887
if (!(__d1._M_saved_available)) { 
# 1888
return true; } else { 
# 1890
return false; }  }  
# 1891
} else { 
# 1893
return false; }  
# 1894
} 
# 1896
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 1898
operator<<(basic_ostream< _CharT, _Traits>  &__os, const normal_distribution< _RealType>  &
# 1899
__x) 
# 1900
{ 
# 1901
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 1902
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 1904
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 1905
const _CharT __fill = (__os.fill()); 
# 1906
const streamsize __precision = (__os.precision()); 
# 1907
const _CharT __space = (__os.widen(' ')); 
# 1908
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 1909
(__os.fill(__space)); 
# 1910
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 1912
((((__os << (__x.mean())) << __space) << (__x.stddev())) << __space) << (__x._M_saved_available); 
# 1914
if (__x._M_saved_available) { 
# 1915
(__os << __space) << (__x._M_saved); }  
# 1917
(__os.flags(__flags)); 
# 1918
(__os.fill(__fill)); 
# 1919
(__os.precision(__precision)); 
# 1920
return __os; 
# 1921
} 
# 1923
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 1925
operator>>(basic_istream< _CharT, _Traits>  &__is, normal_distribution< _RealType>  &
# 1926
__x) 
# 1927
{ 
# 1928
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1929
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1931
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 1932
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 1934
double __mean, __stddev; 
# 1935
((__is >> __mean) >> __stddev) >> (__x._M_saved_available); 
# 1937
if (__x._M_saved_available) { 
# 1938
__is >> (__x._M_saved); }  
# 1939
(__x.param(typename normal_distribution< _RealType> ::param_type(__mean, __stddev))); 
# 1942
(__is.flags(__flags)); 
# 1943
return __is; 
# 1944
} 
# 1947
template< class _RealType> 
# 1948
template< class _ForwardIterator, class 
# 1949
_UniformRandomNumberGenerator> void 
# 1952
lognormal_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 1953
__urng, const param_type &
# 1954
__p) 
# 1955
{ 
# 1957
while (__f != __t) { 
# 1958
(*(__f++)) = std::exp(((__p.s()) * (_M_nd)(__urng)) + (__p.m())); }  
# 1959
} 
# 1961
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 1963
operator<<(basic_ostream< _CharT, _Traits>  &__os, const lognormal_distribution< _RealType>  &
# 1964
__x) 
# 1965
{ 
# 1966
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 1967
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 1969
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 1970
const _CharT __fill = (__os.fill()); 
# 1971
const streamsize __precision = (__os.precision()); 
# 1972
const _CharT __space = (__os.widen(' ')); 
# 1973
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 1974
(__os.fill(__space)); 
# 1975
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 1977
((((__os << (__x.m())) << __space) << (__x.s())) << __space) << (__x._M_nd); 
# 1980
(__os.flags(__flags)); 
# 1981
(__os.fill(__fill)); 
# 1982
(__os.precision(__precision)); 
# 1983
return __os; 
# 1984
} 
# 1986
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 1988
operator>>(basic_istream< _CharT, _Traits>  &__is, lognormal_distribution< _RealType>  &
# 1989
__x) 
# 1990
{ 
# 1991
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1992
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1994
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 1995
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 1997
_RealType __m, __s; 
# 1998
((__is >> __m) >> __s) >> (__x._M_nd); 
# 1999
(__x.param(typename lognormal_distribution< _RealType> ::param_type(__m, __s))); 
# 2002
(__is.flags(__flags)); 
# 2003
return __is; 
# 2004
} 
# 2006
template< class _RealType> 
# 2007
template< class _ForwardIterator, class 
# 2008
_UniformRandomNumberGenerator> void 
# 2011
chi_squared_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2012
__urng) 
# 2013
{ 
# 2015
while (__f != __t) { 
# 2016
(*(__f++)) = (2 * (_M_gd)(__urng)); }  
# 2017
} 
# 2019
template< class _RealType> 
# 2020
template< class _ForwardIterator, class 
# 2021
_UniformRandomNumberGenerator> void 
# 2024
chi_squared_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2025
__urng, const typename gamma_distribution< _RealType> ::param_type &
# 2027
__p) 
# 2028
{ 
# 2030
while (__f != __t) { 
# 2031
(*(__f++)) = (2 * (_M_gd)(__urng, __p)); }  
# 2032
} 
# 2034
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 2036
operator<<(basic_ostream< _CharT, _Traits>  &__os, const chi_squared_distribution< _RealType>  &
# 2037
__x) 
# 2038
{ 
# 2039
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 2040
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 2042
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 2043
const _CharT __fill = (__os.fill()); 
# 2044
const streamsize __precision = (__os.precision()); 
# 2045
const _CharT __space = (__os.widen(' ')); 
# 2046
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 2047
(__os.fill(__space)); 
# 2048
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 2050
((__os << (__x.n())) << __space) << (__x._M_gd); 
# 2052
(__os.flags(__flags)); 
# 2053
(__os.fill(__fill)); 
# 2054
(__os.precision(__precision)); 
# 2055
return __os; 
# 2056
} 
# 2058
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 2060
operator>>(basic_istream< _CharT, _Traits>  &__is, chi_squared_distribution< _RealType>  &
# 2061
__x) 
# 2062
{ 
# 2063
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 2064
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 2066
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 2067
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 2069
_RealType __n; 
# 2070
(__is >> __n) >> (__x._M_gd); 
# 2071
(__x.param((typename chi_squared_distribution< _RealType> ::param_type)__n)); 
# 2074
(__is.flags(__flags)); 
# 2075
return __is; 
# 2076
} 
# 2079
template< class _RealType> 
# 2080
template< class _UniformRandomNumberGenerator> typename cauchy_distribution< _RealType> ::result_type 
# 2083
cauchy_distribution< _RealType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 2084
__p) 
# 2085
{ 
# 2087
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 2088
_RealType __u; 
# 2089
do { 
# 2090
__u = __aurng(); } 
# 2091
while (__u == (0.5)); 
# 2093
const _RealType __pi = ((3.141592653589793116L)); 
# 2094
return (__p.a()) + ((__p.b()) * std::tan(__pi * __u)); 
# 2095
} 
# 2097
template< class _RealType> 
# 2098
template< class _ForwardIterator, class 
# 2099
_UniformRandomNumberGenerator> void 
# 2102
cauchy_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2103
__urng, const param_type &
# 2104
__p) 
# 2105
{ 
# 2107
const _RealType __pi = ((3.141592653589793116L)); 
# 2109
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 2110
while (__f != __t) 
# 2111
{ 
# 2112
_RealType __u; 
# 2113
do { 
# 2114
__u = __aurng(); } 
# 2115
while (__u == (0.5)); 
# 2117
(*(__f++)) = ((__p.a()) + ((__p.b()) * std::tan(__pi * __u))); 
# 2118
}  
# 2119
} 
# 2121
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 2123
operator<<(basic_ostream< _CharT, _Traits>  &__os, const cauchy_distribution< _RealType>  &
# 2124
__x) 
# 2125
{ 
# 2126
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 2127
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 2129
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 2130
const _CharT __fill = (__os.fill()); 
# 2131
const streamsize __precision = (__os.precision()); 
# 2132
const _CharT __space = (__os.widen(' ')); 
# 2133
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 2134
(__os.fill(__space)); 
# 2135
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 2137
((__os << (__x.a())) << __space) << (__x.b()); 
# 2139
(__os.flags(__flags)); 
# 2140
(__os.fill(__fill)); 
# 2141
(__os.precision(__precision)); 
# 2142
return __os; 
# 2143
} 
# 2145
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 2147
operator>>(basic_istream< _CharT, _Traits>  &__is, cauchy_distribution< _RealType>  &
# 2148
__x) 
# 2149
{ 
# 2150
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 2151
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 2153
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 2154
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 2156
_RealType __a, __b; 
# 2157
(__is >> __a) >> __b; 
# 2158
(__x.param(typename cauchy_distribution< _RealType> ::param_type(__a, __b))); 
# 2161
(__is.flags(__flags)); 
# 2162
return __is; 
# 2163
} 
# 2166
template< class _RealType> 
# 2167
template< class _ForwardIterator, class 
# 2168
_UniformRandomNumberGenerator> void 
# 2171
fisher_f_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2172
__urng) 
# 2173
{ 
# 2175
while (__f != __t) { 
# 2176
(*(__f++)) = (((_M_gd_x)(__urng) * n()) / ((_M_gd_y)(__urng) * m())); }  
# 2177
} 
# 2179
template< class _RealType> 
# 2180
template< class _ForwardIterator, class 
# 2181
_UniformRandomNumberGenerator> void 
# 2184
fisher_f_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2185
__urng, const param_type &
# 2186
__p) 
# 2187
{ 
# 2190
typedef typename gamma_distribution< _RealType> ::param_type param_type; 
# 2191
param_type __p1((__p.m()) / 2); 
# 2192
param_type __p2((__p.n()) / 2); 
# 2193
while (__f != __t) { 
# 2194
(*(__f++)) = (((_M_gd_x)(__urng, __p1) * n()) / ((_M_gd_y)(__urng, __p2) * m())); }  
# 2196
} 
# 2198
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 2200
operator<<(basic_ostream< _CharT, _Traits>  &__os, const fisher_f_distribution< _RealType>  &
# 2201
__x) 
# 2202
{ 
# 2203
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 2204
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 2206
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 2207
const _CharT __fill = (__os.fill()); 
# 2208
const streamsize __precision = (__os.precision()); 
# 2209
const _CharT __space = (__os.widen(' ')); 
# 2210
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 2211
(__os.fill(__space)); 
# 2212
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 2214
((((((__os << (__x.m())) << __space) << (__x.n())) << __space) << (__x._M_gd_x)) << __space) << (__x._M_gd_y); 
# 2217
(__os.flags(__flags)); 
# 2218
(__os.fill(__fill)); 
# 2219
(__os.precision(__precision)); 
# 2220
return __os; 
# 2221
} 
# 2223
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 2225
operator>>(basic_istream< _CharT, _Traits>  &__is, fisher_f_distribution< _RealType>  &
# 2226
__x) 
# 2227
{ 
# 2228
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 2229
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 2231
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 2232
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 2234
_RealType __m, __n; 
# 2235
(((__is >> __m) >> __n) >> (__x._M_gd_x)) >> (__x._M_gd_y); 
# 2236
(__x.param(typename fisher_f_distribution< _RealType> ::param_type(__m, __n))); 
# 2239
(__is.flags(__flags)); 
# 2240
return __is; 
# 2241
} 
# 2244
template< class _RealType> 
# 2245
template< class _ForwardIterator, class 
# 2246
_UniformRandomNumberGenerator> void 
# 2249
student_t_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2250
__urng) 
# 2251
{ 
# 2253
while (__f != __t) { 
# 2254
(*(__f++)) = ((_M_nd)(__urng) * std::sqrt(n() / (_M_gd)(__urng))); }  
# 2255
} 
# 2257
template< class _RealType> 
# 2258
template< class _ForwardIterator, class 
# 2259
_UniformRandomNumberGenerator> void 
# 2262
student_t_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2263
__urng, const param_type &
# 2264
__p) 
# 2265
{ 
# 2268
typename gamma_distribution< _RealType> ::param_type __p2((__p.n()) / 2, 2); 
# 2269
while (__f != __t) { 
# 2270
(*(__f++)) = ((_M_nd)(__urng) * std::sqrt((__p.n()) / (_M_gd)(__urng, __p2))); }  
# 2271
} 
# 2273
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 2275
operator<<(basic_ostream< _CharT, _Traits>  &__os, const student_t_distribution< _RealType>  &
# 2276
__x) 
# 2277
{ 
# 2278
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 2279
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 2281
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 2282
const _CharT __fill = (__os.fill()); 
# 2283
const streamsize __precision = (__os.precision()); 
# 2284
const _CharT __space = (__os.widen(' ')); 
# 2285
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 2286
(__os.fill(__space)); 
# 2287
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 2289
((((__os << (__x.n())) << __space) << (__x._M_nd)) << __space) << (__x._M_gd); 
# 2291
(__os.flags(__flags)); 
# 2292
(__os.fill(__fill)); 
# 2293
(__os.precision(__precision)); 
# 2294
return __os; 
# 2295
} 
# 2297
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 2299
operator>>(basic_istream< _CharT, _Traits>  &__is, student_t_distribution< _RealType>  &
# 2300
__x) 
# 2301
{ 
# 2302
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 2303
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 2305
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 2306
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 2308
_RealType __n; 
# 2309
((__is >> __n) >> (__x._M_nd)) >> (__x._M_gd); 
# 2310
(__x.param((typename student_t_distribution< _RealType> ::param_type)__n)); 
# 2312
(__is.flags(__flags)); 
# 2313
return __is; 
# 2314
} 
# 2317
template< class _RealType> void 
# 2320
gamma_distribution< _RealType> ::param_type::_M_initialize() 
# 2321
{ 
# 2322
(_M_malpha) = (((_M_alpha) < (1.0)) ? (_M_alpha) + ((_RealType)(1.0)) : (_M_alpha)); 
# 2324
const _RealType __a1 = (_M_malpha) - (((_RealType)(1.0)) / ((_RealType)(3.0))); 
# 2325
(_M_a2) = (((_RealType)(1.0)) / std::sqrt(((_RealType)(9.0)) * __a1)); 
# 2326
} 
# 2333
template< class _RealType> 
# 2334
template< class _UniformRandomNumberGenerator> typename gamma_distribution< _RealType> ::result_type 
# 2337
gamma_distribution< _RealType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 2338
__param) 
# 2339
{ 
# 2341
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 2343
result_type __u, __v, __n; 
# 2344
const result_type __a1 = (__param._M_malpha) - (((_RealType)(1.0)) / ((_RealType)(3.0))); 
# 2347
do 
# 2348
{ 
# 2349
do 
# 2350
{ 
# 2351
__n = (_M_nd)(__urng); 
# 2352
__v = (((result_type)(1.0)) + ((__param._M_a2) * __n)); 
# 2353
} 
# 2354
while (__v <= (0.0)); 
# 2356
__v = ((__v * __v) * __v); 
# 2357
__u = __aurng(); 
# 2358
} 
# 2359
while ((__u > (((result_type)(1.0)) - (((((0.3310000000000000164) * __n) * __n) * __n) * __n))) && (std::log(__u) > ((((0.5) * __n) * __n) + (__a1 * (((1.0) - __v) + std::log(__v)))))); 
# 2363
if ((__param.alpha()) == (__param._M_malpha)) { 
# 2364
return (__a1 * __v) * (__param.beta()); } else 
# 2366
{ 
# 2367
do { 
# 2368
__u = __aurng(); } 
# 2369
while (__u == (0.0)); 
# 2371
return ((std::pow(__u, ((result_type)(1.0)) / (__param.alpha())) * __a1) * __v) * (__param.beta()); 
# 2373
}  
# 2374
} 
# 2376
template< class _RealType> 
# 2377
template< class _ForwardIterator, class 
# 2378
_UniformRandomNumberGenerator> void 
# 2381
gamma_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2382
__urng, const param_type &
# 2383
__param) 
# 2384
{ 
# 2387
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 2389
result_type __u, __v, __n; 
# 2390
const result_type __a1 = (__param._M_malpha) - (((_RealType)(1.0)) / ((_RealType)(3.0))); 
# 2393
if ((__param.alpha()) == (__param._M_malpha)) { 
# 2394
while (__f != __t) 
# 2395
{ 
# 2396
do 
# 2397
{ 
# 2398
do 
# 2399
{ 
# 2400
__n = (_M_nd)(__urng); 
# 2401
__v = (((result_type)(1.0)) + ((__param._M_a2) * __n)); 
# 2402
} 
# 2403
while (__v <= (0.0)); 
# 2405
__v = ((__v * __v) * __v); 
# 2406
__u = __aurng(); 
# 2407
} 
# 2408
while ((__u > (((result_type)(1.0)) - (((((0.3310000000000000164) * __n) * __n) * __n) * __n))) && (std::log(__u) > ((((0.5) * __n) * __n) + (__a1 * (((1.0) - __v) + std::log(__v)))))); 
# 2412
(*(__f++)) = ((__a1 * __v) * (__param.beta())); 
# 2413
}  } else { 
# 2415
while (__f != __t) 
# 2416
{ 
# 2417
do 
# 2418
{ 
# 2419
do 
# 2420
{ 
# 2421
__n = (_M_nd)(__urng); 
# 2422
__v = (((result_type)(1.0)) + ((__param._M_a2) * __n)); 
# 2423
} 
# 2424
while (__v <= (0.0)); 
# 2426
__v = ((__v * __v) * __v); 
# 2427
__u = __aurng(); 
# 2428
} 
# 2429
while ((__u > (((result_type)(1.0)) - (((((0.3310000000000000164) * __n) * __n) * __n) * __n))) && (std::log(__u) > ((((0.5) * __n) * __n) + (__a1 * (((1.0) - __v) + std::log(__v)))))); 
# 2433
do { 
# 2434
__u = __aurng(); } 
# 2435
while (__u == (0.0)); 
# 2437
(*(__f++)) = (((std::pow(__u, ((result_type)(1.0)) / (__param.alpha())) * __a1) * __v) * (__param.beta())); 
# 2439
}  }  
# 2440
} 
# 2442
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 2444
operator<<(basic_ostream< _CharT, _Traits>  &__os, const gamma_distribution< _RealType>  &
# 2445
__x) 
# 2446
{ 
# 2447
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 2448
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 2450
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 2451
const _CharT __fill = (__os.fill()); 
# 2452
const streamsize __precision = (__os.precision()); 
# 2453
const _CharT __space = (__os.widen(' ')); 
# 2454
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 2455
(__os.fill(__space)); 
# 2456
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 2458
((((__os << (__x.alpha())) << __space) << (__x.beta())) << __space) << (__x._M_nd); 
# 2461
(__os.flags(__flags)); 
# 2462
(__os.fill(__fill)); 
# 2463
(__os.precision(__precision)); 
# 2464
return __os; 
# 2465
} 
# 2467
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 2469
operator>>(basic_istream< _CharT, _Traits>  &__is, gamma_distribution< _RealType>  &
# 2470
__x) 
# 2471
{ 
# 2472
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 2473
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 2475
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 2476
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 2478
_RealType __alpha_val, __beta_val; 
# 2479
((__is >> __alpha_val) >> __beta_val) >> (__x._M_nd); 
# 2480
(__x.param(typename gamma_distribution< _RealType> ::param_type(__alpha_val, __beta_val))); 
# 2483
(__is.flags(__flags)); 
# 2484
return __is; 
# 2485
} 
# 2488
template< class _RealType> 
# 2489
template< class _UniformRandomNumberGenerator> typename weibull_distribution< _RealType> ::result_type 
# 2492
weibull_distribution< _RealType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 2493
__p) 
# 2494
{ 
# 2496
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 2497
return (__p.b()) * std::pow(-std::log(((result_type)1) - __aurng()), ((result_type)1) / (__p.a())); 
# 2499
} 
# 2501
template< class _RealType> 
# 2502
template< class _ForwardIterator, class 
# 2503
_UniformRandomNumberGenerator> void 
# 2506
weibull_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2507
__urng, const param_type &
# 2508
__p) 
# 2509
{ 
# 2512
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 2513
auto __inv_a = ((result_type)1) / (__p.a()); 
# 2515
while (__f != __t) { 
# 2516
(*(__f++)) = ((__p.b()) * std::pow(-std::log(((result_type)1) - __aurng()), __inv_a)); }  
# 2518
} 
# 2520
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 2522
operator<<(basic_ostream< _CharT, _Traits>  &__os, const weibull_distribution< _RealType>  &
# 2523
__x) 
# 2524
{ 
# 2525
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 2526
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 2528
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 2529
const _CharT __fill = (__os.fill()); 
# 2530
const streamsize __precision = (__os.precision()); 
# 2531
const _CharT __space = (__os.widen(' ')); 
# 2532
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 2533
(__os.fill(__space)); 
# 2534
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 2536
((__os << (__x.a())) << __space) << (__x.b()); 
# 2538
(__os.flags(__flags)); 
# 2539
(__os.fill(__fill)); 
# 2540
(__os.precision(__precision)); 
# 2541
return __os; 
# 2542
} 
# 2544
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 2546
operator>>(basic_istream< _CharT, _Traits>  &__is, weibull_distribution< _RealType>  &
# 2547
__x) 
# 2548
{ 
# 2549
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 2550
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 2552
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 2553
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 2555
_RealType __a, __b; 
# 2556
(__is >> __a) >> __b; 
# 2557
(__x.param(typename weibull_distribution< _RealType> ::param_type(__a, __b))); 
# 2560
(__is.flags(__flags)); 
# 2561
return __is; 
# 2562
} 
# 2565
template< class _RealType> 
# 2566
template< class _UniformRandomNumberGenerator> typename extreme_value_distribution< _RealType> ::result_type 
# 2569
extreme_value_distribution< _RealType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 2570
__p) 
# 2571
{ 
# 2573
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 2574
return (__p.a()) - ((__p.b()) * std::log(-std::log(((result_type)1) - __aurng()))); 
# 2576
} 
# 2578
template< class _RealType> 
# 2579
template< class _ForwardIterator, class 
# 2580
_UniformRandomNumberGenerator> void 
# 2583
extreme_value_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2584
__urng, const param_type &
# 2585
__p) 
# 2586
{ 
# 2589
__detail::_Adaptor< _UniformRandomNumberGenerator, _RealType>  __aurng(__urng); 
# 2591
while (__f != __t) { 
# 2592
(*(__f++)) = ((__p.a()) - ((__p.b()) * std::log(-std::log(((result_type)1) - __aurng())))); }  
# 2594
} 
# 2596
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 2598
operator<<(basic_ostream< _CharT, _Traits>  &__os, const extreme_value_distribution< _RealType>  &
# 2599
__x) 
# 2600
{ 
# 2601
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 2602
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 2604
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 2605
const _CharT __fill = (__os.fill()); 
# 2606
const streamsize __precision = (__os.precision()); 
# 2607
const _CharT __space = (__os.widen(' ')); 
# 2608
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 2609
(__os.fill(__space)); 
# 2610
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 2612
((__os << (__x.a())) << __space) << (__x.b()); 
# 2614
(__os.flags(__flags)); 
# 2615
(__os.fill(__fill)); 
# 2616
(__os.precision(__precision)); 
# 2617
return __os; 
# 2618
} 
# 2620
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 2622
operator>>(basic_istream< _CharT, _Traits>  &__is, extreme_value_distribution< _RealType>  &
# 2623
__x) 
# 2624
{ 
# 2625
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 2626
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 2628
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 2629
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 2631
_RealType __a, __b; 
# 2632
(__is >> __a) >> __b; 
# 2633
(__x.param(typename extreme_value_distribution< _RealType> ::param_type(__a, __b))); 
# 2636
(__is.flags(__flags)); 
# 2637
return __is; 
# 2638
} 
# 2641
template< class _IntType> void 
# 2644
discrete_distribution< _IntType> ::param_type::_M_initialize() 
# 2645
{ 
# 2646
if ((_M_prob).size() < (2)) 
# 2647
{ 
# 2648
(_M_prob).clear(); 
# 2649
return; 
# 2650
}  
# 2652
const double __sum = std::accumulate((_M_prob).begin(), (_M_prob).end(), (0.0)); 
# 2655
__detail::__normalize((_M_prob).begin(), (_M_prob).end(), (_M_prob).begin(), __sum); 
# 2658
(_M_cp).reserve((_M_prob).size()); 
# 2659
std::partial_sum((_M_prob).begin(), (_M_prob).end(), std::back_inserter(_M_cp)); 
# 2662
(_M_cp)[(_M_cp).size() - (1)] = (1.0); 
# 2663
} 
# 2665
template< class _IntType> 
# 2666
template< class _Func> 
# 2668
discrete_distribution< _IntType> ::param_type::param_type(size_t __nw, double __xmin, double __xmax, _Func __fw) : _M_prob(), _M_cp() 
# 2670
{ 
# 2671
const size_t __n = (__nw == (0)) ? 1 : __nw; 
# 2672
const double __delta = (__xmax - __xmin) / __n; 
# 2674
(_M_prob).reserve(__n); 
# 2675
for (size_t __k = (0); __k < __nw; ++__k) { 
# 2676
((_M_prob).push_back(__fw((__xmin + (__k * __delta)) + ((0.5) * __delta)))); }  
# 2678
_M_initialize(); 
# 2679
} 
# 2681
template< class _IntType> 
# 2682
template< class _UniformRandomNumberGenerator> typename discrete_distribution< _IntType> ::result_type 
# 2685
discrete_distribution< _IntType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 2686
__param) 
# 2687
{ 
# 2688
if (((__param._M_cp).empty())) { 
# 2689
return (result_type)0; }  
# 2692
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 2694
const double __p = __aurng(); 
# 2695
auto __pos = std::lower_bound(((__param._M_cp).begin()), ((__param._M_cp).end()), __p); 
# 2698
return __pos - ((__param._M_cp).begin()); 
# 2699
} 
# 2701
template< class _IntType> 
# 2702
template< class _ForwardIterator, class 
# 2703
_UniformRandomNumberGenerator> void 
# 2706
discrete_distribution< _IntType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2707
__urng, const param_type &
# 2708
__param) 
# 2709
{ 
# 2712
if (((__param._M_cp).empty())) 
# 2713
{ 
# 2714
while (__f != __t) { 
# 2715
(*(__f++)) = ((result_type)0); }  
# 2716
return; 
# 2717
}  
# 2720
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 2722
while (__f != __t) 
# 2723
{ 
# 2724
const double __p = __aurng(); 
# 2725
auto __pos = std::lower_bound(((__param._M_cp).begin()), ((__param._M_cp).end()), __p); 
# 2728
(*(__f++)) = (__pos - ((__param._M_cp).begin())); 
# 2729
}  
# 2730
} 
# 2732
template< class _IntType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 2734
operator<<(basic_ostream< _CharT, _Traits>  &__os, const discrete_distribution< _IntType>  &
# 2735
__x) 
# 2736
{ 
# 2737
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 2738
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 2740
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 2741
const _CharT __fill = (__os.fill()); 
# 2742
const streamsize __precision = (__os.precision()); 
# 2743
const _CharT __space = (__os.widen(' ')); 
# 2744
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 2745
(__os.fill(__space)); 
# 2746
(__os.precision(std::numeric_limits< double> ::max_digits10)); 
# 2748
vector< double>  __prob = (__x.probabilities()); 
# 2749
__os << __prob.size(); 
# 2750
for (auto __dit = __prob.begin(); (__dit != (__prob.end())); (++__dit)) { 
# 2751
(__os << __space) << (*__dit); }  
# 2753
(__os.flags(__flags)); 
# 2754
(__os.fill(__fill)); 
# 2755
(__os.precision(__precision)); 
# 2756
return __os; 
# 2757
} 
# 2759
template< class _IntType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 2761
operator>>(basic_istream< _CharT, _Traits>  &__is, discrete_distribution< _IntType>  &
# 2762
__x) 
# 2763
{ 
# 2764
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 2765
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 2767
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 2768
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 2770
size_t __n; 
# 2771
__is >> __n; 
# 2773
vector< double>  __prob_vec; 
# 2774
__prob_vec.reserve(__n); 
# 2775
for (; __n != (0); --__n) 
# 2776
{ 
# 2777
double __prob; 
# 2778
__is >> __prob; 
# 2779
__prob_vec.push_back(__prob); 
# 2780
}  
# 2782
(__x.param(typename discrete_distribution< _IntType> ::param_type(__prob_vec.begin(), __prob_vec.end()))); 
# 2785
(__is.flags(__flags)); 
# 2786
return __is; 
# 2787
} 
# 2790
template< class _RealType> void 
# 2793
piecewise_constant_distribution< _RealType> ::param_type::_M_initialize() 
# 2794
{ 
# 2795
if ((((_M_int).size()) < 2) || ((((_M_int).size()) == 2) && (((_M_int)[0]) == ((_RealType)0)) && (((_M_int)[1]) == ((_RealType)1)))) 
# 2799
{ 
# 2800
((_M_int).clear()); 
# 2801
(_M_den).clear(); 
# 2802
return; 
# 2803
}  
# 2805
const double __sum = std::accumulate((_M_den).begin(), (_M_den).end(), (0.0)); 
# 2808
__detail::__normalize((_M_den).begin(), (_M_den).end(), (_M_den).begin(), __sum); 
# 2811
(_M_cp).reserve((_M_den).size()); 
# 2812
std::partial_sum((_M_den).begin(), (_M_den).end(), std::back_inserter(_M_cp)); 
# 2816
(_M_cp)[(_M_cp).size() - (1)] = (1.0); 
# 2818
for (size_t __k = (0); __k < (_M_den).size(); ++__k) { 
# 2819
(_M_den)[__k] /= (((_M_int)[__k + (1)]) - ((_M_int)[__k])); }  
# 2820
} 
# 2822
template< class _RealType> 
# 2823
template< class _InputIteratorB, class _InputIteratorW> 
# 2825
piecewise_constant_distribution< _RealType> ::param_type::param_type(_InputIteratorB __bbegin, _InputIteratorB 
# 2826
__bend, _InputIteratorW 
# 2827
__wbegin) : _M_int(), _M_den(), _M_cp() 
# 2829
{ 
# 2830
if (__bbegin != __bend) 
# 2831
{ 
# 2832
for (; ;) 
# 2833
{ 
# 2834
((_M_int).push_back(*__bbegin)); 
# 2835
++__bbegin; 
# 2836
if (__bbegin == __bend) { 
# 2837
break; }  
# 2839
((_M_den).push_back(*__wbegin)); 
# 2840
++__wbegin; 
# 2841
}  
# 2842
}  
# 2844
_M_initialize(); 
# 2845
} 
# 2847
template< class _RealType> 
# 2848
template< class _Func> 
# 2850
piecewise_constant_distribution< _RealType> ::param_type::param_type(initializer_list< _RealType>  __bl, _Func __fw) : _M_int(), _M_den(), _M_cp() 
# 2852
{ 
# 2853
((_M_int).reserve((__bl.size()))); 
# 2854
for (auto __biter = (__bl.begin()); __biter != (__bl.end()); ++__biter) { 
# 2855
((_M_int).push_back(*__biter)); }  
# 2857
(_M_den).reserve(((_M_int).size()) - 1); 
# 2858
for (size_t __k = (0); __k < (((_M_int).size()) - 1); ++__k) { 
# 2859
((_M_den).push_back(__fw((0.5) * (((_M_int)[__k + (1)]) + ((_M_int)[__k]))))); }  
# 2861
_M_initialize(); 
# 2862
} 
# 2864
template< class _RealType> 
# 2865
template< class _Func> 
# 2867
piecewise_constant_distribution< _RealType> ::param_type::param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw) : _M_int(), _M_den(), _M_cp() 
# 2869
{ 
# 2870
const size_t __n = (__nw == (0)) ? 1 : __nw; 
# 2871
const _RealType __delta = (__xmax - __xmin) / __n; 
# 2873
((_M_int).reserve(__n + (1))); 
# 2874
for (size_t __k = (0); __k <= __nw; ++__k) { 
# 2875
((_M_int).push_back(__xmin + (__k * __delta))); }  
# 2877
(_M_den).reserve(__n); 
# 2878
for (size_t __k = (0); __k < __nw; ++__k) { 
# 2879
((_M_den).push_back(__fw(((_M_int)[__k]) + ((0.5) * __delta)))); }  
# 2881
_M_initialize(); 
# 2882
} 
# 2884
template< class _RealType> 
# 2885
template< class _UniformRandomNumberGenerator> typename piecewise_constant_distribution< _RealType> ::result_type 
# 2888
piecewise_constant_distribution< _RealType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 2889
__param) 
# 2890
{ 
# 2892
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 2894
const double __p = __aurng(); 
# 2895
if (((__param._M_cp).empty())) { 
# 2896
return __p; }  
# 2898
auto __pos = std::lower_bound(((__param._M_cp).begin()), ((__param._M_cp).end()), __p); 
# 2900
const size_t __i = __pos - ((__param._M_cp).begin()); 
# 2902
const double __pref = (__i > (0)) ? (__param._M_cp)[__i - (1)] : (0.0); 
# 2904
return ((__param._M_int)[__i]) + ((__p - __pref) / ((__param._M_den)[__i])); 
# 2905
} 
# 2907
template< class _RealType> 
# 2908
template< class _ForwardIterator, class 
# 2909
_UniformRandomNumberGenerator> void 
# 2912
piecewise_constant_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 2913
__urng, const param_type &
# 2914
__param) 
# 2915
{ 
# 2918
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 2920
if (((__param._M_cp).empty())) 
# 2921
{ 
# 2922
while (__f != __t) { 
# 2923
(*(__f++)) = __aurng(); }  
# 2924
return; 
# 2925
}  
# 2927
while (__f != __t) 
# 2928
{ 
# 2929
const double __p = __aurng(); 
# 2931
auto __pos = std::lower_bound(((__param._M_cp).begin()), ((__param._M_cp).end()), __p); 
# 2933
const size_t __i = __pos - ((__param._M_cp).begin()); 
# 2935
const double __pref = (__i > (0)) ? (__param._M_cp)[__i - (1)] : (0.0); 
# 2937
(*(__f++)) = (((__param._M_int)[__i]) + ((__p - __pref) / ((__param._M_den)[__i]))); 
# 2939
}  
# 2940
} 
# 2942
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 2944
operator<<(basic_ostream< _CharT, _Traits>  &__os, const piecewise_constant_distribution< _RealType>  &
# 2945
__x) 
# 2946
{ 
# 2947
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 2948
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 2950
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 2951
const _CharT __fill = (__os.fill()); 
# 2952
const streamsize __precision = (__os.precision()); 
# 2953
const _CharT __space = (__os.widen(' ')); 
# 2954
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 2955
(__os.fill(__space)); 
# 2956
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 2958
vector< _RealType>  __int = (__x.intervals()); 
# 2959
__os << ((__int.size()) - 1); 
# 2961
for (auto __xit = (__int.begin()); __xit != (__int.end()); ++__xit) { 
# 2962
(__os << __space) << (*__xit); }  
# 2964
vector< double>  __den = (__x.densities()); 
# 2965
for (auto __dit = __den.begin(); (__dit != (__den.end())); (++__dit)) { 
# 2966
(__os << __space) << (*__dit); }  
# 2968
(__os.flags(__flags)); 
# 2969
(__os.fill(__fill)); 
# 2970
(__os.precision(__precision)); 
# 2971
return __os; 
# 2972
} 
# 2974
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 2976
operator>>(basic_istream< _CharT, _Traits>  &__is, piecewise_constant_distribution< _RealType>  &
# 2977
__x) 
# 2978
{ 
# 2979
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 2980
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 2982
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 2983
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 2985
size_t __n; 
# 2986
__is >> __n; 
# 2988
vector< _RealType>  __int_vec; 
# 2989
(__int_vec.reserve(__n + (1))); 
# 2990
for (size_t __i = (0); __i <= __n; ++__i) 
# 2991
{ 
# 2992
_RealType __int; 
# 2993
__is >> __int; 
# 2994
(__int_vec.push_back(__int)); 
# 2995
}  
# 2997
vector< double>  __den_vec; 
# 2998
__den_vec.reserve(__n); 
# 2999
for (size_t __i = (0); __i < __n; ++__i) 
# 3000
{ 
# 3001
double __den; 
# 3002
__is >> __den; 
# 3003
__den_vec.push_back(__den); 
# 3004
}  
# 3006
(__x.param(typename piecewise_constant_distribution< _RealType> ::param_type((__int_vec.begin()), (__int_vec.end()), __den_vec.begin()))); 
# 3009
(__is.flags(__flags)); 
# 3010
return __is; 
# 3011
} 
# 3014
template< class _RealType> void 
# 3017
piecewise_linear_distribution< _RealType> ::param_type::_M_initialize() 
# 3018
{ 
# 3019
if ((((_M_int).size()) < 2) || ((((_M_int).size()) == 2) && (((_M_int)[0]) == ((_RealType)0)) && (((_M_int)[1]) == ((_RealType)1)) && ((_M_den)[0] == (_M_den)[1]))) 
# 3024
{ 
# 3025
((_M_int).clear()); 
# 3026
(_M_den).clear(); 
# 3027
return; 
# 3028
}  
# 3030
double __sum = (0.0); 
# 3031
(_M_cp).reserve(((_M_int).size()) - 1); 
# 3032
(_M_m).reserve(((_M_int).size()) - 1); 
# 3033
for (size_t __k = (0); __k < (((_M_int).size()) - 1); ++__k) 
# 3034
{ 
# 3035
const _RealType __delta = ((_M_int)[__k + (1)]) - ((_M_int)[__k]); 
# 3036
__sum += (((0.5) * ((_M_den)[__k + (1)] + (_M_den)[__k])) * __delta); 
# 3037
(_M_cp).push_back(__sum); 
# 3038
((_M_m).push_back(((_M_den)[__k + (1)] - (_M_den)[__k]) / __delta)); 
# 3039
}  
# 3042
__detail::__normalize((_M_den).begin(), (_M_den).end(), (_M_den).begin(), __sum); 
# 3045
__detail::__normalize((_M_cp).begin(), (_M_cp).end(), (_M_cp).begin(), __sum); 
# 3047
__detail::__normalize((_M_m).begin(), (_M_m).end(), (_M_m).begin(), __sum); 
# 3050
(_M_cp)[(_M_cp).size() - (1)] = (1.0); 
# 3051
} 
# 3053
template< class _RealType> 
# 3054
template< class _InputIteratorB, class _InputIteratorW> 
# 3056
piecewise_linear_distribution< _RealType> ::param_type::param_type(_InputIteratorB __bbegin, _InputIteratorB 
# 3057
__bend, _InputIteratorW 
# 3058
__wbegin) : _M_int(), _M_den(), _M_cp(), _M_m() 
# 3060
{ 
# 3061
for (; __bbegin != __bend; (++__bbegin), (++__wbegin)) 
# 3062
{ 
# 3063
((_M_int).push_back(*__bbegin)); 
# 3064
((_M_den).push_back(*__wbegin)); 
# 3065
}  
# 3067
_M_initialize(); 
# 3068
} 
# 3070
template< class _RealType> 
# 3071
template< class _Func> 
# 3073
piecewise_linear_distribution< _RealType> ::param_type::param_type(initializer_list< _RealType>  __bl, _Func __fw) : _M_int(), _M_den(), _M_cp(), _M_m() 
# 3075
{ 
# 3076
((_M_int).reserve((__bl.size()))); 
# 3077
(_M_den).reserve((__bl.size())); 
# 3078
for (auto __biter = (__bl.begin()); __biter != (__bl.end()); ++__biter) 
# 3079
{ 
# 3080
((_M_int).push_back(*__biter)); 
# 3081
((_M_den).push_back(__fw(*__biter))); 
# 3082
}  
# 3084
_M_initialize(); 
# 3085
} 
# 3087
template< class _RealType> 
# 3088
template< class _Func> 
# 3090
piecewise_linear_distribution< _RealType> ::param_type::param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw) : _M_int(), _M_den(), _M_cp(), _M_m() 
# 3092
{ 
# 3093
const size_t __n = (__nw == (0)) ? 1 : __nw; 
# 3094
const _RealType __delta = (__xmax - __xmin) / __n; 
# 3096
((_M_int).reserve(__n + (1))); 
# 3097
(_M_den).reserve(__n + (1)); 
# 3098
for (size_t __k = (0); __k <= __nw; ++__k) 
# 3099
{ 
# 3100
((_M_int).push_back(__xmin + (__k * __delta))); 
# 3101
((_M_den).push_back(__fw(((_M_int)[__k]) + __delta))); 
# 3102
}  
# 3104
_M_initialize(); 
# 3105
} 
# 3107
template< class _RealType> 
# 3108
template< class _UniformRandomNumberGenerator> typename piecewise_linear_distribution< _RealType> ::result_type 
# 3111
piecewise_linear_distribution< _RealType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 3112
__param) 
# 3113
{ 
# 3115
__detail::_Adaptor< _UniformRandomNumberGenerator, double>  __aurng(__urng); 
# 3117
const double __p = __aurng(); 
# 3118
if (((__param._M_cp).empty())) { 
# 3119
return __p; }  
# 3121
auto __pos = std::lower_bound(((__param._M_cp).begin()), ((__param._M_cp).end()), __p); 
# 3123
const size_t __i = __pos - ((__param._M_cp).begin()); 
# 3125
const double __pref = (__i > (0)) ? (__param._M_cp)[__i - (1)] : (0.0); 
# 3127
const double __a = (0.5) * ((__param._M_m)[__i]); 
# 3128
const double __b = (__param._M_den)[__i]; 
# 3129
const double __cm = (__p - __pref); 
# 3131
_RealType __x = (__param._M_int)[__i]; 
# 3132
if (__a == (0)) { 
# 3133
__x += (__cm / __b); } else 
# 3135
{ 
# 3136
const double __d = ((__b * __b) + (((4.0) * __a) * __cm)); 
# 3137
__x += (((0.5) * (std::sqrt(__d) - __b)) / __a); 
# 3138
}  
# 3140
return __x; 
# 3141
} 
# 3143
template< class _RealType> 
# 3144
template< class _ForwardIterator, class 
# 3145
_UniformRandomNumberGenerator> void 
# 3148
piecewise_linear_distribution< _RealType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 3149
__urng, const param_type &
# 3150
__param) 
# 3151
{ 
# 3154
while (__f != __t) { 
# 3155
(*(__f++)) = (this->operator()(__urng, __param)); }  
# 3156
} 
# 3158
template< class _RealType, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 3160
operator<<(basic_ostream< _CharT, _Traits>  &__os, const piecewise_linear_distribution< _RealType>  &
# 3161
__x) 
# 3162
{ 
# 3163
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 3164
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 3166
const typename basic_ostream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__os.flags()); 
# 3167
const _CharT __fill = (__os.fill()); 
# 3168
const streamsize __precision = (__os.precision()); 
# 3169
const _CharT __space = (__os.widen(' ')); 
# 3170
(__os.flags(__ios_base::scientific | __ios_base::left)); 
# 3171
(__os.fill(__space)); 
# 3172
(__os.precision(std::numeric_limits< _RealType> ::max_digits10)); 
# 3174
vector< _RealType>  __int = (__x.intervals()); 
# 3175
__os << ((__int.size()) - 1); 
# 3177
for (auto __xit = (__int.begin()); __xit != (__int.end()); ++__xit) { 
# 3178
(__os << __space) << (*__xit); }  
# 3180
vector< double>  __den = (__x.densities()); 
# 3181
for (auto __dit = __den.begin(); (__dit != (__den.end())); (++__dit)) { 
# 3182
(__os << __space) << (*__dit); }  
# 3184
(__os.flags(__flags)); 
# 3185
(__os.fill(__fill)); 
# 3186
(__os.precision(__precision)); 
# 3187
return __os; 
# 3188
} 
# 3190
template< class _RealType, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 3192
operator>>(basic_istream< _CharT, _Traits>  &__is, piecewise_linear_distribution< _RealType>  &
# 3193
__x) 
# 3194
{ 
# 3195
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 3196
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 3198
const typename basic_istream< _CharT, _Traits> ::ios_base::fmtflags __flags = (__is.flags()); 
# 3199
(__is.flags(__ios_base::dec | __ios_base::skipws)); 
# 3201
size_t __n; 
# 3202
__is >> __n; 
# 3204
vector< _RealType>  __int_vec; 
# 3205
(__int_vec.reserve(__n + (1))); 
# 3206
for (size_t __i = (0); __i <= __n; ++__i) 
# 3207
{ 
# 3208
_RealType __int; 
# 3209
__is >> __int; 
# 3210
(__int_vec.push_back(__int)); 
# 3211
}  
# 3213
vector< double>  __den_vec; 
# 3214
__den_vec.reserve(__n + (1)); 
# 3215
for (size_t __i = (0); __i <= __n; ++__i) 
# 3216
{ 
# 3217
double __den; 
# 3218
__is >> __den; 
# 3219
__den_vec.push_back(__den); 
# 3220
}  
# 3222
(__x.param(typename piecewise_linear_distribution< _RealType> ::param_type((__int_vec.begin()), (__int_vec.end()), __den_vec.begin()))); 
# 3225
(__is.flags(__flags)); 
# 3226
return __is; 
# 3227
} 
# 3230
template< class _IntType> 
# 3231
seed_seq::seed_seq(initializer_list< _IntType>  __il) 
# 3232
{ 
# 3233
for (auto __iter = (__il.begin()); __iter != (__il.end()); ++__iter) { 
# 3234
((_M_v).push_back(__detail::__mod< result_type, __detail::_Shift< unsigned, 32UL> ::__value> (*__iter))); }  
# 3236
} 
# 3238
template< class _InputIterator> 
# 3239
seed_seq::seed_seq(_InputIterator __begin, _InputIterator __end) 
# 3240
{ 
# 3241
for (_InputIterator __iter = __begin; __iter != __end; ++__iter) { 
# 3242
((_M_v).push_back(__detail::__mod< result_type, __detail::_Shift< unsigned, 32UL> ::__value> (*__iter))); }  
# 3244
} 
# 3246
template< class _RandomAccessIterator> void 
# 3248
seed_seq::generate(_RandomAccessIterator __begin, _RandomAccessIterator 
# 3249
__end) 
# 3250
{ 
# 3252
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _Type; 
# 3254
if (__begin == __end) { 
# 3255
return; }  
# 3257
std::fill(__begin, __end, (_Type)2341178251U); 
# 3259
const size_t __n = __end - __begin; 
# 3260
const size_t __s = (_M_v).size(); 
# 3261
const size_t __t = ((__n >= (623)) ? 11 : ((__n >= (68)) ? 7 : ((__n >= (39)) ? 5 : ((__n >= (7)) ? 3 : ((__n - (1)) / (2)))))); 
# 3266
const size_t __p = ((__n - __t) / (2)); 
# 3267
const size_t __q = (__p + __t); 
# 3268
const size_t __m = std::max((size_t)(__s + (1)), __n); 
# 3270
for (size_t __k = (0); __k < __m; ++__k) 
# 3271
{ 
# 3272
_Type __arg = ((__begin[__k % __n]) ^ (__begin[(__k + __p) % __n])) ^ (__begin[(__k - (1)) % __n]); 
# 3275
_Type __r1 = __arg ^ (__arg >> 27); 
# 3276
__r1 = __detail::__mod< typename iterator_traits< _RandomAccessIterator> ::value_type, __detail::_Shift< typename iterator_traits< _RandomAccessIterator> ::value_type, 32UL> ::__value> (1664525U * __r1); 
# 3278
_Type __r2 = __r1; 
# 3279
if (__k == (0)) { 
# 3280
__r2 += __s; } else { 
# 3281
if (__k <= __s) { 
# 3282
__r2 += ((__k % __n) + ((_M_v)[__k - (1)])); } else { 
# 3284
__r2 += (__k % __n); }  }  
# 3285
__r2 = __detail::__mod< typename iterator_traits< _RandomAccessIterator> ::value_type, __detail::_Shift< typename iterator_traits< _RandomAccessIterator> ::value_type, 32UL> ::__value> (__r2); 
# 3287
(__begin[(__k + __p) % __n]) += __r1; 
# 3288
(__begin[(__k + __q) % __n]) += __r2; 
# 3289
(__begin[__k % __n]) = __r2; 
# 3290
}  
# 3292
for (size_t __k = __m; __k < (__m + __n); ++__k) 
# 3293
{ 
# 3294
_Type __arg = ((__begin[__k % __n]) + (__begin[(__k + __p) % __n])) + (__begin[(__k - (1)) % __n]); 
# 3297
_Type __r3 = __arg ^ (__arg >> 27); 
# 3298
__r3 = __detail::__mod< typename iterator_traits< _RandomAccessIterator> ::value_type, __detail::_Shift< typename iterator_traits< _RandomAccessIterator> ::value_type, 32UL> ::__value> (1566083941U * __r3); 
# 3300
_Type __r4 = __r3 - (__k % __n); 
# 3301
__r4 = __detail::__mod< typename iterator_traits< _RandomAccessIterator> ::value_type, __detail::_Shift< typename iterator_traits< _RandomAccessIterator> ::value_type, 32UL> ::__value> (__r4); 
# 3303
(__begin[(__k + __p) % __n]) ^= __r3; 
# 3304
(__begin[(__k + __q) % __n]) ^= __r4; 
# 3305
(__begin[__k % __n]) = __r4; 
# 3306
}  
# 3307
} 
# 3309
template< class _RealType, size_t __bits, class 
# 3310
_UniformRandomNumberGenerator> _RealType 
# 3312
generate_canonical(_UniformRandomNumberGenerator &__urng) 
# 3313
{ 
# 3314
static_assert((std::is_floating_point< _RealType> ::value), "template argument not a floating point type");
# 3317
const size_t __b = std::min(static_cast< size_t>(std::numeric_limits< _RealType> ::digits), __bits); 
# 3320
const long double __r = ((static_cast< long double>((__urng.max()))) - (static_cast< long double>((__urng.min())))) + (1.0L); 
# 3322
const size_t __log2r = std::log(__r) / std::log((2.0L)); 
# 3323
size_t __k = std::max< size_t> (1UL, ((__b + __log2r) - 1UL) / __log2r); 
# 3324
_RealType __sum = ((_RealType)0); 
# 3325
_RealType __tmp = ((_RealType)1); 
# 3326
for (; __k != (0); --__k) 
# 3327
{ 
# 3328
__sum += (((_RealType)(__urng() - (__urng.min()))) * __tmp); 
# 3329
__tmp *= __r; 
# 3330
}  
# 3331
return __sum / __tmp; 
# 3332
} 
# 3335
}
# 71 "/usr/include/c++/5/bits/stl_algo.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 76
template< class _Iterator, class _Compare> void 
# 78
__move_median_to_first(_Iterator __result, _Iterator __a, _Iterator __b, _Iterator 
# 79
__c, _Compare __comp) 
# 80
{ 
# 81
if (__comp(__a, __b)) 
# 82
{ 
# 83
if (__comp(__b, __c)) { 
# 84
std::iter_swap(__result, __b); } else { 
# 85
if (__comp(__a, __c)) { 
# 86
std::iter_swap(__result, __c); } else { 
# 88
std::iter_swap(__result, __a); }  }  
# 89
} else { 
# 90
if (__comp(__a, __c)) { 
# 91
std::iter_swap(__result, __a); } else { 
# 92
if (__comp(__b, __c)) { 
# 93
std::iter_swap(__result, __c); } else { 
# 95
std::iter_swap(__result, __b); }  }  }  
# 96
} 
# 99
template< class _InputIterator, class _Predicate> inline _InputIterator 
# 101
__find_if(_InputIterator __first, _InputIterator __last, _Predicate 
# 102
__pred, input_iterator_tag) 
# 103
{ 
# 104
while ((__first != __last) && (!__pred(__first))) { 
# 105
++__first; }  
# 106
return __first; 
# 107
} 
# 110
template< class _RandomAccessIterator, class _Predicate> _RandomAccessIterator 
# 112
__find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate 
# 113
__pred, random_access_iterator_tag) 
# 114
{ 
# 116
typename iterator_traits< _RandomAccessIterator> ::difference_type __trip_count = (__last - __first) >> 2; 
# 118
for (; __trip_count > 0; --__trip_count) 
# 119
{ 
# 120
if (__pred(__first)) { 
# 121
return __first; }  
# 122
++__first; 
# 124
if (__pred(__first)) { 
# 125
return __first; }  
# 126
++__first; 
# 128
if (__pred(__first)) { 
# 129
return __first; }  
# 130
++__first; 
# 132
if (__pred(__first)) { 
# 133
return __first; }  
# 134
++__first; 
# 135
}  
# 137
switch (__last - __first) 
# 138
{ 
# 139
case 3:  
# 140
if (__pred(__first)) { 
# 141
return __first; }  
# 142
++__first; 
# 143
case 2:  
# 144
if (__pred(__first)) { 
# 145
return __first; }  
# 146
++__first; 
# 147
case 1:  
# 148
if (__pred(__first)) { 
# 149
return __first; }  
# 150
++__first; 
# 151
case 0:  
# 152
default:  
# 153
return __last; 
# 154
}  
# 155
} 
# 157
template< class _Iterator, class _Predicate> inline _Iterator 
# 159
__find_if(_Iterator __first, _Iterator __last, _Predicate __pred) 
# 160
{ 
# 161
return __find_if(__first, __last, __pred, std::__iterator_category(__first)); 
# 163
} 
# 166
template< class _InputIterator, class _Predicate> inline _InputIterator 
# 168
__find_if_not(_InputIterator __first, _InputIterator __last, _Predicate 
# 169
__pred) 
# 170
{ 
# 171
return std::__find_if(__first, __last, __gnu_cxx::__ops::__negate(__pred), std::__iterator_category(__first)); 
# 174
} 
# 179
template< class _InputIterator, class _Predicate, class _Distance> _InputIterator 
# 181
__find_if_not_n(_InputIterator __first, _Distance &__len, _Predicate __pred) 
# 182
{ 
# 183
for (; __len; (--__len), (++__first)) { 
# 184
if (!__pred(__first)) { 
# 185
break; }  }  
# 186
return __first; 
# 187
} 
# 202 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 203
_BinaryPredicate> _ForwardIterator1 
# 205
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 206
__first2, _ForwardIterator2 __last2, _BinaryPredicate 
# 207
__predicate) 
# 208
{ 
# 210
if ((__first1 == __last1) || (__first2 == __last2)) { 
# 211
return __first1; }  
# 214
_ForwardIterator2 __p1(__first2); 
# 215
if ((++__p1) == __last2) { 
# 216
return std::__find_if(__first1, __last1, __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2)); }  
# 220
_ForwardIterator2 __p; 
# 221
_ForwardIterator1 __current = __first1; 
# 223
for (; ;) 
# 224
{ 
# 225
__first1 = std::__find_if(__first1, __last1, __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2)); 
# 229
if (__first1 == __last1) { 
# 230
return __last1; }  
# 232
__p = __p1; 
# 233
__current = __first1; 
# 234
if ((++__current) == __last1) { 
# 235
return __last1; }  
# 237
while (__predicate(__current, __p)) 
# 238
{ 
# 239
if ((++__p) == __last2) { 
# 240
return __first1; }  
# 241
if ((++__current) == __last1) { 
# 242
return __last1; }  
# 243
}  
# 244
++__first1; 
# 245
}  
# 246
return __first1; 
# 247
} 
# 254
template< class _ForwardIterator, class _Integer, class 
# 255
_UnaryPredicate> _ForwardIterator 
# 257
__search_n_aux(_ForwardIterator __first, _ForwardIterator __last, _Integer 
# 258
__count, _UnaryPredicate __unary_pred, forward_iterator_tag) 
# 260
{ 
# 261
__first = std::__find_if(__first, __last, __unary_pred); 
# 262
while (__first != __last) 
# 263
{ 
# 265
typename iterator_traits< _ForwardIterator> ::difference_type __n = __count; 
# 266
_ForwardIterator __i = __first; 
# 267
++__i; 
# 268
while ((__i != __last) && (__n != 1) && __unary_pred(__i)) 
# 269
{ 
# 270
++__i; 
# 271
--__n; 
# 272
}  
# 273
if (__n == 1) { 
# 274
return __first; }  
# 275
if (__i == __last) { 
# 276
return __last; }  
# 277
__first = std::__find_if(++__i, __last, __unary_pred); 
# 278
}  
# 279
return __last; 
# 280
} 
# 286
template< class _RandomAccessIter, class _Integer, class 
# 287
_UnaryPredicate> _RandomAccessIter 
# 289
__search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last, _Integer 
# 290
__count, _UnaryPredicate __unary_pred, random_access_iterator_tag) 
# 292
{ 
# 294
typedef typename iterator_traits< _RandomAccessIter> ::difference_type _DistanceType; 
# 296
_DistanceType __tailSize = __last - __first; 
# 297
_DistanceType __remainder = __count; 
# 299
while (__remainder <= __tailSize) 
# 300
{ 
# 301
__first += __remainder; 
# 302
__tailSize -= __remainder; 
# 305
_RandomAccessIter __backTrack = __first; 
# 306
while (__unary_pred(--__backTrack)) 
# 307
{ 
# 308
if ((--__remainder) == 0) { 
# 309
return __first - __count; }  
# 310
}  
# 311
__remainder = ((__count + 1) - (__first - __backTrack)); 
# 312
}  
# 313
return __last; 
# 314
} 
# 316
template< class _ForwardIterator, class _Integer, class 
# 317
_UnaryPredicate> _ForwardIterator 
# 319
__search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer 
# 320
__count, _UnaryPredicate 
# 321
__unary_pred) 
# 322
{ 
# 323
if (__count <= 0) { 
# 324
return __first; }  
# 326
if (__count == 1) { 
# 327
return std::__find_if(__first, __last, __unary_pred); }  
# 329
return std::__search_n_aux(__first, __last, __count, __unary_pred, std::__iterator_category(__first)); 
# 331
} 
# 334
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 335
_BinaryPredicate> _ForwardIterator1 
# 337
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 338
__first2, _ForwardIterator2 __last2, forward_iterator_tag, forward_iterator_tag, _BinaryPredicate 
# 340
__comp) 
# 341
{ 
# 342
if (__first2 == __last2) { 
# 343
return __last1; }  
# 345
_ForwardIterator1 __result = __last1; 
# 346
while (1) 
# 347
{ 
# 348
_ForwardIterator1 __new_result = std::__search(__first1, __last1, __first2, __last2, __comp); 
# 350
if (__new_result == __last1) { 
# 351
return __result; } else 
# 353
{ 
# 354
__result = __new_result; 
# 355
__first1 = __new_result; 
# 356
++__first1; 
# 357
}  
# 358
}  
# 359
} 
# 362
template< class _BidirectionalIterator1, class _BidirectionalIterator2, class 
# 363
_BinaryPredicate> _BidirectionalIterator1 
# 365
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 
# 366
__last1, _BidirectionalIterator2 
# 367
__first2, _BidirectionalIterator2 
# 368
__last2, bidirectional_iterator_tag, bidirectional_iterator_tag, _BinaryPredicate 
# 370
__comp) 
# 371
{ 
# 378
typedef reverse_iterator< _BidirectionalIterator1>  _RevIterator1; 
# 379
typedef reverse_iterator< _BidirectionalIterator2>  _RevIterator2; 
# 381
_RevIterator1 __rlast1(__first1); 
# 382
_RevIterator2 __rlast2(__first2); 
# 383
_RevIterator1 __rresult = std::__search(((_RevIterator1)(__last1)), __rlast1, ((_RevIterator2)(__last2)), __rlast2, __comp); 
# 387
if (__rresult == __rlast1) { 
# 388
return __last1; } else 
# 390
{ 
# 391
_BidirectionalIterator1 __result = (__rresult.base()); 
# 392
std::advance(__result, -std::distance(__first2, __last2)); 
# 393
return __result; 
# 394
}  
# 395
} 
# 423 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator1 
# 425
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 426
__first2, _ForwardIterator2 __last2) 
# 427
{ 
# 434
; 
# 435
; 
# 437
return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2), __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 441
} 
# 471 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 472
_BinaryPredicate> inline _ForwardIterator1 
# 474
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 475
__first2, _ForwardIterator2 __last2, _BinaryPredicate 
# 476
__comp) 
# 477
{ 
# 484
; 
# 485
; 
# 487
return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2), __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 491
} 
# 506 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline bool 
# 508
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) 
# 509
{ return __last == std::find_if_not(__first, __last, __pred); } 
# 523 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline bool 
# 525
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) 
# 526
{ return __last == std::find_if(__first, __last, __pred); } 
# 541 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline bool 
# 543
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) 
# 544
{ return !std::none_of(__first, __last, __pred); } 
# 556 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline _InputIterator 
# 558
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate 
# 559
__pred) 
# 560
{ 
# 565
; 
# 566
return std::__find_if_not(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 568
} 
# 580 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline bool 
# 582
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate 
# 583
__pred) 
# 584
{ 
# 585
__first = std::find_if_not(__first, __last, __pred); 
# 586
return std::none_of(__first, __last, __pred); 
# 587
} 
# 598 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Predicate> _ForwardIterator 
# 600
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 601
__pred) 
# 602
{ 
# 609
; 
# 612
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 614
_DistanceType __len = std::distance(__first, __last); 
# 615
_DistanceType __half; 
# 616
_ForwardIterator __middle; 
# 618
while (__len > 0) 
# 619
{ 
# 620
__half = (__len >> 1); 
# 621
__middle = __first; 
# 622
std::advance(__middle, __half); 
# 623
if (__pred(*__middle)) 
# 624
{ 
# 625
__first = __middle; 
# 626
++__first; 
# 627
__len = ((__len - __half) - 1); 
# 628
} else { 
# 630
__len = __half; }  
# 631
}  
# 632
return __first; 
# 633
} 
# 636
template< class _InputIterator, class _OutputIterator, class 
# 637
_Predicate> _OutputIterator 
# 639
__remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 640
__result, _Predicate __pred) 
# 641
{ 
# 642
for (; __first != __last; ++__first) { 
# 643
if (!__pred(__first)) 
# 644
{ 
# 645
(*__result) = (*__first); 
# 646
++__result; 
# 647
}  }  
# 648
return __result; 
# 649
} 
# 665 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class _Tp> inline _OutputIterator 
# 667
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 668
__result, const _Tp &__value) 
# 669
{ 
# 676
; 
# 678
return std::__remove_copy_if(__first, __last, __result, __gnu_cxx::__ops::__iter_equals_val(__value)); 
# 680
} 
# 697 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 698
_Predicate> inline _OutputIterator 
# 700
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 701
__result, _Predicate __pred) 
# 702
{ 
# 709
; 
# 711
return std::__remove_copy_if(__first, __last, __result, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 713
} 
# 731 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 732
_Predicate> _OutputIterator 
# 734
copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 735
__result, _Predicate __pred) 
# 736
{ 
# 743
; 
# 745
for (; __first != __last; ++__first) { 
# 746
if (__pred(*__first)) 
# 747
{ 
# 748
(*__result) = (*__first); 
# 749
++__result; 
# 750
}  }  
# 751
return __result; 
# 752
} 
# 754
template< class _InputIterator, class _Size, class _OutputIterator> _OutputIterator 
# 756
__copy_n(_InputIterator __first, _Size __n, _OutputIterator 
# 757
__result, input_iterator_tag) 
# 758
{ 
# 759
if (__n > 0) 
# 760
{ 
# 761
while (true) 
# 762
{ 
# 763
(*__result) = (*__first); 
# 764
++__result; 
# 765
if ((--__n) > 0) { 
# 766
++__first; } else { 
# 768
break; }  
# 769
}  
# 770
}  
# 771
return __result; 
# 772
} 
# 774
template< class _RandomAccessIterator, class _Size, class 
# 775
_OutputIterator> inline _OutputIterator 
# 777
__copy_n(_RandomAccessIterator __first, _Size __n, _OutputIterator 
# 778
__result, random_access_iterator_tag) 
# 779
{ return std::copy(__first, __first + __n, __result); } 
# 794 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Size, class _OutputIterator> inline _OutputIterator 
# 796
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result) 
# 797
{ 
# 803
return std::__copy_n(__first, __n, __result, std::__iterator_category(__first)); 
# 805
} 
# 822 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator1, class 
# 823
_OutputIterator2, class _Predicate> pair< _OutputIterator1, _OutputIterator2>  
# 825
partition_copy(_InputIterator __first, _InputIterator __last, _OutputIterator1 
# 826
__out_true, _OutputIterator2 __out_false, _Predicate 
# 827
__pred) 
# 828
{ 
# 837
; 
# 839
for (; __first != __last; ++__first) { 
# 840
if (__pred(*__first)) 
# 841
{ 
# 842
(*__out_true) = (*__first); 
# 843
++__out_true; 
# 844
} else 
# 846
{ 
# 847
(*__out_false) = (*__first); 
# 848
++__out_false; 
# 849
}  }  
# 851
return pair< _OutputIterator1, _OutputIterator2> (__out_true, __out_false); 
# 852
} 
# 855
template< class _ForwardIterator, class _Predicate> _ForwardIterator 
# 857
__remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 858
__pred) 
# 859
{ 
# 860
__first = std::__find_if(__first, __last, __pred); 
# 861
if (__first == __last) { 
# 862
return __first; }  
# 863
_ForwardIterator __result = __first; 
# 864
++__first; 
# 865
for (; __first != __last; ++__first) { 
# 866
if (!__pred(__first)) 
# 867
{ 
# 868
(*__result) = std::move(*__first); 
# 869
++__result; 
# 870
}  }  
# 871
return __result; 
# 872
} 
# 891 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp> inline _ForwardIterator 
# 893
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 894
__value) 
# 895
{ 
# 901
; 
# 903
return std::__remove_if(__first, __last, __gnu_cxx::__ops::__iter_equals_val(__value)); 
# 905
} 
# 924 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Predicate> inline _ForwardIterator 
# 926
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 927
__pred) 
# 928
{ 
# 934
; 
# 936
return std::__remove_if(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 938
} 
# 940
template< class _ForwardIterator, class _BinaryPredicate> _ForwardIterator 
# 942
__adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate 
# 943
__binary_pred) 
# 944
{ 
# 945
if (__first == __last) { 
# 946
return __last; }  
# 947
_ForwardIterator __next = __first; 
# 948
while ((++__next) != __last) 
# 949
{ 
# 950
if (__binary_pred(__first, __next)) { 
# 951
return __first; }  
# 952
__first = __next; 
# 953
}  
# 954
return __last; 
# 955
} 
# 957
template< class _ForwardIterator, class _BinaryPredicate> _ForwardIterator 
# 959
__unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate 
# 960
__binary_pred) 
# 961
{ 
# 963
__first = std::__adjacent_find(__first, __last, __binary_pred); 
# 964
if (__first == __last) { 
# 965
return __last; }  
# 968
_ForwardIterator __dest = __first; 
# 969
++__first; 
# 970
while ((++__first) != __last) { 
# 971
if (!__binary_pred(__dest, __first)) { 
# 972
(*(++__dest)) = std::move(*__first); }  }  
# 973
return ++__dest; 
# 974
} 
# 990 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator> inline _ForwardIterator 
# 992
unique(_ForwardIterator __first, _ForwardIterator __last) 
# 993
{ 
# 999
; 
# 1001
return std::__unique(__first, __last, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 1003
} 
# 1020 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _BinaryPredicate> inline _ForwardIterator 
# 1022
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate 
# 1023
__binary_pred) 
# 1024
{ 
# 1031
; 
# 1033
return std::__unique(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred)); 
# 1035
} 
# 1043
template< class _ForwardIterator, class _OutputIterator, class 
# 1044
_BinaryPredicate> _OutputIterator 
# 1046
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator 
# 1047
__result, _BinaryPredicate __binary_pred, forward_iterator_tag, output_iterator_tag) 
# 1049
{ 
# 1055
_ForwardIterator __next = __first; 
# 1056
(*__result) = (*__first); 
# 1057
while ((++__next) != __last) { 
# 1058
if (!__binary_pred(__first, __next)) 
# 1059
{ 
# 1060
__first = __next; 
# 1061
(*(++__result)) = (*__first); 
# 1062
}  }  
# 1063
return ++__result; 
# 1064
} 
# 1072
template< class _InputIterator, class _OutputIterator, class 
# 1073
_BinaryPredicate> _OutputIterator 
# 1075
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 1076
__result, _BinaryPredicate __binary_pred, input_iterator_tag, output_iterator_tag) 
# 1078
{ 
# 1084
typename iterator_traits< _InputIterator> ::value_type __value = *__first; 
# 1086
__decltype((__gnu_cxx::__ops::__iter_comp_val(__binary_pred))) __rebound_pred = __gnu_cxx::__ops::__iter_comp_val(__binary_pred); 
# 1088
(*__result) = __value; 
# 1089
while ((++__first) != __last) { 
# 1090
if (!__rebound_pred(__first, __value)) 
# 1091
{ 
# 1092
__value = (*__first); 
# 1093
(*(++__result)) = __value; 
# 1094
}  }  
# 1095
return ++__result; 
# 1096
} 
# 1104
template< class _InputIterator, class _ForwardIterator, class 
# 1105
_BinaryPredicate> _ForwardIterator 
# 1107
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 1108
__result, _BinaryPredicate __binary_pred, input_iterator_tag, forward_iterator_tag) 
# 1110
{ 
# 1115
(*__result) = (*__first); 
# 1116
while ((++__first) != __last) { 
# 1117
if (!__binary_pred(__result, __first)) { 
# 1118
(*(++__result)) = (*__first); }  }  
# 1119
return ++__result; 
# 1120
} 
# 1127
template< class _BidirectionalIterator> void 
# 1129
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag) 
# 1131
{ 
# 1132
while (true) { 
# 1133
if ((__first == __last) || (__first == (--__last))) { 
# 1134
return; } else 
# 1136
{ 
# 1137
std::iter_swap(__first, __last); 
# 1138
++__first; 
# 1139
}  }  
# 1140
} 
# 1147
template< class _RandomAccessIterator> void 
# 1149
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag) 
# 1151
{ 
# 1152
if (__first == __last) { 
# 1153
return; }  
# 1154
--__last; 
# 1155
while (__first < __last) 
# 1156
{ 
# 1157
std::iter_swap(__first, __last); 
# 1158
++__first; 
# 1159
--__last; 
# 1160
}  
# 1161
} 
# 1175 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _BidirectionalIterator> inline void 
# 1177
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last) 
# 1178
{ 
# 1182
; 
# 1183
std::__reverse(__first, __last, std::__iterator_category(__first)); 
# 1184
} 
# 1202 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _BidirectionalIterator, class _OutputIterator> _OutputIterator 
# 1204
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator 
# 1205
__result) 
# 1206
{ 
# 1212
; 
# 1214
while (__first != __last) 
# 1215
{ 
# 1216
--__last; 
# 1217
(*__result) = (*__last); 
# 1218
++__result; 
# 1219
}  
# 1220
return __result; 
# 1221
} 
# 1227
template< class _EuclideanRingElement> _EuclideanRingElement 
# 1229
__gcd(_EuclideanRingElement __m, _EuclideanRingElement __n) 
# 1230
{ 
# 1231
while (__n != 0) 
# 1232
{ 
# 1233
_EuclideanRingElement __t = __m % __n; 
# 1234
__m = __n; 
# 1235
__n = __t; 
# 1236
}  
# 1237
return __m; 
# 1238
} 
# 1240
inline namespace _V2 { 
# 1244
template< class _ForwardIterator> _ForwardIterator 
# 1246
__rotate(_ForwardIterator __first, _ForwardIterator 
# 1247
__middle, _ForwardIterator 
# 1248
__last, forward_iterator_tag) 
# 1250
{ 
# 1251
if (__first == __middle) { 
# 1252
return __last; } else { 
# 1253
if (__last == __middle) { 
# 1254
return __first; }  }  
# 1256
_ForwardIterator __first2 = __middle; 
# 1257
do 
# 1258
{ 
# 1259
std::iter_swap(__first, __first2); 
# 1260
++__first; 
# 1261
++__first2; 
# 1262
if (__first == __middle) { 
# 1263
__middle = __first2; }  
# 1264
} 
# 1265
while (__first2 != __last); 
# 1267
_ForwardIterator __ret = __first; 
# 1269
__first2 = __middle; 
# 1271
while (__first2 != __last) 
# 1272
{ 
# 1273
std::iter_swap(__first, __first2); 
# 1274
++__first; 
# 1275
++__first2; 
# 1276
if (__first == __middle) { 
# 1277
__middle = __first2; } else { 
# 1278
if (__first2 == __last) { 
# 1279
__first2 = __middle; }  }  
# 1280
}  
# 1281
return __ret; 
# 1282
} 
# 1285
template< class _BidirectionalIterator> _BidirectionalIterator 
# 1287
__rotate(_BidirectionalIterator __first, _BidirectionalIterator 
# 1288
__middle, _BidirectionalIterator 
# 1289
__last, bidirectional_iterator_tag) 
# 1291
{ 
# 1296
if (__first == __middle) { 
# 1297
return __last; } else { 
# 1298
if (__last == __middle) { 
# 1299
return __first; }  }  
# 1301
std::__reverse(__first, __middle, bidirectional_iterator_tag()); 
# 1302
std::__reverse(__middle, __last, bidirectional_iterator_tag()); 
# 1304
while ((__first != __middle) && (__middle != __last)) 
# 1305
{ 
# 1306
std::iter_swap(__first, --__last); 
# 1307
++__first; 
# 1308
}  
# 1310
if (__first == __middle) 
# 1311
{ 
# 1312
std::__reverse(__middle, __last, bidirectional_iterator_tag()); 
# 1313
return __last; 
# 1314
} else 
# 1316
{ 
# 1317
std::__reverse(__first, __middle, bidirectional_iterator_tag()); 
# 1318
return __first; 
# 1319
}  
# 1320
} 
# 1323
template< class _RandomAccessIterator> _RandomAccessIterator 
# 1325
__rotate(_RandomAccessIterator __first, _RandomAccessIterator 
# 1326
__middle, _RandomAccessIterator 
# 1327
__last, random_access_iterator_tag) 
# 1329
{ 
# 1334
if (__first == __middle) { 
# 1335
return __last; } else { 
# 1336
if (__last == __middle) { 
# 1337
return __first; }  }  
# 1340
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _Distance; 
# 1342
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 1344
_Distance __n = __last - __first; 
# 1345
_Distance __k = __middle - __first; 
# 1347
if (__k == (__n - __k)) 
# 1348
{ 
# 1349
std::swap_ranges(__first, __middle, __middle); 
# 1350
return __middle; 
# 1351
}  
# 1353
_RandomAccessIterator __p = __first; 
# 1354
_RandomAccessIterator __ret = __first + (__last - __middle); 
# 1356
for (; ;) 
# 1357
{ 
# 1358
if (__k < (__n - __k)) 
# 1359
{ 
# 1360
if (__is_pod(_ValueType) && (__k == 1)) 
# 1361
{ 
# 1362
_ValueType __t = std::move(*__p); 
# 1363
std::move(__p + 1, __p + __n, __p); 
# 1364
(*((__p + __n) - 1)) = std::move(__t); 
# 1365
return __ret; 
# 1366
}  
# 1367
_RandomAccessIterator __q = __p + __k; 
# 1368
for (_Distance __i = (0); __i < (__n - __k); ++__i) 
# 1369
{ 
# 1370
std::iter_swap(__p, __q); 
# 1371
++__p; 
# 1372
++__q; 
# 1373
}  
# 1374
__n %= __k; 
# 1375
if (__n == 0) { 
# 1376
return __ret; }  
# 1377
std::swap(__n, __k); 
# 1378
__k = (__n - __k); 
# 1379
} else 
# 1381
{ 
# 1382
__k = (__n - __k); 
# 1383
if (__is_pod(_ValueType) && (__k == 1)) 
# 1384
{ 
# 1385
_ValueType __t = std::move(*((__p + __n) - 1)); 
# 1386
std::move_backward(__p, (__p + __n) - 1, __p + __n); 
# 1387
(*__p) = std::move(__t); 
# 1388
return __ret; 
# 1389
}  
# 1390
_RandomAccessIterator __q = __p + __n; 
# 1391
__p = (__q - __k); 
# 1392
for (_Distance __i = (0); __i < (__n - __k); ++__i) 
# 1393
{ 
# 1394
--__p; 
# 1395
--__q; 
# 1396
std::iter_swap(__p, __q); 
# 1397
}  
# 1398
__n %= __k; 
# 1399
if (__n == 0) { 
# 1400
return __ret; }  
# 1401
std::swap(__n, __k); 
# 1402
}  
# 1403
}  
# 1404
} 
# 1429 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator> inline _ForwardIterator 
# 1431
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator 
# 1432
__last) 
# 1433
{ 
# 1437
; 
# 1438
; 
# 1440
return std::__rotate(__first, __middle, __last, std::__iterator_category(__first)); 
# 1442
} 
# 1444
}
# 1466 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _OutputIterator> inline _OutputIterator 
# 1468
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator 
# 1469
__last, _OutputIterator __result) 
# 1470
{ 
# 1475
; 
# 1476
; 
# 1478
return std::copy(__first, __middle, std::copy(__middle, __last, __result)); 
# 1480
} 
# 1483
template< class _ForwardIterator, class _Predicate> _ForwardIterator 
# 1485
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 1486
__pred, forward_iterator_tag) 
# 1487
{ 
# 1488
if (__first == __last) { 
# 1489
return __first; }  
# 1491
while (__pred(*__first)) { 
# 1492
if ((++__first) == __last) { 
# 1493
return __first; }  }  
# 1495
_ForwardIterator __next = __first; 
# 1497
while ((++__next) != __last) { 
# 1498
if (__pred(*__next)) 
# 1499
{ 
# 1500
std::iter_swap(__first, __next); 
# 1501
++__first; 
# 1502
}  }  
# 1504
return __first; 
# 1505
} 
# 1508
template< class _BidirectionalIterator, class _Predicate> _BidirectionalIterator 
# 1510
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate 
# 1511
__pred, bidirectional_iterator_tag) 
# 1512
{ 
# 1513
while (true) 
# 1514
{ 
# 1515
while (true) { 
# 1516
if (__first == __last) { 
# 1517
return __first; } else { 
# 1518
if (__pred(*__first)) { 
# 1519
++__first; } else { 
# 1521
break; }  }  }  
# 1522
--__last; 
# 1523
while (true) { 
# 1524
if (__first == __last) { 
# 1525
return __first; } else { 
# 1526
if (!((bool)__pred(*__last))) { 
# 1527
--__last; } else { 
# 1529
break; }  }  }  
# 1530
std::iter_swap(__first, __last); 
# 1531
++__first; 
# 1532
}  
# 1533
} 
# 1543 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Pointer, class _Predicate, class 
# 1544
_Distance> _ForwardIterator 
# 1546
__stable_partition_adaptive(_ForwardIterator __first, _ForwardIterator 
# 1547
__last, _Predicate 
# 1548
__pred, _Distance __len, _Pointer 
# 1549
__buffer, _Distance 
# 1550
__buffer_size) 
# 1551
{ 
# 1552
if (__len == 1) { 
# 1553
return __first; }  
# 1555
if (__len <= __buffer_size) 
# 1556
{ 
# 1557
_ForwardIterator __result1 = __first; 
# 1558
_Pointer __result2 = __buffer; 
# 1563
(*__result2) = std::move(*__first); 
# 1564
++__result2; 
# 1565
++__first; 
# 1566
for (; __first != __last; ++__first) { 
# 1567
if (__pred(__first)) 
# 1568
{ 
# 1569
(*__result1) = std::move(*__first); 
# 1570
++__result1; 
# 1571
} else 
# 1573
{ 
# 1574
(*__result2) = std::move(*__first); 
# 1575
++__result2; 
# 1576
}  }  
# 1578
std::move(__buffer, __result2, __result1); 
# 1579
return __result1; 
# 1580
}  
# 1582
_ForwardIterator __middle = __first; 
# 1583
std::advance(__middle, __len / 2); 
# 1584
_ForwardIterator __left_split = std::__stable_partition_adaptive(__first, __middle, __pred, __len / 2, __buffer, __buffer_size); 
# 1591
_Distance __right_len = __len - (__len / 2); 
# 1592
_ForwardIterator __right_split = std::__find_if_not_n(__middle, __right_len, __pred); 
# 1595
if (__right_len) { 
# 1596
__right_split = std::__stable_partition_adaptive(__right_split, __last, __pred, __right_len, __buffer, __buffer_size); }  
# 1601
std::rotate(__left_split, __middle, __right_split); 
# 1602
std::advance(__left_split, std::distance(__middle, __right_split)); 
# 1603
return __left_split; 
# 1604
} 
# 1606
template< class _ForwardIterator, class _Predicate> _ForwardIterator 
# 1608
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 1609
__pred) 
# 1610
{ 
# 1611
__first = std::__find_if_not(__first, __last, __pred); 
# 1613
if (__first == __last) { 
# 1614
return __first; }  
# 1617
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 1619
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 1621
_Temporary_buffer< _ForwardIterator, typename iterator_traits< _ForwardIterator> ::value_type>  __buf(__first, __last); 
# 1622
return std::__stable_partition_adaptive(__first, __last, __pred, (_DistanceType)(__buf.requested_size()), (__buf.begin()), (_DistanceType)(__buf.size())); 
# 1627
} 
# 1646 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Predicate> inline _ForwardIterator 
# 1648
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 1649
__pred) 
# 1650
{ 
# 1656
; 
# 1658
return std::__stable_partition(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 1660
} 
# 1663
template< class _RandomAccessIterator, class _Compare> void 
# 1665
__heap_select(_RandomAccessIterator __first, _RandomAccessIterator 
# 1666
__middle, _RandomAccessIterator 
# 1667
__last, _Compare __comp) 
# 1668
{ 
# 1669
std::__make_heap(__first, __middle, __comp); 
# 1670
for (_RandomAccessIterator __i = __middle; __i < __last; ++__i) { 
# 1671
if (__comp(__i, __first)) { 
# 1672
std::__pop_heap(__first, __middle, __i, __comp); }  }  
# 1673
} 
# 1677
template< class _InputIterator, class _RandomAccessIterator, class 
# 1678
_Compare> _RandomAccessIterator 
# 1680
__partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator 
# 1681
__result_first, _RandomAccessIterator 
# 1682
__result_last, _Compare 
# 1683
__comp) 
# 1684
{ 
# 1686
typedef typename iterator_traits< _InputIterator> ::value_type _InputValueType; 
# 1687
typedef iterator_traits< _RandomAccessIterator>  _RItTraits; 
# 1688
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 1690
if (__result_first == __result_last) { 
# 1691
return __result_last; }  
# 1692
_RandomAccessIterator __result_real_last = __result_first; 
# 1693
while ((__first != __last) && (__result_real_last != __result_last)) 
# 1694
{ 
# 1695
(*__result_real_last) = (*__first); 
# 1696
++__result_real_last; 
# 1697
++__first; 
# 1698
}  
# 1700
std::__make_heap(__result_first, __result_real_last, __comp); 
# 1701
while (__first != __last) 
# 1702
{ 
# 1703
if (__comp(__first, __result_first)) { 
# 1704
std::__adjust_heap(__result_first, (_DistanceType)0, (_DistanceType)(__result_real_last - __result_first), (_InputValueType)(*__first), __comp); }  
# 1708
++__first; 
# 1709
}  
# 1710
std::__sort_heap(__result_first, __result_real_last, __comp); 
# 1711
return __result_real_last; 
# 1712
} 
# 1732 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _RandomAccessIterator> inline _RandomAccessIterator 
# 1734
partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator 
# 1735
__result_first, _RandomAccessIterator 
# 1736
__result_last) 
# 1737
{ 
# 1739
typedef typename iterator_traits< _InputIterator> ::value_type _InputValueType; 
# 1741
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _OutputValueType; 
# 1743
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 1752
; 
# 1753
; 
# 1755
return std::__partial_sort_copy(__first, __last, __result_first, __result_last, __gnu_cxx::__ops::__iter_less_iter()); 
# 1758
} 
# 1780 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _RandomAccessIterator, class 
# 1781
_Compare> inline _RandomAccessIterator 
# 1783
partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator 
# 1784
__result_first, _RandomAccessIterator 
# 1785
__result_last, _Compare 
# 1786
__comp) 
# 1787
{ 
# 1789
typedef typename iterator_traits< _InputIterator> ::value_type _InputValueType; 
# 1791
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _OutputValueType; 
# 1793
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 1805
; 
# 1806
; 
# 1808
return std::__partial_sort_copy(__first, __last, __result_first, __result_last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 1811
} 
# 1814
template< class _RandomAccessIterator, class _Compare> void 
# 1816
__unguarded_linear_insert(_RandomAccessIterator __last, _Compare 
# 1817
__comp) 
# 1818
{ 
# 1820
typename iterator_traits< _RandomAccessIterator> ::value_type __val = std::move(*__last); 
# 1821
_RandomAccessIterator __next = __last; 
# 1822
--__next; 
# 1823
while (__comp(__val, __next)) 
# 1824
{ 
# 1825
(*__last) = std::move(*__next); 
# 1826
__last = __next; 
# 1827
--__next; 
# 1828
}  
# 1829
(*__last) = std::move(__val); 
# 1830
} 
# 1833
template< class _RandomAccessIterator, class _Compare> void 
# 1835
__insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 1836
__last, _Compare __comp) 
# 1837
{ 
# 1838
if (__first == __last) { return; }  
# 1840
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) 
# 1841
{ 
# 1842
if (__comp(__i, __first)) 
# 1843
{ 
# 1845
typename iterator_traits< _RandomAccessIterator> ::value_type __val = std::move(*__i); 
# 1846
std::move_backward(__first, __i, __i + 1); 
# 1847
(*__first) = std::move(__val); 
# 1848
} else { 
# 1850
std::__unguarded_linear_insert(__i, __gnu_cxx::__ops::__val_comp_iter(__comp)); }  
# 1852
}  
# 1853
} 
# 1856
template< class _RandomAccessIterator, class _Compare> inline void 
# 1858
__unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 1859
__last, _Compare __comp) 
# 1860
{ 
# 1861
for (_RandomAccessIterator __i = __first; __i != __last; ++__i) { 
# 1862
std::__unguarded_linear_insert(__i, __gnu_cxx::__ops::__val_comp_iter(__comp)); }  
# 1864
} 
# 1870
enum { _S_threshold = 16}; 
# 1873
template< class _RandomAccessIterator, class _Compare> void 
# 1875
__final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 1876
__last, _Compare __comp) 
# 1877
{ 
# 1878
if ((__last - __first) > ((int)_S_threshold)) 
# 1879
{ 
# 1880
std::__insertion_sort(__first, __first + ((int)_S_threshold), __comp); 
# 1881
std::__unguarded_insertion_sort(__first + ((int)_S_threshold), __last, __comp); 
# 1883
} else { 
# 1885
std::__insertion_sort(__first, __last, __comp); }  
# 1886
} 
# 1889
template< class _RandomAccessIterator, class _Compare> _RandomAccessIterator 
# 1891
__unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator 
# 1892
__last, _RandomAccessIterator 
# 1893
__pivot, _Compare __comp) 
# 1894
{ 
# 1895
while (true) 
# 1896
{ 
# 1897
while (__comp(__first, __pivot)) { 
# 1898
++__first; }  
# 1899
--__last; 
# 1900
while (__comp(__pivot, __last)) { 
# 1901
--__last; }  
# 1902
if (!(__first < __last)) { 
# 1903
return __first; }  
# 1904
std::iter_swap(__first, __last); 
# 1905
++__first; 
# 1906
}  
# 1907
} 
# 1910
template< class _RandomAccessIterator, class _Compare> inline _RandomAccessIterator 
# 1912
__unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator 
# 1913
__last, _Compare __comp) 
# 1914
{ 
# 1915
_RandomAccessIterator __mid = __first + ((__last - __first) / 2); 
# 1916
std::__move_median_to_first(__first, __first + 1, __mid, __last - 1, __comp); 
# 1918
return std::__unguarded_partition(__first + 1, __last, __first, __comp); 
# 1919
} 
# 1921
template< class _RandomAccessIterator, class _Compare> inline void 
# 1923
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 1924
__middle, _RandomAccessIterator 
# 1925
__last, _Compare 
# 1926
__comp) 
# 1927
{ 
# 1928
std::__heap_select(__first, __middle, __last, __comp); 
# 1929
std::__sort_heap(__first, __middle, __comp); 
# 1930
} 
# 1933
template< class _RandomAccessIterator, class _Size, class _Compare> void 
# 1935
__introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator 
# 1936
__last, _Size 
# 1937
__depth_limit, _Compare __comp) 
# 1938
{ 
# 1939
while ((__last - __first) > ((int)_S_threshold)) 
# 1940
{ 
# 1941
if (__depth_limit == 0) 
# 1942
{ 
# 1943
std::__partial_sort(__first, __last, __last, __comp); 
# 1944
return; 
# 1945
}  
# 1946
--__depth_limit; 
# 1947
_RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp); 
# 1949
std::__introsort_loop(__cut, __last, __depth_limit, __comp); 
# 1950
__last = __cut; 
# 1951
}  
# 1952
} 
# 1956
template< class _RandomAccessIterator, class _Compare> inline void 
# 1958
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 1959
__comp) 
# 1960
{ 
# 1961
if (__first != __last) 
# 1962
{ 
# 1963
std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2, __comp); 
# 1966
std::__final_insertion_sort(__first, __last, __comp); 
# 1967
}  
# 1968
} 
# 1970
template< class _RandomAccessIterator, class _Size, class _Compare> void 
# 1972
__introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator 
# 1973
__last, _Size __depth_limit, _Compare 
# 1974
__comp) 
# 1975
{ 
# 1976
while ((__last - __first) > 3) 
# 1977
{ 
# 1978
if (__depth_limit == 0) 
# 1979
{ 
# 1980
std::__heap_select(__first, __nth + 1, __last, __comp); 
# 1982
std::iter_swap(__first, __nth); 
# 1983
return; 
# 1984
}  
# 1985
--__depth_limit; 
# 1986
_RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp); 
# 1988
if (__cut <= __nth) { 
# 1989
__first = __cut; } else { 
# 1991
__last = __cut; }  
# 1992
}  
# 1993
std::__insertion_sort(__first, __last, __comp); 
# 1994
} 
# 2016 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp, class _Compare> inline _ForwardIterator 
# 2018
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2019
__val, _Compare __comp) 
# 2020
{ 
# 2022
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 2029
; 
# 2031
return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp)); 
# 2033
} 
# 2035
template< class _ForwardIterator, class _Tp, class _Compare> _ForwardIterator 
# 2037
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2038
__val, _Compare __comp) 
# 2039
{ 
# 2041
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 2043
_DistanceType __len = std::distance(__first, __last); 
# 2045
while (__len > 0) 
# 2046
{ 
# 2047
_DistanceType __half = __len >> 1; 
# 2048
_ForwardIterator __middle = __first; 
# 2049
std::advance(__middle, __half); 
# 2050
if (__comp(__val, __middle)) { 
# 2051
__len = __half; } else 
# 2053
{ 
# 2054
__first = __middle; 
# 2055
++__first; 
# 2056
__len = ((__len - __half) - 1); 
# 2057
}  
# 2058
}  
# 2059
return __first; 
# 2060
} 
# 2073 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp> inline _ForwardIterator 
# 2075
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2076
__val) 
# 2077
{ 
# 2079
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 2084
; 
# 2086
return std::__upper_bound(__first, __last, __val, __gnu_cxx::__ops::__val_less_iter()); 
# 2088
} 
# 2105 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp, class _Compare> inline _ForwardIterator 
# 2107
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2108
__val, _Compare __comp) 
# 2109
{ 
# 2111
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 2118
; 
# 2120
return std::__upper_bound(__first, __last, __val, __gnu_cxx::__ops::__val_comp_iter(__comp)); 
# 2122
} 
# 2124
template< class _ForwardIterator, class _Tp, class 
# 2125
_CompareItTp, class _CompareTpIt> pair< _ForwardIterator, _ForwardIterator>  
# 2127
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2128
__val, _CompareItTp 
# 2129
__comp_it_val, _CompareTpIt __comp_val_it) 
# 2130
{ 
# 2132
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 2134
_DistanceType __len = std::distance(__first, __last); 
# 2136
while (__len > 0) 
# 2137
{ 
# 2138
_DistanceType __half = __len >> 1; 
# 2139
_ForwardIterator __middle = __first; 
# 2140
std::advance(__middle, __half); 
# 2141
if (__comp_it_val(__middle, __val)) 
# 2142
{ 
# 2143
__first = __middle; 
# 2144
++__first; 
# 2145
__len = ((__len - __half) - 1); 
# 2146
} else { 
# 2147
if (__comp_val_it(__val, __middle)) { 
# 2148
__len = __half; } else 
# 2150
{ 
# 2151
_ForwardIterator __left = std::__lower_bound(__first, __middle, __val, __comp_it_val); 
# 2153
std::advance(__first, __len); 
# 2154
_ForwardIterator __right = std::__upper_bound(++__middle, __first, __val, __comp_val_it); 
# 2156
return pair< _ForwardIterator, _ForwardIterator> (__left, __right); 
# 2157
}  }  
# 2158
}  
# 2159
return pair< _ForwardIterator, _ForwardIterator> (__first, __first); 
# 2160
} 
# 2179 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp> inline pair< _ForwardIterator, _ForwardIterator>  
# 2181
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2182
__val) 
# 2183
{ 
# 2185
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 2191
; 
# 2192
; 
# 2194
return std::__equal_range(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val(), __gnu_cxx::__ops::__val_less_iter()); 
# 2197
} 
# 2216 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp, class _Compare> inline pair< _ForwardIterator, _ForwardIterator>  
# 2218
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2219
__val, _Compare __comp) 
# 2220
{ 
# 2222
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 2231
; 
# 2233
; 
# 2235
return std::__equal_range(__first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp), __gnu_cxx::__ops::__val_comp_iter(__comp)); 
# 2238
} 
# 2252 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp> bool 
# 2254
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2255
__val) 
# 2256
{ 
# 2258
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 2263
; 
# 2264
; 
# 2266
_ForwardIterator __i = std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val()); 
# 2269
return (__i != __last) && (!(__val < (*__i))); 
# 2270
} 
# 2287 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp, class _Compare> bool 
# 2289
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2290
__val, _Compare __comp) 
# 2291
{ 
# 2293
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 2300
; 
# 2302
; 
# 2304
_ForwardIterator __i = std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp)); 
# 2307
return (__i != __last) && (!((bool)__comp(__val, *__i))); 
# 2308
} 
# 2313
template< class _InputIterator1, class _InputIterator2, class 
# 2314
_OutputIterator, class _Compare> void 
# 2316
__move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 2317
__first2, _InputIterator2 __last2, _OutputIterator 
# 2318
__result, _Compare __comp) 
# 2319
{ 
# 2320
while ((__first1 != __last1) && (__first2 != __last2)) 
# 2321
{ 
# 2322
if (__comp(__first2, __first1)) 
# 2323
{ 
# 2324
(*__result) = std::move(*__first2); 
# 2325
++__first2; 
# 2326
} else 
# 2328
{ 
# 2329
(*__result) = std::move(*__first1); 
# 2330
++__first1; 
# 2331
}  
# 2332
++__result; 
# 2333
}  
# 2334
if (__first1 != __last1) { 
# 2335
std::move(__first1, __last1, __result); }  
# 2336
} 
# 2339
template< class _BidirectionalIterator1, class _BidirectionalIterator2, class 
# 2340
_BidirectionalIterator3, class _Compare> void 
# 2342
__move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 
# 2343
__last1, _BidirectionalIterator2 
# 2344
__first2, _BidirectionalIterator2 
# 2345
__last2, _BidirectionalIterator3 
# 2346
__result, _Compare 
# 2347
__comp) 
# 2348
{ 
# 2349
if (__first1 == __last1) 
# 2350
{ 
# 2351
std::move_backward(__first2, __last2, __result); 
# 2352
return; 
# 2353
} else { 
# 2354
if (__first2 == __last2) { 
# 2355
return; }  }  
# 2357
--__last1; 
# 2358
--__last2; 
# 2359
while (true) 
# 2360
{ 
# 2361
if (__comp(__last2, __last1)) 
# 2362
{ 
# 2363
(*(--__result)) = std::move(*__last1); 
# 2364
if (__first1 == __last1) 
# 2365
{ 
# 2366
std::move_backward(__first2, ++__last2, __result); 
# 2367
return; 
# 2368
}  
# 2369
--__last1; 
# 2370
} else 
# 2372
{ 
# 2373
(*(--__result)) = std::move(*__last2); 
# 2374
if (__first2 == __last2) { 
# 2375
return; }  
# 2376
--__last2; 
# 2377
}  
# 2378
}  
# 2379
} 
# 2382
template< class _BidirectionalIterator1, class _BidirectionalIterator2, class 
# 2383
_Distance> _BidirectionalIterator1 
# 2385
__rotate_adaptive(_BidirectionalIterator1 __first, _BidirectionalIterator1 
# 2386
__middle, _BidirectionalIterator1 
# 2387
__last, _Distance 
# 2388
__len1, _Distance __len2, _BidirectionalIterator2 
# 2389
__buffer, _Distance 
# 2390
__buffer_size) 
# 2391
{ 
# 2392
_BidirectionalIterator2 __buffer_end; 
# 2393
if ((__len1 > __len2) && (__len2 <= __buffer_size)) 
# 2394
{ 
# 2395
if (__len2) 
# 2396
{ 
# 2397
__buffer_end = std::move(__middle, __last, __buffer); 
# 2398
std::move_backward(__first, __middle, __last); 
# 2399
return std::move(__buffer, __buffer_end, __first); 
# 2400
} else { 
# 2402
return __first; }  
# 2403
} else { 
# 2404
if (__len1 <= __buffer_size) 
# 2405
{ 
# 2406
if (__len1) 
# 2407
{ 
# 2408
__buffer_end = std::move(__first, __middle, __buffer); 
# 2409
std::move(__middle, __last, __first); 
# 2410
return std::move_backward(__buffer, __buffer_end, __last); 
# 2411
} else { 
# 2413
return __last; }  
# 2414
} else 
# 2416
{ 
# 2417
std::rotate(__first, __middle, __last); 
# 2418
std::advance(__first, std::distance(__middle, __last)); 
# 2419
return __first; 
# 2420
}  }  
# 2421
} 
# 2424
template< class _BidirectionalIterator, class _Distance, class 
# 2425
_Pointer, class _Compare> void 
# 2427
__merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator 
# 2428
__middle, _BidirectionalIterator 
# 2429
__last, _Distance 
# 2430
__len1, _Distance __len2, _Pointer 
# 2431
__buffer, _Distance __buffer_size, _Compare 
# 2432
__comp) 
# 2433
{ 
# 2434
if ((__len1 <= __len2) && (__len1 <= __buffer_size)) 
# 2435
{ 
# 2436
_Pointer __buffer_end = std::move(__first, __middle, __buffer); 
# 2437
std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last, __first, __comp); 
# 2439
} else { 
# 2440
if (__len2 <= __buffer_size) 
# 2441
{ 
# 2442
_Pointer __buffer_end = std::move(__middle, __last, __buffer); 
# 2443
std::__move_merge_adaptive_backward(__first, __middle, __buffer, __buffer_end, __last, __comp); 
# 2445
} else 
# 2447
{ 
# 2448
_BidirectionalIterator __first_cut = __first; 
# 2449
_BidirectionalIterator __second_cut = __middle; 
# 2450
_Distance __len11 = (0); 
# 2451
_Distance __len22 = (0); 
# 2452
if (__len1 > __len2) 
# 2453
{ 
# 2454
__len11 = (__len1 / 2); 
# 2455
std::advance(__first_cut, __len11); 
# 2456
__second_cut = std::__lower_bound(__middle, __last, *__first_cut, __gnu_cxx::__ops::__iter_comp_val(__comp)); 
# 2459
__len22 = std::distance(__middle, __second_cut); 
# 2460
} else 
# 2462
{ 
# 2463
__len22 = (__len2 / 2); 
# 2464
std::advance(__second_cut, __len22); 
# 2465
__first_cut = std::__upper_bound(__first, __middle, *__second_cut, __gnu_cxx::__ops::__val_comp_iter(__comp)); 
# 2468
__len11 = std::distance(__first, __first_cut); 
# 2469
}  
# 2471
_BidirectionalIterator __new_middle = std::__rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11, __len22, __buffer, __buffer_size); 
# 2475
std::__merge_adaptive(__first, __first_cut, __new_middle, __len11, __len22, __buffer, __buffer_size, __comp); 
# 2477
std::__merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __buffer, __buffer_size, __comp); 
# 2481
}  }  
# 2482
} 
# 2485
template< class _BidirectionalIterator, class _Distance, class 
# 2486
_Compare> void 
# 2488
__merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator 
# 2489
__middle, _BidirectionalIterator 
# 2490
__last, _Distance 
# 2491
__len1, _Distance __len2, _Compare 
# 2492
__comp) 
# 2493
{ 
# 2494
if ((__len1 == 0) || (__len2 == 0)) { 
# 2495
return; }  
# 2497
if ((__len1 + __len2) == 2) 
# 2498
{ 
# 2499
if (__comp(__middle, __first)) { 
# 2500
std::iter_swap(__first, __middle); }  
# 2501
return; 
# 2502
}  
# 2504
_BidirectionalIterator __first_cut = __first; 
# 2505
_BidirectionalIterator __second_cut = __middle; 
# 2506
_Distance __len11 = (0); 
# 2507
_Distance __len22 = (0); 
# 2508
if (__len1 > __len2) 
# 2509
{ 
# 2510
__len11 = (__len1 / 2); 
# 2511
std::advance(__first_cut, __len11); 
# 2512
__second_cut = std::__lower_bound(__middle, __last, *__first_cut, __gnu_cxx::__ops::__iter_comp_val(__comp)); 
# 2515
__len22 = std::distance(__middle, __second_cut); 
# 2516
} else 
# 2518
{ 
# 2519
__len22 = (__len2 / 2); 
# 2520
std::advance(__second_cut, __len22); 
# 2521
__first_cut = std::__upper_bound(__first, __middle, *__second_cut, __gnu_cxx::__ops::__val_comp_iter(__comp)); 
# 2524
__len11 = std::distance(__first, __first_cut); 
# 2525
}  
# 2527
std::rotate(__first_cut, __middle, __second_cut); 
# 2528
_BidirectionalIterator __new_middle = __first_cut; 
# 2529
std::advance(__new_middle, std::distance(__middle, __second_cut)); 
# 2530
std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22, __comp); 
# 2532
std::__merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __comp); 
# 2534
} 
# 2536
template< class _BidirectionalIterator, class _Compare> void 
# 2538
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator 
# 2539
__middle, _BidirectionalIterator 
# 2540
__last, _Compare 
# 2541
__comp) 
# 2542
{ 
# 2544
typedef typename iterator_traits< _BidirectionalIterator> ::value_type _ValueType; 
# 2546
typedef typename iterator_traits< _BidirectionalIterator> ::difference_type _DistanceType; 
# 2548
if ((__first == __middle) || (__middle == __last)) { 
# 2549
return; }  
# 2551
const _DistanceType __len1 = std::distance(__first, __middle); 
# 2552
const _DistanceType __len2 = std::distance(__middle, __last); 
# 2554
typedef _Temporary_buffer< _BidirectionalIterator, typename iterator_traits< _BidirectionalIterator> ::value_type>  _TmpBuf; 
# 2555
_TmpBuf __buf(__first, __last); 
# 2557
if ((__buf.begin()) == 0) { 
# 2558
std::__merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp); } else { 
# 2561
std::__merge_adaptive(__first, __middle, __last, __len1, __len2, (__buf.begin()), (_DistanceType)(__buf.size()), __comp); }  
# 2564
} 
# 2584 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _BidirectionalIterator> inline void 
# 2586
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator 
# 2587
__middle, _BidirectionalIterator 
# 2588
__last) 
# 2589
{ 
# 2595
; 
# 2596
; 
# 2598
std::__inplace_merge(__first, __middle, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 2600
} 
# 2624 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _BidirectionalIterator, class _Compare> inline void 
# 2626
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator 
# 2627
__middle, _BidirectionalIterator 
# 2628
__last, _Compare 
# 2629
__comp) 
# 2630
{ 
# 2637
; 
# 2638
; 
# 2640
std::__inplace_merge(__first, __middle, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 2642
} 
# 2646
template< class _InputIterator, class _OutputIterator, class 
# 2647
_Compare> _OutputIterator 
# 2649
__move_merge(_InputIterator __first1, _InputIterator __last1, _InputIterator 
# 2650
__first2, _InputIterator __last2, _OutputIterator 
# 2651
__result, _Compare __comp) 
# 2652
{ 
# 2653
while ((__first1 != __last1) && (__first2 != __last2)) 
# 2654
{ 
# 2655
if (__comp(__first2, __first1)) 
# 2656
{ 
# 2657
(*__result) = std::move(*__first2); 
# 2658
++__first2; 
# 2659
} else 
# 2661
{ 
# 2662
(*__result) = std::move(*__first1); 
# 2663
++__first1; 
# 2664
}  
# 2665
++__result; 
# 2666
}  
# 2667
return std::move(__first2, __last2, std::move(__first1, __last1, __result)); 
# 2670
} 
# 2672
template< class _RandomAccessIterator1, class _RandomAccessIterator2, class 
# 2673
_Distance, class _Compare> void 
# 2675
__merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 
# 2676
__last, _RandomAccessIterator2 
# 2677
__result, _Distance __step_size, _Compare 
# 2678
__comp) 
# 2679
{ 
# 2680
const _Distance __two_step = 2 * __step_size; 
# 2682
while ((__last - __first) >= __two_step) 
# 2683
{ 
# 2684
__result = std::__move_merge(__first, __first + __step_size, __first + __step_size, __first + __two_step, __result, __comp); 
# 2688
__first += __two_step; 
# 2689
}  
# 2690
__step_size = std::min((_Distance)(__last - __first), __step_size); 
# 2692
std::__move_merge(__first, __first + __step_size, __first + __step_size, __last, __result, __comp); 
# 2694
} 
# 2696
template< class _RandomAccessIterator, class _Distance, class 
# 2697
_Compare> void 
# 2699
__chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 2700
__last, _Distance 
# 2701
__chunk_size, _Compare __comp) 
# 2702
{ 
# 2703
while ((__last - __first) >= __chunk_size) 
# 2704
{ 
# 2705
std::__insertion_sort(__first, __first + __chunk_size, __comp); 
# 2706
__first += __chunk_size; 
# 2707
}  
# 2708
std::__insertion_sort(__first, __last, __comp); 
# 2709
} 
# 2711
enum { _S_chunk_size = 7}; 
# 2713
template< class _RandomAccessIterator, class _Pointer, class _Compare> void 
# 2715
__merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator 
# 2716
__last, _Pointer 
# 2717
__buffer, _Compare __comp) 
# 2718
{ 
# 2720
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _Distance; 
# 2722
const _Distance __len = __last - __first; 
# 2723
const _Pointer __buffer_last = __buffer + __len; 
# 2725
_Distance __step_size = (_S_chunk_size); 
# 2726
std::__chunk_insertion_sort(__first, __last, __step_size, __comp); 
# 2728
while (__step_size < __len) 
# 2729
{ 
# 2730
std::__merge_sort_loop(__first, __last, __buffer, __step_size, __comp); 
# 2732
__step_size *= 2; 
# 2733
std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp); 
# 2735
__step_size *= 2; 
# 2736
}  
# 2737
} 
# 2739
template< class _RandomAccessIterator, class _Pointer, class 
# 2740
_Distance, class _Compare> void 
# 2742
__stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator 
# 2743
__last, _Pointer 
# 2744
__buffer, _Distance __buffer_size, _Compare 
# 2745
__comp) 
# 2746
{ 
# 2747
const _Distance __len = ((__last - __first) + 1) / 2; 
# 2748
const _RandomAccessIterator __middle = __first + __len; 
# 2749
if (__len > __buffer_size) 
# 2750
{ 
# 2751
std::__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, __comp); 
# 2753
std::__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, __comp); 
# 2755
} else 
# 2757
{ 
# 2758
std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp); 
# 2759
std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp); 
# 2760
}  
# 2761
std::__merge_adaptive(__first, __middle, __last, (_Distance)(__middle - __first), (_Distance)(__last - __middle), __buffer, __buffer_size, __comp); 
# 2766
} 
# 2769
template< class _RandomAccessIterator, class _Compare> void 
# 2771
__inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 2772
__last, _Compare __comp) 
# 2773
{ 
# 2774
if ((__last - __first) < 15) 
# 2775
{ 
# 2776
std::__insertion_sort(__first, __last, __comp); 
# 2777
return; 
# 2778
}  
# 2779
_RandomAccessIterator __middle = __first + ((__last - __first) / 2); 
# 2780
std::__inplace_stable_sort(__first, __middle, __comp); 
# 2781
std::__inplace_stable_sort(__middle, __last, __comp); 
# 2782
std::__merge_without_buffer(__first, __middle, __last, __middle - __first, __last - __middle, __comp); 
# 2786
} 
# 2795 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 2796
_Compare> bool 
# 2798
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 2799
__first2, _InputIterator2 __last2, _Compare 
# 2800
__comp) 
# 2801
{ 
# 2802
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 2803
if (__comp(__first2, __first1)) { 
# 2804
return false; } else { 
# 2805
if (__comp(__first1, __first2)) { 
# 2806
++__first1; } else { 
# 2808
(++__first1), (++__first2); }  }  }  
# 2810
return __first2 == __last2; 
# 2811
} 
# 2831 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2> inline bool 
# 2833
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 2834
__first2, _InputIterator2 __last2) 
# 2835
{ 
# 2845
; 
# 2846
; 
# 2848
return std::__includes(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_less_iter()); 
# 2850
} 
# 2873 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 2874
_Compare> inline bool 
# 2876
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 2877
__first2, _InputIterator2 __last2, _Compare 
# 2878
__comp) 
# 2879
{ 
# 2889
; 
# 2890
; 
# 2892
return std::__includes(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 2894
} 
# 2906 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _BidirectionalIterator, class _Compare> bool 
# 2908
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 2909
__last, _Compare __comp) 
# 2910
{ 
# 2911
if (__first == __last) { 
# 2912
return false; }  
# 2913
_BidirectionalIterator __i = __first; 
# 2914
++__i; 
# 2915
if (__i == __last) { 
# 2916
return false; }  
# 2917
__i = __last; 
# 2918
--__i; 
# 2920
for (; ;) 
# 2921
{ 
# 2922
_BidirectionalIterator __ii = __i; 
# 2923
--__i; 
# 2924
if (__comp(__i, __ii)) 
# 2925
{ 
# 2926
_BidirectionalIterator __j = __last; 
# 2927
while (!__comp(__i, --__j)) 
# 2928
{ }  
# 2929
std::iter_swap(__i, __j); 
# 2930
std::__reverse(__ii, __last, std::__iterator_category(__first)); 
# 2932
return true; 
# 2933
}  
# 2934
if (__i == __first) 
# 2935
{ 
# 2936
std::__reverse(__first, __last, std::__iterator_category(__first)); 
# 2938
return false; 
# 2939
}  
# 2940
}  
# 2941
} 
# 2955 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _BidirectionalIterator> inline bool 
# 2957
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 2958
__last) 
# 2959
{ 
# 2965
; 
# 2967
return std::__next_permutation(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 2969
} 
# 2986 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _BidirectionalIterator, class _Compare> inline bool 
# 2988
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 2989
__last, _Compare __comp) 
# 2990
{ 
# 2997
; 
# 2999
return std::__next_permutation(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 3001
} 
# 3003
template< class _BidirectionalIterator, class _Compare> bool 
# 3005
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 3006
__last, _Compare __comp) 
# 3007
{ 
# 3008
if (__first == __last) { 
# 3009
return false; }  
# 3010
_BidirectionalIterator __i = __first; 
# 3011
++__i; 
# 3012
if (__i == __last) { 
# 3013
return false; }  
# 3014
__i = __last; 
# 3015
--__i; 
# 3017
for (; ;) 
# 3018
{ 
# 3019
_BidirectionalIterator __ii = __i; 
# 3020
--__i; 
# 3021
if (__comp(__ii, __i)) 
# 3022
{ 
# 3023
_BidirectionalIterator __j = __last; 
# 3024
while (!__comp(--__j, __i)) 
# 3025
{ }  
# 3026
std::iter_swap(__i, __j); 
# 3027
std::__reverse(__ii, __last, std::__iterator_category(__first)); 
# 3029
return true; 
# 3030
}  
# 3031
if (__i == __first) 
# 3032
{ 
# 3033
std::__reverse(__first, __last, std::__iterator_category(__first)); 
# 3035
return false; 
# 3036
}  
# 3037
}  
# 3038
} 
# 3053 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _BidirectionalIterator> inline bool 
# 3055
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 3056
__last) 
# 3057
{ 
# 3063
; 
# 3065
return std::__prev_permutation(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 3067
} 
# 3084 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _BidirectionalIterator, class _Compare> inline bool 
# 3086
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 3087
__last, _Compare __comp) 
# 3088
{ 
# 3095
; 
# 3097
return std::__prev_permutation(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 3099
} 
# 3104
template< class _InputIterator, class _OutputIterator, class 
# 3105
_Predicate, class _Tp> _OutputIterator 
# 3107
__replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 3108
__result, _Predicate 
# 3109
__pred, const _Tp &__new_value) 
# 3110
{ 
# 3111
for (; __first != __last; (++__first), (++__result)) { 
# 3112
if (__pred(__first)) { 
# 3113
(*__result) = __new_value; } else { 
# 3115
(*__result) = (*__first); }  }  
# 3116
return __result; 
# 3117
} 
# 3133 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class _Tp> inline _OutputIterator 
# 3135
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 3136
__result, const _Tp &
# 3137
__old_value, const _Tp &__new_value) 
# 3138
{ 
# 3145
; 
# 3147
return std::__replace_copy_if(__first, __last, __result, __gnu_cxx::__ops::__iter_equals_val(__old_value), __new_value); 
# 3150
} 
# 3167 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 3168
_Predicate, class _Tp> inline _OutputIterator 
# 3170
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 3171
__result, _Predicate 
# 3172
__pred, const _Tp &__new_value) 
# 3173
{ 
# 3180
; 
# 3182
return std::__replace_copy_if(__first, __last, __result, __gnu_cxx::__ops::__pred_iter(__pred), __new_value); 
# 3185
} 
# 3187
template< class _InputIterator, class _Predicate> typename iterator_traits< _InputIterator> ::difference_type 
# 3189
__count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) 
# 3190
{ 
# 3191
typename iterator_traits< _InputIterator> ::difference_type __n = (0); 
# 3192
for (; __first != __last; ++__first) { 
# 3193
if (__pred(__first)) { 
# 3194
++__n; }  }  
# 3195
return __n; 
# 3196
} 
# 3206 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator> inline bool 
# 3208
is_sorted(_ForwardIterator __first, _ForwardIterator __last) 
# 3209
{ return std::is_sorted_until(__first, __last) == __last; } 
# 3220 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Compare> inline bool 
# 3222
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 3223
__comp) 
# 3224
{ return std::is_sorted_until(__first, __last, __comp) == __last; } 
# 3226
template< class _ForwardIterator, class _Compare> _ForwardIterator 
# 3228
__is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 3229
__comp) 
# 3230
{ 
# 3231
if (__first == __last) { 
# 3232
return __last; }  
# 3234
_ForwardIterator __next = __first; 
# 3235
for (++__next; __next != __last; (__first = __next), (++__next)) { 
# 3236
if (__comp(__next, __first)) { 
# 3237
return __next; }  }  
# 3238
return __next; 
# 3239
} 
# 3249 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator> inline _ForwardIterator 
# 3251
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last) 
# 3252
{ 
# 3257
; 
# 3259
return std::__is_sorted_until(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 3261
} 
# 3272 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Compare> inline _ForwardIterator 
# 3274
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 3275
__comp) 
# 3276
{ 
# 3282
; 
# 3284
return std::__is_sorted_until(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 3286
} 
# 3296 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _Tp> inline pair< const _Tp &, const _Tp &>  
# 3299
minmax(const _Tp &__a, const _Tp &__b) 
# 3300
{ 
# 3304
return (__b < __a) ? pair< const _Tp &, const _Tp &> (__b, __a) : pair< const _Tp &, const _Tp &> (__a, __b); 
# 3306
} 
# 3317 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _Tp, class _Compare> inline pair< const _Tp &, const _Tp &>  
# 3320
minmax(const _Tp &__a, const _Tp &__b, _Compare __comp) 
# 3321
{ 
# 3322
return (__comp(__b, __a)) ? pair< const _Tp &, const _Tp &> (__b, __a) : pair< const _Tp &, const _Tp &> (__a, __b); 
# 3324
} 
# 3326
template< class _ForwardIterator, class _Compare> pair< _ForwardIterator, _ForwardIterator>  
# 3329
__minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 3330
__comp) 
# 3331
{ 
# 3332
_ForwardIterator __next = __first; 
# 3333
if ((__first == __last) || ((++__next) == __last)) { 
# 3335
return std::make_pair(__first, __first); }  
# 3337
_ForwardIterator __min{}, __max{}; 
# 3338
if (__comp(__next, __first)) 
# 3339
{ 
# 3340
__min = __next; 
# 3341
__max = __first; 
# 3342
} else 
# 3344
{ 
# 3345
__min = __first; 
# 3346
__max = __next; 
# 3347
}  
# 3349
__first = __next; 
# 3350
++__first; 
# 3352
while (__first != __last) 
# 3353
{ 
# 3354
__next = __first; 
# 3355
if ((++__next) == __last) 
# 3356
{ 
# 3357
if (__comp(__first, __min)) { 
# 3358
__min = __first; } else { 
# 3359
if (!__comp(__first, __max)) { 
# 3360
__max = __first; }  }  
# 3361
break; 
# 3362
}  
# 3364
if (__comp(__next, __first)) 
# 3365
{ 
# 3366
if (__comp(__next, __min)) { 
# 3367
__min = __next; }  
# 3368
if (!__comp(__first, __max)) { 
# 3369
__max = __first; }  
# 3370
} else 
# 3372
{ 
# 3373
if (__comp(__first, __min)) { 
# 3374
__min = __first; }  
# 3375
if (!__comp(__next, __max)) { 
# 3376
__max = __next; }  
# 3377
}  
# 3379
__first = __next; 
# 3380
++__first; 
# 3381
}  
# 3383
return std::make_pair(__min, __max); 
# 3384
} 
# 3397 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator> inline pair< _ForwardIterator, _ForwardIterator>  
# 3400
minmax_element(_ForwardIterator __first, _ForwardIterator __last) 
# 3401
{ 
# 3406
; 
# 3408
return std::__minmax_element(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 3410
} 
# 3424 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Compare> inline pair< _ForwardIterator, _ForwardIterator>  
# 3427
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 3428
__comp) 
# 3429
{ 
# 3435
; 
# 3437
return std::__minmax_element(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 3439
} 
# 3442
template< class _Tp> inline _Tp 
# 3445
min(initializer_list< _Tp>  __l) 
# 3446
{ return *std::min_element((__l.begin()), (__l.end())); } 
# 3448
template< class _Tp, class _Compare> inline _Tp 
# 3451
min(initializer_list< _Tp>  __l, _Compare __comp) 
# 3452
{ return *std::min_element((__l.begin()), (__l.end()), __comp); } 
# 3454
template< class _Tp> inline _Tp 
# 3457
max(initializer_list< _Tp>  __l) 
# 3458
{ return *std::max_element((__l.begin()), (__l.end())); } 
# 3460
template< class _Tp, class _Compare> inline _Tp 
# 3463
max(initializer_list< _Tp>  __l, _Compare __comp) 
# 3464
{ return *std::max_element((__l.begin()), (__l.end()), __comp); } 
# 3466
template< class _Tp> inline pair< _Tp, _Tp>  
# 3469
minmax(initializer_list< _Tp>  __l) 
# 3470
{ 
# 3471
pair< const _Tp *, const _Tp *>  __p = std::minmax_element((__l.begin()), (__l.end())); 
# 3473
return std::make_pair(*(__p.first), *(__p.second)); 
# 3474
} 
# 3476
template< class _Tp, class _Compare> inline pair< _Tp, _Tp>  
# 3479
minmax(initializer_list< _Tp>  __l, _Compare __comp) 
# 3480
{ 
# 3481
pair< const _Tp *, const _Tp *>  __p = std::minmax_element((__l.begin()), (__l.end()), __comp); 
# 3483
return std::make_pair(*(__p.first), *(__p.second)); 
# 3484
} 
# 3486
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 3487
_BinaryPredicate> bool 
# 3489
__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 3490
__first2, _BinaryPredicate __pred) 
# 3491
{ 
# 3494
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 3495
if (!__pred(__first1, __first2)) { 
# 3496
break; }  }  
# 3498
if (__first1 == __last1) { 
# 3499
return true; }  
# 3503
_ForwardIterator2 __last2 = __first2; 
# 3504
std::advance(__last2, std::distance(__first1, __last1)); 
# 3505
for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) { 
# 3506
{ 
# 3507
if (__scan != std::__find_if(__first1, __scan, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))) { 
# 3509
continue; }  
# 3511
auto __matches = std::__count_if(__first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)); 
# 3514
if ((0 == __matches) || (std::__count_if(__scan, __last1, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)) != __matches)) { 
# 3518
return false; }  
# 3519
} }  
# 3520
return true; 
# 3521
} 
# 3535 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> inline bool 
# 3537
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 3538
__first2) 
# 3539
{ 
# 3546
; 
# 3548
return std::__is_permutation(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 3550
} 
# 3566 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 3567
_BinaryPredicate> inline bool 
# 3569
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 3570
__first2, _BinaryPredicate __pred) 
# 3571
{ 
# 3578
; 
# 3580
return std::__is_permutation(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__pred)); 
# 3582
} 
# 3714 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class 
# 3715
_UniformRandomNumberGenerator> void 
# 3717
shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator &&
# 3718
__g) 
# 3719
{ 
# 3723
; 
# 3725
if (__first == __last) { 
# 3726
return; }  
# 3729
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 3731
typedef typename make_unsigned< typename iterator_traits< _RandomAccessIterator> ::difference_type> ::type __ud_type; 
# 3732
typedef uniform_int_distribution< typename make_unsigned< typename iterator_traits< _RandomAccessIterator> ::difference_type> ::type>  __distr_type; 
# 3733
typedef typename uniform_int_distribution< typename make_unsigned< typename iterator_traits< _RandomAccessIterator> ::difference_type> ::type> ::param_type __p_type; 
# 3734
__distr_type __d; 
# 3736
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) { 
# 3737
std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first))); }  
# 3738
} 
# 3759 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Function> _Function 
# 3761
for_each(_InputIterator __first, _InputIterator __last, _Function __f) 
# 3762
{ 
# 3765
; 
# 3766
for (; __first != __last; ++__first) { 
# 3767
__f(*__first); }  
# 3768
return std::move(__f); 
# 3769
} 
# 3780 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Tp> inline _InputIterator 
# 3782
find(_InputIterator __first, _InputIterator __last, const _Tp &
# 3783
__val) 
# 3784
{ 
# 3789
; 
# 3790
return std::__find_if(__first, __last, __gnu_cxx::__ops::__iter_equals_val(__val)); 
# 3792
} 
# 3804 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline _InputIterator 
# 3806
find_if(_InputIterator __first, _InputIterator __last, _Predicate 
# 3807
__pred) 
# 3808
{ 
# 3813
; 
# 3815
return std::__find_if(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 3817
} 
# 3835 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _ForwardIterator> _InputIterator 
# 3837
find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator 
# 3838
__first2, _ForwardIterator __last2) 
# 3839
{ 
# 3846
; 
# 3847
; 
# 3849
for (; __first1 != __last1; ++__first1) { 
# 3850
for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter) { 
# 3851
if ((*__first1) == (*__iter)) { 
# 3852
return __first1; }  }  }  
# 3853
return __last1; 
# 3854
} 
# 3875 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _ForwardIterator, class 
# 3876
_BinaryPredicate> _InputIterator 
# 3878
find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator 
# 3879
__first2, _ForwardIterator __last2, _BinaryPredicate 
# 3880
__comp) 
# 3881
{ 
# 3888
; 
# 3889
; 
# 3891
for (; __first1 != __last1; ++__first1) { 
# 3892
for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter) { 
# 3893
if (__comp(*__first1, *__iter)) { 
# 3894
return __first1; }  }  }  
# 3895
return __last1; 
# 3896
} 
# 3907 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator> inline _ForwardIterator 
# 3909
adjacent_find(_ForwardIterator __first, _ForwardIterator __last) 
# 3910
{ 
# 3915
; 
# 3917
return std::__adjacent_find(__first, __last, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 3919
} 
# 3932 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _BinaryPredicate> inline _ForwardIterator 
# 3934
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate 
# 3935
__binary_pred) 
# 3936
{ 
# 3942
; 
# 3944
return std::__adjacent_find(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred)); 
# 3946
} 
# 3957 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Tp> inline typename iterator_traits< _InputIterator> ::difference_type 
# 3959
count(_InputIterator __first, _InputIterator __last, const _Tp &__value) 
# 3960
{ 
# 3965
; 
# 3967
return std::__count_if(__first, __last, __gnu_cxx::__ops::__iter_equals_val(__value)); 
# 3969
} 
# 3980 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline typename iterator_traits< _InputIterator> ::difference_type 
# 3982
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) 
# 3983
{ 
# 3988
; 
# 3990
return std::__count_if(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 3992
} 
# 4020 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator1 
# 4022
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 4023
__first2, _ForwardIterator2 __last2) 
# 4024
{ 
# 4031
; 
# 4032
; 
# 4034
return std::__search(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 4036
} 
# 4059 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 4060
_BinaryPredicate> inline _ForwardIterator1 
# 4062
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 4063
__first2, _ForwardIterator2 __last2, _BinaryPredicate 
# 4064
__predicate) 
# 4065
{ 
# 4072
; 
# 4073
; 
# 4075
return std::__search(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__predicate)); 
# 4077
} 
# 4094 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Integer, class _Tp> inline _ForwardIterator 
# 4096
search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer 
# 4097
__count, const _Tp &__val) 
# 4098
{ 
# 4103
; 
# 4105
return std::__search_n(__first, __last, __count, __gnu_cxx::__ops::__iter_equals_val(__val)); 
# 4107
} 
# 4127 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Integer, class _Tp, class 
# 4128
_BinaryPredicate> inline _ForwardIterator 
# 4130
search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer 
# 4131
__count, const _Tp &__val, _BinaryPredicate 
# 4132
__binary_pred) 
# 4133
{ 
# 4138
; 
# 4140
return std::__search_n(__first, __last, __count, __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val)); 
# 4142
} 
# 4161 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 4162
_UnaryOperation> _OutputIterator 
# 4164
transform(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 4165
__result, _UnaryOperation __unary_op) 
# 4166
{ 
# 4172
; 
# 4174
for (; __first != __last; (++__first), (++__result)) { 
# 4175
(*__result) = __unary_op(*__first); }  
# 4176
return __result; 
# 4177
} 
# 4198 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 4199
_OutputIterator, class _BinaryOperation> _OutputIterator 
# 4201
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 4202
__first2, _OutputIterator __result, _BinaryOperation 
# 4203
__binary_op) 
# 4204
{ 
# 4211
; 
# 4213
for (; __first1 != __last1; ((++__first1), (++__first2)), (++__result)) { 
# 4214
(*__result) = __binary_op(*__first1, *__first2); }  
# 4215
return __result; 
# 4216
} 
# 4231 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp> void 
# 4233
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 4234
__old_value, const _Tp &__new_value) 
# 4235
{ 
# 4243
; 
# 4245
for (; __first != __last; ++__first) { 
# 4246
if ((*__first) == __old_value) { 
# 4247
(*__first) = __new_value; }  }  
# 4248
} 
# 4263 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Predicate, class _Tp> void 
# 4265
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 4266
__pred, const _Tp &__new_value) 
# 4267
{ 
# 4275
; 
# 4277
for (; __first != __last; ++__first) { 
# 4278
if (__pred(*__first)) { 
# 4279
(*__first) = __new_value; }  }  
# 4280
} 
# 4295 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Generator> void 
# 4297
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator 
# 4298
__gen) 
# 4299
{ 
# 4304
; 
# 4306
for (; __first != __last; ++__first) { 
# 4307
(*__first) = __gen(); }  
# 4308
} 
# 4326 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _OutputIterator, class _Size, class _Generator> _OutputIterator 
# 4328
generate_n(_OutputIterator __first, _Size __n, _Generator __gen) 
# 4329
{ 
# 4335
for (__decltype((__n + 0)) __niter = __n; __niter > 0; (--__niter), (++__first)) { 
# 4337
(*__first) = __gen(); }  
# 4338
return __first; 
# 4339
} 
# 4362 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator> inline _OutputIterator 
# 4364
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 4365
__result) 
# 4366
{ 
# 4373
; 
# 4375
if (__first == __last) { 
# 4376
return __result; }  
# 4377
return std::__unique_copy(__first, __last, __result, __gnu_cxx::__ops::__iter_equal_to_iter(), std::__iterator_category(__first), std::__iterator_category(__result)); 
# 4381
} 
# 4402 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 4403
_BinaryPredicate> inline _OutputIterator 
# 4405
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 4406
__result, _BinaryPredicate 
# 4407
__binary_pred) 
# 4408
{ 
# 4413
; 
# 4415
if (__first == __last) { 
# 4416
return __result; }  
# 4417
return std::__unique_copy(__first, __last, __result, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred), std::__iterator_category(__first), std::__iterator_category(__result)); 
# 4421
} 
# 4434 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator> inline void 
# 4436
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 4437
{ 
# 4441
; 
# 4443
if (__first != __last) { 
# 4444
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) 
# 4445
{ 
# 4447
_RandomAccessIterator __j = __first + (std::rand() % ((__i - __first) + 1)); 
# 4449
if (__i != __j) { 
# 4450
std::iter_swap(__i, __j); }  
# 4451
}  }  
# 4452
} 
# 4468 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class _RandomNumberGenerator> void 
# 4470
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &&
# 4472
__rand) 
# 4476
{ 
# 4480
; 
# 4482
if (__first == __last) { 
# 4483
return; }  
# 4484
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) 
# 4485
{ 
# 4486
_RandomAccessIterator __j = __first + __rand((__i - __first) + 1); 
# 4487
if (__i != __j) { 
# 4488
std::iter_swap(__i, __j); }  
# 4489
}  
# 4490
} 
# 4508 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Predicate> inline _ForwardIterator 
# 4510
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 4511
__pred) 
# 4512
{ 
# 4518
; 
# 4520
return std::__partition(__first, __last, __pred, std::__iterator_category(__first)); 
# 4522
} 
# 4541 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator> inline void 
# 4543
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 4544
__middle, _RandomAccessIterator 
# 4545
__last) 
# 4546
{ 
# 4552
; 
# 4553
; 
# 4555
std::__partial_sort(__first, __middle, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 4557
} 
# 4578 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 4580
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 4581
__middle, _RandomAccessIterator 
# 4582
__last, _Compare 
# 4583
__comp) 
# 4584
{ 
# 4591
; 
# 4592
; 
# 4594
std::__partial_sort(__first, __middle, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 4596
} 
# 4613 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator> inline void 
# 4615
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator 
# 4616
__last) 
# 4617
{ 
# 4623
; 
# 4624
; 
# 4626
if ((__first == __last) || (__nth == __last)) { 
# 4627
return; }  
# 4629
std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2, __gnu_cxx::__ops::__iter_less_iter()); 
# 4632
} 
# 4651 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 4653
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator 
# 4654
__last, _Compare __comp) 
# 4655
{ 
# 4662
; 
# 4663
; 
# 4665
if ((__first == __last) || (__nth == __last)) { 
# 4666
return; }  
# 4668
std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 4671
} 
# 4687 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator> inline void 
# 4689
sort(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 4690
{ 
# 4696
; 
# 4698
std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 4699
} 
# 4716 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 4718
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 4719
__comp) 
# 4720
{ 
# 4727
; 
# 4729
std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 4730
} 
# 4732
template< class _InputIterator1, class _InputIterator2, class 
# 4733
_OutputIterator, class _Compare> _OutputIterator 
# 4735
__merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 4736
__first2, _InputIterator2 __last2, _OutputIterator 
# 4737
__result, _Compare __comp) 
# 4738
{ 
# 4739
while ((__first1 != __last1) && (__first2 != __last2)) 
# 4740
{ 
# 4741
if (__comp(__first2, __first1)) 
# 4742
{ 
# 4743
(*__result) = (*__first2); 
# 4744
++__first2; 
# 4745
} else 
# 4747
{ 
# 4748
(*__result) = (*__first1); 
# 4749
++__first1; 
# 4750
}  
# 4751
++__result; 
# 4752
}  
# 4753
return std::copy(__first2, __last2, std::copy(__first1, __last1, __result)); 
# 4755
} 
# 4776 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 4777
_OutputIterator> inline _OutputIterator 
# 4779
merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 4780
__first2, _InputIterator2 __last2, _OutputIterator 
# 4781
__result) 
# 4782
{ 
# 4793
; 
# 4794
; 
# 4796
return std::__merge(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter()); 
# 4799
} 
# 4824 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 4825
_OutputIterator, class _Compare> inline _OutputIterator 
# 4827
merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 4828
__first2, _InputIterator2 __last2, _OutputIterator 
# 4829
__result, _Compare __comp) 
# 4830
{ 
# 4841
; 
# 4842
; 
# 4844
return std::__merge(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 4847
} 
# 4849
template< class _RandomAccessIterator, class _Compare> inline void 
# 4851
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 4852
__comp) 
# 4853
{ 
# 4855
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 4857
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 4859
typedef _Temporary_buffer< _RandomAccessIterator, typename iterator_traits< _RandomAccessIterator> ::value_type>  _TmpBuf; 
# 4860
_TmpBuf __buf(__first, __last); 
# 4862
if ((__buf.begin()) == 0) { 
# 4863
std::__inplace_stable_sort(__first, __last, __comp); } else { 
# 4865
std::__stable_sort_adaptive(__first, __last, (__buf.begin()), (_DistanceType)(__buf.size()), __comp); }  
# 4867
} 
# 4886 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator> inline void 
# 4888
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 4889
{ 
# 4895
; 
# 4897
std::__stable_sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 4899
} 
# 4919 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 4921
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 4922
__comp) 
# 4923
{ 
# 4930
; 
# 4932
std::__stable_sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 4934
} 
# 4936
template< class _InputIterator1, class _InputIterator2, class 
# 4937
_OutputIterator, class 
# 4938
_Compare> _OutputIterator 
# 4940
__set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 4941
__first2, _InputIterator2 __last2, _OutputIterator 
# 4942
__result, _Compare __comp) 
# 4943
{ 
# 4944
while ((__first1 != __last1) && (__first2 != __last2)) 
# 4945
{ 
# 4946
if (__comp(__first1, __first2)) 
# 4947
{ 
# 4948
(*__result) = (*__first1); 
# 4949
++__first1; 
# 4950
} else { 
# 4951
if (__comp(__first2, __first1)) 
# 4952
{ 
# 4953
(*__result) = (*__first2); 
# 4954
++__first2; 
# 4955
} else 
# 4957
{ 
# 4958
(*__result) = (*__first1); 
# 4959
++__first1; 
# 4960
++__first2; 
# 4961
}  }  
# 4962
++__result; 
# 4963
}  
# 4964
return std::copy(__first2, __last2, std::copy(__first1, __last1, __result)); 
# 4966
} 
# 4986 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 4987
_OutputIterator> inline _OutputIterator 
# 4989
set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 4990
__first2, _InputIterator2 __last2, _OutputIterator 
# 4991
__result) 
# 4992
{ 
# 5006
; 
# 5007
; 
# 5009
return std::__set_union(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter()); 
# 5012
} 
# 5033 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5034
_OutputIterator, class _Compare> inline _OutputIterator 
# 5036
set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5037
__first2, _InputIterator2 __last2, _OutputIterator 
# 5038
__result, _Compare __comp) 
# 5039
{ 
# 5053
; 
# 5054
; 
# 5056
return std::__set_union(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5059
} 
# 5061
template< class _InputIterator1, class _InputIterator2, class 
# 5062
_OutputIterator, class 
# 5063
_Compare> _OutputIterator 
# 5065
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5066
__first2, _InputIterator2 __last2, _OutputIterator 
# 5067
__result, _Compare __comp) 
# 5068
{ 
# 5069
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 5070
if (__comp(__first1, __first2)) { 
# 5071
++__first1; } else { 
# 5072
if (__comp(__first2, __first1)) { 
# 5073
++__first2; } else 
# 5075
{ 
# 5076
(*__result) = (*__first1); 
# 5077
++__first1; 
# 5078
++__first2; 
# 5079
++__result; 
# 5080
}  }  }  
# 5081
return __result; 
# 5082
} 
# 5101 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5102
_OutputIterator> inline _OutputIterator 
# 5104
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5105
__first2, _InputIterator2 __last2, _OutputIterator 
# 5106
__result) 
# 5107
{ 
# 5119
; 
# 5120
; 
# 5122
return std::__set_intersection(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter()); 
# 5125
} 
# 5147 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5148
_OutputIterator, class _Compare> inline _OutputIterator 
# 5150
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5151
__first2, _InputIterator2 __last2, _OutputIterator 
# 5152
__result, _Compare __comp) 
# 5153
{ 
# 5165
; 
# 5166
; 
# 5168
return std::__set_intersection(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5171
} 
# 5173
template< class _InputIterator1, class _InputIterator2, class 
# 5174
_OutputIterator, class 
# 5175
_Compare> _OutputIterator 
# 5177
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5178
__first2, _InputIterator2 __last2, _OutputIterator 
# 5179
__result, _Compare __comp) 
# 5180
{ 
# 5181
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 5182
if (__comp(__first1, __first2)) 
# 5183
{ 
# 5184
(*__result) = (*__first1); 
# 5185
++__first1; 
# 5186
++__result; 
# 5187
} else { 
# 5188
if (__comp(__first2, __first1)) { 
# 5189
++__first2; } else 
# 5191
{ 
# 5192
++__first1; 
# 5193
++__first2; 
# 5194
}  }  }  
# 5195
return std::copy(__first1, __last1, __result); 
# 5196
} 
# 5217 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5218
_OutputIterator> inline _OutputIterator 
# 5220
set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5221
__first2, _InputIterator2 __last2, _OutputIterator 
# 5222
__result) 
# 5223
{ 
# 5235
; 
# 5236
; 
# 5238
return std::__set_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter()); 
# 5241
} 
# 5265 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5266
_OutputIterator, class _Compare> inline _OutputIterator 
# 5268
set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5269
__first2, _InputIterator2 __last2, _OutputIterator 
# 5270
__result, _Compare __comp) 
# 5271
{ 
# 5283
; 
# 5284
; 
# 5286
return std::__set_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5289
} 
# 5291
template< class _InputIterator1, class _InputIterator2, class 
# 5292
_OutputIterator, class 
# 5293
_Compare> _OutputIterator 
# 5295
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 
# 5296
__last1, _InputIterator2 
# 5297
__first2, _InputIterator2 
# 5298
__last2, _OutputIterator 
# 5299
__result, _Compare 
# 5300
__comp) 
# 5301
{ 
# 5302
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 5303
if (__comp(__first1, __first2)) 
# 5304
{ 
# 5305
(*__result) = (*__first1); 
# 5306
++__first1; 
# 5307
++__result; 
# 5308
} else { 
# 5309
if (__comp(__first2, __first1)) 
# 5310
{ 
# 5311
(*__result) = (*__first2); 
# 5312
++__first2; 
# 5313
++__result; 
# 5314
} else 
# 5316
{ 
# 5317
++__first1; 
# 5318
++__first2; 
# 5319
}  }  }  
# 5320
return std::copy(__first2, __last2, std::copy(__first1, __last1, __result)); 
# 5322
} 
# 5341 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5342
_OutputIterator> inline _OutputIterator 
# 5344
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5345
__first2, _InputIterator2 __last2, _OutputIterator 
# 5346
__result) 
# 5347
{ 
# 5361
; 
# 5362
; 
# 5364
return std::__set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter()); 
# 5367
} 
# 5389 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5390
_OutputIterator, class _Compare> inline _OutputIterator 
# 5392
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5393
__first2, _InputIterator2 __last2, _OutputIterator 
# 5394
__result, _Compare 
# 5395
__comp) 
# 5396
{ 
# 5410
; 
# 5411
; 
# 5413
return std::__set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5416
} 
# 5418
template< class _ForwardIterator, class _Compare> _ForwardIterator 
# 5421
__min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 5422
__comp) 
# 5423
{ 
# 5424
if (__first == __last) { 
# 5425
return __first; }  
# 5426
_ForwardIterator __result = __first; 
# 5427
while ((++__first) != __last) { 
# 5428
if (__comp(__first, __result)) { 
# 5429
__result = __first; }  }  
# 5430
return __result; 
# 5431
} 
# 5440 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator> inline _ForwardIterator 
# 5443
min_element(_ForwardIterator __first, _ForwardIterator __last) 
# 5444
{ 
# 5449
; 
# 5451
return std::__min_element(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 5453
} 
# 5464 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Compare> inline _ForwardIterator 
# 5467
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 5468
__comp) 
# 5469
{ 
# 5475
; 
# 5477
return std::__min_element(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5479
} 
# 5481
template< class _ForwardIterator, class _Compare> _ForwardIterator 
# 5484
__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 5485
__comp) 
# 5486
{ 
# 5487
if (__first == __last) { return __first; }  
# 5488
_ForwardIterator __result = __first; 
# 5489
while ((++__first) != __last) { 
# 5490
if (__comp(__result, __first)) { 
# 5491
__result = __first; }  }  
# 5492
return __result; 
# 5493
} 
# 5502 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator> inline _ForwardIterator 
# 5505
max_element(_ForwardIterator __first, _ForwardIterator __last) 
# 5506
{ 
# 5511
; 
# 5513
return std::__max_element(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 5515
} 
# 5526 "/usr/include/c++/5/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Compare> inline _ForwardIterator 
# 5529
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 5530
__comp) 
# 5531
{ 
# 5537
; 
# 5539
return std::__max_element(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5541
} 
# 5544
}
# 71 "/usr/include/c++/5/cstring" 3
namespace std __attribute((__visibility__("default"))) { 
# 75
using ::memchr;
# 76
using ::memcmp;
# 77
using ::memcpy;
# 78
using ::memmove;
# 79
using ::memset;
# 80
using ::strcat;
# 81
using ::strcmp;
# 82
using ::strcoll;
# 83
using ::strcpy;
# 84
using ::strcspn;
# 85
using ::strerror;
# 86
using ::strlen;
# 87
using ::strncat;
# 88
using ::strncmp;
# 89
using ::strncpy;
# 90
using ::strspn;
# 91
using ::strtok;
# 92
using ::strxfrm;
# 93
using ::strchr;
# 94
using ::strpbrk;
# 95
using ::strrchr;
# 96
using ::strstr;
# 121 "/usr/include/c++/5/cstring" 3
}
# 64 "/usr/include/opencv2/core/cvstd.hpp" 3
namespace cv { 
# 66
static inline uchar abs(uchar a) { return a; } 
# 67
static inline ushort abs(ushort a) { return a; } 
# 68
static inline unsigned abs(unsigned a) { return a; } 
# 69
static inline uint64 abs(uint64 a) { return a; } 
# 71
using std::min;
# 72
using std::max;
# 73
using std::abs;
# 74
using std::swap;
# 75
using std::sqrt;
# 76
using std::exp;
# 77
using std::pow;
# 78
using std::log;
# 79
}
# 81
namespace cv { 
# 94 "/usr/include/opencv2/core/cvstd.hpp" 3
__attribute((visibility("default"))) void *fastMalloc(size_t bufSize); 
# 103 "/usr/include/opencv2/core/cvstd.hpp" 3
__attribute((visibility("default"))) void fastFree(void * ptr); 
# 108
template< class _Tp> class Allocator { 
# 111
public: typedef _Tp value_type; 
# 112
typedef value_type *pointer; 
# 113
typedef const value_type *const_pointer; 
# 114
typedef value_type &reference; 
# 115
typedef const value_type &const_reference; 
# 116
typedef size_t size_type; 
# 117
typedef ptrdiff_t difference_type; 
# 118
template< class U> class rebind { typedef cv::Allocator< U>  other; }; 
# 120
explicit Allocator() { } 
# 121
~Allocator() { } 
# 122
explicit Allocator(const Allocator &) { } 
# 123
template< class U> explicit 
# 124
Allocator(const cv::Allocator< U>  &) { } 
# 127
pointer address(reference r) { return &r; } 
# 128
const_pointer address(const_reference r) { return &r; } 
# 130
pointer allocate(size_type count, const void * = 0) { return reinterpret_cast< pointer>(fastMalloc(count * sizeof(_Tp))); } 
# 131
void deallocate(pointer p, size_type) { fastFree(p); } 
# 133
void construct(pointer p, const _Tp &v) { new (static_cast< void *>(p)) (_Tp)(v); } 
# 134
void destroy(pointer p) { (p->~_Tp()); } 
# 136
size_type max_size() const { return cv::max((static_cast< _Tp>(-1)) / sizeof(_Tp), 1); } 
# 137
}; 
# 143
namespace detail { 
# 147
template< class T> 
# 148
struct RefOrVoid { typedef T &type; }; 
# 151
template<> struct RefOrVoid< void>  { typedef void type; }; 
# 154
template<> struct RefOrVoid< const void>  { typedef const void type; }; 
# 157
template<> struct RefOrVoid< volatile void>  { typedef volatile void type; }; 
# 160
template<> struct RefOrVoid< const volatile void>  { typedef const volatile void type; }; 
# 163
struct PtrOwner; 
# 165
}
# 167
template< class Y> 
# 168
struct DefaultDeleter { 
# 170
void operator()(Y * p) const; 
# 171
}; 
# 260 "/usr/include/opencv2/core/cvstd.hpp" 3
template< class T> 
# 261
struct Ptr { 
# 264
typedef T element_type; 
# 268
Ptr(); 
# 283 "/usr/include/opencv2/core/cvstd.hpp" 3
template< class Y> Ptr(Y * p); 
# 293
template< class Y, class D> Ptr(Y * p, D d); 
# 309 "/usr/include/opencv2/core/cvstd.hpp" 3
Ptr(const Ptr & o); 
# 314
template< class Y> Ptr(const cv::Ptr< Y>  & o); 
# 321
template< class Y> Ptr(const cv::Ptr< Y>  & o, T * p); 
# 325
~Ptr(); 
# 332
Ptr &operator=(const Ptr & o); 
# 335
template< class Y> Ptr &operator=(const cv::Ptr< Y>  & o); 
# 341
void release(); 
# 347
template< class Y> void reset(Y * p); 
# 354
template< class Y, class D> void reset(Y * p, D d); 
# 361
void swap(Ptr & o); 
# 364
T *get() const; 
# 367
typename detail::RefOrVoid< T> ::type operator*() const; 
# 370
T *operator->() const; 
# 373
operator T *() const; 
# 376
bool empty() const; 
# 381
template< class Y> cv::Ptr< Y>  staticCast() const; 
# 385
template< class Y> cv::Ptr< Y>  constCast() const; 
# 389
template< class Y> cv::Ptr< Y>  dynamicCast() const; 
# 393
Ptr(Ptr && o); 
# 394
Ptr &operator=(Ptr && o); 
# 398
private: detail::PtrOwner *owner; 
# 399
T *stored; 
# 401
template< class Y> friend struct Ptr; 
# 403
}; 
# 406
template< class T> void swap(Ptr< T>  & ptr1, Ptr< T>  & ptr2); 
# 410
template< class T> bool operator==(const Ptr< T>  & ptr1, const Ptr< T>  & ptr2); 
# 412
template< class T> bool operator!=(const Ptr< T>  & ptr1, const Ptr< T>  & ptr2); 
# 421
template< class T> Ptr< T>  makePtr(); 
# 424
template< class T, class A1> Ptr< T>  makePtr(const A1 & a1); 
# 427
template< class T, class A1, class A2> Ptr< T>  makePtr(const A1 & a1, const A2 & a2); 
# 430
template< class T, class A1, class A2, class A3> Ptr< T>  makePtr(const A1 & a1, const A2 & a2, const A3 & a3); 
# 433
template< class T, class A1, class A2, class A3, class A4> Ptr< T>  makePtr(const A1 & a1, const A2 & a2, const A3 & a3, const A4 & a4); 
# 436
template< class T, class A1, class A2, class A3, class A4, class A5> Ptr< T>  makePtr(const A1 & a1, const A2 & a2, const A3 & a3, const A4 & a4, const A5 & a5); 
# 439
template< class T, class A1, class A2, class A3, class A4, class A5, class A6> Ptr< T>  makePtr(const A1 & a1, const A2 & a2, const A3 & a3, const A4 & a4, const A5 & a5, const A6 & a6); 
# 442
template< class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7> Ptr< T>  makePtr(const A1 & a1, const A2 & a2, const A3 & a3, const A4 & a4, const A5 & a5, const A6 & a6, const A7 & a7); 
# 445
template< class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> Ptr< T>  makePtr(const A1 & a1, const A2 & a2, const A3 & a3, const A4 & a4, const A5 & a5, const A6 & a6, const A7 & a7, const A8 & a8); 
# 448
template< class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> Ptr< T>  makePtr(const A1 & a1, const A2 & a2, const A3 & a3, const A4 & a4, const A5 & a5, const A6 & a6, const A7 & a7, const A8 & a8, const A9 & a9); 
# 451
template< class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10> Ptr< T>  makePtr(const A1 & a1, const A2 & a2, const A3 & a3, const A4 & a4, const A5 & a5, const A6 & a6, const A7 & a7, const A8 & a8, const A9 & a9, const A10 & a10); 
# 456
class __attribute((visibility("default"))) FileNode; 
# 458
class __attribute((visibility("default"))) String { 
# 461
public: typedef char value_type; 
# 462
typedef char &reference; 
# 463
typedef const char &const_reference; 
# 464
typedef char *pointer; 
# 465
typedef const char *const_pointer; 
# 466
typedef ptrdiff_t difference_type; 
# 467
typedef size_t size_type; 
# 468
typedef char *iterator; 
# 469
typedef const char *const_iterator; 
# 471
static const size_t npos = ((size_t)(-1)); 
# 473
inline String(); 
# 474
inline String(const String & str); 
# 475
inline String(const String & str, size_t pos, size_t len = npos); 
# 476
inline String(const char * s); 
# 477
inline String(const char * s, size_t n); 
# 478
inline String(size_t n, char c); 
# 479
inline String(const char * first, const char * last); 
# 480
template< class Iterator> inline String(Iterator first, Iterator last); 
# 481
inline explicit String(const FileNode & fn); 
# 482
inline ~String(); 
# 484
inline String &operator=(const String & str); 
# 485
inline String &operator=(const char * s); 
# 486
inline String &operator=(char c); 
# 488
inline String &operator+=(const String & str); 
# 489
inline String &operator+=(const char * s); 
# 490
inline String &operator+=(char c); 
# 492
inline size_t size() const; 
# 493
inline size_t length() const; 
# 495
inline char operator[](size_t idx) const; 
# 496
inline char operator[](int idx) const; 
# 498
inline const char *begin() const; 
# 499
inline const char *end() const; 
# 501
inline const char *c_str() const; 
# 503
inline bool empty() const; 
# 504
inline void clear(); 
# 506
inline int compare(const char * s) const; 
# 507
inline int compare(const String & str) const; 
# 509
inline void swap(String & str); 
# 510
inline String substr(size_t pos = 0, size_t len = npos) const; 
# 512
inline size_t find(const char * s, size_t pos, size_t n) const; 
# 513
inline size_t find(char c, size_t pos = 0) const; 
# 514
inline size_t find(const String & str, size_t pos = 0) const; 
# 515
inline size_t find(const char * s, size_t pos = 0) const; 
# 517
inline size_t rfind(const char * s, size_t pos, size_t n) const; 
# 518
inline size_t rfind(char c, size_t pos = npos) const; 
# 519
inline size_t rfind(const String & str, size_t pos = npos) const; 
# 520
inline size_t rfind(const char * s, size_t pos = npos) const; 
# 522
inline size_t find_first_of(const char * s, size_t pos, size_t n) const; 
# 523
inline size_t find_first_of(char c, size_t pos = 0) const; 
# 524
inline size_t find_first_of(const String & str, size_t pos = 0) const; 
# 525
inline size_t find_first_of(const char * s, size_t pos = 0) const; 
# 527
inline size_t find_last_of(const char * s, size_t pos, size_t n) const; 
# 528
inline size_t find_last_of(char c, size_t pos = npos) const; 
# 529
inline size_t find_last_of(const String & str, size_t pos = npos) const; 
# 530
inline size_t find_last_of(const char * s, size_t pos = npos) const; 
# 532
friend inline String operator+(const String & lhs, const String & rhs); 
# 533
friend inline String operator+(const String & lhs, const char * rhs); 
# 534
friend inline String operator+(const char * lhs, const String & rhs); 
# 535
friend inline String operator+(const String & lhs, char rhs); 
# 536
friend inline String operator+(char lhs, const String & rhs); 
# 538
inline String toLowerCase() const; 
# 540
inline String(const std::__cxx11::string & str); 
# 541
inline String(const std::__cxx11::string & str, size_t pos, size_t len = npos); 
# 542
inline String &operator=(const std::__cxx11::string & str); 
# 543
inline String &operator+=(const std::__cxx11::string & str); 
# 544
inline operator std::__cxx11::string() const; 
# 546
friend inline String operator+(const String & lhs, const std::__cxx11::string & rhs); 
# 547
friend inline String operator+(const std::__cxx11::string & lhs, const String & rhs); 
# 550
private: char *cstr_; 
# 551
size_t len_; 
# 553
char *allocate(size_t len); 
# 554
void deallocate(); 
# 556
String(int); 
# 557
}; 
# 566
inline String::String() : cstr_((0)), len_((0)) 
# 568
{ } 
# 571
inline String::String(const String &str) : cstr_(str.cstr_), len_(str.len_) 
# 573
{ 
# 574
if (cstr_) { 
# 575
(int)__atomic_fetch_add((unsigned *)(((int *)(cstr_)) - 1), (unsigned)1, 4); }  
# 576
} 
# 579
inline String::String(const String &str, size_t pos, size_t len) : cstr_((0)), len_((0)) 
# 581
{ 
# 582
pos = min(pos, str.len_); 
# 583
len = min((str.len_) - pos, len); 
# 584
if (!len) { return; }  
# 585
if (len == (str.len_)) 
# 586
{ 
# 587
(int)__atomic_fetch_add((unsigned *)(((int *)(str.cstr_)) - 1), (unsigned)1, 4); 
# 588
(cstr_) = (str.cstr_); 
# 589
(len_) = (str.len_); 
# 590
return; 
# 591
}  
# 592
memcpy(this->allocate(len), (str.cstr_) + pos, len); 
# 593
} 
# 596
inline String::String(const char *s) : cstr_((0)), len_((0)) 
# 598
{ 
# 599
if (!s) { return; }  
# 600
size_t len = strlen(s); 
# 601
if (!len) { return; }  
# 602
memcpy(this->allocate(len), s, len); 
# 603
} 
# 606
inline String::String(const char *s, size_t n) : cstr_((0)), len_((0)) 
# 608
{ 
# 609
if (!n) { return; }  
# 610
if (!s) { return; }  
# 611
memcpy(this->allocate(n), s, n); 
# 612
} 
# 615
inline String::String(size_t n, char c) : cstr_((0)), len_((0)) 
# 617
{ 
# 618
if (!n) { return; }  
# 619
memset(this->allocate(n), c, n); 
# 620
} 
# 623
inline String::String(const char *first, const char *last) : cstr_((0)), len_((0)) 
# 625
{ 
# 626
size_t len = (size_t)(last - first); 
# 627
if (!len) { return; }  
# 628
memcpy(this->allocate(len), first, len); 
# 629
} 
# 631
template< class Iterator> inline 
# 632
String::String(Iterator first, Iterator last) : cstr_((0)), len_((0)) 
# 634
{ 
# 635
size_t len = (size_t)(last - first); 
# 636
if (!len) { return; }  
# 637
char *str = this->allocate(len); 
# 638
while (first != last) 
# 639
{ 
# 640
(*(str++)) = (*first); 
# 641
++first; 
# 642
}  
# 643
} 
# 646
inline String::~String() 
# 647
{ 
# 648
this->deallocate(); 
# 649
} 
# 652
inline String &String::operator=(const String &str) 
# 653
{ 
# 654
if ((&str) == this) { return *this; }  
# 656
this->deallocate(); 
# 657
if (str.cstr_) { (int)__atomic_fetch_add((unsigned *)(((int *)(str.cstr_)) - 1), (unsigned)1, 4); }  
# 658
(cstr_) = (str.cstr_); 
# 659
(len_) = (str.len_); 
# 660
return *this; 
# 661
} 
# 664
inline String &String::operator=(const char *s) 
# 665
{ 
# 666
this->deallocate(); 
# 667
if (!s) { return *this; }  
# 668
size_t len = strlen(s); 
# 669
if (len) { memcpy(this->allocate(len), s, len); }  
# 670
return *this; 
# 671
} 
# 674
inline String &String::operator=(char c) 
# 675
{ 
# 676
this->deallocate(); 
# 677
(this->allocate(1)[0]) = c; 
# 678
return *this; 
# 679
} 
# 682
inline String &String::operator+=(const String &str) 
# 683
{ 
# 684
((*this) = (((*this) + str))); 
# 685
return *this; 
# 686
} 
# 689
inline String &String::operator+=(const char *s) 
# 690
{ 
# 691
((*this) = (((*this) + s))); 
# 692
return *this; 
# 693
} 
# 696
inline String &String::operator+=(char c) 
# 697
{ 
# 698
((*this) = (((*this) + c))); 
# 699
return *this; 
# 700
} 
# 703
inline size_t String::size() const 
# 704
{ 
# 705
return len_; 
# 706
} 
# 709
inline size_t String::length() const 
# 710
{ 
# 711
return len_; 
# 712
} 
# 715
inline char String::operator[](size_t idx) const 
# 716
{ 
# 717
return (cstr_)[idx]; 
# 718
} 
# 721
inline char String::operator[](int idx) const 
# 722
{ 
# 723
return (cstr_)[idx]; 
# 724
} 
# 727
inline const char *String::begin() const 
# 728
{ 
# 729
return cstr_; 
# 730
} 
# 733
inline const char *String::end() const 
# 734
{ 
# 735
return (len_) ? (cstr_) + (len_) : (__null); 
# 736
} 
# 739
inline bool String::empty() const 
# 740
{ 
# 741
return (len_) == (0); 
# 742
} 
# 745
inline const char *String::c_str() const 
# 746
{ 
# 747
return (cstr_) ? cstr_ : (""); 
# 748
} 
# 751
inline void String::swap(String &str) 
# 752
{ 
# 753
cv::swap(cstr_, str.cstr_); 
# 754
cv::swap(len_, str.len_); 
# 755
} 
# 758
inline void String::clear() 
# 759
{ 
# 760
this->deallocate(); 
# 761
} 
# 764
inline int String::compare(const char *s) const 
# 765
{ 
# 766
if ((cstr_) == s) { return 0; }  
# 767
return strcmp(this->c_str(), s); 
# 768
} 
# 771
inline int String::compare(const String &str) const 
# 772
{ 
# 773
if ((cstr_) == (str.cstr_)) { return 0; }  
# 774
return strcmp(this->c_str(), str.c_str()); 
# 775
} 
# 778
inline String String::substr(size_t pos, size_t len) const 
# 779
{ 
# 780
return String(*this, pos, len); 
# 781
} 
# 784
inline size_t String::find(const char *s, size_t pos, size_t n) const 
# 785
{ 
# 786
if ((n == (0)) || ((pos + n) > (len_))) { return npos; }  
# 787
const char *lmax = ((cstr_) + (len_)) - n; 
# 788
for (const char *i = (cstr_) + pos; i <= lmax; ++i) 
# 789
{ 
# 790
size_t j = (0); 
# 791
while ((j < n) && ((s[j]) == (i[j]))) { ++j; }  
# 792
if (j == n) { return (size_t)(i - (cstr_)); }  
# 793
}  
# 794
return npos; 
# 795
} 
# 798
inline size_t String::find(char c, size_t pos) const 
# 799
{ 
# 800
return this->find(&c, pos, 1); 
# 801
} 
# 804
inline size_t String::find(const String &str, size_t pos) const 
# 805
{ 
# 806
return this->find(str.c_str(), pos, str.len_); 
# 807
} 
# 810
inline size_t String::find(const char *s, size_t pos) const 
# 811
{ 
# 812
if ((pos >= (len_)) || (!(s[0]))) { return npos; }  
# 813
const char *lmax = (cstr_) + (len_); 
# 814
for (const char *i = (cstr_) + pos; i < lmax; ++i) 
# 815
{ 
# 816
size_t j = (0); 
# 817
while ((s[j]) && ((s[j]) == (i[j]))) 
# 818
{ if ((i + j) >= lmax) { return npos; }  
# 819
++j; 
# 820
}  
# 821
if (!(s[j])) { return (size_t)(i - (cstr_)); }  
# 822
}  
# 823
return npos; 
# 824
} 
# 827
inline size_t String::rfind(const char *s, size_t pos, size_t n) const 
# 828
{ 
# 829
if (n > (len_)) { return npos; }  
# 830
if (pos > ((len_) - n)) { pos = ((len_) - n); }  
# 831
for (const char *i = (cstr_) + pos; i >= (cstr_); --i) 
# 832
{ 
# 833
size_t j = (0); 
# 834
while ((j < n) && ((s[j]) == (i[j]))) { ++j; }  
# 835
if (j == n) { return (size_t)(i - (cstr_)); }  
# 836
}  
# 837
return npos; 
# 838
} 
# 841
inline size_t String::rfind(char c, size_t pos) const 
# 842
{ 
# 843
return this->rfind(&c, pos, 1); 
# 844
} 
# 847
inline size_t String::rfind(const String &str, size_t pos) const 
# 848
{ 
# 849
return this->rfind(str.c_str(), pos, str.len_); 
# 850
} 
# 853
inline size_t String::rfind(const char *s, size_t pos) const 
# 854
{ 
# 855
return this->rfind(s, pos, strlen(s)); 
# 856
} 
# 859
inline size_t String::find_first_of(const char *s, size_t pos, size_t n) const 
# 860
{ 
# 861
if ((n == (0)) || ((pos + n) > (len_))) { return npos; }  
# 862
const char *lmax = (cstr_) + (len_); 
# 863
for (const char *i = (cstr_) + pos; i < lmax; ++i) 
# 864
{ 
# 865
for (size_t j = (0); j < n; ++j) { 
# 866
if ((s[j]) == (*i)) { 
# 867
return (size_t)(i - (cstr_)); }  }  
# 868
}  
# 869
return npos; 
# 870
} 
# 873
inline size_t String::find_first_of(char c, size_t pos) const 
# 874
{ 
# 875
return this->find_first_of(&c, pos, 1); 
# 876
} 
# 879
inline size_t String::find_first_of(const String &str, size_t pos) const 
# 880
{ 
# 881
return this->find_first_of(str.c_str(), pos, str.len_); 
# 882
} 
# 885
inline size_t String::find_first_of(const char *s, size_t pos) const 
# 886
{ 
# 887
if ((len_) == (0)) { return npos; }  
# 888
if ((pos >= (len_)) || (!(s[0]))) { return npos; }  
# 889
const char *lmax = (cstr_) + (len_); 
# 890
for (const char *i = (cstr_) + pos; i < lmax; ++i) 
# 891
{ 
# 892
for (size_t j = (0); s[j]; ++j) { 
# 893
if ((s[j]) == (*i)) { 
# 894
return (size_t)(i - (cstr_)); }  }  
# 895
}  
# 896
return npos; 
# 897
} 
# 900
inline size_t String::find_last_of(const char *s, size_t pos, size_t n) const 
# 901
{ 
# 902
if ((len_) == (0)) { return npos; }  
# 903
if (pos >= (len_)) { pos = ((len_) - (1)); }  
# 904
for (const char *i = (cstr_) + pos; i >= (cstr_); --i) 
# 905
{ 
# 906
for (size_t j = (0); j < n; ++j) { 
# 907
if ((s[j]) == (*i)) { 
# 908
return (size_t)(i - (cstr_)); }  }  
# 909
}  
# 910
return npos; 
# 911
} 
# 914
inline size_t String::find_last_of(char c, size_t pos) const 
# 915
{ 
# 916
return this->find_last_of(&c, pos, 1); 
# 917
} 
# 920
inline size_t String::find_last_of(const String &str, size_t pos) const 
# 921
{ 
# 922
return this->find_last_of(str.c_str(), pos, str.len_); 
# 923
} 
# 926
inline size_t String::find_last_of(const char *s, size_t pos) const 
# 927
{ 
# 928
if ((len_) == (0)) { return npos; }  
# 929
if (pos >= (len_)) { pos = ((len_) - (1)); }  
# 930
for (const char *i = (cstr_) + pos; i >= (cstr_); --i) 
# 931
{ 
# 932
for (size_t j = (0); s[j]; ++j) { 
# 933
if ((s[j]) == (*i)) { 
# 934
return (size_t)(i - (cstr_)); }  }  
# 935
}  
# 936
return npos; 
# 937
} 
# 940
inline String String::toLowerCase() const 
# 941
{ 
# 942
if (!(cstr_)) { 
# 943
return String(); }  
# 944
String res(cstr_, len_); 
# 945
for (size_t i = (0); i < (len_); ++i) { 
# 946
((res.cstr_)[i]) = ((char)::tolower((cstr_)[i])); }  
# 948
return res; 
# 949
} 
# 959 "/usr/include/opencv2/core/cvstd.hpp" 3
inline String operator+(const String &lhs, const String &rhs) 
# 960
{ 
# 961
String s; 
# 962
s.allocate((lhs.len_) + (rhs.len_)); 
# 963
if (lhs.len_) { memcpy(s.cstr_, lhs.cstr_, lhs.len_); }  
# 964
if (rhs.len_) { memcpy((s.cstr_) + (lhs.len_), rhs.cstr_, rhs.len_); }  
# 965
return s; 
# 966
} 
# 969
inline String operator+(const String &lhs, const char *rhs) 
# 970
{ 
# 971
String s; 
# 972
size_t rhslen = strlen(rhs); 
# 973
s.allocate((lhs.len_) + rhslen); 
# 974
if (lhs.len_) { memcpy(s.cstr_, lhs.cstr_, lhs.len_); }  
# 975
if (rhslen) { memcpy((s.cstr_) + (lhs.len_), rhs, rhslen); }  
# 976
return s; 
# 977
} 
# 980
inline String operator+(const char *lhs, const String &rhs) 
# 981
{ 
# 982
String s; 
# 983
size_t lhslen = strlen(lhs); 
# 984
s.allocate(lhslen + (rhs.len_)); 
# 985
if (lhslen) { memcpy(s.cstr_, lhs, lhslen); }  
# 986
if (rhs.len_) { memcpy((s.cstr_) + lhslen, rhs.cstr_, rhs.len_); }  
# 987
return s; 
# 988
} 
# 991
inline String operator+(const String &lhs, char rhs) 
# 992
{ 
# 993
String s; 
# 994
s.allocate((lhs.len_) + (1)); 
# 995
if (lhs.len_) { memcpy(s.cstr_, lhs.cstr_, lhs.len_); }  
# 996
((s.cstr_)[lhs.len_]) = rhs; 
# 997
return s; 
# 998
} 
# 1001
inline String operator+(char lhs, const String &rhs) 
# 1002
{ 
# 1003
String s; 
# 1004
s.allocate((rhs.len_) + (1)); 
# 1005
((s.cstr_)[0]) = lhs; 
# 1006
if (rhs.len_) { memcpy((s.cstr_) + 1, rhs.cstr_, rhs.len_); }  
# 1007
return s; 
# 1008
} 
# 1010
static inline bool operator==(const String &lhs, const String &rhs) { return 0 == lhs.compare(rhs); } 
# 1011
static inline bool operator==(const char *lhs, const String &rhs) { return 0 == rhs.compare(lhs); } 
# 1012
static inline bool operator==(const String &lhs, const char *rhs) { return 0 == lhs.compare(rhs); } 
# 1013
static inline bool operator!=(const String &lhs, const String &rhs) { return 0 != lhs.compare(rhs); } 
# 1014
static inline bool operator!=(const char *lhs, const String &rhs) { return 0 != rhs.compare(lhs); } 
# 1015
static inline bool operator!=(const String &lhs, const char *rhs) { return 0 != lhs.compare(rhs); } 
# 1016
static inline bool operator<(const String &lhs, const String &rhs) { return lhs.compare(rhs) < 0; } 
# 1017
static inline bool operator<(const char *lhs, const String &rhs) { return rhs.compare(lhs) > 0; } 
# 1018
static inline bool operator<(const String &lhs, const char *rhs) { return lhs.compare(rhs) < 0; } 
# 1019
static inline bool operator<=(const String &lhs, const String &rhs) { return lhs.compare(rhs) <= 0; } 
# 1020
static inline bool operator<=(const char *lhs, const String &rhs) { return rhs.compare(lhs) >= 0; } 
# 1021
static inline bool operator<=(const String &lhs, const char *rhs) { return lhs.compare(rhs) <= 0; } 
# 1022
static inline bool operator>(const String &lhs, const String &rhs) { return lhs.compare(rhs) > 0; } 
# 1023
static inline bool operator>(const char *lhs, const String &rhs) { return rhs.compare(lhs) < 0; } 
# 1024
static inline bool operator>(const String &lhs, const char *rhs) { return lhs.compare(rhs) > 0; } 
# 1025
static inline bool operator>=(const String &lhs, const String &rhs) { return lhs.compare(rhs) >= 0; } 
# 1026
static inline bool operator>=(const char *lhs, const String &rhs) { return rhs.compare(lhs) <= 0; } 
# 1027
static inline bool operator>=(const String &lhs, const char *rhs) { return lhs.compare(rhs) >= 0; } 
# 1031
}
# 1033
namespace std { 
# 1035
static inline void swap(cv::String &a, cv::String &b) { a.swap(b); } 
# 1036
}
# 49 "/usr/include/opencv2/core/ptr.inl.hpp" 3
namespace cv { 
# 51
template< class Y> void 
# 52
DefaultDeleter< Y> ::operator()(Y *p) const 
# 53
{ 
# 54
delete p; 
# 55
} 
# 57
namespace detail { 
# 60
struct PtrOwner { 
# 62
PtrOwner() : refCount((1)) 
# 63
{ } 
# 65
void incRef() 
# 66
{ 
# 67
(int)__atomic_fetch_add((unsigned *)(&(refCount)), (unsigned)1, 4); 
# 68
} 
# 70
void decRef() 
# 71
{ 
# 72
if (((int)__atomic_fetch_add((unsigned *)(&(refCount)), (unsigned)(-1), 4)) == 1) { this->deleteSelf(); }  
# 73
} 
# 78
protected: virtual ~PtrOwner() 
# 79
{ } 
# 81
virtual void deleteSelf() = 0; 
# 84
private: unsigned refCount; 
# 87
PtrOwner(const PtrOwner &); 
# 88
PtrOwner &operator=(const PtrOwner &); 
# 89
}; 
# 91
template< class Y, class D> 
# 92
struct PtrOwnerImpl : public PtrOwner { 
# 94
PtrOwnerImpl(Y *p, D d) : owned(p), deleter(d) 
# 95
{ } 
# 97
virtual void deleteSelf() 
# 98
{ 
# 99
(deleter)(owned); 
# 100
delete this; 
# 101
} 
# 104
private: Y *owned; 
# 105
D deleter; 
# 106
}; 
# 109
}
# 111
template< class T> 
# 112
Ptr< T> ::Ptr() : owner((__null)), stored((__null)) 
# 113
{ } 
# 115
template< class T> 
# 116
template< class Y> 
# 117
Ptr< T> ::Ptr(Y *p) : owner((p) ? new detail::PtrOwnerImpl< Y, DefaultDeleter< Y> > (p, DefaultDeleter< Y> ()) : __null), stored(p) 
# 122
{ } 
# 124
template< class T> 
# 125
template< class Y, class D> 
# 126
Ptr< T> ::Ptr(Y *p, D d) : owner((p) ? new detail::PtrOwnerImpl< Y, D> (p, d) : __null), stored(p) 
# 131
{ } 
# 133
template< class T> 
# 134
Ptr< T> ::Ptr(const Ptr &o) : owner(((o.owner))), stored(((o.stored))) 
# 135
{ 
# 136
if (owner) { (owner)->incRef(); }  
# 137
} 
# 139
template< class T> 
# 140
template< class Y> 
# 141
Ptr< T> ::Ptr(const cv::Ptr< Y>  &o) : owner(((o.owner))), stored(((o.stored))) 
# 142
{ 
# 143
if (owner) { (owner)->incRef(); }  
# 144
} 
# 146
template< class T> 
# 147
template< class Y> 
# 148
Ptr< T> ::Ptr(const cv::Ptr< Y>  &o, T *p) : owner(((o.owner))), stored(p) 
# 149
{ 
# 150
if (owner) { (owner)->incRef(); }  
# 151
} 
# 153
template< class T> 
# 154
Ptr< T> ::~Ptr() 
# 155
{ 
# 156
release(); 
# 157
} 
# 159
template< class T> Ptr< T>  &
# 160
Ptr< T> ::operator=(const Ptr &o) 
# 161
{ 
# 162
(((Ptr)(o)).swap(*this)); 
# 163
return *this; 
# 164
} 
# 166
template< class T> 
# 167
template< class Y> Ptr< T>  &
# 168
Ptr< T> ::operator=(const cv::Ptr< Y>  &o) 
# 169
{ 
# 170
(((Ptr)(o)).swap(*this)); 
# 171
return *this; 
# 172
} 
# 174
template< class T> void 
# 175
Ptr< T> ::release() 
# 176
{ 
# 177
if (owner) { (owner)->decRef(); }  
# 178
(owner) = (__null); 
# 179
(stored) = __null; 
# 180
} 
# 182
template< class T> 
# 183
template< class Y> void 
# 184
Ptr< T> ::reset(Y *p) 
# 185
{ 
# 186
(((Ptr)(p)).swap(*this)); 
# 187
} 
# 189
template< class T> 
# 190
template< class Y, class D> void 
# 191
Ptr< T> ::reset(Y *p, D d) 
# 192
{ 
# 193
(Ptr(p, d).swap(*this)); 
# 194
} 
# 196
template< class T> void 
# 197
Ptr< T> ::swap(Ptr &o) 
# 198
{ 
# 199
std::swap(owner, (o.owner)); 
# 200
std::swap(stored, (o.stored)); 
# 201
} 
# 203
template< class T> T *
# 204
Ptr< T> ::get() const 
# 205
{ 
# 206
return stored; 
# 207
} 
# 209
template< class T> typename detail::RefOrVoid< T> ::type 
# 210
Ptr< T> ::operator*() const 
# 211
{ 
# 212
return *(stored); 
# 213
} 
# 215
template< class T> T *
# 216
Ptr< T> ::operator->() const 
# 217
{ 
# 218
return stored; 
# 219
} 
# 221
template< class T> 
# 222
Ptr< T> ::operator T *() const 
# 223
{ 
# 224
return stored; 
# 225
} 
# 228
template< class T> bool 
# 229
Ptr< T> ::empty() const 
# 230
{ 
# 231
return !(stored); 
# 232
} 
# 234
template< class T> 
# 235
template< class Y> Ptr< Y>  
# 236
Ptr< T> ::staticCast() const 
# 237
{ 
# 238
return cv::Ptr< Y> (*this, static_cast< Y *>(stored)); 
# 239
} 
# 241
template< class T> 
# 242
template< class Y> Ptr< Y>  
# 243
Ptr< T> ::constCast() const 
# 244
{ 
# 245
return cv::Ptr< Y> (*this, const_cast< Y *>(stored)); 
# 246
} 
# 248
template< class T> 
# 249
template< class Y> Ptr< Y>  
# 250
Ptr< T> ::dynamicCast() const 
# 251
{ 
# 252
return cv::Ptr< Y> (*this, dynamic_cast< Y *>(stored)); 
# 253
} 
# 257
template< class T> 
# 258
Ptr< T> ::Ptr(Ptr &&o) : owner(((o.owner))), stored(((o.stored))) 
# 259
{ 
# 260
(o.owner) = __null; 
# 261
(o.stored) = __null; 
# 262
} 
# 264
template< class T> Ptr< T>  &
# 265
Ptr< T> ::operator=(Ptr &&o) 
# 266
{ 
# 267
if (this == (&o)) { 
# 268
return *this; }  
# 270
release(); 
# 271
(owner) = (o.owner); 
# 272
(stored) = (o.stored); 
# 273
(o.owner) = __null; 
# 274
(o.stored) = __null; 
# 275
return *this; 
# 276
} 
# 281
template< class T> void 
# 282
swap(Ptr< T>  &ptr1, Ptr< T>  &ptr2) { 
# 283
(ptr1.swap(ptr2)); 
# 284
} 
# 286
template< class T> bool 
# 287
operator==(const Ptr< T>  &ptr1, const Ptr< T>  &ptr2) 
# 288
{ 
# 289
return (ptr1.get()) == (ptr2.get()); 
# 290
} 
# 292
template< class T> bool 
# 293
operator!=(const Ptr< T>  &ptr1, const Ptr< T>  &ptr2) 
# 294
{ 
# 295
return (ptr1.get()) != (ptr2.get()); 
# 296
} 
# 298
template< class T> Ptr< T>  
# 299
makePtr() 
# 300
{ 
# 301
return ((Ptr< T> )(new (T)())); 
# 302
} 
# 304
template< class T, class A1> Ptr< T>  
# 305
makePtr(const A1 &a1) 
# 306
{ 
# 307
return ((Ptr< T> )(new (T)(a1))); 
# 308
} 
# 310
template< class T, class A1, class A2> Ptr< T>  
# 311
makePtr(const A1 &a1, const A2 &a2) 
# 312
{ 
# 313
return ((Ptr< T> )(new (T)(a1, a2))); 
# 314
} 
# 316
template< class T, class A1, class A2, class A3> Ptr< T>  
# 317
makePtr(const A1 &a1, const A2 &a2, const A3 &a3) 
# 318
{ 
# 319
return ((Ptr< T> )(new (T)(a1, a2, a3))); 
# 320
} 
# 322
template< class T, class A1, class A2, class A3, class A4> Ptr< T>  
# 323
makePtr(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4) 
# 324
{ 
# 325
return ((Ptr< T> )(new (T)(a1, a2, a3, a4))); 
# 326
} 
# 328
template< class T, class A1, class A2, class A3, class A4, class A5> Ptr< T>  
# 329
makePtr(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5) 
# 330
{ 
# 331
return ((Ptr< T> )(new (T)(a1, a2, a3, a4, a5))); 
# 332
} 
# 334
template< class T, class A1, class A2, class A3, class A4, class A5, class A6> Ptr< T>  
# 335
makePtr(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6) 
# 336
{ 
# 337
return ((Ptr< T> )(new (T)(a1, a2, a3, a4, a5, a6))); 
# 338
} 
# 340
template< class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7> Ptr< T>  
# 341
makePtr(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7) 
# 342
{ 
# 343
return ((Ptr< T> )(new (T)(a1, a2, a3, a4, a5, a6, a7))); 
# 344
} 
# 346
template< class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8> Ptr< T>  
# 347
makePtr(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8) 
# 348
{ 
# 349
return ((Ptr< T> )(new (T)(a1, a2, a3, a4, a5, a6, a7, a8))); 
# 350
} 
# 352
template< class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9> Ptr< T>  
# 353
makePtr(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9) 
# 354
{ 
# 355
return ((Ptr< T> )(new (T)(a1, a2, a3, a4, a5, a6, a7, a8, a9))); 
# 356
} 
# 358
template< class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10> Ptr< T>  
# 359
makePtr(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10) 
# 360
{ 
# 361
return ((Ptr< T> )(new (T)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10))); 
# 362
} 
# 364
template< class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11> Ptr< T>  
# 365
makePtr(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11) 
# 366
{ 
# 367
return ((Ptr< T> )(new (T)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11))); 
# 368
} 
# 370
template< class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12> Ptr< T>  
# 371
makePtr(const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12) 
# 372
{ 
# 373
return ((Ptr< T> )(new (T)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12))); 
# 374
} 
# 375
}
# 60 "/usr/include/opencv2/core/base.hpp" 3
namespace cv { 
# 66
namespace Error { 
# 68
enum Code { 
# 69
StsOk, 
# 70
StsBackTrace = (-1), 
# 71
StsError = (-2), 
# 72
StsInternal = (-3), 
# 73
StsNoMem = (-4), 
# 74
StsBadArg = (-5), 
# 75
StsBadFunc = (-6), 
# 76
StsNoConv = (-7), 
# 77
StsAutoTrace = (-8), 
# 78
HeaderIsNull = (-9), 
# 79
BadImageSize = (-10), 
# 80
BadOffset = (-11), 
# 81
BadDataPtr = (-12), 
# 82
BadStep = (-13), 
# 83
BadModelOrChSeq = (-14), 
# 84
BadNumChannels = (-15), 
# 85
BadNumChannel1U = (-16), 
# 86
BadDepth = (-17), 
# 87
BadAlphaChannel = (-18), 
# 88
BadOrder = (-19), 
# 89
BadOrigin = (-20), 
# 90
BadAlign = (-21), 
# 91
BadCallBack = (-22), 
# 92
BadTileSize = (-23), 
# 93
BadCOI = (-24), 
# 94
BadROISize = (-25), 
# 95
MaskIsTiled = (-26), 
# 96
StsNullPtr = (-27), 
# 97
StsVecLengthErr = (-28), 
# 98
StsFilterStructContentErr = (-29), 
# 99
StsKernelStructContentErr = (-30), 
# 100
StsFilterOffsetErr = (-31), 
# 101
StsBadSize = (-201), 
# 102
StsDivByZero = (-202), 
# 103
StsInplaceNotSupported = (-203), 
# 104
StsObjectNotFound = (-204), 
# 105
StsUnmatchedFormats = (-205), 
# 106
StsBadFlag = (-206), 
# 107
StsBadPoint = (-207), 
# 108
StsBadMask = (-208), 
# 109
StsUnmatchedSizes = (-209), 
# 110
StsUnsupportedFormat = (-210), 
# 111
StsOutOfRange = (-211), 
# 112
StsParseError = (-212), 
# 113
StsNotImplemented = (-213), 
# 114
StsBadMemBlock = (-214), 
# 115
StsAssert = (-215), 
# 116
GpuNotSupported = (-216), 
# 117
GpuApiCallError = (-217), 
# 118
OpenGlNotSupported = (-218), 
# 119
OpenGlApiCallError = (-219), 
# 120
OpenCLApiCallError = (-220), 
# 121
OpenCLDoubleNotSupported = (-221), 
# 122
OpenCLInitError = (-222), 
# 123
OpenCLNoAMDBlasFft = (-223)
# 124
}; 
# 125
}
# 133
enum DecompTypes { 
# 135
DECOMP_LU, 
# 138
DECOMP_SVD, 
# 140
DECOMP_EIG, 
# 143
DECOMP_CHOLESKY, 
# 145
DECOMP_QR, 
# 151
DECOMP_NORMAL = 16
# 152
}; 
# 159
enum NormTypes { 
# 168 "/usr/include/opencv2/core/base.hpp" 3
NORM_INF = 1, 
# 176
NORM_L1, 
# 185 "/usr/include/opencv2/core/base.hpp" 3
NORM_L2 = 4, 
# 194 "/usr/include/opencv2/core/base.hpp" 3
NORM_L2SQR, 
# 199
NORM_HAMMING, 
# 204
NORM_HAMMING2, 
# 205
NORM_TYPE_MASK = 7, 
# 206
NORM_RELATIVE, 
# 207
NORM_MINMAX = 32
# 208
}; 
# 211
enum CmpTypes { CMP_EQ, 
# 212
CMP_GT, 
# 213
CMP_GE, 
# 214
CMP_LT, 
# 215
CMP_LE, 
# 216
CMP_NE
# 217
}; 
# 220
enum GemmFlags { GEMM_1_T = 1, 
# 221
GEMM_2_T, 
# 222
GEMM_3_T = 4
# 223
}; 
# 225
enum DftFlags { 
# 228
DFT_INVERSE = 1, 
# 231
DFT_SCALE, 
# 236
DFT_ROWS = 4, 
# 243
DFT_COMPLEX_OUTPUT = 16, 
# 252 "/usr/include/opencv2/core/base.hpp" 3
DFT_REAL_OUTPUT = 32, 
# 256
DFT_COMPLEX_INPUT = 64, 
# 258
DCT_INVERSE = 1, 
# 263
DCT_ROWS = 4
# 264
}; 
# 268
enum BorderTypes { 
# 269
BORDER_CONSTANT, 
# 270
BORDER_REPLICATE, 
# 271
BORDER_REFLECT, 
# 272
BORDER_WRAP, 
# 273
BORDER_REFLECT_101, 
# 274
BORDER_TRANSPARENT, 
# 276
BORDER_REFLECT101 = 4, 
# 277
BORDER_DEFAULT = 4, 
# 278
BORDER_ISOLATED = 16
# 279
}; 
# 360 "/usr/include/opencv2/core/base.hpp" 3
__attribute((visibility("default"))) void error(int _code, const String & _err, const char * _func, const char * _file, int _line); 
# 370 "/usr/include/opencv2/core/base.hpp" 3
__attribute((__noreturn__)) static inline void errorNoReturn(int _code, const String &_err, const char *_func, const char *_file, int _line) 
# 371
{ 
# 372
error(_code, _err, _func, _file, _line); 
# 376
__builtin_trap(); 
# 380
} 
# 474 "/usr/include/opencv2/core/base.hpp" 3
struct __attribute((visibility("default"))) Hamming { 
# 476
enum { normType = 6}; 
# 477
typedef unsigned char ValueType; 
# 478
typedef int ResultType; 
# 482
ResultType operator()(const unsigned char * a, const unsigned char * b, int size) const; 
# 483
}; 
# 485
typedef Hamming HammingLUT; 
# 489
template< class _Tp> inline _Tp cv_abs(_Tp x) { return std::abs(x); } 
# 490
inline int cv_abs(uchar x) { return x; } 
# 491
inline int cv_abs(schar x) { return std::abs(x); } 
# 492
inline int cv_abs(ushort x) { return x; } 
# 493
inline int cv_abs(short x) { return std::abs(x); } 
# 495
template< class _Tp, class _AccTp> static inline _AccTp 
# 496
normL2Sqr(const _Tp *a, int n) 
# 497
{ 
# 498
_AccTp s = (0); 
# 499
int i = 0; 
# 501
for (; i <= (n - 4); i += 4) 
# 502
{ 
# 503
_AccTp v0 = a[i], v1 = a[i + 1], v2 = a[i + 2], v3 = a[i + 3]; 
# 504
s += ((((v0 * v0) + (v1 * v1)) + (v2 * v2)) + (v3 * v3)); 
# 505
}  
# 507
for (; i < n; i++) 
# 508
{ 
# 509
_AccTp v = a[i]; 
# 510
s += (v * v); 
# 511
}  
# 512
return s; 
# 513
} 
# 515
template< class _Tp, class _AccTp> static inline _AccTp 
# 516
normL1(const _Tp *a, int n) 
# 517
{ 
# 518
_AccTp s = (0); 
# 519
int i = 0; 
# 521
for (; i <= (n - 4); i += 4) 
# 522
{ 
# 523
s += (((((_AccTp)cv_abs(a[i])) + ((_AccTp)cv_abs(a[i + 1]))) + ((_AccTp)cv_abs(a[i + 2]))) + ((_AccTp)cv_abs(a[i + 3]))); 
# 525
}  
# 527
for (; i < n; i++) { 
# 528
s += cv_abs(a[i]); }  
# 529
return s; 
# 530
} 
# 532
template< class _Tp, class _AccTp> static inline _AccTp 
# 533
normInf(const _Tp *a, int n) 
# 534
{ 
# 535
_AccTp s = (0); 
# 536
for (int i = 0; i < n; i++) { 
# 537
s = std::max(s, (_AccTp)cv_abs(a[i])); }  
# 538
return s; 
# 539
} 
# 541
template< class _Tp, class _AccTp> static inline _AccTp 
# 542
normL2Sqr(const _Tp *a, const _Tp *b, int n) 
# 543
{ 
# 544
_AccTp s = (0); 
# 545
int i = 0; 
# 547
for (; i <= (n - 4); i += 4) 
# 548
{ 
# 549
_AccTp v0 = (_AccTp)((a[i]) - (b[i])), v1 = (_AccTp)((a[i + 1]) - (b[i + 1])), v2 = (_AccTp)((a[i + 2]) - (b[i + 2])), v3 = (_AccTp)((a[i + 3]) - (b[i + 3])); 
# 550
s += ((((v0 * v0) + (v1 * v1)) + (v2 * v2)) + (v3 * v3)); 
# 551
}  
# 553
for (; i < n; i++) 
# 554
{ 
# 555
_AccTp v = (_AccTp)((a[i]) - (b[i])); 
# 556
s += (v * v); 
# 557
}  
# 558
return s; 
# 559
} 
# 561
static inline float normL2Sqr(const float *a, const float *b, int n) 
# 562
{ 
# 563
float s = (0.0F); 
# 564
for (int i = 0; i < n; i++) 
# 565
{ 
# 566
float v = (a[i]) - (b[i]); 
# 567
s += (v * v); 
# 568
}  
# 569
return s; 
# 570
} 
# 572
template< class _Tp, class _AccTp> static inline _AccTp 
# 573
normL1(const _Tp *a, const _Tp *b, int n) 
# 574
{ 
# 575
_AccTp s = (0); 
# 576
int i = 0; 
# 578
for (; i <= (n - 4); i += 4) 
# 579
{ 
# 580
_AccTp v0 = (_AccTp)((a[i]) - (b[i])), v1 = (_AccTp)((a[i + 1]) - (b[i + 1])), v2 = (_AccTp)((a[i + 2]) - (b[i + 2])), v3 = (_AccTp)((a[i + 3]) - (b[i + 3])); 
# 581
s += (((std::abs(v0) + std::abs(v1)) + std::abs(v2)) + std::abs(v3)); 
# 582
}  
# 584
for (; i < n; i++) 
# 585
{ 
# 586
_AccTp v = (_AccTp)((a[i]) - (b[i])); 
# 587
s += std::abs(v); 
# 588
}  
# 589
return s; 
# 590
} 
# 592
inline float normL1(const float *a, const float *b, int n) 
# 593
{ 
# 594
float s = (0.0F); 
# 595
for (int i = 0; i < n; i++) 
# 596
{ 
# 597
s += std::abs((a[i]) - (b[i])); 
# 598
}  
# 599
return s; 
# 600
} 
# 602
inline int normL1(const uchar *a, const uchar *b, int n) 
# 603
{ 
# 604
int s = 0; 
# 605
for (int i = 0; i < n; i++) 
# 606
{ 
# 607
s += std::abs((a[i]) - (b[i])); 
# 608
}  
# 609
return s; 
# 610
} 
# 612
template< class _Tp, class _AccTp> static inline _AccTp 
# 613
normInf(const _Tp *a, const _Tp *b, int n) 
# 614
{ 
# 615
_AccTp s = (0); 
# 616
for (int i = 0; i < n; i++) 
# 617
{ 
# 618
_AccTp v0 = (a[i]) - (b[i]); 
# 619
s = std::max(s, std::abs(v0)); 
# 620
}  
# 621
return s; 
# 622
} 
# 631 "/usr/include/opencv2/core/base.hpp" 3
__attribute((visibility("default"))) float cubeRoot(float val); 
# 640 "/usr/include/opencv2/core/base.hpp" 3
__attribute((visibility("default"))) float fastAtan2(float y, float x); 
# 643
__attribute((visibility("default"))) int LU(float * A, size_t astep, int m, float * b, size_t bstep, int n); 
# 645
__attribute((visibility("default"))) int LU(double * A, size_t astep, int m, double * b, size_t bstep, int n); 
# 647
__attribute((visibility("default"))) bool Cholesky(float * A, size_t astep, int m, float * b, size_t bstep, int n); 
# 649
__attribute((visibility("default"))) bool Cholesky(double * A, size_t astep, int m, double * b, size_t bstep, int n); 
# 655
template< class _Tp, int cn> class Vec; 
# 656
template< class _Tp, int m, int n> class Matx; 
# 658
template< class _Tp> class Complex; 
# 659
template< class _Tp> class Point_; 
# 660
template< class _Tp> class Point3_; 
# 661
template< class _Tp> class Size_; 
# 662
template< class _Tp> class Rect_; 
# 663
template< class _Tp> class Scalar_; 
# 665
class __attribute((visibility("default"))) RotatedRect; 
# 666
class __attribute((visibility("default"))) Range; 
# 667
class __attribute((visibility("default"))) TermCriteria; 
# 668
class __attribute((visibility("default"))) KeyPoint; 
# 669
class __attribute((visibility("default"))) DMatch; 
# 670
class __attribute((visibility("default"))) RNG; 
# 672
class __attribute((visibility("default"))) Mat; 
# 673
class __attribute((visibility("default"))) MatExpr; 
# 675
class __attribute((visibility("default"))) UMat; 
# 677
class __attribute((visibility("default"))) SparseMat; 
# 678
typedef Mat MatND; 
# 680
template< class _Tp> class Mat_; 
# 681
template< class _Tp> class SparseMat_; 
# 683
class __attribute((visibility("default"))) MatConstIterator; 
# 684
class __attribute((visibility("default"))) SparseMatIterator; 
# 685
class __attribute((visibility("default"))) SparseMatConstIterator; 
# 686
template< class _Tp> class MatIterator_; 
# 687
template< class _Tp> class MatConstIterator_; 
# 688
template< class _Tp> class SparseMatIterator_; 
# 689
template< class _Tp> class SparseMatConstIterator_; 
# 691
namespace ogl { 
# 693
class __attribute((visibility("default"))) Buffer; 
# 694
class __attribute((visibility("default"))) Texture2D; 
# 695
class __attribute((visibility("default"))) Arrays; 
# 696
}
# 698
namespace cuda { 
# 700
class __attribute((visibility("default"))) GpuMat; 
# 701
class __attribute((visibility("default"))) HostMem; 
# 702
class __attribute((visibility("default"))) Stream; 
# 703
class __attribute((visibility("default"))) Event; 
# 704
}
# 706
namespace cudev { 
# 708
template< class _Tp> class GpuMat_; 
# 709
}
# 711
namespace ipp { 
# 716
__attribute((visibility("default"))) int getIppFeatures(); 
# 718
__attribute((visibility("default"))) void setIppStatus(int status, const char *const funcname = 0, const char *const filename = 0, int line = 0); 
# 720
__attribute((visibility("default"))) int getIppStatus(); 
# 721
__attribute((visibility("default"))) String getIppErrorLocation(); 
# 722
__attribute((visibility("default"))) bool useIPP(); 
# 723
__attribute((visibility("default"))) void setUseIPP(bool flag); 
# 724
__attribute((visibility("default"))) String getIppVersion(); 
# 728
__attribute((visibility("default"))) bool useIPP_NE(); 
# 729
__attribute((visibility("default"))) void setUseIPP_NE(bool flag); 
# 731
}
# 740 "/usr/include/opencv2/core/base.hpp" 3
}
# 49 "/usr/include/opencv2/core/traits.hpp" 3
namespace cv { 
# 112 "/usr/include/opencv2/core/traits.hpp" 3
template< class _Tp> class DataType { 
# 127 "/usr/include/opencv2/core/traits.hpp" 3
}; 
# 129
template<> class DataType< bool>  { 
# 132
public: typedef bool value_type; 
# 133
typedef int work_type; 
# 134
typedef value_type channel_type; 
# 135
typedef value_type vec_type; 
# 136
enum { generic_type, 
# 137
depth = 0, 
# 138
channels, 
# 139
fmt = 117, 
# 140
type = 0
# 141
}; 
# 142
}; 
# 144
template<> class DataType< unsigned char>  { 
# 147
public: typedef uchar value_type; 
# 148
typedef int work_type; 
# 149
typedef value_type channel_type; 
# 150
typedef value_type vec_type; 
# 151
enum { generic_type, 
# 152
depth = 0, 
# 153
channels, 
# 154
fmt = 117, 
# 155
type = 0
# 156
}; 
# 157
}; 
# 159
template<> class DataType< signed char>  { 
# 162
public: typedef schar value_type; 
# 163
typedef int work_type; 
# 164
typedef value_type channel_type; 
# 165
typedef value_type vec_type; 
# 166
enum { generic_type, 
# 167
depth, 
# 168
channels = 1, 
# 169
fmt = 99, 
# 170
type = 1
# 171
}; 
# 172
}; 
# 174
template<> class DataType< char>  { 
# 177
public: typedef schar value_type; 
# 178
typedef int work_type; 
# 179
typedef value_type channel_type; 
# 180
typedef value_type vec_type; 
# 181
enum { generic_type, 
# 182
depth, 
# 183
channels = 1, 
# 184
fmt = 99, 
# 185
type = 1
# 186
}; 
# 187
}; 
# 189
template<> class DataType< unsigned short>  { 
# 192
public: typedef ushort value_type; 
# 193
typedef int work_type; 
# 194
typedef value_type channel_type; 
# 195
typedef value_type vec_type; 
# 196
enum { generic_type, 
# 197
depth = 2, 
# 198
channels = 1, 
# 199
fmt = 119, 
# 200
type = 2
# 201
}; 
# 202
}; 
# 204
template<> class DataType< short>  { 
# 207
public: typedef short value_type; 
# 208
typedef int work_type; 
# 209
typedef value_type channel_type; 
# 210
typedef value_type vec_type; 
# 211
enum { generic_type, 
# 212
depth = 3, 
# 213
channels = 1, 
# 214
fmt = 115, 
# 215
type = 3
# 216
}; 
# 217
}; 
# 219
template<> class DataType< int>  { 
# 222
public: typedef int value_type; 
# 223
typedef value_type work_type; 
# 224
typedef value_type channel_type; 
# 225
typedef value_type vec_type; 
# 226
enum { generic_type, 
# 227
depth = 4, 
# 228
channels = 1, 
# 229
fmt = 105, 
# 230
type = 4
# 231
}; 
# 232
}; 
# 234
template<> class DataType< float>  { 
# 237
public: typedef float value_type; 
# 238
typedef value_type work_type; 
# 239
typedef value_type channel_type; 
# 240
typedef value_type vec_type; 
# 241
enum { generic_type, 
# 242
depth = 5, 
# 243
channels = 1, 
# 244
fmt = 102, 
# 245
type = 5
# 246
}; 
# 247
}; 
# 249
template<> class DataType< double>  { 
# 252
public: typedef double value_type; 
# 253
typedef value_type work_type; 
# 254
typedef value_type channel_type; 
# 255
typedef value_type vec_type; 
# 256
enum { generic_type, 
# 257
depth = 6, 
# 258
channels = 1, 
# 259
fmt = 100, 
# 260
type = 6
# 261
}; 
# 262
}; 
# 270
template< class _Tp> class DataDepth { 
# 274
public: enum { 
# 275
value = DataType< _Tp> ::depth, 
# 276
fmt = DataType< _Tp> ::fmt
# 277
}; 
# 278
}; 
# 337 "/usr/include/opencv2/core/traits.hpp" 3
namespace traits { 
# 339
namespace internal { 
# 354 "/usr/include/opencv2/core/traits.hpp" 3
template< class T> class CheckMember_fmt { struct Fallback { int fmt; }; struct Derived : public T, public Fallback { }; template< class U, U > struct Check; typedef char CV_NO[1]; typedef char CV_YES[2]; template< class U> static CV_NO &func(Check< int (Fallback::*), &U::fmt>  *); template< class U> static CV_YES &func(...); public: typedef CheckMember_fmt type; enum { value = sizeof(func< Derived> (0)) == sizeof(CV_YES)}; }; 
# 355
template< class T> class CheckMember_type { struct Fallback { int type; }; struct Derived : public T, public Fallback { }; template< class U, U > struct Check; typedef char CV_NO[1]; typedef char CV_YES[2]; template< class U> static CV_NO &func(Check< int (Fallback::*), &U::type>  *); template< class U> static CV_YES &func(...); public: typedef CheckMember_type type; enum { value = sizeof(func< Derived> (0)) == sizeof(CV_YES)}; }; 
# 357
}
# 360
template< class T> 
# 361
struct Depth { 
# 362
enum { value = DataType< T> ::depth}; }; 
# 364
template< class T> 
# 365
struct Type { 
# 366
enum { value = DataType< T> ::type}; }; 
# 369
template< class T, bool available = internal::CheckMember_type< DataType< T> > ::value> 
# 370
struct SafeType { }; 
# 372
template< class T> 
# 373
struct SafeType< T, false>  { 
# 374
enum { value = -1}; }; 
# 376
template< class T> 
# 377
struct SafeType< T, true>  { 
# 378
enum { value = Type< T> ::value}; }; 
# 381
template< class T, bool available = internal::CheckMember_fmt< DataType< T> > ::value> 
# 382
struct SafeFmt { }; 
# 384
template< class T> 
# 385
struct SafeFmt< T, false>  { 
# 386
enum { fmt}; }; 
# 388
template< class T> 
# 389
struct SafeFmt< T, true>  { 
# 390
enum { fmt = DataType< T> ::fmt}; }; 
# 393
}
# 395
}
# 101 "/usr/include/opencv2/core/fast_math.hpp" 3
static inline int cvRound(double value) 
# 102
{ 
# 122 "/usr/include/opencv2/core/fast_math.hpp" 3
return (int)lrint(value); 
# 129
} 
# 139 "/usr/include/opencv2/core/fast_math.hpp" 3
static inline int cvFloor(double value) 
# 140
{ 
# 141
int i = (int)value; 
# 142
return i - (i > value); 
# 143
} 
# 152 "/usr/include/opencv2/core/fast_math.hpp" 3
static inline int cvCeil(double value) 
# 153
{ 
# 154
int i = (int)value; 
# 155
return i + (i < value); 
# 156
} 
# 164
static inline int cvIsNaN(double value) 
# 165
{ 
# 166
Cv64suf ieee754; 
# 167
(ieee754.f) = value; 
# 168
return ((((unsigned)((ieee754.u) >> 32)) & (2147483647)) + (((unsigned)(ieee754.u)) != (0))) > (2146435072); 
# 170
} 
# 178
static inline int cvIsInf(double value) 
# 179
{ 
# 180
Cv64suf ieee754; 
# 181
(ieee754.f) = value; 
# 182
return ((((unsigned)((ieee754.u) >> 32)) & (2147483647)) == (2146435072)) && (((unsigned)(ieee754.u)) == (0)); 
# 184
} 
# 189
static inline int cvRound(float value) 
# 190
{ 
# 210 "/usr/include/opencv2/core/fast_math.hpp" 3
return (int)lrintf(value); 
# 217
} 
# 220
static inline int cvRound(int value) 
# 221
{ 
# 222
return value; 
# 223
} 
# 226
static inline int cvFloor(float value) 
# 227
{ 
# 228
int i = (int)value; 
# 229
return i - (i > value); 
# 230
} 
# 233
static inline int cvFloor(int value) 
# 234
{ 
# 235
return value; 
# 236
} 
# 239
static inline int cvCeil(float value) 
# 240
{ 
# 241
int i = (int)value; 
# 242
return i + (i < value); 
# 243
} 
# 246
static inline int cvCeil(int value) 
# 247
{ 
# 248
return value; 
# 249
} 
# 252
static inline int cvIsNaN(float value) 
# 253
{ 
# 254
Cv32suf ieee754; 
# 255
(ieee754.f) = value; 
# 256
return ((ieee754.u) & (2147483647)) > (2139095040); 
# 257
} 
# 260
static inline int cvIsInf(float value) 
# 261
{ 
# 262
Cv32suf ieee754; 
# 263
(ieee754.f) = value; 
# 264
return ((ieee754.u) & (2147483647)) == (2139095040); 
# 265
} 
# 51 "/usr/include/opencv2/core/saturate.hpp" 3
namespace cv { 
# 82 "/usr/include/opencv2/core/saturate.hpp" 3
template< class _Tp> static inline _Tp saturate_cast(uchar v) { return (_Tp)v; } 
# 84
template< class _Tp> static inline _Tp saturate_cast(schar v) { return (_Tp)v; } 
# 86
template< class _Tp> static inline _Tp saturate_cast(ushort v) { return (_Tp)v; } 
# 88
template< class _Tp> static inline _Tp saturate_cast(short v) { return (_Tp)v; } 
# 90
template< class _Tp> static inline _Tp saturate_cast(unsigned v) { return (_Tp)v; } 
# 92
template< class _Tp> static inline _Tp saturate_cast(int v) { return (_Tp)v; } 
# 94
template< class _Tp> static inline _Tp saturate_cast(float v) { return (_Tp)v; } 
# 96
template< class _Tp> static inline _Tp saturate_cast(double v) { return (_Tp)v; } 
# 98
template< class _Tp> static inline _Tp saturate_cast(int64 v) { return (_Tp)v; } 
# 100
template< class _Tp> static inline _Tp saturate_cast(uint64 v) { return (_Tp)v; } 
# 102
template<> inline uchar saturate_cast< unsigned char> (schar v) { return (uchar)std::max((int)v, 0); } 
# 103
template<> inline uchar saturate_cast< unsigned char> (ushort v) { return (uchar)std::min((unsigned)v, (unsigned)((127 * 2) + 1)); } 
# 104
template<> inline uchar saturate_cast< unsigned char> (int v) { return (uchar)((((unsigned)v) <= ((127 * 2) + 1)) ? v : ((v > 0) ? (127 * 2) + 1 : 0)); } 
# 105
template<> inline uchar saturate_cast< unsigned char> (short v) { return saturate_cast< unsigned char> ((int)v); } 
# 106
template<> inline uchar saturate_cast< unsigned char> (unsigned v) { return (uchar)std::min(v, (unsigned)((127 * 2) + 1)); } 
# 107
template<> inline uchar saturate_cast< unsigned char> (float v) { int iv = cvRound(v); return saturate_cast< unsigned char> (iv); } 
# 108
template<> inline uchar saturate_cast< unsigned char> (double v) { int iv = cvRound(v); return saturate_cast< unsigned char> (iv); } 
# 109
template<> inline uchar saturate_cast< unsigned char> (int64 v) { return (uchar)((((uint64)v) <= ((uint64)((127 * 2) + 1))) ? v : ((v > (0)) ? (127 * 2) + 1 : 0)); } 
# 110
template<> inline uchar saturate_cast< unsigned char> (uint64 v) { return (uchar)std::min(v, (uint64)((127 * 2) + 1)); } 
# 112
template<> inline schar saturate_cast< signed char> (uchar v) { return (schar)std::min((int)v, 127); } 
# 113
template<> inline schar saturate_cast< signed char> (ushort v) { return (schar)std::min((unsigned)v, (unsigned)127); } 
# 114
template<> inline schar saturate_cast< signed char> (int v) { return (schar)((((unsigned)(v - ((-127) - 1))) <= ((unsigned)((127 * 2) + 1))) ? v : ((v > 0) ? 127 : ((-127) - 1))); } 
# 115
template<> inline schar saturate_cast< signed char> (short v) { return saturate_cast< signed char> ((int)v); } 
# 116
template<> inline schar saturate_cast< signed char> (unsigned v) { return (schar)std::min(v, (unsigned)127); } 
# 117
template<> inline schar saturate_cast< signed char> (float v) { int iv = cvRound(v); return saturate_cast< signed char> (iv); } 
# 118
template<> inline schar saturate_cast< signed char> (double v) { int iv = cvRound(v); return saturate_cast< signed char> (iv); } 
# 119
template<> inline schar saturate_cast< signed char> (int64 v) { return (schar)((((uint64)(((int64)v) - ((-127) - 1))) <= ((uint64)((127 * 2) + 1))) ? v : ((v > (0)) ? 127 : ((-127) - 1))); } 
# 120
template<> inline schar saturate_cast< signed char> (uint64 v) { return (schar)std::min(v, (uint64)127); } 
# 122
template<> inline ushort saturate_cast< unsigned short> (schar v) { return (ushort)std::max((int)v, 0); } 
# 123
template<> inline ushort saturate_cast< unsigned short> (short v) { return (ushort)std::max((int)v, 0); } 
# 124
template<> inline ushort saturate_cast< unsigned short> (int v) { return (ushort)((((unsigned)v) <= ((unsigned)((32767 * 2) + 1))) ? v : ((v > 0) ? (32767 * 2) + 1 : 0)); } 
# 125
template<> inline ushort saturate_cast< unsigned short> (unsigned v) { return (ushort)std::min(v, (unsigned)((32767 * 2) + 1)); } 
# 126
template<> inline ushort saturate_cast< unsigned short> (float v) { int iv = cvRound(v); return saturate_cast< unsigned short> (iv); } 
# 127
template<> inline ushort saturate_cast< unsigned short> (double v) { int iv = cvRound(v); return saturate_cast< unsigned short> (iv); } 
# 128
template<> inline ushort saturate_cast< unsigned short> (int64 v) { return (ushort)((((uint64)v) <= ((uint64)((32767 * 2) + 1))) ? v : ((v > (0)) ? (32767 * 2) + 1 : 0)); } 
# 129
template<> inline ushort saturate_cast< unsigned short> (uint64 v) { return (ushort)std::min(v, (uint64)((32767 * 2) + 1)); } 
# 131
template<> inline short saturate_cast< short> (ushort v) { return (short)std::min((int)v, 32767); } 
# 132
template<> inline short saturate_cast< short> (int v) { return (short)((((unsigned)(v - ((-32767) - 1))) <= ((unsigned)((32767 * 2) + 1))) ? v : ((v > 0) ? 32767 : ((-32767) - 1))); } 
# 133
template<> inline short saturate_cast< short> (unsigned v) { return (short)std::min(v, (unsigned)32767); } 
# 134
template<> inline short saturate_cast< short> (float v) { int iv = cvRound(v); return saturate_cast< short> (iv); } 
# 135
template<> inline short saturate_cast< short> (double v) { int iv = cvRound(v); return saturate_cast< short> (iv); } 
# 136
template<> inline short saturate_cast< short> (int64 v) { return (short)((((uint64)(((int64)v) - ((-32767) - 1))) <= ((uint64)((32767 * 2) + 1))) ? v : ((v > (0)) ? 32767 : ((-32767) - 1))); } 
# 137
template<> inline short saturate_cast< short> (uint64 v) { return (short)std::min(v, (uint64)32767); } 
# 139
template<> inline int saturate_cast< int> (float v) { return cvRound(v); } 
# 140
template<> inline int saturate_cast< int> (double v) { return cvRound(v); } 
# 143
template<> inline unsigned saturate_cast< unsigned> (float v) { return cvRound(v); } 
# 144
template<> inline unsigned saturate_cast< unsigned> (double v) { return cvRound(v); } 
# 148
}
# 60 "/usr/include/opencv2/core/matx.hpp" 3
namespace cv { 
# 69
struct __attribute((visibility("default"))) Matx_AddOp { }; 
# 70
struct __attribute((visibility("default"))) Matx_SubOp { }; 
# 71
struct __attribute((visibility("default"))) Matx_ScaleOp { }; 
# 72
struct __attribute((visibility("default"))) Matx_MulOp { }; 
# 73
struct __attribute((visibility("default"))) Matx_DivOp { }; 
# 74
struct __attribute((visibility("default"))) Matx_MatMulOp { }; 
# 75
struct __attribute((visibility("default"))) Matx_TOp { }; 
# 100 "/usr/include/opencv2/core/matx.hpp" 3
template< class _Tp, int m, int n> class Matx { 
# 103
public: enum { 
# 104
rows = m, 
# 105
cols = n, 
# 106
channels = (m) * (n), 
# 111
shortdim = (m < n) ? m : n
# 112
}; 
# 114
typedef _Tp value_type; 
# 115
typedef Matx mat_type; 
# 116
typedef cv::Matx< _Tp, shortdim, 1>  diag_type; 
# 119
inline Matx(); 
# 121
inline Matx(_Tp v0); 
# 122
inline Matx(_Tp v0, _Tp v1); 
# 123
inline Matx(_Tp v0, _Tp v1, _Tp v2); 
# 124
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3); 
# 125
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); 
# 126
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); 
# 127
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); 
# 128
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); 
# 129
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); 
# 130
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); 
# 131
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11); 
# 134
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13); 
# 138
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15); 
# 142
inline explicit Matx(const _Tp * vals); 
# 145
inline Matx(std::initializer_list< _Tp> ); 
# 148
static inline Matx all(_Tp alpha); 
# 149
static inline Matx zeros(); 
# 150
static inline Matx ones(); 
# 151
static inline Matx eye(); 
# 152
static inline Matx diag(const diag_type & d); 
# 153
static inline Matx randu(_Tp a, _Tp b); 
# 154
static inline Matx randn(_Tp a, _Tp b); 
# 157
inline _Tp dot(const Matx & v) const; 
# 160
inline double ddot(const Matx & v) const; 
# 163
template< class T2> inline operator cv::Matx< T2, m, n> () const; 
# 166
template< int m1, int n1> inline cv::Matx< _Tp, m1, n1>  reshape() const; 
# 169
template< int m1, int n1> inline cv::Matx< _Tp, m1, n1>  get_minor(int i, int j) const; 
# 172
inline cv::Matx< _Tp, 1, n>  row(int i) const; 
# 175
inline cv::Matx< _Tp, m, 1>  col(int i) const; 
# 178
inline diag_type diag() const; 
# 181
inline cv::Matx< _Tp, n, m>  t() const; 
# 184
inline cv::Matx< _Tp, n, m>  inv(int method = DECOMP_LU, bool * p_is_ok = 0) const; 
# 187
template< int l> inline cv::Matx< _Tp, n, l>  solve(const cv::Matx< _Tp, m, l>  & rhs, int flags = DECOMP_LU) const; 
# 188
inline Vec< _Tp, n>  solve(const Vec< _Tp, m>  & rhs, int method) const; 
# 191
inline Matx mul(const Matx & a) const; 
# 194
inline Matx div(const Matx & a) const; 
# 197
inline const _Tp &operator()(int i, int j) const; 
# 198
inline _Tp &operator()(int i, int j); 
# 201
inline const _Tp &operator()(int i) const; 
# 202
inline _Tp &operator()(int i); 
# 204
inline Matx(const Matx & a, const Matx & b, Matx_AddOp); 
# 205
inline Matx(const Matx & a, const Matx & b, Matx_SubOp); 
# 206
template< class _T2> inline Matx(const Matx & a, _T2 alpha, Matx_ScaleOp); 
# 207
inline Matx(const Matx & a, const Matx & b, Matx_MulOp); 
# 208
inline Matx(const Matx & a, const Matx & b, Matx_DivOp); 
# 209
template< int l> inline Matx(const cv::Matx< _Tp, m, l>  & a, const cv::Matx< _Tp, l, n>  & b, Matx_MatMulOp); 
# 210
inline Matx(const cv::Matx< _Tp, n, m>  & a, Matx_TOp); 
# 212
_Tp val[m * n]; 
# 213
}; 
# 215
typedef Matx< float, 1, 2>  Matx12f; 
# 216
typedef Matx< double, 1, 2>  Matx12d; 
# 217
typedef Matx< float, 1, 3>  Matx13f; 
# 218
typedef Matx< double, 1, 3>  Matx13d; 
# 219
typedef Matx< float, 1, 4>  Matx14f; 
# 220
typedef Matx< double, 1, 4>  Matx14d; 
# 221
typedef Matx< float, 1, 6>  Matx16f; 
# 222
typedef Matx< double, 1, 6>  Matx16d; 
# 224
typedef Matx< float, 2, 1>  Matx21f; 
# 225
typedef Matx< double, 2, 1>  Matx21d; 
# 226
typedef Matx< float, 3, 1>  Matx31f; 
# 227
typedef Matx< double, 3, 1>  Matx31d; 
# 228
typedef Matx< float, 4, 1>  Matx41f; 
# 229
typedef Matx< double, 4, 1>  Matx41d; 
# 230
typedef Matx< float, 6, 1>  Matx61f; 
# 231
typedef Matx< double, 6, 1>  Matx61d; 
# 233
typedef Matx< float, 2, 2>  Matx22f; 
# 234
typedef Matx< double, 2, 2>  Matx22d; 
# 235
typedef Matx< float, 2, 3>  Matx23f; 
# 236
typedef Matx< double, 2, 3>  Matx23d; 
# 237
typedef Matx< float, 3, 2>  Matx32f; 
# 238
typedef Matx< double, 3, 2>  Matx32d; 
# 240
typedef Matx< float, 3, 3>  Matx33f; 
# 241
typedef Matx< double, 3, 3>  Matx33d; 
# 243
typedef Matx< float, 3, 4>  Matx34f; 
# 244
typedef Matx< double, 3, 4>  Matx34d; 
# 245
typedef Matx< float, 4, 3>  Matx43f; 
# 246
typedef Matx< double, 4, 3>  Matx43d; 
# 248
typedef Matx< float, 4, 4>  Matx44f; 
# 249
typedef Matx< double, 4, 4>  Matx44d; 
# 250
typedef Matx< float, 6, 6>  Matx66f; 
# 251
typedef Matx< double, 6, 6>  Matx66d; 
# 256
template< class _Tp, int m, int n> class DataType< Matx< _Tp, m, n> >  { 
# 259
public: typedef Matx< _Tp, m, n>  value_type; 
# 260
typedef Matx< typename cv::DataType< _Tp> ::work_type, m, n>  work_type; 
# 261
typedef _Tp channel_type; 
# 262
typedef value_type vec_type; 
# 264
enum { generic_type, 
# 265
channels = m * n, 
# 266
fmt = traits::SafeFmt< _Tp> ::fmt + (((m * n) - 1) << 8)
# 271
}; 
# 272
}; 
# 274
namespace traits { 
# 275
template< class _Tp, int m, int n> 
# 276
struct Depth< Matx< _Tp, m, n> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 277
template< class _Tp, int m, int n> 
# 278
struct Type< Matx< _Tp, m, n> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + (((n * m) - 1) << 3)}; }; 
# 279
}
# 284
template< class _Tp, int m, int n> class MatxCommaInitializer { 
# 287
public: inline MatxCommaInitializer(Matx< _Tp, m, n>  * _mtx); 
# 288
template< class T2> inline MatxCommaInitializer &operator,(T2 val); 
# 289
inline Matx< _Tp, m, n>  operator*() const; 
# 291
Matx< _Tp, m, n>  *dst; 
# 292
int idx; 
# 293
}; 
# 298
template< class _Tp, int m> static inline double determinant(const Matx< _Tp, m, m>  & a); 
# 299
template< class _Tp, int m, int n> static inline double trace(const Matx< _Tp, m, n>  & a); 
# 300
template< class _Tp, int m, int n> static inline double norm(const Matx< _Tp, m, n>  & M); 
# 301
template< class _Tp, int m, int n> static inline double norm(const Matx< _Tp, m, n>  & M, int normType); 
# 335 "/usr/include/opencv2/core/matx.hpp" 3
template< class _Tp, int cn> class Vec : public Matx< _Tp, cn, 1>  { 
# 338
public: typedef _Tp value_type; 
# 339
enum { 
# 340
channels = cn, 
# 345
_dummy_enum_finalizer = 0
# 346
}; 
# 349
inline Vec(); 
# 351
inline Vec(_Tp v0); 
# 352
inline Vec(_Tp v0, _Tp v1); 
# 353
inline Vec(_Tp v0, _Tp v1, _Tp v2); 
# 354
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3); 
# 355
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); 
# 356
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); 
# 357
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); 
# 358
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); 
# 359
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); 
# 360
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); 
# 361
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13); 
# 362
inline explicit Vec(const _Tp * values); 
# 365
inline Vec(::std::initializer_list< _Tp> ); 
# 368
inline Vec(const Vec & v); 
# 370
static inline Vec all(_Tp alpha); 
# 373
inline Vec mul(const Vec & v) const; 
# 376
Vec conj() const; 
# 383
inline Vec cross(const Vec & v) const; 
# 385
template< class T2> inline operator ::cv::Vec< T2, cn> () const; 
# 388
inline const _Tp &operator[](int i) const; 
# 389
inline _Tp &operator[](int i); 
# 390
inline const _Tp &operator()(int i) const; 
# 391
inline _Tp &operator()(int i); 
# 393
inline Vec(const ::cv::Matx< _Tp, cn, 1>  & a, const ::cv::Matx< _Tp, cn, 1>  & b, ::cv::Matx_AddOp); 
# 394
inline Vec(const ::cv::Matx< _Tp, cn, 1>  & a, const ::cv::Matx< _Tp, cn, 1>  & b, ::cv::Matx_SubOp); 
# 395
template< class _T2> inline Vec(const ::cv::Matx< _Tp, cn, 1>  & a, _T2 alpha, ::cv::Matx_ScaleOp); 
# 396
}; 
# 401
typedef Vec< unsigned char, 2>  Vec2b; 
# 402
typedef Vec< unsigned char, 3>  Vec3b; 
# 403
typedef Vec< unsigned char, 4>  Vec4b; 
# 405
typedef Vec< short, 2>  Vec2s; 
# 406
typedef Vec< short, 3>  Vec3s; 
# 407
typedef Vec< short, 4>  Vec4s; 
# 409
typedef Vec< unsigned short, 2>  Vec2w; 
# 410
typedef Vec< unsigned short, 3>  Vec3w; 
# 411
typedef Vec< unsigned short, 4>  Vec4w; 
# 413
typedef Vec< int, 2>  Vec2i; 
# 414
typedef Vec< int, 3>  Vec3i; 
# 415
typedef Vec< int, 4>  Vec4i; 
# 416
typedef Vec< int, 6>  Vec6i; 
# 417
typedef Vec< int, 8>  Vec8i; 
# 419
typedef Vec< float, 2>  Vec2f; 
# 420
typedef Vec< float, 3>  Vec3f; 
# 421
typedef Vec< float, 4>  Vec4f; 
# 422
typedef Vec< float, 6>  Vec6f; 
# 424
typedef Vec< double, 2>  Vec2d; 
# 425
typedef Vec< double, 3>  Vec3d; 
# 426
typedef Vec< double, 4>  Vec4d; 
# 427
typedef Vec< double, 6>  Vec6d; 
# 433
template< class _Tp, int cn> class DataType< Vec< _Tp, cn> >  { 
# 436
public: typedef Vec< _Tp, cn>  value_type; 
# 437
typedef Vec< typename cv::DataType< _Tp> ::work_type, cn>  work_type; 
# 438
typedef _Tp channel_type; 
# 439
typedef value_type vec_type; 
# 441
enum { generic_type, 
# 442
channels = cn, 
# 443
fmt = DataType< _Tp> ::fmt + (((cn) - 1) << 8), 
# 448
_dummy_enum_finalizer = 0
# 449
}; 
# 450
}; 
# 452
namespace traits { 
# 453
template< class _Tp, int cn> 
# 454
struct Depth< Vec< _Tp, cn> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 455
template< class _Tp, int cn> 
# 456
struct Type< Vec< _Tp, cn> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((cn - 1) << 3)}; }; 
# 457
}
# 462
template< class _Tp, int m> class VecCommaInitializer : public MatxCommaInitializer< _Tp, m, 1>  { 
# 465
public: inline VecCommaInitializer(Vec< _Tp, m>  * _vec); 
# 466
template< class T2> inline VecCommaInitializer &operator,(T2 val); 
# 467
inline Vec< _Tp, m>  operator*() const; 
# 468
}; 
# 470
template< class _Tp, int cn> static inline Vec< _Tp, cn>  normalize(const Vec< _Tp, cn>  & v); 
# 477
namespace internal { 
# 480
template< class _Tp, int m> struct Matx_DetOp { 
# 482
double operator()(const Matx< _Tp, m, m>  &a) const 
# 483
{ 
# 484
Matx< _Tp, m, m>  temp = a; 
# 485
double p = LU((temp.val), (m) * sizeof(_Tp), m, 0, 0, 0); 
# 486
if (p == (0)) { 
# 487
return p; }  
# 488
for (int i = 0; i < m; i++) { 
# 489
p *= temp(i, i); }  
# 490
return p; 
# 491
} 
# 492
}; 
# 494
template< class _Tp> struct Matx_DetOp< _Tp, 1>  { 
# 496
double operator()(const Matx< _Tp, 1, 1>  &a) const 
# 497
{ 
# 498
return a(0, 0); 
# 499
} 
# 500
}; 
# 502
template< class _Tp> struct Matx_DetOp< _Tp, 2>  { 
# 504
double operator()(const Matx< _Tp, 2, 2>  &a) const 
# 505
{ 
# 506
return (a(0, 0) * a(1, 1)) - (a(0, 1) * a(1, 0)); 
# 507
} 
# 508
}; 
# 510
template< class _Tp> struct Matx_DetOp< _Tp, 3>  { 
# 512
double operator()(const Matx< _Tp, 3, 3>  &a) const 
# 513
{ 
# 514
return ((a(0, 0) * ((a(1, 1) * a(2, 2)) - (a(2, 1) * a(1, 2)))) - (a(0, 1) * ((a(1, 0) * a(2, 2)) - (a(2, 0) * a(1, 2))))) + (a(0, 2) * ((a(1, 0) * a(2, 1)) - (a(2, 0) * a(1, 1)))); 
# 517
} 
# 518
}; 
# 520
template< class _Tp> inline Vec< _Tp, 2>  conjugate(const Vec< _Tp, 2>  &v) 
# 521
{ 
# 522
return Vec< _Tp, 2> (v[0], -(v[1])); 
# 523
} 
# 525
template< class _Tp> inline Vec< _Tp, 4>  conjugate(const Vec< _Tp, 4>  &v) 
# 526
{ 
# 527
return Vec< _Tp, 4> (v[0], -(v[1]), -(v[2]), -(v[3])); 
# 528
} 
# 530
}
# 536
template< class _Tp, int m, int n> inline 
# 537
Matx< _Tp, m, n> ::Matx() 
# 538
{ 
# 539
for (int i = 0; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 540
} 
# 542
template< class _Tp, int m, int n> inline 
# 543
Matx< _Tp, m, n> ::Matx(_Tp v0) 
# 544
{ 
# 545
((val)[0]) = v0; 
# 546
for (int i = 1; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 547
} 
# 549
template< class _Tp, int m, int n> inline 
# 550
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1) 
# 551
{ 
# 552
static_assert(((channels) >= 2), "Matx should have at least 2 elements. channels >= 2");
# 553
((val)[0]) = v0; ((val)[1]) = v1; 
# 554
for (int i = 2; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 555
} 
# 557
template< class _Tp, int m, int n> inline 
# 558
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2) 
# 559
{ 
# 560
static_assert(((channels) >= 3), "Matx should have at least 3 elements. channels >= 3");
# 561
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; 
# 562
for (int i = 3; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 563
} 
# 565
template< class _Tp, int m, int n> inline 
# 566
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3) 
# 567
{ 
# 568
static_assert(((channels) >= 4), "Matx should have at least 4 elements. channels >= 4");
# 569
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 570
for (int i = 4; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 571
} 
# 573
template< class _Tp, int m, int n> inline 
# 574
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4) 
# 575
{ 
# 576
static_assert(((channels) >= 5), "Matx should have at least 5 elements. channels >= 5");
# 577
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; ((val)[4]) = v4; 
# 578
for (int i = 5; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 579
} 
# 581
template< class _Tp, int m, int n> inline 
# 582
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5) 
# 583
{ 
# 584
static_assert(((channels) >= 6), "Matx should have at least 6 elements. channels >= 6");
# 585
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 586
((val)[4]) = v4; ((val)[5]) = v5; 
# 587
for (int i = 6; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 588
} 
# 590
template< class _Tp, int m, int n> inline 
# 591
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6) 
# 592
{ 
# 593
static_assert(((channels) >= 7), "Matx should have at least 7 elements. channels >= 7");
# 594
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 595
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; 
# 596
for (int i = 7; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 597
} 
# 599
template< class _Tp, int m, int n> inline 
# 600
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7) 
# 601
{ 
# 602
static_assert(((channels) >= 8), "Matx should have at least 8 elements. channels >= 8");
# 603
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 604
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 605
for (int i = 8; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 606
} 
# 608
template< class _Tp, int m, int n> inline 
# 609
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8) 
# 610
{ 
# 611
static_assert(((channels) >= 9), "Matx should have at least 9 elements. channels >= 9");
# 612
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 613
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 614
((val)[8]) = v8; 
# 615
for (int i = 9; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 616
} 
# 618
template< class _Tp, int m, int n> inline 
# 619
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9) 
# 620
{ 
# 621
static_assert(((channels) >= 10), "Matx should have at least 10 elements. channels >= 10");
# 622
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 623
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 624
((val)[8]) = v8; ((val)[9]) = v9; 
# 625
for (int i = 10; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 626
} 
# 629
template< class _Tp, int m, int n> inline 
# 630
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11) 
# 631
{ 
# 632
static_assert(((channels) >= 12), "Matx should have at least 12 elements. channels >= 12");
# 633
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 634
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 635
((val)[8]) = v8; ((val)[9]) = v9; ((val)[10]) = v10; ((val)[11]) = v11; 
# 636
for (int i = 12; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 637
} 
# 639
template< class _Tp, int m, int n> inline 
# 640
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13) 
# 641
{ 
# 642
static_assert(((channels) >= 14), "Matx should have at least 14 elements. channels >= 14");
# 643
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 644
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 645
((val)[8]) = v8; ((val)[9]) = v9; ((val)[10]) = v10; ((val)[11]) = v11; 
# 646
((val)[12]) = v12; ((val)[13]) = v13; 
# 647
for (int i = 14; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 648
} 
# 651
template< class _Tp, int m, int n> inline 
# 652
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15) 
# 653
{ 
# 654
static_assert(((channels) >= 16), "Matx should have at least 16 elements. channels >= 16");
# 655
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 656
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 657
((val)[8]) = v8; ((val)[9]) = v9; ((val)[10]) = v10; ((val)[11]) = v11; 
# 658
((val)[12]) = v12; ((val)[13]) = v13; ((val)[14]) = v14; ((val)[15]) = v15; 
# 659
for (int i = 16; i < (channels); i++) { ((val)[i]) = ((_Tp)0); }  
# 660
} 
# 662
template< class _Tp, int m, int n> inline 
# 663
Matx< _Tp, m, n> ::Matx(const _Tp *values) 
# 664
{ 
# 665
for (int i = 0; i < (channels); i++) { ((val)[i]) = (values[i]); }  
# 666
} 
# 669
template< class _Tp, int m, int n> inline 
# 670
Matx< _Tp, m, n> ::Matx(std::initializer_list< _Tp>  list) 
# 671
{ 
# 672
; 
# 673
int i = 0; 
# 674
for (const auto &elem : list) 
# 675
{ 
# 676
((val)[i++]) = elem; 
# 677
}  
# 678
} 
# 681
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 682
Matx< _Tp, m, n> ::all(_Tp alpha) 
# 683
{ 
# 684
Matx M; 
# 685
for (int i = 0; i < (m * n); i++) { ((M.val)[i]) = alpha; }  
# 686
return M; 
# 687
} 
# 689
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 690
Matx< _Tp, m, n> ::zeros() 
# 691
{ 
# 692
return (all)(0); 
# 693
} 
# 695
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 696
Matx< _Tp, m, n> ::ones() 
# 697
{ 
# 698
return (all)(1); 
# 699
} 
# 701
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 702
Matx< _Tp, m, n> ::eye() 
# 703
{ 
# 704
Matx M; 
# 705
for (int i = 0; i < (shortdim); i++) { 
# 706
M(i, i) = 1; }  
# 707
return M; 
# 708
} 
# 710
template< class _Tp, int m, int n> inline _Tp 
# 711
Matx< _Tp, m, n> ::dot(const Matx &M) const 
# 712
{ 
# 713
_Tp s = (0); 
# 714
for (int i = 0; i < (channels); i++) { s += (((val)[i]) * ((M.val)[i])); }  
# 715
return s; 
# 716
} 
# 718
template< class _Tp, int m, int n> inline double 
# 719
Matx< _Tp, m, n> ::ddot(const Matx &M) const 
# 720
{ 
# 721
double s = (0); 
# 722
for (int i = 0; i < (channels); i++) { s += (((double)((val)[i])) * ((M.val)[i])); }  
# 723
return s; 
# 724
} 
# 726
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 727
Matx< _Tp, m, n> ::diag(const diag_type &d) 
# 728
{ 
# 729
Matx M; 
# 730
for (int i = 0; i < (shortdim); i++) { 
# 731
M(i, i) = d(i, 0); }  
# 732
return M; 
# 733
} 
# 735
template< class _Tp, int m, int n> template< class T2> inline 
# 736
Matx< _Tp, m, n> ::operator Matx< T2, m, n> () const 
# 737
{ 
# 738
cv::Matx< T2, m, n>  M; 
# 739
for (int i = 0; i < (m * n); i++) { ((M.val)[i]) = saturate_cast< T2> ((val)[i]); }  
# 740
return M; 
# 741
} 
# 743
template< class _Tp, int m, int n> template< int m1, int n1> inline Matx< _Tp, m1, n1>  
# 744
Matx< _Tp, m, n> ::reshape() const 
# 745
{ 
# 746
static_assert(((m1 * n1) == (m * n)), "Input and destnarion matrices must have the same number of elements m1*n1 == m*n");
# 747
return (const cv::Matx< _Tp, m1, n1>  &)(*this); 
# 748
} 
# 750
template< class _Tp, int m, int n> 
# 751
template< int m1, int n1> inline Matx< _Tp, m1, n1>  
# 752
Matx< _Tp, m, n> ::get_minor(int i, int j) const 
# 753
{ 
# 754
; 
# 755
cv::Matx< _Tp, m1, n1>  s; 
# 756
for (int di = 0; di < m1; di++) { 
# 757
for (int dj = 0; dj < n1; dj++) { 
# 758
s(di, dj) = (*this)(i + di, j + dj); }  }  
# 759
return s; 
# 760
} 
# 762
template< class _Tp, int m, int n> inline Matx< _Tp, 1, n>  
# 763
Matx< _Tp, m, n> ::row(int i) const 
# 764
{ 
# 765
; 
# 766
return ((cv::Matx< _Tp, 1, n> )(&((val)[i * n]))); 
# 767
} 
# 769
template< class _Tp, int m, int n> inline Matx< _Tp, m, 1>  
# 770
Matx< _Tp, m, n> ::col(int j) const 
# 771
{ 
# 772
; 
# 773
cv::Matx< _Tp, m, 1>  v; 
# 774
for (int i = 0; i < m; i++) { 
# 775
((v.val)[i]) = ((val)[(i * n) + j]); }  
# 776
return v; 
# 777
} 
# 779
template< class _Tp, int m, int n> inline typename Matx< _Tp, m, n> ::diag_type 
# 780
Matx< _Tp, m, n> ::diag() const 
# 781
{ 
# 782
diag_type d; 
# 783
for (int i = 0; i < (shortdim); i++) { 
# 784
((d.val)[i]) = ((val)[(i * n) + i]); }  
# 785
return d; 
# 786
} 
# 788
template< class _Tp, int m, int n> inline const _Tp &
# 789
Matx< _Tp, m, n> ::operator()(int i, int j) const 
# 790
{ 
# 791
; 
# 792
return (this->val)[(i * n) + j]; 
# 793
} 
# 795
template< class _Tp, int m, int n> inline _Tp &
# 796
Matx< _Tp, m, n> ::operator()(int i, int j) 
# 797
{ 
# 798
; 
# 799
return (val)[(i * n) + j]; 
# 800
} 
# 802
template< class _Tp, int m, int n> inline const _Tp &
# 803
Matx< _Tp, m, n> ::operator()(int i) const 
# 804
{ 
# 805
static_assert(((m == 1) || (n == 1)), "Single index indexation requires matrix to be a column or a row m == 1 || n == 1");
# 806
; 
# 807
return (val)[i]; 
# 808
} 
# 810
template< class _Tp, int m, int n> inline _Tp &
# 811
Matx< _Tp, m, n> ::operator()(int i) 
# 812
{ 
# 813
static_assert(((m == 1) || (n == 1)), "Single index indexation requires matrix to be a column or a row m == 1 || n == 1");
# 814
; 
# 815
return (val)[i]; 
# 816
} 
# 818
template< class _Tp, int m, int n> inline 
# 819
Matx< _Tp, m, n> ::Matx(const Matx &a, const Matx &b, Matx_AddOp) 
# 820
{ 
# 821
for (int i = 0; i < (channels); i++) { 
# 822
((val)[i]) = saturate_cast< _Tp> (((a.val)[i]) + ((b.val)[i])); }  
# 823
} 
# 825
template< class _Tp, int m, int n> inline 
# 826
Matx< _Tp, m, n> ::Matx(const Matx &a, const Matx &b, Matx_SubOp) 
# 827
{ 
# 828
for (int i = 0; i < (channels); i++) { 
# 829
((val)[i]) = saturate_cast< _Tp> (((a.val)[i]) - ((b.val)[i])); }  
# 830
} 
# 832
template< class _Tp, int m, int n> template< class _T2> inline 
# 833
Matx< _Tp, m, n> ::Matx(const Matx &a, _T2 alpha, Matx_ScaleOp) 
# 834
{ 
# 835
for (int i = 0; i < (channels); i++) { 
# 836
((val)[i]) = saturate_cast< _Tp> (((a.val)[i]) * alpha); }  
# 837
} 
# 839
template< class _Tp, int m, int n> inline 
# 840
Matx< _Tp, m, n> ::Matx(const Matx &a, const Matx &b, Matx_MulOp) 
# 841
{ 
# 842
for (int i = 0; i < (channels); i++) { 
# 843
((val)[i]) = saturate_cast< _Tp> (((a.val)[i]) * ((b.val)[i])); }  
# 844
} 
# 846
template< class _Tp, int m, int n> inline 
# 847
Matx< _Tp, m, n> ::Matx(const Matx &a, const Matx &b, Matx_DivOp) 
# 848
{ 
# 849
for (int i = 0; i < (channels); i++) { 
# 850
((val)[i]) = saturate_cast< _Tp> (((a.val)[i]) / ((b.val)[i])); }  
# 851
} 
# 853
template< class _Tp, int m, int n> template< int l> inline 
# 854
Matx< _Tp, m, n> ::Matx(const cv::Matx< _Tp, m, l>  &a, const cv::Matx< _Tp, l, n>  &b, Matx_MatMulOp) 
# 855
{ 
# 856
for (int i = 0; i < m; i++) { 
# 857
for (int j = 0; j < n; j++) 
# 858
{ 
# 859
_Tp s = (0); 
# 860
for (int k = 0; k < l; k++) { 
# 861
s += (a(i, k) * b(k, j)); }  
# 862
((val)[(i * n) + j]) = s; 
# 863
}  }  
# 864
} 
# 866
template< class _Tp, int m, int n> inline 
# 867
Matx< _Tp, m, n> ::Matx(const cv::Matx< _Tp, n, m>  &a, Matx_TOp) 
# 868
{ 
# 869
for (int i = 0; i < m; i++) { 
# 870
for (int j = 0; j < n; j++) { 
# 871
((val)[(i * n) + j]) = a(j, i); }  }  
# 872
} 
# 874
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 875
Matx< _Tp, m, n> ::mul(const Matx &a) const 
# 876
{ 
# 877
return Matx(*this, a, Matx_MulOp()); 
# 878
} 
# 880
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 881
Matx< _Tp, m, n> ::div(const Matx &a) const 
# 882
{ 
# 883
return Matx(*this, a, Matx_DivOp()); 
# 884
} 
# 886
template< class _Tp, int m, int n> inline Matx< _Tp, n, m>  
# 887
Matx< _Tp, m, n> ::t() const 
# 888
{ 
# 889
return cv::Matx< _Tp, n, m> (*this, Matx_TOp()); 
# 890
} 
# 892
template< class _Tp, int m, int n> inline Vec< _Tp, n>  
# 893
Matx< _Tp, m, n> ::solve(const Vec< _Tp, m>  &rhs, int method) const 
# 894
{ 
# 895
cv::Matx< _Tp, n, 1>  x = solve((const cv::Matx< _Tp, m, 1>  &)rhs, method); 
# 896
return (Vec< _Tp, n>  &)x; 
# 897
} 
# 899
template< class _Tp, int m> inline double 
# 900
determinant(const Matx< _Tp, m, m>  &a) 
# 901
{ 
# 902
return internal::Matx_DetOp< _Tp, m> ()(a); 
# 903
} 
# 905
template< class _Tp, int m, int n> inline double 
# 906
trace(const Matx< _Tp, m, n>  &a) 
# 907
{ 
# 908
_Tp s = (0); 
# 909
for (int i = 0; i < std::min(m, n); i++) { 
# 910
s += a(i, i); }  
# 911
return s; 
# 912
} 
# 914
template< class _Tp, int m, int n> inline double 
# 915
norm(const Matx< _Tp, m, n>  &M) 
# 916
{ 
# 917
return std::sqrt(normL2Sqr< _Tp, double> ((M.val), m * n)); 
# 918
} 
# 920
template< class _Tp, int m, int n> inline double 
# 921
norm(const Matx< _Tp, m, n>  &M, int normType) 
# 922
{ 
# 923
switch (normType) { 
# 924
case NORM_INF:  
# 925
return (double)normInf< _Tp, typename DataType< _Tp> ::work_type> ((M.val), m * n); 
# 926
case NORM_L1:  
# 927
return (double)normL1< _Tp, typename DataType< _Tp> ::work_type> ((M.val), m * n); 
# 928
case NORM_L2SQR:  
# 929
return (double)normL2Sqr< _Tp, typename DataType< _Tp> ::work_type> ((M.val), m * n); 
# 930
default:  
# 931
case NORM_L2:  
# 932
return std::sqrt((double)normL2Sqr< _Tp, typename DataType< _Tp> ::work_type> ((M.val), m * n)); 
# 933
}  
# 934
} 
# 940
template< class _Tp, class _T2, int m, int n> static inline MatxCommaInitializer< _Tp, m, n>  
# 941
operator<<(const Matx< _Tp, m, n>  &mtx, _T2 val) 
# 942
{ 
# 943
MatxCommaInitializer< _Tp, m, n>  commaInitializer((Matx< _Tp, m, n>  *)(&mtx)); 
# 944
return (commaInitializer, val); 
# 945
} 
# 947
template< class _Tp, int m, int n> inline 
# 948
MatxCommaInitializer< _Tp, m, n> ::MatxCommaInitializer(Matx< _Tp, m, n>  *_mtx) : dst(_mtx), idx(0) 
# 950
{ } 
# 952
template< class _Tp, int m, int n> template< class _T2> inline MatxCommaInitializer< _Tp, m, n>  &
# 953
MatxCommaInitializer< _Tp, m, n> ::operator,(_T2 value) 
# 954
{ 
# 955
; 
# 956
(((dst)->val)[(idx)++]) = saturate_cast< _Tp> (value); 
# 957
return *this; 
# 958
} 
# 960
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 961
MatxCommaInitializer< _Tp, m, n> ::operator*() const 
# 962
{ 
# 963
; 
# 964
return *(dst); 
# 965
} 
# 971
template< class _Tp, int cn> inline 
# 972
Vec< _Tp, cn> ::Vec() { } 
# 974
template< class _Tp, int cn> inline 
# 975
Vec< _Tp, cn> ::Vec(_Tp v0) : ::cv::Matx< _Tp, cn, 1> (v0) 
# 976
{ } 
# 978
template< class _Tp, int cn> inline 
# 979
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1) : ::cv::Matx< _Tp, cn, 1> (v0, v1) 
# 980
{ } 
# 982
template< class _Tp, int cn> inline 
# 983
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2) : ::cv::Matx< _Tp, cn, 1> (v0, v1, v2) 
# 984
{ } 
# 986
template< class _Tp, int cn> inline 
# 987
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3) : ::cv::Matx< _Tp, cn, 1> (v0, v1, v2, v3) 
# 988
{ } 
# 990
template< class _Tp, int cn> inline 
# 991
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4) : ::cv::Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4) 
# 992
{ } 
# 994
template< class _Tp, int cn> inline 
# 995
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5) : ::cv::Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5) 
# 996
{ } 
# 998
template< class _Tp, int cn> inline 
# 999
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6) : ::cv::Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5, v6) 
# 1000
{ } 
# 1002
template< class _Tp, int cn> inline 
# 1003
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7) : ::cv::Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5, v6, v7) 
# 1004
{ } 
# 1006
template< class _Tp, int cn> inline 
# 1007
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8) : ::cv::Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5, v6, v7, v8) 
# 1008
{ } 
# 1010
template< class _Tp, int cn> inline 
# 1011
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9) : ::cv::Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) 
# 1012
{ } 
# 1014
template< class _Tp, int cn> inline 
# 1015
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13) : ::cv::Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) 
# 1016
{ } 
# 1018
template< class _Tp, int cn> inline 
# 1019
Vec< _Tp, cn> ::Vec(const _Tp *values) : ::cv::Matx< _Tp, cn, 1> (values) 
# 1020
{ } 
# 1023
template< class _Tp, int cn> inline 
# 1024
Vec< _Tp, cn> ::Vec(::std::initializer_list< _Tp>  list) : ::cv::Matx< _Tp, cn, 1> (list) 
# 1025
{ } 
# 1028
template< class _Tp, int cn> inline 
# 1029
Vec< _Tp, cn> ::Vec(const Vec &m) : ::cv::Matx< _Tp, cn, 1> ((m.val)) 
# 1030
{ } 
# 1032
template< class _Tp, int cn> inline 
# 1033
Vec< _Tp, cn> ::Vec(const ::cv::Matx< _Tp, cn, 1>  &a, const ::cv::Matx< _Tp, cn, 1>  &b, ::cv::Matx_AddOp op) : ::cv::Matx< _Tp, cn, 1> (a, b, op) 
# 1034
{ } 
# 1036
template< class _Tp, int cn> inline 
# 1037
Vec< _Tp, cn> ::Vec(const ::cv::Matx< _Tp, cn, 1>  &a, const ::cv::Matx< _Tp, cn, 1>  &b, ::cv::Matx_SubOp op) : ::cv::Matx< _Tp, cn, 1> (a, b, op) 
# 1038
{ } 
# 1040
template< class _Tp, int cn> template< class _T2> inline 
# 1041
Vec< _Tp, cn> ::Vec(const ::cv::Matx< _Tp, cn, 1>  &a, _T2 alpha, ::cv::Matx_ScaleOp op) : ::cv::Matx< _Tp, cn, 1> (a, alpha, op) 
# 1042
{ } 
# 1044
template< class _Tp, int cn> inline Vec< _Tp, cn>  
# 1045
Vec< _Tp, cn> ::all(_Tp alpha) 
# 1046
{ 
# 1047
Vec v; 
# 1048
for (int i = 0; i < cn; i++) { ((v.val)[i]) = alpha; }  
# 1049
return v; 
# 1050
} 
# 1052
template< class _Tp, int cn> inline Vec< _Tp, cn>  
# 1053
Vec< _Tp, cn> ::mul(const Vec &v) const 
# 1054
{ 
# 1055
Vec w; 
# 1056
for (int i = 0; i < cn; i++) { ((w.val)[i]) = saturate_cast< _Tp> (((this->val)[i]) * ((v.val)[i])); }  
# 1057
return w; 
# 1058
} 
# 1061
template<> inline Vec< float, 2>  Vec< float, 2> ::conj() const 
# 1062
{ 
# 1063
return cv::internal::conjugate(*this); 
# 1064
} 
# 1067
template<> inline Vec< double, 2>  Vec< double, 2> ::conj() const 
# 1068
{ 
# 1069
return cv::internal::conjugate(*this); 
# 1070
} 
# 1073
template<> inline Vec< float, 4>  Vec< float, 4> ::conj() const 
# 1074
{ 
# 1075
return cv::internal::conjugate(*this); 
# 1076
} 
# 1079
template<> inline Vec< double, 4>  Vec< double, 4> ::conj() const 
# 1080
{ 
# 1081
return cv::internal::conjugate(*this); 
# 1082
} 
# 1084
template< class _Tp, int cn> inline Vec< _Tp, cn>  
# 1085
Vec< _Tp, cn> ::cross(const Vec &) const 
# 1086
{ 
# 1087
static_assert((cn == 3), "for arbitrary-size vector there is no cross-product defined cn == 3");
# 1088
return Vec(); 
# 1089
} 
# 1092
template<> inline Vec< float, 3>  Vec< float, 3> ::cross(const cv::Vec< float, 3>  &v) const 
# 1093
{ 
# 1094
return cv::Vec< float, 3> ((((this->val)[1]) * ((v.val)[2])) - (((this->val)[2]) * ((v.val)[1])), (((this->val)[2]) * ((v.val)[0])) - (((this->val)[0]) * ((v.val)[2])), (((this->val)[0]) * ((v.val)[1])) - (((this->val)[1]) * ((v.val)[0]))); 
# 1097
} 
# 1100
template<> inline Vec< double, 3>  Vec< double, 3> ::cross(const cv::Vec< double, 3>  &v) const 
# 1101
{ 
# 1102
return cv::Vec< double, 3> ((((this->val)[1]) * ((v.val)[2])) - (((this->val)[2]) * ((v.val)[1])), (((this->val)[2]) * ((v.val)[0])) - (((this->val)[0]) * ((v.val)[2])), (((this->val)[0]) * ((v.val)[1])) - (((this->val)[1]) * ((v.val)[0]))); 
# 1105
} 
# 1107
template< class _Tp, int cn> template< class T2> inline 
# 1108
Vec< _Tp, cn> ::operator Vec< T2, cn> () const 
# 1109
{ 
# 1110
::cv::Vec< T2, cn>  v; 
# 1111
for (int i = 0; i < cn; i++) { ((v.val)[i]) = saturate_cast< T2> ((this->val)[i]); }  
# 1112
return v; 
# 1113
} 
# 1115
template< class _Tp, int cn> inline const _Tp &
# 1116
Vec< _Tp, cn> ::operator[](int i) const 
# 1117
{ 
# 1118
; 
# 1119
return (this->val)[i]; 
# 1120
} 
# 1122
template< class _Tp, int cn> inline _Tp &
# 1123
Vec< _Tp, cn> ::operator[](int i) 
# 1124
{ 
# 1125
; 
# 1126
return (this->val)[i]; 
# 1127
} 
# 1129
template< class _Tp, int cn> inline const _Tp &
# 1130
Vec< _Tp, cn> ::operator()(int i) const 
# 1131
{ 
# 1132
; 
# 1133
return (this->val)[i]; 
# 1134
} 
# 1136
template< class _Tp, int cn> inline _Tp &
# 1137
Vec< _Tp, cn> ::operator()(int i) 
# 1138
{ 
# 1139
; 
# 1140
return (this->val)[i]; 
# 1141
} 
# 1143
template< class _Tp, int cn> inline Vec< _Tp, cn>  
# 1144
normalize(const Vec< _Tp, cn>  &v) 
# 1145
{ 
# 1146
double nv = norm(v); 
# 1147
return v * ((nv) ? (1.0) / nv : (0.0)); 
# 1148
} 
# 1155
template< class _Tp, class _T2, int cn> static inline VecCommaInitializer< _Tp, cn>  
# 1156
operator<<(const Vec< _Tp, cn>  &vec, _T2 val) 
# 1157
{ 
# 1158
VecCommaInitializer< _Tp, cn>  commaInitializer((Vec< _Tp, cn>  *)(&vec)); 
# 1159
return (commaInitializer, val); 
# 1160
} 
# 1162
template< class _Tp, int cn> inline 
# 1163
VecCommaInitializer< _Tp, cn> ::VecCommaInitializer(Vec< _Tp, cn>  *_vec) : ::cv::MatxCommaInitializer< _Tp, cn, 1> (_vec) 
# 1165
{ } 
# 1167
template< class _Tp, int cn> template< class _T2> inline VecCommaInitializer< _Tp, cn>  &
# 1168
VecCommaInitializer< _Tp, cn> ::operator,(_T2 value) 
# 1169
{ 
# 1170
; 
# 1171
(((this->dst)->val)[(this->idx)++]) = saturate_cast< _Tp> (value); 
# 1172
return *this; 
# 1173
} 
# 1175
template< class _Tp, int cn> inline Vec< _Tp, cn>  
# 1176
VecCommaInitializer< _Tp, cn> ::operator*() const 
# 1177
{ 
# 1178
; 
# 1179
return *(this->dst); 
# 1180
} 
# 1189 "/usr/include/opencv2/core/matx.hpp" 3
template< class _Tp1, class _Tp2, int m, int n> static inline Matx< _Tp1, m, n>  &
# 1190
operator+=(Matx< _Tp1, m, n>  &a, const Matx< _Tp2, m, n>  &b) 
# 1191
{ 
# 1192
for (int i = 0; i < (m * n); i++) { 
# 1193
((a.val)[i]) = saturate_cast< _Tp1> (((a.val)[i]) + ((b.val)[i])); }  
# 1194
return a; 
# 1195
} 
# 1197
template< class _Tp1, class _Tp2, int m, int n> static inline Matx< _Tp1, m, n>  &
# 1198
operator-=(Matx< _Tp1, m, n>  &a, const Matx< _Tp2, m, n>  &b) 
# 1199
{ 
# 1200
for (int i = 0; i < (m * n); i++) { 
# 1201
((a.val)[i]) = saturate_cast< _Tp1> (((a.val)[i]) - ((b.val)[i])); }  
# 1202
return a; 
# 1203
} 
# 1205
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1206
operator+(const Matx< _Tp, m, n>  &a, const Matx< _Tp, m, n>  &b) 
# 1207
{ 
# 1208
return Matx< _Tp, m, n> (a, b, Matx_AddOp()); 
# 1209
} 
# 1211
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1212
operator-(const Matx< _Tp, m, n>  &a, const Matx< _Tp, m, n>  &b) 
# 1213
{ 
# 1214
return Matx< _Tp, m, n> (a, b, Matx_SubOp()); 
# 1215
} 
# 1217
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  &
# 1218
operator*=(Matx< _Tp, m, n>  &a, int alpha) 
# 1219
{ 
# 1220
for (int i = 0; i < (m * n); i++) { 
# 1221
((a.val)[i]) = saturate_cast< _Tp> (((a.val)[i]) * alpha); }  
# 1222
return a; 
# 1223
} 
# 1225
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  &
# 1226
operator*=(Matx< _Tp, m, n>  &a, float alpha) 
# 1227
{ 
# 1228
for (int i = 0; i < (m * n); i++) { 
# 1229
((a.val)[i]) = saturate_cast< _Tp> (((a.val)[i]) * alpha); }  
# 1230
return a; 
# 1231
} 
# 1233
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  &
# 1234
operator*=(Matx< _Tp, m, n>  &a, double alpha) 
# 1235
{ 
# 1236
for (int i = 0; i < (m * n); i++) { 
# 1237
((a.val)[i]) = saturate_cast< _Tp> (((a.val)[i]) * alpha); }  
# 1238
return a; 
# 1239
} 
# 1241
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1242
operator*(const Matx< _Tp, m, n>  &a, int alpha) 
# 1243
{ 
# 1244
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1245
} 
# 1247
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1248
operator*(const Matx< _Tp, m, n>  &a, float alpha) 
# 1249
{ 
# 1250
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1251
} 
# 1253
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1254
operator*(const Matx< _Tp, m, n>  &a, double alpha) 
# 1255
{ 
# 1256
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1257
} 
# 1259
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1260
operator*(int alpha, const Matx< _Tp, m, n>  &a) 
# 1261
{ 
# 1262
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1263
} 
# 1265
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1266
operator*(float alpha, const Matx< _Tp, m, n>  &a) 
# 1267
{ 
# 1268
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1269
} 
# 1271
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1272
operator*(double alpha, const Matx< _Tp, m, n>  &a) 
# 1273
{ 
# 1274
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1275
} 
# 1277
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1278
operator-(const Matx< _Tp, m, n>  &a) 
# 1279
{ 
# 1280
return Matx< _Tp, m, n> (a, -1, Matx_ScaleOp()); 
# 1281
} 
# 1283
template< class _Tp, int m, int n, int l> static inline Matx< _Tp, m, n>  
# 1284
operator*(const Matx< _Tp, m, l>  &a, const Matx< _Tp, l, n>  &b) 
# 1285
{ 
# 1286
return Matx< _Tp, m, n> (a, b, Matx_MatMulOp()); 
# 1287
} 
# 1289
template< class _Tp, int m, int n> static inline Vec< _Tp, m>  
# 1290
operator*(const Matx< _Tp, m, n>  &a, const Vec< _Tp, n>  &b) 
# 1291
{ 
# 1292
Matx< _Tp, m, 1>  c(a, b, Matx_MatMulOp()); 
# 1293
return (const Vec< _Tp, m>  &)c; 
# 1294
} 
# 1296
template< class _Tp, int m, int n> static inline bool 
# 1297
operator==(const Matx< _Tp, m, n>  &a, const Matx< _Tp, m, n>  &b) 
# 1298
{ 
# 1299
for (int i = 0; i < (m * n); i++) { 
# 1300
if (((a.val)[i]) != ((b.val)[i])) { return false; }  }  
# 1301
return true; 
# 1302
} 
# 1304
template< class _Tp, int m, int n> static inline bool 
# 1305
operator!=(const Matx< _Tp, m, n>  &a, const Matx< _Tp, m, n>  &b) 
# 1306
{ 
# 1307
return !(a == b); 
# 1308
} 
# 1317 "/usr/include/opencv2/core/matx.hpp" 3
template< class _Tp1, class _Tp2, int cn> static inline Vec< _Tp1, cn>  &
# 1318
operator+=(Vec< _Tp1, cn>  &a, const Vec< _Tp2, cn>  &b) 
# 1319
{ 
# 1320
for (int i = 0; i < cn; i++) { 
# 1321
((a.val)[i]) = saturate_cast< _Tp1> (((a.val)[i]) + ((b.val)[i])); }  
# 1322
return a; 
# 1323
} 
# 1325
template< class _Tp1, class _Tp2, int cn> static inline Vec< _Tp1, cn>  &
# 1326
operator-=(Vec< _Tp1, cn>  &a, const Vec< _Tp2, cn>  &b) 
# 1327
{ 
# 1328
for (int i = 0; i < cn; i++) { 
# 1329
((a.val)[i]) = saturate_cast< _Tp1> (((a.val)[i]) - ((b.val)[i])); }  
# 1330
return a; 
# 1331
} 
# 1333
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1334
operator+(const Vec< _Tp, cn>  &a, const Vec< _Tp, cn>  &b) 
# 1335
{ 
# 1336
return Vec< _Tp, cn> (a, b, Matx_AddOp()); 
# 1337
} 
# 1339
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1340
operator-(const Vec< _Tp, cn>  &a, const Vec< _Tp, cn>  &b) 
# 1341
{ 
# 1342
return Vec< _Tp, cn> (a, b, Matx_SubOp()); 
# 1343
} 
# 1345
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1346
operator*=(Vec< _Tp, cn>  &a, int alpha) 
# 1347
{ 
# 1348
for (int i = 0; i < cn; i++) { 
# 1349
(a[i]) = saturate_cast< _Tp> ((a[i]) * alpha); }  
# 1350
return a; 
# 1351
} 
# 1353
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1354
operator*=(Vec< _Tp, cn>  &a, float alpha) 
# 1355
{ 
# 1356
for (int i = 0; i < cn; i++) { 
# 1357
(a[i]) = saturate_cast< _Tp> ((a[i]) * alpha); }  
# 1358
return a; 
# 1359
} 
# 1361
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1362
operator*=(Vec< _Tp, cn>  &a, double alpha) 
# 1363
{ 
# 1364
for (int i = 0; i < cn; i++) { 
# 1365
(a[i]) = saturate_cast< _Tp> ((a[i]) * alpha); }  
# 1366
return a; 
# 1367
} 
# 1369
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1370
operator/=(Vec< _Tp, cn>  &a, int alpha) 
# 1371
{ 
# 1372
double ialpha = (1.0) / alpha; 
# 1373
for (int i = 0; i < cn; i++) { 
# 1374
(a[i]) = saturate_cast< _Tp> ((a[i]) * ialpha); }  
# 1375
return a; 
# 1376
} 
# 1378
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1379
operator/=(Vec< _Tp, cn>  &a, float alpha) 
# 1380
{ 
# 1381
float ialpha = (1.0F) / alpha; 
# 1382
for (int i = 0; i < cn; i++) { 
# 1383
(a[i]) = saturate_cast< _Tp> ((a[i]) * ialpha); }  
# 1384
return a; 
# 1385
} 
# 1387
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1388
operator/=(Vec< _Tp, cn>  &a, double alpha) 
# 1389
{ 
# 1390
double ialpha = (1.0) / alpha; 
# 1391
for (int i = 0; i < cn; i++) { 
# 1392
(a[i]) = saturate_cast< _Tp> ((a[i]) * ialpha); }  
# 1393
return a; 
# 1394
} 
# 1396
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1397
operator*(const Vec< _Tp, cn>  &a, int alpha) 
# 1398
{ 
# 1399
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1400
} 
# 1402
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1403
operator*(int alpha, const Vec< _Tp, cn>  &a) 
# 1404
{ 
# 1405
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1406
} 
# 1408
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1409
operator*(const Vec< _Tp, cn>  &a, float alpha) 
# 1410
{ 
# 1411
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1412
} 
# 1414
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1415
operator*(float alpha, const Vec< _Tp, cn>  &a) 
# 1416
{ 
# 1417
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1418
} 
# 1420
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1421
operator*(const Vec< _Tp, cn>  &a, double alpha) 
# 1422
{ 
# 1423
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1424
} 
# 1426
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1427
operator*(double alpha, const Vec< _Tp, cn>  &a) 
# 1428
{ 
# 1429
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1430
} 
# 1432
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1433
operator/(const Vec< _Tp, cn>  &a, int alpha) 
# 1434
{ 
# 1435
return Vec< _Tp, cn> (a, (1.0) / alpha, Matx_ScaleOp()); 
# 1436
} 
# 1438
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1439
operator/(const Vec< _Tp, cn>  &a, float alpha) 
# 1440
{ 
# 1441
return Vec< _Tp, cn> (a, (1.0F) / alpha, Matx_ScaleOp()); 
# 1442
} 
# 1444
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1445
operator/(const Vec< _Tp, cn>  &a, double alpha) 
# 1446
{ 
# 1447
return Vec< _Tp, cn> (a, (1.0) / alpha, Matx_ScaleOp()); 
# 1448
} 
# 1450
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1451
operator-(const Vec< _Tp, cn>  &a) 
# 1452
{ 
# 1453
Vec< _Tp, cn>  t; 
# 1454
for (int i = 0; i < cn; i++) { ((t.val)[i]) = saturate_cast< _Tp> (-((a.val)[i])); }  
# 1455
return t; 
# 1456
} 
# 1458
template< class _Tp> inline Vec< _Tp, 4>  operator*(const Vec< _Tp, 4>  &v1, const Vec< _Tp, 4>  &v2) 
# 1459
{ 
# 1460
return Vec< _Tp, 4> (saturate_cast< _Tp> (((((v1[0]) * (v2[0])) - ((v1[1]) * (v2[1]))) - ((v1[2]) * (v2[2]))) - ((v1[3]) * (v2[3]))), saturate_cast< _Tp> (((((v1[0]) * (v2[1])) + ((v1[1]) * (v2[0]))) + ((v1[2]) * (v2[3]))) - ((v1[3]) * (v2[2]))), saturate_cast< _Tp> (((((v1[0]) * (v2[2])) - ((v1[1]) * (v2[3]))) + ((v1[2]) * (v2[0]))) + ((v1[3]) * (v2[1]))), saturate_cast< _Tp> (((((v1[0]) * (v2[3])) + ((v1[1]) * (v2[2]))) - ((v1[2]) * (v2[1]))) + ((v1[3]) * (v2[0])))); 
# 1464
} 
# 1466
template< class _Tp> inline Vec< _Tp, 4>  &operator*=(Vec< _Tp, 4>  &v1, const Vec< _Tp, 4>  &v2) 
# 1467
{ 
# 1468
v1 = (v1 * v2); 
# 1469
return v1; 
# 1470
} 
# 1474
}
# 60 "/usr/include/opencv2/core/types.hpp" 3
namespace cv { 
# 74 "/usr/include/opencv2/core/types.hpp" 3
template< class _Tp> class Complex { 
# 79
public: inline Complex(); 
# 80
inline Complex(_Tp _re, _Tp _im = 0); 
# 83
template< class T2> inline operator cv::Complex< T2> () const; 
# 85
inline Complex conj() const; 
# 87
_Tp re, im; 
# 88
}; 
# 90
typedef Complex< float>  Complexf; 
# 91
typedef Complex< double>  Complexd; 
# 93
template< class _Tp> class DataType< Complex< _Tp> >  { 
# 96
public: typedef Complex< _Tp>  value_type; 
# 97
typedef value_type work_type; 
# 98
typedef _Tp channel_type; 
# 100
enum { generic_type, 
# 101
channels = 2, 
# 102
fmt = DataType< _Tp> ::fmt + (((2) - 1) << 8)
# 107
}; 
# 109
typedef Vec< _Tp, channels>  vec_type; 
# 110
}; 
# 112
namespace traits { 
# 113
template< class _Tp> 
# 114
struct Depth< Complex< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 115
template< class _Tp> 
# 116
struct Type< Complex< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((2 - 1) << 3)}; }; 
# 117
}
# 157 "/usr/include/opencv2/core/types.hpp" 3
template< class _Tp> class Point_ { 
# 160
public: typedef _Tp value_type; 
# 163
inline Point_(); 
# 164
inline Point_(_Tp _x, _Tp _y); 
# 165
inline Point_(const Point_ & pt); 
# 166
inline Point_(const Size_< _Tp>  & sz); 
# 167
inline Point_(const Vec< _Tp, 2>  & v); 
# 169
inline Point_ &operator=(const Point_ & pt); 
# 171
template< class _Tp2> inline operator cv::Point_< _Tp2> () const; 
# 174
inline operator Vec< _Tp, 2> () const; 
# 177
inline _Tp dot(const Point_ & pt) const; 
# 179
inline double ddot(const Point_ & pt) const; 
# 181
inline double cross(const Point_ & pt) const; 
# 183
inline bool inside(const Rect_< _Tp>  & r) const; 
# 185
_Tp x, y; 
# 186
}; 
# 188
typedef Point_< int>  Point2i; 
# 189
typedef Point_< long>  Point2l; 
# 190
typedef Point_< float>  Point2f; 
# 191
typedef Point_< double>  Point2d; 
# 192
typedef Point2i Point; 
# 194
template< class _Tp> class DataType< Point_< _Tp> >  { 
# 197
public: typedef Point_< _Tp>  value_type; 
# 198
typedef Point_< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 199
typedef _Tp channel_type; 
# 201
enum { generic_type, 
# 202
channels = 2, 
# 203
fmt = traits::SafeFmt< _Tp> ::fmt + (((2) - 1) << 8)
# 208
}; 
# 210
typedef Vec< _Tp, channels>  vec_type; 
# 211
}; 
# 213
namespace traits { 
# 214
template< class _Tp> 
# 215
struct Depth< Point_< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 216
template< class _Tp> 
# 217
struct Type< Point_< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((2 - 1) << 3)}; }; 
# 218
}
# 237 "/usr/include/opencv2/core/types.hpp" 3
template< class _Tp> class Point3_ { 
# 240
public: typedef _Tp value_type; 
# 243
inline Point3_(); 
# 244
inline Point3_(_Tp _x, _Tp _y, _Tp _z); 
# 245
inline Point3_(const Point3_ & pt); 
# 246
inline explicit Point3_(const Point_< _Tp>  & pt); 
# 247
inline Point3_(const Vec< _Tp, 3>  & v); 
# 249
inline Point3_ &operator=(const Point3_ & pt); 
# 251
template< class _Tp2> inline operator cv::Point3_< _Tp2> () const; 
# 256
inline operator Vec< _Tp, 3> () const; 
# 260
inline _Tp dot(const Point3_ & pt) const; 
# 262
inline double ddot(const Point3_ & pt) const; 
# 264
inline Point3_ cross(const Point3_ & pt) const; 
# 266
_Tp x, y, z; 
# 267
}; 
# 269
typedef Point3_< int>  Point3i; 
# 270
typedef Point3_< float>  Point3f; 
# 271
typedef Point3_< double>  Point3d; 
# 273
template< class _Tp> class DataType< Point3_< _Tp> >  { 
# 276
public: typedef Point3_< _Tp>  value_type; 
# 277
typedef Point3_< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 278
typedef _Tp channel_type; 
# 280
enum { generic_type, 
# 281
channels = 3, 
# 282
fmt = traits::SafeFmt< _Tp> ::fmt + (((3) - 1) << 8)
# 287
}; 
# 289
typedef Vec< _Tp, channels>  vec_type; 
# 290
}; 
# 292
namespace traits { 
# 293
template< class _Tp> 
# 294
struct Depth< Point3_< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 295
template< class _Tp> 
# 296
struct Type< Point3_< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((3 - 1) << 3)}; }; 
# 297
}
# 314 "/usr/include/opencv2/core/types.hpp" 3
template< class _Tp> class Size_ { 
# 317
public: typedef _Tp value_type; 
# 320
inline Size_(); 
# 321
inline Size_(_Tp _width, _Tp _height); 
# 322
inline Size_(const Size_ & sz); 
# 323
inline Size_(const Point_< _Tp>  & pt); 
# 325
inline Size_ &operator=(const Size_ & sz); 
# 327
inline _Tp area() const; 
# 329
inline bool empty() const; 
# 332
template< class _Tp2> inline operator cv::Size_< _Tp2> () const; 
# 334
_Tp width, height; 
# 335
}; 
# 337
typedef Size_< int>  Size2i; 
# 338
typedef Size_< long>  Size2l; 
# 339
typedef Size_< float>  Size2f; 
# 340
typedef Size_< double>  Size2d; 
# 341
typedef Size2i Size; 
# 343
template< class _Tp> class DataType< Size_< _Tp> >  { 
# 346
public: typedef Size_< _Tp>  value_type; 
# 347
typedef Size_< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 348
typedef _Tp channel_type; 
# 350
enum { generic_type, 
# 351
channels = 2, 
# 352
fmt = DataType< _Tp> ::fmt + (((2) - 1) << 8)
# 357
}; 
# 359
typedef Vec< _Tp, channels>  vec_type; 
# 360
}; 
# 362
namespace traits { 
# 363
template< class _Tp> 
# 364
struct Depth< Size_< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 365
template< class _Tp> 
# 366
struct Type< Size_< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((2 - 1) << 3)}; }; 
# 367
}
# 414 "/usr/include/opencv2/core/types.hpp" 3
template< class _Tp> class Rect_ { 
# 417
public: typedef _Tp value_type; 
# 420
inline Rect_(); 
# 421
inline Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height); 
# 422
inline Rect_(const Rect_ & r); 
# 423
inline Rect_(const Point_< _Tp>  & org, const Size_< _Tp>  & sz); 
# 424
inline Rect_(const Point_< _Tp>  & pt1, const Point_< _Tp>  & pt2); 
# 426
inline Rect_ &operator=(const Rect_ & r); 
# 428
inline Point_< _Tp>  tl() const; 
# 430
inline Point_< _Tp>  br() const; 
# 433
inline Size_< _Tp>  size() const; 
# 435
inline _Tp area() const; 
# 437
inline bool empty() const; 
# 440
template< class _Tp2> inline operator cv::Rect_< _Tp2> () const; 
# 443
inline bool contains(const Point_< _Tp>  & pt) const; 
# 445
_Tp x, y, width, height; 
# 446
}; 
# 448
typedef Rect_< int>  Rect2i; 
# 449
typedef Rect_< float>  Rect2f; 
# 450
typedef Rect_< double>  Rect2d; 
# 451
typedef Rect2i Rect; 
# 453
template< class _Tp> class DataType< Rect_< _Tp> >  { 
# 456
public: typedef Rect_< _Tp>  value_type; 
# 457
typedef Rect_< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 458
typedef _Tp channel_type; 
# 460
enum { generic_type, 
# 461
channels = 4, 
# 462
fmt = traits::SafeFmt< _Tp> ::fmt + (((4) - 1) << 8)
# 467
}; 
# 469
typedef Vec< _Tp, channels>  vec_type; 
# 470
}; 
# 472
namespace traits { 
# 473
template< class _Tp> 
# 474
struct Depth< Rect_< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 475
template< class _Tp> 
# 476
struct Type< Rect_< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((4 - 1) << 3)}; }; 
# 477
}
# 506 "/usr/include/opencv2/core/types.hpp" 3
class __attribute((visibility("default"))) RotatedRect { 
# 510
public: inline RotatedRect(); 
# 517
inline RotatedRect(const Point2f & center, const Size2f & size, float angle); 
# 522
RotatedRect(const Point2f & point1, const Point2f & point2, const Point2f & point3); 
# 527
void points(Point2f  pts[]) const; 
# 529
Rect boundingRect() const; 
# 531
Rect_< float>  boundingRect2f() const; 
# 533
Point2f center; 
# 534
Size2f size; 
# 535
float angle; 
# 536
}; 
# 538
template<> class DataType< RotatedRect>  { 
# 541
public: typedef RotatedRect value_type; 
# 542
typedef value_type work_type; 
# 543
typedef float channel_type; 
# 545
enum { generic_type, 
# 546
channels = 5, 
# 547
fmt = 1126
# 552
}; 
# 554
typedef Vec< float, 5>  vec_type; 
# 555
}; 
# 557
namespace traits { 
# 559
template<> struct Depth< RotatedRect>  { enum { value = 5}; }; 
# 561
template<> struct Type< RotatedRect>  { enum { value = 37}; }; 
# 562
}
# 590 "/usr/include/opencv2/core/types.hpp" 3
class __attribute((visibility("default"))) Range { 
# 593
public: inline Range(); 
# 594
inline Range(int _start, int _end); 
# 595
inline int size() const; 
# 596
inline bool empty() const; 
# 597
static inline Range all(); 
# 599
int start, end; 
# 600
}; 
# 602
template<> class DataType< Range>  { 
# 605
public: typedef Range value_type; 
# 606
typedef value_type work_type; 
# 607
typedef int channel_type; 
# 609
enum { generic_type, 
# 610
channels = 2, 
# 611
fmt = 361
# 616
}; 
# 618
typedef Vec< int, 2>  vec_type; 
# 619
}; 
# 621
namespace traits { 
# 623
template<> struct Depth< Range>  { enum { value = 4}; }; 
# 625
template<> struct Type< Range>  { enum { value = 12}; }; 
# 626
}
# 637 "/usr/include/opencv2/core/types.hpp" 3
template< class _Tp> class Scalar_ : public Vec< _Tp, 4>  { 
# 641
public: inline Scalar_(); 
# 642
inline Scalar_(_Tp v0, _Tp v1, _Tp v2 = 0, _Tp v3 = 0); 
# 643
inline Scalar_(_Tp v0); 
# 645
template< class _Tp2, int cn> inline Scalar_(const ::cv::Vec< _Tp2, cn>  & v); 
# 649
static inline Scalar_ all(_Tp v0); 
# 652
template< class T2> inline operator ::cv::Scalar_< T2> () const; 
# 655
inline Scalar_ mul(const Scalar_ & a, double scale = 1) const; 
# 658
inline Scalar_ conj() const; 
# 661
inline bool isReal() const; 
# 662
}; 
# 664
typedef Scalar_< double>  Scalar; 
# 666
template< class _Tp> class DataType< Scalar_< _Tp> >  { 
# 669
public: typedef Scalar_< _Tp>  value_type; 
# 670
typedef Scalar_< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 671
typedef _Tp channel_type; 
# 673
enum { generic_type, 
# 674
channels = 4, 
# 675
fmt = traits::SafeFmt< _Tp> ::fmt + (((4) - 1) << 8)
# 680
}; 
# 682
typedef Vec< _Tp, channels>  vec_type; 
# 683
}; 
# 685
namespace traits { 
# 686
template< class _Tp> 
# 687
struct Depth< Scalar_< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 688
template< class _Tp> 
# 689
struct Type< Scalar_< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((4 - 1) << 3)}; }; 
# 690
}
# 707 "/usr/include/opencv2/core/types.hpp" 3
class __attribute((visibility("default"))) KeyPoint { 
# 711
public: inline KeyPoint(); 
# 720 "/usr/include/opencv2/core/types.hpp" 3
inline KeyPoint(Point2f _pt, float _size, float _angle = -1, float _response = 0, int _octave = 0, int _class_id = -1); 
# 730 "/usr/include/opencv2/core/types.hpp" 3
inline KeyPoint(float x, float y, float _size, float _angle = -1, float _response = 0, int _octave = 0, int _class_id = -1); 
# 732
size_t hash() const; 
# 743 "/usr/include/opencv2/core/types.hpp" 3
static void convert(const std::vector< KeyPoint>  & keypoints, std::vector< Point_< float> >  & points2f, const std::vector< int>  & keypointIndexes = std::vector< int> ()); 
# 754 "/usr/include/opencv2/core/types.hpp" 3
static void convert(const std::vector< Point_< float> >  & points2f, std::vector< KeyPoint>  & keypoints, float size = 1, float response = 1, int octave = 0, int class_id = -1); 
# 765 "/usr/include/opencv2/core/types.hpp" 3
static float overlap(const KeyPoint & kp1, const KeyPoint & kp2); 
# 767
Point2f pt; 
# 768
float size; 
# 769
float angle; 
# 772
float response; 
# 773
int octave; 
# 774
int class_id; 
# 775
}; 
# 804 "/usr/include/opencv2/core/types.hpp" 3
class __attribute((visibility("default"))) DMatch { 
# 807
public: inline DMatch(); 
# 808
inline DMatch(int _queryIdx, int _trainIdx, float _distance); 
# 809
inline DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance); 
# 811
int queryIdx; 
# 812
int trainIdx; 
# 813
int imgIdx; 
# 815
float distance; 
# 818
inline bool operator<(const DMatch & m) const; 
# 819
}; 
# 848 "/usr/include/opencv2/core/types.hpp" 3
class __attribute((visibility("default"))) TermCriteria { 
# 854
public: enum Type { 
# 856
COUNT = 1, 
# 857
MAX_ITER = 1, 
# 858
EPS
# 859
}; 
# 862
inline TermCriteria(); 
# 868
inline TermCriteria(int type, int maxCount, double epsilon); 
# 870
int type; 
# 871
int maxCount; 
# 872
double epsilon; 
# 873
}; 
# 915 "/usr/include/opencv2/core/types.hpp" 3
class __attribute((visibility("default"))) Moments { 
# 919
public: Moments(); 
# 921
Moments(double m00, double m10, double m01, double m20, double m11, double m02, double m30, double m21, double m12, double m03); 
# 930
double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; 
# 935
double mu20, mu11, mu02, mu30, mu21, mu12, mu03; 
# 940
double nu20, nu11, nu02, nu30, nu21, nu12, nu03; 
# 942
}; 
# 944
template<> class DataType< Moments>  { 
# 947
public: typedef Moments value_type; 
# 948
typedef double work_type; 
# 949
typedef double channel_type; 
# 951
enum { generic_type, 
# 952
channels = 24, 
# 953
fmt = 5988
# 958
}; 
# 960
typedef Vec< double, 24>  vec_type; 
# 961
}; 
# 963
namespace traits { 
# 965
template<> struct Depth< Moments>  { enum { value = 6}; }; 
# 967
template<> struct Type< Moments>  { enum { value = 190}; }; 
# 968
}
# 980 "/usr/include/opencv2/core/types.hpp" 3
template< class _Tp> inline 
# 981
Complex< _Tp> ::Complex() : re(0), im(0) 
# 982
{ } 
# 984
template< class _Tp> inline 
# 985
Complex< _Tp> ::Complex(_Tp _re, _Tp _im) : re(_re), im(_im) 
# 986
{ } 
# 988
template< class _Tp> template< class T2> inline 
# 989
Complex< _Tp> ::operator Complex< T2> () const 
# 990
{ 
# 991
return cv::Complex< T2> (saturate_cast< T2> (re), saturate_cast< T2> (im)); 
# 992
} 
# 994
template< class _Tp> inline Complex< _Tp>  
# 995
Complex< _Tp> ::conj() const 
# 996
{ 
# 997
return Complex(re, -(im)); 
# 998
} 
# 1001
template< class _Tp> static inline bool 
# 1002
operator==(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1003
{ 
# 1004
return ((a.re) == (b.re)) && ((a.im) == (b.im)); 
# 1005
} 
# 1007
template< class _Tp> static inline bool 
# 1008
operator!=(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1009
{ 
# 1010
return ((a.re) != (b.re)) || ((a.im) != (b.im)); 
# 1011
} 
# 1013
template< class _Tp> static inline Complex< _Tp>  
# 1014
operator+(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1015
{ 
# 1016
return Complex< _Tp> ((a.re) + (b.re), (a.im) + (b.im)); 
# 1017
} 
# 1019
template< class _Tp> static inline Complex< _Tp>  &
# 1020
operator+=(Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1021
{ 
# 1022
(a.re) += (b.re); (a.im) += (b.im); 
# 1023
return a; 
# 1024
} 
# 1026
template< class _Tp> static inline Complex< _Tp>  
# 1027
operator-(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1028
{ 
# 1029
return Complex< _Tp> ((a.re) - (b.re), (a.im) - (b.im)); 
# 1030
} 
# 1032
template< class _Tp> static inline Complex< _Tp>  &
# 1033
operator-=(Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1034
{ 
# 1035
(a.re) -= (b.re); (a.im) -= (b.im); 
# 1036
return a; 
# 1037
} 
# 1039
template< class _Tp> static inline Complex< _Tp>  
# 1040
operator-(const Complex< _Tp>  &a) 
# 1041
{ 
# 1042
return Complex< _Tp> (-(a.re), -(a.im)); 
# 1043
} 
# 1045
template< class _Tp> static inline Complex< _Tp>  
# 1046
operator*(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1047
{ 
# 1048
return Complex< _Tp> (((a.re) * (b.re)) - ((a.im) * (b.im)), ((a.re) * (b.im)) + ((a.im) * (b.re))); 
# 1049
} 
# 1051
template< class _Tp> static inline Complex< _Tp>  
# 1052
operator*(const Complex< _Tp>  &a, _Tp b) 
# 1053
{ 
# 1054
return Complex< _Tp> ((a.re) * b, (a.im) * b); 
# 1055
} 
# 1057
template< class _Tp> static inline Complex< _Tp>  
# 1058
operator*(_Tp b, const Complex< _Tp>  &a) 
# 1059
{ 
# 1060
return Complex< _Tp> ((a.re) * b, (a.im) * b); 
# 1061
} 
# 1063
template< class _Tp> static inline Complex< _Tp>  
# 1064
operator+(const Complex< _Tp>  &a, _Tp b) 
# 1065
{ 
# 1066
return Complex< _Tp> ((a.re) + b, (a.im)); 
# 1067
} 
# 1069
template< class _Tp> static inline Complex< _Tp>  
# 1070
operator-(const Complex< _Tp>  &a, _Tp b) 
# 1071
{ return Complex< _Tp> ((a.re) - b, (a.im)); } 
# 1073
template< class _Tp> static inline Complex< _Tp>  
# 1074
operator+(_Tp b, const Complex< _Tp>  &a) 
# 1075
{ 
# 1076
return Complex< _Tp> ((a.re) + b, (a.im)); 
# 1077
} 
# 1079
template< class _Tp> static inline Complex< _Tp>  
# 1080
operator-(_Tp b, const Complex< _Tp>  &a) 
# 1081
{ 
# 1082
return Complex< _Tp> (b - (a.re), -(a.im)); 
# 1083
} 
# 1085
template< class _Tp> static inline Complex< _Tp>  &
# 1086
operator+=(Complex< _Tp>  &a, _Tp b) 
# 1087
{ 
# 1088
(a.re) += b; return a; 
# 1089
} 
# 1091
template< class _Tp> static inline Complex< _Tp>  &
# 1092
operator-=(Complex< _Tp>  &a, _Tp b) 
# 1093
{ 
# 1094
(a.re) -= b; return a; 
# 1095
} 
# 1097
template< class _Tp> static inline Complex< _Tp>  &
# 1098
operator*=(Complex< _Tp>  &a, _Tp b) 
# 1099
{ 
# 1100
(a.re) *= b; (a.im) *= b; return a; 
# 1101
} 
# 1103
template< class _Tp> static inline double 
# 1104
abs(const Complex< _Tp>  &a) 
# 1105
{ 
# 1106
return std::sqrt((((double)(a.re)) * (a.re)) + (((double)(a.im)) * (a.im))); 
# 1107
} 
# 1109
template< class _Tp> static inline Complex< _Tp>  
# 1110
operator/(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1111
{ 
# 1112
double t = (1.0) / ((((double)(b.re)) * (b.re)) + (((double)(b.im)) * (b.im))); 
# 1113
return Complex< _Tp> ((_Tp)((((a.re) * (b.re)) + ((a.im) * (b.im))) * t), (_Tp)((((-(a.re)) * (b.im)) + ((a.im) * (b.re))) * t)); 
# 1115
} 
# 1117
template< class _Tp> static inline Complex< _Tp>  &
# 1118
operator/=(Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1119
{ 
# 1120
a = (a / b); 
# 1121
return a; 
# 1122
} 
# 1124
template< class _Tp> static inline Complex< _Tp>  
# 1125
operator/(const Complex< _Tp>  &a, _Tp b) 
# 1126
{ 
# 1127
_Tp t = ((_Tp)1) / b; 
# 1128
return Complex< _Tp> ((a.re) * t, (a.im) * t); 
# 1129
} 
# 1131
template< class _Tp> static inline Complex< _Tp>  
# 1132
operator/(_Tp b, const Complex< _Tp>  &a) 
# 1133
{ 
# 1134
return ((Complex< _Tp> )(b)) / a; 
# 1135
} 
# 1137
template< class _Tp> static inline Complex< _Tp>  
# 1138
operator/=(const Complex< _Tp>  &a, _Tp b) 
# 1139
{ 
# 1140
_Tp t = ((_Tp)1) / b; 
# 1141
(a.re) *= t; (a.im) *= t; return a; 
# 1142
} 
# 1148
template< class _Tp> inline 
# 1149
Point_< _Tp> ::Point_() : x(0), y(0) 
# 1150
{ } 
# 1152
template< class _Tp> inline 
# 1153
Point_< _Tp> ::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) 
# 1154
{ } 
# 1156
template< class _Tp> inline 
# 1157
Point_< _Tp> ::Point_(const Point_ &pt) : x((pt.x)), y((pt.y)) 
# 1158
{ } 
# 1160
template< class _Tp> inline 
# 1161
Point_< _Tp> ::Point_(const Size_< _Tp>  &sz) : x((sz.width)), y((sz.height)) 
# 1162
{ } 
# 1164
template< class _Tp> inline 
# 1165
Point_< _Tp> ::Point_(const Vec< _Tp, 2>  &v) : x(v[0]), y(v[1]) 
# 1166
{ } 
# 1168
template< class _Tp> inline Point_< _Tp>  &
# 1169
Point_< _Tp> ::operator=(const Point_ &pt) 
# 1170
{ 
# 1171
(x) = (pt.x); (y) = (pt.y); 
# 1172
return *this; 
# 1173
} 
# 1175
template< class _Tp> template< class _Tp2> inline 
# 1176
Point_< _Tp> ::operator Point_< _Tp2> () const 
# 1177
{ 
# 1178
return cv::Point_< _Tp2> (saturate_cast< _Tp2> (x), saturate_cast< _Tp2> (y)); 
# 1179
} 
# 1181
template< class _Tp> inline 
# 1182
Point_< _Tp> ::operator Vec< _Tp, 2> () const 
# 1183
{ 
# 1184
return Vec< _Tp, 2> (x, y); 
# 1185
} 
# 1187
template< class _Tp> inline _Tp 
# 1188
Point_< _Tp> ::dot(const Point_ &pt) const 
# 1189
{ 
# 1190
return saturate_cast< _Tp> (((x) * (pt.x)) + ((y) * (pt.y))); 
# 1191
} 
# 1193
template< class _Tp> inline double 
# 1194
Point_< _Tp> ::ddot(const Point_ &pt) const 
# 1195
{ 
# 1196
return (((double)(x)) * (pt.x)) + (((double)(y)) * (pt.y)); 
# 1197
} 
# 1199
template< class _Tp> inline double 
# 1200
Point_< _Tp> ::cross(const Point_ &pt) const 
# 1201
{ 
# 1202
return (((double)(x)) * (pt.y)) - (((double)(y)) * (pt.x)); 
# 1203
} 
# 1205
template< class _Tp> inline bool 
# 1206
Point_< _Tp> ::inside(const Rect_< _Tp>  &r) const 
# 1207
{ 
# 1208
return (r.contains(*this)); 
# 1209
} 
# 1212
template< class _Tp> static inline Point_< _Tp>  &
# 1213
operator+=(Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1214
{ 
# 1215
(a.x) += (b.x); 
# 1216
(a.y) += (b.y); 
# 1217
return a; 
# 1218
} 
# 1220
template< class _Tp> static inline Point_< _Tp>  &
# 1221
operator-=(Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1222
{ 
# 1223
(a.x) -= (b.x); 
# 1224
(a.y) -= (b.y); 
# 1225
return a; 
# 1226
} 
# 1228
template< class _Tp> static inline Point_< _Tp>  &
# 1229
operator*=(Point_< _Tp>  &a, int b) 
# 1230
{ 
# 1231
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1232
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1233
return a; 
# 1234
} 
# 1236
template< class _Tp> static inline Point_< _Tp>  &
# 1237
operator*=(Point_< _Tp>  &a, float b) 
# 1238
{ 
# 1239
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1240
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1241
return a; 
# 1242
} 
# 1244
template< class _Tp> static inline Point_< _Tp>  &
# 1245
operator*=(Point_< _Tp>  &a, double b) 
# 1246
{ 
# 1247
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1248
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1249
return a; 
# 1250
} 
# 1252
template< class _Tp> static inline Point_< _Tp>  &
# 1253
operator/=(Point_< _Tp>  &a, int b) 
# 1254
{ 
# 1255
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1256
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1257
return a; 
# 1258
} 
# 1260
template< class _Tp> static inline Point_< _Tp>  &
# 1261
operator/=(Point_< _Tp>  &a, float b) 
# 1262
{ 
# 1263
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1264
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1265
return a; 
# 1266
} 
# 1268
template< class _Tp> static inline Point_< _Tp>  &
# 1269
operator/=(Point_< _Tp>  &a, double b) 
# 1270
{ 
# 1271
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1272
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1273
return a; 
# 1274
} 
# 1276
template< class _Tp> static inline double 
# 1277
norm(const Point_< _Tp>  &pt) 
# 1278
{ 
# 1279
return std::sqrt((((double)(pt.x)) * (pt.x)) + (((double)(pt.y)) * (pt.y))); 
# 1280
} 
# 1282
template< class _Tp> static inline bool 
# 1283
operator==(const Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1284
{ 
# 1285
return ((a.x) == (b.x)) && ((a.y) == (b.y)); 
# 1286
} 
# 1288
template< class _Tp> static inline bool 
# 1289
operator!=(const Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1290
{ 
# 1291
return ((a.x) != (b.x)) || ((a.y) != (b.y)); 
# 1292
} 
# 1294
template< class _Tp> static inline Point_< _Tp>  
# 1295
operator+(const Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1296
{ 
# 1297
return Point_< _Tp> (saturate_cast< _Tp> ((a.x) + (b.x)), saturate_cast< _Tp> ((a.y) + (b.y))); 
# 1298
} 
# 1300
template< class _Tp> static inline Point_< _Tp>  
# 1301
operator-(const Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1302
{ 
# 1303
return Point_< _Tp> (saturate_cast< _Tp> ((a.x) - (b.x)), saturate_cast< _Tp> ((a.y) - (b.y))); 
# 1304
} 
# 1306
template< class _Tp> static inline Point_< _Tp>  
# 1307
operator-(const Point_< _Tp>  &a) 
# 1308
{ 
# 1309
return Point_< _Tp> (saturate_cast< _Tp> (-(a.x)), saturate_cast< _Tp> (-(a.y))); 
# 1310
} 
# 1312
template< class _Tp> static inline Point_< _Tp>  
# 1313
operator*(const Point_< _Tp>  &a, int b) 
# 1314
{ 
# 1315
return Point_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b)); 
# 1316
} 
# 1318
template< class _Tp> static inline Point_< _Tp>  
# 1319
operator*(int a, const Point_< _Tp>  &b) 
# 1320
{ 
# 1321
return Point_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a)); 
# 1322
} 
# 1324
template< class _Tp> static inline Point_< _Tp>  
# 1325
operator*(const Point_< _Tp>  &a, float b) 
# 1326
{ 
# 1327
return Point_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b)); 
# 1328
} 
# 1330
template< class _Tp> static inline Point_< _Tp>  
# 1331
operator*(float a, const Point_< _Tp>  &b) 
# 1332
{ 
# 1333
return Point_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a)); 
# 1334
} 
# 1336
template< class _Tp> static inline Point_< _Tp>  
# 1337
operator*(const Point_< _Tp>  &a, double b) 
# 1338
{ 
# 1339
return Point_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b)); 
# 1340
} 
# 1342
template< class _Tp> static inline Point_< _Tp>  
# 1343
operator*(double a, const Point_< _Tp>  &b) 
# 1344
{ 
# 1345
return Point_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a)); 
# 1346
} 
# 1348
template< class _Tp> static inline Point_< _Tp>  
# 1349
operator*(const Matx< _Tp, 2, 2>  &a, const Point_< _Tp>  &b) 
# 1350
{ 
# 1351
Matx< _Tp, 2, 1>  tmp = a * Vec< _Tp, 2> ((b.x), (b.y)); 
# 1352
return Point_< _Tp> ((tmp.val)[0], (tmp.val)[1]); 
# 1353
} 
# 1355
template< class _Tp> static inline Point3_< _Tp>  
# 1356
operator*(const Matx< _Tp, 3, 3>  &a, const Point_< _Tp>  &b) 
# 1357
{ 
# 1358
Matx< _Tp, 3, 1>  tmp = a * Vec< _Tp, 3> ((b.x), (b.y), 1); 
# 1359
return Point3_< _Tp> ((tmp.val)[0], (tmp.val)[1], (tmp.val)[2]); 
# 1360
} 
# 1362
template< class _Tp> static inline Point_< _Tp>  
# 1363
operator/(const Point_< _Tp>  &a, int b) 
# 1364
{ 
# 1365
Point_< _Tp>  tmp(a); 
# 1366
tmp /= b; 
# 1367
return tmp; 
# 1368
} 
# 1370
template< class _Tp> static inline Point_< _Tp>  
# 1371
operator/(const Point_< _Tp>  &a, float b) 
# 1372
{ 
# 1373
Point_< _Tp>  tmp(a); 
# 1374
tmp /= b; 
# 1375
return tmp; 
# 1376
} 
# 1378
template< class _Tp> static inline Point_< _Tp>  
# 1379
operator/(const Point_< _Tp>  &a, double b) 
# 1380
{ 
# 1381
Point_< _Tp>  tmp(a); 
# 1382
tmp /= b; 
# 1383
return tmp; 
# 1384
} 
# 1390
template< class _Tp> inline 
# 1391
Point3_< _Tp> ::Point3_() : x(0), y(0), z(0) 
# 1392
{ } 
# 1394
template< class _Tp> inline 
# 1395
Point3_< _Tp> ::Point3_(_Tp _x, _Tp _y, _Tp _z) : x(_x), y(_y), z(_z) 
# 1396
{ } 
# 1398
template< class _Tp> inline 
# 1399
Point3_< _Tp> ::Point3_(const Point3_ &pt) : x((pt.x)), y((pt.y)), z((pt.z)) 
# 1400
{ } 
# 1402
template< class _Tp> inline 
# 1403
Point3_< _Tp> ::Point3_(const Point_< _Tp>  &pt) : x((pt.x)), y((pt.y)), z(_Tp()) 
# 1404
{ } 
# 1406
template< class _Tp> inline 
# 1407
Point3_< _Tp> ::Point3_(const Vec< _Tp, 3>  &v) : x(v[0]), y(v[1]), z(v[2]) 
# 1408
{ } 
# 1410
template< class _Tp> template< class _Tp2> inline 
# 1411
Point3_< _Tp> ::operator Point3_< _Tp2> () const 
# 1412
{ 
# 1413
return cv::Point3_< _Tp2> (saturate_cast< _Tp2> (x), saturate_cast< _Tp2> (y), saturate_cast< _Tp2> (z)); 
# 1414
} 
# 1423 "/usr/include/opencv2/core/types.hpp" 3
template< class _Tp> inline 
# 1424
Point3_< _Tp> ::operator Vec< _Tp, 3> () const 
# 1425
{ 
# 1426
return Vec< _Tp, 3> (x, y, z); 
# 1427
} 
# 1430
template< class _Tp> inline Point3_< _Tp>  &
# 1431
Point3_< _Tp> ::operator=(const Point3_ &pt) 
# 1432
{ 
# 1433
(x) = (pt.x); (y) = (pt.y); (z) = (pt.z); 
# 1434
return *this; 
# 1435
} 
# 1437
template< class _Tp> inline _Tp 
# 1438
Point3_< _Tp> ::dot(const Point3_ &pt) const 
# 1439
{ 
# 1440
return saturate_cast< _Tp> ((((x) * (pt.x)) + ((y) * (pt.y))) + ((z) * (pt.z))); 
# 1441
} 
# 1443
template< class _Tp> inline double 
# 1444
Point3_< _Tp> ::ddot(const Point3_ &pt) const 
# 1445
{ 
# 1446
return ((((double)(x)) * (pt.x)) + (((double)(y)) * (pt.y))) + (((double)(z)) * (pt.z)); 
# 1447
} 
# 1449
template< class _Tp> inline Point3_< _Tp>  
# 1450
Point3_< _Tp> ::cross(const Point3_ &pt) const 
# 1451
{ 
# 1452
return Point3_(((y) * (pt.z)) - ((z) * (pt.y)), ((z) * (pt.x)) - ((x) * (pt.z)), ((x) * (pt.y)) - ((y) * (pt.x))); 
# 1453
} 
# 1456
template< class _Tp> static inline Point3_< _Tp>  &
# 1457
operator+=(Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1458
{ 
# 1459
(a.x) += (b.x); 
# 1460
(a.y) += (b.y); 
# 1461
(a.z) += (b.z); 
# 1462
return a; 
# 1463
} 
# 1465
template< class _Tp> static inline Point3_< _Tp>  &
# 1466
operator-=(Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1467
{ 
# 1468
(a.x) -= (b.x); 
# 1469
(a.y) -= (b.y); 
# 1470
(a.z) -= (b.z); 
# 1471
return a; 
# 1472
} 
# 1474
template< class _Tp> static inline Point3_< _Tp>  &
# 1475
operator*=(Point3_< _Tp>  &a, int b) 
# 1476
{ 
# 1477
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1478
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1479
(a.z) = saturate_cast< _Tp> ((a.z) * b); 
# 1480
return a; 
# 1481
} 
# 1483
template< class _Tp> static inline Point3_< _Tp>  &
# 1484
operator*=(Point3_< _Tp>  &a, float b) 
# 1485
{ 
# 1486
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1487
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1488
(a.z) = saturate_cast< _Tp> ((a.z) * b); 
# 1489
return a; 
# 1490
} 
# 1492
template< class _Tp> static inline Point3_< _Tp>  &
# 1493
operator*=(Point3_< _Tp>  &a, double b) 
# 1494
{ 
# 1495
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1496
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1497
(a.z) = saturate_cast< _Tp> ((a.z) * b); 
# 1498
return a; 
# 1499
} 
# 1501
template< class _Tp> static inline Point3_< _Tp>  &
# 1502
operator/=(Point3_< _Tp>  &a, int b) 
# 1503
{ 
# 1504
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1505
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1506
(a.z) = saturate_cast< _Tp> ((a.z) / b); 
# 1507
return a; 
# 1508
} 
# 1510
template< class _Tp> static inline Point3_< _Tp>  &
# 1511
operator/=(Point3_< _Tp>  &a, float b) 
# 1512
{ 
# 1513
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1514
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1515
(a.z) = saturate_cast< _Tp> ((a.z) / b); 
# 1516
return a; 
# 1517
} 
# 1519
template< class _Tp> static inline Point3_< _Tp>  &
# 1520
operator/=(Point3_< _Tp>  &a, double b) 
# 1521
{ 
# 1522
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1523
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1524
(a.z) = saturate_cast< _Tp> ((a.z) / b); 
# 1525
return a; 
# 1526
} 
# 1528
template< class _Tp> static inline double 
# 1529
norm(const Point3_< _Tp>  &pt) 
# 1530
{ 
# 1531
return std::sqrt(((((double)(pt.x)) * (pt.x)) + (((double)(pt.y)) * (pt.y))) + (((double)(pt.z)) * (pt.z))); 
# 1532
} 
# 1534
template< class _Tp> static inline bool 
# 1535
operator==(const Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1536
{ 
# 1537
return ((a.x) == (b.x)) && ((a.y) == (b.y)) && ((a.z) == (b.z)); 
# 1538
} 
# 1540
template< class _Tp> static inline bool 
# 1541
operator!=(const Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1542
{ 
# 1543
return (((a.x) != (b.x)) || ((a.y) != (b.y))) || ((a.z) != (b.z)); 
# 1544
} 
# 1546
template< class _Tp> static inline Point3_< _Tp>  
# 1547
operator+(const Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1548
{ 
# 1549
return Point3_< _Tp> (saturate_cast< _Tp> ((a.x) + (b.x)), saturate_cast< _Tp> ((a.y) + (b.y)), saturate_cast< _Tp> ((a.z) + (b.z))); 
# 1550
} 
# 1552
template< class _Tp> static inline Point3_< _Tp>  
# 1553
operator-(const Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1554
{ 
# 1555
return Point3_< _Tp> (saturate_cast< _Tp> ((a.x) - (b.x)), saturate_cast< _Tp> ((a.y) - (b.y)), saturate_cast< _Tp> ((a.z) - (b.z))); 
# 1556
} 
# 1558
template< class _Tp> static inline Point3_< _Tp>  
# 1559
operator-(const Point3_< _Tp>  &a) 
# 1560
{ 
# 1561
return Point3_< _Tp> (saturate_cast< _Tp> (-(a.x)), saturate_cast< _Tp> (-(a.y)), saturate_cast< _Tp> (-(a.z))); 
# 1562
} 
# 1564
template< class _Tp> static inline Point3_< _Tp>  
# 1565
operator*(const Point3_< _Tp>  &a, int b) 
# 1566
{ 
# 1567
return Point3_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b), saturate_cast< _Tp> ((a.z) * b)); 
# 1568
} 
# 1570
template< class _Tp> static inline Point3_< _Tp>  
# 1571
operator*(int a, const Point3_< _Tp>  &b) 
# 1572
{ 
# 1573
return Point3_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a), saturate_cast< _Tp> ((b.z) * a)); 
# 1574
} 
# 1576
template< class _Tp> static inline Point3_< _Tp>  
# 1577
operator*(const Point3_< _Tp>  &a, float b) 
# 1578
{ 
# 1579
return Point3_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b), saturate_cast< _Tp> ((a.z) * b)); 
# 1580
} 
# 1582
template< class _Tp> static inline Point3_< _Tp>  
# 1583
operator*(float a, const Point3_< _Tp>  &b) 
# 1584
{ 
# 1585
return Point3_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a), saturate_cast< _Tp> ((b.z) * a)); 
# 1586
} 
# 1588
template< class _Tp> static inline Point3_< _Tp>  
# 1589
operator*(const Point3_< _Tp>  &a, double b) 
# 1590
{ 
# 1591
return Point3_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b), saturate_cast< _Tp> ((a.z) * b)); 
# 1592
} 
# 1594
template< class _Tp> static inline Point3_< _Tp>  
# 1595
operator*(double a, const Point3_< _Tp>  &b) 
# 1596
{ 
# 1597
return Point3_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a), saturate_cast< _Tp> ((b.z) * a)); 
# 1598
} 
# 1600
template< class _Tp> static inline Point3_< _Tp>  
# 1601
operator*(const Matx< _Tp, 3, 3>  &a, const Point3_< _Tp>  &b) 
# 1602
{ 
# 1603
Matx< _Tp, 3, 1>  tmp = a * Vec< _Tp, 3> ((b.x), (b.y), (b.z)); 
# 1604
return Point3_< _Tp> ((tmp.val)[0], (tmp.val)[1], (tmp.val)[2]); 
# 1605
} 
# 1607
template< class _Tp> static inline Matx< _Tp, 4, 1>  
# 1608
operator*(const Matx< _Tp, 4, 4>  &a, const Point3_< _Tp>  &b) 
# 1609
{ 
# 1610
return a * Matx< _Tp, 4, 1> ((b.x), (b.y), (b.z), 1); 
# 1611
} 
# 1613
template< class _Tp> static inline Point3_< _Tp>  
# 1614
operator/(const Point3_< _Tp>  &a, int b) 
# 1615
{ 
# 1616
Point3_< _Tp>  tmp(a); 
# 1617
tmp /= b; 
# 1618
return tmp; 
# 1619
} 
# 1621
template< class _Tp> static inline Point3_< _Tp>  
# 1622
operator/(const Point3_< _Tp>  &a, float b) 
# 1623
{ 
# 1624
Point3_< _Tp>  tmp(a); 
# 1625
tmp /= b; 
# 1626
return tmp; 
# 1627
} 
# 1629
template< class _Tp> static inline Point3_< _Tp>  
# 1630
operator/(const Point3_< _Tp>  &a, double b) 
# 1631
{ 
# 1632
Point3_< _Tp>  tmp(a); 
# 1633
tmp /= b; 
# 1634
return tmp; 
# 1635
} 
# 1641
template< class _Tp> inline 
# 1642
Size_< _Tp> ::Size_() : width(0), height(0) 
# 1643
{ } 
# 1645
template< class _Tp> inline 
# 1646
Size_< _Tp> ::Size_(_Tp _width, _Tp _height) : width(_width), height(_height) 
# 1647
{ } 
# 1649
template< class _Tp> inline 
# 1650
Size_< _Tp> ::Size_(const Size_ &sz) : width((sz.width)), height((sz.height)) 
# 1651
{ } 
# 1653
template< class _Tp> inline 
# 1654
Size_< _Tp> ::Size_(const Point_< _Tp>  &pt) : width((pt.x)), height((pt.y)) 
# 1655
{ } 
# 1657
template< class _Tp> template< class _Tp2> inline 
# 1658
Size_< _Tp> ::operator Size_< _Tp2> () const 
# 1659
{ 
# 1660
return cv::Size_< _Tp2> (saturate_cast< _Tp2> (width), saturate_cast< _Tp2> (height)); 
# 1661
} 
# 1663
template< class _Tp> inline Size_< _Tp>  &
# 1664
Size_< _Tp> ::operator=(const Size_ &sz) 
# 1665
{ 
# 1666
(width) = (sz.width); (height) = (sz.height); 
# 1667
return *this; 
# 1668
} 
# 1670
template< class _Tp> inline _Tp 
# 1671
Size_< _Tp> ::area() const 
# 1672
{ 
# 1673
const _Tp result = (width) * (height); 
# 1675
; 
# 1676
return result; 
# 1677
} 
# 1679
template< class _Tp> inline bool 
# 1680
Size_< _Tp> ::empty() const 
# 1681
{ 
# 1682
return ((width) <= 0) || ((height) <= 0); 
# 1683
} 
# 1686
template< class _Tp> static inline Size_< _Tp>  &
# 1687
operator*=(Size_< _Tp>  &a, _Tp b) 
# 1688
{ 
# 1689
(a.width) *= b; 
# 1690
(a.height) *= b; 
# 1691
return a; 
# 1692
} 
# 1694
template< class _Tp> static inline Size_< _Tp>  
# 1695
operator*(const Size_< _Tp>  &a, _Tp b) 
# 1696
{ 
# 1697
Size_< _Tp>  tmp(a); 
# 1698
tmp *= b; 
# 1699
return tmp; 
# 1700
} 
# 1702
template< class _Tp> static inline Size_< _Tp>  &
# 1703
operator/=(Size_< _Tp>  &a, _Tp b) 
# 1704
{ 
# 1705
(a.width) /= b; 
# 1706
(a.height) /= b; 
# 1707
return a; 
# 1708
} 
# 1710
template< class _Tp> static inline Size_< _Tp>  
# 1711
operator/(const Size_< _Tp>  &a, _Tp b) 
# 1712
{ 
# 1713
Size_< _Tp>  tmp(a); 
# 1714
tmp /= b; 
# 1715
return tmp; 
# 1716
} 
# 1718
template< class _Tp> static inline Size_< _Tp>  &
# 1719
operator+=(Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1720
{ 
# 1721
(a.width) += (b.width); 
# 1722
(a.height) += (b.height); 
# 1723
return a; 
# 1724
} 
# 1726
template< class _Tp> static inline Size_< _Tp>  
# 1727
operator+(const Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1728
{ 
# 1729
Size_< _Tp>  tmp(a); 
# 1730
tmp += b; 
# 1731
return tmp; 
# 1732
} 
# 1734
template< class _Tp> static inline Size_< _Tp>  &
# 1735
operator-=(Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1736
{ 
# 1737
(a.width) -= (b.width); 
# 1738
(a.height) -= (b.height); 
# 1739
return a; 
# 1740
} 
# 1742
template< class _Tp> static inline Size_< _Tp>  
# 1743
operator-(const Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1744
{ 
# 1745
Size_< _Tp>  tmp(a); 
# 1746
tmp -= b; 
# 1747
return tmp; 
# 1748
} 
# 1750
template< class _Tp> static inline bool 
# 1751
operator==(const Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1752
{ 
# 1753
return ((a.width) == (b.width)) && ((a.height) == (b.height)); 
# 1754
} 
# 1756
template< class _Tp> static inline bool 
# 1757
operator!=(const Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1758
{ 
# 1759
return !(a == b); 
# 1760
} 
# 1766
template< class _Tp> inline 
# 1767
Rect_< _Tp> ::Rect_() : x(0), y(0), width(0), height(0) 
# 1768
{ } 
# 1770
template< class _Tp> inline 
# 1771
Rect_< _Tp> ::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height) : x(_x), y(_y), width(_width), height(_height) 
# 1772
{ } 
# 1774
template< class _Tp> inline 
# 1775
Rect_< _Tp> ::Rect_(const Rect_ &r) : x((r.x)), y((r.y)), width((r.width)), height((r.height)) 
# 1776
{ } 
# 1778
template< class _Tp> inline 
# 1779
Rect_< _Tp> ::Rect_(const Point_< _Tp>  &org, const Size_< _Tp>  &sz) : x((org.x)), y((org.y)), width((sz.width)), height((sz.height)) 
# 1780
{ } 
# 1782
template< class _Tp> inline 
# 1783
Rect_< _Tp> ::Rect_(const Point_< _Tp>  &pt1, const Point_< _Tp>  &pt2) 
# 1784
{ 
# 1785
(x) = std::min((pt1.x), (pt2.x)); 
# 1786
(y) = std::min((pt1.y), (pt2.y)); 
# 1787
(width) = (std::max((pt1.x), (pt2.x)) - (x)); 
# 1788
(height) = (std::max((pt1.y), (pt2.y)) - (y)); 
# 1789
} 
# 1791
template< class _Tp> inline Rect_< _Tp>  &
# 1792
Rect_< _Tp> ::operator=(const Rect_ &r) 
# 1793
{ 
# 1794
(x) = (r.x); 
# 1795
(y) = (r.y); 
# 1796
(width) = (r.width); 
# 1797
(height) = (r.height); 
# 1798
return *this; 
# 1799
} 
# 1801
template< class _Tp> inline Point_< _Tp>  
# 1802
Rect_< _Tp> ::tl() const 
# 1803
{ 
# 1804
return Point_< _Tp> (x, y); 
# 1805
} 
# 1807
template< class _Tp> inline Point_< _Tp>  
# 1808
Rect_< _Tp> ::br() const 
# 1809
{ 
# 1810
return Point_< _Tp> ((x) + (width), (y) + (height)); 
# 1811
} 
# 1813
template< class _Tp> inline Size_< _Tp>  
# 1814
Rect_< _Tp> ::size() const 
# 1815
{ 
# 1816
return Size_< _Tp> (width, height); 
# 1817
} 
# 1819
template< class _Tp> inline _Tp 
# 1820
Rect_< _Tp> ::area() const 
# 1821
{ 
# 1822
const _Tp result = (width) * (height); 
# 1824
; 
# 1825
return result; 
# 1826
} 
# 1828
template< class _Tp> inline bool 
# 1829
Rect_< _Tp> ::empty() const 
# 1830
{ 
# 1831
return ((width) <= 0) || ((height) <= 0); 
# 1832
} 
# 1834
template< class _Tp> template< class _Tp2> inline 
# 1835
Rect_< _Tp> ::operator Rect_< _Tp2> () const 
# 1836
{ 
# 1837
return cv::Rect_< _Tp2> (saturate_cast< _Tp2> (x), saturate_cast< _Tp2> (y), saturate_cast< _Tp2> (width), saturate_cast< _Tp2> (height)); 
# 1838
} 
# 1840
template< class _Tp> inline bool 
# 1841
Rect_< _Tp> ::contains(const Point_< _Tp>  &pt) const 
# 1842
{ 
# 1843
return ((x) <= (pt.x)) && ((pt.x) < ((x) + (width))) && ((y) <= (pt.y)) && ((pt.y) < ((y) + (height))); 
# 1844
} 
# 1847
template< class _Tp> static inline Rect_< _Tp>  &
# 1848
operator+=(Rect_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1849
{ 
# 1850
(a.x) += (b.x); 
# 1851
(a.y) += (b.y); 
# 1852
return a; 
# 1853
} 
# 1855
template< class _Tp> static inline Rect_< _Tp>  &
# 1856
operator-=(Rect_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1857
{ 
# 1858
(a.x) -= (b.x); 
# 1859
(a.y) -= (b.y); 
# 1860
return a; 
# 1861
} 
# 1863
template< class _Tp> static inline Rect_< _Tp>  &
# 1864
operator+=(Rect_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1865
{ 
# 1866
(a.width) += (b.width); 
# 1867
(a.height) += (b.height); 
# 1868
return a; 
# 1869
} 
# 1871
template< class _Tp> static inline Rect_< _Tp>  &
# 1872
operator-=(Rect_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1873
{ 
# 1874
(a.width) -= (b.width); 
# 1875
(a.height) -= (b.height); 
# 1876
return a; 
# 1877
} 
# 1879
template< class _Tp> static inline Rect_< _Tp>  &
# 1880
operator&=(Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 1881
{ 
# 1882
_Tp x1 = std::max((a.x), (b.x)); 
# 1883
_Tp y1 = std::max((a.y), (b.y)); 
# 1884
(a.width) = (std::min((a.x) + (a.width), (b.x) + (b.width)) - x1); 
# 1885
(a.height) = (std::min((a.y) + (a.height), (b.y) + (b.height)) - y1); 
# 1886
(a.x) = x1; 
# 1887
(a.y) = y1; 
# 1888
if (((a.width) <= 0) || ((a.height) <= 0)) { 
# 1889
a = Rect(); }  
# 1890
return a; 
# 1891
} 
# 1893
template< class _Tp> static inline Rect_< _Tp>  &
# 1894
operator|=(Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 1895
{ 
# 1896
if ((a.empty())) { 
# 1897
a = b; 
# 1898
} else { 
# 1899
if (!(b.empty())) { 
# 1900
_Tp x1 = std::min((a.x), (b.x)); 
# 1901
_Tp y1 = std::min((a.y), (b.y)); 
# 1902
(a.width) = (std::max((a.x) + (a.width), (b.x) + (b.width)) - x1); 
# 1903
(a.height) = (std::max((a.y) + (a.height), (b.y) + (b.height)) - y1); 
# 1904
(a.x) = x1; 
# 1905
(a.y) = y1; 
# 1906
}  }  
# 1907
return a; 
# 1908
} 
# 1910
template< class _Tp> static inline bool 
# 1911
operator==(const Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 1912
{ 
# 1913
return ((a.x) == (b.x)) && ((a.y) == (b.y)) && ((a.width) == (b.width)) && ((a.height) == (b.height)); 
# 1914
} 
# 1916
template< class _Tp> static inline bool 
# 1917
operator!=(const Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 1918
{ 
# 1919
return ((((a.x) != (b.x)) || ((a.y) != (b.y))) || ((a.width) != (b.width))) || ((a.height) != (b.height)); 
# 1920
} 
# 1922
template< class _Tp> static inline Rect_< _Tp>  
# 1923
operator+(const Rect_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1924
{ 
# 1925
return Rect_< _Tp> ((a.x) + (b.x), (a.y) + (b.y), (a.width), (a.height)); 
# 1926
} 
# 1928
template< class _Tp> static inline Rect_< _Tp>  
# 1929
operator-(const Rect_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1930
{ 
# 1931
return Rect_< _Tp> ((a.x) - (b.x), (a.y) - (b.y), (a.width), (a.height)); 
# 1932
} 
# 1934
template< class _Tp> static inline Rect_< _Tp>  
# 1935
operator+(const Rect_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1936
{ 
# 1937
return Rect_< _Tp> ((a.x), (a.y), (a.width) + (b.width), (a.height) + (b.height)); 
# 1938
} 
# 1940
template< class _Tp> static inline Rect_< _Tp>  
# 1941
operator&(const Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 1942
{ 
# 1943
Rect_< _Tp>  c = a; 
# 1944
return c &= b; 
# 1945
} 
# 1947
template< class _Tp> static inline Rect_< _Tp>  
# 1948
operator|(const Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 1949
{ 
# 1950
Rect_< _Tp>  c = a; 
# 1951
return c |= b; 
# 1952
} 
# 1960
template< class _Tp> static inline double 
# 1961
jaccardDistance(const Rect_< _Tp>  &a, const Rect_< _Tp>  &b) { 
# 1962
_Tp Aa = (a.area()); 
# 1963
_Tp Ab = (b.area()); 
# 1965
if ((Aa + Ab) <= std::numeric_limits< _Tp> ::epsilon()) { 
# 1967
return (0.0); 
# 1968
}  
# 1970
double Aab = ((a & b).area()); 
# 1972
return (1.0) - (Aab / ((Aa + Ab) - Aab)); 
# 1973
} 
# 1978
inline RotatedRect::RotatedRect() : center(), size(), angle((0)) 
# 1979
{ } 
# 1982
inline RotatedRect::RotatedRect(const Point2f &_center, const Size2f &_size, float _angle) : center(_center), size(_size), angle(_angle) 
# 1983
{ } 
# 1990
inline Range::Range() : start(0), end(0) 
# 1991
{ } 
# 1994
inline Range::Range(int _start, int _end) : start(_start), end(_end) 
# 1995
{ } 
# 1998
inline int Range::size() const 
# 1999
{ 
# 2000
return (end) - (start); 
# 2001
} 
# 2004
inline bool Range::empty() const 
# 2005
{ 
# 2006
return (start) == (end); 
# 2007
} 
# 2010
inline Range Range::all() 
# 2011
{ 
# 2012
return Range((-2147483647) - 1, 2147483647); 
# 2013
} 
# 2017
static inline bool operator==(const Range &r1, const Range &r2) 
# 2018
{ 
# 2019
return ((r1.start) == (r2.start)) && ((r1.end) == (r2.end)); 
# 2020
} 
# 2023
static inline bool operator!=(const Range &r1, const Range &r2) 
# 2024
{ 
# 2025
return !((r1 == r2)); 
# 2026
} 
# 2029
static inline bool operator!(const Range &r) 
# 2030
{ 
# 2031
return (r.start) == (r.end); 
# 2032
} 
# 2035
static inline Range operator&(const Range &r1, const Range &r2) 
# 2036
{ 
# 2037
Range r(std::max(r1.start, r2.start), std::min(r1.end, r2.end)); 
# 2038
(r.end) = std::max(r.end, r.start); 
# 2039
return r; 
# 2040
} 
# 2043
static inline Range &operator&=(Range &r1, const Range &r2) 
# 2044
{ 
# 2045
r1 = ((r1 & r2)); 
# 2046
return r1; 
# 2047
} 
# 2050
static inline Range operator+(const Range &r1, int delta) 
# 2051
{ 
# 2052
return Range((r1.start) + delta, (r1.end) + delta); 
# 2053
} 
# 2056
static inline Range operator+(int delta, const Range &r1) 
# 2057
{ 
# 2058
return Range((r1.start) + delta, (r1.end) + delta); 
# 2059
} 
# 2062
static inline Range operator-(const Range &r1, int delta) 
# 2063
{ 
# 2064
return (r1 + (-delta)); 
# 2065
} 
# 2071
template< class _Tp> inline 
# 2072
Scalar_< _Tp> ::Scalar_() 
# 2073
{ 
# 2074
((this->val)[0]) = (((this->val)[1]) = (((this->val)[2]) = (((this->val)[3]) = 0))); 
# 2075
} 
# 2077
template< class _Tp> inline 
# 2078
Scalar_< _Tp> ::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3) 
# 2079
{ 
# 2080
((this->val)[0]) = v0; 
# 2081
((this->val)[1]) = v1; 
# 2082
((this->val)[2]) = v2; 
# 2083
((this->val)[3]) = v3; 
# 2084
} 
# 2086
template< class _Tp> template< class _Tp2, int cn> inline 
# 2087
Scalar_< _Tp> ::Scalar_(const ::cv::Vec< _Tp2, cn>  &v) 
# 2088
{ 
# 2089
int i; 
# 2090
for (i = 0; i < ((cn < 4) ? cn : 4); i++) { 
# 2091
((this->val)[i]) = ::cv::saturate_cast< _Tp> ((v.val)[i]); }  
# 2092
for (; i < 4; i++) { 
# 2093
((this->val)[i]) = 0; }  
# 2094
} 
# 2096
template< class _Tp> inline 
# 2097
Scalar_< _Tp> ::Scalar_(_Tp v0) 
# 2098
{ 
# 2099
((this->val)[0]) = v0; 
# 2100
((this->val)[1]) = (((this->val)[2]) = (((this->val)[3]) = 0)); 
# 2101
} 
# 2103
template< class _Tp> inline Scalar_< _Tp>  
# 2104
Scalar_< _Tp> ::all(_Tp v0) 
# 2105
{ 
# 2106
return Scalar_(v0, v0, v0, v0); 
# 2107
} 
# 2110
template< class _Tp> inline Scalar_< _Tp>  
# 2111
Scalar_< _Tp> ::mul(const Scalar_ &a, double scale) const 
# 2112
{ 
# 2113
return Scalar_(saturate_cast< _Tp> ((((this->val)[0]) * ((a.val)[0])) * scale), saturate_cast< _Tp> ((((this->val)[1]) * ((a.val)[1])) * scale), saturate_cast< _Tp> ((((this->val)[2]) * ((a.val)[2])) * scale), saturate_cast< _Tp> ((((this->val)[3]) * ((a.val)[3])) * scale)); 
# 2117
} 
# 2119
template< class _Tp> inline Scalar_< _Tp>  
# 2120
Scalar_< _Tp> ::conj() const 
# 2121
{ 
# 2122
return Scalar_(saturate_cast< _Tp> ((this->val)[0]), saturate_cast< _Tp> (-((this->val)[1])), saturate_cast< _Tp> (-((this->val)[2])), saturate_cast< _Tp> (-((this->val)[3]))); 
# 2126
} 
# 2128
template< class _Tp> inline bool 
# 2129
Scalar_< _Tp> ::isReal() const 
# 2130
{ 
# 2131
return (((this->val)[1]) == 0) && (((this->val)[2]) == 0) && (((this->val)[3]) == 0); 
# 2132
} 
# 2135
template< class _Tp> template< class T2> inline 
# 2136
Scalar_< _Tp> ::operator Scalar_< T2> () const 
# 2137
{ 
# 2138
return ::cv::Scalar_< T2> (saturate_cast< T2> ((this->val)[0]), saturate_cast< T2> ((this->val)[1]), saturate_cast< T2> ((this->val)[2]), saturate_cast< T2> ((this->val)[3])); 
# 2142
} 
# 2145
template< class _Tp> static inline Scalar_< _Tp>  &
# 2146
operator+=(Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2147
{ 
# 2148
((a.val)[0]) += ((b.val)[0]); 
# 2149
((a.val)[1]) += ((b.val)[1]); 
# 2150
((a.val)[2]) += ((b.val)[2]); 
# 2151
((a.val)[3]) += ((b.val)[3]); 
# 2152
return a; 
# 2153
} 
# 2155
template< class _Tp> static inline Scalar_< _Tp>  &
# 2156
operator-=(Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2157
{ 
# 2158
((a.val)[0]) -= ((b.val)[0]); 
# 2159
((a.val)[1]) -= ((b.val)[1]); 
# 2160
((a.val)[2]) -= ((b.val)[2]); 
# 2161
((a.val)[3]) -= ((b.val)[3]); 
# 2162
return a; 
# 2163
} 
# 2165
template< class _Tp> static inline Scalar_< _Tp>  &
# 2166
operator*=(Scalar_< _Tp>  &a, _Tp v) 
# 2167
{ 
# 2168
((a.val)[0]) *= v; 
# 2169
((a.val)[1]) *= v; 
# 2170
((a.val)[2]) *= v; 
# 2171
((a.val)[3]) *= v; 
# 2172
return a; 
# 2173
} 
# 2175
template< class _Tp> static inline bool 
# 2176
operator==(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2177
{ 
# 2178
return (((a.val)[0]) == ((b.val)[0])) && (((a.val)[1]) == ((b.val)[1])) && (((a.val)[2]) == ((b.val)[2])) && (((a.val)[3]) == ((b.val)[3])); 
# 2180
} 
# 2182
template< class _Tp> static inline bool 
# 2183
operator!=(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2184
{ 
# 2185
return (((((a.val)[0]) != ((b.val)[0])) || (((a.val)[1]) != ((b.val)[1]))) || (((a.val)[2]) != ((b.val)[2]))) || (((a.val)[3]) != ((b.val)[3])); 
# 2187
} 
# 2189
template< class _Tp> static inline Scalar_< _Tp>  
# 2190
operator+(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2191
{ 
# 2192
return Scalar_< _Tp> (((a.val)[0]) + ((b.val)[0]), ((a.val)[1]) + ((b.val)[1]), ((a.val)[2]) + ((b.val)[2]), ((a.val)[3]) + ((b.val)[3])); 
# 2196
} 
# 2198
template< class _Tp> static inline Scalar_< _Tp>  
# 2199
operator-(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2200
{ 
# 2201
return Scalar_< _Tp> (saturate_cast< _Tp> (((a.val)[0]) - ((b.val)[0])), saturate_cast< _Tp> (((a.val)[1]) - ((b.val)[1])), saturate_cast< _Tp> (((a.val)[2]) - ((b.val)[2])), saturate_cast< _Tp> (((a.val)[3]) - ((b.val)[3]))); 
# 2205
} 
# 2207
template< class _Tp> static inline Scalar_< _Tp>  
# 2208
operator*(const Scalar_< _Tp>  &a, _Tp alpha) 
# 2209
{ 
# 2210
return Scalar_< _Tp> (((a.val)[0]) * alpha, ((a.val)[1]) * alpha, ((a.val)[2]) * alpha, ((a.val)[3]) * alpha); 
# 2214
} 
# 2216
template< class _Tp> static inline Scalar_< _Tp>  
# 2217
operator*(_Tp alpha, const Scalar_< _Tp>  &a) 
# 2218
{ 
# 2219
return a * alpha; 
# 2220
} 
# 2222
template< class _Tp> static inline Scalar_< _Tp>  
# 2223
operator-(const Scalar_< _Tp>  &a) 
# 2224
{ 
# 2225
return Scalar_< _Tp> (saturate_cast< _Tp> (-((a.val)[0])), saturate_cast< _Tp> (-((a.val)[1])), saturate_cast< _Tp> (-((a.val)[2])), saturate_cast< _Tp> (-((a.val)[3]))); 
# 2229
} 
# 2232
template< class _Tp> static inline Scalar_< _Tp>  
# 2233
operator*(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2234
{ 
# 2235
return Scalar_< _Tp> (saturate_cast< _Tp> (((((a[0]) * (b[0])) - ((a[1]) * (b[1]))) - ((a[2]) * (b[2]))) - ((a[3]) * (b[3]))), saturate_cast< _Tp> (((((a[0]) * (b[1])) + ((a[1]) * (b[0]))) + ((a[2]) * (b[3]))) - ((a[3]) * (b[2]))), saturate_cast< _Tp> (((((a[0]) * (b[2])) - ((a[1]) * (b[3]))) + ((a[2]) * (b[0]))) + ((a[3]) * (b[1]))), saturate_cast< _Tp> (((((a[0]) * (b[3])) + ((a[1]) * (b[2]))) - ((a[2]) * (b[1]))) + ((a[3]) * (b[0])))); 
# 2239
} 
# 2241
template< class _Tp> static inline Scalar_< _Tp>  &
# 2242
operator*=(Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2243
{ 
# 2244
a = (a * b); 
# 2245
return a; 
# 2246
} 
# 2248
template< class _Tp> static inline Scalar_< _Tp>  
# 2249
operator/(const Scalar_< _Tp>  &a, _Tp alpha) 
# 2250
{ 
# 2251
return Scalar_< _Tp> (((a.val)[0]) / alpha, ((a.val)[1]) / alpha, ((a.val)[2]) / alpha, ((a.val)[3]) / alpha); 
# 2255
} 
# 2257
template< class _Tp> static inline Scalar_< float>  
# 2258
operator/(const Scalar_< float>  &a, float alpha) 
# 2259
{ 
# 2260
float s = (1) / alpha; 
# 2261
return Scalar_< float> (((a.val)[0]) * s, ((a.val)[1]) * s, ((a.val)[2]) * s, ((a.val)[3]) * s); 
# 2262
} 
# 2264
template< class _Tp> static inline Scalar_< double>  
# 2265
operator/(const Scalar_< double>  &a, double alpha) 
# 2266
{ 
# 2267
double s = (1) / alpha; 
# 2268
return Scalar_< double> (((a.val)[0]) * s, ((a.val)[1]) * s, ((a.val)[2]) * s, ((a.val)[3]) * s); 
# 2269
} 
# 2271
template< class _Tp> static inline Scalar_< _Tp>  &
# 2272
operator/=(Scalar_< _Tp>  &a, _Tp alpha) 
# 2273
{ 
# 2274
a = (a / alpha); 
# 2275
return a; 
# 2276
} 
# 2278
template< class _Tp> static inline Scalar_< _Tp>  
# 2279
operator/(_Tp a, const Scalar_< _Tp>  &b) 
# 2280
{ 
# 2281
_Tp s = a / (((((b[0]) * (b[0])) + ((b[1]) * (b[1]))) + ((b[2]) * (b[2]))) + ((b[3]) * (b[3]))); 
# 2282
return (b.conj()) * s; 
# 2283
} 
# 2285
template< class _Tp> static inline Scalar_< _Tp>  
# 2286
operator/(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2287
{ 
# 2288
return a * (((_Tp)1) / b); 
# 2289
} 
# 2291
template< class _Tp> static inline Scalar_< _Tp>  &
# 2292
operator/=(Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2293
{ 
# 2294
a = (a / b); 
# 2295
return a; 
# 2296
} 
# 2298
template< class _Tp> static inline Scalar 
# 2299
operator*(const Matx< _Tp, 4, 4>  &a, const Scalar &b) 
# 2300
{ 
# 2301
Matx< double, 4, 1>  c(((Matx< double, 4, 4> )(a)), b, Matx_MatMulOp()); 
# 2302
return reinterpret_cast< const Scalar &>(c); 
# 2303
} 
# 2306
template<> inline Scalar operator*(const Matx< double, 4, 4>  &a, const Scalar &b) 
# 2307
{ 
# 2308
Matx< double, 4, 1>  c(a, b, Matx_MatMulOp()); 
# 2309
return reinterpret_cast< const Scalar &>(c); 
# 2310
} 
# 2317
inline KeyPoint::KeyPoint() : pt(0, 0), size((0)), angle((-1)), response((0)), octave(0), class_id((-1)) 
# 2318
{ } 
# 2321
inline KeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id) : pt(_pt), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) 
# 2322
{ } 
# 2325
inline KeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id) : pt(x, y), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) 
# 2326
{ } 
# 2333
inline DMatch::DMatch() : queryIdx((-1)), trainIdx((-1)), imgIdx((-1)), distance((3.402823466e+38F)) 
# 2334
{ } 
# 2337
inline DMatch::DMatch(int _queryIdx, int _trainIdx, float _distance) : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx((-1)), distance(_distance) 
# 2338
{ } 
# 2341
inline DMatch::DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance) : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(_imgIdx), distance(_distance) 
# 2342
{ } 
# 2345
inline bool DMatch::operator<(const DMatch &m) const 
# 2346
{ 
# 2347
return (distance) < (m.distance); 
# 2348
} 
# 2355
inline TermCriteria::TermCriteria() : type(0), maxCount(0), epsilon((0)) 
# 2356
{ } 
# 2359
inline TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon) : type(_type), maxCount(_maxCount), epsilon(_epsilon) 
# 2360
{ } 
# 2364
}
# 15 "/usr/include/opencv2/core/bufferpool.hpp" 3
namespace cv { 
# 21
class BufferPoolController { 
# 24
protected: ~BufferPoolController() { } 
# 26
public: virtual size_t getReservedSize() const = 0; 
# 27
virtual size_t getMaxReservedSize() const = 0; 
# 28
virtual void setMaxReservedSize(size_t size) = 0; 
# 29
virtual void freeAllReservedBuffers() = 0; 
# 30
}; 
# 34
}
# 60 "/usr/include/opencv2/core/mat.hpp" 3
namespace cv { 
# 66
enum { ACCESS_READ = 16777216, ACCESS_WRITE = 33554432, 
# 67
ACCESS_RW = 50331648, ACCESS_MASK = 50331648, ACCESS_FAST = 67108864}; 
# 71
class __attribute((visibility("default"))) _OutputArray; 
# 152 "/usr/include/opencv2/core/mat.hpp" 3
class __attribute((visibility("default"))) _InputArray { 
# 155
public: enum { 
# 156
KIND_SHIFT = 16, 
# 157
FIXED_TYPE = (-2147483647-1), 
# 158
FIXED_SIZE = 1073741824, 
# 159
KIND_MASK = 2031616, 
# 161
NONE = 0, 
# 162
MAT = 65536, 
# 163
MATX = 131072, 
# 164
STD_VECTOR = 196608, 
# 165
STD_VECTOR_VECTOR = 262144, 
# 166
STD_VECTOR_MAT = 327680, 
# 167
EXPR = 393216, 
# 168
OPENGL_BUFFER = 458752, 
# 169
CUDA_HOST_MEM = 524288, 
# 170
CUDA_GPU_MAT = 589824, 
# 171
UMAT = 655360, 
# 172
STD_VECTOR_UMAT = 720896, 
# 173
STD_BOOL_VECTOR = 786432, 
# 174
STD_VECTOR_CUDA_GPU_MAT = 851968, 
# 175
STD_ARRAY = 917504, 
# 176
STD_ARRAY_MAT = 983040
# 177
}; 
# 179
inline _InputArray(); 
# 180
inline _InputArray(int _flags, void * _obj); 
# 181
inline _InputArray(const Mat & m); 
# 182
inline _InputArray(const MatExpr & expr); 
# 183
inline _InputArray(const std::vector< Mat>  & vec); 
# 184
template< class _Tp> inline _InputArray(const Mat_< _Tp>  & m); 
# 185
template< class _Tp> inline _InputArray(const std::vector< _Tp>  & vec); 
# 186
inline _InputArray(const std::vector< bool>  & vec); 
# 187
template< class _Tp> inline _InputArray(const std::vector< std::vector< _Tp> >  & vec); 
# 188
inline _InputArray(const std::vector< std::vector< bool> >  &); 
# 189
template< class _Tp> inline _InputArray(const std::vector< Mat_< _Tp> >  & vec); 
# 190
template< class _Tp> inline _InputArray(const _Tp * vec, int n); 
# 191
template< class _Tp, int m, int n> inline _InputArray(const Matx< _Tp, m, n>  & matx); 
# 192
inline _InputArray(const double & val); 
# 193
inline _InputArray(const cuda::GpuMat & d_mat); 
# 194
inline _InputArray(const std::vector< cuda::GpuMat>  & d_mat_array); 
# 195
inline _InputArray(const ogl::Buffer & buf); 
# 196
inline _InputArray(const cuda::HostMem & cuda_mem); 
# 197
template< class _Tp> _InputArray(const cudev::GpuMat_< _Tp>  & m); 
# 198
inline _InputArray(const UMat & um); 
# 199
inline _InputArray(const std::vector< UMat>  & umv); 
# 202
template< class _Tp, std::size_t _Nm> inline _InputArray(const std::array< _Tp, _Nm>  & arr); 
# 203
template< std::size_t _Nm> inline _InputArray(const std::array< Mat, _Nm>  & arr); 
# 206
inline Mat getMat(int idx = -1) const; 
# 207
Mat getMat_(int idx = -1) const; 
# 208
UMat getUMat(int idx = -1) const; 
# 209
void getMatVector(std::vector< Mat>  & mv) const; 
# 210
void getUMatVector(std::vector< UMat>  & umv) const; 
# 211
void getGpuMatVector(std::vector< cuda::GpuMat>  & gpumv) const; 
# 212
cuda::GpuMat getGpuMat() const; 
# 213
ogl::Buffer getOGlBuffer() const; 
# 215
inline int getFlags() const; 
# 216
inline void *getObj() const; 
# 217
inline Size getSz() const; 
# 219
int kind() const; 
# 220
int dims(int i = -1) const; 
# 221
int cols(int i = -1) const; 
# 222
int rows(int i = -1) const; 
# 223
Size size(int i = -1) const; 
# 224
int sizend(int * sz, int i = -1) const; 
# 225
bool sameSize(const _InputArray & arr) const; 
# 226
size_t total(int i = -1) const; 
# 227
int type(int i = -1) const; 
# 228
int depth(int i = -1) const; 
# 229
int channels(int i = -1) const; 
# 230
bool isContinuous(int i = -1) const; 
# 231
bool isSubmatrix(int i = -1) const; 
# 232
bool empty() const; 
# 233
void copyTo(const _OutputArray & arr) const; 
# 234
void copyTo(const _OutputArray & arr, const _InputArray & mask) const; 
# 235
size_t offset(int i = -1) const; 
# 236
size_t step(int i = -1) const; 
# 237
inline bool isMat() const; 
# 238
inline bool isUMat() const; 
# 239
inline bool isMatVector() const; 
# 240
inline bool isUMatVector() const; 
# 241
inline bool isMatx() const; 
# 242
inline bool isVector() const; 
# 243
inline bool isGpuMatVector() const; 
# 244
inline ~_InputArray(); 
# 247
protected: int flags; 
# 248
void *obj; 
# 249
Size sz; 
# 251
inline void init(int _flags, const void * _obj); 
# 252
inline void init(int _flags, const void * _obj, Size _sz); 
# 253
}; 
# 281 "/usr/include/opencv2/core/mat.hpp" 3
class __attribute((visibility("default"))) _OutputArray : public _InputArray { 
# 285
public: enum { 
# 286
DEPTH_MASK_8U = 1, 
# 287
DEPTH_MASK_8S, 
# 288
DEPTH_MASK_16U = 4, 
# 289
DEPTH_MASK_16S = 8, 
# 290
DEPTH_MASK_32S = 16, 
# 291
DEPTH_MASK_32F = 32, 
# 292
DEPTH_MASK_64F = 64, 
# 293
DEPTH_MASK_ALL = 127, 
# 294
DEPTH_MASK_ALL_BUT_8S = 125, 
# 295
DEPTH_MASK_FLT = 96
# 296
}; 
# 298
inline _OutputArray(); 
# 299
inline _OutputArray(int _flags, void * _obj); 
# 300
inline _OutputArray(Mat & m); 
# 301
inline _OutputArray(std::vector< Mat>  & vec); 
# 302
inline _OutputArray(cuda::GpuMat & d_mat); 
# 303
inline _OutputArray(std::vector< cuda::GpuMat>  & d_mat); 
# 304
inline _OutputArray(ogl::Buffer & buf); 
# 305
inline _OutputArray(cuda::HostMem & cuda_mem); 
# 306
template< class _Tp> _OutputArray(cudev::GpuMat_< _Tp>  & m); 
# 307
template< class _Tp> inline _OutputArray(std::vector< _Tp>  & vec); 
# 308
inline _OutputArray(std::vector< bool>  & vec); 
# 309
template< class _Tp> inline _OutputArray(std::vector< std::vector< _Tp> >  & vec); 
# 310
inline _OutputArray(std::vector< std::vector< bool> >  &); 
# 311
template< class _Tp> inline _OutputArray(std::vector< Mat_< _Tp> >  & vec); 
# 312
template< class _Tp> inline _OutputArray(Mat_< _Tp>  & m); 
# 313
template< class _Tp> inline _OutputArray(_Tp * vec, int n); 
# 314
template< class _Tp, int m, int n> inline _OutputArray(Matx< _Tp, m, n>  & matx); 
# 315
inline _OutputArray(UMat & m); 
# 316
inline _OutputArray(std::vector< UMat>  & vec); 
# 318
inline _OutputArray(const Mat & m); 
# 319
inline _OutputArray(const std::vector< Mat>  & vec); 
# 320
inline _OutputArray(const cuda::GpuMat & d_mat); 
# 321
_OutputArray(const std::vector< cuda::GpuMat>  & d_mat); 
# 322
inline _OutputArray(const ogl::Buffer & buf); 
# 323
inline _OutputArray(const cuda::HostMem & cuda_mem); 
# 324
template< class _Tp> _OutputArray(const cudev::GpuMat_< _Tp>  & m); 
# 325
template< class _Tp> inline _OutputArray(const std::vector< _Tp>  & vec); 
# 326
template< class _Tp> inline _OutputArray(const std::vector< std::vector< _Tp> >  & vec); 
# 327
template< class _Tp> inline _OutputArray(const std::vector< Mat_< _Tp> >  & vec); 
# 328
template< class _Tp> inline _OutputArray(const Mat_< _Tp>  & m); 
# 329
template< class _Tp> inline _OutputArray(const _Tp * vec, int n); 
# 330
template< class _Tp, int m, int n> inline _OutputArray(const Matx< _Tp, m, n>  & matx); 
# 331
inline _OutputArray(const UMat & m); 
# 332
inline _OutputArray(const std::vector< UMat>  & vec); 
# 335
template< class _Tp, std::size_t _Nm> inline _OutputArray(std::array< _Tp, _Nm>  & arr); 
# 336
template< class _Tp, std::size_t _Nm> inline _OutputArray(const std::array< _Tp, _Nm>  & arr); 
# 337
template< std::size_t _Nm> inline _OutputArray(std::array< Mat, _Nm>  & arr); 
# 338
template< std::size_t _Nm> inline _OutputArray(const std::array< Mat, _Nm>  & arr); 
# 341
bool fixedSize() const; 
# 342
bool fixedType() const; 
# 343
bool needed() const; 
# 344
Mat &getMatRef(int i = -1) const; 
# 345
UMat &getUMatRef(int i = -1) const; 
# 346
cuda::GpuMat &getGpuMatRef() const; 
# 347
std::vector< cuda::GpuMat>  &getGpuMatVecRef() const; 
# 348
ogl::Buffer &getOGlBufferRef() const; 
# 349
cuda::HostMem &getHostMemRef() const; 
# 350
void create(Size sz, int type, int i = -1, bool allowTransposed = false, int fixedDepthMask = 0) const; 
# 351
void create(int rows, int cols, int type, int i = -1, bool allowTransposed = false, int fixedDepthMask = 0) const; 
# 352
void create(int dims, const int * size, int type, int i = -1, bool allowTransposed = false, int fixedDepthMask = 0) const; 
# 353
void createSameSize(const _InputArray & arr, int mtype) const; 
# 354
void release() const; 
# 355
void clear() const; 
# 356
void setTo(const _InputArray & value, const _InputArray & mask = _InputArray()) const; 
# 358
void assign(const UMat & u) const; 
# 359
void assign(const Mat & m) const; 
# 360
}; 
# 363
class __attribute((visibility("default"))) _InputOutputArray : public _OutputArray { 
# 366
public: inline _InputOutputArray(); 
# 367
inline _InputOutputArray(int _flags, void * _obj); 
# 368
inline _InputOutputArray(Mat & m); 
# 369
inline _InputOutputArray(std::vector< Mat>  & vec); 
# 370
inline _InputOutputArray(cuda::GpuMat & d_mat); 
# 371
inline _InputOutputArray(ogl::Buffer & buf); 
# 372
inline _InputOutputArray(cuda::HostMem & cuda_mem); 
# 373
template< class _Tp> _InputOutputArray(cudev::GpuMat_< _Tp>  & m); 
# 374
template< class _Tp> inline _InputOutputArray(std::vector< _Tp>  & vec); 
# 375
inline _InputOutputArray(std::vector< bool>  & vec); 
# 376
template< class _Tp> inline _InputOutputArray(std::vector< std::vector< _Tp> >  & vec); 
# 377
template< class _Tp> inline _InputOutputArray(std::vector< Mat_< _Tp> >  & vec); 
# 378
template< class _Tp> inline _InputOutputArray(Mat_< _Tp>  & m); 
# 379
template< class _Tp> inline _InputOutputArray(_Tp * vec, int n); 
# 380
template< class _Tp, int m, int n> inline _InputOutputArray(Matx< _Tp, m, n>  & matx); 
# 381
inline _InputOutputArray(UMat & m); 
# 382
inline _InputOutputArray(std::vector< UMat>  & vec); 
# 384
inline _InputOutputArray(const Mat & m); 
# 385
inline _InputOutputArray(const std::vector< Mat>  & vec); 
# 386
inline _InputOutputArray(const cuda::GpuMat & d_mat); 
# 387
inline _InputOutputArray(const std::vector< cuda::GpuMat>  & d_mat); 
# 388
inline _InputOutputArray(const ogl::Buffer & buf); 
# 389
inline _InputOutputArray(const cuda::HostMem & cuda_mem); 
# 390
template< class _Tp> _InputOutputArray(const cudev::GpuMat_< _Tp>  & m); 
# 391
template< class _Tp> inline _InputOutputArray(const std::vector< _Tp>  & vec); 
# 392
template< class _Tp> inline _InputOutputArray(const std::vector< std::vector< _Tp> >  & vec); 
# 393
template< class _Tp> inline _InputOutputArray(const std::vector< Mat_< _Tp> >  & vec); 
# 394
template< class _Tp> inline _InputOutputArray(const Mat_< _Tp>  & m); 
# 395
template< class _Tp> inline _InputOutputArray(const _Tp * vec, int n); 
# 396
template< class _Tp, int m, int n> inline _InputOutputArray(const Matx< _Tp, m, n>  & matx); 
# 397
inline _InputOutputArray(const UMat & m); 
# 398
inline _InputOutputArray(const std::vector< UMat>  & vec); 
# 401
template< class _Tp, std::size_t _Nm> inline _InputOutputArray(std::array< _Tp, _Nm>  & arr); 
# 402
template< class _Tp, std::size_t _Nm> inline _InputOutputArray(const std::array< _Tp, _Nm>  & arr); 
# 403
template< std::size_t _Nm> inline _InputOutputArray(std::array< Mat, _Nm>  & arr); 
# 404
template< std::size_t _Nm> inline _InputOutputArray(const std::array< Mat, _Nm>  & arr); 
# 407
}; 
# 411
typedef const _InputArray &InputArray; 
# 412
typedef InputArray InputArrayOfArrays; 
# 413
typedef const _OutputArray &OutputArray; 
# 414
typedef OutputArray OutputArrayOfArrays; 
# 415
typedef const _InputOutputArray &InputOutputArray; 
# 416
typedef InputOutputArray InputOutputArrayOfArrays; 
# 418
__attribute((visibility("default"))) InputOutputArray noArray(); 
# 423
enum UMatUsageFlags { 
# 425
USAGE_DEFAULT, 
# 428
USAGE_ALLOCATE_HOST_MEMORY, 
# 429
USAGE_ALLOCATE_DEVICE_MEMORY, 
# 430
USAGE_ALLOCATE_SHARED_MEMORY = 4, 
# 432
__UMAT_USAGE_FLAGS_32BIT = 2147483647
# 433
}; 
# 435
struct __attribute((visibility("default"))) UMatData; 
# 439
class __attribute((visibility("default"))) MatAllocator { 
# 442
public: MatAllocator() { } 
# 443
virtual ~MatAllocator() { } 
# 449
virtual UMatData *allocate(int dims, const int * sizes, int type, void * data, size_t * step, int flags, UMatUsageFlags usageFlags) const = 0; 
# 451
virtual bool allocate(UMatData * data, int accessflags, UMatUsageFlags usageFlags) const = 0; 
# 452
virtual void deallocate(UMatData * data) const = 0; 
# 453
virtual void map(UMatData * data, int accessflags) const; 
# 454
virtual void unmap(UMatData * data) const; 
# 455
virtual void download(UMatData * data, void * dst, int dims, const size_t  sz[], const size_t  srcofs[], const size_t  srcstep[], const size_t  dststep[]) const; 
# 458
virtual void upload(UMatData * data, const void * src, int dims, const size_t  sz[], const size_t  dstofs[], const size_t  dststep[], const size_t  srcstep[]) const; 
# 461
virtual void copy(UMatData * srcdata, UMatData * dstdata, int dims, const size_t  sz[], const size_t  srcofs[], const size_t  srcstep[], const size_t  dstofs[], const size_t  dststep[], bool sync) const; 
# 466
virtual BufferPoolController *getBufferPoolController(const char * id = 0) const; 
# 467
}; 
# 484 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> class MatCommaInitializer_ { 
# 488
public: inline MatCommaInitializer_(Mat_< _Tp>  * _m); 
# 490
template< class T2> inline MatCommaInitializer_ &operator,(T2 v); 
# 492
inline operator Mat_< _Tp> () const; 
# 494
protected: MatIterator_< _Tp>  it; 
# 495
}; 
# 504 "/usr/include/opencv2/core/mat.hpp" 3
struct __attribute((visibility("default"))) UMatData { 
# 506
enum { COPY_ON_MAP = 1, HOST_COPY_OBSOLETE, 
# 507
DEVICE_COPY_OBSOLETE = 4, TEMP_UMAT = 8, TEMP_COPIED_UMAT = 24, 
# 508
USER_ALLOCATED = 32, DEVICE_MEM_MAPPED = 64, 
# 509
ASYNC_CLEANUP = 128
# 510
}; 
# 511
UMatData(const MatAllocator * allocator); 
# 512
~UMatData(); 
# 515
void lock(); 
# 516
void unlock(); 
# 518
inline bool hostCopyObsolete() const; 
# 519
inline bool deviceCopyObsolete() const; 
# 520
inline bool deviceMemMapped() const; 
# 521
inline bool copyOnMap() const; 
# 522
inline bool tempUMat() const; 
# 523
inline bool tempCopiedUMat() const; 
# 524
inline void markHostCopyObsolete(bool flag); 
# 525
inline void markDeviceCopyObsolete(bool flag); 
# 526
inline void markDeviceMemMapped(bool flag); 
# 528
const MatAllocator *prevAllocator; 
# 529
const MatAllocator *currAllocator; 
# 530
int urefcount; 
# 531
int refcount; 
# 532
uchar *data; 
# 533
uchar *origdata; 
# 534
size_t size; 
# 536
int flags; 
# 537
void *handle; 
# 538
void *userdata; 
# 539
int allocatorFlags_; 
# 540
int mapcount; 
# 541
UMatData *originalUMatData; 
# 542
}; 
# 545
struct __attribute((visibility("default"))) UMatDataAutoLock { 
# 547
inline explicit UMatDataAutoLock(UMatData * u); 
# 548
inline ~UMatDataAutoLock(); 
# 549
UMatData *u; 
# 550
}; 
# 553
struct __attribute((visibility("default"))) MatSize { 
# 555
inline explicit MatSize(int * _p); 
# 556
inline Size operator()() const; 
# 557
inline const int &operator[](int i) const; 
# 558
inline int &operator[](int i); 
# 559
inline operator const int *() const; 
# 560
inline bool operator==(const MatSize & sz) const; 
# 561
inline bool operator!=(const MatSize & sz) const; 
# 563
int *p; 
# 564
}; 
# 566
struct __attribute((visibility("default"))) MatStep { 
# 568
inline MatStep(); 
# 569
inline explicit MatStep(size_t s); 
# 570
inline const size_t &operator[](int i) const; 
# 571
inline size_t &operator[](int i); 
# 572
inline operator size_t() const; 
# 573
inline MatStep &operator=(size_t s); 
# 575
size_t *p; 
# 576
size_t buf[2]; 
# 578
protected: MatStep &operator=(const MatStep &); 
# 579
}; 
# 776 "/usr/include/opencv2/core/mat.hpp" 3
class __attribute((visibility("default"))) Mat { 
# 785
public: inline Mat(); 
# 793
inline Mat(int rows, int cols, int type); 
# 801
inline Mat(Size size, int type); 
# 812 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat(int rows, int cols, int type, const Scalar & s); 
# 823 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat(Size size, int type, const Scalar & s); 
# 831
inline Mat(int ndims, const int * sizes, int type); 
# 838
inline Mat(const std::vector< int>  & sizes, int type); 
# 849 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat(int ndims, const int * sizes, int type, const Scalar & s); 
# 859 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat(const std::vector< int>  & sizes, int type, const Scalar & s); 
# 869 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat(const Mat & m); 
# 885 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat(int rows, int cols, int type, void * data, size_t step = AUTO_STEP); 
# 901 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat(Size size, int type, void * data, size_t step = AUTO_STEP); 
# 916 "/usr/include/opencv2/core/mat.hpp" 3
Mat(int ndims, const int * sizes, int type, void * data, const size_t * steps = 0); 
# 930 "/usr/include/opencv2/core/mat.hpp" 3
Mat(const std::vector< int>  & sizes, int type, void * data, const size_t * steps = 0); 
# 942 "/usr/include/opencv2/core/mat.hpp" 3
Mat(const Mat & m, const Range & rowRange, const Range & colRange = Range::all()); 
# 952 "/usr/include/opencv2/core/mat.hpp" 3
Mat(const Mat & m, const Rect & roi); 
# 962 "/usr/include/opencv2/core/mat.hpp" 3
Mat(const Mat & m, const Range * ranges); 
# 972 "/usr/include/opencv2/core/mat.hpp" 3
Mat(const Mat & m, const std::vector< Range>  & ranges); 
# 990 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> inline explicit Mat(const std::vector< _Tp>  & vec, bool copyData = false); 
# 995
template< class _Tp, class  = typename std::enable_if< std::is_arithmetic< _Tp> ::value> ::type> inline explicit Mat(const std::initializer_list< _Tp>  list); 
# 1002
template< class _Tp, size_t _Nm> inline explicit Mat(const std::array< _Tp, _Nm>  & arr, bool copyData = false); 
# 1007
template< class _Tp, int n> inline explicit Mat(const Vec< _Tp, n>  & vec, bool copyData = true); 
# 1011
template< class _Tp, int m, int n> inline explicit Mat(const Matx< _Tp, m, n>  & mtx, bool copyData = true); 
# 1015
template< class _Tp> inline explicit Mat(const Point_< _Tp>  & pt, bool copyData = true); 
# 1019
template< class _Tp> inline explicit Mat(const Point3_< _Tp>  & pt, bool copyData = true); 
# 1023
template< class _Tp> inline explicit Mat(const MatCommaInitializer_< _Tp>  & commaInitializer); 
# 1026
inline explicit Mat(const cuda::GpuMat & m); 
# 1029
inline ~Mat(); 
# 1039 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat &operator=(const Mat & m); 
# 1048 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat &operator=(const MatExpr & expr); 
# 1051
UMat getUMat(int accessFlags, UMatUsageFlags usageFlags = USAGE_DEFAULT) const; 
# 1086 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat row(int y) const; 
# 1095 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat col(int x) const; 
# 1104 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat rowRange(int startrow, int endrow) const; 
# 1109
inline Mat rowRange(const Range & r) const; 
# 1118 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat colRange(int startcol, int endcol) const; 
# 1123
inline Mat colRange(const Range & r) const; 
# 1159 "/usr/include/opencv2/core/mat.hpp" 3
Mat diag(int d = 0) const; 
# 1166
static Mat diag(const Mat & d); 
# 1173
inline Mat clone() const; 
# 1190 "/usr/include/opencv2/core/mat.hpp" 3
void copyTo(OutputArray m) const; 
# 1198
void copyTo(OutputArray m, InputArray mask) const; 
# 1213 "/usr/include/opencv2/core/mat.hpp" 3
void convertTo(OutputArray m, int rtype, double alpha = 1, double beta = 0) const; 
# 1221
inline void assignTo(Mat & m, int type = -1) const; 
# 1226
Mat &operator=(const Scalar & s); 
# 1235 "/usr/include/opencv2/core/mat.hpp" 3
Mat &setTo(InputArray value, InputArray mask = noArray()); 
# 1261 "/usr/include/opencv2/core/mat.hpp" 3
Mat reshape(int cn, int rows = 0) const; 
# 1264
Mat reshape(int cn, int newndims, const int * newsz) const; 
# 1267
Mat reshape(int cn, const std::vector< int>  & newshape) const; 
# 1279 "/usr/include/opencv2/core/mat.hpp" 3
MatExpr t() const; 
# 1288 "/usr/include/opencv2/core/mat.hpp" 3
MatExpr inv(int method = DECOMP_LU) const; 
# 1302 "/usr/include/opencv2/core/mat.hpp" 3
MatExpr mul(InputArray m, double scale = 1) const; 
# 1311 "/usr/include/opencv2/core/mat.hpp" 3
Mat cross(InputArray m) const; 
# 1321 "/usr/include/opencv2/core/mat.hpp" 3
double dot(InputArray m) const; 
# 1337 "/usr/include/opencv2/core/mat.hpp" 3
static MatExpr zeros(int rows, int cols, int type); 
# 1343
static MatExpr zeros(Size size, int type); 
# 1350
static MatExpr zeros(int ndims, const int * sz, int type); 
# 1366 "/usr/include/opencv2/core/mat.hpp" 3
static MatExpr ones(int rows, int cols, int type); 
# 1372
static MatExpr ones(Size size, int type); 
# 1379
static MatExpr ones(int ndims, const int * sz, int type); 
# 1393 "/usr/include/opencv2/core/mat.hpp" 3
static MatExpr eye(int rows, int cols, int type); 
# 1399
static MatExpr eye(Size size, int type); 
# 1434 "/usr/include/opencv2/core/mat.hpp" 3
inline void create(int rows, int cols, int type); 
# 1440
inline void create(Size size, int type); 
# 1447
void create(int ndims, const int * sizes, int type); 
# 1453
void create(const std::vector< int>  & sizes, int type); 
# 1464 "/usr/include/opencv2/core/mat.hpp" 3
inline void addref(); 
# 1479 "/usr/include/opencv2/core/mat.hpp" 3
inline void release(); 
# 1482
void deallocate(); 
# 1484
void copySize(const Mat & m); 
# 1493 "/usr/include/opencv2/core/mat.hpp" 3
void reserve(size_t sz); 
# 1501
void reserveBuffer(size_t sz); 
# 1510 "/usr/include/opencv2/core/mat.hpp" 3
void resize(size_t sz); 
# 1516
void resize(size_t sz, const Scalar & s); 
# 1519
void push_back_(const void * elem); 
# 1528 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> inline void push_back(const _Tp & elem); 
# 1533
template< class _Tp> inline void push_back(const Mat_< _Tp>  & elem); 
# 1538
template< class _Tp> inline void push_back(const std::vector< _Tp>  & elem); 
# 1543
void push_back(const Mat & m); 
# 1551
void pop_back(size_t nelems = 1); 
# 1564 "/usr/include/opencv2/core/mat.hpp" 3
void locateROI(Size & wholeSize, Point & ofs) const; 
# 1593 "/usr/include/opencv2/core/mat.hpp" 3
Mat &adjustROI(int dtop, int dbottom, int dleft, int dright); 
# 1606 "/usr/include/opencv2/core/mat.hpp" 3
inline Mat operator()(Range rowRange, Range colRange) const; 
# 1611
inline Mat operator()(const Rect & roi) const; 
# 1616
inline Mat operator()(const Range * ranges) const; 
# 1621
inline Mat operator()(const std::vector< Range>  & ranges) const; 
# 1630 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> inline operator std::vector< _Tp> () const; 
# 1631
template< class _Tp, int n> inline operator Vec< _Tp, n> () const; 
# 1632
template< class _Tp, int m, int n> inline operator Matx< _Tp, m, n> () const; 
# 1635
template< class _Tp, std::size_t _Nm> inline operator std::array< _Tp, _Nm> () const; 
# 1712 "/usr/include/opencv2/core/mat.hpp" 3
inline bool isContinuous() const; 
# 1715
inline bool isSubmatrix() const; 
# 1722
inline size_t elemSize() const; 
# 1729
inline size_t elemSize1() const; 
# 1736
inline int type() const; 
# 1751 "/usr/include/opencv2/core/mat.hpp" 3
inline int depth() const; 
# 1757
inline int channels() const; 
# 1764
inline size_t step1(int i = 0) const; 
# 1771
inline bool empty() const; 
# 1778
inline size_t total() const; 
# 1784
inline size_t total(int startDim, int endDim = 2147483647) const; 
# 1787
int checkVector(int elemChannels, int depth = -1, bool requireContinuous = true) const; 
# 1795
inline uchar *ptr(int i0 = 0); 
# 1797
inline const uchar *ptr(int i0 = 0) const; 
# 1803
inline uchar *ptr(int row, int col); 
# 1808
inline const uchar *ptr(int row, int col) const; 
# 1811
inline uchar *ptr(int i0, int i1, int i2); 
# 1813
inline const uchar *ptr(int i0, int i1, int i2) const; 
# 1816
inline uchar *ptr(const int * idx); 
# 1818
inline const uchar *ptr(const int * idx) const; 
# 1820
template< int n> uchar *ptr(const Vec< int, n>  & idx); 
# 1822
template< int n> const uchar *ptr(const Vec< int, n>  & idx) const; 
# 1825
template< class _Tp> inline _Tp *ptr(int i0 = 0); 
# 1827
template< class _Tp> inline const _Tp *ptr(int i0 = 0) const; 
# 1832
template< class _Tp> inline _Tp *ptr(int row, int col); 
# 1837
template< class _Tp> inline const _Tp *ptr(int row, int col) const; 
# 1839
template< class _Tp> inline _Tp *ptr(int i0, int i1, int i2); 
# 1841
template< class _Tp> inline const _Tp *ptr(int i0, int i1, int i2) const; 
# 1843
template< class _Tp> inline _Tp *ptr(const int * idx); 
# 1845
template< class _Tp> inline const _Tp *ptr(const int * idx) const; 
# 1847
template< class _Tp, int n> _Tp *ptr(const Vec< int, n>  & idx); 
# 1849
template< class _Tp, int n> const _Tp *ptr(const Vec< int, n>  & idx) const; 
# 1881 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> inline _Tp &at(int i0 = 0); 
# 1885
template< class _Tp> inline const _Tp &at(int i0 = 0) const; 
# 1890
template< class _Tp> inline _Tp &at(int row, int col); 
# 1895
template< class _Tp> inline const _Tp &at(int row, int col) const; 
# 1902
template< class _Tp> inline _Tp &at(int i0, int i1, int i2); 
# 1908
template< class _Tp> inline const _Tp &at(int i0, int i1, int i2) const; 
# 1913
template< class _Tp> inline _Tp &at(const int * idx); 
# 1917
template< class _Tp> inline const _Tp &at(const int * idx) const; 
# 1920
template< class _Tp, int n> inline _Tp &at(const Vec< int, n>  & idx); 
# 1922
template< class _Tp, int n> inline const _Tp &at(const Vec< int, n>  & idx) const; 
# 1928
template< class _Tp> inline _Tp &at(Point pt); 
# 1933
template< class _Tp> inline const _Tp &at(Point pt) const; 
# 1971 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> inline MatIterator_< _Tp>  begin(); 
# 1972
template< class _Tp> inline MatConstIterator_< _Tp>  begin() const; 
# 1979
template< class _Tp> inline MatIterator_< _Tp>  end(); 
# 1980
template< class _Tp> inline MatConstIterator_< _Tp>  end() const; 
# 2036 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp, class Functor> inline void forEach(const Functor & operation); 
# 2038
template< class _Tp, class Functor> inline void forEach(const Functor & operation) const; 
# 2041
inline Mat(Mat && m); 
# 2042
inline Mat &operator=(Mat && m); 
# 2045
enum { MAGIC_VAL = 1124007936, AUTO_STEP = 0, CONTINUOUS_FLAG = 16384, SUBMATRIX_FLAG = 32768}; 
# 2046
enum { MAGIC_MASK = 4294901760U, TYPE_MASK = 4095U, DEPTH_MASK = 7U}; 
# 2054
int flags; 
# 2056
int dims; 
# 2058
int rows, cols; 
# 2060
uchar *data; 
# 2063
const uchar *datastart; 
# 2064
const uchar *dataend; 
# 2065
const uchar *datalimit; 
# 2068
MatAllocator *allocator; 
# 2070
static MatAllocator *getStdAllocator(); 
# 2071
static MatAllocator *getDefaultAllocator(); 
# 2072
static void setDefaultAllocator(MatAllocator * allocator); 
# 2075
UMatData *u; 
# 2077
MatSize size; 
# 2078
MatStep step; 
# 2081
protected: template< class _Tp, class Functor> inline void forEach_impl(const Functor & operation); 
# 2082
}; 
# 2146 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> class Mat_ : public Mat { 
# 2149
public: typedef _Tp value_type; 
# 2150
typedef typename DataType< _Tp> ::channel_type channel_type; 
# 2151
typedef MatIterator_< _Tp>  iterator; 
# 2152
typedef MatConstIterator_< _Tp>  const_iterator; 
# 2155
inline Mat_(); 
# 2157
inline Mat_(int _rows, int _cols); 
# 2159
inline Mat_(int _rows, int _cols, const _Tp & value); 
# 2161
inline explicit Mat_(Size _size); 
# 2163
inline Mat_(Size _size, const _Tp & value); 
# 2165
inline Mat_(int _ndims, const int * _sizes); 
# 2167
inline Mat_(int _ndims, const int * _sizes, const _Tp & value); 
# 2169
inline Mat_(const Mat & m); 
# 2171
inline Mat_(const Mat_ & m); 
# 2173
inline Mat_(int _rows, int _cols, _Tp * _data, size_t _step = AUTO_STEP); 
# 2175
inline Mat_(int _ndims, const int * _sizes, _Tp * _data, const size_t * _steps = 0); 
# 2177
inline Mat_(const Mat_ & m, const Range & rowRange, const Range & colRange = Range::all()); 
# 2179
inline Mat_(const Mat_ & m, const Rect & roi); 
# 2181
inline Mat_(const Mat_ & m, const Range * ranges); 
# 2183
inline Mat_(const Mat_ & m, const std::vector< Range>  & ranges); 
# 2185
inline explicit Mat_(const MatExpr & e); 
# 2187
inline explicit Mat_(const std::vector< _Tp>  & vec, bool copyData = false); 
# 2188
template< int n> inline explicit Mat_(const Vec< typename DataType< _Tp> ::channel_type, n>  & vec, bool copyData = true); 
# 2189
template< int m, int n> inline explicit Mat_(const Matx< typename DataType< _Tp> ::channel_type, m, n>  & mtx, bool copyData = true); 
# 2190
inline explicit Mat_(const Point_< typename DataType< _Tp> ::channel_type>  & pt, bool copyData = true); 
# 2191
inline explicit Mat_(const Point3_< typename DataType< _Tp> ::channel_type>  & pt, bool copyData = true); 
# 2192
inline explicit Mat_(const MatCommaInitializer_< _Tp>  & commaInitializer); 
# 2195
inline Mat_(std::initializer_list< _Tp>  values); 
# 2199
template< std::size_t _Nm> inline explicit Mat_(const std::array< _Tp, _Nm>  & arr, bool copyData = false); 
# 2202
inline Mat_ &operator=(const Mat & m); 
# 2203
inline Mat_ &operator=(const Mat_ & m); 
# 2205
inline Mat_ &operator=(const _Tp & s); 
# 2207
inline Mat_ &operator=(const MatExpr & e); 
# 2210
inline iterator begin(); 
# 2211
inline iterator end(); 
# 2212
inline const_iterator begin() const; 
# 2213
inline const_iterator end() const; 
# 2217
template< class Functor> inline void forEach(const Functor & operation); 
# 2218
template< class Functor> inline void forEach(const Functor & operation) const; 
# 2221
inline void create(int _rows, int _cols); 
# 2223
inline void create(Size _size); 
# 2225
inline void create(int _ndims, const int * _sizes); 
# 2227
inline void release(); 
# 2229
inline Mat_ cross(const Mat_ & m) const; 
# 2231
template< class T2> inline operator cv::Mat_< T2> () const; 
# 2233
inline Mat_ row(int y) const; 
# 2234
inline Mat_ col(int x) const; 
# 2235
inline Mat_ diag(int d = 0) const; 
# 2236
inline Mat_ clone() const; 
# 2239
inline size_t elemSize() const; 
# 2240
inline size_t elemSize1() const; 
# 2241
inline int type() const; 
# 2242
inline int depth() const; 
# 2243
inline int channels() const; 
# 2244
inline size_t step1(int i = 0) const; 
# 2246
inline size_t stepT(int i = 0) const; 
# 2249
static inline MatExpr zeros(int rows, int cols); 
# 2250
static inline MatExpr zeros(Size size); 
# 2251
static MatExpr zeros(int _ndims, const int * _sizes); 
# 2252
static inline MatExpr ones(int rows, int cols); 
# 2253
static inline MatExpr ones(Size size); 
# 2254
static MatExpr ones(int _ndims, const int * _sizes); 
# 2255
static inline MatExpr eye(int rows, int cols); 
# 2256
static inline MatExpr eye(Size size); 
# 2259
inline Mat_ &adjustROI(int dtop, int dbottom, int dleft, int dright); 
# 2260
inline Mat_ operator()(const Range & rowRange, const Range & colRange) const; 
# 2261
inline Mat_ operator()(const Rect & roi) const; 
# 2262
inline Mat_ operator()(const Range * ranges) const; 
# 2263
inline Mat_ operator()(const std::vector< Range>  & ranges) const; 
# 2266
inline _Tp *operator[](int y); 
# 2267
inline const _Tp *operator[](int y) const; 
# 2270
inline _Tp &operator()(const int * idx); 
# 2272
inline const _Tp &operator()(const int * idx) const; 
# 2275
template< int n> inline _Tp &operator()(const Vec< int, n>  & idx); 
# 2277
template< int n> inline const _Tp &operator()(const Vec< int, n>  & idx) const; 
# 2280
inline _Tp &operator()(int idx0); 
# 2282
inline const _Tp &operator()(int idx0) const; 
# 2284
inline _Tp &operator()(int row, int col); 
# 2286
inline const _Tp &operator()(int row, int col) const; 
# 2288
inline _Tp &operator()(int idx0, int idx1, int idx2); 
# 2290
inline const _Tp &operator()(int idx0, int idx1, int idx2) const; 
# 2292
inline _Tp &operator()(Point pt); 
# 2293
inline const _Tp &operator()(Point pt) const; 
# 2296
inline operator std::vector< _Tp> () const; 
# 2300
template< std::size_t _Nm> inline operator std::array< _Tp, _Nm> () const; 
# 2304
template< int n> inline operator Vec< typename DataType< _Tp> ::channel_type, n> () const; 
# 2306
template< int m, int n> inline operator Matx< typename DataType< _Tp> ::channel_type, m, n> () const; 
# 2309
inline Mat_(Mat_ && m); 
# 2310
inline Mat_ &operator=(Mat_ && m); 
# 2312
inline Mat_(Mat && m); 
# 2313
inline Mat_ &operator=(Mat && m); 
# 2315
inline Mat_(MatExpr && e); 
# 2317
}; 
# 2319
typedef Mat_< unsigned char>  Mat1b; 
# 2320
typedef Mat_< Vec< unsigned char, 2> >  Mat2b; 
# 2321
typedef Mat_< Vec< unsigned char, 3> >  Mat3b; 
# 2322
typedef Mat_< Vec< unsigned char, 4> >  Mat4b; 
# 2324
typedef Mat_< short>  Mat1s; 
# 2325
typedef Mat_< Vec< short, 2> >  Mat2s; 
# 2326
typedef Mat_< Vec< short, 3> >  Mat3s; 
# 2327
typedef Mat_< Vec< short, 4> >  Mat4s; 
# 2329
typedef Mat_< unsigned short>  Mat1w; 
# 2330
typedef Mat_< Vec< unsigned short, 2> >  Mat2w; 
# 2331
typedef Mat_< Vec< unsigned short, 3> >  Mat3w; 
# 2332
typedef Mat_< Vec< unsigned short, 4> >  Mat4w; 
# 2334
typedef Mat_< int>  Mat1i; 
# 2335
typedef Mat_< Vec< int, 2> >  Mat2i; 
# 2336
typedef Mat_< Vec< int, 3> >  Mat3i; 
# 2337
typedef Mat_< Vec< int, 4> >  Mat4i; 
# 2339
typedef Mat_< float>  Mat1f; 
# 2340
typedef Mat_< Vec< float, 2> >  Mat2f; 
# 2341
typedef Mat_< Vec< float, 3> >  Mat3f; 
# 2342
typedef Mat_< Vec< float, 4> >  Mat4f; 
# 2344
typedef Mat_< double>  Mat1d; 
# 2345
typedef Mat_< Vec< double, 2> >  Mat2d; 
# 2346
typedef Mat_< Vec< double, 3> >  Mat3d; 
# 2347
typedef Mat_< Vec< double, 4> >  Mat4d; 
# 2350
class __attribute((visibility("default"))) UMat { 
# 2354
public: inline UMat(UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2357
inline UMat(int rows, int cols, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2358
inline UMat(Size size, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2360
inline UMat(int rows, int cols, int type, const Scalar & s, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2361
inline UMat(Size size, int type, const Scalar & s, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2364
inline UMat(int ndims, const int * sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2365
inline UMat(int ndims, const int * sizes, int type, const Scalar & s, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2368
inline UMat(const UMat & m); 
# 2371
UMat(const UMat & m, const Range & rowRange, const Range & colRange = Range::all()); 
# 2372
UMat(const UMat & m, const Rect & roi); 
# 2373
UMat(const UMat & m, const Range * ranges); 
# 2374
UMat(const UMat & m, const std::vector< Range>  & ranges); 
# 2376
template< class _Tp> inline explicit UMat(const std::vector< _Tp>  & vec, bool copyData = false); 
# 2379
template< class _Tp, int n> explicit UMat(const Vec< _Tp, n>  & vec, bool copyData = true); 
# 2381
template< class _Tp, int m, int n> explicit UMat(const Matx< _Tp, m, n>  & mtx, bool copyData = true); 
# 2383
template< class _Tp> explicit UMat(const Point_< _Tp>  & pt, bool copyData = true); 
# 2385
template< class _Tp> explicit UMat(const Point3_< _Tp>  & pt, bool copyData = true); 
# 2387
template< class _Tp> explicit UMat(const MatCommaInitializer_< _Tp>  & commaInitializer); 
# 2390
~UMat(); 
# 2392
inline UMat &operator=(const UMat & m); 
# 2394
Mat getMat(int flags) const; 
# 2397
inline UMat row(int y) const; 
# 2399
inline UMat col(int x) const; 
# 2401
inline UMat rowRange(int startrow, int endrow) const; 
# 2402
inline UMat rowRange(const Range & r) const; 
# 2404
inline UMat colRange(int startcol, int endcol) const; 
# 2405
inline UMat colRange(const Range & r) const; 
# 2410
UMat diag(int d = 0) const; 
# 2412
static UMat diag(const UMat & d); 
# 2415
inline UMat clone() const; 
# 2418
void copyTo(OutputArray m) const; 
# 2420
void copyTo(OutputArray m, InputArray mask) const; 
# 2422
void convertTo(OutputArray m, int rtype, double alpha = 1, double beta = 0) const; 
# 2424
inline void assignTo(UMat & m, int type = -1) const; 
# 2427
UMat &operator=(const Scalar & s); 
# 2429
UMat &setTo(InputArray value, InputArray mask = noArray()); 
# 2432
UMat reshape(int cn, int rows = 0) const; 
# 2433
UMat reshape(int cn, int newndims, const int * newsz) const; 
# 2436
UMat t() const; 
# 2438
UMat inv(int method = DECOMP_LU) const; 
# 2440
UMat mul(InputArray m, double scale = 1) const; 
# 2443
double dot(InputArray m) const; 
# 2446
static UMat zeros(int rows, int cols, int type); 
# 2447
static UMat zeros(Size size, int type); 
# 2448
static UMat zeros(int ndims, const int * sz, int type); 
# 2449
static UMat ones(int rows, int cols, int type); 
# 2450
static UMat ones(Size size, int type); 
# 2451
static UMat ones(int ndims, const int * sz, int type); 
# 2452
static UMat eye(int rows, int cols, int type); 
# 2453
static UMat eye(Size size, int type); 
# 2457
inline void create(int rows, int cols, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2458
inline void create(Size size, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2459
void create(int ndims, const int * sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2460
void create(const std::vector< int>  & sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2463
inline void addref(); 
# 2466
inline void release(); 
# 2469
void deallocate(); 
# 2471
void copySize(const UMat & m); 
# 2474
void locateROI(Size & wholeSize, Point & ofs) const; 
# 2476
UMat &adjustROI(int dtop, int dbottom, int dleft, int dright); 
# 2479
inline UMat operator()(Range rowRange, Range colRange) const; 
# 2480
inline UMat operator()(const Rect & roi) const; 
# 2481
inline UMat operator()(const Range * ranges) const; 
# 2482
inline UMat operator()(const std::vector< Range>  & ranges) const; 
# 2487
inline bool isContinuous() const; 
# 2490
inline bool isSubmatrix() const; 
# 2494
inline size_t elemSize() const; 
# 2496
inline size_t elemSize1() const; 
# 2498
inline int type() const; 
# 2500
inline int depth() const; 
# 2502
inline int channels() const; 
# 2504
inline size_t step1(int i = 0) const; 
# 2506
inline bool empty() const; 
# 2508
inline size_t total() const; 
# 2511
int checkVector(int elemChannels, int depth = -1, bool requireContinuous = true) const; 
# 2514
inline UMat(UMat && m); 
# 2515
inline UMat &operator=(UMat && m); 
# 2522
void *handle(int accessFlags) const; 
# 2523
void ndoffset(size_t * ofs) const; 
# 2525
enum { MAGIC_VAL = 1124007936, AUTO_STEP = 0, CONTINUOUS_FLAG = 16384, SUBMATRIX_FLAG = 32768}; 
# 2526
enum { MAGIC_MASK = 4294901760U, TYPE_MASK = 4095U, DEPTH_MASK = 7U}; 
# 2534
int flags; 
# 2536
int dims; 
# 2538
int rows, cols; 
# 2541
MatAllocator *allocator; 
# 2542
UMatUsageFlags usageFlags; 
# 2544
static MatAllocator *getStdAllocator(); 
# 2547
UMatData *u; 
# 2550
size_t offset; 
# 2552
MatSize size; 
# 2553
MatStep step; 
# 2556
}; 
# 2640 "/usr/include/opencv2/core/mat.hpp" 3
class __attribute((visibility("default"))) SparseMat { 
# 2643
public: typedef SparseMatIterator iterator; 
# 2644
typedef SparseMatConstIterator const_iterator; 
# 2646
enum { MAGIC_VAL = 1123876864U, MAX_DIM = 32U, HASH_SCALE = 1540483477U, HASH_BIT = 2147483648U}; 
# 2649
struct __attribute((visibility("default"))) Hdr { 
# 2651
Hdr(int _dims, const int * _sizes, int _type); 
# 2652
void clear(); 
# 2653
int refcount; 
# 2654
int dims; 
# 2655
int valueOffset; 
# 2656
size_t nodeSize; 
# 2657
size_t nodeCount; 
# 2658
size_t freeList; 
# 2659
std::vector< unsigned char>  pool; 
# 2660
std::vector< unsigned long>  hashtab; 
# 2661
int size[MAX_DIM]; 
# 2662
}; 
# 2665
struct __attribute((visibility("default"))) Node { 
# 2668
size_t hashval; 
# 2670
size_t next; 
# 2672
int idx[MAX_DIM]; 
# 2673
}; 
# 2677
inline SparseMat(); 
# 2684
inline SparseMat(int dims, const int * _sizes, int _type); 
# 2690
inline SparseMat(const SparseMat & m); 
# 2696
explicit SparseMat(const Mat & m); 
# 2699
inline ~SparseMat(); 
# 2702
inline SparseMat &operator=(const SparseMat & m); 
# 2704
inline SparseMat &operator=(const Mat & m); 
# 2707
inline SparseMat clone() const; 
# 2710
void copyTo(SparseMat & m) const; 
# 2712
void copyTo(Mat & m) const; 
# 2714
void convertTo(SparseMat & m, int rtype, double alpha = 1) const; 
# 2725 "/usr/include/opencv2/core/mat.hpp" 3
void convertTo(Mat & m, int rtype, double alpha = 1, double beta = 0) const; 
# 2728
inline void assignTo(SparseMat & m, int type = -1) const; 
# 2736
void create(int dims, const int * _sizes, int _type); 
# 2738
void clear(); 
# 2740
inline void addref(); 
# 2742
inline void release(); 
# 2747
inline size_t elemSize() const; 
# 2749
inline size_t elemSize1() const; 
# 2752
inline int type() const; 
# 2754
inline int depth() const; 
# 2756
inline int channels() const; 
# 2759
inline const int *size() const; 
# 2761
inline int size(int i) const; 
# 2763
inline int dims() const; 
# 2765
inline size_t nzcount() const; 
# 2768
inline size_t hash(int i0) const; 
# 2770
inline size_t hash(int i0, int i1) const; 
# 2772
inline size_t hash(int i0, int i1, int i2) const; 
# 2774
inline size_t hash(const int * idx) const; 
# 2788 "/usr/include/opencv2/core/mat.hpp" 3
uchar *ptr(int i0, bool createMissing, size_t * hashval = 0); 
# 2790
uchar *ptr(int i0, int i1, bool createMissing, size_t * hashval = 0); 
# 2792
uchar *ptr(int i0, int i1, int i2, bool createMissing, size_t * hashval = 0); 
# 2794
uchar *ptr(const int * idx, bool createMissing, size_t * hashval = 0); 
# 2806 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> inline _Tp &ref(int i0, size_t * hashval = 0); 
# 2808
template< class _Tp> inline _Tp &ref(int i0, int i1, size_t * hashval = 0); 
# 2810
template< class _Tp> inline _Tp &ref(int i0, int i1, int i2, size_t * hashval = 0); 
# 2812
template< class _Tp> inline _Tp &ref(const int * idx, size_t * hashval = 0); 
# 2827 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> inline _Tp value(int i0, size_t * hashval = 0) const; 
# 2829
template< class _Tp> inline _Tp value(int i0, int i1, size_t * hashval = 0) const; 
# 2831
template< class _Tp> inline _Tp value(int i0, int i1, int i2, size_t * hashval = 0) const; 
# 2833
template< class _Tp> inline _Tp value(const int * idx, size_t * hashval = 0) const; 
# 2845 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> inline const _Tp *find(int i0, size_t * hashval = 0) const; 
# 2847
template< class _Tp> inline const _Tp *find(int i0, int i1, size_t * hashval = 0) const; 
# 2849
template< class _Tp> inline const _Tp *find(int i0, int i1, int i2, size_t * hashval = 0) const; 
# 2851
template< class _Tp> inline const _Tp *find(const int * idx, size_t * hashval = 0) const; 
# 2855
void erase(int i0, int i1, size_t * hashval = 0); 
# 2857
void erase(int i0, int i1, int i2, size_t * hashval = 0); 
# 2859
void erase(const int * idx, size_t * hashval = 0); 
# 2866
inline SparseMatIterator begin(); 
# 2868
template< class _Tp> inline SparseMatIterator_< _Tp>  begin(); 
# 2870
inline SparseMatConstIterator begin() const; 
# 2872
template< class _Tp> inline SparseMatConstIterator_< _Tp>  begin() const; 
# 2878
inline SparseMatIterator end(); 
# 2880
inline SparseMatConstIterator end() const; 
# 2882
template< class _Tp> inline SparseMatIterator_< _Tp>  end(); 
# 2884
template< class _Tp> inline SparseMatConstIterator_< _Tp>  end() const; 
# 2887
template< class _Tp> inline _Tp &value(Node * n); 
# 2889
template< class _Tp> inline const _Tp &value(const Node * n) const; 
# 2892
inline Node *node(size_t nidx); 
# 2893
inline const Node *node(size_t nidx) const; 
# 2895
uchar *newNode(const int * idx, size_t hashval); 
# 2896
void removeNode(size_t hidx, size_t nidx, size_t previdx); 
# 2897
void resizeHashTab(size_t newsize); 
# 2899
int flags; 
# 2900
Hdr *hdr; 
# 2901
}; 
# 2918 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> class SparseMat_ : public SparseMat { 
# 2921
public: typedef SparseMatIterator_< _Tp>  iterator; 
# 2922
typedef SparseMatConstIterator_< _Tp>  const_iterator; 
# 2925
inline SparseMat_(); 
# 2927
inline SparseMat_(int dims, const int * _sizes); 
# 2929
inline SparseMat_(const SparseMat & m); 
# 2931
inline SparseMat_(const SparseMat_ & m); 
# 2933
inline SparseMat_(const Mat & m); 
# 2937
inline SparseMat_ &operator=(const SparseMat & m); 
# 2939
inline SparseMat_ &operator=(const SparseMat_ & m); 
# 2941
inline SparseMat_ &operator=(const Mat & m); 
# 2944
inline SparseMat_ clone() const; 
# 2946
inline void create(int dims, const int * _sizes); 
# 2951
inline int type() const; 
# 2953
inline int depth() const; 
# 2955
inline int channels() const; 
# 2958
inline _Tp &ref(int i0, size_t * hashval = 0); 
# 2960
inline _Tp &ref(int i0, int i1, size_t * hashval = 0); 
# 2962
inline _Tp &ref(int i0, int i1, int i2, size_t * hashval = 0); 
# 2964
inline _Tp &ref(const int * idx, size_t * hashval = 0); 
# 2967
inline _Tp operator()(int i0, size_t * hashval = 0) const; 
# 2969
inline _Tp operator()(int i0, int i1, size_t * hashval = 0) const; 
# 2971
inline _Tp operator()(int i0, int i1, int i2, size_t * hashval = 0) const; 
# 2973
inline _Tp operator()(const int * idx, size_t * hashval = 0) const; 
# 2976
inline SparseMatIterator_< _Tp>  begin(); 
# 2978
inline SparseMatConstIterator_< _Tp>  begin() const; 
# 2980
inline SparseMatIterator_< _Tp>  end(); 
# 2982
inline SparseMatConstIterator_< _Tp>  end() const; 
# 2983
}; 
# 2989
class __attribute((visibility("default"))) MatConstIterator { 
# 2992
public: typedef uchar *value_type; 
# 2993
typedef ptrdiff_t difference_type; 
# 2994
typedef const uchar **pointer; 
# 2995
typedef uchar *reference; 
# 2997
typedef std::random_access_iterator_tag iterator_category; 
# 3000
inline MatConstIterator(); 
# 3002
inline MatConstIterator(const Mat * _m); 
# 3004
inline MatConstIterator(const Mat * _m, int _row, int _col = 0); 
# 3006
inline MatConstIterator(const Mat * _m, Point _pt); 
# 3008
MatConstIterator(const Mat * _m, const int * _idx); 
# 3010
inline MatConstIterator(const MatConstIterator & it); 
# 3013
inline MatConstIterator &operator=(const MatConstIterator & it); 
# 3015
inline const uchar *operator*() const; 
# 3017
inline const uchar *operator[](ptrdiff_t i) const; 
# 3020
inline MatConstIterator &operator+=(ptrdiff_t ofs); 
# 3022
inline MatConstIterator &operator-=(ptrdiff_t ofs); 
# 3024
inline MatConstIterator &operator--(); 
# 3026
inline MatConstIterator operator--(int); 
# 3028
inline MatConstIterator &operator++(); 
# 3030
inline MatConstIterator operator++(int); 
# 3032
Point pos() const; 
# 3034
void pos(int * _idx) const; 
# 3036
ptrdiff_t lpos() const; 
# 3037
void seek(ptrdiff_t ofs, bool relative = false); 
# 3038
void seek(const int * _idx, bool relative = false); 
# 3040
const Mat *m; 
# 3041
size_t elemSize; 
# 3042
const uchar *ptr; 
# 3043
const uchar *sliceStart; 
# 3044
const uchar *sliceEnd; 
# 3045
}; 
# 3053
template< class _Tp> 
# 3054
class MatConstIterator_ : public MatConstIterator { 
# 3057
public: typedef _Tp value_type; 
# 3058
typedef ptrdiff_t difference_type; 
# 3059
typedef const _Tp *pointer; 
# 3060
typedef const _Tp &reference; 
# 3062
typedef std::random_access_iterator_tag iterator_category; 
# 3065
inline MatConstIterator_(); 
# 3067
inline MatConstIterator_(const Mat_< _Tp>  * _m); 
# 3069
inline MatConstIterator_(const Mat_< _Tp>  * _m, int _row, int _col = 0); 
# 3071
inline MatConstIterator_(const Mat_< _Tp>  * _m, Point _pt); 
# 3073
MatConstIterator_(const Mat_< _Tp>  * _m, const int * _idx); 
# 3075
inline MatConstIterator_(const MatConstIterator_ & it); 
# 3078
inline MatConstIterator_ &operator=(const MatConstIterator_ & it); 
# 3080
inline const _Tp &operator*() const; 
# 3082
inline const _Tp &operator[](ptrdiff_t i) const; 
# 3085
inline MatConstIterator_ &operator+=(ptrdiff_t ofs); 
# 3087
inline MatConstIterator_ &operator-=(ptrdiff_t ofs); 
# 3089
inline MatConstIterator_ &operator--(); 
# 3091
inline MatConstIterator_ operator--(int); 
# 3093
inline MatConstIterator_ &operator++(); 
# 3095
inline MatConstIterator_ operator++(int); 
# 3097
inline Point pos() const; 
# 3098
}; 
# 3106
template< class _Tp> 
# 3107
class MatIterator_ : public MatConstIterator_< _Tp>  { 
# 3110
public: typedef _Tp *pointer; 
# 3111
typedef _Tp &reference; 
# 3113
typedef ::std::random_access_iterator_tag iterator_category; 
# 3116
inline MatIterator_(); 
# 3118
inline MatIterator_(Mat_< _Tp>  * _m); 
# 3120
inline MatIterator_(Mat_< _Tp>  * _m, int _row, int _col = 0); 
# 3122
inline MatIterator_(Mat_< _Tp>  * _m, ::cv::Point _pt); 
# 3124
inline MatIterator_(Mat_< _Tp>  * _m, const int * _idx); 
# 3126
inline MatIterator_(const MatIterator_ & it); 
# 3128
inline MatIterator_ &operator=(const MatIterator_ & it); 
# 3131
inline _Tp &operator*() const; 
# 3133
inline _Tp &operator[](::ptrdiff_t i) const; 
# 3136
inline MatIterator_ &operator+=(::ptrdiff_t ofs); 
# 3138
inline MatIterator_ &operator-=(::ptrdiff_t ofs); 
# 3140
inline MatIterator_ &operator--(); 
# 3142
inline MatIterator_ operator--(int); 
# 3144
inline MatIterator_ &operator++(); 
# 3146
inline MatIterator_ operator++(int); 
# 3147
}; 
# 3165 "/usr/include/opencv2/core/mat.hpp" 3
class __attribute((visibility("default"))) SparseMatConstIterator { 
# 3169
public: inline SparseMatConstIterator(); 
# 3171
SparseMatConstIterator(const SparseMat * _m); 
# 3173
inline SparseMatConstIterator(const SparseMatConstIterator & it); 
# 3176
inline SparseMatConstIterator &operator=(const SparseMatConstIterator & it); 
# 3179
template< class _Tp> inline const _Tp &value() const; 
# 3181
inline const SparseMat::Node *node() const; 
# 3184
SparseMatConstIterator &operator--(); 
# 3186
SparseMatConstIterator operator--(int); 
# 3188
SparseMatConstIterator &operator++(); 
# 3190
inline SparseMatConstIterator operator++(int); 
# 3193
inline void seekEnd(); 
# 3195
const SparseMat *m; 
# 3196
size_t hashidx; 
# 3197
uchar *ptr; 
# 3198
}; 
# 3209 "/usr/include/opencv2/core/mat.hpp" 3
class __attribute((visibility("default"))) SparseMatIterator : public SparseMatConstIterator { 
# 3213
public: inline SparseMatIterator(); 
# 3215
inline SparseMatIterator(SparseMat * _m); 
# 3217
SparseMatIterator(SparseMat * _m, const int * idx); 
# 3219
inline SparseMatIterator(const SparseMatIterator & it); 
# 3222
inline SparseMatIterator &operator=(const SparseMatIterator & it); 
# 3224
template< class _Tp> inline _Tp &value() const; 
# 3226
inline SparseMat::Node *node() const; 
# 3229
inline SparseMatIterator &operator++(); 
# 3231
inline SparseMatIterator operator++(int); 
# 3232
}; 
# 3243 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> class SparseMatConstIterator_ : public SparseMatConstIterator { 
# 3247
public: typedef std::forward_iterator_tag iterator_category; 
# 3250
inline SparseMatConstIterator_(); 
# 3252
inline SparseMatConstIterator_(const SparseMat_< _Tp>  * _m); 
# 3253
inline SparseMatConstIterator_(const SparseMat * _m); 
# 3255
inline SparseMatConstIterator_(const SparseMatConstIterator_ & it); 
# 3258
inline SparseMatConstIterator_ &operator=(const SparseMatConstIterator_ & it); 
# 3260
inline const _Tp &operator*() const; 
# 3263
inline SparseMatConstIterator_ &operator++(); 
# 3265
inline SparseMatConstIterator_ operator++(int); 
# 3266
}; 
# 3277 "/usr/include/opencv2/core/mat.hpp" 3
template< class _Tp> class SparseMatIterator_ : public SparseMatConstIterator_< _Tp>  { 
# 3281
public: typedef ::std::forward_iterator_tag iterator_category; 
# 3284
inline SparseMatIterator_(); 
# 3286
inline SparseMatIterator_(SparseMat_< _Tp>  * _m); 
# 3287
inline SparseMatIterator_(::cv::SparseMat * _m); 
# 3289
inline SparseMatIterator_(const SparseMatIterator_ & it); 
# 3292
inline SparseMatIterator_ &operator=(const SparseMatIterator_ & it); 
# 3294
inline _Tp &operator*() const; 
# 3297
inline SparseMatIterator_ &operator++(); 
# 3299
inline SparseMatIterator_ operator++(int); 
# 3300
}; 
# 3366 "/usr/include/opencv2/core/mat.hpp" 3
class __attribute((visibility("default"))) NAryMatIterator { 
# 3370
public: NAryMatIterator(); 
# 3372
NAryMatIterator(const Mat ** arrays, uchar ** ptrs, int narrays = -1); 
# 3374
NAryMatIterator(const Mat ** arrays, Mat * planes, int narrays = -1); 
# 3376
void init(const Mat ** arrays, Mat * planes, uchar ** ptrs, int narrays = -1); 
# 3379
NAryMatIterator &operator++(); 
# 3381
NAryMatIterator operator++(int); 
# 3384
const Mat **arrays; 
# 3386
Mat *planes; 
# 3388
uchar **ptrs; 
# 3390
int narrays; 
# 3392
size_t nplanes; 
# 3394
size_t size; 
# 3396
protected: int iterdepth; 
# 3397
size_t idx; 
# 3398
}; 
# 3404
class __attribute((visibility("default"))) MatOp { 
# 3407
public: MatOp(); 
# 3408
virtual ~MatOp(); 
# 3410
virtual bool elementWise(const MatExpr & expr) const; 
# 3411
virtual void assign(const MatExpr & expr, Mat & m, int type = -1) const = 0; 
# 3412
virtual void roi(const MatExpr & expr, const Range & rowRange, const Range & colRange, MatExpr & res) const; 
# 3414
virtual void diag(const MatExpr & expr, int d, MatExpr & res) const; 
# 3415
virtual void augAssignAdd(const MatExpr & expr, Mat & m) const; 
# 3416
virtual void augAssignSubtract(const MatExpr & expr, Mat & m) const; 
# 3417
virtual void augAssignMultiply(const MatExpr & expr, Mat & m) const; 
# 3418
virtual void augAssignDivide(const MatExpr & expr, Mat & m) const; 
# 3419
virtual void augAssignAnd(const MatExpr & expr, Mat & m) const; 
# 3420
virtual void augAssignOr(const MatExpr & expr, Mat & m) const; 
# 3421
virtual void augAssignXor(const MatExpr & expr, Mat & m) const; 
# 3423
virtual void add(const MatExpr & expr1, const MatExpr & expr2, MatExpr & res) const; 
# 3424
virtual void add(const MatExpr & expr1, const Scalar & s, MatExpr & res) const; 
# 3426
virtual void subtract(const MatExpr & expr1, const MatExpr & expr2, MatExpr & res) const; 
# 3427
virtual void subtract(const Scalar & s, const MatExpr & expr, MatExpr & res) const; 
# 3429
virtual void multiply(const MatExpr & expr1, const MatExpr & expr2, MatExpr & res, double scale = 1) const; 
# 3430
virtual void multiply(const MatExpr & expr1, double s, MatExpr & res) const; 
# 3432
virtual void divide(const MatExpr & expr1, const MatExpr & expr2, MatExpr & res, double scale = 1) const; 
# 3433
virtual void divide(double s, const MatExpr & expr, MatExpr & res) const; 
# 3435
virtual void abs(const MatExpr & expr, MatExpr & res) const; 
# 3437
virtual void transpose(const MatExpr & expr, MatExpr & res) const; 
# 3438
virtual void matmul(const MatExpr & expr1, const MatExpr & expr2, MatExpr & res) const; 
# 3439
virtual void invert(const MatExpr & expr, int method, MatExpr & res) const; 
# 3441
virtual Size size(const MatExpr & expr) const; 
# 3442
virtual int type(const MatExpr & expr) const; 
# 3443
}; 
# 3491 "/usr/include/opencv2/core/mat.hpp" 3
class __attribute((visibility("default"))) MatExpr { 
# 3494
public: inline MatExpr(); 
# 3495
explicit MatExpr(const Mat & m); 
# 3497
inline MatExpr(const MatOp * _op, int _flags, const Mat & _a = Mat(), const Mat & _b = Mat(), const Mat & _c = Mat(), double _alpha = 1, double _beta = 1, const Scalar & _s = Scalar()); 
# 3500
inline operator Mat() const; 
# 3501
template< class _Tp> inline operator Mat_< _Tp> () const; 
# 3503
Size size() const; 
# 3504
int type() const; 
# 3506
MatExpr row(int y) const; 
# 3507
MatExpr col(int x) const; 
# 3508
MatExpr diag(int d = 0) const; 
# 3509
MatExpr operator()(const Range & rowRange, const Range & colRange) const; 
# 3510
MatExpr operator()(const Rect & roi) const; 
# 3512
MatExpr t() const; 
# 3513
MatExpr inv(int method = DECOMP_LU) const; 
# 3514
MatExpr mul(const MatExpr & e, double scale = 1) const; 
# 3515
MatExpr mul(const Mat & m, double scale = 1) const; 
# 3517
Mat cross(const Mat & m) const; 
# 3518
double dot(const Mat & m) const; 
# 3520
const MatOp *op; 
# 3521
int flags; 
# 3523
Mat a, b, c; 
# 3524
double alpha, beta; 
# 3525
Scalar s; 
# 3526
}; 
# 3532
__attribute((visibility("default"))) MatExpr operator+(const Mat & a, const Mat & b); 
# 3533
__attribute((visibility("default"))) MatExpr operator+(const Mat & a, const Scalar & s); 
# 3534
__attribute((visibility("default"))) MatExpr operator+(const Scalar & s, const Mat & a); 
# 3535
__attribute((visibility("default"))) MatExpr operator+(const MatExpr & e, const Mat & m); 
# 3536
__attribute((visibility("default"))) MatExpr operator+(const Mat & m, const MatExpr & e); 
# 3537
__attribute((visibility("default"))) MatExpr operator+(const MatExpr & e, const Scalar & s); 
# 3538
__attribute((visibility("default"))) MatExpr operator+(const Scalar & s, const MatExpr & e); 
# 3539
__attribute((visibility("default"))) MatExpr operator+(const MatExpr & e1, const MatExpr & e2); 
# 3541
__attribute((visibility("default"))) MatExpr operator-(const Mat & a, const Mat & b); 
# 3542
__attribute((visibility("default"))) MatExpr operator-(const Mat & a, const Scalar & s); 
# 3543
__attribute((visibility("default"))) MatExpr operator-(const Scalar & s, const Mat & a); 
# 3544
__attribute((visibility("default"))) MatExpr operator-(const MatExpr & e, const Mat & m); 
# 3545
__attribute((visibility("default"))) MatExpr operator-(const Mat & m, const MatExpr & e); 
# 3546
__attribute((visibility("default"))) MatExpr operator-(const MatExpr & e, const Scalar & s); 
# 3547
__attribute((visibility("default"))) MatExpr operator-(const Scalar & s, const MatExpr & e); 
# 3548
__attribute((visibility("default"))) MatExpr operator-(const MatExpr & e1, const MatExpr & e2); 
# 3550
__attribute((visibility("default"))) MatExpr operator-(const Mat & m); 
# 3551
__attribute((visibility("default"))) MatExpr operator-(const MatExpr & e); 
# 3553
__attribute((visibility("default"))) MatExpr operator*(const Mat & a, const Mat & b); 
# 3554
__attribute((visibility("default"))) MatExpr operator*(const Mat & a, double s); 
# 3555
__attribute((visibility("default"))) MatExpr operator*(double s, const Mat & a); 
# 3556
__attribute((visibility("default"))) MatExpr operator*(const MatExpr & e, const Mat & m); 
# 3557
__attribute((visibility("default"))) MatExpr operator*(const Mat & m, const MatExpr & e); 
# 3558
__attribute((visibility("default"))) MatExpr operator*(const MatExpr & e, double s); 
# 3559
__attribute((visibility("default"))) MatExpr operator*(double s, const MatExpr & e); 
# 3560
__attribute((visibility("default"))) MatExpr operator*(const MatExpr & e1, const MatExpr & e2); 
# 3562
__attribute((visibility("default"))) MatExpr operator/(const Mat & a, const Mat & b); 
# 3563
__attribute((visibility("default"))) MatExpr operator/(const Mat & a, double s); 
# 3564
__attribute((visibility("default"))) MatExpr operator/(double s, const Mat & a); 
# 3565
__attribute((visibility("default"))) MatExpr operator/(const MatExpr & e, const Mat & m); 
# 3566
__attribute((visibility("default"))) MatExpr operator/(const Mat & m, const MatExpr & e); 
# 3567
__attribute((visibility("default"))) MatExpr operator/(const MatExpr & e, double s); 
# 3568
__attribute((visibility("default"))) MatExpr operator/(double s, const MatExpr & e); 
# 3569
__attribute((visibility("default"))) MatExpr operator/(const MatExpr & e1, const MatExpr & e2); 
# 3571
__attribute((visibility("default"))) MatExpr operator<(const Mat & a, const Mat & b); 
# 3572
__attribute((visibility("default"))) MatExpr operator<(const Mat & a, double s); 
# 3573
__attribute((visibility("default"))) MatExpr operator<(double s, const Mat & a); 
# 3575
__attribute((visibility("default"))) MatExpr operator<=(const Mat & a, const Mat & b); 
# 3576
__attribute((visibility("default"))) MatExpr operator<=(const Mat & a, double s); 
# 3577
__attribute((visibility("default"))) MatExpr operator<=(double s, const Mat & a); 
# 3579
__attribute((visibility("default"))) MatExpr operator==(const Mat & a, const Mat & b); 
# 3580
__attribute((visibility("default"))) MatExpr operator==(const Mat & a, double s); 
# 3581
__attribute((visibility("default"))) MatExpr operator==(double s, const Mat & a); 
# 3583
__attribute((visibility("default"))) MatExpr operator!=(const Mat & a, const Mat & b); 
# 3584
__attribute((visibility("default"))) MatExpr operator!=(const Mat & a, double s); 
# 3585
__attribute((visibility("default"))) MatExpr operator!=(double s, const Mat & a); 
# 3587
__attribute((visibility("default"))) MatExpr operator>=(const Mat & a, const Mat & b); 
# 3588
__attribute((visibility("default"))) MatExpr operator>=(const Mat & a, double s); 
# 3589
__attribute((visibility("default"))) MatExpr operator>=(double s, const Mat & a); 
# 3591
__attribute((visibility("default"))) MatExpr operator>(const Mat & a, const Mat & b); 
# 3592
__attribute((visibility("default"))) MatExpr operator>(const Mat & a, double s); 
# 3593
__attribute((visibility("default"))) MatExpr operator>(double s, const Mat & a); 
# 3595
__attribute((visibility("default"))) MatExpr operator&(const Mat & a, const Mat & b); 
# 3596
__attribute((visibility("default"))) MatExpr operator&(const Mat & a, const Scalar & s); 
# 3597
__attribute((visibility("default"))) MatExpr operator&(const Scalar & s, const Mat & a); 
# 3599
__attribute((visibility("default"))) MatExpr operator|(const Mat & a, const Mat & b); 
# 3600
__attribute((visibility("default"))) MatExpr operator|(const Mat & a, const Scalar & s); 
# 3601
__attribute((visibility("default"))) MatExpr operator|(const Scalar & s, const Mat & a); 
# 3603
__attribute((visibility("default"))) MatExpr operator^(const Mat & a, const Mat & b); 
# 3604
__attribute((visibility("default"))) MatExpr operator^(const Mat & a, const Scalar & s); 
# 3605
__attribute((visibility("default"))) MatExpr operator^(const Scalar & s, const Mat & a); 
# 3607
__attribute((visibility("default"))) MatExpr operator~(const Mat & m); 
# 3609
__attribute((visibility("default"))) MatExpr min(const Mat & a, const Mat & b); 
# 3610
__attribute((visibility("default"))) MatExpr min(const Mat & a, double s); 
# 3611
__attribute((visibility("default"))) MatExpr min(double s, const Mat & a); 
# 3613
__attribute((visibility("default"))) MatExpr max(const Mat & a, const Mat & b); 
# 3614
__attribute((visibility("default"))) MatExpr max(const Mat & a, double s); 
# 3615
__attribute((visibility("default"))) MatExpr max(double s, const Mat & a); 
# 3630 "/usr/include/opencv2/core/mat.hpp" 3
__attribute((visibility("default"))) MatExpr abs(const Mat & m); 
# 3634
__attribute((visibility("default"))) MatExpr abs(const MatExpr & e); 
# 3637
}
# 57 "/usr/include/opencv2/core/mat.inl.hpp" 3
namespace cv { 
# 66
inline void _InputArray::init(int _flags, const void *_obj) 
# 67
{ (flags) = _flags; (obj) = ((void *)_obj); } 
# 69
inline void _InputArray::init(int _flags, const void *_obj, Size _sz) 
# 70
{ (flags) = _flags; (obj) = ((void *)_obj); ((sz) = _sz); } 
# 72
inline void *_InputArray::getObj() const { return obj; } 
# 73
inline int _InputArray::getFlags() const { return flags; } 
# 74
inline Size _InputArray::getSz() const { return sz; } 
# 76
inline _InputArray::_InputArray() { this->init(NONE, 0); } 
# 77
inline _InputArray::_InputArray(int _flags, void *_obj) { this->init(_flags, _obj); } 
# 78
inline _InputArray::_InputArray(const Mat &m) { this->init((MAT) + (ACCESS_READ), &m); } 
# 79
inline _InputArray::_InputArray(const std::vector< Mat>  &vec) { this->init((STD_VECTOR_MAT) + (ACCESS_READ), &vec); } 
# 80
inline _InputArray::_InputArray(const UMat &m) { this->init((UMAT) + (ACCESS_READ), &m); } 
# 81
inline _InputArray::_InputArray(const std::vector< UMat>  &vec) { this->init((STD_VECTOR_UMAT) + (ACCESS_READ), &vec); } 
# 83
template< class _Tp> inline 
# 84
_InputArray::_InputArray(const std::vector< _Tp>  &vec) 
# 85
{ init((((FIXED_TYPE) + (STD_VECTOR)) + traits::Type< _Tp> ::value) + ACCESS_READ, &vec); } 
# 88
template< class _Tp, std::size_t _Nm> inline 
# 89
_InputArray::_InputArray(const std::array< _Tp, _Nm>  &arr) 
# 90
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::Type< _Tp> ::value) + ACCESS_READ, (arr.data()), Size(1, _Nm)); } 
# 92
template< std::size_t _Nm> inline 
# 93
_InputArray::_InputArray(const std::array< Mat, _Nm>  &arr) 
# 94
{ init((STD_ARRAY_MAT) + (ACCESS_READ), (arr.data()), Size(1, _Nm)); } 
# 98
inline _InputArray::_InputArray(const std::vector< bool>  &vec) 
# 99
{ this->init((((FIXED_TYPE) + (STD_BOOL_VECTOR)) + (traits::Type< bool> ::value)) + (ACCESS_READ), &vec); } 
# 101
template< class _Tp> inline 
# 102
_InputArray::_InputArray(const std::vector< std::vector< _Tp> >  &vec) 
# 103
{ init((((FIXED_TYPE) + (STD_VECTOR_VECTOR)) + traits::Type< _Tp> ::value) + ACCESS_READ, &vec); } 
# 106
inline _InputArray::_InputArray(const std::vector< std::vector< bool> >  &) 
# 107
{ cv::error(Error::StsUnsupportedFormat, "std::vector<std::vector<bool> > is not supported!\n", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 107); } 
# 109
template< class _Tp> inline 
# 110
_InputArray::_InputArray(const std::vector< Mat_< _Tp> >  &vec) 
# 111
{ init((((FIXED_TYPE) + (STD_VECTOR_MAT)) + traits::Type< _Tp> ::value) + ACCESS_READ, &vec); } 
# 113
template< class _Tp, int m, int n> inline 
# 114
_InputArray::_InputArray(const Matx< _Tp, m, n>  &mtx) 
# 115
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::Type< _Tp> ::value) + ACCESS_READ, &mtx, Size(n, m)); } 
# 117
template< class _Tp> inline 
# 118
_InputArray::_InputArray(const _Tp *vec, int n) 
# 119
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::Type< _Tp> ::value) + ACCESS_READ, vec, Size(n, 1)); } 
# 121
template< class _Tp> inline 
# 122
_InputArray::_InputArray(const Mat_< _Tp>  &m) 
# 123
{ init((((FIXED_TYPE) + (MAT)) + traits::Type< _Tp> ::value) + ACCESS_READ, &m); } 
# 125
inline _InputArray::_InputArray(const double &val) 
# 126
{ this->init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + 6) + (ACCESS_READ), &val, Size(1, 1)); } 
# 128
inline _InputArray::_InputArray(const MatExpr &expr) 
# 129
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (EXPR)) + (ACCESS_READ), &expr); } 
# 131
inline _InputArray::_InputArray(const cuda::GpuMat &d_mat) 
# 132
{ this->init((CUDA_GPU_MAT) + (ACCESS_READ), &d_mat); } 
# 134
inline _InputArray::_InputArray(const std::vector< cuda::GpuMat>  &d_mat) 
# 135
{ this->init((STD_VECTOR_CUDA_GPU_MAT) + (ACCESS_READ), &d_mat); } 
# 137
inline _InputArray::_InputArray(const ogl::Buffer &buf) 
# 138
{ this->init((OPENGL_BUFFER) + (ACCESS_READ), &buf); } 
# 140
inline _InputArray::_InputArray(const cuda::HostMem &cuda_mem) 
# 141
{ this->init((CUDA_HOST_MEM) + (ACCESS_READ), &cuda_mem); } 
# 143
inline _InputArray::~_InputArray() { } 
# 145
inline Mat _InputArray::getMat(int i) const 
# 146
{ 
# 147
if ((this->kind() == (MAT)) && (i < 0)) { 
# 148
return *((const Mat *)(obj)); }  
# 149
return this->getMat_(i); 
# 150
} 
# 152
inline bool _InputArray::isMat() const { return this->kind() == (_InputArray::MAT); } 
# 153
inline bool _InputArray::isUMat() const { return this->kind() == (_InputArray::UMAT); } 
# 154
inline bool _InputArray::isMatVector() const { return this->kind() == (_InputArray::STD_VECTOR_MAT); } 
# 155
inline bool _InputArray::isUMatVector() const { return this->kind() == (_InputArray::STD_VECTOR_UMAT); } 
# 156
inline bool _InputArray::isMatx() const { return this->kind() == (_InputArray::MATX); } 
# 157
inline bool _InputArray::isVector() const { return ((this->kind() == (_InputArray::STD_VECTOR)) || (this->kind() == (_InputArray::STD_BOOL_VECTOR))) || (this->kind() == (_InputArray::STD_ARRAY)); 
# 159
} 
# 160
inline bool _InputArray::isGpuMatVector() const { return this->kind() == (_InputArray::STD_VECTOR_CUDA_GPU_MAT); } 
# 164
inline _OutputArray::_OutputArray() { this->init(ACCESS_WRITE, 0); } 
# 165
inline _OutputArray::_OutputArray(int _flags, void *_obj) { this->init(_flags | (ACCESS_WRITE), _obj); } 
# 166
inline _OutputArray::_OutputArray(Mat &m) { this->init((MAT) + (ACCESS_WRITE), &m); } 
# 167
inline _OutputArray::_OutputArray(std::vector< Mat>  &vec) { this->init((STD_VECTOR_MAT) + (ACCESS_WRITE), &vec); } 
# 168
inline _OutputArray::_OutputArray(UMat &m) { this->init((UMAT) + (ACCESS_WRITE), &m); } 
# 169
inline _OutputArray::_OutputArray(std::vector< UMat>  &vec) { this->init((STD_VECTOR_UMAT) + (ACCESS_WRITE), &vec); } 
# 171
template< class _Tp> inline 
# 172
_OutputArray::_OutputArray(std::vector< _Tp>  &vec) 
# 173
{ init((((FIXED_TYPE) + (STD_VECTOR)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 176
template< class _Tp, std::size_t _Nm> inline 
# 177
_OutputArray::_OutputArray(std::array< _Tp, _Nm>  &arr) 
# 178
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, (arr.data()), Size(1, _Nm)); } 
# 180
template< std::size_t _Nm> inline 
# 181
_OutputArray::_OutputArray(std::array< Mat, _Nm>  &arr) 
# 182
{ init((STD_ARRAY_MAT) + (ACCESS_WRITE), (arr.data()), Size(1, _Nm)); } 
# 186
inline _OutputArray::_OutputArray(std::vector< bool>  &) 
# 187
{ cv::error(Error::StsUnsupportedFormat, "std::vector<bool> cannot be an output array\n", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 187); } 
# 189
template< class _Tp> inline 
# 190
_OutputArray::_OutputArray(std::vector< std::vector< _Tp> >  &vec) 
# 191
{ init((((FIXED_TYPE) + (STD_VECTOR_VECTOR)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 194
inline _OutputArray::_OutputArray(std::vector< std::vector< bool> >  &) 
# 195
{ cv::error(Error::StsUnsupportedFormat, "std::vector<std::vector<bool> > cannot be an output array\n", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 195); } 
# 197
template< class _Tp> inline 
# 198
_OutputArray::_OutputArray(std::vector< Mat_< _Tp> >  &vec) 
# 199
{ init((((FIXED_TYPE) + (STD_VECTOR_MAT)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 201
template< class _Tp> inline 
# 202
_OutputArray::_OutputArray(Mat_< _Tp>  &m) 
# 203
{ init((((FIXED_TYPE) + (MAT)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, &m); } 
# 205
template< class _Tp, int m, int n> inline 
# 206
_OutputArray::_OutputArray(Matx< _Tp, m, n>  &mtx) 
# 207
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, &mtx, Size(n, m)); } 
# 209
template< class _Tp> inline 
# 210
_OutputArray::_OutputArray(_Tp *vec, int n) 
# 211
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, vec, Size(n, 1)); } 
# 213
template< class _Tp> inline 
# 214
_OutputArray::_OutputArray(const std::vector< _Tp>  &vec) 
# 215
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 218
template< class _Tp, std::size_t _Nm> inline 
# 219
_OutputArray::_OutputArray(const std::array< _Tp, _Nm>  &arr) 
# 220
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, (arr.data()), Size(1, _Nm)); } 
# 222
template< std::size_t _Nm> inline 
# 223
_OutputArray::_OutputArray(const std::array< Mat, _Nm>  &arr) 
# 224
{ init(((FIXED_SIZE) + (STD_ARRAY_MAT)) + (ACCESS_WRITE), (arr.data()), Size(1, _Nm)); } 
# 227
template< class _Tp> inline 
# 228
_OutputArray::_OutputArray(const std::vector< std::vector< _Tp> >  &vec) 
# 229
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_VECTOR)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 231
template< class _Tp> inline 
# 232
_OutputArray::_OutputArray(const std::vector< Mat_< _Tp> >  &vec) 
# 233
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_MAT)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 235
template< class _Tp> inline 
# 236
_OutputArray::_OutputArray(const Mat_< _Tp>  &m) 
# 237
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MAT)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, &m); } 
# 239
template< class _Tp, int m, int n> inline 
# 240
_OutputArray::_OutputArray(const Matx< _Tp, m, n>  &mtx) 
# 241
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, &mtx, Size(n, m)); } 
# 243
template< class _Tp> inline 
# 244
_OutputArray::_OutputArray(const _Tp *vec, int n) 
# 245
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::Type< _Tp> ::value) + ACCESS_WRITE, vec, Size(n, 1)); } 
# 247
inline _OutputArray::_OutputArray(cuda::GpuMat &d_mat) 
# 248
{ this->init((CUDA_GPU_MAT) + (ACCESS_WRITE), &d_mat); } 
# 250
inline _OutputArray::_OutputArray(std::vector< cuda::GpuMat>  &d_mat) 
# 251
{ this->init((STD_VECTOR_CUDA_GPU_MAT) + (ACCESS_WRITE), &d_mat); } 
# 253
inline _OutputArray::_OutputArray(ogl::Buffer &buf) 
# 254
{ this->init((OPENGL_BUFFER) + (ACCESS_WRITE), &buf); } 
# 256
inline _OutputArray::_OutputArray(cuda::HostMem &cuda_mem) 
# 257
{ this->init((CUDA_HOST_MEM) + (ACCESS_WRITE), &cuda_mem); } 
# 259
inline _OutputArray::_OutputArray(const Mat &m) 
# 260
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (MAT)) + (ACCESS_WRITE), &m); } 
# 262
inline _OutputArray::_OutputArray(const std::vector< Mat>  &vec) 
# 263
{ this->init(((FIXED_SIZE) + (STD_VECTOR_MAT)) + (ACCESS_WRITE), &vec); } 
# 265
inline _OutputArray::_OutputArray(const UMat &m) 
# 266
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (UMAT)) + (ACCESS_WRITE), &m); } 
# 268
inline _OutputArray::_OutputArray(const std::vector< UMat>  &vec) 
# 269
{ this->init(((FIXED_SIZE) + (STD_VECTOR_UMAT)) + (ACCESS_WRITE), &vec); } 
# 271
inline _OutputArray::_OutputArray(const cuda::GpuMat &d_mat) 
# 272
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (CUDA_GPU_MAT)) + (ACCESS_WRITE), &d_mat); } 
# 275
inline _OutputArray::_OutputArray(const ogl::Buffer &buf) 
# 276
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (OPENGL_BUFFER)) + (ACCESS_WRITE), &buf); } 
# 278
inline _OutputArray::_OutputArray(const cuda::HostMem &cuda_mem) 
# 279
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (CUDA_HOST_MEM)) + (ACCESS_WRITE), &cuda_mem); } 
# 283
inline _InputOutputArray::_InputOutputArray() { this->init(ACCESS_RW, 0); } 
# 284
inline _InputOutputArray::_InputOutputArray(int _flags, void *_obj) { this->init(_flags | (ACCESS_RW), _obj); } 
# 285
inline _InputOutputArray::_InputOutputArray(Mat &m) { this->init((MAT) + (ACCESS_RW), &m); } 
# 286
inline _InputOutputArray::_InputOutputArray(std::vector< Mat>  &vec) { this->init((STD_VECTOR_MAT) + (ACCESS_RW), &vec); } 
# 287
inline _InputOutputArray::_InputOutputArray(UMat &m) { this->init((UMAT) + (ACCESS_RW), &m); } 
# 288
inline _InputOutputArray::_InputOutputArray(std::vector< UMat>  &vec) { this->init((STD_VECTOR_UMAT) + (ACCESS_RW), &vec); } 
# 290
template< class _Tp> inline 
# 291
_InputOutputArray::_InputOutputArray(std::vector< _Tp>  &vec) 
# 292
{ init((((FIXED_TYPE) + (STD_VECTOR)) + traits::Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 295
template< class _Tp, std::size_t _Nm> inline 
# 296
_InputOutputArray::_InputOutputArray(std::array< _Tp, _Nm>  &arr) 
# 297
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::Type< _Tp> ::value) + ACCESS_RW, (arr.data()), Size(1, _Nm)); } 
# 299
template< std::size_t _Nm> inline 
# 300
_InputOutputArray::_InputOutputArray(std::array< Mat, _Nm>  &arr) 
# 301
{ init((STD_ARRAY_MAT) + (ACCESS_RW), (arr.data()), Size(1, _Nm)); } 
# 304
inline _InputOutputArray::_InputOutputArray(std::vector< bool>  &) 
# 305
{ cv::error(Error::StsUnsupportedFormat, "std::vector<bool> cannot be an input/output array\n", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 305); } 
# 307
template< class _Tp> inline 
# 308
_InputOutputArray::_InputOutputArray(std::vector< std::vector< _Tp> >  &vec) 
# 309
{ init((((FIXED_TYPE) + (STD_VECTOR_VECTOR)) + traits::Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 311
template< class _Tp> inline 
# 312
_InputOutputArray::_InputOutputArray(std::vector< Mat_< _Tp> >  &vec) 
# 313
{ init((((FIXED_TYPE) + (STD_VECTOR_MAT)) + traits::Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 315
template< class _Tp> inline 
# 316
_InputOutputArray::_InputOutputArray(Mat_< _Tp>  &m) 
# 317
{ init((((FIXED_TYPE) + (MAT)) + traits::Type< _Tp> ::value) + ACCESS_RW, &m); } 
# 319
template< class _Tp, int m, int n> inline 
# 320
_InputOutputArray::_InputOutputArray(Matx< _Tp, m, n>  &mtx) 
# 321
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::Type< _Tp> ::value) + ACCESS_RW, &mtx, Size(n, m)); } 
# 323
template< class _Tp> inline 
# 324
_InputOutputArray::_InputOutputArray(_Tp *vec, int n) 
# 325
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::Type< _Tp> ::value) + ACCESS_RW, vec, Size(n, 1)); } 
# 327
template< class _Tp> inline 
# 328
_InputOutputArray::_InputOutputArray(const std::vector< _Tp>  &vec) 
# 329
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR)) + traits::Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 332
template< class _Tp, std::size_t _Nm> inline 
# 333
_InputOutputArray::_InputOutputArray(const std::array< _Tp, _Nm>  &arr) 
# 334
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::Type< _Tp> ::value) + ACCESS_RW, (arr.data()), Size(1, _Nm)); } 
# 336
template< std::size_t _Nm> inline 
# 337
_InputOutputArray::_InputOutputArray(const std::array< Mat, _Nm>  &arr) 
# 338
{ init(((FIXED_SIZE) + (STD_ARRAY_MAT)) + (ACCESS_RW), (arr.data()), Size(1, _Nm)); } 
# 341
template< class _Tp> inline 
# 342
_InputOutputArray::_InputOutputArray(const std::vector< std::vector< _Tp> >  &vec) 
# 343
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_VECTOR)) + traits::Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 345
template< class _Tp> inline 
# 346
_InputOutputArray::_InputOutputArray(const std::vector< Mat_< _Tp> >  &vec) 
# 347
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_MAT)) + traits::Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 349
template< class _Tp> inline 
# 350
_InputOutputArray::_InputOutputArray(const Mat_< _Tp>  &m) 
# 351
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MAT)) + traits::Type< _Tp> ::value) + ACCESS_RW, &m); } 
# 353
template< class _Tp, int m, int n> inline 
# 354
_InputOutputArray::_InputOutputArray(const Matx< _Tp, m, n>  &mtx) 
# 355
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::Type< _Tp> ::value) + ACCESS_RW, &mtx, Size(n, m)); } 
# 357
template< class _Tp> inline 
# 358
_InputOutputArray::_InputOutputArray(const _Tp *vec, int n) 
# 359
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::Type< _Tp> ::value) + ACCESS_RW, vec, Size(n, 1)); } 
# 361
inline _InputOutputArray::_InputOutputArray(cuda::GpuMat &d_mat) 
# 362
{ this->init((CUDA_GPU_MAT) + (ACCESS_RW), &d_mat); } 
# 364
inline _InputOutputArray::_InputOutputArray(ogl::Buffer &buf) 
# 365
{ this->init((OPENGL_BUFFER) + (ACCESS_RW), &buf); } 
# 367
inline _InputOutputArray::_InputOutputArray(cuda::HostMem &cuda_mem) 
# 368
{ this->init((CUDA_HOST_MEM) + (ACCESS_RW), &cuda_mem); } 
# 370
inline _InputOutputArray::_InputOutputArray(const Mat &m) 
# 371
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (MAT)) + (ACCESS_RW), &m); } 
# 373
inline _InputOutputArray::_InputOutputArray(const std::vector< Mat>  &vec) 
# 374
{ this->init(((FIXED_SIZE) + (STD_VECTOR_MAT)) + (ACCESS_RW), &vec); } 
# 376
inline _InputOutputArray::_InputOutputArray(const UMat &m) 
# 377
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (UMAT)) + (ACCESS_RW), &m); } 
# 379
inline _InputOutputArray::_InputOutputArray(const std::vector< UMat>  &vec) 
# 380
{ this->init(((FIXED_SIZE) + (STD_VECTOR_UMAT)) + (ACCESS_RW), &vec); } 
# 382
inline _InputOutputArray::_InputOutputArray(const cuda::GpuMat &d_mat) 
# 383
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (CUDA_GPU_MAT)) + (ACCESS_RW), &d_mat); } 
# 385
inline _InputOutputArray::_InputOutputArray(const std::vector< cuda::GpuMat>  &d_mat) 
# 386
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_CUDA_GPU_MAT)) + (ACCESS_RW), &d_mat); } 
# 388
template<> inline _InputOutputArray::_InputOutputArray(std::vector< cuda::GpuMat>  &d_mat) 
# 389
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_CUDA_GPU_MAT)) + (ACCESS_RW), &d_mat); } 
# 391
inline _InputOutputArray::_InputOutputArray(const ogl::Buffer &buf) 
# 392
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (OPENGL_BUFFER)) + (ACCESS_RW), &buf); } 
# 394
inline _InputOutputArray::_InputOutputArray(const cuda::HostMem &cuda_mem) 
# 395
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (CUDA_HOST_MEM)) + (ACCESS_RW), &cuda_mem); } 
# 402
inline Mat::Mat() : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 405
{ } 
# 408
inline Mat::Mat(int _rows, int _cols, int _type) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 411
{ 
# 412
this->create(_rows, _cols, _type); 
# 413
} 
# 416
inline Mat::Mat(int _rows, int _cols, int _type, const Scalar &_s) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 419
{ 
# 420
this->create(_rows, _cols, _type); 
# 421
((*this) = _s); 
# 422
} 
# 425
inline Mat::Mat(Size _sz, int _type) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 428
{ 
# 429
this->create(_sz.height, _sz.width, _type); 
# 430
} 
# 433
inline Mat::Mat(Size _sz, int _type, const Scalar &_s) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 436
{ 
# 437
this->create(_sz.height, _sz.width, _type); 
# 438
((*this) = _s); 
# 439
} 
# 442
inline Mat::Mat(int _dims, const int *_sz, int _type) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 445
{ 
# 446
this->create(_dims, _sz, _type); 
# 447
} 
# 450
inline Mat::Mat(int _dims, const int *_sz, int _type, const Scalar &_s) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 453
{ 
# 454
this->create(_dims, _sz, _type); 
# 455
((*this) = _s); 
# 456
} 
# 459
inline Mat::Mat(const std::vector< int>  &_sz, int _type) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 462
{ 
# 463
this->create(_sz, _type); 
# 464
} 
# 467
inline Mat::Mat(const std::vector< int>  &_sz, int _type, const Scalar &_s) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 470
{ 
# 471
this->create(_sz, _type); 
# 472
((*this) = _s); 
# 473
} 
# 476
inline Mat::Mat(const Mat &m) : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data), datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator), u(m.u), size(&(rows)), step(0) 
# 480
{ 
# 481
if (u) { 
# 482
(int)__atomic_fetch_add((unsigned *)(&((u)->refcount)), (unsigned)1, 4); }  
# 483
if ((m.dims) <= 2) 
# 484
{ 
# 485
(step)[0] = (m.step)[0]; (step)[1] = (m.step)[1]; 
# 486
} else 
# 488
{ 
# 489
(dims) = 0; 
# 490
this->copySize(m); 
# 491
}  
# 492
} 
# 495
inline Mat::Mat(int _rows, int _cols, int _type, void *_data, size_t _step) : flags((MAGIC_VAL) + (_type & (TYPE_MASK))), dims(2), rows(_rows), cols(_cols), data((uchar *)_data), datastart((uchar *)_data), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)) 
# 499
{ 
# 500
if (!(!((this->total() == (0)) || ((data) != (__null))))) { ; } else { cv::error(cv::Error::StsAssert, "total() == 0 || data != __null", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 500); }  
# 502
size_t esz = (((_type & ((512 - 1) << 3)) >> 3) + 1) << ((((((sizeof(size_t) / (4)) + (1)) * (16384)) | (14928)) >> ((_type & ((1 << 3) - 1)) * 2)) & (3)), esz1 = (((sizeof(size_t) << 28) | (138682897)) >> ((_type & ((1 << 3) - 1)) * 4)) & (15); 
# 503
size_t minstep = (cols) * esz; 
# 504
if (_step == (AUTO_STEP)) 
# 505
{ 
# 506
_step = minstep; 
# 507
(flags) |= (CONTINUOUS_FLAG); 
# 508
} else 
# 510
{ 
# 511
if ((rows) == 1) { _step = minstep; }  
# 512
; 
# 514
if ((_step % esz1) != (0)) 
# 515
{ 
# 516
cv::error(Error::BadStep, "Step must be a multiple of esz1", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 516); 
# 517
}  
# 519
(flags) |= ((_step == minstep) ? CONTINUOUS_FLAG : 0); 
# 520
}  
# 521
(step)[0] = _step; 
# 522
(step)[1] = esz; 
# 523
(datalimit) = ((datastart) + (_step * (rows))); 
# 524
(dataend) = (((datalimit) - _step) + minstep); 
# 525
} 
# 528
inline Mat::Mat(Size _sz, int _type, void *_data, size_t _step) : flags((MAGIC_VAL) + (_type & (TYPE_MASK))), dims(2), rows(_sz.height), cols(_sz.width), data((uchar *)_data), datastart((uchar *)_data), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)) 
# 532
{ 
# 533
if (!(!((this->total() == (0)) || ((data) != (__null))))) { ; } else { cv::error(cv::Error::StsAssert, "total() == 0 || data != __null", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 533); }  
# 535
size_t esz = (((_type & ((512 - 1) << 3)) >> 3) + 1) << ((((((sizeof(size_t) / (4)) + (1)) * (16384)) | (14928)) >> ((_type & ((1 << 3) - 1)) * 2)) & (3)), esz1 = (((sizeof(size_t) << 28) | (138682897)) >> ((_type & ((1 << 3) - 1)) * 4)) & (15); 
# 536
size_t minstep = (cols) * esz; 
# 537
if (_step == (AUTO_STEP)) 
# 538
{ 
# 539
_step = minstep; 
# 540
(flags) |= (CONTINUOUS_FLAG); 
# 541
} else 
# 543
{ 
# 544
if ((rows) == 1) { _step = minstep; }  
# 545
; 
# 547
if ((_step % esz1) != (0)) 
# 548
{ 
# 549
cv::error(Error::BadStep, "Step must be a multiple of esz1", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 549); 
# 550
}  
# 552
(flags) |= ((_step == minstep) ? CONTINUOUS_FLAG : 0); 
# 553
}  
# 554
(step)[0] = _step; 
# 555
(step)[1] = esz; 
# 556
(datalimit) = ((datastart) + (_step * (rows))); 
# 557
(dataend) = (((datalimit) - _step) + minstep); 
# 558
} 
# 560
template< class _Tp> inline 
# 561
Mat::Mat(const std::vector< _Tp>  &vec, bool copyData) : flags(((MAGIC_VAL | traits::Type< _Tp> ::value) | (1 << 14))), dims(2), rows((int)(vec.size())), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 564
{ 
# 565
if ((vec.empty())) { 
# 566
return; }  
# 567
if (!copyData) 
# 568
{ 
# 569
(step)[0] = ((step)[1] = sizeof(_Tp)); 
# 570
(datastart) = ((data) = ((uchar *)(&(vec[0])))); 
# 571
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 572
} else { 
# 574
Mat((int)(vec.size()), 1, traits::Type< _Tp> ::value, (uchar *)(&(vec[0]))).copyTo(*this); }  
# 575
} 
# 578
template< class _Tp, class > inline 
# 579
Mat::Mat(const std::initializer_list< _Tp>  list) : flags(((MAGIC_VAL | traits::Type< _Tp> ::value) | (1 << 14))), dims(2), rows((int)(list.size())), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 582
{ 
# 583
if ((list.size()) == 0) { 
# 584
return; }  
# 585
Mat((int)(list.size()), 1, traits::Type< _Tp> ::value, (uchar *)(list.begin())).copyTo(*this); 
# 586
} 
# 590
template< class _Tp, std::size_t _Nm> inline 
# 591
Mat::Mat(const std::array< _Tp, _Nm>  &arr, bool copyData) : flags(((MAGIC_VAL | traits::Type< _Tp> ::value) | (1 << 14))), dims(2), rows((int)(arr.size())), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 594
{ 
# 595
if ((arr.empty())) { 
# 596
return; }  
# 597
if (!copyData) 
# 598
{ 
# 599
(step)[0] = ((step)[1] = sizeof(_Tp)); 
# 600
(datastart) = ((data) = ((uchar *)(arr.data()))); 
# 601
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 602
} else { 
# 604
Mat((int)(arr.size()), 1, traits::Type< _Tp> ::value, (uchar *)(arr.data())).copyTo(*this); }  
# 605
} 
# 608
template< class _Tp, int n> inline 
# 609
Mat::Mat(const Vec< _Tp, n>  &vec, bool copyData) : flags(((MAGIC_VAL | traits::Type< _Tp> ::value) | (1 << 14))), dims(2), rows(n), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 612
{ 
# 613
if (!copyData) 
# 614
{ 
# 615
(step)[0] = ((step)[1] = sizeof(_Tp)); 
# 616
(datastart) = ((data) = ((uchar *)(vec.val))); 
# 617
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 618
} else { 
# 620
Mat(n, 1, traits::Type< _Tp> ::value, (void *)(vec.val)).copyTo(*this); }  
# 621
} 
# 624
template< class _Tp, int m, int n> inline 
# 625
Mat::Mat(const Matx< _Tp, m, n>  &M, bool copyData) : flags(((MAGIC_VAL | traits::Type< _Tp> ::value) | (1 << 14))), dims(2), rows(m), cols(n), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 628
{ 
# 629
if (!copyData) 
# 630
{ 
# 631
(step)[0] = ((cols) * sizeof(_Tp)); 
# 632
(step)[1] = sizeof(_Tp); 
# 633
(datastart) = ((data) = ((uchar *)(M.val))); 
# 634
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 635
} else { 
# 637
Mat(m, n, traits::Type< _Tp> ::value, (uchar *)(M.val)).copyTo(*this); }  
# 638
} 
# 640
template< class _Tp> inline 
# 641
Mat::Mat(const Point_< _Tp>  &pt, bool copyData) : flags(((MAGIC_VAL | traits::Type< _Tp> ::value) | (1 << 14))), dims(2), rows(2), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 644
{ 
# 645
if (!copyData) 
# 646
{ 
# 647
(step)[0] = ((step)[1] = sizeof(_Tp)); 
# 648
(datastart) = ((data) = ((uchar *)(&(pt.x)))); 
# 649
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 650
} else 
# 652
{ 
# 653
create(2, 1, traits::Type< _Tp> ::value); 
# 654
(((_Tp *)(data))[0]) = (pt.x); 
# 655
(((_Tp *)(data))[1]) = (pt.y); 
# 656
}  
# 657
} 
# 659
template< class _Tp> inline 
# 660
Mat::Mat(const Point3_< _Tp>  &pt, bool copyData) : flags(((MAGIC_VAL | traits::Type< _Tp> ::value) | (1 << 14))), dims(2), rows(3), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 663
{ 
# 664
if (!copyData) 
# 665
{ 
# 666
(step)[0] = ((step)[1] = sizeof(_Tp)); 
# 667
(datastart) = ((data) = ((uchar *)(&(pt.x)))); 
# 668
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 669
} else 
# 671
{ 
# 672
create(3, 1, traits::Type< _Tp> ::value); 
# 673
(((_Tp *)(data))[0]) = (pt.x); 
# 674
(((_Tp *)(data))[1]) = (pt.y); 
# 675
(((_Tp *)(data))[2]) = (pt.z); 
# 676
}  
# 677
} 
# 679
template< class _Tp> inline 
# 680
Mat::Mat(const MatCommaInitializer_< _Tp>  &commaInitializer) : flags(((MAGIC_VAL | traits::Type< _Tp> ::value) | (1 << 14))), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), allocator((0)), u((0)), size(&(rows)) 
# 683
{ 
# 684
(*this) = (commaInitializer.MatCommaInitializer_< _Tp> ::operator Mat_< _Tp> ()); 
# 685
} 
# 688
inline Mat::~Mat() 
# 689
{ 
# 690
this->release(); 
# 691
if (((step).p) != ((step).buf)) { 
# 692
fastFree((step).p); }  
# 693
} 
# 696
inline Mat &Mat::operator=(const Mat &m) 
# 697
{ 
# 698
if (this != (&m)) 
# 699
{ 
# 700
if (m.u) { 
# 701
(int)__atomic_fetch_add((unsigned *)(&((m.u)->refcount)), (unsigned)1, 4); }  
# 702
this->release(); 
# 703
(flags) = (m.flags); 
# 704
if (((dims) <= 2) && ((m.dims) <= 2)) 
# 705
{ 
# 706
(dims) = (m.dims); 
# 707
(rows) = (m.rows); 
# 708
(cols) = (m.cols); 
# 709
(step)[0] = (m.step)[0]; 
# 710
(step)[1] = (m.step)[1]; 
# 711
} else { 
# 713
this->copySize(m); }  
# 714
(data) = (m.data); 
# 715
(datastart) = (m.datastart); 
# 716
(dataend) = (m.dataend); 
# 717
(datalimit) = (m.datalimit); 
# 718
(allocator) = (m.allocator); 
# 719
(u) = (m.u); 
# 720
}  
# 721
return *this; 
# 722
} 
# 725
inline Mat Mat::row(int y) const 
# 726
{ 
# 727
return Mat(*this, Range(y, y + 1), Range::all()); 
# 728
} 
# 731
inline Mat Mat::col(int x) const 
# 732
{ 
# 733
return Mat(*this, Range::all(), Range(x, x + 1)); 
# 734
} 
# 737
inline Mat Mat::rowRange(int startrow, int endrow) const 
# 738
{ 
# 739
return Mat(*this, Range(startrow, endrow), Range::all()); 
# 740
} 
# 743
inline Mat Mat::rowRange(const Range &r) const 
# 744
{ 
# 745
return Mat(*this, r, Range::all()); 
# 746
} 
# 749
inline Mat Mat::colRange(int startcol, int endcol) const 
# 750
{ 
# 751
return Mat(*this, Range::all(), Range(startcol, endcol)); 
# 752
} 
# 755
inline Mat Mat::colRange(const Range &r) const 
# 756
{ 
# 757
return Mat(*this, Range::all(), r); 
# 758
} 
# 761
inline Mat Mat::clone() const 
# 762
{ 
# 763
Mat m; 
# 764
this->copyTo(m); 
# 765
return m; 
# 766
} 
# 769
inline void Mat::assignTo(Mat &m, int _type) const 
# 770
{ 
# 771
if (_type < 0) { 
# 772
(m = (*this)); } else { 
# 774
this->convertTo(m, _type); }  
# 775
} 
# 778
inline void Mat::create(int _rows, int _cols, int _type) 
# 779
{ 
# 780
_type &= (TYPE_MASK); 
# 781
if (((dims) <= 2) && ((rows) == _rows) && ((cols) == _cols) && (this->type() == _type) && (data)) { 
# 782
return; }  
# 783
int sz[] = {_rows, _cols}; 
# 784
this->create(2, sz, _type); 
# 785
} 
# 788
inline void Mat::create(Size _sz, int _type) 
# 789
{ 
# 790
this->create(_sz.height, _sz.width, _type); 
# 791
} 
# 794
inline void Mat::addref() 
# 795
{ 
# 796
if (u) { 
# 797
(int)__atomic_fetch_add((unsigned *)(&((u)->refcount)), (unsigned)1, 4); }  
# 798
} 
# 801
inline void Mat::release() 
# 802
{ 
# 803
if ((u) && (((int)__atomic_fetch_add((unsigned *)(&((u)->refcount)), (unsigned)(-1), 4)) == 1)) { 
# 804
this->deallocate(); }  
# 805
(u) = (__null); 
# 806
(datastart) = ((dataend) = ((datalimit) = ((data) = (0)))); 
# 807
for (int i = 0; i < (dims); i++) { 
# 808
(((size).p)[i]) = 0; }  
# 819 "/usr/include/opencv2/core/mat.inl.hpp" 3
} 
# 822
inline Mat Mat::operator()(Range _rowRange, Range _colRange) const 
# 823
{ 
# 824
return Mat(*this, _rowRange, _colRange); 
# 825
} 
# 828
inline Mat Mat::operator()(const Rect &roi) const 
# 829
{ 
# 830
return Mat(*this, roi); 
# 831
} 
# 834
inline Mat Mat::operator()(const Range *ranges) const 
# 835
{ 
# 836
return Mat(*this, ranges); 
# 837
} 
# 840
inline Mat Mat::operator()(const std::vector< Range>  &ranges) const 
# 841
{ 
# 842
return Mat(*this, ranges); 
# 843
} 
# 846
inline bool Mat::isContinuous() const 
# 847
{ 
# 848
return ((flags) & (CONTINUOUS_FLAG)) != 0; 
# 849
} 
# 852
inline bool Mat::isSubmatrix() const 
# 853
{ 
# 854
return ((flags) & (SUBMATRIX_FLAG)) != 0; 
# 855
} 
# 858
inline size_t Mat::elemSize() const 
# 859
{ 
# 860
return ((dims) > 0) ? ((step).p)[(dims) - 1] : (0); 
# 861
} 
# 864
inline size_t Mat::elemSize1() const 
# 865
{ 
# 866
return (((sizeof(size_t) << 28) | (138682897)) >> (((flags) & ((1 << 3) - 1)) * 4)) & (15); 
# 867
} 
# 870
inline int Mat::type() const 
# 871
{ 
# 872
return (flags) & (((1 << 3) * 512) - 1); 
# 873
} 
# 876
inline int Mat::depth() const 
# 877
{ 
# 878
return (flags) & ((1 << 3) - 1); 
# 879
} 
# 882
inline int Mat::channels() const 
# 883
{ 
# 884
return (((flags) & ((512 - 1) << 3)) >> 3) + 1; 
# 885
} 
# 888
inline size_t Mat::step1(int i) const 
# 889
{ 
# 890
return (((step).p)[i]) / this->elemSize1(); 
# 891
} 
# 894
inline bool Mat::empty() const 
# 895
{ 
# 896
return (((data) == (0)) || (this->total() == (0))) || ((dims) == 0); 
# 897
} 
# 900
inline size_t Mat::total() const 
# 901
{ 
# 902
if ((dims) <= 2) { 
# 903
return ((size_t)(rows)) * (cols); }  
# 904
size_t p = (1); 
# 905
for (int i = 0; i < (dims); i++) { 
# 906
p *= ((size)[i]); }  
# 907
return p; 
# 908
} 
# 911
inline size_t Mat::total(int startDim, int endDim) const 
# 912
{ 
# 913
if (!(!((0 <= startDim) && (startDim <= endDim)))) { ; } else { cv::error(cv::Error::StsAssert, "0 <= startDim && startDim <= endDim", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 913); }  
# 914
size_t p = (1); 
# 915
int endDim_ = (endDim <= (dims)) ? endDim : (dims); 
# 916
for (int i = startDim; i < endDim_; i++) { 
# 917
p *= ((size)[i]); }  
# 918
return p; 
# 919
} 
# 922
inline uchar *Mat::ptr(int y) 
# 923
{ 
# 924
; 
# 925
return (data) + ((((step).p)[0]) * y); 
# 926
} 
# 929
inline const uchar *Mat::ptr(int y) const 
# 930
{ 
# 931
; 
# 932
return (data) + ((((step).p)[0]) * y); 
# 933
} 
# 935
template< class _Tp> inline _Tp *
# 936
Mat::ptr(int y) 
# 937
{ 
# 938
; 
# 939
return (_Tp *)((data) + ((((step).p)[0]) * y)); 
# 940
} 
# 942
template< class _Tp> inline const _Tp *
# 943
Mat::ptr(int y) const 
# 944
{ 
# 945
; 
# 946
return (const _Tp *)((data) + ((((step).p)[0]) * y)); 
# 947
} 
# 950
inline uchar *Mat::ptr(int i0, int i1) 
# 951
{ 
# 952
; 
# 953
; 
# 954
; 
# 955
; 
# 956
return ((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1])); 
# 957
} 
# 960
inline const uchar *Mat::ptr(int i0, int i1) const 
# 961
{ 
# 962
; 
# 963
; 
# 964
; 
# 965
; 
# 966
return ((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1])); 
# 967
} 
# 969
template< class _Tp> inline _Tp *
# 970
Mat::ptr(int i0, int i1) 
# 971
{ 
# 972
; 
# 973
; 
# 974
; 
# 975
; 
# 976
return (_Tp *)(((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))); 
# 977
} 
# 979
template< class _Tp> inline const _Tp *
# 980
Mat::ptr(int i0, int i1) const 
# 981
{ 
# 982
; 
# 983
; 
# 984
; 
# 985
; 
# 986
return (const _Tp *)(((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))); 
# 987
} 
# 990
inline uchar *Mat::ptr(int i0, int i1, int i2) 
# 991
{ 
# 992
; 
# 993
; 
# 994
; 
# 995
; 
# 996
; 
# 997
return (((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))) + (i2 * (((step).p)[2])); 
# 998
} 
# 1001
inline const uchar *Mat::ptr(int i0, int i1, int i2) const 
# 1002
{ 
# 1003
; 
# 1004
; 
# 1005
; 
# 1006
; 
# 1007
; 
# 1008
return (((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))) + (i2 * (((step).p)[2])); 
# 1009
} 
# 1011
template< class _Tp> inline _Tp *
# 1012
Mat::ptr(int i0, int i1, int i2) 
# 1013
{ 
# 1014
; 
# 1015
; 
# 1016
; 
# 1017
; 
# 1018
; 
# 1019
return (_Tp *)((((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))) + (i2 * (((step).p)[2]))); 
# 1020
} 
# 1022
template< class _Tp> inline const _Tp *
# 1023
Mat::ptr(int i0, int i1, int i2) const 
# 1024
{ 
# 1025
; 
# 1026
; 
# 1027
; 
# 1028
; 
# 1029
; 
# 1030
return (const _Tp *)((((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))) + (i2 * (((step).p)[2]))); 
# 1031
} 
# 1034
inline uchar *Mat::ptr(const int *idx) 
# 1035
{ 
# 1036
int i, d = dims; 
# 1037
uchar *p = data; 
# 1038
; 
# 1039
for (i = 0; i < d; i++) 
# 1040
{ 
# 1041
; 
# 1042
p += ((idx[i]) * (((step).p)[i])); 
# 1043
}  
# 1044
return p; 
# 1045
} 
# 1048
inline const uchar *Mat::ptr(const int *idx) const 
# 1049
{ 
# 1050
int i, d = dims; 
# 1051
uchar *p = data; 
# 1052
; 
# 1053
for (i = 0; i < d; i++) 
# 1054
{ 
# 1055
; 
# 1056
p += ((idx[i]) * (((step).p)[i])); 
# 1057
}  
# 1058
return p; 
# 1059
} 
# 1061
template< class _Tp> inline _Tp *
# 1062
Mat::ptr(const int *idx) 
# 1063
{ 
# 1064
int i, d = dims; 
# 1065
uchar *p = data; 
# 1066
; 
# 1067
for (i = 0; i < d; i++) 
# 1068
{ 
# 1069
; 
# 1070
p += ((idx[i]) * (((step).p)[i])); 
# 1071
}  
# 1072
return (_Tp *)p; 
# 1073
} 
# 1075
template< class _Tp> inline const _Tp *
# 1076
Mat::ptr(const int *idx) const 
# 1077
{ 
# 1078
int i, d = dims; 
# 1079
uchar *p = data; 
# 1080
; 
# 1081
for (i = 0; i < d; i++) 
# 1082
{ 
# 1083
; 
# 1084
p += ((idx[i]) * (((step).p)[i])); 
# 1085
}  
# 1086
return (const _Tp *)p; 
# 1087
} 
# 1089
template< class _Tp> inline _Tp &
# 1090
Mat::at(int i0, int i1) 
# 1091
{ 
# 1092
; 
# 1093
; 
# 1094
; 
# 1095
; 
# 1096
; 
# 1097
return ((_Tp *)((data) + ((((step).p)[0]) * i0)))[i1]; 
# 1098
} 
# 1100
template< class _Tp> inline const _Tp &
# 1101
Mat::at(int i0, int i1) const 
# 1102
{ 
# 1103
; 
# 1104
; 
# 1105
; 
# 1106
; 
# 1107
; 
# 1108
return ((const _Tp *)((data) + ((((step).p)[0]) * i0)))[i1]; 
# 1109
} 
# 1111
template< class _Tp> inline _Tp &
# 1112
Mat::at(Point pt) 
# 1113
{ 
# 1114
; 
# 1115
; 
# 1116
; 
# 1117
; 
# 1118
; 
# 1119
return ((_Tp *)((data) + ((((step).p)[0]) * (pt.y))))[pt.x]; 
# 1120
} 
# 1122
template< class _Tp> inline const _Tp &
# 1123
Mat::at(Point pt) const 
# 1124
{ 
# 1125
; 
# 1126
; 
# 1127
; 
# 1128
; 
# 1129
; 
# 1130
return ((const _Tp *)((data) + ((((step).p)[0]) * (pt.y))))[pt.x]; 
# 1131
} 
# 1133
template< class _Tp> inline _Tp &
# 1134
Mat::at(int i0) 
# 1135
{ 
# 1136
; 
# 1137
; 
# 1138
; 
# 1139
; 
# 1140
if (this->isContinuous() || ((((size).p)[0]) == 1)) { 
# 1141
return ((_Tp *)(data))[i0]; }  
# 1142
if ((((size).p)[1]) == 1) { 
# 1143
return *((_Tp *)((data) + ((((step).p)[0]) * i0))); }  
# 1144
int i = i0 / (cols), j = i0 - (i * (cols)); 
# 1145
return ((_Tp *)((data) + ((((step).p)[0]) * i)))[j]; 
# 1146
} 
# 1148
template< class _Tp> inline const _Tp &
# 1149
Mat::at(int i0) const 
# 1150
{ 
# 1151
; 
# 1152
; 
# 1153
; 
# 1154
; 
# 1155
if (this->isContinuous() || ((((size).p)[0]) == 1)) { 
# 1156
return ((const _Tp *)(data))[i0]; }  
# 1157
if ((((size).p)[1]) == 1) { 
# 1158
return *((const _Tp *)((data) + ((((step).p)[0]) * i0))); }  
# 1159
int i = i0 / (cols), j = i0 - (i * (cols)); 
# 1160
return ((const _Tp *)((data) + ((((step).p)[0]) * i)))[j]; 
# 1161
} 
# 1163
template< class _Tp> inline _Tp &
# 1164
Mat::at(int i0, int i1, int i2) 
# 1165
{ 
# 1166
; 
# 1167
return *((_Tp *)this->ptr(i0, i1, i2)); 
# 1168
} 
# 1170
template< class _Tp> inline const _Tp &
# 1171
Mat::at(int i0, int i1, int i2) const 
# 1172
{ 
# 1173
; 
# 1174
return *((const _Tp *)this->ptr(i0, i1, i2)); 
# 1175
} 
# 1177
template< class _Tp> inline _Tp &
# 1178
Mat::at(const int *idx) 
# 1179
{ 
# 1180
; 
# 1181
return *((_Tp *)this->ptr(idx)); 
# 1182
} 
# 1184
template< class _Tp> inline const _Tp &
# 1185
Mat::at(const int *idx) const 
# 1186
{ 
# 1187
; 
# 1188
return *((const _Tp *)this->ptr(idx)); 
# 1189
} 
# 1191
template< class _Tp, int n> inline _Tp &
# 1192
Mat::at(const Vec< int, n>  &idx) 
# 1193
{ 
# 1194
; 
# 1195
return *((_Tp *)ptr((idx.val))); 
# 1196
} 
# 1198
template< class _Tp, int n> inline const _Tp &
# 1199
Mat::at(const Vec< int, n>  &idx) const 
# 1200
{ 
# 1201
; 
# 1202
return *((const _Tp *)ptr((idx.val))); 
# 1203
} 
# 1205
template< class _Tp> inline MatConstIterator_< _Tp>  
# 1206
Mat::begin() const 
# 1207
{ 
# 1208
; 
# 1209
return ((MatConstIterator_< _Tp> )((const Mat_< _Tp>  *)this)); 
# 1210
} 
# 1212
template< class _Tp> inline MatConstIterator_< _Tp>  
# 1213
Mat::end() const 
# 1214
{ 
# 1215
; 
# 1216
MatConstIterator_< _Tp>  it((const Mat_< _Tp>  *)this); 
# 1217
it += this->total(); 
# 1218
return it; 
# 1219
} 
# 1221
template< class _Tp> inline MatIterator_< _Tp>  
# 1222
Mat::begin() 
# 1223
{ 
# 1224
; 
# 1225
return ((MatIterator_< _Tp> )((Mat_< _Tp>  *)this)); 
# 1226
} 
# 1228
template< class _Tp> inline MatIterator_< _Tp>  
# 1229
Mat::end() 
# 1230
{ 
# 1231
; 
# 1232
MatIterator_< _Tp>  it((Mat_< _Tp>  *)this); 
# 1233
it += this->total(); 
# 1234
return it; 
# 1235
} 
# 1237
template< class _Tp, class Functor> inline void 
# 1238
Mat::forEach(const Functor &operation) { 
# 1239
(this->template forEach_impl< _Tp> (operation)); 
# 1240
} 
# 1242
template< class _Tp, class Functor> inline void 
# 1243
Mat::forEach(const Functor &operation) const { 
# 1245
((const_cast< Mat *>(this))->template forEach< _Tp> (operation)); 
# 1246
} 
# 1248
template< class _Tp> inline 
# 1249
Mat::operator std::vector< _Tp> () const 
# 1250
{ 
# 1251
std::vector< _Tp>  v; 
# 1252
copyTo(v); 
# 1253
return v; 
# 1254
} 
# 1257
template< class _Tp, std::size_t _Nm> inline 
# 1258
Mat::operator std::array< _Tp, _Nm> () const 
# 1259
{ 
# 1260
std::array< _Tp, _Nm>  v; 
# 1261
copyTo(v); 
# 1262
return v; 
# 1263
} 
# 1266
template< class _Tp, int n> inline 
# 1267
Mat::operator Vec< _Tp, n> () const 
# 1268
{ 
# 1269
if (!(!((data) && ((dims) <= 2) && (((rows) == 1) || ((cols) == 1)) && ((((rows) + (cols)) - 1) == n) && (this->channels() == 1)))) { ; } else { cv::error(cv::Error::StsAssert, "data && dims <= 2 && (rows == 1 || cols == 1) && rows + cols - 1 == n && channels() == 1", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 1270); }  
# 1272 "/usr/include/opencv2/core/mat.inl.hpp" 3
if (this->isContinuous() && (this->type() == traits::Type< _Tp> ::value)) { 
# 1273
return ((Vec< _Tp, n> )((_Tp *)(data))); }  
# 1274
Vec< _Tp, n>  v; 
# 1275
Mat tmp(rows, cols, traits::Type< _Tp> ::value, (v.val)); 
# 1276
this->convertTo(tmp, tmp.type()); 
# 1277
return v; 
# 1278
} 
# 1280
template< class _Tp, int m, int n> inline 
# 1281
Mat::operator Matx< _Tp, m, n> () const 
# 1282
{ 
# 1283
if (!(!((data) && ((dims) <= 2) && ((rows) == m) && ((cols) == n) && (this->channels() == 1)))) { ; } else { cv::error(cv::Error::StsAssert, "data && dims <= 2 && rows == m && cols == n && channels() == 1", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 1283); }  
# 1285
if (this->isContinuous() && (this->type() == traits::Type< _Tp> ::value)) { 
# 1286
return ((Matx< _Tp, m, n> )((_Tp *)(data))); }  
# 1287
Matx< _Tp, m, n>  mtx; 
# 1288
Mat tmp(rows, cols, traits::Type< _Tp> ::value, (mtx.val)); 
# 1289
this->convertTo(tmp, tmp.type()); 
# 1290
return mtx; 
# 1291
} 
# 1293
template< class _Tp> inline void 
# 1294
Mat::push_back(const _Tp &elem) 
# 1295
{ 
# 1296
if (!(data)) 
# 1297
{ 
# 1298
((*this) = (Mat(1, 1, traits::Type< _Tp> ::value, (void *)(&elem)).clone())); 
# 1299
return; 
# 1300
}  
# 1301
if (!(!((traits::Type< _Tp> ::value == this->type()) && ((cols) == 1)))) { ; } else { cv::error(cv::Error::StsAssert, "traits::Type<_Tp>::value == type() && cols == 1", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 1302); }  
# 1303 "/usr/include/opencv2/core/mat.inl.hpp" 3
const uchar *tmp = (dataend) + (step)[0]; 
# 1304
if ((!this->isSubmatrix()) && this->isContinuous() && (tmp <= (datalimit))) 
# 1305
{ 
# 1306
(*((_Tp *)((data) + (((((size).p)[0])++) * (((step).p)[0]))))) = elem; 
# 1307
(dataend) = tmp; 
# 1308
} else { 
# 1310
this->push_back_(&elem); }  
# 1311
} 
# 1313
template< class _Tp> inline void 
# 1314
Mat::push_back(const Mat_< _Tp>  &m) 
# 1315
{ 
# 1316
this->push_back((const Mat &)m); 
# 1317
} 
# 1320
template<> inline void Mat::push_back(const MatExpr &expr) 
# 1321
{ 
# 1322
this->push_back(static_cast< Mat>(expr)); 
# 1323
} 
# 1326
template< class _Tp> inline void 
# 1327
Mat::push_back(const std::vector< _Tp>  &v) 
# 1328
{ 
# 1329
this->push_back(((Mat)(v))); 
# 1330
} 
# 1335
inline Mat::Mat(Mat &&m) : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data), datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator), u(m.u), size(&(rows)) 
# 1339
{ 
# 1340
if ((m.dims) <= 2) 
# 1341
{ 
# 1342
(step)[0] = (m.step)[0]; 
# 1343
(step)[1] = (m.step)[1]; 
# 1344
} else 
# 1346
{ 
# 1347
; 
# 1348
((step).p) = ((m.step).p); 
# 1349
((size).p) = ((m.size).p); 
# 1350
((m.step).p) = ((m.step).buf); 
# 1351
((m.size).p) = (&(m.rows)); 
# 1352
}  
# 1353
(m.flags) = (MAGIC_VAL); (m.dims) = ((m.rows) = ((m.cols) = 0)); 
# 1354
(m.data) = (__null); (m.datastart) = (__null); (m.dataend) = (__null); (m.datalimit) = (__null); 
# 1355
(m.allocator) = (__null); 
# 1356
(m.u) = (__null); 
# 1357
} 
# 1360
inline Mat &Mat::operator=(Mat &&m) 
# 1361
{ 
# 1362
if (this == (&m)) { 
# 1363
return *this; }  
# 1365
this->release(); 
# 1366
(flags) = (m.flags); (dims) = (m.dims); (rows) = (m.rows); (cols) = (m.cols); (data) = (m.data); 
# 1367
(datastart) = (m.datastart); (dataend) = (m.dataend); (datalimit) = (m.datalimit); (allocator) = (m.allocator); 
# 1368
(u) = (m.u); 
# 1369
if (((step).p) != ((step).buf)) 
# 1370
{ 
# 1371
fastFree((step).p); 
# 1372
((step).p) = ((step).buf); 
# 1373
((size).p) = (&(rows)); 
# 1374
}  
# 1375
if ((m.dims) <= 2) 
# 1376
{ 
# 1377
(step)[0] = (m.step)[0]; 
# 1378
(step)[1] = (m.step)[1]; 
# 1379
} else 
# 1381
{ 
# 1382
; 
# 1383
((step).p) = ((m.step).p); 
# 1384
((size).p) = ((m.size).p); 
# 1385
((m.step).p) = ((m.step).buf); 
# 1386
((m.size).p) = (&(m.rows)); 
# 1387
}  
# 1388
(m.flags) = (MAGIC_VAL); (m.dims) = ((m.rows) = ((m.cols) = 0)); 
# 1389
(m.data) = (__null); (m.datastart) = (__null); (m.dataend) = (__null); (m.datalimit) = (__null); 
# 1390
(m.allocator) = (__null); 
# 1391
(m.u) = (__null); 
# 1392
return *this; 
# 1393
} 
# 1401
inline MatSize::MatSize(int *_p) : p(_p) 
# 1402
{ } 
# 1405
inline Size MatSize::operator()() const 
# 1406
{ 
# 1407
; 
# 1408
return Size((p)[1], (p)[0]); 
# 1409
} 
# 1412
inline const int &MatSize::operator[](int i) const 
# 1413
{ 
# 1414
return (p)[i]; 
# 1415
} 
# 1418
inline int &MatSize::operator[](int i) 
# 1419
{ 
# 1420
return (p)[i]; 
# 1421
} 
# 1424
inline MatSize::operator const int *() const 
# 1425
{ 
# 1426
return p; 
# 1427
} 
# 1430
inline bool MatSize::operator==(const MatSize &sz) const 
# 1431
{ 
# 1432
int d = (p)[-1]; 
# 1433
int dsz = (sz.p)[-1]; 
# 1434
if (d != dsz) { 
# 1435
return false; }  
# 1436
if (d == 2) { 
# 1437
return (((p)[0]) == ((sz.p)[0])) && (((p)[1]) == ((sz.p)[1])); }  
# 1439
for (int i = 0; i < d; i++) { 
# 1440
if (((p)[i]) != ((sz.p)[i])) { 
# 1441
return false; }  }  
# 1442
return true; 
# 1443
} 
# 1446
inline bool MatSize::operator!=(const MatSize &sz) const 
# 1447
{ 
# 1448
return !((*this) == sz); 
# 1449
} 
# 1456
inline MatStep::MatStep() 
# 1457
{ 
# 1458
(p) = (buf); ((p)[0]) = (((p)[1]) = (0)); 
# 1459
} 
# 1462
inline MatStep::MatStep(size_t s) 
# 1463
{ 
# 1464
(p) = (buf); ((p)[0]) = s; ((p)[1]) = (0); 
# 1465
} 
# 1468
inline const size_t &MatStep::operator[](int i) const 
# 1469
{ 
# 1470
return (p)[i]; 
# 1471
} 
# 1474
inline size_t &MatStep::operator[](int i) 
# 1475
{ 
# 1476
return (p)[i]; 
# 1477
} 
# 1479
inline MatStep::operator size_t() const 
# 1480
{ 
# 1481
; 
# 1482
return (buf)[0]; 
# 1483
} 
# 1485
inline MatStep &MatStep::operator=(size_t s) 
# 1486
{ 
# 1487
; 
# 1488
((buf)[0]) = s; 
# 1489
return *this; 
# 1490
} 
# 1496
template< class _Tp> inline 
# 1497
Mat_< _Tp> ::Mat_() : Mat() 
# 1499
{ 
# 1500
(flags) = (((flags) & (~(((1 << 3) * 512) - 1))) | traits::Type< _Tp> ::value); 
# 1501
} 
# 1503
template< class _Tp> inline 
# 1504
Mat_< _Tp> ::Mat_(int _rows, int _cols) : Mat(_rows, _cols, traits::Type< _Tp> ::value) 
# 1506
{ 
# 1507
} 
# 1509
template< class _Tp> inline 
# 1510
Mat_< _Tp> ::Mat_(int _rows, int _cols, const _Tp &value) : Mat(_rows, _cols, traits::Type< _Tp> ::value) 
# 1512
{ 
# 1513
(*this) = value; 
# 1514
} 
# 1516
template< class _Tp> inline 
# 1517
Mat_< _Tp> ::Mat_(Size _sz) : Mat(_sz.height, _sz.width, traits::Type< _Tp> ::value) 
# 1519
{ } 
# 1521
template< class _Tp> inline 
# 1522
Mat_< _Tp> ::Mat_(Size _sz, const _Tp &value) : Mat(_sz.height, _sz.width, traits::Type< _Tp> ::value) 
# 1524
{ 
# 1525
(*this) = value; 
# 1526
} 
# 1528
template< class _Tp> inline 
# 1529
Mat_< _Tp> ::Mat_(int _dims, const int *_sz) : Mat(_dims, _sz, traits::Type< _Tp> ::value) 
# 1531
{ } 
# 1533
template< class _Tp> inline 
# 1534
Mat_< _Tp> ::Mat_(int _dims, const int *_sz, const _Tp &_s) : Mat(_dims, _sz, traits::Type< _Tp> ::value, ((Scalar)(_s))) 
# 1536
{ } 
# 1538
template< class _Tp> inline 
# 1539
Mat_< _Tp> ::Mat_(int _dims, const int *_sz, _Tp *_data, const size_t *_steps) : Mat(_dims, _sz, traits::Type< _Tp> ::value, _data, _steps) 
# 1541
{ } 
# 1543
template< class _Tp> inline 
# 1544
Mat_< _Tp> ::Mat_(const Mat_ &m, const Range *ranges) : Mat(m, ranges) 
# 1546
{ } 
# 1548
template< class _Tp> inline 
# 1549
Mat_< _Tp> ::Mat_(const Mat_ &m, const std::vector< Range>  &ranges) : Mat(m, ranges) 
# 1551
{ } 
# 1553
template< class _Tp> inline 
# 1554
Mat_< _Tp> ::Mat_(const Mat &m) : Mat() 
# 1556
{ 
# 1557
(flags) = (((flags) & (~(((1 << 3) * 512) - 1))) | traits::Type< _Tp> ::value); 
# 1558
(*this) = m; 
# 1559
} 
# 1561
template< class _Tp> inline 
# 1562
Mat_< _Tp> ::Mat_(const Mat_ &m) : Mat(m) 
# 1564
{ } 
# 1566
template< class _Tp> inline 
# 1567
Mat_< _Tp> ::Mat_(int _rows, int _cols, _Tp *_data, size_t steps) : Mat(_rows, _cols, traits::Type< _Tp> ::value, _data, steps) 
# 1569
{ } 
# 1571
template< class _Tp> inline 
# 1572
Mat_< _Tp> ::Mat_(const Mat_ &m, const Range &_rowRange, const Range &_colRange) : Mat(m, _rowRange, _colRange) 
# 1574
{ } 
# 1576
template< class _Tp> inline 
# 1577
Mat_< _Tp> ::Mat_(const Mat_ &m, const Rect &roi) : Mat(m, roi) 
# 1579
{ } 
# 1581
template< class _Tp> template< int n> inline 
# 1582
Mat_< _Tp> ::Mat_(const Vec< typename DataType< _Tp> ::channel_type, n>  &vec, bool copyData) : Mat(n / DataType< _Tp> ::channels, 1, traits::Type< _Tp> ::value, (void *)(&vec)) 
# 1584
{ 
# 1585
if (!(!((n % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "n%DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 1585); }  
# 1586
if (copyData) { 
# 1587
(*this) = clone(); }  
# 1588
} 
# 1590
template< class _Tp> template< int m, int n> inline 
# 1591
Mat_< _Tp> ::Mat_(const Matx< typename DataType< _Tp> ::channel_type, m, n>  &M, bool copyData) : Mat(m, n / DataType< _Tp> ::channels, traits::Type< _Tp> ::value, (void *)(&M)) 
# 1593
{ 
# 1594
if (!(!((n % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "n % DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 1594); }  
# 1595
if (copyData) { 
# 1596
(*this) = clone(); }  
# 1597
} 
# 1599
template< class _Tp> inline 
# 1600
Mat_< _Tp> ::Mat_(const Point_< typename DataType< _Tp> ::channel_type>  &pt, bool copyData) : Mat(2 / DataType< _Tp> ::channels, 1, traits::Type< _Tp> ::value, (void *)(&pt)) 
# 1602
{ 
# 1603
if (!(!((2 % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "2 % DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 1603); }  
# 1604
if (copyData) { 
# 1605
(*this) = clone(); }  
# 1606
} 
# 1608
template< class _Tp> inline 
# 1609
Mat_< _Tp> ::Mat_(const Point3_< typename DataType< _Tp> ::channel_type>  &pt, bool copyData) : Mat(3 / DataType< _Tp> ::channels, 1, traits::Type< _Tp> ::value, (void *)(&pt)) 
# 1611
{ 
# 1612
if (!(!((3 % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "3 % DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 1612); }  
# 1613
if (copyData) { 
# 1614
(*this) = clone(); }  
# 1615
} 
# 1617
template< class _Tp> inline 
# 1618
Mat_< _Tp> ::Mat_(const MatCommaInitializer_< _Tp>  &commaInitializer) : Mat(commaInitializer) 
# 1620
{ } 
# 1622
template< class _Tp> inline 
# 1623
Mat_< _Tp> ::Mat_(const std::vector< _Tp>  &vec, bool copyData) : Mat(vec, copyData) 
# 1625
{ } 
# 1628
template< class _Tp> inline 
# 1629
Mat_< _Tp> ::Mat_(std::initializer_list< _Tp>  list) : Mat(list) 
# 1631
{ } 
# 1635
template< class _Tp> template< std::size_t _Nm> inline 
# 1636
Mat_< _Tp> ::Mat_(const std::array< _Tp, _Nm>  &arr, bool copyData) : Mat(arr, copyData) 
# 1638
{ } 
# 1641
template< class _Tp> inline Mat_< _Tp>  &
# 1642
Mat_< _Tp> ::operator=(const Mat &m) 
# 1643
{ 
# 1644
if (traits::Type< _Tp> ::value == m.type()) 
# 1645
{ 
# 1646
this->Mat::operator=(m); 
# 1647
return *this; 
# 1648
}  
# 1649
if (traits::Depth< _Tp> ::value == m.depth()) 
# 1650
{ 
# 1651
return (*this) = (m.reshape(DataType< _Tp> ::channels, m.dims, 0)); 
# 1652
}  
# 1653
; 
# 1654
m.convertTo(*this, type()); 
# 1655
return *this; 
# 1656
} 
# 1658
template< class _Tp> inline Mat_< _Tp>  &
# 1659
Mat_< _Tp> ::operator=(const Mat_ &m) 
# 1660
{ 
# 1661
Mat::operator=(m); 
# 1662
return *this; 
# 1663
} 
# 1665
template< class _Tp> inline Mat_< _Tp>  &
# 1666
Mat_< _Tp> ::operator=(const _Tp &s) 
# 1667
{ 
# 1668
typedef typename DataType< _Tp> ::vec_type VT; 
# 1669
this->Mat::operator=(((Scalar)((const VT &)s))); 
# 1670
return *this; 
# 1671
} 
# 1673
template< class _Tp> inline void 
# 1674
Mat_< _Tp> ::create(int _rows, int _cols) 
# 1675
{ 
# 1676
Mat::create(_rows, _cols, traits::Type< _Tp> ::value); 
# 1677
} 
# 1679
template< class _Tp> inline void 
# 1680
Mat_< _Tp> ::create(Size _sz) 
# 1681
{ 
# 1682
Mat::create(_sz, traits::Type< _Tp> ::value); 
# 1683
} 
# 1685
template< class _Tp> inline void 
# 1686
Mat_< _Tp> ::create(int _dims, const int *_sz) 
# 1687
{ 
# 1688
Mat::create(_dims, _sz, traits::Type< _Tp> ::value); 
# 1689
} 
# 1691
template< class _Tp> inline void 
# 1692
Mat_< _Tp> ::release() 
# 1693
{ 
# 1694
this->Mat::release(); 
# 1698
} 
# 1700
template< class _Tp> inline Mat_< _Tp>  
# 1701
Mat_< _Tp> ::cross(const Mat_ &m) const 
# 1702
{ 
# 1703
return ((Mat_)(this->Mat::cross(m))); 
# 1704
} 
# 1706
template< class _Tp> template< class T2> inline 
# 1707
Mat_< _Tp> ::operator Mat_< T2> () const 
# 1708
{ 
# 1709
return ((cv::Mat_< T2> )(*this)); 
# 1710
} 
# 1712
template< class _Tp> inline Mat_< _Tp>  
# 1713
Mat_< _Tp> ::row(int y) const 
# 1714
{ 
# 1715
return Mat_(*this, Range(y, y + 1), Range::all()); 
# 1716
} 
# 1718
template< class _Tp> inline Mat_< _Tp>  
# 1719
Mat_< _Tp> ::col(int x) const 
# 1720
{ 
# 1721
return Mat_(*this, Range::all(), Range(x, x + 1)); 
# 1722
} 
# 1724
template< class _Tp> inline Mat_< _Tp>  
# 1725
Mat_< _Tp> ::diag(int d) const 
# 1726
{ 
# 1727
return ((Mat_)(this->Mat::diag(d))); 
# 1728
} 
# 1730
template< class _Tp> inline Mat_< _Tp>  
# 1731
Mat_< _Tp> ::clone() const 
# 1732
{ 
# 1733
return ((Mat_)(this->Mat::clone())); 
# 1734
} 
# 1736
template< class _Tp> inline size_t 
# 1737
Mat_< _Tp> ::elemSize() const 
# 1738
{ 
# 1739
; 
# 1740
return sizeof(_Tp); 
# 1741
} 
# 1743
template< class _Tp> inline size_t 
# 1744
Mat_< _Tp> ::elemSize1() const 
# 1745
{ 
# 1746
; 
# 1747
return sizeof(_Tp) / DataType< _Tp> ::channels; 
# 1748
} 
# 1750
template< class _Tp> inline int 
# 1751
Mat_< _Tp> ::type() const 
# 1752
{ 
# 1753
; 
# 1754
return traits::Type< _Tp> ::value; 
# 1755
} 
# 1757
template< class _Tp> inline int 
# 1758
Mat_< _Tp> ::depth() const 
# 1759
{ 
# 1760
; 
# 1761
return traits::Depth< _Tp> ::value; 
# 1762
} 
# 1764
template< class _Tp> inline int 
# 1765
Mat_< _Tp> ::channels() const 
# 1766
{ 
# 1767
; 
# 1768
return DataType< _Tp> ::channels; 
# 1769
} 
# 1771
template< class _Tp> inline size_t 
# 1772
Mat_< _Tp> ::stepT(int i) const 
# 1773
{ 
# 1774
return (((step).p)[i]) / elemSize(); 
# 1775
} 
# 1777
template< class _Tp> inline size_t 
# 1778
Mat_< _Tp> ::step1(int i) const 
# 1779
{ 
# 1780
return (((step).p)[i]) / elemSize1(); 
# 1781
} 
# 1783
template< class _Tp> inline Mat_< _Tp>  &
# 1784
Mat_< _Tp> ::adjustROI(int dtop, int dbottom, int dleft, int dright) 
# 1785
{ 
# 1786
return (Mat_ &)this->Mat::adjustROI(dtop, dbottom, dleft, dright); 
# 1787
} 
# 1789
template< class _Tp> inline Mat_< _Tp>  
# 1790
Mat_< _Tp> ::operator()(const Range &_rowRange, const Range &_colRange) const 
# 1791
{ 
# 1792
return Mat_(*this, _rowRange, _colRange); 
# 1793
} 
# 1795
template< class _Tp> inline Mat_< _Tp>  
# 1796
Mat_< _Tp> ::operator()(const Rect &roi) const 
# 1797
{ 
# 1798
return Mat_(*this, roi); 
# 1799
} 
# 1801
template< class _Tp> inline Mat_< _Tp>  
# 1802
Mat_< _Tp> ::operator()(const Range *ranges) const 
# 1803
{ 
# 1804
return Mat_(*this, ranges); 
# 1805
} 
# 1807
template< class _Tp> inline Mat_< _Tp>  
# 1808
Mat_< _Tp> ::operator()(const std::vector< Range>  &ranges) const 
# 1809
{ 
# 1810
return Mat_(*this, ranges); 
# 1811
} 
# 1813
template< class _Tp> inline _Tp *
# 1814
Mat_< _Tp> ::operator[](int y) 
# 1815
{ 
# 1816
; 
# 1817
return (_Tp *)((data) + (y * (((step).p)[0]))); 
# 1818
} 
# 1820
template< class _Tp> inline const _Tp *
# 1821
Mat_< _Tp> ::operator[](int y) const 
# 1822
{ 
# 1823
; 
# 1824
return (const _Tp *)((data) + (y * (((step).p)[0]))); 
# 1825
} 
# 1827
template< class _Tp> inline _Tp &
# 1828
Mat_< _Tp> ::operator()(int i0, int i1) 
# 1829
{ 
# 1830
; 
# 1831
; 
# 1832
; 
# 1833
; 
# 1834
; 
# 1835
return ((_Tp *)((data) + ((((step).p)[0]) * i0)))[i1]; 
# 1836
} 
# 1838
template< class _Tp> inline const _Tp &
# 1839
Mat_< _Tp> ::operator()(int i0, int i1) const 
# 1840
{ 
# 1841
; 
# 1842
; 
# 1843
; 
# 1844
; 
# 1845
; 
# 1846
return ((const _Tp *)((data) + ((((step).p)[0]) * i0)))[i1]; 
# 1847
} 
# 1849
template< class _Tp> inline _Tp &
# 1850
Mat_< _Tp> ::operator()(Point pt) 
# 1851
{ 
# 1852
; 
# 1853
; 
# 1854
; 
# 1855
; 
# 1856
; 
# 1857
return ((_Tp *)((data) + ((((step).p)[0]) * (pt.y))))[pt.x]; 
# 1858
} 
# 1860
template< class _Tp> inline const _Tp &
# 1861
Mat_< _Tp> ::operator()(Point pt) const 
# 1862
{ 
# 1863
; 
# 1864
; 
# 1865
; 
# 1866
; 
# 1867
; 
# 1868
return ((const _Tp *)((data) + ((((step).p)[0]) * (pt.y))))[pt.x]; 
# 1869
} 
# 1871
template< class _Tp> inline _Tp &
# 1872
Mat_< _Tp> ::operator()(const int *idx) 
# 1873
{ 
# 1874
return Mat::template at< _Tp> (idx); 
# 1875
} 
# 1877
template< class _Tp> inline const _Tp &
# 1878
Mat_< _Tp> ::operator()(const int *idx) const 
# 1879
{ 
# 1880
return Mat::template at< _Tp> (idx); 
# 1881
} 
# 1883
template< class _Tp> template< int n> inline _Tp &
# 1884
Mat_< _Tp> ::operator()(const Vec< int, n>  &idx) 
# 1885
{ 
# 1886
return Mat::template at< _Tp> (idx); 
# 1887
} 
# 1889
template< class _Tp> template< int n> inline const _Tp &
# 1890
Mat_< _Tp> ::operator()(const Vec< int, n>  &idx) const 
# 1891
{ 
# 1892
return Mat::template at< _Tp> (idx); 
# 1893
} 
# 1895
template< class _Tp> inline _Tp &
# 1896
Mat_< _Tp> ::operator()(int i0) 
# 1897
{ 
# 1898
return (this->template at< _Tp> (i0)); 
# 1899
} 
# 1901
template< class _Tp> inline const _Tp &
# 1902
Mat_< _Tp> ::operator()(int i0) const 
# 1903
{ 
# 1904
return (this->template at< _Tp> (i0)); 
# 1905
} 
# 1907
template< class _Tp> inline _Tp &
# 1908
Mat_< _Tp> ::operator()(int i0, int i1, int i2) 
# 1909
{ 
# 1910
return (this->template at< _Tp> (i0, i1, i2)); 
# 1911
} 
# 1913
template< class _Tp> inline const _Tp &
# 1914
Mat_< _Tp> ::operator()(int i0, int i1, int i2) const 
# 1915
{ 
# 1916
return (this->template at< _Tp> (i0, i1, i2)); 
# 1917
} 
# 1919
template< class _Tp> inline 
# 1920
Mat_< _Tp> ::operator std::vector< _Tp> () const 
# 1921
{ 
# 1922
std::vector< _Tp>  v; 
# 1923
copyTo(v); 
# 1924
return v; 
# 1925
} 
# 1928
template< class _Tp> template< std::size_t _Nm> inline 
# 1929
Mat_< _Tp> ::operator std::array< _Tp, _Nm> () const 
# 1930
{ 
# 1931
std::array< _Tp, _Nm>  a; 
# 1932
copyTo(a); 
# 1933
return a; 
# 1934
} 
# 1937
template< class _Tp> template< int n> inline 
# 1938
Mat_< _Tp> ::operator Vec< typename DataType< _Tp> ::channel_type, n> () const 
# 1939
{ 
# 1940
if (!(!((n % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "n % DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 1940); }  
# 1946
return (this->Mat::operator Vec< typename DataType< _Tp> ::channel_type, n> ()); 
# 1948
} 
# 1950
template< class _Tp> template< int m, int n> inline 
# 1951
Mat_< _Tp> ::operator Matx< typename DataType< _Tp> ::channel_type, m, n> () const 
# 1952
{ 
# 1953
if (!(!((n % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "n % DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 1953); }  
# 1960
Matx< typename DataType< _Tp> ::channel_type, m, n>  res = (this->Mat::operator Matx< typename DataType< _Tp> ::channel_type, m, n> ()); 
# 1961
return res; 
# 1963
} 
# 1965
template< class _Tp> inline typename Mat_< _Tp> ::const_iterator 
# 1966
Mat_< _Tp> ::begin() const 
# 1967
{ 
# 1968
return Mat::template begin< _Tp> (); 
# 1969
} 
# 1971
template< class _Tp> inline typename Mat_< _Tp> ::const_iterator 
# 1972
Mat_< _Tp> ::end() const 
# 1973
{ 
# 1974
return Mat::template end< _Tp> (); 
# 1975
} 
# 1977
template< class _Tp> inline typename Mat_< _Tp> ::iterator 
# 1978
Mat_< _Tp> ::begin() 
# 1979
{ 
# 1980
return Mat::template begin< _Tp> (); 
# 1981
} 
# 1983
template< class _Tp> inline typename Mat_< _Tp> ::iterator 
# 1984
Mat_< _Tp> ::end() 
# 1985
{ 
# 1986
return Mat::template end< _Tp> (); 
# 1987
} 
# 1989
template< class _Tp> template< class Functor> inline void 
# 1990
Mat_< _Tp> ::forEach(const Functor &operation) { 
# 1991
Mat::template forEach< _Tp, Functor> (operation); 
# 1992
} 
# 1994
template< class _Tp> template< class Functor> inline void 
# 1995
Mat_< _Tp> ::forEach(const Functor &operation) const { 
# 1996
Mat::template forEach< _Tp, Functor> (operation); 
# 1997
} 
# 2001
template< class _Tp> inline 
# 2002
Mat_< _Tp> ::Mat_(Mat_ &&m) : Mat(m) 
# 2004
{ 
# 2005
} 
# 2007
template< class _Tp> inline Mat_< _Tp>  &
# 2008
Mat_< _Tp> ::operator=(Mat_ &&m) 
# 2009
{ 
# 2010
Mat::operator=(std::move(m)); 
# 2011
return *this; 
# 2012
} 
# 2014
template< class _Tp> inline 
# 2015
Mat_< _Tp> ::Mat_(Mat &&m) : Mat() 
# 2017
{ 
# 2018
(flags) = (((flags) & (~(((1 << 3) * 512) - 1))) | traits::Type< _Tp> ::value); 
# 2019
(*this) = m; 
# 2020
} 
# 2022
template< class _Tp> inline Mat_< _Tp>  &
# 2023
Mat_< _Tp> ::operator=(Mat &&m) 
# 2024
{ 
# 2025
if (traits::Type< _Tp> ::value == m.type()) 
# 2026
{ 
# 2027
this->Mat::operator=((Mat &&)m); 
# 2028
return *this; 
# 2029
}  
# 2030
if (traits::Depth< _Tp> ::value == m.depth()) 
# 2031
{ 
# 2032
this->Mat::operator=((Mat &&)(m.reshape(DataType< _Tp> ::channels, m.dims, 0))); 
# 2033
return *this; 
# 2034
}  
# 2035
; 
# 2036
m.convertTo(*this, type()); 
# 2037
return *this; 
# 2038
} 
# 2040
template< class _Tp> inline 
# 2041
Mat_< _Tp> ::Mat_(MatExpr &&e) : Mat() 
# 2043
{ 
# 2044
(flags) = (((flags) & (~(((1 << 3) * 512) - 1))) | traits::Type< _Tp> ::value); 
# 2045
(*this) = ((Mat)(e)); 
# 2046
} 
# 2053
inline SparseMat::SparseMat() : flags((MAGIC_VAL)), hdr((0)) 
# 2055
{ } 
# 2058
inline SparseMat::SparseMat(int _dims, const int *_sizes, int _type) : flags((MAGIC_VAL)), hdr((0)) 
# 2060
{ 
# 2061
this->create(_dims, _sizes, _type); 
# 2062
} 
# 2065
inline SparseMat::SparseMat(const SparseMat &m) : flags(m.flags), hdr(m.hdr) 
# 2067
{ 
# 2068
this->addref(); 
# 2069
} 
# 2072
inline SparseMat::~SparseMat() 
# 2073
{ 
# 2074
this->release(); 
# 2075
} 
# 2078
inline SparseMat &SparseMat::operator=(const SparseMat &m) 
# 2079
{ 
# 2080
if (this != (&m)) 
# 2081
{ 
# 2082
if (m.hdr) { 
# 2083
(int)__atomic_fetch_add((unsigned *)(&((m.hdr)->refcount)), (unsigned)1, 4); }  
# 2084
this->release(); 
# 2085
(flags) = (m.flags); 
# 2086
(hdr) = (m.hdr); 
# 2087
}  
# 2088
return *this; 
# 2089
} 
# 2092
inline SparseMat &SparseMat::operator=(const Mat &m) 
# 2093
{ 
# 2094
return ((*this) = ((SparseMat)(m))); 
# 2095
} 
# 2098
inline SparseMat SparseMat::clone() const 
# 2099
{ 
# 2100
SparseMat temp; 
# 2101
this->copyTo(temp); 
# 2102
return temp; 
# 2103
} 
# 2106
inline void SparseMat::assignTo(SparseMat &m, int _type) const 
# 2107
{ 
# 2108
if (_type < 0) { 
# 2109
(m = (*this)); } else { 
# 2111
this->convertTo(m, _type); }  
# 2112
} 
# 2115
inline void SparseMat::addref() 
# 2116
{ 
# 2117
if (hdr) { 
# 2118
(int)__atomic_fetch_add((unsigned *)(&((hdr)->refcount)), (unsigned)1, 4); }  
# 2119
} 
# 2122
inline void SparseMat::release() 
# 2123
{ 
# 2124
if ((hdr) && (((int)__atomic_fetch_add((unsigned *)(&((hdr)->refcount)), (unsigned)(-1), 4)) == 1)) { 
# 2125
delete (hdr); }  
# 2126
(hdr) = (0); 
# 2127
} 
# 2130
inline size_t SparseMat::elemSize() const 
# 2131
{ 
# 2132
return ((((flags) & ((512 - 1) << 3)) >> 3) + 1) << ((((((sizeof(size_t) / (4)) + (1)) * (16384)) | (14928)) >> (((flags) & ((1 << 3) - 1)) * 2)) & (3)); 
# 2133
} 
# 2136
inline size_t SparseMat::elemSize1() const 
# 2137
{ 
# 2138
return (((sizeof(size_t) << 28) | (138682897)) >> (((flags) & ((1 << 3) - 1)) * 4)) & (15); 
# 2139
} 
# 2142
inline int SparseMat::type() const 
# 2143
{ 
# 2144
return (flags) & (((1 << 3) * 512) - 1); 
# 2145
} 
# 2148
inline int SparseMat::depth() const 
# 2149
{ 
# 2150
return (flags) & ((1 << 3) - 1); 
# 2151
} 
# 2154
inline int SparseMat::channels() const 
# 2155
{ 
# 2156
return (((flags) & ((512 - 1) << 3)) >> 3) + 1; 
# 2157
} 
# 2160
inline const int *SparseMat::size() const 
# 2161
{ 
# 2162
return (hdr) ? (hdr)->size : (0); 
# 2163
} 
# 2166
inline int SparseMat::size(int i) const 
# 2167
{ 
# 2168
if (hdr) 
# 2169
{ 
# 2170
; 
# 2171
return ((hdr)->size)[i]; 
# 2172
}  
# 2173
return 0; 
# 2174
} 
# 2177
inline int SparseMat::dims() const 
# 2178
{ 
# 2179
return (hdr) ? (hdr)->dims : 0; 
# 2180
} 
# 2183
inline size_t SparseMat::nzcount() const 
# 2184
{ 
# 2185
return (hdr) ? (hdr)->nodeCount : (0); 
# 2186
} 
# 2189
inline size_t SparseMat::hash(int i0) const 
# 2190
{ 
# 2191
return (size_t)i0; 
# 2192
} 
# 2195
inline size_t SparseMat::hash(int i0, int i1) const 
# 2196
{ 
# 2197
return (((size_t)((unsigned)i0)) * (HASH_SCALE)) + ((unsigned)i1); 
# 2198
} 
# 2201
inline size_t SparseMat::hash(int i0, int i1, int i2) const 
# 2202
{ 
# 2203
return (((((size_t)((unsigned)i0)) * (HASH_SCALE)) + ((unsigned)i1)) * (HASH_SCALE)) + ((unsigned)i2); 
# 2204
} 
# 2207
inline size_t SparseMat::hash(const int *idx) const 
# 2208
{ 
# 2209
size_t h = (unsigned)(idx[0]); 
# 2210
if (!(hdr)) { 
# 2211
return 0; }  
# 2212
int d = (hdr)->dims; 
# 2213
for (int i = 1; i < d; i++) { 
# 2214
h = ((h * (HASH_SCALE)) + ((unsigned)(idx[i]))); }  
# 2215
return h; 
# 2216
} 
# 2218
template< class _Tp> inline _Tp &
# 2219
SparseMat::ref(int i0, size_t *hashval) 
# 2220
{ 
# 2221
return *((_Tp *)((SparseMat *)this)->ptr(i0, true, hashval)); 
# 2222
} 
# 2224
template< class _Tp> inline _Tp &
# 2225
SparseMat::ref(int i0, int i1, size_t *hashval) 
# 2226
{ 
# 2227
return *((_Tp *)((SparseMat *)this)->ptr(i0, i1, true, hashval)); 
# 2228
} 
# 2230
template< class _Tp> inline _Tp &
# 2231
SparseMat::ref(int i0, int i1, int i2, size_t *hashval) 
# 2232
{ 
# 2233
return *((_Tp *)((SparseMat *)this)->ptr(i0, i1, i2, true, hashval)); 
# 2234
} 
# 2236
template< class _Tp> inline _Tp &
# 2237
SparseMat::ref(const int *idx, size_t *hashval) 
# 2238
{ 
# 2239
return *((_Tp *)((SparseMat *)this)->ptr(idx, true, hashval)); 
# 2240
} 
# 2242
template< class _Tp> inline _Tp 
# 2243
SparseMat::value(int i0, size_t *hashval) const 
# 2244
{ 
# 2245
const _Tp *p = (const _Tp *)((SparseMat *)this)->ptr(i0, false, hashval); 
# 2246
return (p) ? *p : (_Tp()); 
# 2247
} 
# 2249
template< class _Tp> inline _Tp 
# 2250
SparseMat::value(int i0, int i1, size_t *hashval) const 
# 2251
{ 
# 2252
const _Tp *p = (const _Tp *)((SparseMat *)this)->ptr(i0, i1, false, hashval); 
# 2253
return (p) ? *p : (_Tp()); 
# 2254
} 
# 2256
template< class _Tp> inline _Tp 
# 2257
SparseMat::value(int i0, int i1, int i2, size_t *hashval) const 
# 2258
{ 
# 2259
const _Tp *p = (const _Tp *)((SparseMat *)this)->ptr(i0, i1, i2, false, hashval); 
# 2260
return (p) ? *p : (_Tp()); 
# 2261
} 
# 2263
template< class _Tp> inline _Tp 
# 2264
SparseMat::value(const int *idx, size_t *hashval) const 
# 2265
{ 
# 2266
const _Tp *p = (const _Tp *)((SparseMat *)this)->ptr(idx, false, hashval); 
# 2267
return (p) ? *p : (_Tp()); 
# 2268
} 
# 2270
template< class _Tp> inline const _Tp *
# 2271
SparseMat::find(int i0, size_t *hashval) const 
# 2272
{ 
# 2273
return (const _Tp *)((SparseMat *)this)->ptr(i0, false, hashval); 
# 2274
} 
# 2276
template< class _Tp> inline const _Tp *
# 2277
SparseMat::find(int i0, int i1, size_t *hashval) const 
# 2278
{ 
# 2279
return (const _Tp *)((SparseMat *)this)->ptr(i0, i1, false, hashval); 
# 2280
} 
# 2282
template< class _Tp> inline const _Tp *
# 2283
SparseMat::find(int i0, int i1, int i2, size_t *hashval) const 
# 2284
{ 
# 2285
return (const _Tp *)((SparseMat *)this)->ptr(i0, i1, i2, false, hashval); 
# 2286
} 
# 2288
template< class _Tp> inline const _Tp *
# 2289
SparseMat::find(const int *idx, size_t *hashval) const 
# 2290
{ 
# 2291
return (const _Tp *)((SparseMat *)this)->ptr(idx, false, hashval); 
# 2292
} 
# 2294
template< class _Tp> inline _Tp &
# 2295
SparseMat::value(Node *n) 
# 2296
{ 
# 2297
return *((_Tp *)(((uchar *)n) + ((hdr)->valueOffset))); 
# 2298
} 
# 2300
template< class _Tp> inline const _Tp &
# 2301
SparseMat::value(const Node *n) const 
# 2302
{ 
# 2303
return *((const _Tp *)(((const uchar *)n) + ((hdr)->valueOffset))); 
# 2304
} 
# 2307
inline SparseMat::Node *SparseMat::node(size_t nidx) 
# 2308
{ 
# 2309
return (Node *)((void *)(&((hdr)->pool)[nidx])); 
# 2310
} 
# 2313
inline const SparseMat::Node *SparseMat::node(size_t nidx) const 
# 2314
{ 
# 2315
return (const Node *)((const void *)(&((hdr)->pool)[nidx])); 
# 2316
} 
# 2319
inline SparseMatIterator SparseMat::begin() 
# 2320
{ 
# 2321
return ((SparseMatIterator)(this)); 
# 2322
} 
# 2325
inline SparseMatConstIterator SparseMat::begin() const 
# 2326
{ 
# 2327
return ((SparseMatConstIterator)(this)); 
# 2328
} 
# 2331
inline SparseMatIterator SparseMat::end() 
# 2332
{ 
# 2333
SparseMatIterator it(this); 
# 2334
it.seekEnd(); 
# 2335
return it; 
# 2336
} 
# 2339
inline SparseMatConstIterator SparseMat::end() const 
# 2340
{ 
# 2341
SparseMatConstIterator it(this); 
# 2342
it.seekEnd(); 
# 2343
return it; 
# 2344
} 
# 2346
template< class _Tp> inline SparseMatIterator_< _Tp>  
# 2347
SparseMat::begin() 
# 2348
{ 
# 2349
return ((SparseMatIterator_< _Tp> )(this)); 
# 2350
} 
# 2352
template< class _Tp> inline SparseMatConstIterator_< _Tp>  
# 2353
SparseMat::begin() const 
# 2354
{ 
# 2355
return ((SparseMatConstIterator_< _Tp> )(this)); 
# 2356
} 
# 2358
template< class _Tp> inline SparseMatIterator_< _Tp>  
# 2359
SparseMat::end() 
# 2360
{ 
# 2361
SparseMatIterator_< _Tp>  it(this); 
# 2362
(it.seekEnd()); 
# 2363
return it; 
# 2364
} 
# 2366
template< class _Tp> inline SparseMatConstIterator_< _Tp>  
# 2367
SparseMat::end() const 
# 2368
{ 
# 2369
SparseMatConstIterator_< _Tp>  it(this); 
# 2370
(it.seekEnd()); 
# 2371
return it; 
# 2372
} 
# 2378
template< class _Tp> inline 
# 2379
SparseMat_< _Tp> ::SparseMat_() 
# 2380
{ 
# 2381
(flags) = (MAGIC_VAL | traits::Type< _Tp> ::value); 
# 2382
} 
# 2384
template< class _Tp> inline 
# 2385
SparseMat_< _Tp> ::SparseMat_(int _dims, const int *_sizes) : SparseMat(_dims, _sizes, traits::Type< _Tp> ::value) 
# 2387
{ } 
# 2389
template< class _Tp> inline 
# 2390
SparseMat_< _Tp> ::SparseMat_(const SparseMat &m) 
# 2391
{ 
# 2392
if (m.type() == traits::Type< _Tp> ::value) { 
# 2393
(*this) = ((const SparseMat_ &)m); } else { 
# 2395
(m.convertTo(*this, traits::Type< _Tp> ::value)); }  
# 2396
} 
# 2398
template< class _Tp> inline 
# 2399
SparseMat_< _Tp> ::SparseMat_(const SparseMat_ &m) 
# 2400
{ 
# 2401
(this->flags) = (m.flags); 
# 2402
(this->hdr) = (m.hdr); 
# 2403
if (this->hdr) { 
# 2404
(int)__atomic_fetch_add((unsigned *)(&((this->hdr)->refcount)), (unsigned)1, 4); }  
# 2405
} 
# 2407
template< class _Tp> inline 
# 2408
SparseMat_< _Tp> ::SparseMat_(const Mat &m) 
# 2409
{ 
# 2410
SparseMat sm(m); 
# 2411
(*this) = sm; 
# 2412
} 
# 2414
template< class _Tp> inline SparseMat_< _Tp>  &
# 2415
SparseMat_< _Tp> ::operator=(const SparseMat_ &m) 
# 2416
{ 
# 2417
if (this != (&m)) 
# 2418
{ 
# 2419
if (m.hdr) { (int)__atomic_fetch_add((unsigned *)(&((m.hdr)->refcount)), (unsigned)1, 4); }  
# 2420
this->SparseMat::release(); 
# 2421
(flags) = (m.flags); 
# 2422
(hdr) = (m.hdr); 
# 2423
}  
# 2424
return *this; 
# 2425
} 
# 2427
template< class _Tp> inline SparseMat_< _Tp>  &
# 2428
SparseMat_< _Tp> ::operator=(const SparseMat &m) 
# 2429
{ 
# 2430
if (m.type() == traits::Type< _Tp> ::value) { 
# 2431
return (*this) = ((const SparseMat_ &)m); }  
# 2432
(m.convertTo(*this, traits::Type< _Tp> ::value)); 
# 2433
return *this; 
# 2434
} 
# 2436
template< class _Tp> inline SparseMat_< _Tp>  &
# 2437
SparseMat_< _Tp> ::operator=(const Mat &m) 
# 2438
{ 
# 2439
return (*this) = ((SparseMat)(m)); 
# 2440
} 
# 2442
template< class _Tp> inline SparseMat_< _Tp>  
# 2443
SparseMat_< _Tp> ::clone() const 
# 2444
{ 
# 2445
SparseMat_ m; 
# 2446
(this->copyTo(m)); 
# 2447
return m; 
# 2448
} 
# 2450
template< class _Tp> inline void 
# 2451
SparseMat_< _Tp> ::create(int _dims, const int *_sizes) 
# 2452
{ 
# 2453
this->SparseMat::create(_dims, _sizes, traits::Type< _Tp> ::value); 
# 2454
} 
# 2456
template< class _Tp> inline int 
# 2457
SparseMat_< _Tp> ::type() const 
# 2458
{ 
# 2459
return traits::Type< _Tp> ::value; 
# 2460
} 
# 2462
template< class _Tp> inline int 
# 2463
SparseMat_< _Tp> ::depth() const 
# 2464
{ 
# 2465
return traits::Depth< _Tp> ::value; 
# 2466
} 
# 2468
template< class _Tp> inline int 
# 2469
SparseMat_< _Tp> ::channels() const 
# 2470
{ 
# 2471
return DataType< _Tp> ::channels; 
# 2472
} 
# 2474
template< class _Tp> inline _Tp &
# 2475
SparseMat_< _Tp> ::ref(int i0, size_t *hashval) 
# 2476
{ 
# 2477
return SparseMat::template ref< _Tp> (i0, hashval); 
# 2478
} 
# 2480
template< class _Tp> inline _Tp 
# 2481
SparseMat_< _Tp> ::operator()(int i0, size_t *hashval) const 
# 2482
{ 
# 2483
return SparseMat::template value< _Tp> (i0, hashval); 
# 2484
} 
# 2486
template< class _Tp> inline _Tp &
# 2487
SparseMat_< _Tp> ::ref(int i0, int i1, size_t *hashval) 
# 2488
{ 
# 2489
return SparseMat::template ref< _Tp> (i0, i1, hashval); 
# 2490
} 
# 2492
template< class _Tp> inline _Tp 
# 2493
SparseMat_< _Tp> ::operator()(int i0, int i1, size_t *hashval) const 
# 2494
{ 
# 2495
return SparseMat::template value< _Tp> (i0, i1, hashval); 
# 2496
} 
# 2498
template< class _Tp> inline _Tp &
# 2499
SparseMat_< _Tp> ::ref(int i0, int i1, int i2, size_t *hashval) 
# 2500
{ 
# 2501
return SparseMat::template ref< _Tp> (i0, i1, i2, hashval); 
# 2502
} 
# 2504
template< class _Tp> inline _Tp 
# 2505
SparseMat_< _Tp> ::operator()(int i0, int i1, int i2, size_t *hashval) const 
# 2506
{ 
# 2507
return SparseMat::template value< _Tp> (i0, i1, i2, hashval); 
# 2508
} 
# 2510
template< class _Tp> inline _Tp &
# 2511
SparseMat_< _Tp> ::ref(const int *idx, size_t *hashval) 
# 2512
{ 
# 2513
return SparseMat::template ref< _Tp> (idx, hashval); 
# 2514
} 
# 2516
template< class _Tp> inline _Tp 
# 2517
SparseMat_< _Tp> ::operator()(const int *idx, size_t *hashval) const 
# 2518
{ 
# 2519
return SparseMat::template value< _Tp> (idx, hashval); 
# 2520
} 
# 2522
template< class _Tp> inline SparseMatIterator_< _Tp>  
# 2523
SparseMat_< _Tp> ::begin() 
# 2524
{ 
# 2525
return ((SparseMatIterator_< _Tp> )(this)); 
# 2526
} 
# 2528
template< class _Tp> inline SparseMatConstIterator_< _Tp>  
# 2529
SparseMat_< _Tp> ::begin() const 
# 2530
{ 
# 2531
return ((SparseMatConstIterator_< _Tp> )(this)); 
# 2532
} 
# 2534
template< class _Tp> inline SparseMatIterator_< _Tp>  
# 2535
SparseMat_< _Tp> ::end() 
# 2536
{ 
# 2537
SparseMatIterator_< _Tp>  it(this); 
# 2538
(it.seekEnd()); 
# 2539
return it; 
# 2540
} 
# 2542
template< class _Tp> inline SparseMatConstIterator_< _Tp>  
# 2543
SparseMat_< _Tp> ::end() const 
# 2544
{ 
# 2545
SparseMatConstIterator_< _Tp>  it(this); 
# 2546
(it.seekEnd()); 
# 2547
return it; 
# 2548
} 
# 2555
inline MatConstIterator::MatConstIterator() : m((0)), elemSize((0)), ptr((0)), sliceStart((0)), sliceEnd((0)) 
# 2557
{ } 
# 2560
inline MatConstIterator::MatConstIterator(const Mat *_m) : m(_m), elemSize(_m->elemSize()), ptr((0)), sliceStart((0)), sliceEnd((0)) 
# 2562
{ 
# 2563
if ((m) && (m)->isContinuous()) 
# 2564
{ 
# 2565
(sliceStart) = (m)->ptr(); 
# 2566
(sliceEnd) = ((sliceStart) + ((m)->total() * (elemSize))); 
# 2567
}  
# 2568
this->seek((const int *)0); 
# 2569
} 
# 2572
inline MatConstIterator::MatConstIterator(const Mat *_m, int _row, int _col) : m(_m), elemSize(_m->elemSize()), ptr((0)), sliceStart((0)), sliceEnd((0)) 
# 2574
{ 
# 2575
if (!(!((m) && (((m)->dims) <= 2)))) { ; } else { cv::error(cv::Error::StsAssert, "m && m->dims <= 2", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 2575); }  
# 2576
if ((m)->isContinuous()) 
# 2577
{ 
# 2578
(sliceStart) = (m)->ptr(); 
# 2579
(sliceEnd) = ((sliceStart) + ((m)->total() * (elemSize))); 
# 2580
}  
# 2581
int idx[] = {_row, _col}; 
# 2582
this->seek(idx); 
# 2583
} 
# 2586
inline MatConstIterator::MatConstIterator(const Mat *_m, Point _pt) : m(_m), elemSize(_m->elemSize()), ptr((0)), sliceStart((0)), sliceEnd((0)) 
# 2588
{ 
# 2589
if (!(!((m) && (((m)->dims) <= 2)))) { ; } else { cv::error(cv::Error::StsAssert, "m && m->dims <= 2", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 2589); }  
# 2590
if ((m)->isContinuous()) 
# 2591
{ 
# 2592
(sliceStart) = (m)->ptr(); 
# 2593
(sliceEnd) = ((sliceStart) + ((m)->total() * (elemSize))); 
# 2594
}  
# 2595
int idx[] = {_pt.y, _pt.x}; 
# 2596
this->seek(idx); 
# 2597
} 
# 2600
inline MatConstIterator::MatConstIterator(const MatConstIterator &it) : m(it.m), elemSize(it.elemSize), ptr(it.ptr), sliceStart(it.sliceStart), sliceEnd(it.sliceEnd) 
# 2602
{ } 
# 2605
inline MatConstIterator &MatConstIterator::operator=(const MatConstIterator &it) 
# 2606
{ 
# 2607
(m) = (it.m); (elemSize) = (it.elemSize); (ptr) = (it.ptr); 
# 2608
(sliceStart) = (it.sliceStart); (sliceEnd) = (it.sliceEnd); 
# 2609
return *this; 
# 2610
} 
# 2613
inline const uchar *MatConstIterator::operator*() const 
# 2614
{ 
# 2615
return ptr; 
# 2616
} 
# 2618
inline MatConstIterator &MatConstIterator::operator+=(ptrdiff_t ofs) 
# 2619
{ 
# 2620
if ((!(m)) || (ofs == (0))) { 
# 2621
return *this; }  
# 2622
ptrdiff_t ofsb = ofs * (elemSize); 
# 2623
(ptr) += ofsb; 
# 2624
if (((ptr) < (sliceStart)) || ((sliceEnd) <= (ptr))) 
# 2625
{ 
# 2626
(ptr) -= ofsb; 
# 2627
this->seek(ofs, true); 
# 2628
}  
# 2629
return *this; 
# 2630
} 
# 2633
inline MatConstIterator &MatConstIterator::operator-=(ptrdiff_t ofs) 
# 2634
{ 
# 2635
return ((*this) += (-ofs)); 
# 2636
} 
# 2639
inline MatConstIterator &MatConstIterator::operator--() 
# 2640
{ 
# 2641
if ((m) && (((ptr) -= (elemSize)) < (sliceStart))) 
# 2642
{ 
# 2643
(ptr) += (elemSize); 
# 2644
this->seek(-1, true); 
# 2645
}  
# 2646
return *this; 
# 2647
} 
# 2650
inline MatConstIterator MatConstIterator::operator--(int) 
# 2651
{ 
# 2652
MatConstIterator b = *this; 
# 2653
((*this) += (-1)); 
# 2654
return b; 
# 2655
} 
# 2658
inline MatConstIterator &MatConstIterator::operator++() 
# 2659
{ 
# 2660
if ((m) && (((ptr) += (elemSize)) >= (sliceEnd))) 
# 2661
{ 
# 2662
(ptr) -= (elemSize); 
# 2663
this->seek(1, true); 
# 2664
}  
# 2665
return *this; 
# 2666
} 
# 2668
inline MatConstIterator MatConstIterator::operator++(int) 
# 2669
{ 
# 2670
MatConstIterator b = *this; 
# 2671
((*this) += (1)); 
# 2672
return b; 
# 2673
} 
# 2677
static inline bool operator==(const MatConstIterator &a, const MatConstIterator &b) 
# 2678
{ 
# 2679
return ((a.m) == (b.m)) && ((a.ptr) == (b.ptr)); 
# 2680
} 
# 2683
static inline bool operator!=(const MatConstIterator &a, const MatConstIterator &b) 
# 2684
{ 
# 2685
return !((a == b)); 
# 2686
} 
# 2689
static inline bool operator<(const MatConstIterator &a, const MatConstIterator &b) 
# 2690
{ 
# 2691
return (a.ptr) < (b.ptr); 
# 2692
} 
# 2695
static inline bool operator>(const MatConstIterator &a, const MatConstIterator &b) 
# 2696
{ 
# 2697
return (a.ptr) > (b.ptr); 
# 2698
} 
# 2701
static inline bool operator<=(const MatConstIterator &a, const MatConstIterator &b) 
# 2702
{ 
# 2703
return (a.ptr) <= (b.ptr); 
# 2704
} 
# 2707
static inline bool operator>=(const MatConstIterator &a, const MatConstIterator &b) 
# 2708
{ 
# 2709
return (a.ptr) >= (b.ptr); 
# 2710
} 
# 2713
static inline ptrdiff_t operator-(const MatConstIterator &b, const MatConstIterator &a) 
# 2714
{ 
# 2715
if ((a.m) != (b.m)) { 
# 2716
return ((size_t)(-1)) >> 1; }  
# 2717
if ((a.sliceEnd) == (b.sliceEnd)) { 
# 2718
return ((b.ptr) - (a.ptr)) / (static_cast< ptrdiff_t>(b.elemSize)); }  
# 2720
return b.lpos() - a.lpos(); 
# 2721
} 
# 2724
static inline MatConstIterator operator+(const MatConstIterator &a, ptrdiff_t ofs) 
# 2725
{ 
# 2726
MatConstIterator b = a; 
# 2727
return (b += ofs); 
# 2728
} 
# 2731
static inline MatConstIterator operator+(ptrdiff_t ofs, const MatConstIterator &a) 
# 2732
{ 
# 2733
MatConstIterator b = a; 
# 2734
return (b += ofs); 
# 2735
} 
# 2738
static inline MatConstIterator operator-(const MatConstIterator &a, ptrdiff_t ofs) 
# 2739
{ 
# 2740
MatConstIterator b = a; 
# 2741
return (b += (-ofs)); 
# 2742
} 
# 2746
inline const uchar *MatConstIterator::operator[](ptrdiff_t i) const 
# 2747
{ 
# 2748
return (*(((*this) + i))); 
# 2749
} 
# 2755
template< class _Tp> inline 
# 2756
MatConstIterator_< _Tp> ::MatConstIterator_() 
# 2757
{ } 
# 2759
template< class _Tp> inline 
# 2760
MatConstIterator_< _Tp> ::MatConstIterator_(const Mat_< _Tp>  *_m) : MatConstIterator(_m) 
# 2762
{ } 
# 2764
template< class _Tp> inline 
# 2765
MatConstIterator_< _Tp> ::MatConstIterator_(const Mat_< _Tp>  *_m, int _row, int _col) : MatConstIterator(_m, _row, _col) 
# 2767
{ } 
# 2769
template< class _Tp> inline 
# 2770
MatConstIterator_< _Tp> ::MatConstIterator_(const Mat_< _Tp>  *_m, Point _pt) : MatConstIterator(_m, _pt) 
# 2772
{ } 
# 2774
template< class _Tp> inline 
# 2775
MatConstIterator_< _Tp> ::MatConstIterator_(const MatConstIterator_ &it) : MatConstIterator(it) 
# 2777
{ } 
# 2779
template< class _Tp> inline MatConstIterator_< _Tp>  &
# 2780
MatConstIterator_< _Tp> ::operator=(const MatConstIterator_ &it) 
# 2781
{ 
# 2782
this->MatConstIterator::operator=(it); 
# 2783
return *this; 
# 2784
} 
# 2786
template< class _Tp> inline const _Tp &
# 2787
MatConstIterator_< _Tp> ::operator*() const 
# 2788
{ 
# 2789
return *((_Tp *)(this->ptr)); 
# 2790
} 
# 2792
template< class _Tp> inline MatConstIterator_< _Tp>  &
# 2793
MatConstIterator_< _Tp> ::operator+=(ptrdiff_t ofs) 
# 2794
{ 
# 2795
this->MatConstIterator::operator+=(ofs); 
# 2796
return *this; 
# 2797
} 
# 2799
template< class _Tp> inline MatConstIterator_< _Tp>  &
# 2800
MatConstIterator_< _Tp> ::operator-=(ptrdiff_t ofs) 
# 2801
{ 
# 2802
return (*this) += (-ofs); 
# 2803
} 
# 2805
template< class _Tp> inline MatConstIterator_< _Tp>  &
# 2806
MatConstIterator_< _Tp> ::operator--() 
# 2807
{ 
# 2808
this->MatConstIterator::operator--(); 
# 2809
return *this; 
# 2810
} 
# 2812
template< class _Tp> inline MatConstIterator_< _Tp>  
# 2813
MatConstIterator_< _Tp> ::operator--(int) 
# 2814
{ 
# 2815
MatConstIterator_ b = *this; 
# 2816
this->MatConstIterator::operator--(); 
# 2817
return b; 
# 2818
} 
# 2820
template< class _Tp> inline MatConstIterator_< _Tp>  &
# 2821
MatConstIterator_< _Tp> ::operator++() 
# 2822
{ 
# 2823
this->MatConstIterator::operator++(); 
# 2824
return *this; 
# 2825
} 
# 2827
template< class _Tp> inline MatConstIterator_< _Tp>  
# 2828
MatConstIterator_< _Tp> ::operator++(int) 
# 2829
{ 
# 2830
MatConstIterator_ b = *this; 
# 2831
this->MatConstIterator::operator++(); 
# 2832
return b; 
# 2833
} 
# 2836
template< class _Tp> inline Point 
# 2837
MatConstIterator_< _Tp> ::pos() const 
# 2838
{ 
# 2839
if (!(m)) { 
# 2840
return Point(); }  
# 2841
; 
# 2842
if ((m)->isContinuous()) 
# 2843
{ 
# 2844
ptrdiff_t ofs = ((const _Tp *)(ptr)) - ((const _Tp *)((m)->data)); 
# 2845
int y = (int)(ofs / ((m)->cols)); 
# 2846
int x = (int)(ofs - (((ptrdiff_t)y) * ((m)->cols))); 
# 2847
return Point(x, y); 
# 2848
} else 
# 2850
{ 
# 2851
ptrdiff_t ofs = ((uchar *)(ptr)) - ((m)->data); 
# 2852
int y = (int)(ofs / ((m)->step)); 
# 2853
int x = (int)((ofs - (y * ((m)->step))) / sizeof(_Tp)); 
# 2854
return Point(x, y); 
# 2855
}  
# 2856
} 
# 2859
template< class _Tp> static inline bool 
# 2860
operator==(const MatConstIterator_< _Tp>  &a, const MatConstIterator_< _Tp>  &b) 
# 2861
{ 
# 2862
return ((a.m) == (b.m)) && ((a.ptr) == (b.ptr)); 
# 2863
} 
# 2865
template< class _Tp> static inline bool 
# 2866
operator!=(const MatConstIterator_< _Tp>  &a, const MatConstIterator_< _Tp>  &b) 
# 2867
{ 
# 2868
return ((a.m) != (b.m)) || ((a.ptr) != (b.ptr)); 
# 2869
} 
# 2871
template< class _Tp> static inline MatConstIterator_< _Tp>  
# 2872
operator+(const MatConstIterator_< _Tp>  &a, ptrdiff_t ofs) 
# 2873
{ 
# 2874
MatConstIterator t = (((const MatConstIterator &)a) + ofs); 
# 2875
return (MatConstIterator_< _Tp>  &)t; 
# 2876
} 
# 2878
template< class _Tp> static inline MatConstIterator_< _Tp>  
# 2879
operator+(ptrdiff_t ofs, const MatConstIterator_< _Tp>  &a) 
# 2880
{ 
# 2881
MatConstIterator t = (((const MatConstIterator &)a) + ofs); 
# 2882
return (MatConstIterator_< _Tp>  &)t; 
# 2883
} 
# 2885
template< class _Tp> static inline MatConstIterator_< _Tp>  
# 2886
operator-(const MatConstIterator_< _Tp>  &a, ptrdiff_t ofs) 
# 2887
{ 
# 2888
MatConstIterator t = (((const MatConstIterator &)a) - ofs); 
# 2889
return (MatConstIterator_< _Tp>  &)t; 
# 2890
} 
# 2892
template< class _Tp> inline const _Tp &
# 2893
MatConstIterator_< _Tp> ::operator[](ptrdiff_t i) const 
# 2894
{ 
# 2895
return *((_Tp *)this->MatConstIterator::operator[](i)); 
# 2896
} 
# 2902
template< class _Tp> inline 
# 2903
MatIterator_< _Tp> ::MatIterator_() : ::cv::MatConstIterator_< _Tp> () 
# 2905
{ } 
# 2907
template< class _Tp> inline 
# 2908
MatIterator_< _Tp> ::MatIterator_(Mat_< _Tp>  *_m) : ::cv::MatConstIterator_< _Tp> (_m) 
# 2910
{ } 
# 2912
template< class _Tp> inline 
# 2913
MatIterator_< _Tp> ::MatIterator_(Mat_< _Tp>  *_m, int _row, int _col) : ::cv::MatConstIterator_< _Tp> (_m, _row, _col) 
# 2915
{ } 
# 2917
template< class _Tp> inline 
# 2918
MatIterator_< _Tp> ::MatIterator_(Mat_< _Tp>  *_m, ::cv::Point _pt) : ::cv::MatConstIterator_< _Tp> (_m, _pt) 
# 2920
{ } 
# 2922
template< class _Tp> inline 
# 2923
MatIterator_< _Tp> ::MatIterator_(Mat_< _Tp>  *_m, const int *_idx) : ::cv::MatConstIterator_< _Tp> (_m, _idx) 
# 2925
{ } 
# 2927
template< class _Tp> inline 
# 2928
MatIterator_< _Tp> ::MatIterator_(const MatIterator_ &it) : ::cv::MatConstIterator_< _Tp> (it) 
# 2930
{ } 
# 2932
template< class _Tp> inline MatIterator_< _Tp>  &
# 2933
MatIterator_< _Tp> ::operator=(const MatIterator_ &it) 
# 2934
{ 
# 2935
this->MatConstIterator::operator=(it); 
# 2936
return *this; 
# 2937
} 
# 2939
template< class _Tp> inline _Tp &
# 2940
MatIterator_< _Tp> ::operator*() const 
# 2941
{ 
# 2942
return *((_Tp *)(this->ptr)); 
# 2943
} 
# 2945
template< class _Tp> inline MatIterator_< _Tp>  &
# 2946
MatIterator_< _Tp> ::operator+=(::ptrdiff_t ofs) 
# 2947
{ 
# 2948
this->MatConstIterator::operator+=(ofs); 
# 2949
return *this; 
# 2950
} 
# 2952
template< class _Tp> inline MatIterator_< _Tp>  &
# 2953
MatIterator_< _Tp> ::operator-=(::ptrdiff_t ofs) 
# 2954
{ 
# 2955
this->MatConstIterator::operator+=(-ofs); 
# 2956
return *this; 
# 2957
} 
# 2959
template< class _Tp> inline MatIterator_< _Tp>  &
# 2960
MatIterator_< _Tp> ::operator--() 
# 2961
{ 
# 2962
this->MatConstIterator::operator--(); 
# 2963
return *this; 
# 2964
} 
# 2966
template< class _Tp> inline MatIterator_< _Tp>  
# 2967
MatIterator_< _Tp> ::operator--(int) 
# 2968
{ 
# 2969
MatIterator_ b = *this; 
# 2970
this->MatConstIterator::operator--(); 
# 2971
return b; 
# 2972
} 
# 2974
template< class _Tp> inline MatIterator_< _Tp>  &
# 2975
MatIterator_< _Tp> ::operator++() 
# 2976
{ 
# 2977
this->MatConstIterator::operator++(); 
# 2978
return *this; 
# 2979
} 
# 2981
template< class _Tp> inline MatIterator_< _Tp>  
# 2982
MatIterator_< _Tp> ::operator++(int) 
# 2983
{ 
# 2984
MatIterator_ b = *this; 
# 2985
this->MatConstIterator::operator++(); 
# 2986
return b; 
# 2987
} 
# 2989
template< class _Tp> inline _Tp &
# 2990
MatIterator_< _Tp> ::operator[](::ptrdiff_t i) const 
# 2991
{ 
# 2992
return *((*this) + i); 
# 2993
} 
# 2996
template< class _Tp> static inline bool 
# 2997
operator==(const MatIterator_< _Tp>  &a, const MatIterator_< _Tp>  &b) 
# 2998
{ 
# 2999
return ((a.m) == (b.m)) && ((a.ptr) == (b.ptr)); 
# 3000
} 
# 3002
template< class _Tp> static inline bool 
# 3003
operator!=(const MatIterator_< _Tp>  &a, const MatIterator_< _Tp>  &b) 
# 3004
{ 
# 3005
return ((a.m) != (b.m)) || ((a.ptr) != (b.ptr)); 
# 3006
} 
# 3008
template< class _Tp> static inline MatIterator_< _Tp>  
# 3009
operator+(const MatIterator_< _Tp>  &a, ptrdiff_t ofs) 
# 3010
{ 
# 3011
MatConstIterator t = (((const MatConstIterator &)a) + ofs); 
# 3012
return (MatIterator_< _Tp>  &)t; 
# 3013
} 
# 3015
template< class _Tp> static inline MatIterator_< _Tp>  
# 3016
operator+(ptrdiff_t ofs, const MatIterator_< _Tp>  &a) 
# 3017
{ 
# 3018
MatConstIterator t = (((const MatConstIterator &)a) + ofs); 
# 3019
return (MatIterator_< _Tp>  &)t; 
# 3020
} 
# 3022
template< class _Tp> static inline MatIterator_< _Tp>  
# 3023
operator-(const MatIterator_< _Tp>  &a, ptrdiff_t ofs) 
# 3024
{ 
# 3025
MatConstIterator t = (((const MatConstIterator &)a) - ofs); 
# 3026
return (MatIterator_< _Tp>  &)t; 
# 3027
} 
# 3034
inline SparseMatConstIterator::SparseMatConstIterator() : m((0)), hashidx((0)), ptr((0)) 
# 3036
{ } 
# 3039
inline SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator &it) : m(it.m), hashidx(it.hashidx), ptr(it.ptr) 
# 3041
{ } 
# 3043
inline SparseMatConstIterator &SparseMatConstIterator::operator=(const SparseMatConstIterator &it) 
# 3044
{ 
# 3045
if (this != (&it)) 
# 3046
{ 
# 3047
(m) = (it.m); 
# 3048
(hashidx) = (it.hashidx); 
# 3049
(ptr) = (it.ptr); 
# 3050
}  
# 3051
return *this; 
# 3052
} 
# 3054
template< class _Tp> inline const _Tp &
# 3055
SparseMatConstIterator::value() const 
# 3056
{ 
# 3057
return *((const _Tp *)(ptr)); 
# 3058
} 
# 3061
inline const SparseMat::Node *SparseMatConstIterator::node() const 
# 3062
{ 
# 3063
return ((ptr) && (m) && ((m)->hdr)) ? (const SparseMat::Node *)((const void *)((ptr) - (((m)->hdr)->valueOffset))) : (0); 
# 3064
} 
# 3067
inline SparseMatConstIterator SparseMatConstIterator::operator++(int) 
# 3068
{ 
# 3069
SparseMatConstIterator it = *this; 
# 3070
(++(*this)); 
# 3071
return it; 
# 3072
} 
# 3075
inline void SparseMatConstIterator::seekEnd() 
# 3076
{ 
# 3077
if ((m) && ((m)->hdr)) 
# 3078
{ 
# 3079
(hashidx) = (((m)->hdr)->hashtab).size(); 
# 3080
(ptr) = (0); 
# 3081
}  
# 3082
} 
# 3086
static inline bool operator==(const SparseMatConstIterator &it1, const SparseMatConstIterator &it2) 
# 3087
{ 
# 3088
return ((it1.m) == (it2.m)) && ((it1.ptr) == (it2.ptr)); 
# 3089
} 
# 3092
static inline bool operator!=(const SparseMatConstIterator &it1, const SparseMatConstIterator &it2) 
# 3093
{ 
# 3094
return !((it1 == it2)); 
# 3095
} 
# 3102
inline SparseMatIterator::SparseMatIterator() 
# 3103
{ } 
# 3106
inline SparseMatIterator::SparseMatIterator(SparseMat *_m) : SparseMatConstIterator(_m) 
# 3108
{ } 
# 3111
inline SparseMatIterator::SparseMatIterator(const SparseMatIterator &it) : SparseMatConstIterator(it) 
# 3113
{ } 
# 3116
inline SparseMatIterator &SparseMatIterator::operator=(const SparseMatIterator &it) 
# 3117
{ 
# 3118
(((SparseMatConstIterator &)(*this)) = it); 
# 3119
return *this; 
# 3120
} 
# 3122
template< class _Tp> inline _Tp &
# 3123
SparseMatIterator::value() const 
# 3124
{ 
# 3125
return *((_Tp *)(ptr)); 
# 3126
} 
# 3129
inline SparseMat::Node *SparseMatIterator::node() const 
# 3130
{ 
# 3131
return (SparseMat::Node *)this->SparseMatConstIterator::node(); 
# 3132
} 
# 3135
inline SparseMatIterator &SparseMatIterator::operator++() 
# 3136
{ 
# 3137
this->SparseMatConstIterator::operator++(); 
# 3138
return *this; 
# 3139
} 
# 3142
inline SparseMatIterator SparseMatIterator::operator++(int) 
# 3143
{ 
# 3144
SparseMatIterator it = *this; 
# 3145
(++(*this)); 
# 3146
return it; 
# 3147
} 
# 3153
template< class _Tp> inline 
# 3154
SparseMatConstIterator_< _Tp> ::SparseMatConstIterator_() 
# 3155
{ } 
# 3157
template< class _Tp> inline 
# 3158
SparseMatConstIterator_< _Tp> ::SparseMatConstIterator_(const SparseMat_< _Tp>  *_m) : SparseMatConstIterator(_m) 
# 3160
{ } 
# 3162
template< class _Tp> inline 
# 3163
SparseMatConstIterator_< _Tp> ::SparseMatConstIterator_(const SparseMat *_m) : SparseMatConstIterator(_m) 
# 3165
{ 
# 3166
if (!(!(_m->type() == traits::Type< _Tp> ::value))) { ; } else { cv::error(cv::Error::StsAssert, "_m->type() == traits::Type<_Tp>::value", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 3166); }  
# 3167
} 
# 3169
template< class _Tp> inline 
# 3170
SparseMatConstIterator_< _Tp> ::SparseMatConstIterator_(const SparseMatConstIterator_ &it) : SparseMatConstIterator(it) 
# 3172
{ } 
# 3174
template< class _Tp> inline SparseMatConstIterator_< _Tp>  &
# 3175
SparseMatConstIterator_< _Tp> ::operator=(const SparseMatConstIterator_ &it) 
# 3176
{ 
# 3177
return reinterpret_cast< SparseMatConstIterator_ &>(((*(reinterpret_cast< SparseMatConstIterator *>(this))) = (reinterpret_cast< const SparseMatConstIterator &>(it)))); 
# 3180
} 
# 3182
template< class _Tp> inline const _Tp &
# 3183
SparseMatConstIterator_< _Tp> ::operator*() const 
# 3184
{ 
# 3185
return *((const _Tp *)(this->ptr)); 
# 3186
} 
# 3188
template< class _Tp> inline SparseMatConstIterator_< _Tp>  &
# 3189
SparseMatConstIterator_< _Tp> ::operator++() 
# 3190
{ 
# 3191
this->SparseMatConstIterator::operator++(); 
# 3192
return *this; 
# 3193
} 
# 3195
template< class _Tp> inline SparseMatConstIterator_< _Tp>  
# 3196
SparseMatConstIterator_< _Tp> ::operator++(int) 
# 3197
{ 
# 3198
SparseMatConstIterator_ it = *this; 
# 3199
this->SparseMatConstIterator::operator++(); 
# 3200
return it; 
# 3201
} 
# 3207
template< class _Tp> inline 
# 3208
SparseMatIterator_< _Tp> ::SparseMatIterator_() 
# 3209
{ } 
# 3211
template< class _Tp> inline 
# 3212
SparseMatIterator_< _Tp> ::SparseMatIterator_(SparseMat_< _Tp>  *_m) : ::cv::SparseMatConstIterator_< _Tp> (_m) 
# 3214
{ } 
# 3216
template< class _Tp> inline 
# 3217
SparseMatIterator_< _Tp> ::SparseMatIterator_(::cv::SparseMat *_m) : ::cv::SparseMatConstIterator_< _Tp> (_m) 
# 3219
{ } 
# 3221
template< class _Tp> inline 
# 3222
SparseMatIterator_< _Tp> ::SparseMatIterator_(const SparseMatIterator_ &it) : ::cv::SparseMatConstIterator_< _Tp> (it) 
# 3224
{ } 
# 3226
template< class _Tp> inline SparseMatIterator_< _Tp>  &
# 3227
SparseMatIterator_< _Tp> ::operator=(const SparseMatIterator_ &it) 
# 3228
{ 
# 3229
return reinterpret_cast< SparseMatIterator_ &>(((*(reinterpret_cast< ::cv::SparseMatConstIterator *>(this))) = (reinterpret_cast< const ::cv::SparseMatConstIterator &>(it)))); 
# 3232
} 
# 3234
template< class _Tp> inline _Tp &
# 3235
SparseMatIterator_< _Tp> ::operator*() const 
# 3236
{ 
# 3237
return *((_Tp *)(this->ptr)); 
# 3238
} 
# 3240
template< class _Tp> inline SparseMatIterator_< _Tp>  &
# 3241
SparseMatIterator_< _Tp> ::operator++() 
# 3242
{ 
# 3243
this->SparseMatConstIterator::operator++(); 
# 3244
return *this; 
# 3245
} 
# 3247
template< class _Tp> inline SparseMatIterator_< _Tp>  
# 3248
SparseMatIterator_< _Tp> ::operator++(int) 
# 3249
{ 
# 3250
SparseMatIterator_ it = *this; 
# 3251
this->SparseMatConstIterator::operator++(); 
# 3252
return it; 
# 3253
} 
# 3259
template< class _Tp> inline 
# 3260
MatCommaInitializer_< _Tp> ::MatCommaInitializer_(Mat_< _Tp>  *_m) : it(_m) 
# 3262
{ } 
# 3264
template< class _Tp> template< class T2> inline MatCommaInitializer_< _Tp>  &
# 3265
MatCommaInitializer_< _Tp> ::operator,(T2 v) 
# 3266
{ 
# 3267
; 
# 3268
(*(this->it)) = ((_Tp)v); 
# 3269
++(this->it); 
# 3270
return *this; 
# 3271
} 
# 3273
template< class _Tp> inline 
# 3274
MatCommaInitializer_< _Tp> ::operator Mat_< _Tp> () const 
# 3275
{ 
# 3276
; 
# 3277
return ((Mat_< _Tp> )(*((this->it).m))); 
# 3278
} 
# 3281
template< class _Tp, class T2> static inline MatCommaInitializer_< _Tp>  
# 3282
operator<<(const Mat_< _Tp>  &m, T2 val) 
# 3283
{ 
# 3284
MatCommaInitializer_< _Tp>  commaInitializer((Mat_< _Tp>  *)(&m)); 
# 3285
return (commaInitializer, val); 
# 3286
} 
# 3293
inline Mat &Mat::operator=(const MatExpr &e) 
# 3294
{ 
# 3295
(e.op)->assign(e, *this); 
# 3296
return *this; 
# 3297
} 
# 3299
template< class _Tp> inline 
# 3300
Mat_< _Tp> ::Mat_(const MatExpr &e) 
# 3301
{ 
# 3302
(e.op)->assign(e, *this, traits::Type< _Tp> ::value); 
# 3303
} 
# 3305
template< class _Tp> inline Mat_< _Tp>  &
# 3306
Mat_< _Tp> ::operator=(const MatExpr &e) 
# 3307
{ 
# 3308
(e.op)->assign(e, *this, traits::Type< _Tp> ::value); 
# 3309
return *this; 
# 3310
} 
# 3312
template< class _Tp> inline MatExpr 
# 3313
Mat_< _Tp> ::zeros(int rows, int cols) 
# 3314
{ 
# 3315
return Mat::zeros(rows, cols, traits::Type< _Tp> ::value); 
# 3316
} 
# 3318
template< class _Tp> inline MatExpr 
# 3319
Mat_< _Tp> ::zeros(Size sz) 
# 3320
{ 
# 3321
return Mat::zeros(sz, traits::Type< _Tp> ::value); 
# 3322
} 
# 3324
template< class _Tp> inline MatExpr 
# 3325
Mat_< _Tp> ::ones(int rows, int cols) 
# 3326
{ 
# 3327
return Mat::ones(rows, cols, traits::Type< _Tp> ::value); 
# 3328
} 
# 3330
template< class _Tp> inline MatExpr 
# 3331
Mat_< _Tp> ::ones(Size sz) 
# 3332
{ 
# 3333
return Mat::ones(sz, traits::Type< _Tp> ::value); 
# 3334
} 
# 3336
template< class _Tp> inline MatExpr 
# 3337
Mat_< _Tp> ::eye(int rows, int cols) 
# 3338
{ 
# 3339
return Mat::eye(rows, cols, traits::Type< _Tp> ::value); 
# 3340
} 
# 3342
template< class _Tp> inline MatExpr 
# 3343
Mat_< _Tp> ::eye(Size sz) 
# 3344
{ 
# 3345
return Mat::eye(sz, traits::Type< _Tp> ::value); 
# 3346
} 
# 3349
inline MatExpr::MatExpr() : op((0)), flags(0), a(), b(), c(), alpha((0)), beta((0)), s() 
# 3351
{ } 
# 3354
inline MatExpr::MatExpr(const MatOp *_op, int _flags, const Mat &_a, const Mat &_b, const Mat &
# 3355
_c, double _alpha, double _beta, const Scalar &_s) : op(_op), flags(_flags), a(_a), b(_b), c(_c), alpha(_alpha), beta(_beta), s(_s) 
# 3357
{ } 
# 3360
inline MatExpr::operator Mat() const 
# 3361
{ 
# 3362
Mat m; 
# 3363
(op)->assign(*this, m); 
# 3364
return m; 
# 3365
} 
# 3367
template< class _Tp> inline 
# 3368
MatExpr::operator Mat_< _Tp> () const 
# 3369
{ 
# 3370
Mat_< _Tp>  m; 
# 3371
(op)->assign(*this, m, traits::Type< _Tp> ::value); 
# 3372
return m; 
# 3373
} 
# 3376
template< class _Tp> static inline MatExpr 
# 3377
min(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) 
# 3378
{ 
# 3379
return cv::min((const Mat &)a, (const Mat &)b); 
# 3380
} 
# 3382
template< class _Tp> static inline MatExpr 
# 3383
min(const Mat_< _Tp>  &a, double s) 
# 3384
{ 
# 3385
return cv::min((const Mat &)a, s); 
# 3386
} 
# 3388
template< class _Tp> static inline MatExpr 
# 3389
min(double s, const Mat_< _Tp>  &a) 
# 3390
{ 
# 3391
return cv::min((const Mat &)a, s); 
# 3392
} 
# 3394
template< class _Tp> static inline MatExpr 
# 3395
max(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) 
# 3396
{ 
# 3397
return cv::max((const Mat &)a, (const Mat &)b); 
# 3398
} 
# 3400
template< class _Tp> static inline MatExpr 
# 3401
max(const Mat_< _Tp>  &a, double s) 
# 3402
{ 
# 3403
return cv::max((const Mat &)a, s); 
# 3404
} 
# 3406
template< class _Tp> static inline MatExpr 
# 3407
max(double s, const Mat_< _Tp>  &a) 
# 3408
{ 
# 3409
return cv::max((const Mat &)a, s); 
# 3410
} 
# 3412
template< class _Tp> static inline MatExpr 
# 3413
abs(const Mat_< _Tp>  &m) 
# 3414
{ 
# 3415
return cv::abs((const Mat &)m); 
# 3416
} 
# 3420
static inline Mat &operator+=(Mat &a, const MatExpr &b) 
# 3421
{ 
# 3422
(b.op)->augAssignAdd(b, a); 
# 3423
return a; 
# 3424
} 
# 3427
static inline const Mat &operator+=(const Mat &a, const MatExpr &b) 
# 3428
{ 
# 3429
(b.op)->augAssignAdd(b, (Mat &)a); 
# 3430
return a; 
# 3431
} 
# 3433
template< class _Tp> static inline Mat_< _Tp>  &
# 3434
operator+=(Mat_< _Tp>  &a, const MatExpr &b) 
# 3435
{ 
# 3436
(b.op)->augAssignAdd(b, a); 
# 3437
return a; 
# 3438
} 
# 3440
template< class _Tp> static inline const Mat_< _Tp>  &
# 3441
operator+=(const Mat_< _Tp>  &a, const MatExpr &b) 
# 3442
{ 
# 3443
(b.op)->augAssignAdd(b, (Mat &)a); 
# 3444
return a; 
# 3445
} 
# 3448
static inline Mat &operator-=(Mat &a, const MatExpr &b) 
# 3449
{ 
# 3450
(b.op)->augAssignSubtract(b, a); 
# 3451
return a; 
# 3452
} 
# 3455
static inline const Mat &operator-=(const Mat &a, const MatExpr &b) 
# 3456
{ 
# 3457
(b.op)->augAssignSubtract(b, (Mat &)a); 
# 3458
return a; 
# 3459
} 
# 3461
template< class _Tp> static inline Mat_< _Tp>  &
# 3462
operator-=(Mat_< _Tp>  &a, const MatExpr &b) 
# 3463
{ 
# 3464
(b.op)->augAssignSubtract(b, a); 
# 3465
return a; 
# 3466
} 
# 3468
template< class _Tp> static inline const Mat_< _Tp>  &
# 3469
operator-=(const Mat_< _Tp>  &a, const MatExpr &b) 
# 3470
{ 
# 3471
(b.op)->augAssignSubtract(b, (Mat &)a); 
# 3472
return a; 
# 3473
} 
# 3476
static inline Mat &operator*=(Mat &a, const MatExpr &b) 
# 3477
{ 
# 3478
(b.op)->augAssignMultiply(b, a); 
# 3479
return a; 
# 3480
} 
# 3483
static inline const Mat &operator*=(const Mat &a, const MatExpr &b) 
# 3484
{ 
# 3485
(b.op)->augAssignMultiply(b, (Mat &)a); 
# 3486
return a; 
# 3487
} 
# 3489
template< class _Tp> static inline Mat_< _Tp>  &
# 3490
operator*=(Mat_< _Tp>  &a, const MatExpr &b) 
# 3491
{ 
# 3492
(b.op)->augAssignMultiply(b, a); 
# 3493
return a; 
# 3494
} 
# 3496
template< class _Tp> static inline const Mat_< _Tp>  &
# 3497
operator*=(const Mat_< _Tp>  &a, const MatExpr &b) 
# 3498
{ 
# 3499
(b.op)->augAssignMultiply(b, (Mat &)a); 
# 3500
return a; 
# 3501
} 
# 3504
static inline Mat &operator/=(Mat &a, const MatExpr &b) 
# 3505
{ 
# 3506
(b.op)->augAssignDivide(b, a); 
# 3507
return a; 
# 3508
} 
# 3511
static inline const Mat &operator/=(const Mat &a, const MatExpr &b) 
# 3512
{ 
# 3513
(b.op)->augAssignDivide(b, (Mat &)a); 
# 3514
return a; 
# 3515
} 
# 3517
template< class _Tp> static inline Mat_< _Tp>  &
# 3518
operator/=(Mat_< _Tp>  &a, const MatExpr &b) 
# 3519
{ 
# 3520
(b.op)->augAssignDivide(b, a); 
# 3521
return a; 
# 3522
} 
# 3524
template< class _Tp> static inline const Mat_< _Tp>  &
# 3525
operator/=(const Mat_< _Tp>  &a, const MatExpr &b) 
# 3526
{ 
# 3527
(b.op)->augAssignDivide(b, (Mat &)a); 
# 3528
return a; 
# 3529
} 
# 3535
inline UMat::UMat(UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3537
{ } 
# 3540
inline UMat::UMat(int _rows, int _cols, int _type, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3542
{ 
# 3543
this->create(_rows, _cols, _type); 
# 3544
} 
# 3547
inline UMat::UMat(int _rows, int _cols, int _type, const Scalar &_s, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3549
{ 
# 3550
this->create(_rows, _cols, _type); 
# 3551
((*this) = _s); 
# 3552
} 
# 3555
inline UMat::UMat(Size _sz, int _type, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3557
{ 
# 3558
this->create(_sz.height, _sz.width, _type); 
# 3559
} 
# 3562
inline UMat::UMat(Size _sz, int _type, const Scalar &_s, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3564
{ 
# 3565
this->create(_sz.height, _sz.width, _type); 
# 3566
((*this) = _s); 
# 3567
} 
# 3570
inline UMat::UMat(int _dims, const int *_sz, int _type, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3572
{ 
# 3573
this->create(_dims, _sz, _type); 
# 3574
} 
# 3577
inline UMat::UMat(int _dims, const int *_sz, int _type, const Scalar &_s, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3579
{ 
# 3580
this->create(_dims, _sz, _type); 
# 3581
((*this) = _s); 
# 3582
} 
# 3585
inline UMat::UMat(const UMat &m) : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), allocator(m.allocator), usageFlags(m.usageFlags), u(m.u), offset(m.offset), size(&(rows)) 
# 3588
{ 
# 3589
this->addref(); 
# 3590
if ((m.dims) <= 2) 
# 3591
{ 
# 3592
(step)[0] = (m.step)[0]; (step)[1] = (m.step)[1]; 
# 3593
} else 
# 3595
{ 
# 3596
(dims) = 0; 
# 3597
this->copySize(m); 
# 3598
}  
# 3599
} 
# 3602
template< class _Tp> inline 
# 3603
UMat::UMat(const std::vector< _Tp>  &vec, bool copyData) : flags(((MAGIC_VAL | traits::Type< _Tp> ::value) | (1 << 14))), dims(2), rows((int)(vec.size())), cols(1), allocator((0)), usageFlags(USAGE_DEFAULT), u((0)), offset((0)), size(&(rows)) 
# 3606
{ 
# 3607
if ((vec.empty())) { 
# 3608
return; }  
# 3609
if (!copyData) 
# 3610
{ 
# 3612
cv::error(Error::StsNotImplemented, "", __func__, "/usr/include/opencv2/core/mat.inl.hpp", 3612); 
# 3613
} else { 
# 3615
Mat((int)(vec.size()), 1, traits::Type< _Tp> ::value, (uchar *)(&(vec[0]))).copyTo(*this); }  
# 3616
} 
# 3619
inline UMat &UMat::operator=(const UMat &m) 
# 3620
{ 
# 3621
if (this != (&m)) 
# 3622
{ 
# 3623
(const_cast< UMat &>(m)).addref(); 
# 3624
this->release(); 
# 3625
(flags) = (m.flags); 
# 3626
if (((dims) <= 2) && ((m.dims) <= 2)) 
# 3627
{ 
# 3628
(dims) = (m.dims); 
# 3629
(rows) = (m.rows); 
# 3630
(cols) = (m.cols); 
# 3631
(step)[0] = (m.step)[0]; 
# 3632
(step)[1] = (m.step)[1]; 
# 3633
} else { 
# 3635
this->copySize(m); }  
# 3636
(allocator) = (m.allocator); 
# 3637
if ((usageFlags) == (USAGE_DEFAULT)) { 
# 3638
(usageFlags) = (m.usageFlags); }  
# 3639
(u) = (m.u); 
# 3640
(offset) = (m.offset); 
# 3641
}  
# 3642
return *this; 
# 3643
} 
# 3646
inline UMat UMat::row(int y) const 
# 3647
{ 
# 3648
return UMat(*this, Range(y, y + 1), Range::all()); 
# 3649
} 
# 3652
inline UMat UMat::col(int x) const 
# 3653
{ 
# 3654
return UMat(*this, Range::all(), Range(x, x + 1)); 
# 3655
} 
# 3658
inline UMat UMat::rowRange(int startrow, int endrow) const 
# 3659
{ 
# 3660
return UMat(*this, Range(startrow, endrow), Range::all()); 
# 3661
} 
# 3664
inline UMat UMat::rowRange(const Range &r) const 
# 3665
{ 
# 3666
return UMat(*this, r, Range::all()); 
# 3667
} 
# 3670
inline UMat UMat::colRange(int startcol, int endcol) const 
# 3671
{ 
# 3672
return UMat(*this, Range::all(), Range(startcol, endcol)); 
# 3673
} 
# 3676
inline UMat UMat::colRange(const Range &r) const 
# 3677
{ 
# 3678
return UMat(*this, Range::all(), r); 
# 3679
} 
# 3682
inline UMat UMat::clone() const 
# 3683
{ 
# 3684
UMat m; 
# 3685
this->copyTo(m); 
# 3686
return m; 
# 3687
} 
# 3690
inline void UMat::assignTo(UMat &m, int _type) const 
# 3691
{ 
# 3692
if (_type < 0) { 
# 3693
(m = (*this)); } else { 
# 3695
this->convertTo(m, _type); }  
# 3696
} 
# 3699
inline void UMat::create(int _rows, int _cols, int _type, UMatUsageFlags _usageFlags) 
# 3700
{ 
# 3701
_type &= (TYPE_MASK); 
# 3702
if (((dims) <= 2) && ((rows) == _rows) && ((cols) == _cols) && (this->type() == _type) && (u)) { 
# 3703
return; }  
# 3704
int sz[] = {_rows, _cols}; 
# 3705
this->create(2, sz, _type, _usageFlags); 
# 3706
} 
# 3709
inline void UMat::create(Size _sz, int _type, UMatUsageFlags _usageFlags) 
# 3710
{ 
# 3711
this->create(_sz.height, _sz.width, _type, _usageFlags); 
# 3712
} 
# 3715
inline void UMat::addref() 
# 3716
{ 
# 3717
if (u) { 
# 3718
(int)__atomic_fetch_add((unsigned *)(&((u)->urefcount)), (unsigned)1, 4); }  
# 3719
} 
# 3721
inline void UMat::release() 
# 3722
{ 
# 3723
if ((u) && (((int)__atomic_fetch_add((unsigned *)(&((u)->urefcount)), (unsigned)(-1), 4)) == 1)) { 
# 3724
this->deallocate(); }  
# 3725
for (int i = 0; i < (dims); i++) { 
# 3726
(((size).p)[i]) = 0; }  
# 3727
(u) = (0); 
# 3728
} 
# 3731
inline UMat UMat::operator()(Range _rowRange, Range _colRange) const 
# 3732
{ 
# 3733
return UMat(*this, _rowRange, _colRange); 
# 3734
} 
# 3737
inline UMat UMat::operator()(const Rect &roi) const 
# 3738
{ 
# 3739
return UMat(*this, roi); 
# 3740
} 
# 3743
inline UMat UMat::operator()(const Range *ranges) const 
# 3744
{ 
# 3745
return UMat(*this, ranges); 
# 3746
} 
# 3749
inline UMat UMat::operator()(const std::vector< Range>  &ranges) const 
# 3750
{ 
# 3751
return UMat(*this, ranges); 
# 3752
} 
# 3755
inline bool UMat::isContinuous() const 
# 3756
{ 
# 3757
return ((flags) & (CONTINUOUS_FLAG)) != 0; 
# 3758
} 
# 3761
inline bool UMat::isSubmatrix() const 
# 3762
{ 
# 3763
return ((flags) & (SUBMATRIX_FLAG)) != 0; 
# 3764
} 
# 3767
inline size_t UMat::elemSize() const 
# 3768
{ 
# 3769
return ((dims) > 0) ? ((step).p)[(dims) - 1] : (0); 
# 3770
} 
# 3773
inline size_t UMat::elemSize1() const 
# 3774
{ 
# 3775
return (((sizeof(size_t) << 28) | (138682897)) >> (((flags) & ((1 << 3) - 1)) * 4)) & (15); 
# 3776
} 
# 3779
inline int UMat::type() const 
# 3780
{ 
# 3781
return (flags) & (((1 << 3) * 512) - 1); 
# 3782
} 
# 3785
inline int UMat::depth() const 
# 3786
{ 
# 3787
return (flags) & ((1 << 3) - 1); 
# 3788
} 
# 3791
inline int UMat::channels() const 
# 3792
{ 
# 3793
return (((flags) & ((512 - 1) << 3)) >> 3) + 1; 
# 3794
} 
# 3797
inline size_t UMat::step1(int i) const 
# 3798
{ 
# 3799
return (((step).p)[i]) / this->elemSize1(); 
# 3800
} 
# 3803
inline bool UMat::empty() const 
# 3804
{ 
# 3805
return (((u) == (0)) || (this->total() == (0))) || ((dims) == 0); 
# 3806
} 
# 3809
inline size_t UMat::total() const 
# 3810
{ 
# 3811
if ((dims) <= 2) { 
# 3812
return ((size_t)(rows)) * (cols); }  
# 3813
size_t p = (1); 
# 3814
for (int i = 0; i < (dims); i++) { 
# 3815
p *= ((size)[i]); }  
# 3816
return p; 
# 3817
} 
# 3822
inline UMat::UMat(UMat &&m) : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), allocator(m.allocator), usageFlags(m.usageFlags), u(m.u), offset(m.offset), size(&(rows)) 
# 3825
{ 
# 3826
if ((m.dims) <= 2) 
# 3827
{ 
# 3828
(step)[0] = (m.step)[0]; 
# 3829
(step)[1] = (m.step)[1]; 
# 3830
} else 
# 3832
{ 
# 3833
; 
# 3834
((step).p) = ((m.step).p); 
# 3835
((size).p) = ((m.size).p); 
# 3836
((m.step).p) = ((m.step).buf); 
# 3837
((m.size).p) = (&(m.rows)); 
# 3838
}  
# 3839
(m.flags) = (MAGIC_VAL); (m.dims) = ((m.rows) = ((m.cols) = 0)); 
# 3840
(m.allocator) = (__null); 
# 3841
(m.u) = (__null); 
# 3842
(m.offset) = (0); 
# 3843
} 
# 3846
inline UMat &UMat::operator=(UMat &&m) 
# 3847
{ 
# 3848
if (this == (&m)) { 
# 3849
return *this; }  
# 3850
this->release(); 
# 3851
(flags) = (m.flags); (dims) = (m.dims); (rows) = (m.rows); (cols) = (m.cols); 
# 3852
(allocator) = (m.allocator); (usageFlags) = (m.usageFlags); 
# 3853
(u) = (m.u); 
# 3854
(offset) = (m.offset); 
# 3855
if (((step).p) != ((step).buf)) 
# 3856
{ 
# 3857
fastFree((step).p); 
# 3858
((step).p) = ((step).buf); 
# 3859
((size).p) = (&(rows)); 
# 3860
}  
# 3861
if ((m.dims) <= 2) 
# 3862
{ 
# 3863
(step)[0] = (m.step)[0]; 
# 3864
(step)[1] = (m.step)[1]; 
# 3865
} else 
# 3867
{ 
# 3868
; 
# 3869
((step).p) = ((m.step).p); 
# 3870
((size).p) = ((m.size).p); 
# 3871
((m.step).p) = ((m.step).buf); 
# 3872
((m.size).p) = (&(m.rows)); 
# 3873
}  
# 3874
(m.flags) = (MAGIC_VAL); (m.dims) = ((m.rows) = ((m.cols) = 0)); 
# 3875
(m.allocator) = (__null); 
# 3876
(m.u) = (__null); 
# 3877
(m.offset) = (0); 
# 3878
return *this; 
# 3879
} 
# 3884
inline bool UMatData::hostCopyObsolete() const { return ((flags) & (HOST_COPY_OBSOLETE)) != 0; } 
# 3885
inline bool UMatData::deviceCopyObsolete() const { return ((flags) & (DEVICE_COPY_OBSOLETE)) != 0; } 
# 3886
inline bool UMatData::deviceMemMapped() const { return ((flags) & (DEVICE_MEM_MAPPED)) != 0; } 
# 3887
inline bool UMatData::copyOnMap() const { return ((flags) & (COPY_ON_MAP)) != 0; } 
# 3888
inline bool UMatData::tempUMat() const { return ((flags) & (TEMP_UMAT)) != 0; } 
# 3889
inline bool UMatData::tempCopiedUMat() const { return ((flags) & (TEMP_COPIED_UMAT)) == (TEMP_COPIED_UMAT); } 
# 3891
inline void UMatData::markDeviceMemMapped(bool flag) 
# 3892
{ 
# 3893
if (flag) { 
# 3894
(flags) |= (DEVICE_MEM_MAPPED); } else { 
# 3896
(flags) &= (~(DEVICE_MEM_MAPPED)); }  
# 3897
} 
# 3899
inline void UMatData::markHostCopyObsolete(bool flag) 
# 3900
{ 
# 3901
if (flag) { 
# 3902
(flags) |= (HOST_COPY_OBSOLETE); } else { 
# 3904
(flags) &= (~(HOST_COPY_OBSOLETE)); }  
# 3905
} 
# 3906
inline void UMatData::markDeviceCopyObsolete(bool flag) 
# 3907
{ 
# 3908
if (flag) { 
# 3909
(flags) |= (DEVICE_COPY_OBSOLETE); } else { 
# 3911
(flags) &= (~(DEVICE_COPY_OBSOLETE)); }  
# 3912
} 
# 3914
inline UMatDataAutoLock::UMatDataAutoLock(UMatData *_u) : u(_u) { (u)->lock(); } 
# 3915
inline UMatDataAutoLock::~UMatDataAutoLock() { (u)->unlock(); } 
# 3919
}
# 97 "/usr/include/opencv2/core/persistence.hpp" 3
typedef struct CvFileStorage CvFileStorage; 
# 98
typedef struct CvFileNode CvFileNode; 
# 99
typedef struct CvMat CvMat; 
# 100
typedef struct CvMatND CvMatND; 
# 107
namespace cv { 
# 301 "/usr/include/opencv2/core/persistence.hpp" 3
class __attribute((visibility("default"))) FileNode; 
# 302
class __attribute((visibility("default"))) FileNodeIterator; 
# 307
class __attribute((visibility("default"))) FileStorage { 
# 311
public: enum Mode { 
# 313
READ, 
# 314
WRITE, 
# 315
APPEND, 
# 316
MEMORY = 4, 
# 318
FORMAT_MASK = 56, 
# 319
FORMAT_AUTO = 0, 
# 320
FORMAT_XML = 8, 
# 321
FORMAT_YAML = 16, 
# 322
FORMAT_JSON = 24, 
# 324
BASE64 = 64, 
# 325
WRITE_BASE64
# 326
}; 
# 328
enum { 
# 329
UNDEFINED, 
# 330
VALUE_EXPECTED, 
# 331
NAME_EXPECTED, 
# 332
INSIDE_MAP = 4
# 333
}; 
# 340
FileStorage(); 
# 352 "/usr/include/opencv2/core/persistence.hpp" 3
FileStorage(const String & source, int flags, const String & encoding = String()); 
# 355
FileStorage(CvFileStorage * fs, bool owning = true); 
# 358
virtual ~FileStorage(); 
# 375 "/usr/include/opencv2/core/persistence.hpp" 3
virtual bool open(const String & filename, int flags, const String & encoding = String()); 
# 382
virtual bool isOpened() const; 
# 388
virtual void release(); 
# 395
virtual String releaseAndGetString(); 
# 400
inline FileNode getFirstTopLevelNode() const; 
# 407
FileNode root(int streamidx = 0) const; 
# 413
FileNode operator[](const String & nodename) const; 
# 416
FileNode operator[](const char * nodename) const; 
# 421
CvFileStorage *operator*() { return (fs).get(); } 
# 424
const CvFileStorage *operator*() const { return (fs).get(); } 
# 434 "/usr/include/opencv2/core/persistence.hpp" 3
void writeRaw(const String & fmt, const uchar * vec, size_t len); 
# 441
void writeObj(const String & name, const void * obj); 
# 448
void write(const String & name, double val); 
# 450
void write(const String & name, const String & val); 
# 452
void write(const String & name, InputArray val); 
# 462 "/usr/include/opencv2/core/persistence.hpp" 3
void writeComment(const String & comment, bool append = false); 
# 468
static String getDefaultObjectName(const String & filename); 
# 473
int getFormat() const; 
# 475
Ptr< CvFileStorage>  fs; 
# 476
String elname; 
# 477
std::vector< char>  structs; 
# 478
int state; 
# 479
}; 
# 481
template<> __attribute((visibility("default"))) void DefaultDeleter< CvFileStorage> ::operator()(CvFileStorage * obj) const; 
# 495 "/usr/include/opencv2/core/persistence.hpp" 3
class __attribute((visibility("default"))) FileNode { 
# 499
public: enum Type { 
# 501
NONE, 
# 502
INT, 
# 503
REAL, 
# 504
FLOAT = 2, 
# 505
STR, 
# 506
STRING = 3, 
# 507
REF, 
# 508
SEQ, 
# 509
MAP, 
# 510
TYPE_MASK, 
# 511
FLOW, 
# 512
USER = 16, 
# 513
EMPTY = 32, 
# 514
NAMED = 64
# 515
}; 
# 521
inline FileNode(); 
# 527
inline FileNode(const CvFileStorage * fs, const CvFileNode * node); 
# 532
inline FileNode(const FileNode & node); 
# 538
FileNode operator[](const String & nodename) const; 
# 543
FileNode operator[](const char * nodename) const; 
# 548
FileNode operator[](int i) const; 
# 553
int type() const; 
# 556
inline bool empty() const; 
# 558
inline bool isNone() const; 
# 560
inline bool isSeq() const; 
# 562
inline bool isMap() const; 
# 564
inline bool isInt() const; 
# 566
inline bool isReal() const; 
# 568
inline bool isString() const; 
# 570
bool isNamed() const; 
# 572
String name() const; 
# 574
size_t size() const; 
# 576
inline operator int() const; 
# 578
inline operator float() const; 
# 580
inline operator double() const; 
# 582
inline operator String() const; 
# 583
inline operator std::__cxx11::string() const; 
# 586
inline CvFileNode *operator*(); 
# 588
inline const CvFileNode *operator*() const; 
# 591
inline FileNodeIterator begin() const; 
# 593
inline FileNodeIterator end() const; 
# 603 "/usr/include/opencv2/core/persistence.hpp" 3
inline void readRaw(const String & fmt, uchar * vec, size_t len) const; 
# 606
void *readObj() const; 
# 609
inline double real() const; 
# 611
inline String string() const; 
# 613
inline Mat mat() const; 
# 616
const CvFileStorage *fs; 
# 617
const CvFileNode *node; 
# 618
}; 
# 626
class __attribute((visibility("default"))) FileNodeIterator { 
# 634
public: FileNodeIterator(); 
# 641
FileNodeIterator(const CvFileStorage * fs, const CvFileNode * node, size_t ofs = 0); 
# 646
FileNodeIterator(const FileNodeIterator & it); 
# 649
inline FileNode operator*() const; 
# 651
inline FileNode operator->() const; 
# 654
FileNodeIterator &operator++(); 
# 656
FileNodeIterator operator++(int); 
# 658
FileNodeIterator &operator--(); 
# 660
FileNodeIterator operator--(int); 
# 662
FileNodeIterator &operator+=(int ofs); 
# 664
FileNodeIterator &operator-=(int ofs); 
# 674 "/usr/include/opencv2/core/persistence.hpp" 3
FileNodeIterator &readRaw(const String & fmt, uchar * vec, size_t maxCount = (size_t)2147483647); 
# 677
struct SeqReader { 
# 679
int header_size; 
# 680
void *seq; 
# 681
void *block; 
# 682
schar *ptr; 
# 683
schar *block_min; 
# 684
schar *block_max; 
# 685
int delta_index; 
# 686
schar *prev_elem; 
# 687
}; 
# 689
const CvFileStorage *fs; 
# 690
const CvFileNode *container; 
# 691
SeqReader reader; 
# 692
size_t remaining; 
# 693
}; 
# 702 "/usr/include/opencv2/core/persistence.hpp" 3
__attribute((visibility("default"))) void write(FileStorage & fs, const String & name, int value); 
# 703
__attribute((visibility("default"))) void write(FileStorage & fs, const String & name, float value); 
# 704
__attribute((visibility("default"))) void write(FileStorage & fs, const String & name, double value); 
# 705
__attribute((visibility("default"))) void write(FileStorage & fs, const String & name, const String & value); 
# 706
__attribute((visibility("default"))) void write(FileStorage & fs, const String & name, const Mat & value); 
# 707
__attribute((visibility("default"))) void write(FileStorage & fs, const String & name, const SparseMat & value); 
# 709
__attribute((visibility("default"))) void write(FileStorage & fs, const String & name, const std::vector< KeyPoint>  & value); 
# 710
__attribute((visibility("default"))) void write(FileStorage & fs, const String & name, const std::vector< DMatch>  & value); 
# 713
__attribute((visibility("default"))) void writeScalar(FileStorage & fs, int value); 
# 714
__attribute((visibility("default"))) void writeScalar(FileStorage & fs, float value); 
# 715
__attribute((visibility("default"))) void writeScalar(FileStorage & fs, double value); 
# 716
__attribute((visibility("default"))) void writeScalar(FileStorage & fs, const String & value); 
# 723
__attribute((visibility("default"))) void read(const FileNode & node, int & value, int default_value); 
# 724
__attribute((visibility("default"))) void read(const FileNode & node, float & value, float default_value); 
# 725
__attribute((visibility("default"))) void read(const FileNode & node, double & value, double default_value); 
# 726
__attribute((visibility("default"))) void read(const FileNode & node, String & value, const String & default_value); 
# 727
__attribute((visibility("default"))) void read(const FileNode & node, std::__cxx11::string & value, const std::__cxx11::string & default_value); 
# 728
__attribute((visibility("default"))) void read(const FileNode & node, Mat & mat, const Mat & default_mat = Mat()); 
# 729
__attribute((visibility("default"))) void read(const FileNode & node, SparseMat & mat, const SparseMat & default_mat = SparseMat()); 
# 731
__attribute((visibility("default"))) void read(const FileNode & node, std::vector< KeyPoint>  & keypoints); 
# 732
__attribute((visibility("default"))) void read(const FileNode & node, std::vector< DMatch>  & matches); 
# 734
__attribute((visibility("default"))) void read(const FileNode & node, KeyPoint & value, const KeyPoint & default_value); 
# 735
__attribute((visibility("default"))) void read(const FileNode & node, DMatch & value, const DMatch & default_value); 
# 737
template< class _Tp> static inline void read(const FileNode &node, Point_< _Tp>  &value, const Point_< _Tp>  &default_value) 
# 738
{ 
# 739
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 740
value = (((temp.size()) != 2) ? default_value : Point_< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]))); 
# 741
} 
# 743
template< class _Tp> static inline void read(const FileNode &node, Point3_< _Tp>  &value, const Point3_< _Tp>  &default_value) 
# 744
{ 
# 745
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 746
value = (((temp.size()) != 3) ? default_value : Point3_< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]), saturate_cast< _Tp> (temp[2]))); 
# 748
} 
# 750
template< class _Tp> static inline void read(const FileNode &node, Size_< _Tp>  &value, const Size_< _Tp>  &default_value) 
# 751
{ 
# 752
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 753
value = (((temp.size()) != 2) ? default_value : Size_< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]))); 
# 754
} 
# 756
template< class _Tp> static inline void read(const FileNode &node, Complex< _Tp>  &value, const Complex< _Tp>  &default_value) 
# 757
{ 
# 758
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 759
value = (((temp.size()) != 2) ? default_value : Complex< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]))); 
# 760
} 
# 762
template< class _Tp> static inline void read(const FileNode &node, Rect_< _Tp>  &value, const Rect_< _Tp>  &default_value) 
# 763
{ 
# 764
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 765
value = (((temp.size()) != 4) ? default_value : Rect_< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]), saturate_cast< _Tp> (temp[2]), saturate_cast< _Tp> (temp[3]))); 
# 767
} 
# 769
template< class _Tp, int cn> static inline void read(const FileNode &node, Vec< _Tp, cn>  &value, const Vec< _Tp, cn>  &default_value) 
# 770
{ 
# 771
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 772
value = (((temp.size()) != cn) ? default_value : ((Vec< _Tp, cn> )(&(temp[0])))); 
# 773
} 
# 775
template< class _Tp> static inline void read(const FileNode &node, Scalar_< _Tp>  &value, const Scalar_< _Tp>  &default_value) 
# 776
{ 
# 777
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 778
value = (((temp.size()) != 4) ? default_value : Scalar_< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]), saturate_cast< _Tp> (temp[2]), saturate_cast< _Tp> (temp[3]))); 
# 780
} 
# 782
static inline void read(const FileNode &node, Range &value, const Range &default_value) 
# 783
{ 
# 784
Point2i temp(value.start, value.end); const Point2i default_temp = Point2i(default_value.start, default_value.end); 
# 785
read(node, temp, default_temp); 
# 786
(value.start) = (temp.x); (value.end) = (temp.y); 
# 787
} 
# 794
__attribute((visibility("default"))) FileStorage &operator<<(FileStorage & fs, const String & str); 
# 798
namespace internal { 
# 800
class __attribute((visibility("default"))) WriteStructContext { 
# 803
public: WriteStructContext(FileStorage & _fs, const String & name, int flags, const String & typeName = String()); 
# 804
~WriteStructContext(); 
# 806
private: FileStorage *fs; 
# 807
}; 
# 809
template< class _Tp, int numflag> class VecWriterProxy { 
# 812
public: VecWriterProxy(FileStorage *_fs) : fs(_fs) { } 
# 813
void operator()(const std::vector< _Tp>  &vec) const 
# 814
{ 
# 815
size_t count = (vec.size()); 
# 816
for (size_t i = (0); i < count; i++) { 
# 817
write(*(fs), vec[i]); }  
# 818
} 
# 820
private: FileStorage *fs; 
# 821
}; 
# 823
template< class _Tp> class VecWriterProxy< _Tp, 1>  { 
# 826
public: VecWriterProxy(FileStorage *_fs) : fs(_fs) { } 
# 827
void operator()(const std::vector< _Tp>  &vec) const 
# 828
{ 
# 829
int _fmt = (traits::SafeFmt< _Tp> ::fmt); 
# 830
char fmt[] = {(char)((_fmt >> 8) + ('1')), (char)_fmt, '\000'}; 
# 831
(fs)->writeRaw(fmt, (!(vec.empty())) ? (uchar *)(&(vec[0])) : (0), (vec.size()) * sizeof(_Tp)); 
# 832
} 
# 834
private: FileStorage *fs; 
# 835
}; 
# 837
template< class _Tp, int numflag> class VecReaderProxy { 
# 840
public: VecReaderProxy(FileNodeIterator *_it) : it(_it) { } 
# 841
void operator()(std::vector< _Tp>  &vec, size_t count) const 
# 842
{ 
# 843
count = std::min(count, (it)->remaining); 
# 844
(vec.resize(count)); 
# 845
for (size_t i = (0); i < count; (i++), (++(*(it)))) { 
# 846
read((*(*(it))), vec[i], _Tp()); }  
# 847
} 
# 849
private: FileNodeIterator *it; 
# 850
}; 
# 852
template< class _Tp> class VecReaderProxy< _Tp, 1>  { 
# 855
public: VecReaderProxy(FileNodeIterator *_it) : it(_it) { } 
# 856
void operator()(std::vector< _Tp>  &vec, size_t count) const 
# 857
{ 
# 858
size_t remaining = (it)->remaining; 
# 859
size_t cn = (DataType< _Tp> ::channels); 
# 860
int _fmt = (traits::SafeFmt< _Tp> ::fmt); 
# 861
char fmt[] = {(char)((_fmt >> 8) + ('1')), (char)_fmt, '\000'}; 
# 862
size_t remaining1 = remaining / cn; 
# 863
count = ((count < remaining1) ? count : remaining1); 
# 864
(vec.resize(count)); 
# 865
(it)->readRaw(fmt, (!(vec.empty())) ? (uchar *)(&(vec[0])) : (0), count * sizeof(_Tp)); 
# 866
} 
# 868
private: FileNodeIterator *it; 
# 869
}; 
# 871
}
# 878
template< class _Tp> static inline void 
# 879
write(FileStorage &fs, const _Tp &value) 
# 880
{ 
# 881
write(fs, String(), value); 
# 882
} 
# 885
template<> inline void write(FileStorage &fs, const int &value) 
# 886
{ 
# 887
writeScalar(fs, value); 
# 888
} 
# 891
template<> inline void write(FileStorage &fs, const float &value) 
# 892
{ 
# 893
writeScalar(fs, value); 
# 894
} 
# 897
template<> inline void write(FileStorage &fs, const double &value) 
# 898
{ 
# 899
writeScalar(fs, value); 
# 900
} 
# 903
template<> inline void write(FileStorage &fs, const String &value) 
# 904
{ 
# 905
writeScalar(fs, value); 
# 906
} 
# 908
template< class _Tp> static inline void 
# 909
write(FileStorage &fs, const Point_< _Tp>  &pt) 
# 910
{ 
# 911
write(fs, (pt.x)); 
# 912
write(fs, (pt.y)); 
# 913
} 
# 915
template< class _Tp> static inline void 
# 916
write(FileStorage &fs, const Point3_< _Tp>  &pt) 
# 917
{ 
# 918
write(fs, (pt.x)); 
# 919
write(fs, (pt.y)); 
# 920
write(fs, (pt.z)); 
# 921
} 
# 923
template< class _Tp> static inline void 
# 924
write(FileStorage &fs, const Size_< _Tp>  &sz) 
# 925
{ 
# 926
write(fs, (sz.width)); 
# 927
write(fs, (sz.height)); 
# 928
} 
# 930
template< class _Tp> static inline void 
# 931
write(FileStorage &fs, const Complex< _Tp>  &c) 
# 932
{ 
# 933
write(fs, (c.re)); 
# 934
write(fs, (c.im)); 
# 935
} 
# 937
template< class _Tp> static inline void 
# 938
write(FileStorage &fs, const Rect_< _Tp>  &r) 
# 939
{ 
# 940
write(fs, (r.x)); 
# 941
write(fs, (r.y)); 
# 942
write(fs, (r.width)); 
# 943
write(fs, (r.height)); 
# 944
} 
# 946
template< class _Tp, int cn> static inline void 
# 947
write(FileStorage &fs, const Vec< _Tp, cn>  &v) 
# 948
{ 
# 949
for (int i = 0; i < cn; i++) { 
# 950
write(fs, (v.val)[i]); }  
# 951
} 
# 953
template< class _Tp> static inline void 
# 954
write(FileStorage &fs, const Scalar_< _Tp>  &s) 
# 955
{ 
# 956
write(fs, (s.val)[0]); 
# 957
write(fs, (s.val)[1]); 
# 958
write(fs, (s.val)[2]); 
# 959
write(fs, (s.val)[3]); 
# 960
} 
# 963
static inline void write(FileStorage &fs, const Range &r) 
# 964
{ 
# 965
write(fs, r.start); 
# 966
write(fs, r.end); 
# 967
} 
# 969
template< class _Tp> static inline void 
# 970
write(FileStorage &fs, const std::vector< _Tp>  &vec) 
# 971
{ 
# 972
internal::VecWriterProxy< _Tp, traits::SafeFmt< _Tp> ::fmt != 0>  w(&fs); 
# 973
w(vec); 
# 974
} 
# 976
template< class _Tp> static inline void 
# 977
write(FileStorage &fs, const String &name, const Point_< _Tp>  &pt) 
# 978
{ 
# 979
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 980
write(fs, pt); 
# 981
} 
# 983
template< class _Tp> static inline void 
# 984
write(FileStorage &fs, const String &name, const Point3_< _Tp>  &pt) 
# 985
{ 
# 986
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 987
write(fs, pt); 
# 988
} 
# 990
template< class _Tp> static inline void 
# 991
write(FileStorage &fs, const String &name, const Size_< _Tp>  &sz) 
# 992
{ 
# 993
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 994
write(fs, sz); 
# 995
} 
# 997
template< class _Tp> static inline void 
# 998
write(FileStorage &fs, const String &name, const Complex< _Tp>  &c) 
# 999
{ 
# 1000
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1001
write(fs, c); 
# 1002
} 
# 1004
template< class _Tp> static inline void 
# 1005
write(FileStorage &fs, const String &name, const Rect_< _Tp>  &r) 
# 1006
{ 
# 1007
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1008
write(fs, r); 
# 1009
} 
# 1011
template< class _Tp, int cn> static inline void 
# 1012
write(FileStorage &fs, const String &name, const Vec< _Tp, cn>  &v) 
# 1013
{ 
# 1014
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1015
write(fs, v); 
# 1016
} 
# 1018
template< class _Tp> static inline void 
# 1019
write(FileStorage &fs, const String &name, const Scalar_< _Tp>  &s) 
# 1020
{ 
# 1021
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1022
write(fs, s); 
# 1023
} 
# 1026
static inline void write(FileStorage &fs, const String &name, const Range &r) 
# 1027
{ 
# 1028
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1029
write(fs, r); 
# 1030
} 
# 1033
static inline void write(FileStorage &fs, const String &name, const KeyPoint &kpt) 
# 1034
{ 
# 1035
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1036
write(fs, (kpt.pt).x); 
# 1037
write(fs, (kpt.pt).y); 
# 1038
write(fs, kpt.size); 
# 1039
write(fs, kpt.angle); 
# 1040
write(fs, kpt.response); 
# 1041
write(fs, kpt.octave); 
# 1042
write(fs, kpt.class_id); 
# 1043
} 
# 1046
static inline void write(FileStorage &fs, const String &name, const DMatch &m) 
# 1047
{ 
# 1048
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1049
write(fs, m.queryIdx); 
# 1050
write(fs, m.trainIdx); 
# 1051
write(fs, m.imgIdx); 
# 1052
write(fs, m.distance); 
# 1053
} 
# 1055
template< class _Tp> static inline void 
# 1056
write(FileStorage &fs, const String &name, const std::vector< _Tp>  &vec) 
# 1057
{ 
# 1058
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + ((traits::SafeFmt< _Tp> ::fmt != 0) ? FileNode::FLOW : 0)); 
# 1059
write(fs, vec); 
# 1060
} 
# 1062
template< class _Tp> static inline void 
# 1063
write(FileStorage &fs, const String &name, const std::vector< std::vector< _Tp> >  &vec) 
# 1064
{ 
# 1065
internal::WriteStructContext ws(fs, name, FileNode::SEQ); 
# 1066
for (size_t i = (0); i < (vec.size()); i++) 
# 1067
{ 
# 1068
internal::WriteStructContext ws_(fs, name, (FileNode::SEQ) + ((traits::SafeFmt< _Tp> ::fmt != 0) ? FileNode::FLOW : 0)); 
# 1069
write(fs, vec[i]); 
# 1070
}  
# 1071
} 
# 1076
static inline void write(FileStorage &fs, const KeyPoint &kpt) { write(fs, String(), kpt); } 
# 1077
static inline void write(FileStorage &fs, const DMatch &m) { write(fs, String(), m); } 
# 1078
static inline void write(FileStorage &fs, const std::vector< KeyPoint>  &vec) 
# 1079
{ 
# 1080
internal::VecWriterProxy< KeyPoint, 0>  w(&fs); 
# 1081
w(vec); 
# 1082
} 
# 1083
static inline void write(FileStorage &fs, const std::vector< DMatch>  &vec) 
# 1084
{ 
# 1085
internal::VecWriterProxy< DMatch, 0>  w(&fs); 
# 1086
w(vec); 
# 1088
} 
# 1097
static inline void read(const FileNode &node, bool &value, bool default_value) 
# 1098
{ 
# 1099
int temp; 
# 1100
read(node, temp, (int)default_value); 
# 1101
value = (temp != 0); 
# 1102
} 
# 1105
static inline void read(const FileNode &node, uchar &value, uchar default_value) 
# 1106
{ 
# 1107
int temp; 
# 1108
read(node, temp, (int)default_value); 
# 1109
value = saturate_cast< unsigned char> (temp); 
# 1110
} 
# 1113
static inline void read(const FileNode &node, schar &value, schar default_value) 
# 1114
{ 
# 1115
int temp; 
# 1116
read(node, temp, (int)default_value); 
# 1117
value = saturate_cast< signed char> (temp); 
# 1118
} 
# 1121
static inline void read(const FileNode &node, ushort &value, ushort default_value) 
# 1122
{ 
# 1123
int temp; 
# 1124
read(node, temp, (int)default_value); 
# 1125
value = saturate_cast< unsigned short> (temp); 
# 1126
} 
# 1129
static inline void read(const FileNode &node, short &value, short default_value) 
# 1130
{ 
# 1131
int temp; 
# 1132
read(node, temp, (int)default_value); 
# 1133
value = saturate_cast< short> (temp); 
# 1134
} 
# 1136
template< class _Tp> static inline void 
# 1137
read(FileNodeIterator &it, std::vector< _Tp>  &vec, size_t maxCount = (size_t)2147483647) 
# 1138
{ 
# 1139
internal::VecReaderProxy< _Tp, traits::SafeFmt< _Tp> ::fmt != 0>  r(&it); 
# 1140
r(vec, maxCount); 
# 1141
} 
# 1143
template< class _Tp> static inline void 
# 1144
read(const FileNode &node, std::vector< _Tp>  &vec, const std::vector< _Tp>  &default_value = std::vector< _Tp> ()) 
# 1145
{ 
# 1146
if (!(node.node)) { 
# 1147
vec = default_value; } else 
# 1149
{ 
# 1150
FileNodeIterator it = node.begin(); 
# 1151
read(it, vec); 
# 1152
}  
# 1153
} 
# 1156
static inline void read(const FileNode &node, std::vector< KeyPoint>  &vec, const std::vector< KeyPoint>  &default_value) 
# 1157
{ 
# 1158
if (!(node.node)) { 
# 1159
(vec = default_value); } else { 
# 1161
read(node, vec); }  
# 1162
} 
# 1165
static inline void read(const FileNode &node, std::vector< DMatch>  &vec, const std::vector< DMatch>  &default_value) 
# 1166
{ 
# 1167
if (!(node.node)) { 
# 1168
(vec = default_value); } else { 
# 1170
read(node, vec); }  
# 1171
} 
# 1180 "/usr/include/opencv2/core/persistence.hpp" 3
template< class _Tp> static inline FileStorage &
# 1181
operator<<(FileStorage &fs, const _Tp &value) 
# 1182
{ 
# 1183
if (!fs.isOpened()) { 
# 1184
return fs; }  
# 1185
if ((fs.state) == ((FileStorage::NAME_EXPECTED) + (FileStorage::INSIDE_MAP))) { 
# 1186
cv::error(Error::StsError, "No element name has been given", __func__, "/usr/include/opencv2/core/persistence.hpp", 1186); }  
# 1187
write(fs, fs.elname, value); 
# 1188
if ((fs.state) & (FileStorage::INSIDE_MAP)) { 
# 1189
(fs.state) = ((FileStorage::NAME_EXPECTED) + (FileStorage::INSIDE_MAP)); }  
# 1190
return fs; 
# 1191
} 
# 1196
static inline FileStorage &operator<<(FileStorage &fs, const char *str) 
# 1197
{ 
# 1198
return (fs << ((String)(str))); 
# 1199
} 
# 1204
static inline FileStorage &operator<<(FileStorage &fs, char *value) 
# 1205
{ 
# 1206
return (fs << ((String)(value))); 
# 1207
} 
# 1216 "/usr/include/opencv2/core/persistence.hpp" 3
template< class _Tp> static inline FileNodeIterator &
# 1217
operator>>(FileNodeIterator &it, _Tp &value) 
# 1218
{ 
# 1219
read((*it), value, _Tp()); 
# 1220
return (++it); 
# 1221
} 
# 1225
template< class _Tp> static inline FileNodeIterator &
# 1226
operator>>(FileNodeIterator &it, std::vector< _Tp>  &vec) 
# 1227
{ 
# 1228
internal::VecReaderProxy< _Tp, traits::SafeFmt< _Tp> ::fmt != 0>  r(&it); 
# 1229
r(vec, (size_t)2147483647); 
# 1230
return it; 
# 1231
} 
# 1240 "/usr/include/opencv2/core/persistence.hpp" 3
template< class _Tp> static inline void 
# 1241
operator>>(const FileNode &n, _Tp &value) 
# 1242
{ 
# 1243
read(n, value, _Tp()); 
# 1244
} 
# 1248
template< class _Tp> static inline void 
# 1249
operator>>(const FileNode &n, std::vector< _Tp>  &vec) 
# 1250
{ 
# 1251
FileNodeIterator it = n.begin(); 
# 1252
it >> vec; 
# 1253
} 
# 1259
static inline void operator>>(const FileNode &n, KeyPoint &kpt) 
# 1260
{ 
# 1261
FileNodeIterator it = n.begin(); 
# 1262
(((((((((((((it >> ((kpt.pt).x))) >> ((kpt.pt).y))) >> (kpt.size))) >> (kpt.angle))) >> (kpt.response))) >> (kpt.octave))) >> (kpt.class_id)); 
# 1263
} 
# 1267
static inline void operator>>(const FileNode &n, std::vector< KeyPoint>  &vec) 
# 1268
{ 
# 1269
read(n, vec); 
# 1270
} 
# 1272
static inline void operator>>(const FileNode &n, std::vector< DMatch>  &vec) 
# 1273
{ 
# 1274
read(n, vec); 
# 1275
} 
# 1282
static inline void operator>>(const FileNode &n, DMatch &m) 
# 1283
{ 
# 1284
FileNodeIterator it = n.begin(); 
# 1285
(((((((it >> (m.queryIdx))) >> (m.trainIdx))) >> (m.imgIdx))) >> (m.distance)); 
# 1286
} 
# 1294
static inline bool operator==(const FileNodeIterator &it1, const FileNodeIterator &it2) 
# 1295
{ 
# 1296
return ((it1.fs) == (it2.fs)) && ((it1.container) == (it2.container)) && (((it1.reader).ptr) == ((it2.reader).ptr)) && ((it1.remaining) == (it2.remaining)); 
# 1298
} 
# 1301
static inline bool operator!=(const FileNodeIterator &it1, const FileNodeIterator &it2) 
# 1302
{ 
# 1303
return !((it1 == it2)); 
# 1304
} 
# 1307
static inline ptrdiff_t operator-(const FileNodeIterator &it1, const FileNodeIterator &it2) 
# 1308
{ 
# 1309
return (it2.remaining) - (it1.remaining); 
# 1310
} 
# 1313
static inline bool operator<(const FileNodeIterator &it1, const FileNodeIterator &it2) 
# 1314
{ 
# 1315
return (it1.remaining) > (it2.remaining); 
# 1316
} 
# 1322
inline FileNode FileStorage::getFirstTopLevelNode() const { FileNode r = this->root(); FileNodeIterator it = r.begin(); return (((it != (r.end()))) ? (*it) : FileNode()); } 
# 1323
inline FileNode::FileNode() : fs((0)), node((0)) { } 
# 1324
inline FileNode::FileNode(const CvFileStorage *_fs, const CvFileNode *_node) : fs(_fs), node(_node) { } 
# 1325
inline FileNode::FileNode(const FileNode &_node) : fs(_node.fs), node(_node.node) { } 
# 1326
inline bool FileNode::empty() const { return (node) == (0); } 
# 1327
inline bool FileNode::isNone() const { return this->type() == (NONE); } 
# 1328
inline bool FileNode::isSeq() const { return this->type() == (SEQ); } 
# 1329
inline bool FileNode::isMap() const { return this->type() == (MAP); } 
# 1330
inline bool FileNode::isInt() const { return this->type() == (INT); } 
# 1331
inline bool FileNode::isReal() const { return this->type() == (REAL); } 
# 1332
inline bool FileNode::isString() const { return this->type() == (STR); } 
# 1333
inline CvFileNode *FileNode::operator*() { return (CvFileNode *)(node); } 
# 1334
inline const CvFileNode *FileNode::operator*() const { return node; } 
# 1335
inline FileNode::operator int() const { int value; read(*this, value, 0); return value; } 
# 1336
inline FileNode::operator float() const { float value; read(*this, value, (0.0F)); return value; } 
# 1337
inline FileNode::operator double() const { double value; read(*this, value, (0.0)); return value; } 
# 1338
inline FileNode::operator String() const { String value; read(*this, value, value); return value; } 
# 1339
inline double FileNode::real() const { return (double)(*this); } 
# 1340
inline String FileNode::string() const { return ((String)(*this)); } 
# 1341
inline Mat FileNode::mat() const { Mat value; read(*this, value, value); return value; } 
# 1342
inline FileNodeIterator FileNode::begin() const { return FileNodeIterator(fs, node); } 
# 1343
inline FileNodeIterator FileNode::end() const { return FileNodeIterator(fs, node, this->size()); } 
# 1344
inline void FileNode::readRaw(const String &fmt, uchar *vec, size_t len) const { (this->begin()).readRaw(fmt, vec, len); } 
# 1345
inline FileNode FileNodeIterator::operator*() const { return FileNode(fs, (const CvFileNode *)((const void *)((reader).ptr))); } 
# 1346
inline FileNode FileNodeIterator::operator->() const { return FileNode(fs, (const CvFileNode *)((const void *)((reader).ptr))); } 
# 1347
inline String::String(const FileNode &fn) : cstr_((0)), len_((0)) { read(fn, *this, *this); } 
# 1352
__attribute((visibility("default"))) void cvStartWriteRawData_Base64(CvFileStorage * fs, const char * name, int len, const char * dt); 
# 1354
__attribute((visibility("default"))) void cvWriteRawData_Base64(CvFileStorage * fs, const void * _data, int len); 
# 1356
__attribute((visibility("default"))) void cvEndWriteRawData_Base64(CvFileStorage * fs); 
# 1358
__attribute((visibility("default"))) void cvWriteMat_Base64(CvFileStorage * fs, const char * name, const CvMat * mat); 
# 1360
__attribute((visibility("default"))) void cvWriteMatND_Base64(CvFileStorage * fs, const char * name, const CvMatND * mat); 
# 1362
}
# 98 "/usr/include/opencv2/core.hpp" 3
namespace cv { 
# 110 "/usr/include/opencv2/core.hpp" 3
class __attribute((visibility("default"))) Exception : public std::exception { 
# 116
public: Exception(); 
# 121
Exception(int _code, const String & _err, const String & _func, const String & _file, int _line); 
# 122
virtual ~Exception() throw(); 
# 127
virtual const char *what() const throw(); 
# 128
void formatMessage(); 
# 130
String msg; 
# 132
int code; 
# 133
String err; 
# 134
String func; 
# 135
String file; 
# 136
int line; 
# 137
}; 
# 147 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void error(const Exception & exc); 
# 149
enum SortFlags { SORT_EVERY_ROW, 
# 150
SORT_EVERY_COLUMN, 
# 153
SORT_ASCENDING = 0, 
# 155
SORT_DESCENDING = 16
# 158
}; 
# 166
enum CovarFlags { 
# 174
COVAR_SCRAMBLED, 
# 179
COVAR_NORMAL, 
# 185
COVAR_USE_AVG, 
# 190
COVAR_SCALE = 4, 
# 194
COVAR_ROWS = 8, 
# 198
COVAR_COLS = 16
# 199
}; 
# 202
enum KmeansFlags { 
# 204
KMEANS_RANDOM_CENTERS, 
# 206
KMEANS_PP_CENTERS = 2, 
# 211
KMEANS_USE_INITIAL_LABELS = 1
# 212
}; 
# 215
enum LineTypes { 
# 216
FILLED = (-1), 
# 217
LINE_4 = 4, 
# 218
LINE_8 = 8, 
# 219
LINE_AA = 16
# 220
}; 
# 224
enum HersheyFonts { 
# 225
FONT_HERSHEY_SIMPLEX, 
# 226
FONT_HERSHEY_PLAIN, 
# 227
FONT_HERSHEY_DUPLEX, 
# 228
FONT_HERSHEY_COMPLEX, 
# 229
FONT_HERSHEY_TRIPLEX, 
# 230
FONT_HERSHEY_COMPLEX_SMALL, 
# 231
FONT_HERSHEY_SCRIPT_SIMPLEX, 
# 232
FONT_HERSHEY_SCRIPT_COMPLEX, 
# 233
FONT_ITALIC = 16
# 234
}; 
# 236
enum ReduceTypes { REDUCE_SUM, 
# 237
REDUCE_AVG, 
# 238
REDUCE_MAX, 
# 239
REDUCE_MIN
# 240
}; 
# 245
__attribute((visibility("default"))) void swap(Mat & a, Mat & b); 
# 247
__attribute((visibility("default"))) void swap(UMat & a, UMat & b); 
# 275 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) int borderInterpolate(int p, int len, int borderType); 
# 323 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar & value = Scalar()); 
# 363 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void add(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray(), int dtype = -1); 
# 403 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray(), int dtype = -1); 
# 428 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void multiply(InputArray src1, InputArray src2, OutputArray dst, double scale = 1, int dtype = -1); 
# 451 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void divide(InputArray src1, InputArray src2, OutputArray dst, double scale = 1, int dtype = -1); 
# 455
__attribute((visibility("default"))) void divide(double scale, InputArray src2, OutputArray dst, int dtype = -1); 
# 476 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst); 
# 503 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype = -1); 
# 531 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void convertScaleAbs(InputArray src, OutputArray dst, double alpha = 1, double beta = 0); 
# 543 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void convertFp16(InputArray src, OutputArray dst); 
# 559 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void LUT(InputArray src, InputArray lut, OutputArray dst); 
# 568 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) Scalar sum(InputArray src); 
# 577 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) int countNonZero(InputArray src); 
# 605 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void findNonZero(InputArray src, OutputArray idx); 
# 618 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) Scalar mean(InputArray src, InputArray mask = noArray()); 
# 640 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask = noArray()); 
# 679 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) double norm(InputArray src1, int normType = NORM_L2, InputArray mask = noArray()); 
# 692 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) double norm(InputArray src1, InputArray src2, int normType = NORM_L2, InputArray mask = noArray()); 
# 698
__attribute((visibility("default"))) double norm(const SparseMat & src, int normType); 
# 716 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) double PSNR(InputArray src1, InputArray src2); 
# 723
__attribute((visibility("default"))) void batchDistance(InputArray src1, InputArray src2, OutputArray dist, int dtype, OutputArray nidx, int normType = NORM_L2, int K = 0, InputArray mask = noArray(), int update = 0, bool crosscheck = false); 
# 787 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void normalize(InputArray src, InputOutputArray dst, double alpha = 1, double beta = 0, int norm_type = NORM_L2, int dtype = -1, InputArray mask = noArray()); 
# 797 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void normalize(const SparseMat & src, SparseMat & dst, double alpha, int normType); 
# 817 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void minMaxLoc(InputArray src, double * minVal, double * maxVal = 0, Point * minLoc = 0, Point * maxLoc = 0, InputArray mask = noArray()); 
# 845 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void minMaxIdx(InputArray src, double * minVal, double * maxVal = 0, int * minIdx = 0, int * maxIdx = 0, InputArray mask = noArray()); 
# 857 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void minMaxLoc(const SparseMat & a, double * minVal, double * maxVal, int * minIdx = 0, int * maxIdx = 0); 
# 884 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype = -1); 
# 905 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void merge(const Mat * mv, size_t count, OutputArray dst); 
# 913
__attribute((visibility("default"))) void merge(InputArrayOfArrays mv, OutputArray dst); 
# 930 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void split(const Mat & src, Mat * mvbegin); 
# 936
__attribute((visibility("default"))) void split(InputArray m, OutputArrayOfArrays mv); 
# 979 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void mixChannels(const Mat * src, size_t nsrcs, Mat * dst, size_t ndsts, const int * fromTo, size_t npairs); 
# 996 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void mixChannels(InputArrayOfArrays src, InputOutputArrayOfArrays dst, const int * fromTo, size_t npairs); 
# 1012 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void mixChannels(InputArrayOfArrays src, InputOutputArrayOfArrays dst, const std::vector< int>  & fromTo); 
# 1021
__attribute((visibility("default"))) void extractChannel(InputArray src, OutputArray dst, int coi); 
# 1029
__attribute((visibility("default"))) void insertChannel(InputArray src, InputOutputArray dst, int coi); 
# 1063 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void flip(InputArray src, OutputArray dst, int flipCode); 
# 1065
enum RotateFlags { 
# 1066
ROTATE_90_CLOCKWISE, 
# 1067
ROTATE_180, 
# 1068
ROTATE_90_COUNTERCLOCKWISE
# 1069
}; 
# 1081 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void rotate(InputArray src, OutputArray dst, int rotateCode); 
# 1096 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void repeat(InputArray src, int ny, int nx, OutputArray dst); 
# 1105 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) Mat repeat(const Mat & src, int ny, int nx); 
# 1128 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void hconcat(const Mat * src, size_t nsrc, OutputArray dst); 
# 1149 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void hconcat(InputArray src1, InputArray src2, OutputArray dst); 
# 1168 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void hconcat(InputArrayOfArrays src, OutputArray dst); 
# 1190 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void vconcat(const Mat * src, size_t nsrc, OutputArray dst); 
# 1214 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void vconcat(InputArray src1, InputArray src2, OutputArray dst); 
# 1232 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void vconcat(InputArrayOfArrays src, OutputArray dst); 
# 1259 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void bitwise_and(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray()); 
# 1286 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void bitwise_or(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray()); 
# 1314 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void bitwise_xor(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray()); 
# 1331 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void bitwise_not(InputArray src, OutputArray dst, InputArray mask = noArray()); 
# 1357 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void absdiff(InputArray src1, InputArray src2, OutputArray dst); 
# 1378 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst); 
# 1407 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop); 
# 1420 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void min(InputArray src1, InputArray src2, OutputArray dst); 
# 1424
__attribute((visibility("default"))) void min(const Mat & src1, const Mat & src2, Mat & dst); 
# 1428
__attribute((visibility("default"))) void min(const UMat & src1, const UMat & src2, UMat & dst); 
# 1441 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void max(InputArray src1, InputArray src2, OutputArray dst); 
# 1445
__attribute((visibility("default"))) void max(const Mat & src1, const Mat & src2, Mat & dst); 
# 1449
__attribute((visibility("default"))) void max(const UMat & src1, const UMat & src2, UMat & dst); 
# 1460 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void sqrt(InputArray src, OutputArray dst); 
# 1485 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void pow(InputArray src, double power, OutputArray dst); 
# 1501 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void exp(InputArray src, OutputArray dst); 
# 1514 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void log(InputArray src, OutputArray dst); 
# 1536 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees = false); 
# 1557 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees = false); 
# 1577 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees = false); 
# 1591 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void magnitude(InputArray x, InputArray y, OutputArray magnitude); 
# 1608 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) bool checkRange(InputArray a, bool quiet = true, Point * pos = 0, double minVal = -((double)(1.797693134862315708e+308L)), double maxVal = (double)(1.797693134862315708e+308L)); 
# 1613
__attribute((visibility("default"))) void patchNaNs(InputOutputArray a, double val = 0); 
# 1643 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double beta, OutputArray dst, int flags = 0); 
# 1674 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta = noArray(), double scale = 1, int dtype = -1); 
# 1687 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void transpose(InputArray src, OutputArray dst); 
# 1713 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void transform(InputArray src, OutputArray dst, InputArray m); 
# 1740 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void perspectiveTransform(InputArray src, OutputArray dst, InputArray m); 
# 1755 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void completeSymm(InputOutputArray mtx, bool lowerToUpper = false); 
# 1772 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void setIdentity(InputOutputArray mtx, const Scalar & s = ((Scalar)(1))); 
# 1787 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) double determinant(InputArray mtx); 
# 1796 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) Scalar trace(InputArray mtx); 
# 1823 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) double invert(InputArray src, OutputArray dst, int flags = DECOMP_LU); 
# 1847 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags = DECOMP_LU); 
# 1863 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void sort(InputArray src, OutputArray dst, int flags); 
# 1883 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void sortIdx(InputArray src, OutputArray dst, int flags); 
# 1897 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) int solveCubic(InputArray coeffs, OutputArray roots); 
# 1907 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) double solvePoly(InputArray coeffs, OutputArray roots, int maxIters = 300); 
# 1928 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) bool eigen(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors = noArray()); 
# 1945 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void eigenNonSymmetric(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors); 
# 1961 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void calcCovarMatrix(const Mat * samples, int nsamples, Mat & covar, Mat & mean, int flags, int ctype = 6); 
# 1972 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void calcCovarMatrix(InputArray samples, OutputArray covar, InputOutputArray mean, int flags, int ctype = 6); 
# 1976
__attribute((visibility("default"))) void PCACompute(InputArray data, InputOutputArray mean, OutputArray eigenvectors, int maxComponents = 0); 
# 1980
__attribute((visibility("default"))) void PCACompute(InputArray data, InputOutputArray mean, OutputArray eigenvectors, double retainedVariance); 
# 1984
__attribute((visibility("default"))) void PCAProject(InputArray data, InputArray mean, InputArray eigenvectors, OutputArray result); 
# 1988
__attribute((visibility("default"))) void PCABackProject(InputArray data, InputArray mean, InputArray eigenvectors, OutputArray result); 
# 1992
__attribute((visibility("default"))) void SVDecomp(InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags = 0); 
# 1995
__attribute((visibility("default"))) void SVBackSubst(InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst); 
# 2008 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar); 
# 2142 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void dft(InputArray src, OutputArray dst, int flags = 0, int nonzeroRows = 0); 
# 2156 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void idft(InputArray src, OutputArray dst, int flags = 0, int nonzeroRows = 0); 
# 2197 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void dct(InputArray src, OutputArray dst, int flags = 0); 
# 2207 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void idct(InputArray src, OutputArray dst, int flags = 0); 
# 2226 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB = false); 
# 2250 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) int getOptimalDFTSize(int vecsize); 
# 2261 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) RNG &theRNG(); 
# 2269
__attribute((visibility("default"))) void setRNGSeed(int seed); 
# 2281 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void randu(InputOutputArray dst, InputArray low, InputArray high); 
# 2294 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void randn(InputOutputArray dst, InputArray mean, InputArray stddev); 
# 2307 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) void randShuffle(InputOutputArray dst, double iterFactor = (1.0), RNG * rng = 0); 
# 2374 "/usr/include/opencv2/core.hpp" 3
class __attribute((visibility("default"))) PCA { 
# 2377
public: enum Flags { DATA_AS_ROW, 
# 2378
DATA_AS_COL, 
# 2379
USE_AVG
# 2380
}; 
# 2387
PCA(); 
# 2398 "/usr/include/opencv2/core.hpp" 3
PCA(InputArray data, InputArray mean, int flags, int maxComponents = 0); 
# 2410 "/usr/include/opencv2/core.hpp" 3
PCA(InputArray data, InputArray mean, int flags, double retainedVariance); 
# 2432 "/usr/include/opencv2/core.hpp" 3
PCA &operator()(InputArray data, InputArray mean, int flags, int maxComponents = 0); 
# 2445 "/usr/include/opencv2/core.hpp" 3
PCA &operator()(InputArray data, InputArray mean, int flags, double retainedVariance); 
# 2461 "/usr/include/opencv2/core.hpp" 3
Mat project(InputArray vec) const; 
# 2475 "/usr/include/opencv2/core.hpp" 3
void project(InputArray vec, OutputArray result) const; 
# 2490 "/usr/include/opencv2/core.hpp" 3
Mat backProject(InputArray vec) const; 
# 2499 "/usr/include/opencv2/core.hpp" 3
void backProject(InputArray vec, OutputArray result) const; 
# 2505
void write(FileStorage & fs) const; 
# 2511
void read(const FileNode & fn); 
# 2513
Mat eigenvectors; 
# 2514
Mat eigenvalues; 
# 2515
Mat mean; 
# 2516
}; 
# 2526 "/usr/include/opencv2/core.hpp" 3
class __attribute((visibility("default"))) LDA { 
# 2532
public: explicit LDA(int num_components = 0); 
# 2539
LDA(InputArrayOfArrays src, InputArray labels, int num_components = 0); 
# 2543
void save(const String & filename) const; 
# 2547
void load(const String & filename); 
# 2551
void save(FileStorage & fs) const; 
# 2555
void load(const FileStorage & node); 
# 2559
~LDA(); 
# 2563
void compute(InputArrayOfArrays src, InputArray labels); 
# 2568
Mat project(InputArray src); 
# 2573
Mat reconstruct(InputArray src); 
# 2577
Mat eigenvectors() const { return _eigenvectors; } 
# 2581
Mat eigenvalues() const { return _eigenvalues; } 
# 2583
static Mat subspaceProject(InputArray W, InputArray mean, InputArray src); 
# 2584
static Mat subspaceReconstruct(InputArray W, InputArray mean, InputArray src); 
# 2587
protected: bool _dataAsRow; 
# 2588
int _num_components; 
# 2589
Mat _eigenvectors; 
# 2590
Mat _eigenvalues; 
# 2591
void lda(InputArrayOfArrays src, InputArray labels); 
# 2592
}; 
# 2608 "/usr/include/opencv2/core.hpp" 3
class __attribute((visibility("default"))) SVD { 
# 2611
public: enum Flags { 
# 2614
MODIFY_A = 1, 
# 2617
NO_UV, 
# 2621
FULL_UV = 4
# 2622
}; 
# 2628
inline SVD(); 
# 2635
inline SVD(InputArray src, int flags = 0); 
# 2648 "/usr/include/opencv2/core.hpp" 3
SVD &operator()(InputArray src, int flags = 0); 
# 2667 "/usr/include/opencv2/core.hpp" 3
static void compute(InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags = 0); 
# 2676
static void compute(InputArray src, OutputArray w, int flags = 0); 
# 2680
static void backSubst(InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst); 
# 2694 "/usr/include/opencv2/core.hpp" 3
static inline void solveZ(InputArray src, OutputArray dst); 
# 2718 "/usr/include/opencv2/core.hpp" 3
void backSubst(InputArray rhs, OutputArray dst) const; 
# 2721
template< class _Tp, int m, int n, int nm> static inline void compute(const Matx< _Tp, m, n>  & a, Matx< _Tp, nm, 1>  & w, Matx< _Tp, m, nm>  & u, Matx< _Tp, n, nm>  & vt); 
# 2725
template< class _Tp, int m, int n, int nm> static inline void compute(const Matx< _Tp, m, n>  & a, Matx< _Tp, nm, 1>  & w); 
# 2729
template< class _Tp, int m, int n, int nm, int nb> static inline void backSubst(const Matx< _Tp, nm, 1>  & w, const Matx< _Tp, m, nm>  & u, const Matx< _Tp, n, nm>  & vt, const Matx< _Tp, m, nb>  & rhs, Matx< _Tp, n, nb>  & dst); 
# 2732
Mat u, w, vt; 
# 2733
}; 
# 2747 "/usr/include/opencv2/core.hpp" 3
class __attribute((visibility("default"))) RNG { 
# 2750
public: enum { UNIFORM, 
# 2751
NORMAL
# 2752
}; 
# 2762 "/usr/include/opencv2/core.hpp" 3
inline RNG(); 
# 2766
inline RNG(uint64 state); 
# 2769
inline unsigned next(); 
# 2777
inline operator uchar(); 
# 2779
inline operator schar(); 
# 2781
inline operator ushort(); 
# 2783
inline operator short(); 
# 2785
inline operator unsigned(); 
# 2787
inline operator int(); 
# 2789
inline operator float(); 
# 2791
inline operator double(); 
# 2800 "/usr/include/opencv2/core.hpp" 3
inline unsigned operator()(); 
# 2804
inline unsigned operator()(unsigned N); 
# 2842 "/usr/include/opencv2/core.hpp" 3
inline int uniform(int a, int b); 
# 2844
inline float uniform(float a, float b); 
# 2846
inline double uniform(double a, double b); 
# 2882 "/usr/include/opencv2/core.hpp" 3
void fill(InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange = false); 
# 2892 "/usr/include/opencv2/core.hpp" 3
double gaussian(double sigma); 
# 2894
uint64 state; 
# 2896
inline bool operator==(const RNG & other) const; 
# 2897
}; 
# 2904
class __attribute((visibility("default"))) RNG_MT19937 { 
# 2907
public: RNG_MT19937(); 
# 2908
RNG_MT19937(unsigned s); 
# 2909
void seed(unsigned s); 
# 2911
unsigned next(); 
# 2913
operator int(); 
# 2914
operator unsigned(); 
# 2915
operator float(); 
# 2916
operator double(); 
# 2918
unsigned operator()(unsigned N); 
# 2919
unsigned operator()(); 
# 2924
int uniform(int a, int b); 
# 2928
float uniform(float a, float b); 
# 2932
double uniform(double a, double b); 
# 2935
private: enum PeriodParameters { N = 624, M = 397}; 
# 2936
unsigned state[N]; 
# 2937
int mti; 
# 2938
}; 
# 2982 "/usr/include/opencv2/core.hpp" 3
__attribute((visibility("default"))) double kmeans(InputArray data, int K, InputOutputArray bestLabels, TermCriteria criteria, int attempts, int flags, OutputArray centers = noArray()); 
# 2994 "/usr/include/opencv2/core.hpp" 3
class __attribute((visibility("default"))) Formatted { 
# 2997
public: virtual const char *next() = 0; 
# 2998
virtual void reset() = 0; 
# 2999
virtual ~Formatted(); 
# 3000
}; 
# 3003
class __attribute((visibility("default"))) Formatter { 
# 3006
public: enum { FMT_DEFAULT, 
# 3007
FMT_MATLAB, 
# 3008
FMT_CSV, 
# 3009
FMT_PYTHON, 
# 3010
FMT_NUMPY, 
# 3011
FMT_C
# 3012
}; 
# 3014
virtual ~Formatter(); 
# 3016
virtual Ptr< Formatted>  format(const Mat & mtx) const = 0; 
# 3018
virtual void set32fPrecision(int p = 8) = 0; 
# 3019
virtual void set64fPrecision(int p = 16) = 0; 
# 3020
virtual void setMultiline(bool ml = true) = 0; 
# 3022
static Ptr< Formatter>  get(int fmt = FMT_DEFAULT); 
# 3024
}; 
# 3027
static inline String &operator<<(String &out, Ptr< Formatted>  fmtd) 
# 3028
{ 
# 3029
fmtd->reset(); 
# 3030
for (const char *str = fmtd->next(); str; str = fmtd->next()) { 
# 3031
(out += ((String)(str))); }  
# 3032
return out; 
# 3033
} 
# 3036
static inline String &operator<<(String &out, const Mat &mtx) 
# 3037
{ 
# 3038
return (out << ((Formatter::get())->format(mtx))); 
# 3039
} 
# 3043
class __attribute((visibility("default"))) Algorithm; 
# 3045
template< class _Tp> struct ParamType { }; 
# 3082 "/usr/include/opencv2/core.hpp" 3
class __attribute((visibility("default"))) Algorithm { 
# 3085
public: Algorithm(); 
# 3086
virtual ~Algorithm(); 
# 3090
virtual void clear() { } 
# 3094
virtual void write(FileStorage &fs) const { (void)fs; } 
# 3098
virtual void read(const FileNode &fn) { (void)fn; } 
# 3102
virtual bool empty() const { return false; } 
# 3115 "/usr/include/opencv2/core.hpp" 3
template< class _Tp> static Ptr< _Tp>  read(const FileNode &fn) 
# 3116
{ 
# 3117
Ptr< _Tp>  obj = _Tp::create(); 
# 3118
(obj->read(fn)); 
# 3119
return (!(obj->empty())) ? obj : Ptr< _Tp> (); 
# 3120
} 
# 3134 "/usr/include/opencv2/core.hpp" 3
template< class _Tp> static Ptr< _Tp>  load(const String &filename, const String &objname = String()) 
# 3135
{ 
# 3136
FileStorage fs(filename, FileStorage::READ); 
# 3137
FileNode fn = (objname.empty() ? fs.getFirstTopLevelNode() : (fs[objname])); 
# 3138
if (fn.empty()) { return Ptr< _Tp> (); }  
# 3139
Ptr< _Tp>  obj = _Tp::create(); 
# 3140
(obj->read(fn)); 
# 3141
return (!(obj->empty())) ? obj : Ptr< _Tp> (); 
# 3142
} 
# 3154 "/usr/include/opencv2/core.hpp" 3
template< class _Tp> static Ptr< _Tp>  loadFromString(const String &strModel, const String &objname = String()) 
# 3155
{ 
# 3156
FileStorage fs(strModel, (FileStorage::READ) + (FileStorage::MEMORY)); 
# 3157
FileNode fn = (objname.empty() ? fs.getFirstTopLevelNode() : (fs[objname])); 
# 3158
Ptr< _Tp>  obj = _Tp::create(); 
# 3159
(obj->read(fn)); 
# 3160
return (!(obj->empty())) ? obj : Ptr< _Tp> (); 
# 3161
} 
# 3165
virtual void save(const String & filename) const; 
# 3169
virtual String getDefaultName() const; 
# 3172
protected: void writeFormat(FileStorage & fs) const; 
# 3173
}; 
# 3175
struct Param { 
# 3176
enum { INT, BOOLEAN, REAL, STRING, MAT, MAT_VECTOR, ALGORITHM, FLOAT, 
# 3177
UNSIGNED_INT, UINT64, UCHAR = 11}; 
# 3178
}; 
# 3182
template<> struct ParamType< bool>  { 
# 3184
typedef bool const_param_type; 
# 3185
typedef bool member_type; 
# 3187
enum { type = 1}; 
# 3188
}; 
# 3190
template<> struct ParamType< int>  { 
# 3192
typedef int const_param_type; 
# 3193
typedef int member_type; 
# 3195
enum { type}; 
# 3196
}; 
# 3198
template<> struct ParamType< double>  { 
# 3200
typedef double const_param_type; 
# 3201
typedef double member_type; 
# 3203
enum { type = 2}; 
# 3204
}; 
# 3206
template<> struct ParamType< String>  { 
# 3208
typedef const String &const_param_type; 
# 3209
typedef String member_type; 
# 3211
enum { type = 3}; 
# 3212
}; 
# 3214
template<> struct ParamType< Mat>  { 
# 3216
typedef const Mat &const_param_type; 
# 3217
typedef Mat member_type; 
# 3219
enum { type = 4}; 
# 3220
}; 
# 3222
template<> struct ParamType< std::vector< Mat> >  { 
# 3224
typedef const std::vector< Mat>  &const_param_type; 
# 3225
typedef std::vector< Mat>  member_type; 
# 3227
enum { type = 5}; 
# 3228
}; 
# 3230
template<> struct ParamType< Algorithm>  { 
# 3232
typedef const Ptr< Algorithm>  &const_param_type; 
# 3233
typedef Ptr< Algorithm>  member_type; 
# 3235
enum { type = 6}; 
# 3236
}; 
# 3238
template<> struct ParamType< float>  { 
# 3240
typedef float const_param_type; 
# 3241
typedef float member_type; 
# 3243
enum { type = 7}; 
# 3244
}; 
# 3246
template<> struct ParamType< unsigned>  { 
# 3248
typedef unsigned const_param_type; 
# 3249
typedef unsigned member_type; 
# 3251
enum { type = 8}; 
# 3252
}; 
# 3254
template<> struct ParamType< unsigned long>  { 
# 3256
typedef uint64 const_param_type; 
# 3257
typedef uint64 member_type; 
# 3259
enum { type = 9}; 
# 3260
}; 
# 3262
template<> struct ParamType< unsigned char>  { 
# 3264
typedef uchar const_param_type; 
# 3265
typedef uchar member_type; 
# 3267
enum { type = 11}; 
# 3268
}; 
# 3272
}
# 56 "/usr/include/opencv2/core/operations.hpp" 3
namespace cv { 
# 61
namespace internal { 
# 64
template< class _Tp, int m> struct Matx_FastInvOp { 
# 66
bool operator()(const Matx< _Tp, m, m>  &a, Matx< _Tp, m, m>  &b, int method) const 
# 67
{ 
# 68
Matx< _Tp, m, m>  temp = a; 
# 71
for (int i = 0; i < m; i++) { 
# 72
b(i, i) = ((_Tp)1); }  
# 74
if (method == (DECOMP_CHOLESKY)) { 
# 75
return Cholesky((temp.val), (m) * sizeof(_Tp), m, (b.val), (m) * sizeof(_Tp), m); }  
# 77
return LU((temp.val), (m) * sizeof(_Tp), m, (b.val), (m) * sizeof(_Tp), m) != 0; 
# 78
} 
# 79
}; 
# 81
template< class _Tp> struct Matx_FastInvOp< _Tp, 2>  { 
# 83
bool operator()(const Matx< _Tp, 2, 2>  &a, Matx< _Tp, 2, 2>  &b, int) const 
# 84
{ 
# 85
_Tp d = (_Tp)determinant(a); 
# 86
if (d == 0) { 
# 87
return false; }  
# 88
d = (1 / d); 
# 89
b(1, 1) = (a(0, 0) * d); 
# 90
b(0, 0) = (a(1, 1) * d); 
# 91
b(0, 1) = ((-a(0, 1)) * d); 
# 92
b(1, 0) = ((-a(1, 0)) * d); 
# 93
return true; 
# 94
} 
# 95
}; 
# 97
template< class _Tp> struct Matx_FastInvOp< _Tp, 3>  { 
# 99
bool operator()(const Matx< _Tp, 3, 3>  &a, Matx< _Tp, 3, 3>  &b, int) const 
# 100
{ 
# 101
_Tp d = (_Tp)determinant(a); 
# 102
if (d == 0) { 
# 103
return false; }  
# 104
d = (1 / d); 
# 105
b(0, 0) = (((a(1, 1) * a(2, 2)) - (a(1, 2) * a(2, 1))) * d); 
# 106
b(0, 1) = (((a(0, 2) * a(2, 1)) - (a(0, 1) * a(2, 2))) * d); 
# 107
b(0, 2) = (((a(0, 1) * a(1, 2)) - (a(0, 2) * a(1, 1))) * d); 
# 109
b(1, 0) = (((a(1, 2) * a(2, 0)) - (a(1, 0) * a(2, 2))) * d); 
# 110
b(1, 1) = (((a(0, 0) * a(2, 2)) - (a(0, 2) * a(2, 0))) * d); 
# 111
b(1, 2) = (((a(0, 2) * a(1, 0)) - (a(0, 0) * a(1, 2))) * d); 
# 113
b(2, 0) = (((a(1, 0) * a(2, 1)) - (a(1, 1) * a(2, 0))) * d); 
# 114
b(2, 1) = (((a(0, 1) * a(2, 0)) - (a(0, 0) * a(2, 1))) * d); 
# 115
b(2, 2) = (((a(0, 0) * a(1, 1)) - (a(0, 1) * a(1, 0))) * d); 
# 116
return true; 
# 117
} 
# 118
}; 
# 121
template< class _Tp, int m, int n> struct Matx_FastSolveOp { 
# 123
bool operator()(const Matx< _Tp, m, m>  &a, const Matx< _Tp, m, n>  &b, Matx< _Tp, m, n>  &
# 124
x, int method) const 
# 125
{ 
# 126
Matx< _Tp, m, m>  temp = a; 
# 127
x = b; 
# 128
if (method == (DECOMP_CHOLESKY)) { 
# 129
return Cholesky((temp.val), (m) * sizeof(_Tp), m, (x.val), (n) * sizeof(_Tp), n); }  
# 131
return LU((temp.val), (m) * sizeof(_Tp), m, (x.val), (n) * sizeof(_Tp), n) != 0; 
# 132
} 
# 133
}; 
# 135
template< class _Tp> struct Matx_FastSolveOp< _Tp, 2, 1>  { 
# 137
bool operator()(const Matx< _Tp, 2, 2>  &a, const Matx< _Tp, 2, 1>  &b, Matx< _Tp, 2, 1>  &
# 138
x, int) const 
# 139
{ 
# 140
_Tp d = (_Tp)determinant(a); 
# 141
if (d == 0) { 
# 142
return false; }  
# 143
d = (1 / d); 
# 144
x(0) = (((b(0) * a(1, 1)) - (b(1) * a(0, 1))) * d); 
# 145
x(1) = (((b(1) * a(0, 0)) - (b(0) * a(1, 0))) * d); 
# 146
return true; 
# 147
} 
# 148
}; 
# 150
template< class _Tp> struct Matx_FastSolveOp< _Tp, 3, 1>  { 
# 152
bool operator()(const Matx< _Tp, 3, 3>  &a, const Matx< _Tp, 3, 1>  &b, Matx< _Tp, 3, 1>  &
# 153
x, int) const 
# 154
{ 
# 155
_Tp d = (_Tp)determinant(a); 
# 156
if (d == 0) { 
# 157
return false; }  
# 158
d = (1 / d); 
# 159
x(0) = (d * (((b(0) * ((a(1, 1) * a(2, 2)) - (a(1, 2) * a(2, 1)))) - (a(0, 1) * ((b(1) * a(2, 2)) - (a(1, 2) * b(2))))) + (a(0, 2) * ((b(1) * a(2, 1)) - (a(1, 1) * b(2)))))); 
# 163
x(1) = (d * (((a(0, 0) * ((b(1) * a(2, 2)) - (a(1, 2) * b(2)))) - (b(0) * ((a(1, 0) * a(2, 2)) - (a(1, 2) * a(2, 0))))) + (a(0, 2) * ((a(1, 0) * b(2)) - (b(1) * a(2, 0)))))); 
# 167
x(2) = (d * (((a(0, 0) * ((a(1, 1) * b(2)) - (b(1) * a(2, 1)))) - (a(0, 1) * ((a(1, 0) * b(2)) - (b(1) * a(2, 0))))) + (b(0) * ((a(1, 0) * a(2, 1)) - (a(1, 1) * a(2, 0)))))); 
# 170
return true; 
# 171
} 
# 172
}; 
# 174
}
# 176
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 177
Matx< _Tp, m, n> ::randu(_Tp a, _Tp b) 
# 178
{ 
# 179
Matx M; 
# 180
cv::randu(M, ((Scalar)(a)), ((Scalar)(b))); 
# 181
return M; 
# 182
} 
# 184
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 185
Matx< _Tp, m, n> ::randn(_Tp a, _Tp b) 
# 186
{ 
# 187
Matx M; 
# 188
cv::randn(M, ((Scalar)(a)), ((Scalar)(b))); 
# 189
return M; 
# 190
} 
# 192
template< class _Tp, int m, int n> inline Matx< _Tp, n, m>  
# 193
Matx< _Tp, m, n> ::inv(int method, bool *p_is_ok) const 
# 194
{ 
# 195
cv::Matx< _Tp, n, m>  b; 
# 196
bool ok; 
# 197
if ((method == (DECOMP_LU)) || (method == (DECOMP_CHOLESKY))) { 
# 198
ok = internal::Matx_FastInvOp< _Tp, m> ()(*this, b, method); } else 
# 200
{ 
# 201
Mat A(*this, false), B(b, false); 
# 202
ok = (invert(A, B, method) != (0)); 
# 203
}  
# 204
if ((__null) != p_is_ok) { (*p_is_ok) = ok; }  
# 205
return ok ? b : Matx< _Tp, n, m> ::zeros(); 
# 206
} 
# 208
template< class _Tp, int m, int n> template< int l> inline Matx< _Tp, n, l>  
# 209
Matx< _Tp, m, n> ::solve(const cv::Matx< _Tp, m, l>  &rhs, int method) const 
# 210
{ 
# 211
cv::Matx< _Tp, n, l>  x; 
# 212
bool ok; 
# 213
if ((method == (DECOMP_LU)) || (method == (DECOMP_CHOLESKY))) { 
# 214
ok = internal::Matx_FastSolveOp< _Tp, m, l> ()(*this, rhs, x, method); } else 
# 216
{ 
# 217
Mat A(*this, false), B(rhs, false), X(x, false); 
# 218
ok = cv::solve(A, B, X, method); 
# 219
}  
# 221
return ok ? x : Matx< _Tp, n, l> ::zeros(); 
# 222
} 
# 239 "/usr/include/opencv2/core/operations.hpp" 3
static inline Mat &operator+=(Mat &a, const Mat &b) { cv::add(a, b, a); return a; } static inline const Mat &operator+=(const Mat &a, const Mat &b) { cv::add(a, b, a); return a; } 
# 240
static inline Mat &operator+=(Mat &a, const Scalar &b) { cv::add(a, b, a); return a; } static inline const Mat &operator+=(const Mat &a, const Scalar &b) { cv::add(a, b, a); return a; } 
# 241
template< class _Tp> static inline Mat_< _Tp>  &operator+=(Mat_< _Tp>  &a, const Mat &b) { cv::add(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator+=(const Mat_< _Tp>  &a, const Mat &b) { cv::add(a, b, a); return a; } 
# 242
template< class _Tp> static inline Mat_< _Tp>  &operator+=(Mat_< _Tp>  &a, const Scalar &b) { cv::add(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator+=(const Mat_< _Tp>  &a, const Scalar &b) { cv::add(a, b, a); return a; } 
# 243
template< class _Tp> static inline Mat_< _Tp>  &operator+=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::add(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator+=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::add(a, b, a); return a; } 
# 245
static inline Mat &operator-=(Mat &a, const Mat &b) { cv::subtract(a, b, a); return a; } static inline const Mat &operator-=(const Mat &a, const Mat &b) { cv::subtract(a, b, a); return a; } 
# 246
static inline Mat &operator-=(Mat &a, const Scalar &b) { cv::subtract(a, b, a); return a; } static inline const Mat &operator-=(const Mat &a, const Scalar &b) { cv::subtract(a, b, a); return a; } 
# 247
template< class _Tp> static inline Mat_< _Tp>  &operator-=(Mat_< _Tp>  &a, const Mat &b) { cv::subtract(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator-=(const Mat_< _Tp>  &a, const Mat &b) { cv::subtract(a, b, a); return a; } 
# 248
template< class _Tp> static inline Mat_< _Tp>  &operator-=(Mat_< _Tp>  &a, const Scalar &b) { cv::subtract(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator-=(const Mat_< _Tp>  &a, const Scalar &b) { cv::subtract(a, b, a); return a; } 
# 249
template< class _Tp> static inline Mat_< _Tp>  &operator-=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::subtract(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator-=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::subtract(a, b, a); return a; } 
# 251
static inline Mat &operator*=(Mat &a, const Mat &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } static inline const Mat &operator*=(const Mat &a, const Mat &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } 
# 252
template< class _Tp> static inline Mat_< _Tp>  &operator*=(Mat_< _Tp>  &a, const Mat &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator*=(const Mat_< _Tp>  &a, const Mat &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } 
# 253
template< class _Tp> static inline Mat_< _Tp>  &operator*=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator*=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } 
# 254
static inline Mat &operator*=(Mat &a, const double &b) { a.convertTo(a, -1, b); return a; } static inline const Mat &operator*=(const Mat &a, const double &b) { a.convertTo(a, -1, b); return a; } 
# 255
template< class _Tp> static inline Mat_< _Tp>  &operator*=(Mat_< _Tp>  &a, const double &b) { (a.convertTo(a, -1, b)); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator*=(const Mat_< _Tp>  &a, const double &b) { (a.convertTo(a, -1, b)); return a; } 
# 257
static inline Mat &operator/=(Mat &a, const Mat &b) { cv::divide(a, b, a); return a; } static inline const Mat &operator/=(const Mat &a, const Mat &b) { cv::divide(a, b, a); return a; } 
# 258
template< class _Tp> static inline Mat_< _Tp>  &operator/=(Mat_< _Tp>  &a, const Mat &b) { cv::divide(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator/=(const Mat_< _Tp>  &a, const Mat &b) { cv::divide(a, b, a); return a; } 
# 259
template< class _Tp> static inline Mat_< _Tp>  &operator/=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::divide(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator/=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::divide(a, b, a); return a; } 
# 260
static inline Mat &operator/=(Mat &a, const double &b) { a.convertTo((Mat &)a, -1, (1.0) / b); return a; } static inline const Mat &operator/=(const Mat &a, const double &b) { a.convertTo((Mat &)a, -1, (1.0) / b); return a; } 
# 261
template< class _Tp> static inline Mat_< _Tp>  &operator/=(Mat_< _Tp>  &a, const double &b) { (a.convertTo((Mat &)a, -1, (1.0) / b)); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator/=(const Mat_< _Tp>  &a, const double &b) { (a.convertTo((Mat &)a, -1, (1.0) / b)); return a; } 
# 263
static inline Mat &operator&=(Mat &a, const Mat &b) { cv::bitwise_and(a, b, a); return a; } static inline const Mat &operator&=(const Mat &a, const Mat &b) { cv::bitwise_and(a, b, a); return a; } 
# 264
static inline Mat &operator&=(Mat &a, const Scalar &b) { cv::bitwise_and(a, b, a); return a; } static inline const Mat &operator&=(const Mat &a, const Scalar &b) { cv::bitwise_and(a, b, a); return a; } 
# 265
template< class _Tp> static inline Mat_< _Tp>  &operator&=(Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_and(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator&=(const Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_and(a, b, a); return a; } 
# 266
template< class _Tp> static inline Mat_< _Tp>  &operator&=(Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_and(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator&=(const Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_and(a, b, a); return a; } 
# 267
template< class _Tp> static inline Mat_< _Tp>  &operator&=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_and(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator&=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_and(a, b, a); return a; } 
# 269
static inline Mat &operator|=(Mat &a, const Mat &b) { cv::bitwise_or(a, b, a); return a; } static inline const Mat &operator|=(const Mat &a, const Mat &b) { cv::bitwise_or(a, b, a); return a; } 
# 270
static inline Mat &operator|=(Mat &a, const Scalar &b) { cv::bitwise_or(a, b, a); return a; } static inline const Mat &operator|=(const Mat &a, const Scalar &b) { cv::bitwise_or(a, b, a); return a; } 
# 271
template< class _Tp> static inline Mat_< _Tp>  &operator|=(Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_or(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator|=(const Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_or(a, b, a); return a; } 
# 272
template< class _Tp> static inline Mat_< _Tp>  &operator|=(Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_or(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator|=(const Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_or(a, b, a); return a; } 
# 273
template< class _Tp> static inline Mat_< _Tp>  &operator|=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_or(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator|=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_or(a, b, a); return a; } 
# 275
static inline Mat &operator^=(Mat &a, const Mat &b) { cv::bitwise_xor(a, b, a); return a; } static inline const Mat &operator^=(const Mat &a, const Mat &b) { cv::bitwise_xor(a, b, a); return a; } 
# 276
static inline Mat &operator^=(Mat &a, const Scalar &b) { cv::bitwise_xor(a, b, a); return a; } static inline const Mat &operator^=(const Mat &a, const Scalar &b) { cv::bitwise_xor(a, b, a); return a; } 
# 277
template< class _Tp> static inline Mat_< _Tp>  &operator^=(Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_xor(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator^=(const Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_xor(a, b, a); return a; } 
# 278
template< class _Tp> static inline Mat_< _Tp>  &operator^=(Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_xor(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator^=(const Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_xor(a, b, a); return a; } 
# 279
template< class _Tp> static inline Mat_< _Tp>  &operator^=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_xor(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator^=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_xor(a, b, a); return a; } 
# 289 "/usr/include/opencv2/core/operations.hpp" 3
inline SVD::SVD() { } 
# 290
inline SVD::SVD(InputArray m, int flags) { this->operator()(m, flags); } 
# 291
inline void SVD::solveZ(InputArray m, OutputArray _dst) 
# 292
{ 
# 293
Mat mtx = m.getMat(); 
# 294
SVD svd(mtx, ((mtx.rows) >= (mtx.cols)) ? 0 : (SVD::FULL_UV)); 
# 295
_dst.create((svd.vt).cols, 1, (svd.vt).type()); 
# 296
Mat dst = _dst.getMat(); 
# 297
(((svd.vt).row(((svd.vt).rows) - 1)).reshape(1, (svd.vt).cols)).copyTo(dst); 
# 298
} 
# 300
template< class _Tp, int m, int n, int nm> inline void 
# 301
SVD::compute(const Matx< _Tp, m, n>  &a, Matx< _Tp, nm, 1>  &w, Matx< _Tp, m, nm>  &u, Matx< _Tp, n, nm>  &vt) 
# 302
{ 
# 303
static_assert((nm == ((m > n) ? n : m)), "Invalid size of output vector. nm == MIN(m, n)");
# 304
Mat _a(a, false), _u(u, false), _w(w, false), _vt(vt, false); 
# 305
SVD::compute(_a, _w, _u, _vt); 
# 306
if (!(!(((_w.data) == ((uchar *)(&((w.val)[0])))) && ((_u.data) == ((uchar *)(&((u.val)[0])))) && ((_vt.data) == ((uchar *)(&((vt.val)[0]))))))) { ; } else { cv::error(cv::Error::StsAssert, "_w.data == (uchar*)&w.val[0] && _u.data == (uchar*)&u.val[0] && _vt.data == (uchar*)&vt.val[0]", __func__, "/usr/include/opencv2/core/operations.hpp", 306); }  
# 307
} 
# 309
template< class _Tp, int m, int n, int nm> inline void 
# 310
SVD::compute(const Matx< _Tp, m, n>  &a, Matx< _Tp, nm, 1>  &w) 
# 311
{ 
# 312
static_assert((nm == ((m > n) ? n : m)), "Invalid size of output vector. nm == MIN(m, n)");
# 313
Mat _a(a, false), _w(w, false); 
# 314
SVD::compute(_a, _w); 
# 315
if (!(!((_w.data) == ((uchar *)(&((w.val)[0])))))) { ; } else { cv::error(cv::Error::StsAssert, "_w.data == (uchar*)&w.val[0]", __func__, "/usr/include/opencv2/core/operations.hpp", 315); }  
# 316
} 
# 318
template< class _Tp, int m, int n, int nm, int nb> inline void 
# 319
SVD::backSubst(const Matx< _Tp, nm, 1>  &w, const Matx< _Tp, m, nm>  &u, const Matx< _Tp, n, nm>  &
# 320
vt, const Matx< _Tp, m, nb>  &rhs, Matx< _Tp, n, nb>  &
# 321
dst) 
# 322
{ 
# 323
static_assert((nm == ((m > n) ? n : m)), "Invalid size of output vector. nm == MIN(m, n)");
# 324
Mat _u(u, false), _w(w, false), _vt(vt, false), _rhs(rhs, false), _dst(dst, false); 
# 325
SVD::backSubst(_w, _u, _vt, _rhs, _dst); 
# 326
if (!(!((_dst.data) == ((uchar *)(&((dst.val)[0])))))) { ; } else { cv::error(cv::Error::StsAssert, "_dst.data == (uchar*)&dst.val[0]", __func__, "/usr/include/opencv2/core/operations.hpp", 326); }  
# 327
} 
# 333
inline RNG::RNG() { (state) = (4294967295U); } 
# 334
inline RNG::RNG(uint64 _state) { (state) = ((_state) ? _state : (4294967295U)); } 
# 336
inline RNG::operator uchar() { return (uchar)this->next(); } 
# 337
inline RNG::operator schar() { return (schar)this->next(); } 
# 338
inline RNG::operator ushort() { return (ushort)this->next(); } 
# 339
inline RNG::operator short() { return (short)this->next(); } 
# 340
inline RNG::operator int() { return (int)this->next(); } 
# 341
inline RNG::operator unsigned() { return this->next(); } 
# 342
inline RNG::operator float() { return (this->next()) * (2.328306437e-10F); } 
# 343
inline RNG::operator double() { unsigned t = this->next(); return ((((uint64)t) << 32) | (this->next())) * (5.42101086242752217e-20); } 
# 345
inline unsigned RNG::operator()(unsigned N) { return (unsigned)this->uniform(0, N); } 
# 346
inline unsigned RNG::operator()() { return this->next(); } 
# 348
inline int RNG::uniform(int a, int b) { return (a == b) ? a : ((int)((this->next() % (b - a)) + a)); } 
# 349
inline float RNG::uniform(float a, float b) { return (((float)(*this)) * (b - a)) + a; } 
# 350
inline double RNG::uniform(double a, double b) { return (((double)(*this)) * (b - a)) + a; } 
# 352
inline bool RNG::operator==(const RNG &other) const { return (state) == (other.state); } 
# 354
inline unsigned RNG::next() 
# 355
{ 
# 356
(state) = ((((uint64)((unsigned)(state))) * (4164903690U)) + ((unsigned)((state) >> 32))); 
# 357
return (unsigned)(state); 
# 358
} 
# 361
template< class _Tp> static inline _Tp randu() 
# 362
{ 
# 363
return (_Tp)theRNG(); 
# 364
} 
# 368
__attribute((visibility("default"))) String format(const char * fmt, ...); 
# 373
static inline Ptr< Formatted>  format(InputArray mtx, int fmt) 
# 374
{ 
# 375
return (Formatter::get(fmt))->format(mtx.getMat()); 
# 376
} 
# 379
static inline int print(Ptr< Formatted>  fmtd, FILE *stream = stdout) 
# 380
{ 
# 381
int written = 0; 
# 382
fmtd->reset(); 
# 383
for (const char *str = fmtd->next(); str; str = fmtd->next()) { 
# 384
written += fputs(str, stream); }  
# 386
return written; 
# 387
} 
# 390
static inline int print(const Mat &mtx, FILE *stream = stdout) 
# 391
{ 
# 392
return print((Formatter::get())->format(mtx), stream); 
# 393
} 
# 396
static inline int print(const UMat &mtx, FILE *stream = stdout) 
# 397
{ 
# 398
return print((Formatter::get())->format(mtx.getMat(ACCESS_READ)), stream); 
# 399
} 
# 401
template< class _Tp> static inline int 
# 402
print(const std::vector< Point_< _Tp> >  &vec, FILE *stream = stdout) 
# 403
{ 
# 404
return print((Formatter::get())->format(((Mat)(vec))), stream); 
# 405
} 
# 407
template< class _Tp> static inline int 
# 408
print(const std::vector< Point3_< _Tp> >  &vec, FILE *stream = stdout) 
# 409
{ 
# 410
return print((Formatter::get())->format(((Mat)(vec))), stream); 
# 411
} 
# 413
template< class _Tp, int m, int n> static inline int 
# 414
print(const Matx< _Tp, m, n>  &matx, FILE *stream = stdout) 
# 415
{ 
# 416
return print((Formatter::get())->format(((Mat)(matx))), stream); 
# 417
} 
# 440 "/usr/include/opencv2/core/operations.hpp" 3
template< class _Tp, class _EqPredicate> int 
# 441
partition(const std::vector< _Tp>  &_vec, std::vector< int>  &labels, _EqPredicate 
# 442
predicate = _EqPredicate()) 
# 443
{ 
# 444
int i, j, N = (int)(_vec.size()); 
# 445
const _Tp *vec = (&(_vec[0])); 
# 447
const int PARENT = 0; 
# 448
const int RANK = 1; 
# 450
std::vector< int>  _nodes(N * 2); 
# 451
int (*nodes)[2] = (int (*)[2])(&_nodes[0]); 
# 454
for (i = 0; i < N; i++) 
# 455
{ 
# 456
((nodes[i])[PARENT]) = (-1); 
# 457
((nodes[i])[RANK]) = 0; 
# 458
}  
# 461
for (i = 0; i < N; i++) 
# 462
{ 
# 463
int root = i; 
# 466
while (((nodes[root])[PARENT]) >= 0) { 
# 467
root = ((nodes[root])[PARENT]); }  
# 469
for (j = 0; j < N; j++) { 
# 470
{ 
# 471
if ((i == j) || (!predicate(vec[i], vec[j]))) { 
# 472
continue; }  
# 473
int root2 = j; 
# 475
while (((nodes[root2])[PARENT]) >= 0) { 
# 476
root2 = ((nodes[root2])[PARENT]); }  
# 478
if (root2 != root) 
# 479
{ 
# 481
int rank = (nodes[root])[RANK], rank2 = (nodes[root2])[RANK]; 
# 482
if (rank > rank2) { 
# 483
((nodes[root2])[PARENT]) = root; } else 
# 485
{ 
# 486
((nodes[root])[PARENT]) = root2; 
# 487
((nodes[root2])[RANK]) += (rank == rank2); 
# 488
root = root2; 
# 489
}  
# 490
if (!(!(((nodes[root])[PARENT]) < 0))) { ; } else { cv::error(cv::Error::StsAssert, "nodes[root][PARENT] < 0", __func__, "/usr/include/opencv2/core/operations.hpp", 490); }  
# 492
int k = j, parent; 
# 495
while ((parent = ((nodes[k])[PARENT])) >= 0) 
# 496
{ 
# 497
((nodes[k])[PARENT]) = root; 
# 498
k = parent; 
# 499
}  
# 502
k = i; 
# 503
while ((parent = ((nodes[k])[PARENT])) >= 0) 
# 504
{ 
# 505
((nodes[k])[PARENT]) = root; 
# 506
k = parent; 
# 507
}  
# 508
}  
# 509
} }  
# 510
}  
# 513
labels.resize(N); 
# 514
int nclasses = 0; 
# 516
for (i = 0; i < N; i++) 
# 517
{ 
# 518
int root = i; 
# 519
while (((nodes[root])[PARENT]) >= 0) { 
# 520
root = ((nodes[root])[PARENT]); }  
# 522
if (((nodes[root])[RANK]) >= 0) { 
# 523
((nodes[root])[RANK]) = (~(nclasses++)); }  
# 524
labels[i] = (~((nodes[root])[RANK])); 
# 525
}  
# 527
return nclasses; 
# 528
} 
# 530
}
# 50 "/usr/include/c++/5/complex" 3
namespace std __attribute((__visibility__("default"))) { 
# 63 "/usr/include/c++/5/complex" 3
template< class _Tp> struct complex; 
# 64
template<> struct complex< float> ; 
# 65
template<> struct complex< double> ; 
# 66
template<> struct complex< long double> ; 
# 69
template< class _Tp> inline _Tp abs(const complex< _Tp>  &); 
# 71
template< class _Tp> inline _Tp arg(const complex< _Tp>  &); 
# 73
template< class _Tp> inline _Tp norm(const complex< _Tp>  &); 
# 76
template< class _Tp> inline complex< _Tp>  conj(const complex< _Tp>  &); 
# 78
template< class _Tp> inline complex< _Tp>  polar(const _Tp &, const _Tp & = 0); 
# 82
template< class _Tp> inline complex< _Tp>  cos(const complex< _Tp>  &); 
# 84
template< class _Tp> inline complex< _Tp>  cosh(const complex< _Tp>  &); 
# 86
template< class _Tp> inline complex< _Tp>  exp(const complex< _Tp>  &); 
# 88
template< class _Tp> inline complex< _Tp>  log(const complex< _Tp>  &); 
# 90
template< class _Tp> inline complex< _Tp>  log10(const complex< _Tp>  &); 
# 92
template< class _Tp> inline complex< _Tp>  pow(const complex< _Tp>  &, int); 
# 94
template< class _Tp> complex< _Tp>  pow(const complex< _Tp>  &, const _Tp &); 
# 96
template< class _Tp> inline complex< _Tp>  pow(const complex< _Tp>  &, const complex< _Tp>  &); 
# 99
template< class _Tp> inline complex< _Tp>  pow(const _Tp &, const complex< _Tp>  &); 
# 101
template< class _Tp> inline complex< _Tp>  sin(const complex< _Tp>  &); 
# 103
template< class _Tp> inline complex< _Tp>  sinh(const complex< _Tp>  &); 
# 105
template< class _Tp> inline complex< _Tp>  sqrt(const complex< _Tp>  &); 
# 107
template< class _Tp> inline complex< _Tp>  tan(const complex< _Tp>  &); 
# 109
template< class _Tp> inline complex< _Tp>  tanh(const complex< _Tp>  &); 
# 121 "/usr/include/c++/5/complex" 3
template< class _Tp> 
# 122
struct complex { 
# 125
typedef _Tp value_type; 
# 129
constexpr complex(const _Tp &__r = _Tp(), const _Tp &__i = _Tp()) : _M_real(__r), _M_imag(__i) 
# 130
{ } 
# 134
constexpr complex(const complex &) = default;
# 138
template< class _Up> constexpr 
# 139
complex(const std::complex< _Up>  &__z) : _M_real((__z.real())), _M_imag((__z.imag())) 
# 140
{ } 
# 145
__attribute((__abi_tag__("cxx11"))) constexpr _Tp 
# 147
real() const { return _M_real; } 
# 149
__attribute((__abi_tag__("cxx11"))) constexpr _Tp 
# 151
imag() const { return _M_imag; } 
# 173 "/usr/include/c++/5/complex" 3
void real(_Tp __val) { (_M_real) = __val; } 
# 176
void imag(_Tp __val) { (_M_imag) = __val; } 
# 179
complex &operator=(const _Tp &); 
# 184
complex &operator+=(const _Tp &__t) 
# 185
{ 
# 186
(_M_real) += __t; 
# 187
return *this; 
# 188
} 
# 193
complex &operator-=(const _Tp &__t) 
# 194
{ 
# 195
(_M_real) -= __t; 
# 196
return *this; 
# 197
} 
# 200
complex &operator*=(const _Tp &); 
# 202
complex &operator/=(const _Tp &); 
# 206
complex &operator=(const complex &) = default;
# 210
template< class _Up> complex &operator=(const std::complex< _Up>  &); 
# 213
template< class _Up> complex &operator+=(const std::complex< _Up>  &); 
# 216
template< class _Up> complex &operator-=(const std::complex< _Up>  &); 
# 219
template< class _Up> complex &operator*=(const std::complex< _Up>  &); 
# 222
template< class _Up> complex &operator/=(const std::complex< _Up>  &); 
# 225
constexpr complex __rep() const 
# 226
{ return *this; } 
# 229
private: _Tp _M_real; 
# 230
_Tp _M_imag; 
# 231
}; 
# 233
template< class _Tp> complex< _Tp>  &
# 235
complex< _Tp> ::operator=(const _Tp &__t) 
# 236
{ 
# 237
(_M_real) = __t; 
# 238
(_M_imag) = _Tp(); 
# 239
return *this; 
# 240
} 
# 243
template< class _Tp> complex< _Tp>  &
# 245
complex< _Tp> ::operator*=(const _Tp &__t) 
# 246
{ 
# 247
(_M_real) *= __t; 
# 248
(_M_imag) *= __t; 
# 249
return *this; 
# 250
} 
# 253
template< class _Tp> complex< _Tp>  &
# 255
complex< _Tp> ::operator/=(const _Tp &__t) 
# 256
{ 
# 257
(_M_real) /= __t; 
# 258
(_M_imag) /= __t; 
# 259
return *this; 
# 260
} 
# 262
template< class _Tp> 
# 263
template< class _Up> complex< _Tp>  &
# 265
complex< _Tp> ::operator=(const std::complex< _Up>  &__z) 
# 266
{ 
# 267
(_M_real) = (__z.real()); 
# 268
(_M_imag) = (__z.imag()); 
# 269
return *this; 
# 270
} 
# 273
template< class _Tp> 
# 274
template< class _Up> complex< _Tp>  &
# 276
complex< _Tp> ::operator+=(const std::complex< _Up>  &__z) 
# 277
{ 
# 278
(_M_real) += (__z.real()); 
# 279
(_M_imag) += (__z.imag()); 
# 280
return *this; 
# 281
} 
# 284
template< class _Tp> 
# 285
template< class _Up> complex< _Tp>  &
# 287
complex< _Tp> ::operator-=(const std::complex< _Up>  &__z) 
# 288
{ 
# 289
(_M_real) -= (__z.real()); 
# 290
(_M_imag) -= (__z.imag()); 
# 291
return *this; 
# 292
} 
# 296
template< class _Tp> 
# 297
template< class _Up> complex< _Tp>  &
# 299
complex< _Tp> ::operator*=(const std::complex< _Up>  &__z) 
# 300
{ 
# 301
const _Tp __r = ((_M_real) * (__z.real())) - ((_M_imag) * (__z.imag())); 
# 302
(_M_imag) = (((_M_real) * (__z.imag())) + ((_M_imag) * (__z.real()))); 
# 303
(_M_real) = __r; 
# 304
return *this; 
# 305
} 
# 309
template< class _Tp> 
# 310
template< class _Up> complex< _Tp>  &
# 312
complex< _Tp> ::operator/=(const std::complex< _Up>  &__z) 
# 313
{ 
# 314
const _Tp __r = ((_M_real) * (__z.real())) + ((_M_imag) * (__z.imag())); 
# 315
const _Tp __n = std::norm(__z); 
# 316
(_M_imag) = ((((_M_imag) * (__z.real())) - ((_M_real) * (__z.imag()))) / __n); 
# 317
(_M_real) = (__r / __n); 
# 318
return *this; 
# 319
} 
# 324
template< class _Tp> inline complex< _Tp>  
# 326
operator+(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 327
{ 
# 328
complex< _Tp>  __r = __x; 
# 329
__r += __y; 
# 330
return __r; 
# 331
} 
# 333
template< class _Tp> inline complex< _Tp>  
# 335
operator+(const complex< _Tp>  &__x, const _Tp &__y) 
# 336
{ 
# 337
complex< _Tp>  __r = __x; 
# 338
__r += __y; 
# 339
return __r; 
# 340
} 
# 342
template< class _Tp> inline complex< _Tp>  
# 344
operator+(const _Tp &__x, const complex< _Tp>  &__y) 
# 345
{ 
# 346
complex< _Tp>  __r = __y; 
# 347
__r += __x; 
# 348
return __r; 
# 349
} 
# 354
template< class _Tp> inline complex< _Tp>  
# 356
operator-(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 357
{ 
# 358
complex< _Tp>  __r = __x; 
# 359
__r -= __y; 
# 360
return __r; 
# 361
} 
# 363
template< class _Tp> inline complex< _Tp>  
# 365
operator-(const complex< _Tp>  &__x, const _Tp &__y) 
# 366
{ 
# 367
complex< _Tp>  __r = __x; 
# 368
__r -= __y; 
# 369
return __r; 
# 370
} 
# 372
template< class _Tp> inline complex< _Tp>  
# 374
operator-(const _Tp &__x, const complex< _Tp>  &__y) 
# 375
{ 
# 376
complex< _Tp>  __r(__x, -(__y.imag())); 
# 377
__r -= (__y.real()); 
# 378
return __r; 
# 379
} 
# 384
template< class _Tp> inline complex< _Tp>  
# 386
operator*(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 387
{ 
# 388
complex< _Tp>  __r = __x; 
# 389
__r *= __y; 
# 390
return __r; 
# 391
} 
# 393
template< class _Tp> inline complex< _Tp>  
# 395
operator*(const complex< _Tp>  &__x, const _Tp &__y) 
# 396
{ 
# 397
complex< _Tp>  __r = __x; 
# 398
__r *= __y; 
# 399
return __r; 
# 400
} 
# 402
template< class _Tp> inline complex< _Tp>  
# 404
operator*(const _Tp &__x, const complex< _Tp>  &__y) 
# 405
{ 
# 406
complex< _Tp>  __r = __y; 
# 407
__r *= __x; 
# 408
return __r; 
# 409
} 
# 414
template< class _Tp> inline complex< _Tp>  
# 416
operator/(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 417
{ 
# 418
complex< _Tp>  __r = __x; 
# 419
__r /= __y; 
# 420
return __r; 
# 421
} 
# 423
template< class _Tp> inline complex< _Tp>  
# 425
operator/(const complex< _Tp>  &__x, const _Tp &__y) 
# 426
{ 
# 427
complex< _Tp>  __r = __x; 
# 428
__r /= __y; 
# 429
return __r; 
# 430
} 
# 432
template< class _Tp> inline complex< _Tp>  
# 434
operator/(const _Tp &__x, const complex< _Tp>  &__y) 
# 435
{ 
# 436
complex< _Tp>  __r = __x; 
# 437
__r /= __y; 
# 438
return __r; 
# 439
} 
# 443
template< class _Tp> inline complex< _Tp>  
# 445
operator+(const complex< _Tp>  &__x) 
# 446
{ return __x; } 
# 449
template< class _Tp> inline complex< _Tp>  
# 451
operator-(const complex< _Tp>  &__x) 
# 452
{ return complex< _Tp> (-(__x.real()), -(__x.imag())); } 
# 456
template< class _Tp> constexpr bool 
# 458
operator==(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 459
{ return ((__x.real()) == (__y.real())) && ((__x.imag()) == (__y.imag())); } 
# 461
template< class _Tp> constexpr bool 
# 463
operator==(const complex< _Tp>  &__x, const _Tp &__y) 
# 464
{ return ((__x.real()) == __y) && ((__x.imag()) == _Tp()); } 
# 466
template< class _Tp> constexpr bool 
# 468
operator==(const _Tp &__x, const complex< _Tp>  &__y) 
# 469
{ return (__x == (__y.real())) && (_Tp() == (__y.imag())); } 
# 474
template< class _Tp> constexpr bool 
# 476
operator!=(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 477
{ return ((__x.real()) != (__y.real())) || ((__x.imag()) != (__y.imag())); } 
# 479
template< class _Tp> constexpr bool 
# 481
operator!=(const complex< _Tp>  &__x, const _Tp &__y) 
# 482
{ return ((__x.real()) != __y) || ((__x.imag()) != _Tp()); } 
# 484
template< class _Tp> constexpr bool 
# 486
operator!=(const _Tp &__x, const complex< _Tp>  &__y) 
# 487
{ return (__x != (__y.real())) || (_Tp() != (__y.imag())); } 
# 491
template< class _Tp, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 493
operator>>(basic_istream< _CharT, _Traits>  &__is, complex< _Tp>  &__x) 
# 494
{ 
# 495
_Tp __re_x, __im_x; 
# 496
_CharT __ch; 
# 497
__is >> __ch; 
# 498
if (__ch == '(') 
# 499
{ 
# 500
(__is >> __re_x) >> __ch; 
# 501
if (__ch == ',') 
# 502
{ 
# 503
(__is >> __im_x) >> __ch; 
# 504
if (__ch == ')') { 
# 505
__x = complex< _Tp> (__re_x, __im_x); } else { 
# 507
(__is.setstate(ios_base::failbit)); }  
# 508
} else { 
# 509
if (__ch == ')') { 
# 510
__x = __re_x; } else { 
# 512
(__is.setstate(ios_base::failbit)); }  }  
# 513
} else 
# 515
{ 
# 516
(__is.putback(__ch)); 
# 517
__is >> __re_x; 
# 518
__x = __re_x; 
# 519
}  
# 520
return __is; 
# 521
} 
# 524
template< class _Tp, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 526
operator<<(basic_ostream< _CharT, _Traits>  &__os, const complex< _Tp>  &__x) 
# 527
{ 
# 528
__cxx11::basic_ostringstream< _CharT, _Traits, allocator< _CharT> >  __s; 
# 529
(__s.flags((__os.flags()))); 
# 530
(__s.imbue((__os.getloc()))); 
# 531
(__s.precision((__os.precision()))); 
# 532
((((__s << '(') << (__x.real())) << ',') << (__x.imag())) << ')'; 
# 533
return __os << (__s.str()); 
# 534
} 
# 538
template< class _Tp> constexpr _Tp 
# 540
real(const complex< _Tp>  &__z) 
# 541
{ return (__z.real()); } 
# 543
template< class _Tp> constexpr _Tp 
# 545
imag(const complex< _Tp>  &__z) 
# 546
{ return (__z.imag()); } 
# 570 "/usr/include/c++/5/complex" 3
template< class _Tp> inline _Tp 
# 572
__complex_abs(const complex< _Tp>  &__z) 
# 573
{ 
# 574
_Tp __x = (__z.real()); 
# 575
_Tp __y = (__z.imag()); 
# 576
const _Tp __s = std::max(abs(__x), abs(__y)); 
# 577
if (__s == _Tp()) { 
# 578
return __s; }  
# 579
__x /= __s; 
# 580
__y /= __s; 
# 581
return __s * sqrt((__x * __x) + (__y * __y)); 
# 582
} 
# 586
inline float __complex_abs(float __complex__ __z) { return __builtin_cabsf(__z); } 
# 589
inline double __complex_abs(double __complex__ __z) { return __builtin_cabs(__z); } 
# 592
inline long double __complex_abs(const long double __complex__ &__z) 
# 593
{ return __builtin_cabsl(__z); } 
# 595
template< class _Tp> inline _Tp 
# 597
abs(const complex< _Tp>  &__z) { return __complex_abs((__z.__rep())); } 
# 606 "/usr/include/c++/5/complex" 3
template< class _Tp> inline _Tp 
# 608
__complex_arg(const complex< _Tp>  &__z) 
# 609
{ return atan2((__z.imag()), (__z.real())); } 
# 613
inline float __complex_arg(float __complex__ __z) { return __builtin_cargf(__z); } 
# 616
inline double __complex_arg(double __complex__ __z) { return __builtin_carg(__z); } 
# 619
inline long double __complex_arg(const long double __complex__ &__z) 
# 620
{ return __builtin_cargl(__z); } 
# 622
template< class _Tp> inline _Tp 
# 624
arg(const complex< _Tp>  &__z) { return __complex_arg((__z.__rep())); } 
# 636 "/usr/include/c++/5/complex" 3
template< bool > 
# 637
struct _Norm_helper { 
# 639
template< class _Tp> static _Tp 
# 640
_S_do_it(const complex< _Tp>  &__z) 
# 641
{ 
# 642
const _Tp __x = (__z.real()); 
# 643
const _Tp __y = (__z.imag()); 
# 644
return (__x * __x) + (__y * __y); 
# 645
} 
# 646
}; 
# 649
template<> struct _Norm_helper< true>  { 
# 651
template< class _Tp> static _Tp 
# 652
_S_do_it(const complex< _Tp>  &__z) 
# 653
{ 
# 654
_Tp __res = std::abs(__z); 
# 655
return __res * __res; 
# 656
} 
# 657
}; 
# 659
template< class _Tp> inline _Tp 
# 661
norm(const complex< _Tp>  &__z) 
# 662
{ 
# 663
return _Norm_helper< __is_floating< _Tp> ::__value && (!(0))> ::_S_do_it(__z); 
# 665
} 
# 667
template< class _Tp> inline complex< _Tp>  
# 669
polar(const _Tp &__rho, const _Tp &__theta) 
# 670
{ return complex< _Tp> (__rho * cos(__theta), __rho * sin(__theta)); } 
# 672
template< class _Tp> inline complex< _Tp>  
# 674
conj(const complex< _Tp>  &__z) 
# 675
{ return complex< _Tp> ((__z.real()), -(__z.imag())); } 
# 680
template< class _Tp> inline complex< _Tp>  
# 682
__complex_cos(const complex< _Tp>  &__z) 
# 683
{ 
# 684
const _Tp __x = (__z.real()); 
# 685
const _Tp __y = (__z.imag()); 
# 686
return complex< _Tp> (cos(__x) * cosh(__y), (-sin(__x)) * sinh(__y)); 
# 687
} 
# 691
inline float __complex__ __complex_cos(float __complex__ __z) { return __builtin_ccosf(__z); } 
# 694
inline double __complex__ __complex_cos(double __complex__ __z) { return __builtin_ccos(__z); } 
# 697
inline long double __complex__ __complex_cos(const long double __complex__ &__z) 
# 698
{ return __builtin_ccosl(__z); } 
# 700
template< class _Tp> inline complex< _Tp>  
# 702
cos(const complex< _Tp>  &__z) { return __complex_cos((__z.__rep())); } 
# 710
template< class _Tp> inline complex< _Tp>  
# 712
__complex_cosh(const complex< _Tp>  &__z) 
# 713
{ 
# 714
const _Tp __x = (__z.real()); 
# 715
const _Tp __y = (__z.imag()); 
# 716
return complex< _Tp> (cosh(__x) * cos(__y), sinh(__x) * sin(__y)); 
# 717
} 
# 721
inline float __complex__ __complex_cosh(float __complex__ __z) { return __builtin_ccoshf(__z); } 
# 724
inline double __complex__ __complex_cosh(double __complex__ __z) { return __builtin_ccosh(__z); } 
# 727
inline long double __complex__ __complex_cosh(const long double __complex__ &__z) 
# 728
{ return __builtin_ccoshl(__z); } 
# 730
template< class _Tp> inline complex< _Tp>  
# 732
cosh(const complex< _Tp>  &__z) { return __complex_cosh((__z.__rep())); } 
# 740
template< class _Tp> inline complex< _Tp>  
# 742
__complex_exp(const complex< _Tp>  &__z) 
# 743
{ return std::polar< _Tp> (exp((__z.real())), (__z.imag())); } 
# 747
inline float __complex__ __complex_exp(float __complex__ __z) { return __builtin_cexpf(__z); } 
# 750
inline double __complex__ __complex_exp(double __complex__ __z) { return __builtin_cexp(__z); } 
# 753
inline long double __complex__ __complex_exp(const long double __complex__ &__z) 
# 754
{ return __builtin_cexpl(__z); } 
# 756
template< class _Tp> inline complex< _Tp>  
# 758
exp(const complex< _Tp>  &__z) { return __complex_exp((__z.__rep())); } 
# 767 "/usr/include/c++/5/complex" 3
template< class _Tp> inline complex< _Tp>  
# 769
__complex_log(const complex< _Tp>  &__z) 
# 770
{ return complex< _Tp> (log(std::abs(__z)), std::arg(__z)); } 
# 774
inline float __complex__ __complex_log(float __complex__ __z) { return __builtin_clogf(__z); } 
# 777
inline double __complex__ __complex_log(double __complex__ __z) { return __builtin_clog(__z); } 
# 780
inline long double __complex__ __complex_log(const long double __complex__ &__z) 
# 781
{ return __builtin_clogl(__z); } 
# 783
template< class _Tp> inline complex< _Tp>  
# 785
log(const complex< _Tp>  &__z) { return __complex_log((__z.__rep())); } 
# 792
template< class _Tp> inline complex< _Tp>  
# 794
log10(const complex< _Tp>  &__z) 
# 795
{ return std::log(__z) / log((_Tp)(10.0)); } 
# 798
template< class _Tp> inline complex< _Tp>  
# 800
__complex_sin(const complex< _Tp>  &__z) 
# 801
{ 
# 802
const _Tp __x = (__z.real()); 
# 803
const _Tp __y = (__z.imag()); 
# 804
return complex< _Tp> (sin(__x) * cosh(__y), cos(__x) * sinh(__y)); 
# 805
} 
# 809
inline float __complex__ __complex_sin(float __complex__ __z) { return __builtin_csinf(__z); } 
# 812
inline double __complex__ __complex_sin(double __complex__ __z) { return __builtin_csin(__z); } 
# 815
inline long double __complex__ __complex_sin(const long double __complex__ &__z) 
# 816
{ return __builtin_csinl(__z); } 
# 818
template< class _Tp> inline complex< _Tp>  
# 820
sin(const complex< _Tp>  &__z) { return __complex_sin((__z.__rep())); } 
# 828
template< class _Tp> inline complex< _Tp>  
# 830
__complex_sinh(const complex< _Tp>  &__z) 
# 831
{ 
# 832
const _Tp __x = (__z.real()); 
# 833
const _Tp __y = (__z.imag()); 
# 834
return complex< _Tp> (sinh(__x) * cos(__y), cosh(__x) * sin(__y)); 
# 835
} 
# 839
inline float __complex__ __complex_sinh(float __complex__ __z) { return __builtin_csinhf(__z); } 
# 842
inline double __complex__ __complex_sinh(double __complex__ __z) { return __builtin_csinh(__z); } 
# 845
inline long double __complex__ __complex_sinh(const long double __complex__ &__z) 
# 846
{ return __builtin_csinhl(__z); } 
# 848
template< class _Tp> inline complex< _Tp>  
# 850
sinh(const complex< _Tp>  &__z) { return __complex_sinh((__z.__rep())); } 
# 859 "/usr/include/c++/5/complex" 3
template< class _Tp> complex< _Tp>  
# 861
__complex_sqrt(const complex< _Tp>  &__z) 
# 862
{ 
# 863
_Tp __x = (__z.real()); 
# 864
_Tp __y = (__z.imag()); 
# 866
if (__x == _Tp()) 
# 867
{ 
# 868
_Tp __t = sqrt(abs(__y) / 2); 
# 869
return complex< _Tp> (__t, (__y < _Tp()) ? -__t : __t); 
# 870
} else 
# 872
{ 
# 873
_Tp __t = sqrt(2 * (std::abs(__z) + abs(__x))); 
# 874
_Tp __u = __t / 2; 
# 875
return (__x > _Tp()) ? complex< _Tp> (__u, __y / __t) : complex< _Tp> (abs(__y) / __t, (__y < _Tp()) ? -__u : __u); 
# 878
}  
# 879
} 
# 883
inline float __complex__ __complex_sqrt(float __complex__ __z) { return __builtin_csqrtf(__z); } 
# 886
inline double __complex__ __complex_sqrt(double __complex__ __z) { return __builtin_csqrt(__z); } 
# 889
inline long double __complex__ __complex_sqrt(const long double __complex__ &__z) 
# 890
{ return __builtin_csqrtl(__z); } 
# 892
template< class _Tp> inline complex< _Tp>  
# 894
sqrt(const complex< _Tp>  &__z) { return __complex_sqrt((__z.__rep())); } 
# 903 "/usr/include/c++/5/complex" 3
template< class _Tp> inline complex< _Tp>  
# 905
__complex_tan(const complex< _Tp>  &__z) 
# 906
{ return std::sin(__z) / std::cos(__z); } 
# 910
inline float __complex__ __complex_tan(float __complex__ __z) { return __builtin_ctanf(__z); } 
# 913
inline double __complex__ __complex_tan(double __complex__ __z) { return __builtin_ctan(__z); } 
# 916
inline long double __complex__ __complex_tan(const long double __complex__ &__z) 
# 917
{ return __builtin_ctanl(__z); } 
# 919
template< class _Tp> inline complex< _Tp>  
# 921
tan(const complex< _Tp>  &__z) { return __complex_tan((__z.__rep())); } 
# 931 "/usr/include/c++/5/complex" 3
template< class _Tp> inline complex< _Tp>  
# 933
__complex_tanh(const complex< _Tp>  &__z) 
# 934
{ return std::sinh(__z) / std::cosh(__z); } 
# 938
inline float __complex__ __complex_tanh(float __complex__ __z) { return __builtin_ctanhf(__z); } 
# 941
inline double __complex__ __complex_tanh(double __complex__ __z) { return __builtin_ctanh(__z); } 
# 944
inline long double __complex__ __complex_tanh(const long double __complex__ &__z) 
# 945
{ return __builtin_ctanhl(__z); } 
# 947
template< class _Tp> inline complex< _Tp>  
# 949
tanh(const complex< _Tp>  &__z) { return __complex_tanh((__z.__rep())); } 
# 960 "/usr/include/c++/5/complex" 3
template< class _Tp> complex< _Tp>  
# 962
__complex_pow_unsigned(complex< _Tp>  __x, unsigned __n) 
# 963
{ 
# 964
complex< _Tp>  __y = (__n % (2)) ? __x : ((complex< _Tp> )(1)); 
# 966
while (__n >>= 1) 
# 967
{ 
# 968
__x *= __x; 
# 969
if (__n % (2)) { 
# 970
__y *= __x; }  
# 971
}  
# 973
return __y; 
# 974
} 
# 982
template< class _Tp> inline complex< _Tp>  
# 984
pow(const complex< _Tp>  &__z, int __n) 
# 985
{ 
# 986
return (__n < 0) ? ((complex< _Tp> )(1)) / std::__complex_pow_unsigned(__z, -((unsigned)__n)) : std::__complex_pow_unsigned(__z, __n); 
# 989
} 
# 991
template< class _Tp> complex< _Tp>  
# 993
pow(const complex< _Tp>  &__x, const _Tp &__y) 
# 994
{ 
# 999
if (((__x.imag()) == _Tp()) && ((__x.real()) > _Tp())) { 
# 1000
return pow((__x.real()), __y); }  
# 1002
complex< _Tp>  __t = std::log(__x); 
# 1003
return std::polar< _Tp> (exp(__y * (__t.real())), __y * (__t.imag())); 
# 1004
} 
# 1006
template< class _Tp> inline complex< _Tp>  
# 1008
__complex_pow(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 1009
{ return (__x == _Tp()) ? _Tp() : std::exp(__y * std::log(__x)); } 
# 1013
inline float __complex__ __complex_pow(float __complex__ __x, float __complex__ __y) 
# 1014
{ return __builtin_cpowf(__x, __y); } 
# 1017
inline double __complex__ __complex_pow(double __complex__ __x, double __complex__ __y) 
# 1018
{ return __builtin_cpow(__x, __y); } 
# 1021
inline long double __complex__ __complex_pow(const long double __complex__ &__x, const long double __complex__ &
# 1022
__y) 
# 1023
{ return __builtin_cpowl(__x, __y); } 
# 1025
template< class _Tp> inline complex< _Tp>  
# 1027
pow(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 1028
{ return __complex_pow((__x.__rep()), (__y.__rep())); } 
# 1036
template< class _Tp> inline complex< _Tp>  
# 1038
pow(const _Tp &__x, const complex< _Tp>  &__y) 
# 1039
{ 
# 1040
return (__x > _Tp()) ? std::polar< _Tp> (pow(__x, (__y.real())), (__y.imag()) * log(__x)) : std::pow(((complex< _Tp> )(__x)), __y); 
# 1043
} 
# 1048
template<> struct complex< float>  { 
# 1050
typedef float value_type; 
# 1051
typedef float __complex__ _ComplexT; 
# 1053
constexpr complex(_ComplexT __z) : _M_value(__z) { } 
# 1055
constexpr complex(float __r = (0.0F), float __i = (0.0F)) : _M_value{__r, __i} 
# 1057
{ } 
# 1065
constexpr explicit complex(const std::complex< double>  &); 
# 1066
constexpr explicit complex(const std::complex< long double>  &); 
# 1071
__attribute((__abi_tag__("cxx11"))) constexpr float 
# 1073
real() const { return __real(_M_value); } 
# 1075
__attribute((__abi_tag__("cxx11"))) constexpr float 
# 1077
imag() const { return __imag(_M_value); } 
# 1095 "/usr/include/c++/5/complex" 3
void real(float __val) { (__real(_M_value)) = __val; } 
# 1098
void imag(float __val) { (__imag(_M_value)) = __val; } 
# 1101
std::complex< float>  &operator=(float __f) 
# 1102
{ 
# 1103
(_M_value) = __f; 
# 1104
return *this; 
# 1105
} 
# 1108
std::complex< float>  &operator+=(float __f) 
# 1109
{ 
# 1110
(_M_value) += __f; 
# 1111
return *this; 
# 1112
} 
# 1115
std::complex< float>  &operator-=(float __f) 
# 1116
{ 
# 1117
(_M_value) -= __f; 
# 1118
return *this; 
# 1119
} 
# 1122
std::complex< float>  &operator*=(float __f) 
# 1123
{ 
# 1124
(_M_value) *= __f; 
# 1125
return *this; 
# 1126
} 
# 1129
std::complex< float>  &operator/=(float __f) 
# 1130
{ 
# 1131
(_M_value) /= __f; 
# 1132
return *this; 
# 1133
} 
# 1139
template< class _Tp> std::complex< float>  &
# 1141
operator=(const std::complex< _Tp>  &__z) 
# 1142
{ 
# 1143
(__real(_M_value)) = (__z.real()); 
# 1144
(__imag(_M_value)) = (__z.imag()); 
# 1145
return *this; 
# 1146
} 
# 1148
template< class _Tp> std::complex< float>  &
# 1150
operator+=(const std::complex< _Tp>  &__z) 
# 1151
{ 
# 1152
(__real(_M_value)) += (__z.real()); 
# 1153
(__imag(_M_value)) += (__z.imag()); 
# 1154
return *this; 
# 1155
} 
# 1157
template< class _Tp> std::complex< float>  &
# 1159
operator-=(const std::complex< _Tp>  &__z) 
# 1160
{ 
# 1161
(__real(_M_value)) -= (__z.real()); 
# 1162
(__imag(_M_value)) -= (__z.imag()); 
# 1163
return *this; 
# 1164
} 
# 1166
template< class _Tp> std::complex< float>  &
# 1168
operator*=(const std::complex< _Tp>  &__z) 
# 1169
{ 
# 1170
_ComplexT __t; 
# 1171
(__real(__t)) = (__z.real()); 
# 1172
(__imag(__t)) = (__z.imag()); 
# 1173
(_M_value) *= __t; 
# 1174
return *this; 
# 1175
} 
# 1177
template< class _Tp> std::complex< float>  &
# 1179
operator/=(const std::complex< _Tp>  &__z) 
# 1180
{ 
# 1181
_ComplexT __t; 
# 1182
(__real(__t)) = (__z.real()); 
# 1183
(__imag(__t)) = (__z.imag()); 
# 1184
(_M_value) /= __t; 
# 1185
return *this; 
# 1186
} 
# 1188
constexpr _ComplexT __rep() const { return _M_value; } 
# 1191
private: _ComplexT _M_value; 
# 1192
}; 
# 1197
template<> struct complex< double>  { 
# 1199
typedef double value_type; 
# 1200
typedef double __complex__ _ComplexT; 
# 1202
constexpr complex(_ComplexT __z) : _M_value(__z) { } 
# 1204
constexpr complex(double __r = (0.0), double __i = (0.0)) : _M_value{__r, __i} 
# 1206
{ } 
# 1214
constexpr complex(const std::complex< float>  &__z) : _M_value(__z.__rep()) 
# 1215
{ } 
# 1217
constexpr explicit complex(const std::complex< long double>  &); 
# 1222
__attribute((__abi_tag__("cxx11"))) constexpr double 
# 1224
real() const { return __real(_M_value); } 
# 1226
__attribute((__abi_tag__("cxx11"))) constexpr double 
# 1228
imag() const { return __imag(_M_value); } 
# 1246 "/usr/include/c++/5/complex" 3
void real(double __val) { (__real(_M_value)) = __val; } 
# 1249
void imag(double __val) { (__imag(_M_value)) = __val; } 
# 1252
std::complex< double>  &operator=(double __d) 
# 1253
{ 
# 1254
(_M_value) = __d; 
# 1255
return *this; 
# 1256
} 
# 1259
std::complex< double>  &operator+=(double __d) 
# 1260
{ 
# 1261
(_M_value) += __d; 
# 1262
return *this; 
# 1263
} 
# 1266
std::complex< double>  &operator-=(double __d) 
# 1267
{ 
# 1268
(_M_value) -= __d; 
# 1269
return *this; 
# 1270
} 
# 1273
std::complex< double>  &operator*=(double __d) 
# 1274
{ 
# 1275
(_M_value) *= __d; 
# 1276
return *this; 
# 1277
} 
# 1280
std::complex< double>  &operator/=(double __d) 
# 1281
{ 
# 1282
(_M_value) /= __d; 
# 1283
return *this; 
# 1284
} 
# 1289
template< class _Tp> std::complex< double>  &
# 1291
operator=(const std::complex< _Tp>  &__z) 
# 1292
{ 
# 1293
(__real(_M_value)) = (__z.real()); 
# 1294
(__imag(_M_value)) = (__z.imag()); 
# 1295
return *this; 
# 1296
} 
# 1298
template< class _Tp> std::complex< double>  &
# 1300
operator+=(const std::complex< _Tp>  &__z) 
# 1301
{ 
# 1302
(__real(_M_value)) += (__z.real()); 
# 1303
(__imag(_M_value)) += (__z.imag()); 
# 1304
return *this; 
# 1305
} 
# 1307
template< class _Tp> std::complex< double>  &
# 1309
operator-=(const std::complex< _Tp>  &__z) 
# 1310
{ 
# 1311
(__real(_M_value)) -= (__z.real()); 
# 1312
(__imag(_M_value)) -= (__z.imag()); 
# 1313
return *this; 
# 1314
} 
# 1316
template< class _Tp> std::complex< double>  &
# 1318
operator*=(const std::complex< _Tp>  &__z) 
# 1319
{ 
# 1320
_ComplexT __t; 
# 1321
(__real(__t)) = (__z.real()); 
# 1322
(__imag(__t)) = (__z.imag()); 
# 1323
(_M_value) *= __t; 
# 1324
return *this; 
# 1325
} 
# 1327
template< class _Tp> std::complex< double>  &
# 1329
operator/=(const std::complex< _Tp>  &__z) 
# 1330
{ 
# 1331
_ComplexT __t; 
# 1332
(__real(__t)) = (__z.real()); 
# 1333
(__imag(__t)) = (__z.imag()); 
# 1334
(_M_value) /= __t; 
# 1335
return *this; 
# 1336
} 
# 1338
constexpr _ComplexT __rep() const { return _M_value; } 
# 1341
private: _ComplexT _M_value; 
# 1342
}; 
# 1347
template<> struct complex< long double>  { 
# 1349
typedef long double value_type; 
# 1350
typedef long double __complex__ _ComplexT; 
# 1352
constexpr complex(_ComplexT __z) : _M_value(__z) { } 
# 1354
constexpr complex(long double __r = (0.0L), long double 
# 1355
__i = (0.0L)) : _M_value{__r, __i} 
# 1357
{ } 
# 1365
constexpr complex(const std::complex< float>  &__z) : _M_value(__z.__rep()) 
# 1366
{ } 
# 1368
constexpr complex(const std::complex< double>  &__z) : _M_value(__z.__rep()) 
# 1369
{ } 
# 1374
__attribute((__abi_tag__("cxx11"))) constexpr long double 
# 1376
real() const { return __real(_M_value); } 
# 1378
__attribute((__abi_tag__("cxx11"))) constexpr long double 
# 1380
imag() const { return __imag(_M_value); } 
# 1398 "/usr/include/c++/5/complex" 3
void real(long double __val) { (__real(_M_value)) = __val; } 
# 1401
void imag(long double __val) { (__imag(_M_value)) = __val; } 
# 1404
std::complex< long double>  &operator=(long double __r) 
# 1405
{ 
# 1406
(_M_value) = __r; 
# 1407
return *this; 
# 1408
} 
# 1411
std::complex< long double>  &operator+=(long double __r) 
# 1412
{ 
# 1413
(_M_value) += __r; 
# 1414
return *this; 
# 1415
} 
# 1418
std::complex< long double>  &operator-=(long double __r) 
# 1419
{ 
# 1420
(_M_value) -= __r; 
# 1421
return *this; 
# 1422
} 
# 1425
std::complex< long double>  &operator*=(long double __r) 
# 1426
{ 
# 1427
(_M_value) *= __r; 
# 1428
return *this; 
# 1429
} 
# 1432
std::complex< long double>  &operator/=(long double __r) 
# 1433
{ 
# 1434
(_M_value) /= __r; 
# 1435
return *this; 
# 1436
} 
# 1441
template< class _Tp> std::complex< long double>  &
# 1443
operator=(const std::complex< _Tp>  &__z) 
# 1444
{ 
# 1445
(__real(_M_value)) = (__z.real()); 
# 1446
(__imag(_M_value)) = (__z.imag()); 
# 1447
return *this; 
# 1448
} 
# 1450
template< class _Tp> std::complex< long double>  &
# 1452
operator+=(const std::complex< _Tp>  &__z) 
# 1453
{ 
# 1454
(__real(_M_value)) += (__z.real()); 
# 1455
(__imag(_M_value)) += (__z.imag()); 
# 1456
return *this; 
# 1457
} 
# 1459
template< class _Tp> std::complex< long double>  &
# 1461
operator-=(const std::complex< _Tp>  &__z) 
# 1462
{ 
# 1463
(__real(_M_value)) -= (__z.real()); 
# 1464
(__imag(_M_value)) -= (__z.imag()); 
# 1465
return *this; 
# 1466
} 
# 1468
template< class _Tp> std::complex< long double>  &
# 1470
operator*=(const std::complex< _Tp>  &__z) 
# 1471
{ 
# 1472
_ComplexT __t; 
# 1473
(__real(__t)) = (__z.real()); 
# 1474
(__imag(__t)) = (__z.imag()); 
# 1475
(_M_value) *= __t; 
# 1476
return *this; 
# 1477
} 
# 1479
template< class _Tp> std::complex< long double>  &
# 1481
operator/=(const std::complex< _Tp>  &__z) 
# 1482
{ 
# 1483
_ComplexT __t; 
# 1484
(__real(__t)) = (__z.real()); 
# 1485
(__imag(__t)) = (__z.imag()); 
# 1486
(_M_value) /= __t; 
# 1487
return *this; 
# 1488
} 
# 1490
constexpr _ComplexT __rep() const { return _M_value; } 
# 1493
private: _ComplexT _M_value; 
# 1494
}; 
# 1499
constexpr complex< float> ::complex(const std::complex< double>  &__z) : _M_value(__z.__rep()) 
# 1500
{ } 
# 1503
constexpr complex< float> ::complex(const std::complex< long double>  &__z) : _M_value(__z.__rep()) 
# 1504
{ } 
# 1507
constexpr complex< double> ::complex(const std::complex< long double>  &__z) : _M_value(__z.__rep()) 
# 1508
{ } 
# 1514
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __is, complex< float>  & __x);
# 1515
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __os, const complex< float>  & __x);
# 1516
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __is, complex< double>  & __x);
# 1517
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __os, const complex< double>  & __x);
# 1518
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __is, complex< long double>  & __x);
# 1519
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __os, const complex< long double>  & __x);
# 1522
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __is, complex< float>  & __x);
# 1523
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os, const complex< float>  & __x);
# 1524
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __is, complex< double>  & __x);
# 1525
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os, const complex< double>  & __x);
# 1526
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __is, complex< long double>  & __x);
# 1527
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os, const complex< long double>  & __x);
# 1534
}
# 1536
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 1541
template< class _Tp, class _Up> 
# 1542
struct __promote_2< std::complex< _Tp> , _Up, typename __promote< std::complex< _Tp> > ::__type, typename __promote< _Up> ::__type>  { 
# 1545
typedef std::complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  __type; 
# 1546
}; 
# 1548
template< class _Tp, class _Up> 
# 1549
struct __promote_2< _Tp, std::complex< _Up> , typename __promote< _Tp> ::__type, typename __promote< std::complex< _Up> > ::__type>  { 
# 1552
typedef std::complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  __type; 
# 1553
}; 
# 1555
template< class _Tp, class _Up> 
# 1556
struct __promote_2< std::complex< _Tp> , std::complex< _Up> , typename __promote< std::complex< _Tp> > ::__type, typename __promote< std::complex< _Up> > ::__type>  { 
# 1559
typedef std::complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  __type; 
# 1560
}; 
# 1563
}
# 1567
namespace std __attribute((__visibility__("default"))) { 
# 1572
template< class _Tp> inline complex< _Tp>  acos(const complex< _Tp>  &); 
# 1573
template< class _Tp> inline complex< _Tp>  asin(const complex< _Tp>  &); 
# 1574
template< class _Tp> inline complex< _Tp>  atan(const complex< _Tp>  &); 
# 1576
template< class _Tp> inline complex< _Tp>  acosh(const complex< _Tp>  &); 
# 1577
template< class _Tp> inline complex< _Tp>  asinh(const complex< _Tp>  &); 
# 1578
template< class _Tp> inline complex< _Tp>  atanh(const complex< _Tp>  &); 
# 1580
template< class _Tp> inline _Tp fabs(const complex< _Tp>  &); 
# 1582
template< class _Tp> inline complex< _Tp>  
# 1584
__complex_acos(const complex< _Tp>  &__z) 
# 1585
{ 
# 1586
const complex< _Tp>  __t = std::asin(__z); 
# 1587
const _Tp __pi_2 = ((1.570796326794896558L)); 
# 1588
return complex< _Tp> (__pi_2 - (__t.real()), -(__t.imag())); 
# 1589
} 
# 1593
inline float __complex__ __complex_acos(float __complex__ __z) 
# 1594
{ return __builtin_cacosf(__z); } 
# 1597
inline double __complex__ __complex_acos(double __complex__ __z) 
# 1598
{ return __builtin_cacos(__z); } 
# 1601
inline long double __complex__ __complex_acos(const long double __complex__ &__z) 
# 1602
{ return __builtin_cacosl(__z); } 
# 1604
template< class _Tp> inline complex< _Tp>  
# 1606
acos(const complex< _Tp>  &__z) 
# 1607
{ return __complex_acos((__z.__rep())); } 
# 1618 "/usr/include/c++/5/complex" 3
template< class _Tp> inline complex< _Tp>  
# 1620
__complex_asin(const complex< _Tp>  &__z) 
# 1621
{ 
# 1622
complex< _Tp>  __t(-(__z.imag()), (__z.real())); 
# 1623
__t = std::asinh(__t); 
# 1624
return complex< _Tp> ((__t.imag()), -(__t.real())); 
# 1625
} 
# 1629
inline float __complex__ __complex_asin(float __complex__ __z) 
# 1630
{ return __builtin_casinf(__z); } 
# 1633
inline double __complex__ __complex_asin(double __complex__ __z) 
# 1634
{ return __builtin_casin(__z); } 
# 1637
inline long double __complex__ __complex_asin(const long double __complex__ &__z) 
# 1638
{ return __builtin_casinl(__z); } 
# 1640
template< class _Tp> inline complex< _Tp>  
# 1642
asin(const complex< _Tp>  &__z) 
# 1643
{ return __complex_asin((__z.__rep())); } 
# 1654 "/usr/include/c++/5/complex" 3
template< class _Tp> complex< _Tp>  
# 1656
__complex_atan(const complex< _Tp>  &__z) 
# 1657
{ 
# 1658
const _Tp __r2 = (__z.real()) * (__z.real()); 
# 1659
const _Tp __x = (((_Tp)(1.0)) - __r2) - ((__z.imag()) * (__z.imag())); 
# 1661
_Tp __num = (__z.imag()) + ((_Tp)(1.0)); 
# 1662
_Tp __den = (__z.imag()) - ((_Tp)(1.0)); 
# 1664
__num = (__r2 + (__num * __num)); 
# 1665
__den = (__r2 + (__den * __den)); 
# 1667
return complex< _Tp> (((_Tp)(0.5)) * atan2(((_Tp)(2.0)) * (__z.real()), __x), ((_Tp)(0.25)) * log(__num / __den)); 
# 1669
} 
# 1673
inline float __complex__ __complex_atan(float __complex__ __z) 
# 1674
{ return __builtin_catanf(__z); } 
# 1677
inline double __complex__ __complex_atan(double __complex__ __z) 
# 1678
{ return __builtin_catan(__z); } 
# 1681
inline long double __complex__ __complex_atan(const long double __complex__ &__z) 
# 1682
{ return __builtin_catanl(__z); } 
# 1684
template< class _Tp> inline complex< _Tp>  
# 1686
atan(const complex< _Tp>  &__z) 
# 1687
{ return __complex_atan((__z.__rep())); } 
# 1698 "/usr/include/c++/5/complex" 3
template< class _Tp> complex< _Tp>  
# 1700
__complex_acosh(const complex< _Tp>  &__z) 
# 1701
{ 
# 1703
return ((_Tp)(2.0)) * std::log(std::sqrt(((_Tp)(0.5)) * (__z + ((_Tp)(1.0)))) + std::sqrt(((_Tp)(0.5)) * (__z - ((_Tp)(1.0))))); 
# 1705
} 
# 1709
inline float __complex__ __complex_acosh(float __complex__ __z) 
# 1710
{ return __builtin_cacoshf(__z); } 
# 1713
inline double __complex__ __complex_acosh(double __complex__ __z) 
# 1714
{ return __builtin_cacosh(__z); } 
# 1717
inline long double __complex__ __complex_acosh(const long double __complex__ &__z) 
# 1718
{ return __builtin_cacoshl(__z); } 
# 1720
template< class _Tp> inline complex< _Tp>  
# 1722
acosh(const complex< _Tp>  &__z) 
# 1723
{ return __complex_acosh((__z.__rep())); } 
# 1734 "/usr/include/c++/5/complex" 3
template< class _Tp> complex< _Tp>  
# 1736
__complex_asinh(const complex< _Tp>  &__z) 
# 1737
{ 
# 1738
complex< _Tp>  __t((((__z.real()) - (__z.imag())) * ((__z.real()) + (__z.imag()))) + ((_Tp)(1.0)), (((_Tp)(2.0)) * (__z.real())) * (__z.imag())); 
# 1741
__t = std::sqrt(__t); 
# 1743
return std::log(__t + __z); 
# 1744
} 
# 1748
inline float __complex__ __complex_asinh(float __complex__ __z) 
# 1749
{ return __builtin_casinhf(__z); } 
# 1752
inline double __complex__ __complex_asinh(double __complex__ __z) 
# 1753
{ return __builtin_casinh(__z); } 
# 1756
inline long double __complex__ __complex_asinh(const long double __complex__ &__z) 
# 1757
{ return __builtin_casinhl(__z); } 
# 1759
template< class _Tp> inline complex< _Tp>  
# 1761
asinh(const complex< _Tp>  &__z) 
# 1762
{ return __complex_asinh((__z.__rep())); } 
# 1773 "/usr/include/c++/5/complex" 3
template< class _Tp> complex< _Tp>  
# 1775
__complex_atanh(const complex< _Tp>  &__z) 
# 1776
{ 
# 1777
const _Tp __i2 = (__z.imag()) * (__z.imag()); 
# 1778
const _Tp __x = (((_Tp)(1.0)) - __i2) - ((__z.real()) * (__z.real())); 
# 1780
_Tp __num = ((_Tp)(1.0)) + (__z.real()); 
# 1781
_Tp __den = ((_Tp)(1.0)) - (__z.real()); 
# 1783
__num = (__i2 + (__num * __num)); 
# 1784
__den = (__i2 + (__den * __den)); 
# 1786
return complex< _Tp> (((_Tp)(0.25)) * (log(__num) - log(__den)), ((_Tp)(0.5)) * atan2(((_Tp)(2.0)) * (__z.imag()), __x)); 
# 1788
} 
# 1792
inline float __complex__ __complex_atanh(float __complex__ __z) 
# 1793
{ return __builtin_catanhf(__z); } 
# 1796
inline double __complex__ __complex_atanh(double __complex__ __z) 
# 1797
{ return __builtin_catanh(__z); } 
# 1800
inline long double __complex__ __complex_atanh(const long double __complex__ &__z) 
# 1801
{ return __builtin_catanhl(__z); } 
# 1803
template< class _Tp> inline complex< _Tp>  
# 1805
atanh(const complex< _Tp>  &__z) 
# 1806
{ return __complex_atanh((__z.__rep())); } 
# 1817 "/usr/include/c++/5/complex" 3
template< class _Tp> inline _Tp 
# 1822
fabs(const complex< _Tp>  &__z) 
# 1823
{ return std::abs(__z); } 
# 1826
template< class _Tp> inline typename __gnu_cxx::__promote< _Tp> ::__type 
# 1828
arg(_Tp __x) 
# 1829
{ 
# 1830
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 1832
return (std::signbit(__x)) ? (__type)(3.141592653589793116L) : (__type()); 
# 1837
} 
# 1839
template< class _Tp> inline typename __gnu_cxx::__promote< _Tp> ::__type 
# 1841
imag(_Tp) 
# 1842
{ return _Tp(); } 
# 1844
template< class _Tp> inline typename __gnu_cxx::__promote< _Tp> ::__type 
# 1846
norm(_Tp __x) 
# 1847
{ 
# 1848
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 1849
return ((__type)__x) * ((__type)__x); 
# 1850
} 
# 1852
template< class _Tp> inline typename __gnu_cxx::__promote< _Tp> ::__type 
# 1854
real(_Tp __x) 
# 1855
{ return __x; } 
# 1857
template< class _Tp, class _Up> inline complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  
# 1859
pow(const complex< _Tp>  &__x, const _Up &__y) 
# 1860
{ 
# 1861
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1862
return std::pow(((complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type> )(__x)), (__type)__y); 
# 1863
} 
# 1865
template< class _Tp, class _Up> inline complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  
# 1867
pow(const _Tp &__x, const complex< _Up>  &__y) 
# 1868
{ 
# 1869
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1870
return std::pow((__type)__x, ((complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type> )(__y))); 
# 1871
} 
# 1873
template< class _Tp, class _Up> inline complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  
# 1875
pow(const complex< _Tp>  &__x, const complex< _Up>  &__y) 
# 1876
{ 
# 1877
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1878
return std::pow(((complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type> )(__x)), ((complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type> )(__y))); 
# 1880
} 
# 1884
template< class _Tp> inline complex< _Tp>  proj(const complex< _Tp>  &); 
# 1886
template< class _Tp> complex< _Tp>  
# 1888
__complex_proj(const complex< _Tp>  &__z) 
# 1889
{ 
# 1890
const _Tp __den = (((__z.real()) * (__z.real())) + ((__z.imag()) * (__z.imag()))) + ((_Tp)(1.0)); 
# 1893
return complex< _Tp> ((((_Tp)(2.0)) * (__z.real())) / __den, (((_Tp)(2.0)) * (__z.imag())) / __den); 
# 1895
} 
# 1899
inline float __complex__ __complex_proj(float __complex__ __z) 
# 1900
{ return __builtin_cprojf(__z); } 
# 1903
inline double __complex__ __complex_proj(double __complex__ __z) 
# 1904
{ return __builtin_cproj(__z); } 
# 1907
inline long double __complex__ __complex_proj(const long double __complex__ &__z) 
# 1908
{ return __builtin_cprojl(__z); } 
# 1910
template< class _Tp> inline complex< _Tp>  
# 1912
proj(const complex< _Tp>  &__z) 
# 1913
{ return __complex_proj((__z.__rep())); } 
# 1922 "/usr/include/c++/5/complex" 3
template< class _Tp> inline typename __gnu_cxx::__promote< _Tp> ::__type 
# 1924
proj(_Tp __x) 
# 1925
{ return __x; } 
# 1927
template< class _Tp> inline typename __gnu_cxx::__promote< _Tp> ::__type 
# 1929
conj(_Tp __x) 
# 1930
{ return __x; } 
# 1969 "/usr/include/c++/5/complex" 3
}
# 57 "/usr/include/opencv2/core/cvstd.inl.hpp" 3
namespace cv { 
# 60
template< class _Tp> class DataType< std::complex< _Tp> >  { 
# 63
public: typedef std::complex< _Tp>  value_type; 
# 64
typedef value_type work_type; 
# 65
typedef _Tp channel_type; 
# 67
enum { generic_type, 
# 68
depth = cv::DataType< _Tp> ::depth, 
# 69
channels = 2, 
# 70
fmt = DataType< _Tp> ::fmt + (((2) - 1) << 8), 
# 71
type = ((cv::DataType< _Tp> ::depth) & ((1 << 3) - 1)) + (((2) - 1) << 3)}; 
# 73
typedef Vec< _Tp, channels>  vec_type; 
# 74
}; 
# 77
inline String::String(const std::__cxx11::string &str) : cstr_((0)), len_((0)) 
# 79
{ 
# 80
if (!str.empty()) 
# 81
{ 
# 82
size_t len = str.size(); 
# 83
if (len) { memcpy(this->allocate(len), str.c_str(), len); }  
# 84
}  
# 85
} 
# 88
inline String::String(const std::__cxx11::string &str, size_t pos, size_t len) : cstr_((0)), len_((0)) 
# 90
{ 
# 91
size_t strlen = str.size(); 
# 92
pos = min(pos, strlen); 
# 93
len = min(strlen - pos, len); 
# 94
if (!len) { return; }  
# 95
memcpy(this->allocate(len), str.c_str() + pos, len); 
# 96
} 
# 99
inline String &String::operator=(const std::__cxx11::string &str) 
# 100
{ 
# 101
this->deallocate(); 
# 102
if (!str.empty()) 
# 103
{ 
# 104
size_t len = str.size(); 
# 105
if (len) { memcpy(this->allocate(len), str.c_str(), len); }  
# 106
}  
# 107
return *this; 
# 108
} 
# 111
inline String &String::operator+=(const std::__cxx11::string &str) 
# 112
{ 
# 113
((*this) = (((*this) + str))); 
# 114
return *this; 
# 115
} 
# 118
inline String::operator std::__cxx11::string() const 
# 119
{ 
# 120
return std::__cxx11::string(cstr_, len_); 
# 121
} 
# 124
inline String operator+(const String &lhs, const std::__cxx11::string &rhs) 
# 125
{ 
# 126
String s; 
# 127
size_t rhslen = rhs.size(); 
# 128
s.allocate((lhs.len_) + rhslen); 
# 129
if (lhs.len_) { memcpy(s.cstr_, lhs.cstr_, lhs.len_); }  
# 130
if (rhslen) { memcpy((s.cstr_) + (lhs.len_), rhs.c_str(), rhslen); }  
# 131
return s; 
# 132
} 
# 135
inline String operator+(const std::__cxx11::string &lhs, const String &rhs) 
# 136
{ 
# 137
String s; 
# 138
size_t lhslen = lhs.size(); 
# 139
s.allocate(lhslen + (rhs.len_)); 
# 140
if (lhslen) { memcpy(s.cstr_, lhs.c_str(), lhslen); }  
# 141
if (rhs.len_) { memcpy((s.cstr_) + lhslen, rhs.cstr_, rhs.len_); }  
# 142
return s; 
# 143
} 
# 146
inline FileNode::operator std::__cxx11::string() const 
# 147
{ 
# 148
String value; 
# 149
read(*this, value, value); 
# 150
return value; 
# 151
} 
# 154
template<> inline void operator>>(const FileNode &n, std::__cxx11::string &value) 
# 155
{ 
# 156
read(n, value, std::__cxx11::string()); 
# 157
} 
# 160
template<> inline FileStorage &operator<<(FileStorage &fs, const std::__cxx11::string &value) 
# 161
{ 
# 162
return (fs << ((String)(value))); 
# 163
} 
# 166
static inline std::ostream &operator<<(std::ostream &os, const String &str) 
# 167
{ 
# 168
return (os << (str.c_str())); 
# 169
} 
# 172
static inline std::ostream &operator<<(std::ostream &out, Ptr< Formatted>  fmtd) 
# 173
{ 
# 174
fmtd->reset(); 
# 175
for (const char *str = fmtd->next(); str; str = fmtd->next()) { 
# 176
(out << str); }  
# 177
return out; 
# 178
} 
# 181
static inline std::ostream &operator<<(std::ostream &out, const Mat &mtx) 
# 182
{ 
# 183
return (out << ((Formatter::get())->format(mtx))); 
# 184
} 
# 187
static inline std::ostream &operator<<(std::ostream &out, const UMat &m) 
# 188
{ 
# 189
return (out << (m.getMat(ACCESS_READ))); 
# 190
} 
# 192
template< class _Tp> static inline std::ostream &
# 193
operator<<(std::ostream &out, const Complex< _Tp>  &c) 
# 194
{ 
# 195
return (((((out << ("("))) << (c.re)) << ",") << (c.im)) << ")"; 
# 196
} 
# 198
template< class _Tp> static inline std::ostream &
# 199
operator<<(std::ostream &out, const std::vector< Point_< _Tp> >  &vec) 
# 200
{ 
# 201
return (out << ((Formatter::get())->format(((Mat)(vec))))); 
# 202
} 
# 205
template< class _Tp> static inline std::ostream &
# 206
operator<<(std::ostream &out, const std::vector< Point3_< _Tp> >  &vec) 
# 207
{ 
# 208
return (out << ((Formatter::get())->format(((Mat)(vec))))); 
# 209
} 
# 212
template< class _Tp, int m, int n> static inline std::ostream &
# 213
operator<<(std::ostream &out, const Matx< _Tp, m, n>  &matx) 
# 214
{ 
# 215
return (out << ((Formatter::get())->format(((Mat)(matx))))); 
# 216
} 
# 218
template< class _Tp> static inline std::ostream &
# 219
operator<<(std::ostream &out, const Point_< _Tp>  &p) 
# 220
{ 
# 221
(((((out << ("["))) << (p.x)) << ", ") << (p.y)) << "]"; 
# 222
return out; 
# 223
} 
# 225
template< class _Tp> static inline std::ostream &
# 226
operator<<(std::ostream &out, const Point3_< _Tp>  &p) 
# 227
{ 
# 228
(((((((out << ("["))) << (p.x)) << ", ") << (p.y)) << ", ") << (p.z)) << "]"; 
# 229
return out; 
# 230
} 
# 232
template< class _Tp, int n> static inline std::ostream &
# 233
operator<<(std::ostream &out, const Vec< _Tp, n>  &vec) 
# 234
{ 
# 235
(out << ("[")); 
# 236
if (cv::traits::Depth< _Tp> ::value <= 4) 
# 237
{ 
# 238
for (int i = 0; i < (n - 1); ++i) { 
# 239
(((out << ((int)(vec[i])))) << (", ")); 
# 240
}  
# 241
(((out << ((int)(vec[n - 1])))) << ("]")); 
# 242
} else 
# 244
{ 
# 245
for (int i = 0; i < (n - 1); ++i) { 
# 246
(out << (vec[i])) << ", "; 
# 247
}  
# 248
(out << (vec[n - 1])) << "]"; 
# 249
}  
# 251
return out; 
# 252
} 
# 254
template< class _Tp> static inline std::ostream &
# 255
operator<<(std::ostream &out, const Size_< _Tp>  &size) 
# 256
{ 
# 257
return (((((out << ("["))) << (size.width)) << " x ") << (size.height)) << "]"; 
# 258
} 
# 260
template< class _Tp> static inline std::ostream &
# 261
operator<<(std::ostream &out, const Rect_< _Tp>  &rect) 
# 262
{ 
# 263
return (((((((((out << ("["))) << (rect.width)) << " x ") << (rect.height)) << " from (") << (rect.x)) << ", ") << (rect.y)) << ")]"; 
# 264
} 
# 266
static inline std::ostream &operator<<(std::ostream &out, const MatSize &msize) 
# 267
{ 
# 268
int i, dims = (msize.p)[-1]; 
# 269
for (i = 0; i < dims; i++) 
# 270
{ 
# 271
(out << ((msize.p)[i])); 
# 272
if (i < (dims - 1)) { 
# 273
(out << (" x ")); }  
# 274
}  
# 275
return out; 
# 276
} 
# 278
}
# 63 "/usr/include/opencv2/core/utility.hpp" 3
namespace cv { 
# 119 "/usr/include/opencv2/core/utility.hpp" 3
template< class _Tp, size_t fixed_size = ((1024) / sizeof(_Tp)) + (8)> class AutoBuffer { 
# 122
public: typedef _Tp value_type; 
# 125
inline AutoBuffer(); 
# 127
inline AutoBuffer(size_t _size); 
# 130
inline AutoBuffer(const AutoBuffer & buf); 
# 132
inline AutoBuffer &operator=(const AutoBuffer & buf); 
# 135
inline ~AutoBuffer(); 
# 138
inline void allocate(size_t _size); 
# 140
inline void deallocate(); 
# 142
inline void resize(size_t _size); 
# 144
inline size_t size() const; 
# 146
inline operator _Tp *(); 
# 148
inline operator const _Tp *() const; 
# 152
protected: _Tp *ptr; 
# 154
size_t sz; 
# 156
_Tp buf[(fixed_size > (0)) ? fixed_size : (1)]; 
# 157
}; 
# 166 "/usr/include/opencv2/core/utility.hpp" 3
__attribute((visibility("default"))) bool setBreakOnError(bool flag); 
# 168
extern "C" { typedef int (*ErrorCallback)(int status, const char * func_name, const char * err_msg, const char * file_name, int line, void * userdata); }
# 183 "/usr/include/opencv2/core/utility.hpp" 3
__attribute((visibility("default"))) ErrorCallback redirectError(ErrorCallback errCallback, void * userdata = 0, void ** prevUserdata = 0); 
# 191
__attribute((visibility("default"))) String format(const char * fmt, ...); 
# 192
__attribute((visibility("default"))) String tempfile(const char * suffix = 0); 
# 193
__attribute((visibility("default"))) void glob(String pattern, std::vector< String>  & result, bool recursive = false); 
# 213 "/usr/include/opencv2/core/utility.hpp" 3
__attribute((visibility("default"))) void setNumThreads(int nthreads); 
# 231 "/usr/include/opencv2/core/utility.hpp" 3
__attribute((visibility("default"))) int getNumThreads(); 
# 245 "/usr/include/opencv2/core/utility.hpp" 3
__attribute((visibility("default"))) int getThreadNum(); 
# 253
__attribute((visibility("default"))) const String &getBuildInformation(); 
# 262 "/usr/include/opencv2/core/utility.hpp" 3
__attribute((visibility("default"))) int64 getTickCount(); 
# 275 "/usr/include/opencv2/core/utility.hpp" 3
__attribute((visibility("default"))) double getTickFrequency(); 
# 304 "/usr/include/opencv2/core/utility.hpp" 3
class __attribute((visibility("default"))) TickMeter { 
# 308
public: TickMeter() 
# 309
{ 
# 310
this->reset(); 
# 311
} 
# 316
void start() 
# 317
{ 
# 318
(startTime) = cv::getTickCount(); 
# 319
} 
# 324
void stop() 
# 325
{ 
# 326
int64 time = cv::getTickCount(); 
# 327
if ((startTime) == (0)) { 
# 328
return; }  
# 329
++(counter); 
# 330
(sumTime) += (time - (startTime)); 
# 331
(startTime) = (0); 
# 332
} 
# 337
int64 getTimeTicks() const 
# 338
{ 
# 339
return sumTime; 
# 340
} 
# 345
double getTimeMicro() const 
# 346
{ 
# 347
return this->getTimeMilli() * (1000.0); 
# 348
} 
# 353
double getTimeMilli() const 
# 354
{ 
# 355
return this->getTimeSec() * (1000.0); 
# 356
} 
# 361
double getTimeSec() const 
# 362
{ 
# 363
return ((double)this->getTimeTicks()) / getTickFrequency(); 
# 364
} 
# 369
int64 getCounter() const 
# 370
{ 
# 371
return counter; 
# 372
} 
# 377
void reset() 
# 378
{ 
# 379
(startTime) = (0); 
# 380
(sumTime) = (0); 
# 381
(counter) = (0); 
# 382
} 
# 385
private: int64 counter; 
# 386
int64 sumTime; 
# 387
int64 startTime; 
# 388
}; 
# 401 "/usr/include/opencv2/core/utility.hpp" 3
static inline std::ostream &operator<<(std::ostream &out, const TickMeter &tm) 
# 402
{ 
# 403
return (((out << (tm.getTimeSec()))) << ("sec")); 
# 404
} 
# 418 "/usr/include/opencv2/core/utility.hpp" 3
__attribute((visibility("default"))) int64 getCPUTickCount(); 
# 428 "/usr/include/opencv2/core/utility.hpp" 3
__attribute((visibility("default"))) bool checkHardwareSupport(int feature); 
# 432
__attribute((visibility("default"))) int getNumberOfCPUs(); 
# 442 "/usr/include/opencv2/core/utility.hpp" 3
template< class _Tp> static inline _Tp *alignPtr(_Tp *ptr, int n = (int)sizeof(_Tp)) 
# 443
{ 
# 444
; 
# 445
return (_Tp *)(((((size_t)ptr) + n) - (1)) & (-n)); 
# 446
} 
# 455 "/usr/include/opencv2/core/utility.hpp" 3
static inline size_t alignSize(size_t sz, int n) 
# 456
{ 
# 457
; 
# 458
return ((sz + n) - (1)) & (-n); 
# 459
} 
# 467
static inline int divUp(int a, unsigned b) 
# 468
{ 
# 469
; 
# 470
return ((a + b) - (1)) / b; 
# 471
} 
# 473
static inline size_t divUp(size_t a, unsigned b) 
# 474
{ 
# 475
return ((a + b) - (1)) / b; 
# 476
} 
# 491 "/usr/include/opencv2/core/utility.hpp" 3
__attribute((visibility("default"))) void setUseOptimized(bool onoff); 
# 497
__attribute((visibility("default"))) bool useOptimized(); 
# 499
static inline size_t getElemSize(int type) { return (size_t)((((type & ((512 - 1) << 3)) >> 3) + 1) << ((((((sizeof(size_t) / (4)) + (1)) * (16384)) | (14928)) >> ((type & ((1 << 3) - 1)) * 2)) & (3))); } 
# 505
class __attribute((visibility("default"))) ParallelLoopBody { 
# 508
public: virtual ~ParallelLoopBody(); 
# 509
virtual void operator()(const Range & range) const = 0; 
# 510
}; 
# 514
__attribute((visibility("default"))) void parallel_for_(const Range & range, const ParallelLoopBody & body, double nstripes = -(1.0)); 
# 517
class ParallelLoopBodyLambdaWrapper : public ParallelLoopBody { 
# 520
std::function< void (const Range &)>  m_functor; 
# 522
public: ParallelLoopBodyLambdaWrapper(std::function< void (const Range &)>  functor) : m_functor(functor) 
# 524
{ } 
# 526
virtual void operator()(const Range &range) const 
# 527
{ 
# 528
(m_functor)(range); 
# 529
} 
# 530
}; 
# 532
inline void parallel_for_(const Range &range, std::function< void (const Range &)>  functor, double nstripes = -(1.0)) 
# 533
{ 
# 534
parallel_for_(range, ((ParallelLoopBodyLambdaWrapper)(functor)), nstripes); 
# 535
} 
# 539
template< class _Tp, class Functor> inline void 
# 540
Mat::forEach_impl(const Functor &operation) { 
# 541
if (false) { 
# 542
operation(*(reinterpret_cast< _Tp *>(0)), reinterpret_cast< int *>(0)); 
# 547
}  
# 549
if (!(!((this->total() / ((this->size)[(this->dims) - 1])) <= (2147483647)))) { ; } else { cv::error(cv::Error::StsAssert, "this->total() / this->size[this->dims - 1] <= 0x7fffffff", __func__, "/usr/include/opencv2/core/utility.hpp", 549); }  
# 550
const int LINES = static_cast< int>(this->total() / ((this->size)[(this->dims) - 1])); 
# 552
class PixelOperationWrapper : public ParallelLoopBody { 
# 555
public: PixelOperationWrapper(Mat_< _Tp>  *const frame, const Functor &_operation) : mat(frame), op(_operation) 
# 556
{ } 
# 557
virtual ~PixelOperationWrapper() { } 
# 560
virtual void operator()(const Range &range) const { 
# 561
const int DIMS = (((mat)->dims)); 
# 562
const int COLS = ((mat)->size)[DIMS - 1]; 
# 563
if (DIMS <= 2) { 
# 564
for (int row = range.start; row < (range.end); ++row) { 
# 565
this->rowCall2(row, COLS); 
# 566
}  
# 567
} else { 
# 568
std::vector< int>  idx(DIMS); 
# 569
idx[DIMS - 2] = ((range.start) - 1); 
# 571
for (int line_num = range.start; line_num < (range.end); ++line_num) { 
# 572
idx[DIMS - 2]++; 
# 573
for (int i = (DIMS - 2); i >= 0; --i) { 
# 574
if (idx[i] >= (((mat)->size)[i])) { 
# 575
idx[i - 1] += (idx[i] / (((mat)->size)[i])); 
# 576
idx[i] %= (((mat)->size)[i]); 
# 577
continue; 
# 578
} else 
# 579
{ 
# 580
break; 
# 581
}  
# 582
}  
# 583
this->rowCall(&idx[0], COLS, DIMS); 
# 584
}  
# 585
}  
# 586
} 
# 588
private: Mat_< _Tp>  *const mat; 
# 589
const Functor op; 
# 591
void rowCall(int *const idx, const int COLS, const int DIMS) const { 
# 592
int &col = idx[DIMS - 1]; 
# 593
col = 0; 
# 594
_Tp *pixel = (&((mat)->template at< _Tp> (idx))); 
# 596
while (col < COLS) { 
# 597
(op)(*pixel, const_cast< const int *>(idx)); 
# 598
pixel++; col++; 
# 599
}  
# 600
col = 0; 
# 601
} 
# 603
void rowCall2(const int row, const int COLS) const { 
# 604
union Index { 
# 605
int body[2]; 
# 606
operator const int *() const { 
# 607
return reinterpret_cast< const int *>(this); 
# 608
} 
# 609
int &operator[](const int i) { 
# 610
return (body)[i]; 
# 611
} 
# 612
} idx = {{row, 0}}; 
# 617
_Tp *pixel = (&((mat)->template at< _Tp> (idx))); 
# 618
const _Tp *const pixel_end = pixel + COLS; 
# 619
while (pixel < pixel_end) { 
# 620
(op)(*(pixel++), static_cast< const int *>(idx)); 
# 621
(idx[1])++; 
# 622
}  
# 623
} 
# 624
PixelOperationWrapper &operator=(const PixelOperationWrapper &) { 
# 625
if (!(!false)) { ; } else { cv::error(cv::Error::StsAssert, "false", __func__, "/usr/include/opencv2/core/utility.hpp", 625); }  
# 627
return *this; 
# 628
} 
# 629
}; 
# 631
parallel_for_(Range(0, LINES), PixelOperationWrapper(reinterpret_cast< Mat_< _Tp>  *>(this), operation)); 
# 632
} 
# 636
class __attribute((visibility("default"))) Mutex { 
# 639
public: Mutex(); 
# 640
~Mutex(); 
# 641
Mutex(const Mutex & m); 
# 642
Mutex &operator=(const Mutex & m); 
# 644
void lock(); 
# 645
bool trylock(); 
# 646
void unlock(); 
# 648
struct Impl; 
# 650
protected: Impl *impl; 
# 651
}; 
# 653
class __attribute((visibility("default"))) AutoLock { 
# 656
public: AutoLock(Mutex &m) : mutex(&m) { (mutex)->lock(); } 
# 657
~AutoLock() { (mutex)->unlock(); } 
# 659
protected: Mutex *mutex; 
# 661
private: AutoLock(const AutoLock &); 
# 662
AutoLock &operator=(const AutoLock &); 
# 663
}; 
# 666
class __attribute((visibility("default"))) TLSDataContainer { 
# 669
protected: TLSDataContainer(); 
# 670
virtual ~TLSDataContainer(); 
# 672
void gatherData(std::vector< void *>  & data) const; 
# 679
void release(); 
# 682
public: void *getData() const; 
# 684
virtual void *createDataInstance() const = 0; 
# 685
virtual void deleteDataInstance(void * pData) const = 0; 
# 687
int key_; 
# 690
void cleanup(); 
# 691
}; 
# 694
template< class T> 
# 695
class TLSData : protected TLSDataContainer { 
# 698
public: TLSData() { } 
# 699
virtual ~TLSData() { this->TLSDataContainer::release(); } 
# 700
T *get() const { return (T *)this->TLSDataContainer::getData(); } 
# 701
T &getRef() const { T *ptr = (T *)this->TLSDataContainer::getData(); if (!(!ptr)) { ; } else { cv::error(cv::Error::StsAssert, "ptr", __func__, "/usr/include/opencv2/core/utility.hpp", 701); }  return *ptr; } 
# 704
void gather(std::vector< T *>  &data) const 
# 705
{ 
# 706
std::vector< void *>  &dataVoid = reinterpret_cast< std::vector< void *>  &>(data); 
# 707
this->TLSDataContainer::gatherData(dataVoid); 
# 708
} 
# 710
void cleanup() { this->TLSDataContainer::cleanup(); } 
# 713
private: virtual void *createDataInstance() const { return new (T); } 
# 714
virtual void deleteDataInstance(void *pData) const { delete ((T *)pData); } 
# 717
TLSData(TLSData &) { } 
# 718
TLSData &operator=(const TLSData &) { return *this; } 
# 719
}; 
# 798 "/usr/include/opencv2/core/utility.hpp" 3
class __attribute((visibility("default"))) CommandLineParser { 
# 810 "/usr/include/opencv2/core/utility.hpp" 3
public: CommandLineParser(int argc, const char *const  argv[], const String & keys); 
# 813
CommandLineParser(const CommandLineParser & parser); 
# 816
CommandLineParser &operator=(const CommandLineParser & parser); 
# 819
~CommandLineParser(); 
# 831 "/usr/include/opencv2/core/utility.hpp" 3
String getPathToApplication() const; 
# 864 "/usr/include/opencv2/core/utility.hpp" 3
template< class T> T 
# 865
get(const String &name, bool space_delete = true) const 
# 866
{ 
# 867
T val = (T()); 
# 868
this->getByName(name, space_delete, ParamType< T> ::type, (void *)(&val)); 
# 869
return val; 
# 870
} 
# 896 "/usr/include/opencv2/core/utility.hpp" 3
template< class T> T 
# 897
get(int index, bool space_delete = true) const 
# 898
{ 
# 899
T val = (T()); 
# 900
this->getByIndex(index, space_delete, ParamType< T> ::type, (void *)(&val)); 
# 901
return val; 
# 902
} 
# 908
bool has(const String & name) const; 
# 915
bool check() const; 
# 921
void about(const String & message); 
# 929
void printMessage() const; 
# 935
void printErrors() const; 
# 938
protected: void getByName(const String & name, bool space_delete, int type, void * dst) const; 
# 939
void getByIndex(int index, bool space_delete, int type, void * dst) const; 
# 941
struct Impl; 
# 942
Impl *impl; 
# 943
}; 
# 951
template< class _Tp, size_t fixed_size> inline 
# 952
AutoBuffer< _Tp, fixed_size> ::AutoBuffer() 
# 953
{ 
# 954
(ptr) = (buf); 
# 955
(sz) = fixed_size; 
# 956
} 
# 958
template< class _Tp, size_t fixed_size> inline 
# 959
AutoBuffer< _Tp, fixed_size> ::AutoBuffer(size_t _size) 
# 960
{ 
# 961
(ptr) = (buf); 
# 962
(sz) = fixed_size; 
# 963
allocate(_size); 
# 964
} 
# 966
template< class _Tp, size_t fixed_size> inline 
# 967
AutoBuffer< _Tp, fixed_size> ::AutoBuffer(const AutoBuffer &abuf) 
# 968
{ 
# 969
(ptr) = (buf); 
# 970
(sz) = fixed_size; 
# 971
allocate((abuf.size())); 
# 972
for (size_t i = (0); i < (sz); i++) { 
# 973
((ptr)[i]) = ((abuf.ptr)[i]); }  
# 974
} 
# 976
template< class _Tp, size_t fixed_size> inline AutoBuffer< _Tp, fixed_size>  &
# 977
AutoBuffer< _Tp, fixed_size> ::operator=(const AutoBuffer &abuf) 
# 978
{ 
# 979
if (this != (&abuf)) 
# 980
{ 
# 981
deallocate(); 
# 982
allocate((abuf.size())); 
# 983
for (size_t i = (0); i < (sz); i++) { 
# 984
((ptr)[i]) = ((abuf.ptr)[i]); }  
# 985
}  
# 986
return *this; 
# 987
} 
# 989
template< class _Tp, size_t fixed_size> inline 
# 990
AutoBuffer< _Tp, fixed_size> ::~AutoBuffer() 
# 991
{ deallocate(); } 
# 993
template< class _Tp, size_t fixed_size> inline void 
# 994
AutoBuffer< _Tp, fixed_size> ::allocate(size_t _size) 
# 995
{ 
# 996
if (_size <= (sz)) 
# 997
{ 
# 998
(sz) = _size; 
# 999
return; 
# 1000
}  
# 1001
deallocate(); 
# 1002
(sz) = _size; 
# 1003
if (_size > fixed_size) 
# 1004
{ 
# 1005
(ptr) = (new _Tp [_size]); 
# 1006
}  
# 1007
} 
# 1009
template< class _Tp, size_t fixed_size> inline void 
# 1010
AutoBuffer< _Tp, fixed_size> ::deallocate() 
# 1011
{ 
# 1012
if ((ptr) != (buf)) 
# 1013
{ 
# 1014
delete [] (ptr); 
# 1015
(ptr) = (buf); 
# 1016
(sz) = fixed_size; 
# 1017
}  
# 1018
} 
# 1020
template< class _Tp, size_t fixed_size> inline void 
# 1021
AutoBuffer< _Tp, fixed_size> ::resize(size_t _size) 
# 1022
{ 
# 1023
if (_size <= (sz)) 
# 1024
{ 
# 1025
(sz) = _size; 
# 1026
return; 
# 1027
}  
# 1028
size_t i, prevsize = sz, minsize = (prevsize > _size) ? _size : prevsize; 
# 1029
_Tp *prevptr = ptr; 
# 1031
(ptr) = ((_size > fixed_size) ? new _Tp [_size] : (buf)); 
# 1032
(sz) = _size; 
# 1034
if ((ptr) != prevptr) { 
# 1035
for (i = (0); i < minsize; i++) { 
# 1036
((ptr)[i]) = (prevptr[i]); }  }  
# 1037
for (i = prevsize; i < _size; i++) { 
# 1038
((ptr)[i]) = _Tp(); }  
# 1040
if (prevptr != (buf)) { 
# 1041
delete [] prevptr; }  
# 1042
} 
# 1044
template< class _Tp, size_t fixed_size> inline size_t 
# 1045
AutoBuffer< _Tp, fixed_size> ::size() const 
# 1046
{ return sz; } 
# 1048
template< class _Tp, size_t fixed_size> inline 
# 1049
AutoBuffer< _Tp, fixed_size> ::operator _Tp *() 
# 1050
{ return ptr; } 
# 1052
template< class _Tp, size_t fixed_size> inline 
# 1053
AutoBuffer< _Tp, fixed_size> ::operator const _Tp *() const 
# 1054
{ return ptr; } 
# 1056
template<> inline std::__cxx11::string CommandLineParser::get< std::__cxx11::basic_string< char, std::char_traits< char> , std::allocator< char> > > (int index, bool space_delete) const 
# 1057
{ 
# 1058
return (this->get< String> (index, space_delete)); 
# 1059
} 
# 1060
template<> inline std::__cxx11::string CommandLineParser::get< std::__cxx11::basic_string< char, std::char_traits< char> , std::allocator< char> > > (const String &name, bool space_delete) const 
# 1061
{ 
# 1062
return (this->get< String> (name, space_delete)); 
# 1063
} 
# 1069
template< class OBJECT> 
# 1070
class __attribute((visibility("default"))) Node { 
# 1073
public: Node() 
# 1074
{ 
# 1075
(m_pParent) = 0; 
# 1076
} 
# 1077
Node(OBJECT &payload) : m_payload(payload) 
# 1078
{ 
# 1079
(m_pParent) = 0; 
# 1080
} 
# 1081
~Node() 
# 1082
{ 
# 1083
removeChilds(); 
# 1084
if (m_pParent) 
# 1085
{ 
# 1086
int idx = ((m_pParent)->findChild(this)); 
# 1087
if (idx >= 0) { 
# 1088
(((m_pParent)->m_childs).erase((((m_pParent)->m_childs).begin()) + idx)); }  
# 1089
}  
# 1090
} 
# 1092
Node *findChild(OBJECT &payload) const 
# 1093
{ 
# 1094
for (size_t i = (0); i < ((this->m_childs).size()); i++) 
# 1095
{ 
# 1096
if ((((this->m_childs)[i])->m_payload) == payload) { 
# 1097
return (this->m_childs)[i]; }  
# 1098
}  
# 1099
return __null; 
# 1100
} 
# 1102
int findChild(Node *pNode) const 
# 1103
{ 
# 1104
for (size_t i = (0); i < ((this->m_childs).size()); i++) 
# 1105
{ 
# 1106
if (((this->m_childs)[i]) == pNode) { 
# 1107
return (int)i; }  
# 1108
}  
# 1109
return -1; 
# 1110
} 
# 1112
void addChild(Node *pNode) 
# 1113
{ 
# 1114
if (!pNode) { 
# 1115
return; }  
# 1117
if (!(!((pNode->m_pParent) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "pNode->m_pParent == 0", __func__, "/usr/include/opencv2/core/utility.hpp", 1117); }  
# 1118
(pNode->m_pParent) = this; 
# 1119
((this->m_childs).push_back(pNode)); 
# 1120
} 
# 1122
void removeChilds() 
# 1123
{ 
# 1124
for (size_t i = (0); i < ((m_childs).size()); i++) 
# 1125
{ 
# 1126
(((m_childs)[i])->m_pParent) = 0; 
# 1127
delete ((m_childs)[i]); 
# 1128
}  
# 1129
((m_childs).clear()); 
# 1130
} 
# 1132
int getDepth() 
# 1133
{ 
# 1134
int count = 0; 
# 1135
Node *pParent = m_pParent; 
# 1136
while (pParent) { (count++), (pParent = (pParent->m_pParent)); }  
# 1137
return count; 
# 1138
} 
# 1141
OBJECT m_payload; 
# 1142
Node *m_pParent; 
# 1143
std::vector< Node *>  m_childs; 
# 1144
}; 
# 1147
namespace instr { 
# 1152
enum TYPE { 
# 1154
TYPE_GENERAL, 
# 1155
TYPE_MARKER, 
# 1156
TYPE_WRAPPER, 
# 1157
TYPE_FUN
# 1158
}; 
# 1160
enum IMPL { 
# 1162
IMPL_PLAIN, 
# 1163
IMPL_IPP, 
# 1164
IMPL_OPENCL
# 1165
}; 
# 1167
struct NodeDataTls { 
# 1169
NodeDataTls() 
# 1170
{ 
# 1171
(m_ticksTotal) = (0); 
# 1172
} 
# 1173
uint64 m_ticksTotal; 
# 1174
}; 
# 1176
class __attribute((visibility("default"))) NodeData { 
# 1179
public: NodeData(const char * funName = 0, const char * fileName = 0, int lineNum = 0, void * retAddress = 0, bool alwaysExpand = false, TYPE instrType = TYPE_GENERAL, IMPL implType = IMPL_PLAIN); 
# 1180
NodeData(NodeData & ref); 
# 1181
~NodeData(); 
# 1182
NodeData &operator=(const NodeData &); 
# 1184
String m_funName; 
# 1185
TYPE m_instrType; 
# 1186
IMPL m_implType; 
# 1187
const char *m_fileName; 
# 1188
int m_lineNum; 
# 1189
void *m_retAddress; 
# 1190
bool m_alwaysExpand; 
# 1191
bool m_funError; 
# 1193
volatile int m_counter; 
# 1194
volatile uint64 m_ticksTotal; 
# 1195
TLSData< NodeDataTls>  m_tls; 
# 1196
int m_threads; 
# 1199
double getTotalMs() const { return (((double)(m_ticksTotal)) / cv::getTickFrequency()) * (1000); } 
# 1200
double getMeanMs() const { return ((((double)(m_ticksTotal)) / (m_counter)) / cv::getTickFrequency()) * (1000); } 
# 1201
}; 
# 1202
bool operator==(const NodeData & lhs, const NodeData & rhs); 
# 1204
typedef Node< NodeData>  InstrNode; 
# 1206
__attribute((visibility("default"))) InstrNode *getTrace(); 
# 1211
__attribute((visibility("default"))) bool useInstrumentation(); 
# 1212
__attribute((visibility("default"))) void setUseInstrumentation(bool flag); 
# 1213
__attribute((visibility("default"))) void resetTrace(); 
# 1215
enum FLAGS { 
# 1217
FLAGS_NONE, 
# 1218
FLAGS_MAPPING, 
# 1219
FLAGS_EXPAND_SAME_NAMES
# 1220
}; 
# 1222
__attribute((visibility("default"))) void setFlags(FLAGS modeFlags); 
# 1223
static inline void setFlags(int modeFlags) { setFlags((FLAGS)modeFlags); } 
# 1224
__attribute((visibility("default"))) FLAGS getFlags(); 
# 1225
}
# 1227
namespace utils { 
# 1229
__attribute((visibility("default"))) int getThreadID(); 
# 1231
}
# 1233
}
# 114 "/usr/include/opencv2/core/types_c.h" 3
typedef void CvArr; 
# 116
typedef int CVStatus; 
# 119
enum { 
# 120
CV_StsOk, 
# 121
CV_StsBackTrace = (-1), 
# 122
CV_StsError = (-2), 
# 123
CV_StsInternal = (-3), 
# 124
CV_StsNoMem = (-4), 
# 125
CV_StsBadArg = (-5), 
# 126
CV_StsBadFunc = (-6), 
# 127
CV_StsNoConv = (-7), 
# 128
CV_StsAutoTrace = (-8), 
# 129
CV_HeaderIsNull = (-9), 
# 130
CV_BadImageSize = (-10), 
# 131
CV_BadOffset = (-11), 
# 132
CV_BadDataPtr = (-12), 
# 133
CV_BadStep = (-13), 
# 134
CV_BadModelOrChSeq = (-14), 
# 135
CV_BadNumChannels = (-15), 
# 136
CV_BadNumChannel1U = (-16), 
# 137
CV_BadDepth = (-17), 
# 138
CV_BadAlphaChannel = (-18), 
# 139
CV_BadOrder = (-19), 
# 140
CV_BadOrigin = (-20), 
# 141
CV_BadAlign = (-21), 
# 142
CV_BadCallBack = (-22), 
# 143
CV_BadTileSize = (-23), 
# 144
CV_BadCOI = (-24), 
# 145
CV_BadROISize = (-25), 
# 146
CV_MaskIsTiled = (-26), 
# 147
CV_StsNullPtr = (-27), 
# 148
CV_StsVecLengthErr = (-28), 
# 149
CV_StsFilterStructContentErr = (-29), 
# 150
CV_StsKernelStructContentErr = (-30), 
# 151
CV_StsFilterOffsetErr = (-31), 
# 152
CV_StsBadSize = (-201), 
# 153
CV_StsDivByZero = (-202), 
# 154
CV_StsInplaceNotSupported = (-203), 
# 155
CV_StsObjectNotFound = (-204), 
# 156
CV_StsUnmatchedFormats = (-205), 
# 157
CV_StsBadFlag = (-206), 
# 158
CV_StsBadPoint = (-207), 
# 159
CV_StsBadMask = (-208), 
# 160
CV_StsUnmatchedSizes = (-209), 
# 161
CV_StsUnsupportedFormat = (-210), 
# 162
CV_StsOutOfRange = (-211), 
# 163
CV_StsParseError = (-212), 
# 164
CV_StsNotImplemented = (-213), 
# 165
CV_StsBadMemBlock = (-214), 
# 166
CV_StsAssert = (-215), 
# 167
CV_GpuNotSupported = (-216), 
# 168
CV_GpuApiCallError = (-217), 
# 169
CV_OpenGlNotSupported = (-218), 
# 170
CV_OpenGlApiCallError = (-219), 
# 171
CV_OpenCLApiCallError = (-220), 
# 172
CV_OpenCLDoubleNotSupported = (-221), 
# 173
CV_OpenCLInitError = (-222), 
# 174
CV_OpenCLNoAMDBlasFft = (-223)
# 175
}; 
# 203 "/usr/include/opencv2/core/types_c.h" 3
typedef uint64 CvRNG; 
# 215 "/usr/include/opencv2/core/types_c.h" 3
static inline CvRNG cvRNG(int64 seed = -1) 
# 216
{ 
# 217
CvRNG rng = (seed) ? (uint64)seed : ((uint64)((int64)(-1))); 
# 218
return rng; 
# 219
} 
# 228 "/usr/include/opencv2/core/types_c.h" 3
static inline unsigned cvRandInt(CvRNG *rng) 
# 229
{ 
# 230
uint64 temp = *rng; 
# 231
temp = ((((uint64)((unsigned)temp)) * (4164903690U)) + (temp >> 32)); 
# 232
(*rng) = temp; 
# 233
return (unsigned)temp; 
# 234
} 
# 242
static inline double cvRandReal(CvRNG *rng) 
# 243
{ 
# 244
return (cvRandInt(rng)) * (2.328306436538696289e-10); 
# 245
} 
# 338 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 300
struct
# 298
 __attribute((visibility("default"))) _IplImage { 
# 302
int nSize; 
# 303
int ID; 
# 304
int nChannels; 
# 305
int alphaChannel; 
# 306
int depth; 
# 308
char colorModel[4]; 
# 309
char channelSeq[4]; 
# 310
int dataOrder; 
# 312
int origin; 
# 314
int align; 
# 316
int width; 
# 317
int height; 
# 318
struct _IplROI *roi; 
# 319
_IplImage *maskROI; 
# 320
void *imageId; 
# 321
struct _IplTileInfo *tileInfo; 
# 322
int imageSize; 
# 325
char *imageData; 
# 326
int widthStep; 
# 327
int BorderMode[4]; 
# 328
int BorderConst[4]; 
# 329
char *imageDataOrigin; 
# 334
_IplImage() { } 
# 335
_IplImage(const cv::Mat & m); 
# 338
} IplImage; 
# 340
typedef _IplTileInfo IplTileInfo; 
# 350
typedef 
# 342
struct _IplROI { 
# 344
int coi; 
# 345
int xOffset; 
# 346
int yOffset; 
# 347
int width; 
# 348
int height; 
# 350
} IplROI; 
# 361
typedef 
# 352
struct _IplConvKernel { 
# 354
int nCols; 
# 355
int nRows; 
# 356
int anchorX; 
# 357
int anchorY; 
# 358
int *values; 
# 359
int nShiftR; 
# 361
} IplConvKernel; 
# 371
typedef 
# 363
struct _IplConvKernelFP { 
# 365
int nCols; 
# 366
int nRows; 
# 367
int anchorX; 
# 368
int anchorY; 
# 369
float *values; 
# 371
} IplConvKernelFP; 
# 466 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 423
struct CvMat { 
# 425
int type; 
# 426
int step; 
# 429
int *refcount; 
# 430
int hdr_refcount; 
# 433
union { 
# 434
uchar *ptr; 
# 435
short *s; 
# 436
int *i; 
# 437
float *fl; 
# 438
double *db; 
# 439
} data; 
# 443
union { 
# 444
int rows; 
# 445
int height; 
# 446
}; 
# 449
union { 
# 450
int cols; 
# 451
int width; 
# 452
}; 
# 460
CvMat() { } 
# 461
CvMat(const CvMat &m) { memcpy(this, &m, sizeof(CvMat)); } 
# 462
inline CvMat(const cv::Mat & m); 
# 466
} CvMat; 
# 509 "/usr/include/opencv2/core/types_c.h" 3
static inline CvMat cvMat(int rows, int cols, int type, void *data = 0) 
# 510
{ 
# 511
CvMat m; 
# 513
(((unsigned)(type & ((1 << 3) - 1))) <= (6)) ? static_cast< void>(0) : __assert_fail("(unsigned)CV_MAT_DEPTH(type) <= CV_64F", "/usr/include/opencv2/core/types_c.h", 513, __PRETTY_FUNCTION__); 
# 514
type = (type & (((1 << 3) * 512) - 1)); 
# 515
(m.type) = ((1111621632 | (1 << 14)) | type); 
# 516
(m.cols) = cols; 
# 517
(m.rows) = rows; 
# 518
(m.step) = ((m.cols) * ((((type & ((512 - 1) << 3)) >> 3) + 1) << ((((((sizeof(size_t) / (4)) + (1)) * (16384)) | (14928)) >> ((type & ((1 << 3) - 1)) * 2)) & (3)))); 
# 519
((m.data).ptr) = ((uchar *)data); 
# 520
(m.refcount) = (__null); 
# 521
(m.hdr_refcount) = 0; 
# 523
return m; 
# 524
} 
# 527
inline CvMat::CvMat(const cv::Mat &m) 
# 528
{ 
# 529
; 
# 530
(*this) = (cvMat(m.rows, ((m.dims) == 1) ? 1 : (m.cols), m.type(), m.data)); 
# 531
(step) = ((int)(m.step)[0]); 
# 532
(type) = (((type) & (~(cv::Mat::CONTINUOUS_FLAG))) | ((m.flags) & (cv::Mat::CONTINUOUS_FLAG))); 
# 533
} 
# 557 "/usr/include/opencv2/core/types_c.h" 3
static inline double cvmGet(const CvMat *mat, int row, int col) 
# 558
{ 
# 559
int type; 
# 561
type = ((mat->type) & (((1 << 3) * 512) - 1)); 
# 562
((((unsigned)row) < ((unsigned)(mat->rows))) && (((unsigned)col) < ((unsigned)(mat->cols)))) ? static_cast< void>(0) : __assert_fail("(unsigned)row < (unsigned)mat->rows && (unsigned)col < (unsigned)mat->cols", "/usr/include/opencv2/core/types_c.h", 563, __PRETTY_FUNCTION__); 
# 565 "/usr/include/opencv2/core/types_c.h" 3
if (type == ((5 & ((1 << 3) - 1)) + ((1 - 1) << 3))) { 
# 566
return ((float *)((void *)(((mat->data).ptr) + (((size_t)(mat->step)) * row))))[col]; } else 
# 568
{ 
# 569
(type == ((6 & ((1 << 3) - 1)) + ((1 - 1) << 3))) ? static_cast< void>(0) : __assert_fail("type == CV_64FC1", "/usr/include/opencv2/core/types_c.h", 569, __PRETTY_FUNCTION__); 
# 570
return ((double *)((void *)(((mat->data).ptr) + (((size_t)(mat->step)) * row))))[col]; 
# 571
}  
# 572
} 
# 584 "/usr/include/opencv2/core/types_c.h" 3
static inline void cvmSet(CvMat *mat, int row, int col, double value) 
# 585
{ 
# 586
int type; 
# 587
type = ((mat->type) & (((1 << 3) * 512) - 1)); 
# 588
((((unsigned)row) < ((unsigned)(mat->rows))) && (((unsigned)col) < ((unsigned)(mat->cols)))) ? static_cast< void>(0) : __assert_fail("(unsigned)row < (unsigned)mat->rows && (unsigned)col < (unsigned)mat->cols", "/usr/include/opencv2/core/types_c.h", 589, __PRETTY_FUNCTION__); 
# 591 "/usr/include/opencv2/core/types_c.h" 3
if (type == ((5 & ((1 << 3) - 1)) + ((1 - 1) << 3))) { 
# 592
(((float *)((void *)(((mat->data).ptr) + (((size_t)(mat->step)) * row))))[col]) = ((float)value); } else 
# 594
{ 
# 595
(type == ((6 & ((1 << 3) - 1)) + ((1 - 1) << 3))) ? static_cast< void>(0) : __assert_fail("type == CV_64FC1", "/usr/include/opencv2/core/types_c.h", 595, __PRETTY_FUNCTION__); 
# 596
(((double *)((void *)(((mat->data).ptr) + (((size_t)(mat->step)) * row))))[col]) = value; 
# 597
}  
# 598
} 
# 601
static inline int cvIplDepth(int type) 
# 602
{ 
# 603
int depth = type & ((1 << 3) - 1); 
# 604
return (((((sizeof(size_t) << 28) | (138682897)) >> ((depth & ((1 << 3) - 1)) * 4)) & (15)) * (8)) | ((((depth == 1) || (depth == 3)) || (depth == 4)) ? 2147483648U : (0)); 
# 606
} 
# 655 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 626
struct
# 624
 __attribute((visibility("default"))) CvMatND { 
# 628
int type; 
# 629
int dims; 
# 631
int *refcount; 
# 632
int hdr_refcount; 
# 635
union { 
# 636
uchar *ptr; 
# 637
float *fl; 
# 638
double *db; 
# 639
int *i; 
# 640
short *s; 
# 641
} data; 
# 644
struct { 
# 645
int size; 
# 646
int step; 
# 648
} dim[32]; 
# 651
CvMatND() { } 
# 652
CvMatND(const cv::Mat & m); 
# 655
} CvMatND; 
# 671 "/usr/include/opencv2/core/types_c.h" 3
struct CvSet; 
# 695
typedef 
# 677
struct
# 675
 __attribute((visibility("default"))) CvSparseMat { 
# 679
int type; 
# 680
int dims; 
# 681
int *refcount; 
# 682
int hdr_refcount; 
# 684
CvSet *heap; 
# 685
void **hashtable; 
# 686
int hashsize; 
# 687
int valoffset; 
# 688
int idxoffset; 
# 689
int size[32]; 
# 692
void copyToSparseMat(cv::SparseMat & m) const; 
# 695
} CvSparseMat; 
# 698
__attribute((visibility("default"))) CvSparseMat *cvCreateSparseMat(const cv::SparseMat & m); 
# 715 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 710
struct CvSparseNode { 
# 712
unsigned hashval; 
# 713
CvSparseNode *next; 
# 715
} CvSparseNode; 
# 723
typedef 
# 717
struct CvSparseMatIterator { 
# 719
CvSparseMat *mat; 
# 720
CvSparseNode *node; 
# 721
int curidx; 
# 723
} CvSparseMatIterator; 
# 732 "/usr/include/opencv2/core/types_c.h" 3
typedef int CvHistType; 
# 756 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 748
struct CvHistogram { 
# 750
int type; 
# 751
CvArr *bins; 
# 752
float thresh[32][2]; 
# 753
float **thresh2; 
# 754
CvMatND mat; 
# 756
} CvHistogram; 
# 793 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 778
struct CvRect { 
# 780
int x; 
# 781
int y; 
# 782
int width; 
# 783
int height; 
# 786
CvRect(int _x = 0, int _y = 0, int w = 0, int h = 0) : x(_x), y(_y), width(w), height(h) { } 
# 787
template< class _Tp> 
# 788
CvRect(const cv::Rect_< _Tp>  &r) : x(cv::saturate_cast< int> ((r.x))), y(cv::saturate_cast< int> ((r.y))), width(cv::saturate_cast< int> ((r.width))), height(cv::saturate_cast< int> ((r.height))) { } 
# 789
template< class _Tp> 
# 790
operator cv::Rect_< _Tp> () const { return cv::Rect_< _Tp> ((_Tp)(x), (_Tp)(y), (_Tp)(width), (_Tp)(height)); } 
# 793
} CvRect; 
# 796
static inline CvRect cvRect(int x, int y, int width, int height) 
# 797
{ 
# 798
CvRect r; 
# 800
(r.x) = x; 
# 801
(r.y) = y; 
# 802
(r.width) = width; 
# 803
(r.height) = height; 
# 805
return r; 
# 806
} 
# 809
static inline IplROI cvRectToROI(CvRect rect, int coi) 
# 810
{ 
# 811
IplROI roi; 
# 812
(roi.xOffset) = (rect.x); 
# 813
(roi.yOffset) = (rect.y); 
# 814
(roi.width) = (rect.width); 
# 815
(roi.height) = (rect.height); 
# 816
(roi.coi) = coi; 
# 818
return roi; 
# 819
} 
# 822
static inline CvRect cvROIToRect(IplROI roi) 
# 823
{ 
# 824
return cvRect(roi.xOffset, roi.yOffset, roi.width, roi.height); 
# 825
} 
# 850 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 835
struct CvTermCriteria { 
# 837
int type; 
# 840
int max_iter; 
# 841
double epsilon; 
# 844
CvTermCriteria(int _type = 0, int _iter = 0, double _eps = 0) : type(_type), max_iter(_iter), epsilon(_eps) { } 
# 845
CvTermCriteria(const cv::TermCriteria &t) : type(t.type), max_iter(t.maxCount), epsilon(t.epsilon) { } 
# 846
operator cv::TermCriteria() const { return cv::TermCriteria(type, max_iter, epsilon); } 
# 850
} CvTermCriteria; 
# 852
static inline CvTermCriteria cvTermCriteria(int type, int max_iter, double epsilon) 
# 853
{ 
# 854
CvTermCriteria t; 
# 856
(t.type) = type; 
# 857
(t.max_iter) = max_iter; 
# 858
(t.epsilon) = ((float)epsilon); 
# 860
return t; 
# 861
} 
# 879
typedef 
# 866
struct CvPoint { 
# 868
int x; 
# 869
int y; 
# 872
CvPoint(int _x = 0, int _y = 0) : x(_x), y(_y) { } 
# 873
template< class _Tp> 
# 874
CvPoint(const cv::Point_< _Tp>  &pt) : x((int)(pt.x)), y((int)(pt.y)) { } 
# 875
template< class _Tp> 
# 876
operator cv::Point_< _Tp> () const { return cv::Point_< _Tp> (cv::saturate_cast< _Tp> (x), cv::saturate_cast< _Tp> (y)); } 
# 879
} CvPoint; 
# 882
static inline CvPoint cvPoint(int x, int y) 
# 883
{ 
# 884
CvPoint p; 
# 886
(p.x) = x; 
# 887
(p.y) = y; 
# 889
return p; 
# 890
} 
# 906
typedef 
# 893
struct CvPoint2D32f { 
# 895
float x; 
# 896
float y; 
# 899
CvPoint2D32f(float _x = 0, float _y = 0) : x(_x), y(_y) { } 
# 900
template< class _Tp> 
# 901
CvPoint2D32f(const cv::Point_< _Tp>  &pt) : x((float)(pt.x)), y((float)(pt.y)) { } 
# 902
template< class _Tp> 
# 903
operator cv::Point_< _Tp> () const { return cv::Point_< _Tp> (cv::saturate_cast< _Tp> (x), cv::saturate_cast< _Tp> (y)); } 
# 906
} CvPoint2D32f; 
# 909
static inline CvPoint2D32f cvPoint2D32f(double x, double y) 
# 910
{ 
# 911
CvPoint2D32f p; 
# 913
(p.x) = ((float)x); 
# 914
(p.y) = ((float)y); 
# 916
return p; 
# 917
} 
# 920
static inline CvPoint2D32f cvPointTo32f(CvPoint point) 
# 921
{ 
# 922
return cvPoint2D32f((float)(point.x), (float)(point.y)); 
# 923
} 
# 926
static inline CvPoint cvPointFrom32f(CvPoint2D32f point) 
# 927
{ 
# 928
CvPoint ipt; 
# 929
(ipt.x) = cvRound(point.x); 
# 930
(ipt.y) = cvRound(point.y); 
# 932
return ipt; 
# 933
} 
# 950
typedef 
# 936
struct CvPoint3D32f { 
# 938
float x; 
# 939
float y; 
# 940
float z; 
# 943
CvPoint3D32f(float _x = 0, float _y = 0, float _z = 0) : x(_x), y(_y), z(_z) { } 
# 944
template< class _Tp> 
# 945
CvPoint3D32f(const cv::Point3_< _Tp>  &pt) : x((float)(pt.x)), y((float)(pt.y)), z((float)(pt.z)) { } 
# 946
template< class _Tp> 
# 947
operator cv::Point3_< _Tp> () const { return cv::Point3_< _Tp> (cv::saturate_cast< _Tp> (x), cv::saturate_cast< _Tp> (y), cv::saturate_cast< _Tp> (z)); } 
# 950
} CvPoint3D32f; 
# 953
static inline CvPoint3D32f cvPoint3D32f(double x, double y, double z) 
# 954
{ 
# 955
CvPoint3D32f p; 
# 957
(p.x) = ((float)x); 
# 958
(p.y) = ((float)y); 
# 959
(p.z) = ((float)z); 
# 961
return p; 
# 962
} 
# 970
typedef 
# 965
struct CvPoint2D64f { 
# 967
double x; 
# 968
double y; 
# 970
} CvPoint2D64f; 
# 973
static inline CvPoint2D64f cvPoint2D64f(double x, double y) 
# 974
{ 
# 975
CvPoint2D64f p; 
# 977
(p.x) = x; 
# 978
(p.y) = y; 
# 980
return p; 
# 981
} 
# 990
typedef 
# 984
struct CvPoint3D64f { 
# 986
double x; 
# 987
double y; 
# 988
double z; 
# 990
} CvPoint3D64f; 
# 993
static inline CvPoint3D64f cvPoint3D64f(double x, double y, double z) 
# 994
{ 
# 995
CvPoint3D64f p; 
# 997
(p.x) = x; 
# 998
(p.y) = y; 
# 999
(p.z) = z; 
# 1001
return p; 
# 1002
} 
# 1020
typedef 
# 1007
struct CvSize { 
# 1009
int width; 
# 1010
int height; 
# 1013
CvSize(int w = 0, int h = 0) : width(w), height(h) { } 
# 1014
template< class _Tp> 
# 1015
CvSize(const cv::Size_< _Tp>  &sz) : width(cv::saturate_cast< int> ((sz.width))), height(cv::saturate_cast< int> ((sz.height))) { } 
# 1016
template< class _Tp> 
# 1017
operator cv::Size_< _Tp> () const { return cv::Size_< _Tp> (cv::saturate_cast< _Tp> (width), cv::saturate_cast< _Tp> (height)); } 
# 1020
} CvSize; 
# 1023
static inline CvSize cvSize(int width, int height) 
# 1024
{ 
# 1025
CvSize s; 
# 1027
(s.width) = width; 
# 1028
(s.height) = height; 
# 1030
return s; 
# 1031
} 
# 1046
typedef 
# 1033
struct CvSize2D32f { 
# 1035
float width; 
# 1036
float height; 
# 1039
CvSize2D32f(float w = 0, float h = 0) : width(w), height(h) { } 
# 1040
template< class _Tp> 
# 1041
CvSize2D32f(const cv::Size_< _Tp>  &sz) : width(cv::saturate_cast< float> ((sz.width))), height(cv::saturate_cast< float> ((sz.height))) { } 
# 1042
template< class _Tp> 
# 1043
operator cv::Size_< _Tp> () const { return cv::Size_< _Tp> (cv::saturate_cast< _Tp> (width), cv::saturate_cast< _Tp> (height)); } 
# 1046
} CvSize2D32f; 
# 1049
static inline CvSize2D32f cvSize2D32f(double width, double height) 
# 1050
{ 
# 1051
CvSize2D32f s; 
# 1053
(s.width) = ((float)width); 
# 1054
(s.height) = ((float)height); 
# 1056
return s; 
# 1057
} 
# 1074
typedef 
# 1061
struct CvBox2D { 
# 1063
CvPoint2D32f center; 
# 1064
CvSize2D32f size; 
# 1065
float angle; 
# 1069
CvBox2D(CvPoint2D32f c = CvPoint2D32f(), CvSize2D32f s = CvSize2D32f(), float a = 0) : center(c), size(s), angle(a) { } 
# 1070
CvBox2D(const cv::RotatedRect &rr) : center(rr.center), size(rr.size), angle(rr.angle) { } 
# 1071
operator cv::RotatedRect() const { return cv::RotatedRect((center), (size), angle); } 
# 1074
} CvBox2D; 
# 1090
typedef 
# 1078
struct CvLineIterator { 
# 1081
uchar *ptr; 
# 1084
int err; 
# 1085
int plus_delta; 
# 1086
int minus_delta; 
# 1087
int plus_step; 
# 1088
int minus_step; 
# 1090
} CvLineIterator; 
# 1108
typedef 
# 1098
struct CvSlice { 
# 1100
int start_index, end_index; 
# 1108
} CvSlice; 
# 1110
static inline CvSlice cvSlice(int start, int end) 
# 1111
{ 
# 1112
CvSlice slice; 
# 1113
(slice.start_index) = start; 
# 1114
(slice.end_index) = end; 
# 1116
return slice; 
# 1117
} 
# 1144
typedef 
# 1124
struct CvScalar { 
# 1126
double val[4]; 
# 1129
CvScalar() { } 
# 1130
CvScalar(double d0, double d1 = 0, double d2 = 0, double d3 = 0) { ((val)[0]) = d0; ((val)[1]) = d1; ((val)[2]) = d2; ((val)[3]) = d3; } 
# 1131
template< class _Tp> 
# 1132
CvScalar(const cv::Scalar_< _Tp>  &s) { ((val)[0]) = ((s.val)[0]); ((val)[1]) = ((s.val)[1]); ((val)[2]) = ((s.val)[2]); ((val)[3]) = ((s.val)[3]); } 
# 1133
template< class _Tp> 
# 1134
operator cv::Scalar_< _Tp> () const { return cv::Scalar_< _Tp> (cv::saturate_cast< _Tp> ((val)[0]), cv::saturate_cast< _Tp> ((val)[1]), cv::saturate_cast< _Tp> ((val)[2]), cv::saturate_cast< _Tp> ((val)[3])); } 
# 1135
template< class _Tp, int cn> 
# 1136
CvScalar(const cv::Vec< _Tp, cn>  &v) 
# 1137
{ 
# 1138
int i; 
# 1139
for (i = 0; i < ((cn < 4) ? cn : 4); i++) { ((val)[i]) = ((v.val)[i]); }  
# 1140
for (; i < 4; i++) { ((val)[i]) = (0); }  
# 1141
} 
# 1144
} CvScalar; 
# 1146
static inline CvScalar cvScalar(double val0, double val1 = 0, double 
# 1147
val2 = 0, double val3 = 0) 
# 1148
{ 
# 1149
CvScalar scalar; 
# 1150
((scalar.val)[0]) = val0; ((scalar.val)[1]) = val1; 
# 1151
((scalar.val)[2]) = val2; ((scalar.val)[3]) = val3; 
# 1152
return scalar; 
# 1153
} 
# 1156
static inline CvScalar cvRealScalar(double val0) 
# 1157
{ 
# 1158
CvScalar scalar; 
# 1159
((scalar.val)[0]) = val0; 
# 1160
((scalar.val)[1]) = (((scalar.val)[2]) = (((scalar.val)[3]) = (0))); 
# 1161
return scalar; 
# 1162
} 
# 1164
static inline CvScalar cvScalarAll(double val0123) 
# 1165
{ 
# 1166
CvScalar scalar; 
# 1167
((scalar.val)[0]) = val0123; 
# 1168
((scalar.val)[1]) = val0123; 
# 1169
((scalar.val)[2]) = val0123; 
# 1170
((scalar.val)[3]) = val0123; 
# 1171
return scalar; 
# 1172
} 
# 1185
typedef 
# 1180
struct CvMemBlock { 
# 1182
CvMemBlock *prev; 
# 1183
CvMemBlock *next; 
# 1185
} CvMemBlock; 
# 1198
typedef 
# 1189
struct CvMemStorage { 
# 1191
int signature; 
# 1192
CvMemBlock *bottom; 
# 1193
CvMemBlock *top; 
# 1194
CvMemStorage *parent; 
# 1195
int block_size; 
# 1196
int free_space; 
# 1198
} CvMemStorage; 
# 1210
typedef 
# 1205
struct CvMemStoragePos { 
# 1207
CvMemBlock *top; 
# 1208
int free_space; 
# 1210
} CvMemStoragePos; 
# 1224
typedef 
# 1215
struct CvSeqBlock { 
# 1217
CvSeqBlock *prev; 
# 1218
CvSeqBlock *next; 
# 1219
int start_index; 
# 1221
int count; 
# 1222
schar *data; 
# 1224
} CvSeqBlock; 
# 1254 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 1250
struct CvSeq { 
# 1252
int flags; int header_size; CvSeq *h_prev; CvSeq *h_next; CvSeq *v_prev; CvSeq *v_next; int total; int elem_size; schar *block_max; schar *ptr; int delta_elems; CvMemStorage *storage; CvSeqBlock *free_blocks; CvSeqBlock *first; 
# 1254
} CvSeq; 
# 1273 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 1269
struct CvSetElem { 
# 1271
int flags; CvSetElem *next_free; 
# 1273
} CvSetElem; 
# 1284
typedef 
# 1280
struct CvSet { 
# 1282
int flags; int header_size; CvSeq *h_prev; CvSeq *h_next; CvSeq *v_prev; CvSeq *v_next; int total; int elem_size; schar *block_max; schar *ptr; int delta_elems; CvMemStorage *storage; CvSeqBlock *free_blocks; CvSeqBlock *first; CvSetElem *free_elems; int active_count; 
# 1284
} CvSet; 
# 1331 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 1327
struct CvGraphEdge { 
# 1329
int flags; float weight; CvGraphEdge *next[2]; struct CvGraphVtx *vtx[2]; 
# 1331
} CvGraphEdge; 
# 1337
typedef 
# 1333
struct CvGraphVtx { 
# 1335
int flags; CvGraphEdge *first; 
# 1337
} CvGraphVtx; 
# 1344
typedef 
# 1339
struct CvGraphVtx2D { 
# 1341
int flags; CvGraphEdge *first; 
# 1342
CvPoint2D32f *ptr; 
# 1344
} CvGraphVtx2D; 
# 1358 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 1354
struct CvGraph { 
# 1356
int flags; int header_size; CvSeq *h_prev; CvSeq *h_next; CvSeq *v_prev; CvSeq *v_next; int total; int elem_size; schar *block_max; schar *ptr; int delta_elems; CvMemStorage *storage; CvSeqBlock *free_blocks; CvSeqBlock *first; CvSetElem *free_elems; int active_count; CvSet *edges; 
# 1358
} CvGraph; 
# 1371
typedef 
# 1366
struct CvChain { 
# 1368
int flags; int header_size; CvSeq *h_prev; CvSeq *h_next; CvSeq *v_prev; CvSeq *v_next; int total; int elem_size; schar *block_max; schar *ptr; int delta_elems; CvMemStorage *storage; CvSeqBlock *free_blocks; CvSeqBlock *first; 
# 1369
CvPoint origin; 
# 1371
} CvChain; 
# 1383
typedef 
# 1379
struct CvContour { 
# 1381
int flags; int header_size; CvSeq *h_prev; CvSeq *h_next; CvSeq *v_prev; CvSeq *v_next; int total; int elem_size; schar *block_max; schar *ptr; int delta_elems; CvMemStorage *storage; CvSeqBlock *free_blocks; CvSeqBlock *first; CvRect rect; int color; int reserved[3]; 
# 1383
} CvContour; 
# 1385
typedef CvContour CvPoint2DSeq; 
# 1526 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 1522
struct CvSeqWriter { 
# 1524
int header_size; CvSeq *seq; CvSeqBlock *block; schar *ptr; schar *block_min; schar *block_max; 
# 1526
} CvSeqWriter; 
# 1543 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 1539
struct CvSeqReader { 
# 1541
int header_size; CvSeq *seq; CvSeqBlock *block; schar *ptr; schar *block_min; schar *block_max; int delta_index; schar *prev_elem; 
# 1543
} CvSeqReader; 
# 1659 "/usr/include/opencv2/core/types_c.h" 3
typedef CvFileStorage CvFileStorage; 
# 1688 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 1683
struct CvAttrList { 
# 1685
const char **attr; 
# 1686
CvAttrList *next; 
# 1688
} CvAttrList; 
# 1691
static inline CvAttrList cvAttrList(const char **attr = 0, CvAttrList *
# 1692
next = 0) 
# 1693
{ 
# 1694
CvAttrList l; 
# 1695
(l.attr) = attr; 
# 1696
(l.next) = next; 
# 1698
return l; 
# 1699
} 
# 1701
struct CvTypeInfo; 
# 1742 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 1737
struct CvString { 
# 1739
int len; 
# 1740
char *ptr; 
# 1742
} CvString; 
# 1752
typedef 
# 1746
struct CvStringHashNode { 
# 1748
unsigned hashval; 
# 1749
CvString str; 
# 1750
CvStringHashNode *next; 
# 1752
} CvStringHashNode; 
# 1754
typedef struct CvGenericHash CvFileNodeHash; 
# 1771
typedef 
# 1757
struct CvFileNode { 
# 1759
int tag; 
# 1760
CvTypeInfo *info; 
# 1763
union { 
# 1764
double f; 
# 1765
int i; 
# 1766
CvString str; 
# 1767
CvSeq *seq; 
# 1768
CvFileNodeHash *map; 
# 1769
} data; 
# 1771
} CvFileNode; 
# 1774
extern "C" {
# 1776
typedef int (*CvIsInstanceFunc)(const void * struct_ptr); 
# 1777
typedef void (*CvReleaseFunc)(void ** struct_dblptr); 
# 1778
typedef void *(*CvReadFunc)(CvFileStorage * storage, CvFileNode * node); 
# 1779
typedef void (*CvWriteFunc)(CvFileStorage * storage, const char * name, const void * struct_ptr, CvAttrList attributes); 
# 1781
typedef void *(*CvCloneFunc)(const void * struct_ptr); 
# 1783
}
# 1809 "/usr/include/opencv2/core/types_c.h" 3
typedef 
# 1796
struct CvTypeInfo { 
# 1798
int flags; 
# 1799
int header_size; 
# 1800
CvTypeInfo *prev; 
# 1801
CvTypeInfo *next; 
# 1802
const char *type_name; 
# 1803
CvIsInstanceFunc is_instance; 
# 1804
CvReleaseFunc release; 
# 1805
CvReadFunc read; 
# 1806
CvWriteFunc write; 
# 1807
CvCloneFunc clone; 
# 1809
} CvTypeInfo; 
# 1822
typedef 
# 1814
struct CvPluginFuncInfo { 
# 1816
void **func_addr; 
# 1817
void *default_func_addr; 
# 1818
const char *func_names; 
# 1819
int search_modules; 
# 1820
int loaded_from; 
# 1822
} CvPluginFuncInfo; 
# 1831
typedef 
# 1824
struct CvModuleInfo { 
# 1826
CvModuleInfo *next; 
# 1827
const char *name; 
# 1828
const char *version; 
# 1829
CvPluginFuncInfo *func_tab; 
# 1831
} CvModuleInfo; 
# 65 "/usr/include/opencv2/core/core_c.h" 3
extern "C" {
# 80 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void *cvAlloc(size_t size); 
# 88
__attribute((visibility("default"))) void cvFree_(void * ptr); 
# 97 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) IplImage *cvCreateImageHeader(CvSize size, int depth, int channels); 
# 109 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) IplImage *cvInitImageHeader(IplImage * image, CvSize size, int depth, int channels, int origin = 0, int align = 4); 
# 125 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) IplImage *cvCreateImage(CvSize size, int depth, int channels); 
# 140 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvReleaseImageHeader(IplImage ** image); 
# 154 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvReleaseImage(IplImage ** image); 
# 157
__attribute((visibility("default"))) IplImage *cvCloneImage(const IplImage * image); 
# 169 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvSetImageCOI(IplImage * image, int coi); 
# 177
__attribute((visibility("default"))) int cvGetImageCOI(const IplImage * image); 
# 190 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvSetImageROI(IplImage * image, CvRect rect); 
# 201 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvResetImageROI(IplImage * image); 
# 208
__attribute((visibility("default"))) CvRect cvGetImageROI(const IplImage * image); 
# 218 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMat *cvCreateMatHeader(int rows, int cols, int type); 
# 254 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMat *cvInitMatHeader(CvMat * mat, int rows, int cols, int type, void * data = 0, int step = 2147483647); 
# 272 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMat *cvCreateMat(int rows, int cols, int type); 
# 285 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvReleaseMat(CvMat ** mat); 
# 298 "/usr/include/opencv2/core/core_c.h" 3
static inline void cvDecRefData(CvArr *arr) 
# 299
{ 
# 300
if ((arr != (__null)) && (((((const CvMat *)arr)->type) & 4294901760U) == (1111621632)) && ((((const CvMat *)arr)->cols) > 0) && ((((const CvMat *)arr)->rows) > 0) && (((((const CvMat *)arr)->data).ptr) != (__null))) 
# 301
{ 
# 302
CvMat *mat = (CvMat *)arr; 
# 303
((mat->data).ptr) = (__null); 
# 304
if (((mat->refcount) != (__null)) && ((--(*(mat->refcount))) == 0)) { 
# 305
cvFree_(*(&(mat->refcount))), ((*(&(mat->refcount))) = (0)); }  
# 306
(mat->refcount) = (__null); 
# 307
} else { 
# 308
if ((arr != (__null)) && (((((const CvMatND *)arr)->type) & 4294901760U) == (1111687168)) && (((((const CvMatND *)arr)->data).ptr) != (__null))) 
# 309
{ 
# 310
CvMatND *mat = (CvMatND *)arr; 
# 311
((mat->data).ptr) = (__null); 
# 312
if (((mat->refcount) != (__null)) && ((--(*(mat->refcount))) == 0)) { 
# 313
cvFree_(*(&(mat->refcount))), ((*(&(mat->refcount))) = (0)); }  
# 314
(mat->refcount) = (__null); 
# 315
}  }  
# 316
} 
# 324
static inline int cvIncRefData(CvArr *arr) 
# 325
{ 
# 326
int refcount = 0; 
# 327
if ((arr != (__null)) && (((((const CvMat *)arr)->type) & 4294901760U) == (1111621632)) && ((((const CvMat *)arr)->cols) > 0) && ((((const CvMat *)arr)->rows) > 0) && (((((const CvMat *)arr)->data).ptr) != (__null))) 
# 328
{ 
# 329
CvMat *mat = (CvMat *)arr; 
# 330
if ((mat->refcount) != (__null)) { 
# 331
refcount = (++(*(mat->refcount))); }  
# 332
} else { 
# 333
if ((arr != (__null)) && (((((const CvMatND *)arr)->type) & 4294901760U) == (1111687168)) && (((((const CvMatND *)arr)->data).ptr) != (__null))) 
# 334
{ 
# 335
CvMatND *mat = (CvMatND *)arr; 
# 336
if ((mat->refcount) != (__null)) { 
# 337
refcount = (++(*(mat->refcount))); }  
# 338
}  }  
# 339
return refcount; 
# 340
} 
# 344
__attribute((visibility("default"))) CvMat *cvCloneMat(const CvMat * mat); 
# 357 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMat *cvGetSubRect(const CvArr * arr, CvMat * submat, CvRect rect); 
# 371 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMat *cvGetRows(const CvArr * arr, CvMat * submat, int start_row, int end_row, int delta_row = 1); 
# 380
static inline CvMat *cvGetRow(const CvArr *arr, CvMat *submat, int row) 
# 381
{ 
# 382
return cvGetRows(arr, submat, row, row + 1, 1); 
# 383
} 
# 398 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMat *cvGetCols(const CvArr * arr, CvMat * submat, int start_col, int end_col); 
# 406
static inline CvMat *cvGetCol(const CvArr *arr, CvMat *submat, int col) 
# 407
{ 
# 408
return cvGetCols(arr, submat, col, col + 1); 
# 409
} 
# 420 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMat *cvGetDiag(const CvArr * arr, CvMat * submat, int diag = 0); 
# 424
__attribute((visibility("default"))) void cvScalarToRawData(const CvScalar * scalar, void * data, int type, int extend_to_12 = 0); 
# 427
__attribute((visibility("default"))) void cvRawDataToScalar(const void * data, int type, CvScalar * scalar); 
# 437 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMatND *cvCreateMatNDHeader(int dims, const int * sizes, int type); 
# 451 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMatND *cvCreateMatND(int dims, const int * sizes, int type); 
# 461 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMatND *cvInitMatNDHeader(CvMatND * mat, int dims, const int * sizes, int type, void * data = 0); 
# 475 "/usr/include/opencv2/core/core_c.h" 3
static inline void cvReleaseMatND(CvMatND **mat) 
# 476
{ 
# 477
cvReleaseMat((CvMat **)mat); 
# 478
} 
# 481
__attribute((visibility("default"))) CvMatND *cvCloneMatND(const CvMatND * mat); 
# 492 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvSparseMat *cvCreateSparseMat(int dims, const int * sizes, int type); 
# 499
__attribute((visibility("default"))) void cvReleaseSparseMat(CvSparseMat ** mat); 
# 502
__attribute((visibility("default"))) CvSparseMat *cvCloneSparseMat(const CvSparseMat * mat); 
# 511 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvSparseNode *cvInitSparseMatIterator(const CvSparseMat * mat, CvSparseMatIterator * mat_iterator); 
# 542 "/usr/include/opencv2/core/core_c.h" 3
static inline CvSparseNode *cvGetNextSparseNode(CvSparseMatIterator *mat_iterator) 
# 543
{ 
# 544
if ((mat_iterator->node)->next) { 
# 545
return (mat_iterator->node) = ((mat_iterator->node)->next); } else 
# 547
{ 
# 548
int idx; 
# 549
for (idx = (++(mat_iterator->curidx)); idx < ((mat_iterator->mat)->hashsize); idx++) 
# 550
{ 
# 551
CvSparseNode *node = (CvSparseNode *)(((mat_iterator->mat)->hashtable)[idx]); 
# 552
if (node) 
# 553
{ 
# 554
(mat_iterator->curidx) = idx; 
# 555
return (mat_iterator->node) = node; 
# 556
}  
# 557
}  
# 558
return __null; 
# 559
}  
# 560
} 
# 576
typedef 
# 566
struct CvNArrayIterator { 
# 568
int count; 
# 569
int dims; 
# 570
CvSize size; 
# 571
uchar *ptr[10]; 
# 572
int stack[32]; 
# 573
CvMatND *hdr[10]; 
# 576
} CvNArrayIterator; 
# 585 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) int cvInitNArrayIterator(int count, CvArr ** arrs, const CvArr * mask, CvMatND * stubs, CvNArrayIterator * array_iterator, int flags = 0); 
# 591
__attribute((visibility("default"))) int cvNextNArraySlice(CvNArrayIterator * array_iterator); 
# 604 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) int cvGetElemType(const CvArr * arr); 
# 622 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) int cvGetDims(const CvArr * arr, int * sizes = 0); 
# 631 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) int cvGetDimSize(const CvArr * arr, int index); 
# 649 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) uchar *cvPtr1D(const CvArr * arr, int idx0, int * type = 0); 
# 651
__attribute((visibility("default"))) uchar *cvPtr2D(const CvArr * arr, int idx0, int idx1, int * type = 0); 
# 653
__attribute((visibility("default"))) uchar *cvPtr3D(const CvArr * arr, int idx0, int idx1, int idx2, int * type = 0); 
# 665 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) uchar *cvPtrND(const CvArr * arr, const int * idx, int * type = 0, int create_node = 1, unsigned * precalc_hashval = 0); 
# 676 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvScalar cvGet1D(const CvArr * arr, int idx0); 
# 678
__attribute((visibility("default"))) CvScalar cvGet2D(const CvArr * arr, int idx0, int idx1); 
# 680
__attribute((visibility("default"))) CvScalar cvGet3D(const CvArr * arr, int idx0, int idx1, int idx2); 
# 685
__attribute((visibility("default"))) CvScalar cvGetND(const CvArr * arr, const int * idx); 
# 698 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) double cvGetReal1D(const CvArr * arr, int idx0); 
# 700
__attribute((visibility("default"))) double cvGetReal2D(const CvArr * arr, int idx0, int idx1); 
# 702
__attribute((visibility("default"))) double cvGetReal3D(const CvArr * arr, int idx0, int idx1, int idx2); 
# 707
__attribute((visibility("default"))) double cvGetRealND(const CvArr * arr, const int * idx); 
# 717 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvSet1D(CvArr * arr, int idx0, CvScalar value); 
# 719
__attribute((visibility("default"))) void cvSet2D(CvArr * arr, int idx0, int idx1, CvScalar value); 
# 721
__attribute((visibility("default"))) void cvSet3D(CvArr * arr, int idx0, int idx1, int idx2, CvScalar value); 
# 727
__attribute((visibility("default"))) void cvSetND(CvArr * arr, const int * idx, CvScalar value); 
# 740 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvSetReal1D(CvArr * arr, int idx0, double value); 
# 742
__attribute((visibility("default"))) void cvSetReal2D(CvArr * arr, int idx0, int idx1, double value); 
# 744
__attribute((visibility("default"))) void cvSetReal3D(CvArr * arr, int idx0, int idx1, int idx2, double value); 
# 751
__attribute((visibility("default"))) void cvSetRealND(CvArr * arr, const int * idx, double value); 
# 755
__attribute((visibility("default"))) void cvClearND(CvArr * arr, const int * idx); 
# 779 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMat *cvGetMat(const CvArr * arr, CvMat * header, int * coi = 0, int allowND = 0); 
# 793 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) IplImage *cvGetImage(const CvArr * arr, IplImage * image_header); 
# 832 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvArr *cvReshapeMatND(const CvArr * arr, int sizeof_header, CvArr * header, int new_cn, int new_dims, int * new_sizes); 
# 867 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvMat *cvReshape(const CvArr * arr, CvMat * header, int new_cn, int new_rows = 0); 
# 872
__attribute((visibility("default"))) void cvRepeat(const CvArr * src, CvArr * dst); 
# 882 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvCreateData(CvArr * arr); 
# 891 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvReleaseData(CvArr * arr); 
# 902 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvSetData(CvArr * arr, void * data, int step); 
# 930 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvGetRawData(const CvArr * arr, uchar ** data, int * step = 0, CvSize * roi_size = 0); 
# 940
__attribute((visibility("default"))) CvSize cvGetSize(const CvArr * arr); 
# 956 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvCopy(const CvArr * src, CvArr * dst, const CvArr * mask = 0); 
# 969 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvSet(CvArr * arr, CvScalar value, const CvArr * mask = 0); 
# 979 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvSetZero(CvArr * arr); 
# 985
__attribute((visibility("default"))) void cvSplit(const CvArr * src, CvArr * dst0, CvArr * dst1, CvArr * dst2, CvArr * dst3); 
# 990
__attribute((visibility("default"))) void cvMerge(const CvArr * src0, const CvArr * src1, const CvArr * src2, const CvArr * src3, CvArr * dst); 
# 996
__attribute((visibility("default"))) void cvMixChannels(const CvArr ** src, int src_count, CvArr ** dst, int dst_count, const int * from_to, int pair_count); 
# 1018 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvConvertScale(const CvArr * src, CvArr * dst, double scale = 1, double shift = 0); 
# 1031 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvConvertScaleAbs(const CvArr * src, CvArr * dst, double scale = 1, double shift = 0); 
# 1041
__attribute((visibility("default"))) CvTermCriteria cvCheckTermCriteria(CvTermCriteria criteria, double default_eps, int default_max_iters); 
# 1050
__attribute((visibility("default"))) void cvAdd(const CvArr * src1, const CvArr * src2, CvArr * dst, const CvArr * mask = 0); 
# 1054
__attribute((visibility("default"))) void cvAddS(const CvArr * src, CvScalar value, CvArr * dst, const CvArr * mask = 0); 
# 1058
__attribute((visibility("default"))) void cvSub(const CvArr * src1, const CvArr * src2, CvArr * dst, const CvArr * mask = 0); 
# 1062
static inline void cvSubS(const CvArr *src, CvScalar value, CvArr *dst, const CvArr *
# 1063
mask = 0) 
# 1064
{ 
# 1065
cvAddS(src, cvScalar(-((value.val)[0]), -((value.val)[1]), -((value.val)[2]), -((value.val)[3])), dst, mask); 
# 1067
} 
# 1070
__attribute((visibility("default"))) void cvSubRS(const CvArr * src, CvScalar value, CvArr * dst, const CvArr * mask = 0); 
# 1075
__attribute((visibility("default"))) void cvMul(const CvArr * src1, const CvArr * src2, CvArr * dst, double scale = 1); 
# 1081
__attribute((visibility("default"))) void cvDiv(const CvArr * src1, const CvArr * src2, CvArr * dst, double scale = 1); 
# 1085
__attribute((visibility("default"))) void cvScaleAdd(const CvArr * src1, CvScalar scale, const CvArr * src2, CvArr * dst); 
# 1090
__attribute((visibility("default"))) void cvAddWeighted(const CvArr * src1, double alpha, const CvArr * src2, double beta, double gamma, CvArr * dst); 
# 1106 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) double cvDotProduct(const CvArr * src1, const CvArr * src2); 
# 1109
__attribute((visibility("default"))) void cvAnd(const CvArr * src1, const CvArr * src2, CvArr * dst, const CvArr * mask = 0); 
# 1113
__attribute((visibility("default"))) void cvAndS(const CvArr * src, CvScalar value, CvArr * dst, const CvArr * mask = 0); 
# 1117
__attribute((visibility("default"))) void cvOr(const CvArr * src1, const CvArr * src2, CvArr * dst, const CvArr * mask = 0); 
# 1121
__attribute((visibility("default"))) void cvOrS(const CvArr * src, CvScalar value, CvArr * dst, const CvArr * mask = 0); 
# 1125
__attribute((visibility("default"))) void cvXor(const CvArr * src1, const CvArr * src2, CvArr * dst, const CvArr * mask = 0); 
# 1129
__attribute((visibility("default"))) void cvXorS(const CvArr * src, CvScalar value, CvArr * dst, const CvArr * mask = 0); 
# 1133
__attribute((visibility("default"))) void cvNot(const CvArr * src, CvArr * dst); 
# 1136
__attribute((visibility("default"))) void cvInRange(const CvArr * src, const CvArr * lower, const CvArr * upper, CvArr * dst); 
# 1140
__attribute((visibility("default"))) void cvInRangeS(const CvArr * src, CvScalar lower, CvScalar upper, CvArr * dst); 
# 1154 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvCmp(const CvArr * src1, const CvArr * src2, CvArr * dst, int cmp_op); 
# 1157
__attribute((visibility("default"))) void cvCmpS(const CvArr * src, double value, CvArr * dst, int cmp_op); 
# 1160
__attribute((visibility("default"))) void cvMin(const CvArr * src1, const CvArr * src2, CvArr * dst); 
# 1163
__attribute((visibility("default"))) void cvMax(const CvArr * src1, const CvArr * src2, CvArr * dst); 
# 1166
__attribute((visibility("default"))) void cvMinS(const CvArr * src, double value, CvArr * dst); 
# 1169
__attribute((visibility("default"))) void cvMaxS(const CvArr * src, double value, CvArr * dst); 
# 1172
__attribute((visibility("default"))) void cvAbsDiff(const CvArr * src1, const CvArr * src2, CvArr * dst); 
# 1175
__attribute((visibility("default"))) void cvAbsDiffS(const CvArr * src, CvArr * dst, CvScalar value); 
# 1184 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvCartToPolar(const CvArr * x, const CvArr * y, CvArr * magnitude, CvArr * angle = 0, int angle_in_degrees = 0); 
# 1191
__attribute((visibility("default"))) void cvPolarToCart(const CvArr * magnitude, const CvArr * angle, CvArr * x, CvArr * y, int angle_in_degrees = 0); 
# 1196
__attribute((visibility("default"))) void cvPow(const CvArr * src, CvArr * dst, double power); 
# 1201
__attribute((visibility("default"))) void cvExp(const CvArr * src, CvArr * dst); 
# 1207
__attribute((visibility("default"))) void cvLog(const CvArr * src, CvArr * dst); 
# 1210
__attribute((visibility("default"))) float cvFastArctan(float y, float x); 
# 1213
__attribute((visibility("default"))) float cvCbrt(float value); 
# 1221
__attribute((visibility("default"))) int cvCheckArr(const CvArr * arr, int flags = 0, double min_val = 0, double max_val = 0); 
# 1244 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvRandArr(CvRNG * rng, CvArr * arr, int dist_type, CvScalar param1, CvScalar param2); 
# 1247
__attribute((visibility("default"))) void cvRandShuffle(CvArr * mat, CvRNG * rng, double iter_factor = (1.0)); 
# 1255
__attribute((visibility("default"))) void cvSort(const CvArr * src, CvArr * dst = 0, CvArr * idxmat = 0, int flags = 0); 
# 1260
__attribute((visibility("default"))) int cvSolveCubic(const CvMat * coeffs, CvMat * roots); 
# 1263
__attribute((visibility("default"))) void cvSolvePoly(const CvMat * coeffs, CvMat * roots2, int maxiter = 20, int fig = 100); 
# 1280 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvCrossProduct(const CvArr * src1, const CvArr * src2, CvArr * dst); 
# 1291 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvGEMM(const CvArr * src1, const CvArr * src2, double alpha, const CvArr * src3, double beta, CvArr * dst, int tABC = 0); 
# 1298
__attribute((visibility("default"))) void cvTransform(const CvArr * src, CvArr * dst, const CvMat * transmat, const CvMat * shiftvec = 0); 
# 1304
__attribute((visibility("default"))) void cvPerspectiveTransform(const CvArr * src, CvArr * dst, const CvMat * mat); 
# 1308
__attribute((visibility("default"))) void cvMulTransposed(const CvArr * src, CvArr * dst, int order, const CvArr * delta = 0, double scale = (1.0)); 
# 1313
__attribute((visibility("default"))) void cvTranspose(const CvArr * src, CvArr * dst); 
# 1317
__attribute((visibility("default"))) void cvCompleteSymm(CvMat * matrix, int LtoR = 0); 
# 1322
__attribute((visibility("default"))) void cvFlip(const CvArr * src, CvArr * dst = 0, int flip_mode = 0); 
# 1332 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvSVD(CvArr * A, CvArr * W, CvArr * U = 0, CvArr * V = 0, int flags = 0); 
# 1337
__attribute((visibility("default"))) void cvSVBkSb(const CvArr * W, const CvArr * U, const CvArr * V, const CvArr * B, CvArr * X, int flags); 
# 1349 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) double cvInvert(const CvArr * src, CvArr * dst, int method = 0); 
# 1355
__attribute((visibility("default"))) int cvSolve(const CvArr * src1, const CvArr * src2, CvArr * dst, int method = 0); 
# 1359
__attribute((visibility("default"))) double cvDet(const CvArr * mat); 
# 1362
__attribute((visibility("default"))) CvScalar cvTrace(const CvArr * mat); 
# 1365
__attribute((visibility("default"))) void cvEigenVV(CvArr * mat, CvArr * evects, CvArr * evals, double eps = 0, int lowindex = -1, int highindex = -1); 
# 1375
__attribute((visibility("default"))) void cvSetIdentity(CvArr * mat, CvScalar value = cvRealScalar(1)); 
# 1378
__attribute((visibility("default"))) CvArr *cvRange(CvArr * mat, double start, double end); 
# 1410 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvCalcCovarMatrix(const CvArr ** vects, int count, CvArr * cov_mat, CvArr * avg, int flags); 
# 1416
__attribute((visibility("default"))) void cvCalcPCA(const CvArr * data, CvArr * mean, CvArr * eigenvals, CvArr * eigenvects, int flags); 
# 1419
__attribute((visibility("default"))) void cvProjectPCA(const CvArr * data, const CvArr * mean, const CvArr * eigenvects, CvArr * result); 
# 1422
__attribute((visibility("default"))) void cvBackProjectPCA(const CvArr * proj, const CvArr * mean, const CvArr * eigenvects, CvArr * result); 
# 1426
__attribute((visibility("default"))) double cvMahalanobis(const CvArr * vec1, const CvArr * vec2, const CvArr * mat); 
# 1434
__attribute((visibility("default"))) CvScalar cvSum(const CvArr * arr); 
# 1437
__attribute((visibility("default"))) int cvCountNonZero(const CvArr * arr); 
# 1440
__attribute((visibility("default"))) CvScalar cvAvg(const CvArr * arr, const CvArr * mask = 0); 
# 1443
__attribute((visibility("default"))) void cvAvgSdv(const CvArr * arr, CvScalar * mean, CvScalar * std_dev, const CvArr * mask = 0); 
# 1447
__attribute((visibility("default"))) void cvMinMaxLoc(const CvArr * arr, double * min_val, double * max_val, CvPoint * min_loc = 0, CvPoint * max_loc = 0, const CvArr * mask = 0); 
# 1475 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) double cvNorm(const CvArr * arr1, const CvArr * arr2 = 0, int norm_type = 4, const CvArr * mask = 0); 
# 1480
__attribute((visibility("default"))) void cvNormalize(const CvArr * src, CvArr * dst, double a = (1.0), double b = (0.0), int norm_type = 4, const CvArr * mask = 0); 
# 1496 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvReduce(const CvArr * src, CvArr * dst, int dim = -1, int op = 0); 
# 1522 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvDFT(const CvArr * src, CvArr * dst, int flags, int nonzero_rows = 0); 
# 1529
__attribute((visibility("default"))) void cvMulSpectrums(const CvArr * src1, const CvArr * src2, CvArr * dst, int flags); 
# 1533
__attribute((visibility("default"))) int cvGetOptimalDFTSize(int size0); 
# 1538
__attribute((visibility("default"))) void cvDCT(const CvArr * src, CvArr * dst, int flags); 
# 1545
__attribute((visibility("default"))) int cvSliceLength(CvSlice slice, const CvSeq * seq); 
# 1551
__attribute((visibility("default"))) CvMemStorage *cvCreateMemStorage(int block_size = 0); 
# 1555
__attribute((visibility("default"))) CvMemStorage *cvCreateChildMemStorage(CvMemStorage * parent); 
# 1560
__attribute((visibility("default"))) void cvReleaseMemStorage(CvMemStorage ** storage); 
# 1567
__attribute((visibility("default"))) void cvClearMemStorage(CvMemStorage * storage); 
# 1570
__attribute((visibility("default"))) void cvSaveMemStoragePos(const CvMemStorage * storage, CvMemStoragePos * pos); 
# 1573
__attribute((visibility("default"))) void cvRestoreMemStoragePos(CvMemStorage * storage, CvMemStoragePos * pos); 
# 1576
__attribute((visibility("default"))) void *cvMemStorageAlloc(CvMemStorage * storage, size_t size); 
# 1579
__attribute((visibility("default"))) CvString cvMemStorageAllocString(CvMemStorage * storage, const char * ptr, int len = -1); 
# 1583
__attribute((visibility("default"))) CvSeq *cvCreateSeq(int seq_flags, size_t header_size, size_t elem_size, CvMemStorage * storage); 
# 1588
__attribute((visibility("default"))) void cvSetSeqBlockSize(CvSeq * seq, int delta_elems); 
# 1592
__attribute((visibility("default"))) schar *cvSeqPush(CvSeq * seq, const void * element = 0); 
# 1596
__attribute((visibility("default"))) schar *cvSeqPushFront(CvSeq * seq, const void * element = 0); 
# 1600
__attribute((visibility("default"))) void cvSeqPop(CvSeq * seq, void * element = 0); 
# 1604
__attribute((visibility("default"))) void cvSeqPopFront(CvSeq * seq, void * element = 0); 
# 1610
__attribute((visibility("default"))) void cvSeqPushMulti(CvSeq * seq, const void * elements, int count, int in_front = 0); 
# 1614
__attribute((visibility("default"))) void cvSeqPopMulti(CvSeq * seq, void * elements, int count, int in_front = 0); 
# 1619
__attribute((visibility("default"))) schar *cvSeqInsert(CvSeq * seq, int before_index, const void * element = 0); 
# 1623
__attribute((visibility("default"))) void cvSeqRemove(CvSeq * seq, int index); 
# 1629
__attribute((visibility("default"))) void cvClearSeq(CvSeq * seq); 
# 1635
__attribute((visibility("default"))) schar *cvGetSeqElem(const CvSeq * seq, int index); 
# 1639
__attribute((visibility("default"))) int cvSeqElemIdx(const CvSeq * seq, const void * element, CvSeqBlock ** block = 0); 
# 1643
__attribute((visibility("default"))) void cvStartAppendToSeq(CvSeq * seq, CvSeqWriter * writer); 
# 1647
__attribute((visibility("default"))) void cvStartWriteSeq(int seq_flags, int header_size, int elem_size, CvMemStorage * storage, CvSeqWriter * writer); 
# 1655
__attribute((visibility("default"))) CvSeq *cvEndWriteSeq(CvSeqWriter * writer); 
# 1660
__attribute((visibility("default"))) void cvFlushSeqWriter(CvSeqWriter * writer); 
# 1665
__attribute((visibility("default"))) void cvStartReadSeq(const CvSeq * seq, CvSeqReader * reader, int reverse = 0); 
# 1670
__attribute((visibility("default"))) int cvGetSeqReaderPos(CvSeqReader * reader); 
# 1675
__attribute((visibility("default"))) void cvSetSeqReaderPos(CvSeqReader * reader, int index, int is_relative = 0); 
# 1679
__attribute((visibility("default"))) void *cvCvtSeqToArray(const CvSeq * seq, void * elements, CvSlice slice = cvSlice(0, 1073741823)); 
# 1685
__attribute((visibility("default"))) CvSeq *cvMakeSeqHeaderForArray(int seq_type, int header_size, int elem_size, void * elements, int total, CvSeq * seq, CvSeqBlock * block); 
# 1690
__attribute((visibility("default"))) CvSeq *cvSeqSlice(const CvSeq * seq, CvSlice slice, CvMemStorage * storage = 0, int copy_data = 0); 
# 1694
static inline CvSeq *cvCloneSeq(const CvSeq *seq, CvMemStorage *storage = 0) 
# 1695
{ 
# 1696
return cvSeqSlice(seq, cvSlice(0, 1073741823), storage, 1); 
# 1697
} 
# 1700
__attribute((visibility("default"))) void cvSeqRemoveSlice(CvSeq * seq, CvSlice slice); 
# 1703
__attribute((visibility("default"))) void cvSeqInsertSlice(CvSeq * seq, int before_index, const CvArr * from_arr); 
# 1706
typedef int (*CvCmpFunc)(const void * a, const void * b, void * userdata); 
# 1709
__attribute((visibility("default"))) void cvSeqSort(CvSeq * seq, CvCmpFunc func, void * userdata = 0); 
# 1712
__attribute((visibility("default"))) schar *cvSeqSearch(CvSeq * seq, const void * elem, CvCmpFunc func, int is_sorted, int * elem_idx, void * userdata = 0); 
# 1717
__attribute((visibility("default"))) void cvSeqInvert(CvSeq * seq); 
# 1720
__attribute((visibility("default"))) int cvSeqPartition(const CvSeq * seq, CvMemStorage * storage, CvSeq ** labels, CvCmpFunc is_equal, void * userdata); 
# 1724
__attribute((visibility("default"))) void cvChangeSeqBlock(void * reader, int direction); 
# 1725
__attribute((visibility("default"))) void cvCreateSeqBlock(CvSeqWriter * writer); 
# 1729
__attribute((visibility("default"))) CvSet *cvCreateSet(int set_flags, int header_size, int elem_size, CvMemStorage * storage); 
# 1733
__attribute((visibility("default"))) int cvSetAdd(CvSet * set_header, CvSetElem * elem = 0, CvSetElem ** inserted_elem = 0); 
# 1737
static inline CvSetElem *cvSetNew(CvSet *set_header) 
# 1738
{ 
# 1739
CvSetElem *elem = set_header->free_elems; 
# 1740
if (elem) 
# 1741
{ 
# 1742
(set_header->free_elems) = (elem->next_free); 
# 1743
(elem->flags) = ((elem->flags) & ((1 << 26) - 1)); 
# 1744
(set_header->active_count)++; 
# 1745
} else { 
# 1747
cvSetAdd(set_header, __null, &elem); }  
# 1748
return elem; 
# 1749
} 
# 1752
static inline void cvSetRemoveByPtr(CvSet *set_header, void *elem) 
# 1753
{ 
# 1754
CvSetElem *_elem = (CvSetElem *)elem; 
# 1755
((_elem->flags) >= 0) ? static_cast< void>(0) : __assert_fail("_elem->flags >= 0", "/usr/include/opencv2/core/core_c.h", 1755, __PRETTY_FUNCTION__); 
# 1756
(_elem->next_free) = (set_header->free_elems); 
# 1757
(_elem->flags) = (((_elem->flags) & ((1 << 26) - 1)) | (1 << ((sizeof(int) * (8)) - (1)))); 
# 1758
(set_header->free_elems) = _elem; 
# 1759
(set_header->active_count)--; 
# 1760
} 
# 1763
__attribute((visibility("default"))) void cvSetRemove(CvSet * set_header, int index); 
# 1767
static inline CvSetElem *cvGetSetElem(const CvSet *set_header, int idx) 
# 1768
{ 
# 1769
CvSetElem *elem = (CvSetElem *)((void *)cvGetSeqElem((CvSeq *)set_header, idx)); 
# 1770
return (elem && ((((CvSetElem *)elem)->flags) >= 0)) ? elem : (0); 
# 1771
} 
# 1774
__attribute((visibility("default"))) void cvClearSet(CvSet * set_header); 
# 1777
__attribute((visibility("default"))) CvGraph *cvCreateGraph(int graph_flags, int header_size, int vtx_size, int edge_size, CvMemStorage * storage); 
# 1782
__attribute((visibility("default"))) int cvGraphAddVtx(CvGraph * graph, const CvGraphVtx * vtx = 0, CvGraphVtx ** inserted_vtx = 0); 
# 1787
__attribute((visibility("default"))) int cvGraphRemoveVtx(CvGraph * graph, int index); 
# 1788
__attribute((visibility("default"))) int cvGraphRemoveVtxByPtr(CvGraph * graph, CvGraphVtx * vtx); 
# 1795
__attribute((visibility("default"))) int cvGraphAddEdge(CvGraph * graph, int start_idx, int end_idx, const CvGraphEdge * edge = 0, CvGraphEdge ** inserted_edge = 0); 
# 1800
__attribute((visibility("default"))) int cvGraphAddEdgeByPtr(CvGraph * graph, CvGraphVtx * start_vtx, CvGraphVtx * end_vtx, const CvGraphEdge * edge = 0, CvGraphEdge ** inserted_edge = 0); 
# 1806
__attribute((visibility("default"))) void cvGraphRemoveEdge(CvGraph * graph, int start_idx, int end_idx); 
# 1807
__attribute((visibility("default"))) void cvGraphRemoveEdgeByPtr(CvGraph * graph, CvGraphVtx * start_vtx, CvGraphVtx * end_vtx); 
# 1811
__attribute((visibility("default"))) CvGraphEdge *cvFindGraphEdge(const CvGraph * graph, int start_idx, int end_idx); 
# 1812
__attribute((visibility("default"))) CvGraphEdge *cvFindGraphEdgeByPtr(const CvGraph * graph, const CvGraphVtx * start_vtx, const CvGraphVtx * end_vtx); 
# 1819
__attribute((visibility("default"))) void cvClearGraph(CvGraph * graph); 
# 1823
__attribute((visibility("default"))) int cvGraphVtxDegree(const CvGraph * graph, int vtx_idx); 
# 1824
__attribute((visibility("default"))) int cvGraphVtxDegreeByPtr(const CvGraph * graph, const CvGraphVtx * vtx); 
# 1871 "/usr/include/opencv2/core/core_c.h" 3
typedef 
# 1860
struct CvGraphScanner { 
# 1862
CvGraphVtx *vtx; 
# 1863
CvGraphVtx *dst; 
# 1864
CvGraphEdge *edge; 
# 1866
CvGraph *graph; 
# 1867
CvSeq *stack; 
# 1868
int index; 
# 1869
int mask; 
# 1871
} CvGraphScanner; 
# 1874
__attribute((visibility("default"))) CvGraphScanner *cvCreateGraphScanner(CvGraph * graph, CvGraphVtx * vtx = 0, int mask = -1); 
# 1879
__attribute((visibility("default"))) void cvReleaseGraphScanner(CvGraphScanner ** scanner); 
# 1882
__attribute((visibility("default"))) int cvNextGraphItem(CvGraphScanner * scanner); 
# 1885
__attribute((visibility("default"))) CvGraph *cvCloneGraph(const CvGraph * graph, CvMemStorage * storage); 
# 1890
__attribute((visibility("default"))) void cvLUT(const CvArr * src, CvArr * dst, const CvArr * lut); 
# 1900
typedef 
# 1894
struct CvTreeNodeIterator { 
# 1896
const void *node; 
# 1897
int level; 
# 1898
int max_level; 
# 1900
} CvTreeNodeIterator; 
# 1902
__attribute((visibility("default"))) void cvInitTreeNodeIterator(CvTreeNodeIterator * tree_iterator, const void * first, int max_level); 
# 1904
__attribute((visibility("default"))) void *cvNextTreeNode(CvTreeNodeIterator * tree_iterator); 
# 1905
__attribute((visibility("default"))) void *cvPrevTreeNode(CvTreeNodeIterator * tree_iterator); 
# 1910
__attribute((visibility("default"))) void cvInsertNodeIntoTree(void * node, void * parent, void * frame); 
# 1913
__attribute((visibility("default"))) void cvRemoveNodeFromTree(void * node, void * frame); 
# 1917
__attribute((visibility("default"))) CvSeq *cvTreeToNodeSeq(const void * first, int header_size, CvMemStorage * storage); 
# 1923
__attribute((visibility("default"))) int cvKMeans2(const CvArr * samples, int cluster_count, CvArr * labels, CvTermCriteria termcrit, int attempts = 1, CvRNG * rng = 0, int flags = 0, CvArr * _centers = 0, double * compactness = 0); 
# 1933
__attribute((visibility("default"))) int cvUseOptimized(int on_off); 
# 1935
typedef IplImage *(*Cv_iplCreateImageHeader)(int, int, int, char *, char *, int, int, int, int, int, IplROI *, IplImage *, void *, IplTileInfo *); 
# 1938
typedef void (*Cv_iplAllocateImageData)(IplImage *, int, int); 
# 1939
typedef void (*Cv_iplDeallocate)(IplImage *, int); 
# 1940
typedef IplROI *(*Cv_iplCreateROI)(int, int, int, int, int); 
# 1941
typedef IplImage *(*Cv_iplCloneImage)(const IplImage *); 
# 1959 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvSetIPLAllocators(Cv_iplCreateImageHeader create_header, Cv_iplAllocateImageData allocate_data, Cv_iplDeallocate deallocate, Cv_iplCreateROI create_roi, Cv_iplCloneImage clone_image); 
# 1999 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvFileStorage *cvOpenFileStorage(const char * filename, CvMemStorage * memstorage, int flags, const char * encoding = 0); 
# 2008
__attribute((visibility("default"))) void cvReleaseFileStorage(CvFileStorage ** fs); 
# 2011
__attribute((visibility("default"))) const char *cvAttrValue(const CvAttrList * attr, const char * attr_name); 
# 2039 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvStartWriteStruct(CvFileStorage * fs, const char * name, int struct_flags, const char * type_name = 0, CvAttrList attributes = cvAttrList()); 
# 2047
__attribute((visibility("default"))) void cvEndWriteStruct(CvFileStorage * fs); 
# 2057 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvWriteInt(CvFileStorage * fs, const char * name, int value); 
# 2084 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvWriteReal(CvFileStorage * fs, const char * name, double value); 
# 2097 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvWriteString(CvFileStorage * fs, const char * name, const char * str, int quote = 0); 
# 2109 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvWriteComment(CvFileStorage * fs, const char * comment, int eol_comment); 
# 2157 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvWrite(CvFileStorage * fs, const char * name, const void * ptr, CvAttrList attributes = cvAttrList()); 
# 2184 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvStartNextStream(CvFileStorage * fs); 
# 2197 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvWriteRawData(CvFileStorage * fs, const void * src, int len, const char * dt); 
# 2219 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvWriteRawDataBase64(CvFileStorage * fs, const void * src, int len, const char * dt); 
# 2290 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvStringHashNode *cvGetHashedKey(CvFileStorage * fs, const char * name, int len = -1, int create_missing = 0); 
# 2305 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvFileNode *cvGetRootFileNode(const CvFileStorage * fs, int stream_index = 0); 
# 2318 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvFileNode *cvGetFileNode(CvFileStorage * fs, CvFileNode * map, const CvStringHashNode * key, int create_missing = 0); 
# 2334 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvFileNode *cvGetFileNodeByName(const CvFileStorage * fs, const CvFileNode * map, const char * name); 
# 2348 "/usr/include/opencv2/core/core_c.h" 3
static inline int cvReadInt(const CvFileNode *node, int default_value = 0) 
# 2349
{ 
# 2350
return (!node) ? default_value : ((((node->tag) & 7) == 1) ? (node->data).i : ((((node->tag) & 7) == 2) ? cvRound((node->data).f) : 2147483647)); 
# 2353
} 
# 2363 "/usr/include/opencv2/core/core_c.h" 3
static inline int cvReadIntByName(const CvFileStorage *fs, const CvFileNode *map, const char *
# 2364
name, int default_value = 0) 
# 2365
{ 
# 2366
return cvReadInt(cvGetFileNodeByName(fs, map, name), default_value); 
# 2367
} 
# 2379 "/usr/include/opencv2/core/core_c.h" 3
static inline double cvReadReal(const CvFileNode *node, double default_value = (0.0)) 
# 2380
{ 
# 2381
return (!node) ? default_value : ((((node->tag) & 7) == 1) ? (double)((node->data).i) : ((((node->tag) & 7) == 2) ? (node->data).f : (1.000000000000000053e+300))); 
# 2384
} 
# 2394 "/usr/include/opencv2/core/core_c.h" 3
static inline double cvReadRealByName(const CvFileStorage *fs, const CvFileNode *map, const char *
# 2395
name, double default_value = (0.0)) 
# 2396
{ 
# 2397
return cvReadReal(cvGetFileNodeByName(fs, map, name), default_value); 
# 2398
} 
# 2409 "/usr/include/opencv2/core/core_c.h" 3
static inline const char *cvReadString(const CvFileNode *node, const char *
# 2410
default_value = 0) 
# 2411
{ 
# 2412
return (!node) ? default_value : ((((node->tag) & 7) == 3) ? ((node->data).str).ptr : (0)); 
# 2413
} 
# 2423 "/usr/include/opencv2/core/core_c.h" 3
static inline const char *cvReadStringByName(const CvFileStorage *fs, const CvFileNode *map, const char *
# 2424
name, const char *default_value = 0) 
# 2425
{ 
# 2426
return cvReadString(cvGetFileNodeByName(fs, map, name), default_value); 
# 2427
} 
# 2444 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void *cvRead(CvFileStorage * fs, CvFileNode * node, CvAttrList * attributes = 0); 
# 2455 "/usr/include/opencv2/core/core_c.h" 3
static inline void *cvReadByName(CvFileStorage *fs, const CvFileNode *map, const char *
# 2456
name, CvAttrList *attributes = 0) 
# 2457
{ 
# 2458
return cvRead(fs, cvGetFileNodeByName(fs, map, name), attributes); 
# 2459
} 
# 2470 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvStartReadRawData(const CvFileStorage * fs, const CvFileNode * src, CvSeqReader * reader); 
# 2486 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvReadRawDataSlice(const CvFileStorage * fs, CvSeqReader * reader, int count, void * dst, const char * dt); 
# 2497 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvReadRawData(const CvFileStorage * fs, const CvFileNode * src, void * dst, const char * dt); 
# 2513 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvWriteFileNode(CvFileStorage * fs, const char * new_node_name, const CvFileNode * node, int embed); 
# 2522
__attribute((visibility("default"))) const char *cvGetFileNodeName(const CvFileNode * node); 
# 2532 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvRegisterType(const CvTypeInfo * info); 
# 2541 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvUnregisterType(const char * type_name); 
# 2548
__attribute((visibility("default"))) CvTypeInfo *cvFirstType(); 
# 2556
__attribute((visibility("default"))) CvTypeInfo *cvFindType(const char * type_name); 
# 2566 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) CvTypeInfo *cvTypeOf(const void * struct_ptr); 
# 2573
__attribute((visibility("default"))) void cvRelease(void ** struct_ptr); 
# 2582 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void *cvClone(const void * struct_ptr); 
# 2593 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void cvSave(const char * filename, const void * struct_ptr, const char * name = 0, const char * comment = 0, CvAttrList attributes = cvAttrList()); 
# 2614 "/usr/include/opencv2/core/core_c.h" 3
__attribute((visibility("default"))) void *cvLoad(const char * filename, CvMemStorage * memstorage = 0, const char * name = 0, const char ** real_name = 0); 
# 2623
__attribute((visibility("default"))) int64 cvGetTickCount(); 
# 2624
__attribute((visibility("default"))) double cvGetTickFrequency(); 
# 2628
__attribute((visibility("default"))) int cvCheckHardwareSupport(int feature); 
# 2633
__attribute((visibility("default"))) int cvGetNumThreads(); 
# 2634
__attribute((visibility("default"))) void cvSetNumThreads(int threads = 0); 
# 2636
__attribute((visibility("default"))) int cvGetThreadNum(); 
# 2642
__attribute((visibility("default"))) int cvGetErrStatus(); 
# 2645
__attribute((visibility("default"))) void cvSetErrStatus(int status); 
# 2652
__attribute((visibility("default"))) int cvGetErrMode(); 
# 2655
__attribute((visibility("default"))) int cvSetErrMode(int mode); 
# 2660
__attribute((visibility("default"))) void cvError(int status, const char * func_name, const char * err_msg, const char * file_name, int line); 
# 2664
__attribute((visibility("default"))) const char *cvErrorStr(int status); 
# 2667
__attribute((visibility("default"))) int cvGetErrInfo(const char ** errcode_desc, const char ** description, const char ** filename, int * line); 
# 2671
__attribute((visibility("default"))) int cvErrorFromIppStatus(int ipp_status); 
# 2673
typedef int (*CvErrorCallback)(int status, const char * func_name, const char * err_msg, const char * file_name, int line, void * userdata); 
# 2677
__attribute((visibility("default"))) CvErrorCallback cvRedirectError(CvErrorCallback error_handler, void * userdata = 0, void ** prev_userdata = 0); 
# 2682
__attribute((visibility("default"))) int cvNulDevReport(int status, const char * func_name, const char * err_msg, const char * file_name, int line, void * userdata); 
# 2686
__attribute((visibility("default"))) int cvStdErrReport(int status, const char * func_name, const char * err_msg, const char * file_name, int line, void * userdata); 
# 2690
__attribute((visibility("default"))) int cvGuiBoxReport(int status, const char * func_name, const char * err_msg, const char * file_name, int line, void * userdata); 
# 2764 "/usr/include/opencv2/core/core_c.h" 3
}
# 2773 "/usr/include/opencv2/core/core_c.h" 3
struct __attribute((visibility("default"))) CvType { 
# 2775
CvType(const char * type_name, CvIsInstanceFunc is_instance, CvReleaseFunc release = 0, CvReadFunc read = 0, CvWriteFunc write = 0, CvCloneFunc clone = 0); 
# 2778
~CvType(); 
# 2779
CvTypeInfo *info; 
# 2781
static CvTypeInfo *first; 
# 2782
static CvTypeInfo *last; 
# 2783
}; 
# 2789 "/usr/include/opencv2/core/core_c.h" 3
namespace cv { 
# 2798
__attribute((visibility("default"))) Mat cvarrToMat(const CvArr * arr, bool copyData = false, bool allowND = true, int coiMode = 0, AutoBuffer< double>  * buf = 0); 
# 2802
static inline Mat cvarrToMatND(const CvArr *arr, bool copyData = false, int coiMode = 0) 
# 2803
{ 
# 2804
return cvarrToMat(arr, copyData, true, coiMode); 
# 2805
} 
# 2809
__attribute((visibility("default"))) void extractImageCOI(const CvArr * arr, OutputArray coiimg, int coi = -1); 
# 2811
__attribute((visibility("default"))) void insertImageCOI(InputArray coiimg, CvArr * arr, int coi = -1); 
# 2817
template<> __attribute((visibility("default"))) void DefaultDeleter< CvMat> ::operator()(CvMat * obj) const; 
# 2818
template<> __attribute((visibility("default"))) void DefaultDeleter< _IplImage> ::operator()(IplImage * obj) const; 
# 2819
template<> __attribute((visibility("default"))) void DefaultDeleter< CvMatND> ::operator()(CvMatND * obj) const; 
# 2820
template<> __attribute((visibility("default"))) void DefaultDeleter< CvSparseMat> ::operator()(CvSparseMat * obj) const; 
# 2821
template<> __attribute((visibility("default"))) void DefaultDeleter< CvMemStorage> ::operator()(CvMemStorage * obj) const; 
# 2825
template< class _Tp> class SeqIterator; 
# 2827
typedef Ptr< CvMemStorage>  MemStorage; 
# 2839 "/usr/include/opencv2/core/core_c.h" 3
template< class _Tp> class Seq { 
# 2842
public: typedef SeqIterator< _Tp>  iterator; 
# 2843
typedef SeqIterator< _Tp>  const_iterator; 
# 2846
inline Seq(); 
# 2848
inline Seq(const CvSeq * seq); 
# 2850
inline Seq(MemStorage & storage, int headerSize = sizeof(CvSeq)); 
# 2852
inline _Tp &operator[](int idx); 
# 2854
inline const _Tp &operator[](int idx) const; 
# 2856
inline SeqIterator< _Tp>  begin() const; 
# 2858
inline SeqIterator< _Tp>  end() const; 
# 2860
inline size_t size() const; 
# 2862
inline int type() const; 
# 2864
inline int depth() const; 
# 2866
inline int channels() const; 
# 2868
inline size_t elemSize() const; 
# 2870
inline size_t index(const _Tp & elem) const; 
# 2872
inline void push_back(const _Tp & elem); 
# 2874
inline void push_front(const _Tp & elem); 
# 2876
inline void push_back(const _Tp * elems, size_t count); 
# 2878
inline void push_front(const _Tp * elems, size_t count); 
# 2880
inline void insert(int idx, const _Tp & elem); 
# 2882
inline void insert(int idx, const _Tp * elems, size_t count); 
# 2884
inline void remove(int idx); 
# 2886
inline void remove(const Range & r); 
# 2889
inline _Tp &front(); 
# 2891
inline const _Tp &front() const; 
# 2893
inline _Tp &back(); 
# 2895
inline const _Tp &back() const; 
# 2897
inline bool empty() const; 
# 2900
inline void clear(); 
# 2902
inline void pop_front(); 
# 2904
inline void pop_back(); 
# 2906
inline void pop_front(_Tp * elems, size_t count); 
# 2908
inline void pop_back(_Tp * elems, size_t count); 
# 2911
inline void copyTo(std::vector< _Tp>  & vec, const Range & range = Range::all()) const; 
# 2913
inline operator std::vector< _Tp> () const; 
# 2915
CvSeq *seq; 
# 2916
}; 
# 2922
template< class _Tp> class SeqIterator : public CvSeqReader { 
# 2926
public: inline SeqIterator(); 
# 2928
inline SeqIterator(const Seq< _Tp>  & seq, bool seekEnd = false); 
# 2930
inline void seek(size_t pos); 
# 2932
inline size_t tell() const; 
# 2934
inline _Tp &operator*(); 
# 2936
inline const _Tp &operator*() const; 
# 2938
inline SeqIterator &operator++(); 
# 2940
inline SeqIterator operator++(int) const; 
# 2942
inline SeqIterator &operator--(); 
# 2944
inline SeqIterator operator--(int) const; 
# 2947
inline SeqIterator &operator+=(int); 
# 2949
inline SeqIterator &operator-=(int); 
# 2953
int index; 
# 2954
}; 
# 2959
__attribute((visibility("default"))) schar *seqPush(CvSeq * seq, const void * element = 0); 
# 2960
__attribute((visibility("default"))) schar *seqPushFront(CvSeq * seq, const void * element = 0); 
# 2961
__attribute((visibility("default"))) void seqPop(CvSeq * seq, void * element = 0); 
# 2962
__attribute((visibility("default"))) void seqPopFront(CvSeq * seq, void * element = 0); 
# 2963
__attribute((visibility("default"))) void seqPopMulti(CvSeq * seq, void * elements, int count, int in_front = 0); 
# 2965
__attribute((visibility("default"))) void seqRemove(CvSeq * seq, int index); 
# 2966
__attribute((visibility("default"))) void clearSeq(CvSeq * seq); 
# 2967
__attribute((visibility("default"))) schar *getSeqElem(const CvSeq * seq, int index); 
# 2968
__attribute((visibility("default"))) void seqRemoveSlice(CvSeq * seq, CvSlice slice); 
# 2969
__attribute((visibility("default"))) void seqInsertSlice(CvSeq * seq, int before_index, const CvArr * from_arr); 
# 2971
template< class _Tp> inline Seq< _Tp> ::Seq() : seq((0)) { } 
# 2972
template< class _Tp> inline Seq< _Tp> ::Seq(const CvSeq *_seq) : seq((CvSeq *)_seq) 
# 2973
{ 
# 2974
if (!(!((!_seq) || ((_seq->elem_size) == sizeof(_Tp))))) { ; } else { cv::error(cv::Error::StsAssert, "!_seq || _seq->elem_size == sizeof(_Tp)", __func__, "/usr/include/opencv2/core/core_c.h", 2974); }  
# 2975
} 
# 2977
template< class _Tp> inline Seq< _Tp> ::Seq(MemStorage &storage, int 
# 2978
headerSize) 
# 2979
{ 
# 2980
if (!(!(headerSize >= ((int)sizeof(CvSeq))))) { ; } else { cv::error(cv::Error::StsAssert, "headerSize >= (int)sizeof(CvSeq)", __func__, "/usr/include/opencv2/core/core_c.h", 2980); }  
# 2981
(seq) = cvCreateSeq(DataType< _Tp> ::type, headerSize, sizeof(_Tp), storage); 
# 2982
} 
# 2984
template< class _Tp> inline _Tp &Seq< _Tp> ::operator[](int idx) 
# 2985
{ return *((_Tp *)getSeqElem(seq, idx)); } 
# 2987
template< class _Tp> inline const _Tp &Seq< _Tp> ::operator[](int idx) const 
# 2988
{ return *((_Tp *)getSeqElem(seq, idx)); } 
# 2990
template< class _Tp> inline SeqIterator< _Tp>  Seq< _Tp> ::begin() const 
# 2991
{ return ((SeqIterator< _Tp> )(*this)); } 
# 2993
template< class _Tp> inline SeqIterator< _Tp>  Seq< _Tp> ::end() const 
# 2994
{ return SeqIterator< _Tp> (*this, true); } 
# 2996
template< class _Tp> inline size_t Seq< _Tp> ::size() const 
# 2997
{ return (seq) ? (seq)->total : 0; } 
# 2999
template< class _Tp> inline int Seq< _Tp> ::type() const 
# 3000
{ return (seq) ? ((seq)->flags) & (((1 << 3) * 512) - 1) : 0; } 
# 3002
template< class _Tp> inline int Seq< _Tp> ::depth() const 
# 3003
{ return (seq) ? ((seq)->flags) & ((1 << 3) - 1) : 0; } 
# 3005
template< class _Tp> inline int Seq< _Tp> ::channels() const 
# 3006
{ return (seq) ? ((((seq)->flags) & ((512 - 1) << 3)) >> 3) + 1 : 0; } 
# 3008
template< class _Tp> inline size_t Seq< _Tp> ::elemSize() const 
# 3009
{ return (seq) ? (seq)->elem_size : 0; } 
# 3011
template< class _Tp> inline size_t Seq< _Tp> ::index(const _Tp &elem) const 
# 3012
{ return cvSeqElemIdx(seq, &elem); } 
# 3014
template< class _Tp> inline void Seq< _Tp> ::push_back(const _Tp &elem) 
# 3015
{ cvSeqPush(seq, &elem); } 
# 3017
template< class _Tp> inline void Seq< _Tp> ::push_front(const _Tp &elem) 
# 3018
{ cvSeqPushFront(seq, &elem); } 
# 3020
template< class _Tp> inline void Seq< _Tp> ::push_back(const _Tp *elem, size_t count) 
# 3021
{ cvSeqPushMulti(seq, elem, (int)count, 0); } 
# 3023
template< class _Tp> inline void Seq< _Tp> ::push_front(const _Tp *elem, size_t count) 
# 3024
{ cvSeqPushMulti(seq, elem, (int)count, 1); } 
# 3026
template< class _Tp> inline _Tp &Seq< _Tp> ::back() 
# 3027
{ return *((_Tp *)getSeqElem(seq, -1)); } 
# 3029
template< class _Tp> inline const _Tp &Seq< _Tp> ::back() const 
# 3030
{ return *((const _Tp *)getSeqElem(seq, -1)); } 
# 3032
template< class _Tp> inline _Tp &Seq< _Tp> ::front() 
# 3033
{ return *((_Tp *)getSeqElem(seq, 0)); } 
# 3035
template< class _Tp> inline const _Tp &Seq< _Tp> ::front() const 
# 3036
{ return *((const _Tp *)getSeqElem(seq, 0)); } 
# 3038
template< class _Tp> inline bool Seq< _Tp> ::empty() const 
# 3039
{ return (!(seq)) || (((seq)->total) == 0); } 
# 3041
template< class _Tp> inline void Seq< _Tp> ::clear() 
# 3042
{ if (seq) { clearSeq(seq); }  } 
# 3044
template< class _Tp> inline void Seq< _Tp> ::pop_back() 
# 3045
{ seqPop(seq); } 
# 3047
template< class _Tp> inline void Seq< _Tp> ::pop_front() 
# 3048
{ seqPopFront(seq); } 
# 3050
template< class _Tp> inline void Seq< _Tp> ::pop_back(_Tp *elem, size_t count) 
# 3051
{ seqPopMulti(seq, elem, (int)count, 0); } 
# 3053
template< class _Tp> inline void Seq< _Tp> ::pop_front(_Tp *elem, size_t count) 
# 3054
{ seqPopMulti(seq, elem, (int)count, 1); } 
# 3056
template< class _Tp> inline void Seq< _Tp> ::insert(int idx, const _Tp &elem) 
# 3057
{ seqInsert(seq, idx, &elem); } 
# 3059
template< class _Tp> inline void Seq< _Tp> ::insert(int idx, const _Tp *elems, size_t count) 
# 3060
{ 
# 3061
CvMat m = cvMat(1, count, DataType< _Tp> ::type, elems); 
# 3062
seqInsertSlice(seq, idx, &m); 
# 3063
} 
# 3065
template< class _Tp> inline void Seq< _Tp> ::remove(int idx) 
# 3066
{ seqRemove(seq, idx); } 
# 3068
template< class _Tp> inline void Seq< _Tp> ::remove(const Range &r) 
# 3069
{ seqRemoveSlice(seq, cvSlice(r.start, r.end)); } 
# 3071
template< class _Tp> inline void Seq< _Tp> ::copyTo(std::vector< _Tp>  &vec, const Range &range) const 
# 3072
{ 
# 3073
size_t len = (!(seq)) ? 0 : (((range == (Range::all()))) ? (seq)->total : ((range.end) - (range.start))); 
# 3074
(vec.resize(len)); 
# 3075
if ((seq) && len) { 
# 3076
cvCvtSeqToArray(seq, &(vec[0]), range); }  
# 3077
} 
# 3079
template< class _Tp> inline Seq< _Tp> ::operator std::vector< _Tp> () const 
# 3080
{ 
# 3081
std::vector< _Tp>  vec; 
# 3082
copyTo(vec); 
# 3083
return vec; 
# 3084
} 
# 3086
template< class _Tp> inline SeqIterator< _Tp> ::SeqIterator() 
# 3087
{ memset(this, 0, sizeof((*this))); } 
# 3089
template< class _Tp> inline SeqIterator< _Tp> ::SeqIterator(const Seq< _Tp>  &_seq, bool seekEnd) 
# 3090
{ 
# 3091
cvStartReadSeq((_seq.seq), this); 
# 3092
(index) = (seekEnd ? (_seq.seq)->total : 0); 
# 3093
} 
# 3095
template< class _Tp> inline void SeqIterator< _Tp> ::seek(size_t pos) 
# 3096
{ 
# 3097
cvSetSeqReaderPos(this, (int)pos, false); 
# 3098
(index) = pos; 
# 3099
} 
# 3101
template< class _Tp> inline size_t SeqIterator< _Tp> ::tell() const 
# 3102
{ return index; } 
# 3104
template< class _Tp> inline _Tp &SeqIterator< _Tp> ::operator*() 
# 3105
{ return *((_Tp *)(ptr)); } 
# 3107
template< class _Tp> inline const _Tp &SeqIterator< _Tp> ::operator*() const 
# 3108
{ return *((const _Tp *)(ptr)); } 
# 3110
template< class _Tp> inline SeqIterator< _Tp>  &SeqIterator< _Tp> ::operator++() 
# 3111
{ 
# 3112
{ if ((((*this).ptr) += sizeof(_Tp)) >= ((*this).block_max)) { cvChangeSeqBlock(&(*this), 1); }  } ; 
# 3113
if ((++(index)) >= (((seq)->total) * 2)) { 
# 3114
(index) = 0; }  
# 3115
return *this; 
# 3116
} 
# 3118
template< class _Tp> inline SeqIterator< _Tp>  SeqIterator< _Tp> ::operator++(int) const 
# 3119
{ 
# 3120
SeqIterator it = *this; 
# 3121
++(*this); 
# 3122
return it; 
# 3123
} 
# 3125
template< class _Tp> inline SeqIterator< _Tp>  &SeqIterator< _Tp> ::operator--() 
# 3126
{ 
# 3127
{ if ((((*this).ptr) -= sizeof(_Tp)) < ((*this).block_min)) { cvChangeSeqBlock(&(*this), -1); }  } ; 
# 3128
if ((--(index)) < 0) { 
# 3129
(index) = ((((seq)->total) * 2) - 1); }  
# 3130
return *this; 
# 3131
} 
# 3133
template< class _Tp> inline SeqIterator< _Tp>  SeqIterator< _Tp> ::operator--(int) const 
# 3134
{ 
# 3135
SeqIterator it = *this; 
# 3136
--(*this); 
# 3137
return it; 
# 3138
} 
# 3140
template< class _Tp> inline SeqIterator< _Tp>  &SeqIterator< _Tp> ::operator+=(int delta) 
# 3141
{ 
# 3142
cvSetSeqReaderPos(this, delta, 1); 
# 3143
(index) += delta; 
# 3144
int n = ((seq)->total) * 2; 
# 3145
if ((index) < 0) { 
# 3146
(index) += n; }  
# 3147
if ((index) >= n) { 
# 3148
(index) -= n; }  
# 3149
return *this; 
# 3150
} 
# 3152
template< class _Tp> inline SeqIterator< _Tp>  &SeqIterator< _Tp> ::operator-=(int delta) 
# 3153
{ 
# 3154
return (*this) += (-delta); 
# 3155
} 
# 3157
template< class _Tp> inline ptrdiff_t operator-(const SeqIterator< _Tp>  &a, const SeqIterator< _Tp>  &
# 3158
b) 
# 3159
{ 
# 3160
ptrdiff_t delta = (a.index) - (b.index), n = (((a.seq)->total)); 
# 3161
if ((delta > n) || (delta < (-n))) { 
# 3162
delta += ((delta < (0)) ? n : (-n)); }  
# 3163
return delta; 
# 3164
} 
# 3166
template< class _Tp> inline bool operator==(const SeqIterator< _Tp>  &a, const SeqIterator< _Tp>  &
# 3167
b) 
# 3168
{ 
# 3169
return ((a.seq) == (b.seq)) && ((a.index) == (b.index)); 
# 3170
} 
# 3172
template< class _Tp> inline bool operator!=(const SeqIterator< _Tp>  &a, const SeqIterator< _Tp>  &
# 3173
b) 
# 3174
{ 
# 3175
return !(a == b); 
# 3176
} 
# 3180
}
# 47 "/usr/include/opencv2/core/optim.hpp" 3
namespace cv { 
# 58 "/usr/include/opencv2/core/optim.hpp" 3
class __attribute((visibility("default"))) MinProblemSolver : public Algorithm { 
# 63
public: class __attribute((visibility("default"))) Function { 
# 66
public: virtual ~Function() { } 
# 67
virtual int getDims() const = 0; 
# 68
virtual double getGradientEps() const; 
# 69
virtual double calc(const double * x) const = 0; 
# 70
virtual void getGradient(const double * x, double * grad); 
# 71
}; 
# 81 "/usr/include/opencv2/core/optim.hpp" 3
virtual Ptr< Function>  getFunction() const = 0; 
# 89
virtual void setFunction(const Ptr< Function>  & f) = 0; 
# 95
virtual TermCriteria getTermCriteria() const = 0; 
# 108 "/usr/include/opencv2/core/optim.hpp" 3
virtual void setTermCriteria(const TermCriteria & termcrit) = 0; 
# 122 "/usr/include/opencv2/core/optim.hpp" 3
virtual double minimize(InputOutputArray x) = 0; 
# 123
}; 
# 155 "/usr/include/opencv2/core/optim.hpp" 3
class __attribute((visibility("default"))) DownhillSolver : public MinProblemSolver { 
# 164
public: virtual void getInitStep(OutputArray step) const = 0; 
# 180 "/usr/include/opencv2/core/optim.hpp" 3
virtual void setInitStep(InputArray step) = 0; 
# 198 "/usr/include/opencv2/core/optim.hpp" 3
static Ptr< DownhillSolver>  create(const Ptr< Function>  & f = Ptr< Function> (), InputArray initStep = Mat_< double> (1, 1, (0.0)), TermCriteria termcrit = TermCriteria((TermCriteria::MAX_ITER) + (TermCriteria::EPS), 5000, (9.999999999999999547e-07))); 
# 201
}; 
# 236 "/usr/include/opencv2/core/optim.hpp" 3
class __attribute((visibility("default"))) ConjGradSolver : public MinProblemSolver { 
# 252 "/usr/include/opencv2/core/optim.hpp" 3
public: static Ptr< ConjGradSolver>  create(const Ptr< Function>  & f = Ptr< Function> (), TermCriteria termcrit = TermCriteria((TermCriteria::MAX_ITER) + (TermCriteria::EPS), 5000, (9.999999999999999547e-07))); 
# 254
}; 
# 257
enum SolveLPResult { 
# 259
SOLVELP_UNBOUNDED = (-2), 
# 260
SOLVELP_UNFEASIBLE, 
# 261
SOLVELP_SINGLE = 0, 
# 262
SOLVELP_MULTI
# 263
}; 
# 296 "/usr/include/opencv2/core/optim.hpp" 3
__attribute((visibility("default"))) int solveLP(const Mat & Func, const Mat & Constr, Mat & z); 
# 300
}
# 16 "/usr/include/opencv2/core/ovx.hpp" 3
namespace cv { 
# 19
__attribute((visibility("default"))) bool haveOpenVX(); 
# 22
__attribute((visibility("default"))) bool useOpenVX(); 
# 25
__attribute((visibility("default"))) void setUseOpenVX(bool flag); 
# 26
}
# 65 "/usr/include/opencv2/flann/defines.h" 3
namespace cvflann { 
# 68
enum flann_algorithm_t { 
# 70
FLANN_INDEX_LINEAR, 
# 71
FLANN_INDEX_KDTREE, 
# 72
FLANN_INDEX_KMEANS, 
# 73
FLANN_INDEX_COMPOSITE, 
# 74
FLANN_INDEX_KDTREE_SINGLE, 
# 75
FLANN_INDEX_HIERARCHICAL, 
# 76
FLANN_INDEX_LSH, 
# 77
FLANN_INDEX_SAVED = 254, 
# 78
FLANN_INDEX_AUTOTUNED, 
# 81
LINEAR = 0, 
# 82
KDTREE, 
# 83
KMEANS, 
# 84
COMPOSITE, 
# 85
KDTREE_SINGLE, 
# 86
SAVED = 254, 
# 87
AUTOTUNED
# 88
}; 
# 92
enum flann_centers_init_t { 
# 94
FLANN_CENTERS_RANDOM, 
# 95
FLANN_CENTERS_GONZALES, 
# 96
FLANN_CENTERS_KMEANSPP, 
# 97
FLANN_CENTERS_GROUPWISE, 
# 100
CENTERS_RANDOM = 0, 
# 101
CENTERS_GONZALES, 
# 102
CENTERS_KMEANSPP
# 103
}; 
# 105
enum flann_log_level_t { 
# 107
FLANN_LOG_NONE, 
# 108
FLANN_LOG_FATAL, 
# 109
FLANN_LOG_ERROR, 
# 110
FLANN_LOG_WARN, 
# 111
FLANN_LOG_INFO
# 112
}; 
# 114
enum flann_distance_t { 
# 116
FLANN_DIST_EUCLIDEAN = 1, 
# 117
FLANN_DIST_L2 = 1, 
# 118
FLANN_DIST_MANHATTAN, 
# 119
FLANN_DIST_L1 = 2, 
# 120
FLANN_DIST_MINKOWSKI, 
# 121
FLANN_DIST_MAX, 
# 122
FLANN_DIST_HIST_INTERSECT, 
# 123
FLANN_DIST_HELLINGER, 
# 124
FLANN_DIST_CHI_SQUARE, 
# 125
FLANN_DIST_CS = 7, 
# 126
FLANN_DIST_KULLBACK_LEIBLER, 
# 127
FLANN_DIST_KL = 8, 
# 128
FLANN_DIST_HAMMING, 
# 131
EUCLIDEAN = 1, 
# 132
MANHATTAN, 
# 133
MINKOWSKI, 
# 134
MAX_DIST, 
# 135
HIST_INTERSECT, 
# 136
HELLINGER, 
# 137
CS, 
# 138
KL, 
# 139
KULLBACK_LEIBLER = 8
# 140
}; 
# 142
enum flann_datatype_t { 
# 144
FLANN_INT8, 
# 145
FLANN_INT16, 
# 146
FLANN_INT32, 
# 147
FLANN_INT64, 
# 148
FLANN_UINT8, 
# 149
FLANN_UINT16, 
# 150
FLANN_UINT32, 
# 151
FLANN_UINT64, 
# 152
FLANN_FLOAT32, 
# 153
FLANN_FLOAT64
# 154
}; 
# 157
enum { 
# 158
FLANN_CHECKS_UNLIMITED = (-1), 
# 159
FLANN_CHECKS_AUTOTUNED = (-2)
# 160
}; 
# 162
}
# 49 "/usr/include/opencv2/flann/miniflann.hpp" 3
namespace cv { 
# 52
namespace flann { 
# 55
struct __attribute((visibility("default"))) IndexParams { 
# 57
IndexParams(); 
# 58
~IndexParams(); 
# 60
String getString(const String & key, const String & defaultVal = String()) const; 
# 61
int getInt(const String & key, int defaultVal = -1) const; 
# 62
double getDouble(const String & key, double defaultVal = -1) const; 
# 64
void setString(const String & key, const String & value); 
# 65
void setInt(const String & key, int value); 
# 66
void setDouble(const String & key, double value); 
# 67
void setFloat(const String & key, float value); 
# 68
void setBool(const String & key, bool value); 
# 69
void setAlgorithm(int value); 
# 71
void getAll(std::vector< String>  & names, std::vector< int>  & types, std::vector< String>  & strValues, std::vector< double>  & numValues) const; 
# 76
void *params; 
# 79
private: IndexParams(const IndexParams &); 
# 80
IndexParams &operator=(const IndexParams &); 
# 81
}; 
# 83
struct __attribute((visibility("default"))) KDTreeIndexParams : public IndexParams { 
# 85
KDTreeIndexParams(int trees = 4); 
# 86
}; 
# 88
struct __attribute((visibility("default"))) LinearIndexParams : public IndexParams { 
# 90
LinearIndexParams(); 
# 91
}; 
# 93
struct __attribute((visibility("default"))) CompositeIndexParams : public IndexParams { 
# 95
CompositeIndexParams(int trees = 4, int branching = 32, int iterations = 11, cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, float cb_index = (0.200000003F)); 
# 97
}; 
# 99
struct __attribute((visibility("default"))) AutotunedIndexParams : public IndexParams { 
# 101
AutotunedIndexParams(float target_precision = (0.8000000119F), float build_weight = (0.009999999776F), float memory_weight = 0, float sample_fraction = (0.1000000015F)); 
# 103
}; 
# 105
struct __attribute((visibility("default"))) HierarchicalClusteringIndexParams : public IndexParams { 
# 107
HierarchicalClusteringIndexParams(int branching = 32, cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, int trees = 4, int leaf_size = 100); 
# 109
}; 
# 111
struct __attribute((visibility("default"))) KMeansIndexParams : public IndexParams { 
# 113
KMeansIndexParams(int branching = 32, int iterations = 11, cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, float cb_index = (0.200000003F)); 
# 115
}; 
# 117
struct __attribute((visibility("default"))) LshIndexParams : public IndexParams { 
# 119
LshIndexParams(int table_number, int key_size, int multi_probe_level); 
# 120
}; 
# 122
struct __attribute((visibility("default"))) SavedIndexParams : public IndexParams { 
# 124
SavedIndexParams(const String & filename); 
# 125
}; 
# 127
struct __attribute((visibility("default"))) SearchParams : public IndexParams { 
# 129
SearchParams(int checks = 32, float eps = 0, bool sorted = true); 
# 130
}; 
# 132
class __attribute((visibility("default"))) Index { 
# 135
public: Index(); 
# 136
Index(InputArray features, const IndexParams & params, cvflann::flann_distance_t distType = cvflann::FLANN_DIST_L2); 
# 137
virtual ~Index(); 
# 139
virtual void build(InputArray features, const IndexParams & params, cvflann::flann_distance_t distType = cvflann::FLANN_DIST_L2); 
# 140
virtual void knnSearch(InputArray query, OutputArray indices, OutputArray dists, int knn, const SearchParams & params = SearchParams()); 
# 143
virtual int radiusSearch(InputArray query, OutputArray indices, OutputArray dists, double radius, int maxResults, const SearchParams & params = SearchParams()); 
# 147
virtual void save(const String & filename) const; 
# 148
virtual bool load(InputArray features, const String & filename); 
# 149
virtual void release(); 
# 150
cvflann::flann_distance_t getDistance() const; 
# 151
cvflann::flann_algorithm_t getAlgorithm() const; 
# 154
protected: cvflann::flann_distance_t distType; 
# 155
cvflann::flann_algorithm_t algo; 
# 156
int featureType; 
# 157
void *index; 
# 158
}; 
# 160
}}
# 86 "/usr/include/opencv2/features2d.hpp" 3
namespace cv { 
# 102 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) KeyPointsFilter { 
# 105
public: KeyPointsFilter() { } 
# 110
static void runByImageBorder(std::vector< KeyPoint>  & keypoints, Size imageSize, int borderSize); 
# 114
static void runByKeypointSize(std::vector< KeyPoint>  & keypoints, float minSize, float maxSize = (3.402823466e+38F)); 
# 119
static void runByPixelsMask(std::vector< KeyPoint>  & keypoints, const Mat & mask); 
# 123
static void removeDuplicated(std::vector< KeyPoint>  & keypoints); 
# 127
static void removeDuplicatedSorted(std::vector< KeyPoint>  & keypoints); 
# 132
static void retainBest(std::vector< KeyPoint>  & keypoints, int npoints); 
# 133
}; 
# 140
class __attribute((visibility("default"))) Feature2D : virtual public Algorithm { 
# 143
public: virtual ~Feature2D(); 
# 153 "/usr/include/opencv2/features2d.hpp" 3
virtual void detect(InputArray image, std::vector< KeyPoint>  & keypoints, InputArray mask = noArray()); 
# 164 "/usr/include/opencv2/features2d.hpp" 3
virtual void detect(InputArrayOfArrays images, std::vector< std::vector< KeyPoint> >  & keypoints, InputArrayOfArrays masks = noArray()); 
# 179 "/usr/include/opencv2/features2d.hpp" 3
virtual void compute(InputArray image, std::vector< KeyPoint>  & keypoints, OutputArray descriptors); 
# 193 "/usr/include/opencv2/features2d.hpp" 3
virtual void compute(InputArrayOfArrays images, std::vector< std::vector< KeyPoint> >  & keypoints, OutputArrayOfArrays descriptors); 
# 198
virtual void detectAndCompute(InputArray image, InputArray mask, std::vector< KeyPoint>  & keypoints, OutputArray descriptors, bool useProvidedKeypoints = false); 
# 203
virtual int descriptorSize() const; 
# 204
virtual int descriptorType() const; 
# 205
virtual int defaultNorm() const; 
# 207
void write(const String & fileName) const; 
# 209
void read(const String & fileName); 
# 211
virtual void write(FileStorage &) const; 
# 213
virtual void read(const FileNode &); 
# 216
virtual bool empty() const; 
# 217
virtual String getDefaultName() const; 
# 218
}; 
# 223
typedef Feature2D FeatureDetector; 
# 230
typedef Feature2D DescriptorExtractor; 
# 237
class __attribute((visibility("default"))) BRISK : public Feature2D { 
# 247
public: static Ptr< BRISK>  create(int thresh = 30, int octaves = 3, float patternScale = (1.0F)); 
# 260 "/usr/include/opencv2/features2d.hpp" 3
static Ptr< BRISK>  create(const std::vector< float>  & radiusList, const std::vector< int>  & numberList, float dMax = (5.849999905F), float dMin = (8.199999809F), const std::vector< int>  & indexChange = std::vector< int> ()); 
# 276 "/usr/include/opencv2/features2d.hpp" 3
static Ptr< BRISK>  create(int thresh, int octaves, const std::vector< float>  & radiusList, const std::vector< int>  & numberList, float dMax = (5.849999905F), float dMin = (8.199999809F), const std::vector< int>  & indexChange = std::vector< int> ()); 
# 279
virtual String getDefaultName() const; 
# 280
}; 
# 289 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) ORB : public Feature2D { 
# 292
public: enum { kBytes = 32, HARRIS_SCORE = 0, FAST_SCORE}; 
# 324 "/usr/include/opencv2/features2d.hpp" 3
static Ptr< ORB>  create(int nfeatures = 500, float scaleFactor = (1.200000048F), int nlevels = 8, int edgeThreshold = 31, int firstLevel = 0, int WTA_K = 2, int scoreType = ORB::HARRIS_SCORE, int patchSize = 31, int fastThreshold = 20); 
# 327
virtual void setMaxFeatures(int maxFeatures) = 0; 
# 328
virtual int getMaxFeatures() const = 0; 
# 330
virtual void setScaleFactor(double scaleFactor) = 0; 
# 331
virtual double getScaleFactor() const = 0; 
# 333
virtual void setNLevels(int nlevels) = 0; 
# 334
virtual int getNLevels() const = 0; 
# 336
virtual void setEdgeThreshold(int edgeThreshold) = 0; 
# 337
virtual int getEdgeThreshold() const = 0; 
# 339
virtual void setFirstLevel(int firstLevel) = 0; 
# 340
virtual int getFirstLevel() const = 0; 
# 342
virtual void setWTA_K(int wta_k) = 0; 
# 343
virtual int getWTA_K() const = 0; 
# 345
virtual void setScoreType(int scoreType) = 0; 
# 346
virtual int getScoreType() const = 0; 
# 348
virtual void setPatchSize(int patchSize) = 0; 
# 349
virtual int getPatchSize() const = 0; 
# 351
virtual void setFastThreshold(int fastThreshold) = 0; 
# 352
virtual int getFastThreshold() const = 0; 
# 353
virtual String getDefaultName() const; 
# 354
}; 
# 372 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) MSER : public Feature2D { 
# 387 "/usr/include/opencv2/features2d.hpp" 3
public: static Ptr< MSER>  create(int _delta = 5, int _min_area = 60, int _max_area = 14400, double _max_variation = (0.25), double _min_diversity = (0.2000000000000000111), int _max_evolution = 200, double _area_threshold = (1.010000000000000009), double _min_margin = (0.003000000000000000062), int _edge_blur_size = 5); 
# 398
virtual void detectRegions(InputArray image, std::vector< std::vector< Point_< int> > >  & msers, std::vector< Rect_< int> >  & bboxes) = 0; 
# 402
virtual void setDelta(int delta) = 0; 
# 403
virtual int getDelta() const = 0; 
# 405
virtual void setMinArea(int minArea) = 0; 
# 406
virtual int getMinArea() const = 0; 
# 408
virtual void setMaxArea(int maxArea) = 0; 
# 409
virtual int getMaxArea() const = 0; 
# 411
virtual void setPass2Only(bool f) = 0; 
# 412
virtual bool getPass2Only() const = 0; 
# 413
virtual String getDefaultName() const; 
# 414
}; 
# 417
__attribute((visibility("default"))) void FAST(InputArray image, std::vector< KeyPoint>  & keypoints, int threshold, bool nonmaxSuppression = true); 
# 438 "/usr/include/opencv2/features2d.hpp" 3
__attribute((visibility("default"))) void FAST(InputArray image, std::vector< KeyPoint>  & keypoints, int threshold, bool nonmaxSuppression, int type); 
# 448 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) FastFeatureDetector : public Feature2D { 
# 452
public: enum { 
# 453
TYPE_5_8, TYPE_7_12, TYPE_9_16, 
# 454
THRESHOLD = 10000, NONMAX_SUPPRESSION, FAST_N
# 455
}; 
# 457
static Ptr< FastFeatureDetector>  create(int threshold = 10, bool nonmaxSuppression = true, int type = FastFeatureDetector::TYPE_9_16); 
# 461
virtual void setThreshold(int threshold) = 0; 
# 462
virtual int getThreshold() const = 0; 
# 464
virtual void setNonmaxSuppression(bool f) = 0; 
# 465
virtual bool getNonmaxSuppression() const = 0; 
# 467
virtual void setType(int type) = 0; 
# 468
virtual int getType() const = 0; 
# 469
virtual String getDefaultName() const; 
# 470
}; 
# 473
__attribute((visibility("default"))) void AGAST(InputArray image, std::vector< KeyPoint>  & keypoints, int threshold, bool nonmaxSuppression = true); 
# 494 "/usr/include/opencv2/features2d.hpp" 3
__attribute((visibility("default"))) void AGAST(InputArray image, std::vector< KeyPoint>  & keypoints, int threshold, bool nonmaxSuppression, int type); 
# 503
class __attribute((visibility("default"))) AgastFeatureDetector : public Feature2D { 
# 507
public: enum { 
# 508
AGAST_5_8, AGAST_7_12d, AGAST_7_12s, OAST_9_16, 
# 509
THRESHOLD = 10000, NONMAX_SUPPRESSION
# 510
}; 
# 512
static Ptr< AgastFeatureDetector>  create(int threshold = 10, bool nonmaxSuppression = true, int type = AgastFeatureDetector::OAST_9_16); 
# 516
virtual void setThreshold(int threshold) = 0; 
# 517
virtual int getThreshold() const = 0; 
# 519
virtual void setNonmaxSuppression(bool f) = 0; 
# 520
virtual bool getNonmaxSuppression() const = 0; 
# 522
virtual void setType(int type) = 0; 
# 523
virtual int getType() const = 0; 
# 524
virtual String getDefaultName() const; 
# 525
}; 
# 529
class __attribute((visibility("default"))) GFTTDetector : public Feature2D { 
# 532
public: static Ptr< GFTTDetector>  create(int maxCorners = 1000, double qualityLevel = (0.01000000000000000021), double minDistance = 1, int blockSize = 3, bool useHarrisDetector = false, double k = (0.04000000000000000083)); 
# 534
static Ptr< GFTTDetector>  create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize, bool useHarrisDetector = false, double k = (0.04000000000000000083)); 
# 536
virtual void setMaxFeatures(int maxFeatures) = 0; 
# 537
virtual int getMaxFeatures() const = 0; 
# 539
virtual void setQualityLevel(double qlevel) = 0; 
# 540
virtual double getQualityLevel() const = 0; 
# 542
virtual void setMinDistance(double minDistance) = 0; 
# 543
virtual double getMinDistance() const = 0; 
# 545
virtual void setBlockSize(int blockSize) = 0; 
# 546
virtual int getBlockSize() const = 0; 
# 548
virtual void setHarrisDetector(bool val) = 0; 
# 549
virtual bool getHarrisDetector() const = 0; 
# 551
virtual void setK(double k) = 0; 
# 552
virtual double getK() const = 0; 
# 553
virtual String getDefaultName() const; 
# 554
}; 
# 587 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) SimpleBlobDetector : public Feature2D { 
# 590
public: struct __attribute((visibility("default"))) Params { 
# 592
Params(); 
# 593
float thresholdStep; 
# 594
float minThreshold; 
# 595
float maxThreshold; 
# 596
size_t minRepeatability; 
# 597
float minDistBetweenBlobs; 
# 599
bool filterByColor; 
# 600
uchar blobColor; 
# 602
bool filterByArea; 
# 603
float minArea, maxArea; 
# 605
bool filterByCircularity; 
# 606
float minCircularity, maxCircularity; 
# 608
bool filterByInertia; 
# 609
float minInertiaRatio, maxInertiaRatio; 
# 611
bool filterByConvexity; 
# 612
float minConvexity, maxConvexity; 
# 614
void read(const FileNode & fn); 
# 615
void write(FileStorage & fs) const; 
# 616
}; 
# 619
static Ptr< SimpleBlobDetector>  create(const Params & parameters = Params()); 
# 620
virtual String getDefaultName() const; 
# 621
}; 
# 634 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) KAZE : public Feature2D { 
# 638
public: enum { 
# 639
DIFF_PM_G1, 
# 640
DIFF_PM_G2, 
# 641
DIFF_WEICKERT, 
# 642
DIFF_CHARBONNIER
# 643
}; 
# 655 "/usr/include/opencv2/features2d.hpp" 3
static Ptr< KAZE>  create(bool extended = false, bool upright = false, float threshold = (0.001000000047F), int nOctaves = 4, int nOctaveLayers = 4, int diffusivity = KAZE::DIFF_PM_G2); 
# 660
virtual void setExtended(bool extended) = 0; 
# 661
virtual bool getExtended() const = 0; 
# 663
virtual void setUpright(bool upright) = 0; 
# 664
virtual bool getUpright() const = 0; 
# 666
virtual void setThreshold(double threshold) = 0; 
# 667
virtual double getThreshold() const = 0; 
# 669
virtual void setNOctaves(int octaves) = 0; 
# 670
virtual int getNOctaves() const = 0; 
# 672
virtual void setNOctaveLayers(int octaveLayers) = 0; 
# 673
virtual int getNOctaveLayers() const = 0; 
# 675
virtual void setDiffusivity(int diff) = 0; 
# 676
virtual int getDiffusivity() const = 0; 
# 677
virtual String getDefaultName() const; 
# 678
}; 
# 696 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) AKAZE : public Feature2D { 
# 701
public: enum { 
# 702
DESCRIPTOR_KAZE_UPRIGHT = 2, 
# 703
DESCRIPTOR_KAZE, 
# 704
DESCRIPTOR_MLDB_UPRIGHT, 
# 705
DESCRIPTOR_MLDB
# 706
}; 
# 720 "/usr/include/opencv2/features2d.hpp" 3
static Ptr< AKAZE>  create(int descriptor_type = AKAZE::DESCRIPTOR_MLDB, int descriptor_size = 0, int descriptor_channels = 3, float threshold = (0.001000000047F), int nOctaves = 4, int nOctaveLayers = 4, int diffusivity = KAZE::DIFF_PM_G2); 
# 725
virtual void setDescriptorType(int dtype) = 0; 
# 726
virtual int getDescriptorType() const = 0; 
# 728
virtual void setDescriptorSize(int dsize) = 0; 
# 729
virtual int getDescriptorSize() const = 0; 
# 731
virtual void setDescriptorChannels(int dch) = 0; 
# 732
virtual int getDescriptorChannels() const = 0; 
# 734
virtual void setThreshold(double threshold) = 0; 
# 735
virtual double getThreshold() const = 0; 
# 737
virtual void setNOctaves(int octaves) = 0; 
# 738
virtual int getNOctaves() const = 0; 
# 740
virtual void setNOctaveLayers(int octaveLayers) = 0; 
# 741
virtual int getNOctaveLayers() const = 0; 
# 743
virtual void setDiffusivity(int diff) = 0; 
# 744
virtual int getDiffusivity() const = 0; 
# 745
virtual String getDefaultName() const; 
# 746
}; 
# 754
template< class T> 
# 755
struct __attribute((visibility("default"))) Accumulator { 
# 757
typedef T Type; 
# 758
}; 
# 760
template<> struct Accumulator< unsigned char>  { typedef float Type; }; 
# 761
template<> struct Accumulator< unsigned short>  { typedef float Type; }; 
# 762
template<> struct Accumulator< char>  { typedef float Type; }; 
# 763
template<> struct Accumulator< short>  { typedef float Type; }; 
# 768
template< class T> 
# 769
struct __attribute((visibility("default"))) SL2 { 
# 771
enum { normType = NORM_L2SQR}; 
# 772
typedef T ValueType; 
# 773
typedef typename Accumulator< T> ::Type ResultType; 
# 775
ResultType operator()(const T *a, const T *b, int size) const 
# 776
{ 
# 777
return normL2Sqr< ValueType, ResultType> (a, b, size); 
# 778
} 
# 779
}; 
# 784
template< class T> 
# 785
struct __attribute((visibility("default"))) L2 { 
# 787
enum { normType = NORM_L2}; 
# 788
typedef T ValueType; 
# 789
typedef typename Accumulator< T> ::Type ResultType; 
# 791
ResultType operator()(const T *a, const T *b, int size) const 
# 792
{ 
# 793
return (ResultType)std::sqrt((double)normL2Sqr< ValueType, ResultType> (a, b, size)); 
# 794
} 
# 795
}; 
# 800
template< class T> 
# 801
struct __attribute((visibility("default"))) L1 { 
# 803
enum { normType = NORM_L1}; 
# 804
typedef T ValueType; 
# 805
typedef typename Accumulator< T> ::Type ResultType; 
# 807
ResultType operator()(const T *a, const T *b, int size) const 
# 808
{ 
# 809
return normL1< ValueType, ResultType> (a, b, size); 
# 810
} 
# 811
}; 
# 825 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) DescriptorMatcher : public Algorithm { 
# 829
public: enum { 
# 830
FLANNBASED = 1, 
# 831
BRUTEFORCE, 
# 832
BRUTEFORCE_L1, 
# 833
BRUTEFORCE_HAMMING, 
# 834
BRUTEFORCE_HAMMINGLUT, 
# 835
BRUTEFORCE_SL2
# 836
}; 
# 837
virtual ~DescriptorMatcher(); 
# 847 "/usr/include/opencv2/features2d.hpp" 3
virtual void add(InputArrayOfArrays descriptors); 
# 851
const std::vector< Mat>  &getTrainDescriptors() const; 
# 855
virtual void clear(); 
# 859
virtual bool empty() const; 
# 863
virtual bool isMaskSupported() const = 0; 
# 872 "/usr/include/opencv2/features2d.hpp" 3
virtual void train(); 
# 890 "/usr/include/opencv2/features2d.hpp" 3
void match(InputArray queryDescriptors, InputArray trainDescriptors, std::vector< DMatch>  & matches, InputArray mask = noArray()) const; 
# 911 "/usr/include/opencv2/features2d.hpp" 3
void knnMatch(InputArray queryDescriptors, InputArray trainDescriptors, std::vector< std::vector< DMatch> >  & matches, int k, InputArray mask = noArray(), bool compactResult = false) const; 
# 934 "/usr/include/opencv2/features2d.hpp" 3
void radiusMatch(InputArray queryDescriptors, InputArray trainDescriptors, std::vector< std::vector< DMatch> >  & matches, float maxDistance, InputArray mask = noArray(), bool compactResult = false) const; 
# 945 "/usr/include/opencv2/features2d.hpp" 3
void match(InputArray queryDescriptors, std::vector< DMatch>  & matches, InputArrayOfArrays masks = noArray()); 
# 958 "/usr/include/opencv2/features2d.hpp" 3
void knnMatch(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, int k, InputArrayOfArrays masks = noArray(), bool compactResult = false); 
# 972 "/usr/include/opencv2/features2d.hpp" 3
void radiusMatch(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, float maxDistance, InputArrayOfArrays masks = noArray(), bool compactResult = false); 
# 976
void write(const String &fileName) const 
# 977
{ 
# 978
FileStorage fs(fileName, FileStorage::WRITE); 
# 979
this->write(fs); 
# 980
} 
# 982
void read(const String &fileName) 
# 983
{ 
# 984
FileStorage fs(fileName, FileStorage::READ); 
# 985
this->read(fs.root()); 
# 986
} 
# 988
virtual void read(const FileNode &); 
# 990
virtual void write(FileStorage &) const; 
# 998
virtual Ptr< DescriptorMatcher>  clone(bool emptyTrainData = false) const = 0; 
# 1011 "/usr/include/opencv2/features2d.hpp" 3
static Ptr< DescriptorMatcher>  create(const String & descriptorMatcherType); 
# 1013
static Ptr< DescriptorMatcher>  create(int matcherType); 
# 1020
protected: class __attribute((visibility("default"))) DescriptorCollection { 
# 1023
public: DescriptorCollection(); 
# 1024
DescriptorCollection(const DescriptorCollection & collection); 
# 1025
virtual ~DescriptorCollection(); 
# 1028
void set(const std::vector< Mat>  & descriptors); 
# 1029
virtual void clear(); 
# 1031
const Mat &getDescriptors() const; 
# 1032
const Mat getDescriptor(int imgIdx, int localDescIdx) const; 
# 1033
const Mat getDescriptor(int globalDescIdx) const; 
# 1034
void getLocalIdx(int globalDescIdx, int & imgIdx, int & localDescIdx) const; 
# 1036
int size() const; 
# 1039
protected: Mat mergedDescriptors; 
# 1040
std::vector< int>  startIdxs; 
# 1041
}; 
# 1046
virtual void knnMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, int k, InputArrayOfArrays masks = noArray(), bool compactResult = false) = 0; 
# 1048
virtual void radiusMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, float maxDistance, InputArrayOfArrays masks = noArray(), bool compactResult = false) = 0; 
# 1051
static bool isPossibleMatch(InputArray mask, int queryIdx, int trainIdx); 
# 1052
static bool isMaskedOut(InputArrayOfArrays masks, int queryIdx); 
# 1054
static Mat clone_op(Mat m) { return m.clone(); } 
# 1055
void checkMasks(InputArrayOfArrays masks, int queryDescriptorsCount) const; 
# 1058
std::vector< Mat>  trainDescCollection; 
# 1059
std::vector< UMat>  utrainDescCollection; 
# 1060
}; 
# 1068
class __attribute((visibility("default"))) BFMatcher : public DescriptorMatcher { 
# 1075
public: BFMatcher(int normType = NORM_L2, bool crossCheck = false); 
# 1077
virtual ~BFMatcher() { } 
# 1079
virtual bool isMaskSupported() const { return true; } 
# 1093 "/usr/include/opencv2/features2d.hpp" 3
static Ptr< BFMatcher>  create(int normType = NORM_L2, bool crossCheck = false); 
# 1095
virtual Ptr< DescriptorMatcher>  clone(bool emptyTrainData = false) const; 
# 1097
protected: virtual void knnMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, int k, InputArrayOfArrays masks = noArray(), bool compactResult = false); 
# 1099
virtual void radiusMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, float maxDistance, InputArrayOfArrays masks = noArray(), bool compactResult = false); 
# 1102
int normType; 
# 1103
bool crossCheck; 
# 1104
}; 
# 1115 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) FlannBasedMatcher : public DescriptorMatcher { 
# 1118
public: FlannBasedMatcher(const Ptr< flann::IndexParams>  & indexParams = makePtr< flann::KDTreeIndexParams> (), const Ptr< flann::SearchParams>  & searchParams = makePtr< flann::SearchParams> ()); 
# 1121
virtual void add(InputArrayOfArrays descriptors); 
# 1122
virtual void clear(); 
# 1125
virtual void read(const FileNode &); 
# 1127
virtual void write(FileStorage &) const; 
# 1129
virtual void train(); 
# 1130
virtual bool isMaskSupported() const; 
# 1132
static Ptr< FlannBasedMatcher>  create(); 
# 1134
virtual Ptr< DescriptorMatcher>  clone(bool emptyTrainData = false) const; 
# 1136
protected: static void convertToDMatches(const DescriptorCollection & descriptors, const Mat & indices, const Mat & distances, std::vector< std::vector< DMatch> >  & matches); 
# 1140
virtual void knnMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, int k, InputArrayOfArrays masks = noArray(), bool compactResult = false); 
# 1142
virtual void radiusMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, float maxDistance, InputArrayOfArrays masks = noArray(), bool compactResult = false); 
# 1145
Ptr< flann::IndexParams>  indexParams; 
# 1146
Ptr< flann::SearchParams>  searchParams; 
# 1147
Ptr< flann::Index>  flannIndex; 
# 1149
DescriptorCollection mergedDescriptors; 
# 1150
int addedDescCount; 
# 1151
}; 
# 1164 "/usr/include/opencv2/features2d.hpp" 3
struct __attribute((visibility("default"))) DrawMatchesFlags { 
# 1166
enum { DEFAULT, 
# 1171
DRAW_OVER_OUTIMG, 
# 1173
NOT_DRAW_SINGLE_POINTS, 
# 1174
DRAW_RICH_KEYPOINTS = 4
# 1176
}; 
# 1177
}; 
# 1194 "/usr/include/opencv2/features2d.hpp" 3
__attribute((visibility("default"))) void drawKeypoints(InputArray image, const std::vector< KeyPoint>  & keypoints, InputOutputArray outImage, const Scalar & color = Scalar::all(-1), int flags = DrawMatchesFlags::DEFAULT); 
# 1219 "/usr/include/opencv2/features2d.hpp" 3
__attribute((visibility("default"))) void drawMatches(InputArray img1, const std::vector< KeyPoint>  & keypoints1, InputArray img2, const std::vector< KeyPoint>  & keypoints2, const std::vector< DMatch>  & matches1to2, InputOutputArray outImg, const Scalar & matchColor = Scalar::all(-1), const Scalar & singlePointColor = Scalar::all(-1), const std::vector< char>  & matchesMask = std::vector< char> (), int flags = DrawMatchesFlags::DEFAULT); 
# 1226
__attribute((visibility("default"))) void drawMatches(InputArray img1, const std::vector< KeyPoint>  & keypoints1, InputArray img2, const std::vector< KeyPoint>  & keypoints2, const std::vector< std::vector< DMatch> >  & matches1to2, InputOutputArray outImg, const Scalar & matchColor = Scalar::all(-1), const Scalar & singlePointColor = Scalar::all(-1), const std::vector< std::vector< char> >  & matchesMask = std::vector< std::vector< char> > (), int flags = DrawMatchesFlags::DEFAULT); 
# 1238
__attribute((visibility("default"))) void evaluateFeatureDetector(const Mat & img1, const Mat & img2, const Mat & H1to2, std::vector< KeyPoint>  * keypoints1, std::vector< KeyPoint>  * keypoints2, float & repeatability, int & correspCount, const Ptr< Feature2D>  & fdetector = Ptr< Feature2D> ()); 
# 1243
__attribute((visibility("default"))) void computeRecallPrecisionCurve(const std::vector< std::vector< DMatch> >  & matches1to2, const std::vector< std::vector< unsigned char> >  & correctMatches1to2Mask, std::vector< Point_< float> >  & recallPrecisionCurve); 
# 1247
__attribute((visibility("default"))) float getRecall(const std::vector< Point_< float> >  & recallPrecisionCurve, float l_precision); 
# 1248
__attribute((visibility("default"))) int getNearestPoint(const std::vector< Point_< float> >  & recallPrecisionCurve, float l_precision); 
# 1262 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) BOWTrainer { 
# 1265
public: BOWTrainer(); 
# 1266
virtual ~BOWTrainer(); 
# 1275 "/usr/include/opencv2/features2d.hpp" 3
void add(const Mat & descriptors); 
# 1279
const std::vector< Mat>  &getDescriptors() const; 
# 1283
int descriptorsCount() const; 
# 1285
virtual void clear(); 
# 1288
virtual Mat cluster() const = 0; 
# 1299 "/usr/include/opencv2/features2d.hpp" 3
virtual Mat cluster(const Mat & descriptors) const = 0; 
# 1302
protected: std::vector< Mat>  descriptors; 
# 1303
int size; 
# 1304
}; 
# 1308
class __attribute((visibility("default"))) BOWKMeansTrainer : public BOWTrainer { 
# 1315
public: BOWKMeansTrainer(int clusterCount, const TermCriteria & termcrit = TermCriteria(), int attempts = 3, int flags = KMEANS_PP_CENTERS); 
# 1317
virtual ~BOWKMeansTrainer(); 
# 1320
virtual Mat cluster() const; 
# 1321
virtual Mat cluster(const Mat & descriptors) const; 
# 1325
protected: int clusterCount; 
# 1326
TermCriteria termcrit; 
# 1327
int attempts; 
# 1328
int flags; 
# 1329
}; 
# 1341 "/usr/include/opencv2/features2d.hpp" 3
class __attribute((visibility("default"))) BOWImgDescriptorExtractor { 
# 1351
public: BOWImgDescriptorExtractor(const Ptr< Feature2D>  & dextractor, const Ptr< DescriptorMatcher>  & dmatcher); 
# 1354
BOWImgDescriptorExtractor(const Ptr< DescriptorMatcher>  & dmatcher); 
# 1355
virtual ~BOWImgDescriptorExtractor(); 
# 1362
void setVocabulary(const Mat & vocabulary); 
# 1366
const Mat &getVocabulary() const; 
# 1378 "/usr/include/opencv2/features2d.hpp" 3
void compute(InputArray image, std::vector< KeyPoint>  & keypoints, OutputArray imgDescriptor, std::vector< std::vector< int> >  * pointIdxsOfClusters = 0, Mat * descriptors = 0); 
# 1387
void compute(InputArray keypointDescriptors, OutputArray imgDescriptor, std::vector< std::vector< int> >  * pointIdxsOfClusters = 0); 
# 1391
void compute2(const Mat &image, std::vector< KeyPoint>  &keypoints, Mat &imgDescriptor) 
# 1392
{ this->compute(image, keypoints, imgDescriptor); } 
# 1396
int descriptorSize() const; 
# 1400
int descriptorType() const; 
# 1403
protected: Mat vocabulary; 
# 1404
Ptr< Feature2D>  dextractor; 
# 1405
Ptr< DescriptorMatcher>  dmatcher; 
# 1406
}; 
# 1412
}
# 51 "/usr/include/opencv2/core/affine.hpp" 3
namespace cv { 
# 60
template< class T> 
# 61
class Affine3 { 
# 64
public: typedef T float_type; 
# 65
typedef Matx< T, 3, 3>  Mat3; 
# 66
typedef Matx< T, 4, 4>  Mat4; 
# 67
typedef Vec< T, 3>  Vec3; 
# 69
inline Affine3(); 
# 72
inline Affine3(const Mat4 & affine); 
# 75
inline Affine3(const Mat3 & R, const Vec3 & t = Vec3::all(0)); 
# 78
inline Affine3(const Vec3 & rvec, const Vec3 & t = Vec3::all(0)); 
# 81
inline explicit Affine3(const Mat & data, const Vec3 & t = Vec3::all(0)); 
# 84
inline explicit Affine3(const float_type * vals); 
# 87
static inline Affine3 Identity(); 
# 90
inline void rotation(const Mat3 & R); 
# 93
inline void rotation(const Vec3 & rvec); 
# 96
inline void rotation(const Mat & data); 
# 98
inline void linear(const Mat3 & L); 
# 99
inline void translation(const Vec3 & t); 
# 101
inline Mat3 rotation() const; 
# 102
inline Mat3 linear() const; 
# 103
inline Vec3 translation() const; 
# 106
inline Vec3 rvec() const; 
# 108
inline Affine3 inv(int method = cv::DECOMP_SVD) const; 
# 111
inline Affine3 rotate(const Mat3 & R) const; 
# 114
inline Affine3 rotate(const Vec3 & rvec) const; 
# 117
inline Affine3 translate(const Vec3 & t) const; 
# 120
inline Affine3 concatenate(const Affine3 & affine) const; 
# 122
template< class Y> inline operator cv::Affine3< Y> () const; 
# 124
template< class Y> inline cv::Affine3< Y>  cast() const; 
# 126
Mat4 matrix; 
# 134
}; 
# 136
template< class T> static inline Affine3< T>  operator*(const Affine3< T>  & affine1, const Affine3< T>  & affine2); 
# 139
template< class T, class V> static inline V operator*(const Affine3< T>  & affine, const V & vector); 
# 142
typedef Affine3< float>  Affine3f; 
# 143
typedef Affine3< double>  Affine3d; 
# 145
static inline Vec3f operator*(const Affine3f & affine, const Vec3f & vector); 
# 146
static inline Vec3d operator*(const Affine3d & affine, const Vec3d & vector); 
# 148
template< class _Tp> class DataType< Affine3< _Tp> >  { 
# 151
public: typedef Affine3< _Tp>  value_type; 
# 152
typedef Affine3< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 153
typedef _Tp channel_type; 
# 155
enum { generic_type, 
# 156
channels = 16, 
# 157
fmt = traits::SafeFmt< _Tp> ::fmt + (((16) - 1) << 8)
# 162
}; 
# 164
typedef Vec< _Tp, channels>  vec_type; 
# 165
}; 
# 167
namespace traits { 
# 168
template< class _Tp> 
# 169
struct Depth< Affine3< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 170
template< class _Tp> 
# 171
struct Type< Affine3< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((16 - 1) << 3)}; }; 
# 172
}
# 176
}
# 183
template< class T> inline 
# 184
cv::Affine3< T> ::Affine3() : matrix(Mat4::eye()) 
# 186
{ } 
# 188
template< class T> inline 
# 189
cv::Affine3< T> ::Affine3(const Mat4 &affine) : matrix(affine) 
# 191
{ } 
# 193
template< class T> inline 
# 194
cv::Affine3< T> ::Affine3(const Mat3 &R, const Vec3 &t) 
# 195
{ 
# 196
rotation(R); 
# 197
translation(t); 
# 198
(((matrix).val)[12]) = ((((matrix).val)[13]) = ((((matrix).val)[14]) = 0)); 
# 199
(((matrix).val)[15]) = 1; 
# 200
} 
# 202
template< class T> inline 
# 203
cv::Affine3< T> ::Affine3(const Vec3 &_rvec, const Vec3 &t) 
# 204
{ 
# 205
rotation(_rvec); 
# 206
translation(t); 
# 207
(((matrix).val)[12]) = ((((matrix).val)[13]) = ((((matrix).val)[14]) = 0)); 
# 208
(((matrix).val)[15]) = 1; 
# 209
} 
# 211
template< class T> inline 
# 212
cv::Affine3< T> ::Affine3(const Mat &data, const Vec3 &t) 
# 213
{ 
# 214
if (!(!(data.type() == cv::traits::Type< T> ::value))) { ; } else { cv::error(cv::Error::StsAssert, "data.type() == cv::traits::Type<T>::value", __func__, "/usr/include/opencv2/core/affine.hpp", 214); }  
# 216
if (((data.cols) == 4) && ((data.rows) == 4)) 
# 217
{ 
# 218
(data.copyTo(matrix)); 
# 219
return; 
# 220
} else { 
# 221
if (((data.cols) == 4) && ((data.rows) == 3)) 
# 222
{ 
# 223
rotation(data(Rect(0, 0, 3, 3))); 
# 224
translation(data(Rect(3, 0, 1, 3))); 
# 225
} else 
# 227
{ 
# 228
rotation(data); 
# 229
translation(t); 
# 230
}  }  
# 232
(((matrix).val)[12]) = ((((matrix).val)[13]) = ((((matrix).val)[14]) = 0)); 
# 233
(((matrix).val)[15]) = 1; 
# 234
} 
# 236
template< class T> inline 
# 237
cv::Affine3< T> ::Affine3(const float_type *vals) : matrix(vals) 
# 238
{ } 
# 240
template< class T> inline cv::Affine3< T>  
# 241
cv::Affine3< T> ::Identity() 
# 242
{ 
# 243
return ((Affine3)(cv::Affine3< T> ::Mat4::eye())); 
# 244
} 
# 246
template< class T> inline void 
# 247
cv::Affine3< T> ::rotation(const Mat3 &R) 
# 248
{ 
# 249
linear(R); 
# 250
} 
# 252
template< class T> inline void 
# 253
cv::Affine3< T> ::rotation(const Vec3 &_rvec) 
# 254
{ 
# 255
double theta = norm(_rvec); 
# 257
if (theta < ((double)(2.220446049250313081e-16L))) { 
# 258
rotation(Mat3::eye()); } else 
# 260
{ 
# 261
double c = std::cos(theta); 
# 262
double s = std::sin(theta); 
# 263
double c1 = (1.0) - c; 
# 264
double itheta = (theta != (0)) ? (1.0) / theta : (0.0); 
# 266
Point3_< T>  r = _rvec * itheta; 
# 268
Mat3 rrt((r.x) * (r.x), (r.x) * (r.y), (r.x) * (r.z), (r.x) * (r.y), (r.y) * (r.y), (r.y) * (r.z), (r.x) * (r.z), (r.y) * (r.z), (r.z) * (r.z)); 
# 269
Mat3 r_x(0, -(r.z), (r.y), (r.z), 0, -(r.x), -(r.y), (r.x), 0); 
# 273
Mat3 R = ((c * Mat3::eye()) + (c1 * rrt)) + (s * r_x); 
# 275
rotation(R); 
# 276
}  
# 277
} 
# 280
template< class T> inline void 
# 281
cv::Affine3< T> ::rotation(const Mat &data) 
# 282
{ 
# 283
if (!(!(data.type() == cv::traits::Type< T> ::value))) { ; } else { cv::error(cv::Error::StsAssert, "data.type() == cv::traits::Type<T>::value", __func__, "/usr/include/opencv2/core/affine.hpp", 283); }  
# 285
if (((data.cols) == 3) && ((data.rows) == 3)) 
# 286
{ 
# 287
Mat3 R; 
# 288
(data.copyTo(R)); 
# 289
rotation(R); 
# 290
} else { 
# 291
if ((((data.cols) == 3) && ((data.rows) == 1)) || (((data.cols) == 1) && ((data.rows) == 3))) 
# 292
{ 
# 293
Vec3 _rvec; 
# 294
((data.reshape(1, 3)).copyTo(_rvec)); 
# 295
rotation(_rvec); 
# 296
} else { 
# 298
if (!(!(!("Input marix can be 3x3, 1x3 or 3x1")))) { ; } else { cv::error(cv::Error::StsAssert, "!\"Input marix can be 3x3, 1x3 or 3x1\"", __func__, "/usr/include/opencv2/core/affine.hpp", 298); }  }  }  
# 299
} 
# 301
template< class T> inline void 
# 302
cv::Affine3< T> ::linear(const Mat3 &L) 
# 303
{ 
# 304
(((matrix).val)[0]) = ((L.val)[0]); (((matrix).val)[1]) = ((L.val)[1]); (((matrix).val)[2]) = ((L.val)[2]); 
# 305
(((matrix).val)[4]) = ((L.val)[3]); (((matrix).val)[5]) = ((L.val)[4]); (((matrix).val)[6]) = ((L.val)[5]); 
# 306
(((matrix).val)[8]) = ((L.val)[6]); (((matrix).val)[9]) = ((L.val)[7]); (((matrix).val)[10]) = ((L.val)[8]); 
# 307
} 
# 309
template< class T> inline void 
# 310
cv::Affine3< T> ::translation(const Vec3 &t) 
# 311
{ 
# 312
(((matrix).val)[3]) = (t[0]); (((matrix).val)[7]) = (t[1]); (((matrix).val)[11]) = (t[2]); 
# 313
} 
# 315
template< class T> inline typename cv::Affine3< T> ::Mat3 
# 316
cv::Affine3< T> ::rotation() const 
# 317
{ 
# 318
return linear(); 
# 319
} 
# 321
template< class T> inline typename cv::Affine3< T> ::Mat3 
# 322
cv::Affine3< T> ::linear() const 
# 323
{ 
# 324
Mat3 R; 
# 325
((R.val)[0]) = (((matrix).val)[0]); ((R.val)[1]) = (((matrix).val)[1]); ((R.val)[2]) = (((matrix).val)[2]); 
# 326
((R.val)[3]) = (((matrix).val)[4]); ((R.val)[4]) = (((matrix).val)[5]); ((R.val)[5]) = (((matrix).val)[6]); 
# 327
((R.val)[6]) = (((matrix).val)[8]); ((R.val)[7]) = (((matrix).val)[9]); ((R.val)[8]) = (((matrix).val)[10]); 
# 328
return R; 
# 329
} 
# 331
template< class T> inline typename cv::Affine3< T> ::Vec3 
# 332
cv::Affine3< T> ::translation() const 
# 333
{ 
# 334
return Vec3(((matrix).val)[3], ((matrix).val)[7], ((matrix).val)[11]); 
# 335
} 
# 337
template< class T> inline typename cv::Affine3< T> ::Vec3 
# 338
cv::Affine3< T> ::rvec() const 
# 339
{ 
# 340
Vec3d w; 
# 341
Matx33d u, vt, R = rotation(); 
# 342
cv::SVD::compute(R, w, u, vt, (cv::SVD::FULL_UV) + (cv::SVD::MODIFY_A)); 
# 343
R = ((u * vt)); 
# 345
double rx = ((R.val)[7]) - ((R.val)[5]); 
# 346
double ry = ((R.val)[2]) - ((R.val)[6]); 
# 347
double rz = ((R.val)[3]) - ((R.val)[1]); 
# 349
double s = std::sqrt((((rx * rx) + (ry * ry)) + (rz * rz)) * (0.25)); 
# 350
double c = (((((R.val)[0]) + ((R.val)[4])) + ((R.val)[8])) - (1)) * (0.5); 
# 351
c = ((c > (1.0)) ? (1.0) : ((c < (-(1.0))) ? -(1.0) : c)); 
# 352
double theta = acos(c); 
# 354
if (s < (1.000000000000000082e-05)) 
# 355
{ 
# 356
if (c > (0)) { 
# 357
rx = (ry = (rz = (0))); } else 
# 359
{ 
# 360
double t; 
# 361
t = ((((R.val)[0]) + (1)) * (0.5)); 
# 362
rx = std::sqrt(std::max(t, (0.0))); 
# 363
t = ((((R.val)[4]) + (1)) * (0.5)); 
# 364
ry = (std::sqrt(std::max(t, (0.0))) * ((((R.val)[1]) < (0)) ? -(1.0) : (1.0))); 
# 365
t = ((((R.val)[8]) + (1)) * (0.5)); 
# 366
rz = (std::sqrt(std::max(t, (0.0))) * ((((R.val)[2]) < (0)) ? -(1.0) : (1.0))); 
# 368
if ((fabs(rx) < fabs(ry)) && (fabs(rx) < fabs(rz)) && ((((R.val)[5]) > (0)) != ((ry * rz) > (0)))) { 
# 369
rz = (-rz); }  
# 370
theta /= std::sqrt(((rx * rx) + (ry * ry)) + (rz * rz)); 
# 371
rx *= theta; 
# 372
ry *= theta; 
# 373
rz *= theta; 
# 374
}  
# 375
} else 
# 377
{ 
# 378
double vth = (1) / ((2) * s); 
# 379
vth *= theta; 
# 380
rx *= vth; ry *= vth; rz *= vth; 
# 381
}  
# 383
return Vec3d(rx, ry, rz); 
# 384
} 
# 386
template< class T> inline cv::Affine3< T>  
# 387
cv::Affine3< T> ::inv(int method) const 
# 388
{ 
# 389
return ((matrix).inv(method)); 
# 390
} 
# 392
template< class T> inline cv::Affine3< T>  
# 393
cv::Affine3< T> ::rotate(const Mat3 &R) const 
# 394
{ 
# 395
Mat3 Lc = linear(); 
# 396
Vec3 tc = translation(); 
# 397
Mat4 result; 
# 398
((result.val)[12]) = (((result.val)[13]) = (((result.val)[14]) = 0)); 
# 399
((result.val)[15]) = 1; 
# 401
for (int j = 0; j < 3; ++j) 
# 402
{ 
# 403
for (int i = 0; i < 3; ++i) 
# 404
{ 
# 405
float_type value = (0); 
# 406
for (int k = 0; k < 3; ++k) { 
# 407
value += (R(j, k) * Lc(k, i)); }  
# 408
result(j, i) = value; 
# 409
}  
# 411
result(j, 3) = ((R.row(j)).dot((tc.t()))); 
# 412
}  
# 413
return result; 
# 414
} 
# 416
template< class T> inline cv::Affine3< T>  
# 417
cv::Affine3< T> ::rotate(const Vec3 &_rvec) const 
# 418
{ 
# 419
return rotate(((Affine3f)(_rvec)).rotation()); 
# 420
} 
# 422
template< class T> inline cv::Affine3< T>  
# 423
cv::Affine3< T> ::translate(const Vec3 &t) const 
# 424
{ 
# 425
Mat4 m = matrix; 
# 426
((m.val)[3]) += (t[0]); 
# 427
((m.val)[7]) += (t[1]); 
# 428
((m.val)[11]) += (t[2]); 
# 429
return m; 
# 430
} 
# 432
template< class T> inline cv::Affine3< T>  
# 433
cv::Affine3< T> ::concatenate(const Affine3 &affine) const 
# 434
{ 
# 435
return (((*this).rotate((affine.rotation()))).translate((affine.translation()))); 
# 436
} 
# 438
template< class T> template< class Y> inline 
# 439
cv::Affine3< T> ::operator cv::Affine3< Y> () const 
# 440
{ 
# 441
return ((cv::Affine3< Y> )(matrix)); 
# 442
} 
# 444
template< class T> template< class Y> inline cv::Affine3< Y>  
# 445
cv::Affine3< T> ::cast() const 
# 446
{ 
# 447
return ((cv::Affine3< Y> )(matrix)); 
# 448
} 
# 450
template< class T> inline cv::Affine3< T>  
# 451
cv::operator*(const Affine3< T>  &affine1, const Affine3< T>  &affine2) 
# 452
{ 
# 453
return (affine2.concatenate(affine1)); 
# 454
} 
# 456
template< class T, class V> inline V 
# 457
cv::operator*(const Affine3< T>  &affine, const V &v) 
# 458
{ 
# 459
const typename Affine3< T> ::Mat4 &m = ((affine.matrix)); 
# 461
V r; 
# 462
(r.x) = ((((((m.val)[0]) * (v.x)) + (((m.val)[1]) * (v.y))) + (((m.val)[2]) * (v.z))) + ((m.val)[3])); 
# 463
(r.y) = ((((((m.val)[4]) * (v.x)) + (((m.val)[5]) * (v.y))) + (((m.val)[6]) * (v.z))) + ((m.val)[7])); 
# 464
(r.z) = ((((((m.val)[8]) * (v.x)) + (((m.val)[9]) * (v.y))) + (((m.val)[10]) * (v.z))) + ((m.val)[11])); 
# 465
return r; 
# 466
} 
# 469
static inline cv::Vec3f cv::operator*(const Affine3f &affine, const Vec3f &v) 
# 470
{ 
# 471
const Matx44f &m = affine.matrix; 
# 472
Vec3f r; 
# 473
((r.val)[0]) = ((((((m.val)[0]) * v[0]) + (((m.val)[1]) * v[1])) + (((m.val)[2]) * v[2])) + ((m.val)[3])); 
# 474
((r.val)[1]) = ((((((m.val)[4]) * v[0]) + (((m.val)[5]) * v[1])) + (((m.val)[6]) * v[2])) + ((m.val)[7])); 
# 475
((r.val)[2]) = ((((((m.val)[8]) * v[0]) + (((m.val)[9]) * v[1])) + (((m.val)[10]) * v[2])) + ((m.val)[11])); 
# 476
return r; 
# 477
} 
# 480
static inline cv::Vec3d cv::operator*(const Affine3d &affine, const Vec3d &v) 
# 481
{ 
# 482
const Matx44d &m = affine.matrix; 
# 483
Vec3d r; 
# 484
((r.val)[0]) = ((((((m.val)[0]) * v[0]) + (((m.val)[1]) * v[1])) + (((m.val)[2]) * v[2])) + ((m.val)[3])); 
# 485
((r.val)[1]) = ((((((m.val)[4]) * v[0]) + (((m.val)[5]) * v[1])) + (((m.val)[6]) * v[2])) + ((m.val)[7])); 
# 486
((r.val)[2]) = ((((((m.val)[8]) * v[0]) + (((m.val)[9]) * v[1])) + (((m.val)[10]) * v[2])) + ((m.val)[11])); 
# 487
return r; 
# 488
} 
# 223 "/usr/include/opencv2/calib3d.hpp" 3
namespace cv { 
# 230
enum { LMEDS = 4, 
# 231
RANSAC = 8, 
# 232
RHO = 16
# 233
}; 
# 235
enum { SOLVEPNP_ITERATIVE, 
# 236
SOLVEPNP_EPNP, 
# 237
SOLVEPNP_P3P, 
# 238
SOLVEPNP_DLS, 
# 239
SOLVEPNP_UPNP, 
# 240
SOLVEPNP_AP3P, 
# 241
SOLVEPNP_MAX_COUNT
# 242
}; 
# 244
enum { CALIB_CB_ADAPTIVE_THRESH = 1, 
# 245
CALIB_CB_NORMALIZE_IMAGE, 
# 246
CALIB_CB_FILTER_QUADS = 4, 
# 247
CALIB_CB_FAST_CHECK = 8
# 248
}; 
# 250
enum { CALIB_CB_SYMMETRIC_GRID = 1, 
# 251
CALIB_CB_ASYMMETRIC_GRID, 
# 252
CALIB_CB_CLUSTERING = 4
# 253
}; 
# 255
enum { CALIB_USE_INTRINSIC_GUESS = 1, 
# 256
CALIB_FIX_ASPECT_RATIO, 
# 257
CALIB_FIX_PRINCIPAL_POINT = 4, 
# 258
CALIB_ZERO_TANGENT_DIST = 8, 
# 259
CALIB_FIX_FOCAL_LENGTH = 16, 
# 260
CALIB_FIX_K1 = 32, 
# 261
CALIB_FIX_K2 = 64, 
# 262
CALIB_FIX_K3 = 128, 
# 263
CALIB_FIX_K4 = 2048, 
# 264
CALIB_FIX_K5 = 4096, 
# 265
CALIB_FIX_K6 = 8192, 
# 266
CALIB_RATIONAL_MODEL = 16384, 
# 267
CALIB_THIN_PRISM_MODEL = 32768, 
# 268
CALIB_FIX_S1_S2_S3_S4 = 65536, 
# 269
CALIB_TILTED_MODEL = 262144, 
# 270
CALIB_FIX_TAUX_TAUY = 524288, 
# 271
CALIB_USE_QR = 1048576, 
# 272
CALIB_FIX_TANGENT_DIST = 2097152, 
# 274
CALIB_FIX_INTRINSIC = 256, 
# 275
CALIB_SAME_FOCAL_LENGTH = 512, 
# 277
CALIB_ZERO_DISPARITY = 1024, 
# 278
CALIB_USE_LU = 131072
# 279
}; 
# 282
enum { FM_7POINT = 1, 
# 283
FM_8POINT, 
# 284
FM_LMEDS = 4, 
# 285
FM_RANSAC = 8
# 286
}; 
# 307 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian = noArray()); 
# 374 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method = 0, double ransacReprojThreshold = 3, OutputArray mask = noArray(), const int maxIters = 2000, const double confidence = (0.9949999999999999956)); 
# 380
__attribute((visibility("default"))) Mat findHomography(InputArray srcPoints, InputArray dstPoints, OutputArray mask, int method = 0, double ransacReprojThreshold = 3); 
# 402 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) Vec3d RQDecomp3x3(InputArray src, OutputArray mtxR, OutputArray mtxQ, OutputArray Qx = noArray(), OutputArray Qy = noArray(), OutputArray Qz = noArray()); 
# 429 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void decomposeProjectionMatrix(InputArray projMatrix, OutputArray cameraMatrix, OutputArray rotMatrix, OutputArray transVect, OutputArray rotMatrixX = noArray(), OutputArray rotMatrixY = noArray(), OutputArray rotMatrixZ = noArray(), OutputArray eulerAngles = noArray()); 
# 449 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void matMulDeriv(InputArray A, InputArray B, OutputArray dABdA, OutputArray dABdB); 
# 481 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void composeRT(InputArray rvec1, InputArray tvec1, InputArray rvec2, InputArray tvec2, OutputArray rvec3, OutputArray tvec3, OutputArray dr3dr1 = noArray(), OutputArray dr3dt1 = noArray(), OutputArray dr3dr2 = noArray(), OutputArray dr3dt2 = noArray(), OutputArray dt3dr1 = noArray(), OutputArray dt3dt1 = noArray(), OutputArray dt3dr2 = noArray(), OutputArray dt3dt2 = noArray()); 
# 521 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian = noArray(), double aspectRatio = 0); 
# 592 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess = false, int flags = SOLVEPNP_ITERATIVE); 
# 639 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) bool solvePnPRansac(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess = false, int iterationsCount = 100, float reprojectionError = (8.0), double confidence = (0.9899999999999999911), OutputArray inliers = noArray(), int flags = SOLVEPNP_ITERATIVE); 
# 668 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) int solveP3P(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags); 
# 688 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) Mat initCameraMatrix2D(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, double aspectRatio = (1.0)); 
# 741 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags = (CALIB_CB_ADAPTIVE_THRESH) + (CALIB_CB_NORMALIZE_IMAGE)); 
# 745
__attribute((visibility("default"))) bool find4QuadCornerSubpix(InputArray img, InputOutputArray corners, Size region_size); 
# 759 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void drawChessboardCorners(InputOutputArray image, Size patternSize, InputArray corners, bool patternWasFound); 
# 762
struct __attribute((visibility("default"))) CirclesGridFinderParameters { 
# 764
CirclesGridFinderParameters(); 
# 765
Size2f densityNeighborhoodSize; 
# 766
float minDensity; 
# 767
int kmeansAttempts; 
# 768
int minDistanceToAddKeypoint; 
# 769
int keypointScale; 
# 770
float minGraphConfidence; 
# 771
float vertexGain; 
# 772
float vertexPenalty; 
# 773
float existingVertexGain; 
# 774
float edgeGain; 
# 775
float edgePenalty; 
# 776
float convexHullFactor; 
# 777
float minRNGEdgeSwitchDist; 
# 779
enum GridType { 
# 781
SYMMETRIC_GRID, ASYMMETRIC_GRID
# 782
}; 
# 783
GridType gridType; 
# 784
}; 
# 786
struct __attribute((visibility("default"))) CirclesGridFinderParameters2 : public CirclesGridFinderParameters { 
# 788
CirclesGridFinderParameters2(); 
# 790
float squareSize; 
# 791
float maxRectifiedDistance; 
# 792
}; 
# 826 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) bool findCirclesGrid(InputArray image, Size patternSize, OutputArray centers, int flags, const Ptr< Feature2D>  & blobDetector, CirclesGridFinderParameters parameters); 
# 832
__attribute((visibility("default"))) bool findCirclesGrid2(InputArray image, Size patternSize, OutputArray centers, int flags, const Ptr< Feature2D>  & blobDetector, CirclesGridFinderParameters2 parameters); 
# 838
__attribute((visibility("default"))) bool findCirclesGrid(InputArray image, Size patternSize, OutputArray centers, int flags = CALIB_CB_SYMMETRIC_GRID, const Ptr< Feature2D>  & blobDetector = SimpleBlobDetector::create()); 
# 955 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, OutputArray stdDeviationsIntrinsics, OutputArray stdDeviationsExtrinsics, OutputArray perViewErrors, int flags = 0, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (double)(2.220446049250313081e-16L))); 
# 973 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags = 0, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (double)(2.220446049250313081e-16L))); 
# 1000 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void calibrationMatrixValues(InputArray cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double & fovx, double & fovy, double & focalLength, Point2d & principalPoint, double & aspectRatio); 
# 1098 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, int flags = CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (9.999999999999999547e-07))); 
# 1186 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags = CALIB_ZERO_DISPARITY, double alpha = -1, Size newImageSize = Size(), Rect * validPixROI1 = 0, Rect * validPixROI2 = 0); 
# 1224 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) bool stereoRectifyUncalibrated(InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold = 5); 
# 1230
__attribute((visibility("default"))) float rectify3Collinear(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, InputArray cameraMatrix3, InputArray distCoeffs3, InputArrayOfArrays imgpt1, InputArrayOfArrays imgpt3, Size imageSize, InputArray R12, InputArray T12, InputArray R13, InputArray T13, OutputArray R1, OutputArray R2, OutputArray R3, OutputArray P1, OutputArray P2, OutputArray P3, OutputArray Q, double alpha, Size newImgSize, Rect * roi1, Rect * roi2, int flags); 
# 1268 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) Mat getOptimalNewCameraMatrix(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize = Size(), Rect * validPixROI = 0, bool centerPrincipalPoint = false); 
# 1281 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void convertPointsToHomogeneous(InputArray src, OutputArray dst); 
# 1292 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void convertPointsFromHomogeneous(InputArray src, OutputArray dst); 
# 1304 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void convertPointsHomogeneous(InputArray src, OutputArray dst); 
# 1356 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) Mat findFundamentalMat(InputArray points1, InputArray points2, int method = FM_RANSAC, double param1 = (3.0), double param2 = (0.9899999999999999911), OutputArray mask = noArray()); 
# 1362
__attribute((visibility("default"))) Mat findFundamentalMat(InputArray points1, InputArray points2, OutputArray mask, int method = FM_RANSAC, double param1 = (3.0), double param2 = (0.9899999999999999911)); 
# 1395 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) Mat findEssentialMat(InputArray points1, InputArray points2, InputArray cameraMatrix, int method = RANSAC, double prob = (0.9989999999999999991), double threshold = (1.0), OutputArray mask = noArray()); 
# 1429 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) Mat findEssentialMat(InputArray points1, InputArray points2, double focal = (1.0), Point2d pp = Point2d(0, 0), int method = RANSAC, double prob = (0.9989999999999999991), double threshold = (1.0), OutputArray mask = noArray()); 
# 1445 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void decomposeEssentialMat(InputArray E, OutputArray R1, OutputArray R2, OutputArray t); 
# 1492 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) int recoverPose(InputArray E, InputArray points1, InputArray points2, InputArray cameraMatrix, OutputArray R, OutputArray t, InputOutputArray mask = noArray()); 
# 1521 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) int recoverPose(InputArray E, InputArray points1, InputArray points2, OutputArray R, OutputArray t, double focal = (1.0), Point2d pp = Point2d(0, 0), InputOutputArray mask = noArray()); 
# 1544 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) int recoverPose(InputArray E, InputArray points1, InputArray points2, InputArray cameraMatrix, OutputArray R, OutputArray t, double distanceThresh, InputOutputArray mask = noArray(), OutputArray triangulatedPoints = noArray()); 
# 1571 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void computeCorrespondEpilines(InputArray points, int whichImage, InputArray F, OutputArray lines); 
# 1593 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void triangulatePoints(InputArray projMatr1, InputArray projMatr2, InputArray projPoints1, InputArray projPoints2, OutputArray points4D); 
# 1612 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void correctMatches(InputArray F, InputArray points1, InputArray points2, OutputArray newPoints1, OutputArray newPoints2); 
# 1627 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void filterSpeckles(InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff, InputOutputArray buf = noArray()); 
# 1632
__attribute((visibility("default"))) Rect getValidDisparityROI(Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int SADWindowSize); 
# 1637
__attribute((visibility("default"))) void validateDisparity(InputOutputArray disparity, InputArray cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp = 1); 
# 1667 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues = false, int ddepth = -1); 
# 1681 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) double sampsonDistance(InputArray pt1, InputArray pt2, InputArray F); 
# 1698 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) int estimateAffine3D(InputArray src, InputArray dst, OutputArray out, OutputArray inliers, double ransacThreshold = 3, double confidence = (0.9899999999999999911)); 
# 1736 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) Mat estimateAffine2D(InputArray from, InputArray to, OutputArray inliers = noArray(), int method = RANSAC, double ransacReprojThreshold = 3, size_t maxIters = 2000, double confidence = (0.9899999999999999911), size_t refineIters = 10); 
# 1784 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) Mat estimateAffinePartial2D(InputArray from, InputArray to, OutputArray inliers = noArray(), int method = RANSAC, double ransacReprojThreshold = 3, size_t maxIters = 2000, double confidence = (0.9899999999999999911), size_t refineIters = 10); 
# 1803 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) int decomposeHomographyMat(InputArray H, InputArray K, OutputArrayOfArrays rotations, OutputArrayOfArrays translations, OutputArrayOfArrays normals); 
# 1811
class __attribute((visibility("default"))) StereoMatcher : public Algorithm { 
# 1814
public: enum { DISP_SHIFT = 4, 
# 1815
DISP_SCALE = 16
# 1816
}; 
# 1826 "/usr/include/opencv2/calib3d.hpp" 3
virtual void compute(InputArray left, InputArray right, OutputArray disparity) = 0; 
# 1829
virtual int getMinDisparity() const = 0; 
# 1830
virtual void setMinDisparity(int minDisparity) = 0; 
# 1832
virtual int getNumDisparities() const = 0; 
# 1833
virtual void setNumDisparities(int numDisparities) = 0; 
# 1835
virtual int getBlockSize() const = 0; 
# 1836
virtual void setBlockSize(int blockSize) = 0; 
# 1838
virtual int getSpeckleWindowSize() const = 0; 
# 1839
virtual void setSpeckleWindowSize(int speckleWindowSize) = 0; 
# 1841
virtual int getSpeckleRange() const = 0; 
# 1842
virtual void setSpeckleRange(int speckleRange) = 0; 
# 1844
virtual int getDisp12MaxDiff() const = 0; 
# 1845
virtual void setDisp12MaxDiff(int disp12MaxDiff) = 0; 
# 1846
}; 
# 1852
class __attribute((visibility("default"))) StereoBM : public StereoMatcher { 
# 1855
public: enum { PREFILTER_NORMALIZED_RESPONSE, 
# 1856
PREFILTER_XSOBEL
# 1857
}; 
# 1859
virtual int getPreFilterType() const = 0; 
# 1860
virtual void setPreFilterType(int preFilterType) = 0; 
# 1862
virtual int getPreFilterSize() const = 0; 
# 1863
virtual void setPreFilterSize(int preFilterSize) = 0; 
# 1865
virtual int getPreFilterCap() const = 0; 
# 1866
virtual void setPreFilterCap(int preFilterCap) = 0; 
# 1868
virtual int getTextureThreshold() const = 0; 
# 1869
virtual void setTextureThreshold(int textureThreshold) = 0; 
# 1871
virtual int getUniquenessRatio() const = 0; 
# 1872
virtual void setUniquenessRatio(int uniquenessRatio) = 0; 
# 1874
virtual int getSmallerBlockSize() const = 0; 
# 1875
virtual void setSmallerBlockSize(int blockSize) = 0; 
# 1877
virtual Rect getROI1() const = 0; 
# 1878
virtual void setROI1(Rect roi1) = 0; 
# 1880
virtual Rect getROI2() const = 0; 
# 1881
virtual void setROI2(Rect roi2) = 0; 
# 1896 "/usr/include/opencv2/calib3d.hpp" 3
static Ptr< StereoBM>  create(int numDisparities = 0, int blockSize = 21); 
# 1897
}; 
# 1917 "/usr/include/opencv2/calib3d.hpp" 3
class __attribute((visibility("default"))) StereoSGBM : public StereoMatcher { 
# 1921
public: enum { 
# 1922
MODE_SGBM, 
# 1923
MODE_HH, 
# 1924
MODE_SGBM_3WAY, 
# 1925
MODE_HH4
# 1926
}; 
# 1928
virtual int getPreFilterCap() const = 0; 
# 1929
virtual void setPreFilterCap(int preFilterCap) = 0; 
# 1931
virtual int getUniquenessRatio() const = 0; 
# 1932
virtual void setUniquenessRatio(int uniquenessRatio) = 0; 
# 1934
virtual int getP1() const = 0; 
# 1935
virtual void setP1(int P1) = 0; 
# 1937
virtual int getP2() const = 0; 
# 1938
virtual void setP2(int P2) = 0; 
# 1940
virtual int getMode() const = 0; 
# 1941
virtual void setMode(int mode) = 0; 
# 1980 "/usr/include/opencv2/calib3d.hpp" 3
static Ptr< StereoSGBM>  create(int minDisparity = 0, int numDisparities = 16, int blockSize = 3, int P1 = 0, int P2 = 0, int disp12MaxDiff = 0, int preFilterCap = 0, int uniquenessRatio = 0, int speckleWindowSize = 0, int speckleRange = 0, int mode = StereoSGBM::MODE_SGBM); 
# 1985
}; 
# 1992
namespace fisheye { 
# 1997
enum { 
# 1998
CALIB_USE_INTRINSIC_GUESS = 1, 
# 1999
CALIB_RECOMPUTE_EXTRINSIC, 
# 2000
CALIB_CHECK_COND = 4, 
# 2001
CALIB_FIX_SKEW = 8, 
# 2002
CALIB_FIX_K1 = 16, 
# 2003
CALIB_FIX_K2 = 32, 
# 2004
CALIB_FIX_K3 = 64, 
# 2005
CALIB_FIX_K4 = 128, 
# 2006
CALIB_FIX_INTRINSIC = 256, 
# 2007
CALIB_FIX_PRINCIPAL_POINT = 512
# 2008
}; 
# 2030 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void projectPoints(InputArray objectPoints, OutputArray imagePoints, const Affine3d & affine, InputArray K, InputArray D, double alpha = 0, OutputArray jacobian = noArray()); 
# 2034
__attribute((visibility("default"))) void projectPoints(InputArray objectPoints, OutputArray imagePoints, InputArray rvec, InputArray tvec, InputArray K, InputArray D, double alpha = 0, OutputArray jacobian = noArray()); 
# 2050 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void distortPoints(InputArray undistorted, OutputArray distorted, InputArray K, InputArray D, double alpha = 0); 
# 2063 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void undistortPoints(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray R = noArray(), InputArray P = noArray()); 
# 2080 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void initUndistortRectifyMap(InputArray K, InputArray D, InputArray R, InputArray P, const Size & size, int m1type, OutputArray map1, OutputArray map2); 
# 2111 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void undistortImage(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray Knew = cv::noArray(), const Size & new_size = Size()); 
# 2127 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void estimateNewCameraMatrixForUndistortRectify(InputArray K, InputArray D, const Size & image_size, InputArray R, OutputArray P, double balance = (0.0), const Size & new_size = Size(), double fov_scale = (1.0)); 
# 2163 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) double calibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, const Size & image_size, InputOutputArray K, InputOutputArray D, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags = 0, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 100, (double)(2.220446049250313081e-16L))); 
# 2197 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) void stereoRectify(InputArray K1, InputArray D1, InputArray K2, InputArray D2, const Size & imageSize, InputArray R, InputArray tvec, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, const Size & newImageSize = Size(), double balance = (0.0), double fov_scale = (1.0)); 
# 2233 "/usr/include/opencv2/calib3d.hpp" 3
__attribute((visibility("default"))) double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray K1, InputOutputArray D1, InputOutputArray K2, InputOutputArray D2, Size imageSize, OutputArray R, OutputArray T, int flags = fisheye::CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 100, (double)(2.220446049250313081e-16L))); 
# 2239
}
# 2241
}
# 50 "/usr/include/opencv2/calib3d/calib3d_c.h" 3
extern "C" {
# 61 "/usr/include/opencv2/calib3d/calib3d_c.h" 3
typedef struct CvPOSITObject CvPOSITObject; 
# 64
__attribute((visibility("default"))) CvPOSITObject *cvCreatePOSITObject(CvPoint3D32f * points, int point_count); 
# 69
__attribute((visibility("default"))) void cvPOSIT(CvPOSITObject * posit_object, CvPoint2D32f * image_points, double focal_length, CvTermCriteria criteria, float * rotation_matrix, float * translation_vector); 
# 74
__attribute((visibility("default"))) void cvReleasePOSITObject(CvPOSITObject ** posit_object); 
# 77
__attribute((visibility("default"))) int cvRANSACUpdateNumIters(double p, double err_prob, int model_points, int max_iters); 
# 80
__attribute((visibility("default"))) void cvConvertPointsHomogeneous(const CvMat * src, CvMat * dst); 
# 95 "/usr/include/opencv2/calib3d/calib3d_c.h" 3
enum { 
# 96
CV_ITERATIVE, 
# 97
CV_EPNP, 
# 98
CV_P3P, 
# 99
CV_DLS
# 100
}; 
# 102
__attribute((visibility("default"))) int cvFindFundamentalMat(const CvMat * points1, const CvMat * points2, CvMat * fundamental_matrix, int method = 8, double param1 = (3.0), double param2 = (0.9899999999999999911), CvMat * status = 0); 
# 111
__attribute((visibility("default"))) void cvComputeCorrespondEpilines(const CvMat * points, int which_image, const CvMat * fundamental_matrix, CvMat * correspondent_lines); 
# 118
__attribute((visibility("default"))) void cvTriangulatePoints(CvMat * projMatr1, CvMat * projMatr2, CvMat * projPoints1, CvMat * projPoints2, CvMat * points4D); 
# 122
__attribute((visibility("default"))) void cvCorrectMatches(CvMat * F, CvMat * points1, CvMat * points2, CvMat * new_points1, CvMat * new_points2); 
# 130
__attribute((visibility("default"))) void cvGetOptimalNewCameraMatrix(const CvMat * camera_matrix, const CvMat * dist_coeffs, CvSize image_size, double alpha, CvMat * new_camera_matrix, CvSize new_imag_size = cvSize(0, 0), CvRect * valid_pixel_ROI = 0, int center_principal_point = 0); 
# 139
__attribute((visibility("default"))) int cvRodrigues2(const CvMat * src, CvMat * dst, CvMat * jacobian = 0); 
# 143
__attribute((visibility("default"))) int cvFindHomography(const CvMat * src_points, const CvMat * dst_points, CvMat * homography, int method = 0, double ransacReprojThreshold = 3, CvMat * mask = 0, int maxIters = 2000, double confidence = (0.9949999999999999956)); 
# 153
__attribute((visibility("default"))) void cvRQDecomp3x3(const CvMat * matrixM, CvMat * matrixR, CvMat * matrixQ, CvMat * matrixQx = 0, CvMat * matrixQy = 0, CvMat * matrixQz = 0, CvPoint3D64f * eulerAngles = 0); 
# 160
__attribute((visibility("default"))) void cvDecomposeProjectionMatrix(const CvMat * projMatr, CvMat * calibMatr, CvMat * rotMatr, CvMat * posVect, CvMat * rotMatrX = 0, CvMat * rotMatrY = 0, CvMat * rotMatrZ = 0, CvPoint3D64f * eulerAngles = 0); 
# 168
__attribute((visibility("default"))) void cvCalcMatMulDeriv(const CvMat * A, const CvMat * B, CvMat * dABdA, CvMat * dABdB); 
# 172
__attribute((visibility("default"))) void cvComposeRT(const CvMat * _rvec1, const CvMat * _tvec1, const CvMat * _rvec2, const CvMat * _tvec2, CvMat * _rvec3, CvMat * _tvec3, CvMat * dr3dr1 = 0, CvMat * dr3dt1 = 0, CvMat * dr3dr2 = 0, CvMat * dr3dt2 = 0, CvMat * dt3dr1 = 0, CvMat * dt3dt1 = 0, CvMat * dt3dr2 = 0, CvMat * dt3dt2 = 0); 
# 182
__attribute((visibility("default"))) void cvProjectPoints2(const CvMat * object_points, const CvMat * rotation_vector, const CvMat * translation_vector, const CvMat * camera_matrix, const CvMat * distortion_coeffs, CvMat * image_points, CvMat * dpdrot = 0, CvMat * dpdt = 0, CvMat * dpdf = 0, CvMat * dpdc = 0, CvMat * dpddist = 0, double aspect_ratio = 0); 
# 192
__attribute((visibility("default"))) void cvFindExtrinsicCameraParams2(const CvMat * object_points, const CvMat * image_points, const CvMat * camera_matrix, const CvMat * distortion_coeffs, CvMat * rotation_vector, CvMat * translation_vector, int use_extrinsic_guess = 0); 
# 202
__attribute((visibility("default"))) void cvInitIntrinsicParams2D(const CvMat * object_points, const CvMat * image_points, const CvMat * npoints, CvSize image_size, CvMat * camera_matrix, double aspect_ratio = (1.0)); 
# 219 "/usr/include/opencv2/calib3d/calib3d_c.h" 3
__attribute((visibility("default"))) int cvCheckChessboard(IplImage * src, CvSize size); 
# 222
__attribute((visibility("default"))) int cvFindChessboardCorners(const void * image, CvSize pattern_size, CvPoint2D32f * corners, int * corner_count = 0, int flags = 1 + 2); 
# 228
__attribute((visibility("default"))) void cvDrawChessboardCorners(CvArr * image, CvSize pattern_size, CvPoint2D32f * corners, int count, int pattern_was_found); 
# 254 "/usr/include/opencv2/calib3d/calib3d_c.h" 3
__attribute((visibility("default"))) double cvCalibrateCamera2(const CvMat * object_points, const CvMat * image_points, const CvMat * point_counts, CvSize image_size, CvMat * camera_matrix, CvMat * distortion_coeffs, CvMat * rotation_vectors = 0, CvMat * translation_vectors = 0, int flags = 0, CvTermCriteria term_crit = cvTermCriteria(1 + 2, 30, (double)(2.220446049250313081e-16L))); 
# 268
__attribute((visibility("default"))) void cvCalibrationMatrixValues(const CvMat * camera_matrix, CvSize image_size, double aperture_width = 0, double aperture_height = 0, double * fovx = 0, double * fovy = 0, double * focal_length = 0, CvPoint2D64f * principal_point = 0, double * pixel_aspect_ratio = 0); 
# 284
__attribute((visibility("default"))) double cvStereoCalibrate(const CvMat * object_points, const CvMat * image_points1, const CvMat * image_points2, const CvMat * npoints, CvMat * camera_matrix1, CvMat * dist_coeffs1, CvMat * camera_matrix2, CvMat * dist_coeffs2, CvSize image_size, CvMat * R, CvMat * T, CvMat * E = 0, CvMat * F = 0, int flags = 256, CvTermCriteria term_crit = cvTermCriteria(1 + 2, 30, (9.999999999999999547e-07))); 
# 298
__attribute((visibility("default"))) void cvStereoRectify(const CvMat * camera_matrix1, const CvMat * camera_matrix2, const CvMat * dist_coeffs1, const CvMat * dist_coeffs2, CvSize image_size, const CvMat * R, const CvMat * T, CvMat * R1, CvMat * R2, CvMat * P1, CvMat * P2, CvMat * Q = 0, int flags = 1024, double alpha = -1, CvSize new_image_size = cvSize(0, 0), CvRect * valid_pix_ROI1 = 0, CvRect * valid_pix_ROI2 = 0); 
# 311
__attribute((visibility("default"))) int cvStereoRectifyUncalibrated(const CvMat * points1, const CvMat * points2, const CvMat * F, CvSize img_size, CvMat * H1, CvMat * H2, double threshold = 5); 
# 356 "/usr/include/opencv2/calib3d/calib3d_c.h" 3
typedef 
# 324
struct CvStereoBMState { 
# 327
int preFilterType; 
# 328
int preFilterSize; 
# 329
int preFilterCap; 
# 332
int SADWindowSize; 
# 333
int minDisparity; 
# 334
int numberOfDisparities; 
# 337
int textureThreshold; 
# 339
int uniquenessRatio; 
# 342
int speckleWindowSize; 
# 343
int speckleRange; 
# 345
int trySmallerWindows; 
# 347
CvRect roi1, roi2; 
# 348
int disp12MaxDiff; 
# 351
CvMat *preFilteredImg0; 
# 352
CvMat *preFilteredImg1; 
# 353
CvMat *slidingSumBuf; 
# 354
CvMat *cost; 
# 355
CvMat *disp; 
# 356
} CvStereoBMState; 
# 362
__attribute((visibility("default"))) CvStereoBMState *cvCreateStereoBMState(int preset = 0, int numberOfDisparities = 0); 
# 365
__attribute((visibility("default"))) void cvReleaseStereoBMState(CvStereoBMState ** state); 
# 367
__attribute((visibility("default"))) void cvFindStereoCorrespondenceBM(const CvArr * left, const CvArr * right, CvArr * disparity, CvStereoBMState * state); 
# 370
__attribute((visibility("default"))) CvRect cvGetValidDisparityROI(CvRect roi1, CvRect roi2, int minDisparity, int numberOfDisparities, int SADWindowSize); 
# 373
__attribute((visibility("default"))) void cvValidateDisparity(CvArr * disparity, const CvArr * cost, int minDisparity, int numberOfDisparities, int disp12MaxDiff = 1); 
# 378
__attribute((visibility("default"))) void cvReprojectImageTo3D(const CvArr * disparityImage, CvArr * _3dImage, const CvMat * Q, int handleMissingValues = 0); 
# 385
}
# 388
class __attribute((visibility("default"))) CvLevMarq { 
# 391
public: CvLevMarq(); 
# 392
CvLevMarq(int nparams, int nerrs, CvTermCriteria criteria = cvTermCriteria(2 + 1, 30, (double)(2.220446049250313081e-16L)), bool completeSymmFlag = false); 
# 395
~CvLevMarq(); 
# 396
void init(int nparams, int nerrs, CvTermCriteria criteria = cvTermCriteria(2 + 1, 30, (double)(2.220446049250313081e-16L)), bool completeSymmFlag = false); 
# 399
bool update(const CvMat *& param, CvMat *& J, CvMat *& err); 
# 400
bool updateAlt(const CvMat *& param, CvMat *& JtJ, CvMat *& JtErr, double *& errNorm); 
# 402
void clear(); 
# 403
void step(); 
# 404
enum { DONE, STARTED, CALC_J, CHECK_ERR}; 
# 406
cv::Ptr< CvMat>  mask; 
# 407
cv::Ptr< CvMat>  prevParam; 
# 408
cv::Ptr< CvMat>  param; 
# 409
cv::Ptr< CvMat>  J; 
# 410
cv::Ptr< CvMat>  err; 
# 411
cv::Ptr< CvMat>  JtJ; 
# 412
cv::Ptr< CvMat>  JtJN; 
# 413
cv::Ptr< CvMat>  JtErr; 
# 414
cv::Ptr< CvMat>  JtJV; 
# 415
cv::Ptr< CvMat>  JtJW; 
# 416
double prevErrNorm, errNorm; 
# 417
int lambdaLg10; 
# 418
CvTermCriteria criteria; 
# 419
int state; 
# 420
int iters; 
# 421
bool completeSymmFlag; 
# 422
int solveMethod; 
# 423
}; 
# 36 "/usr/include/opencv2/flann/general.h" 3
namespace cvflann { 
# 39
class FLANNException : public cv::Exception { 
# 42
public: FLANNException(const char *message) : cv::Exception(0, message, "", "/usr/include/opencv2/flann/general.h", 42) { } 
# 44
FLANNException(const cv::String &message) : cv::Exception(0, message, "", "/usr/include/opencv2/flann/general.h", 44) { } 
# 45
}; 
# 47
}
# 38 "/usr/include/opencv2/flann/matrix.h" 3
namespace cvflann { 
# 45
template< class T> 
# 46
class Matrix { 
# 49
public: typedef T type; 
# 51
size_t rows; 
# 52
size_t cols; 
# 53
size_t stride; 
# 54
T *data; 
# 56
Matrix() : rows((0)), cols((0)), stride((0)), data((__null)) 
# 57
{ 
# 58
} 
# 60
Matrix(T *data_, size_t rows_, size_t cols_, size_t stride_ = 0) : rows(rows_), cols(cols_), stride(stride_), data(data_) 
# 62
{ 
# 63
if ((stride) == (0)) { (stride) = (cols); }  
# 64
} 
# 69
__attribute((deprecated)) void free() 
# 70
{ 
# 71
fprintf(stderr, "The cvflann::Matrix<T>::free() method is deprecated and it does not do any memory deallocation any more.  You areresponsible for" " deallocating the matrix memory (by doing\'delete[] matrix.data\' for example)"); 
# 75
} 
# 80
T *operator[](size_t index) const 
# 81
{ 
# 82
return (data) + (index * (stride)); 
# 83
} 
# 84
}; 
# 87
class UntypedMatrix { 
# 90
public: size_t rows; 
# 91
size_t cols; 
# 92
void *data; 
# 93
flann_datatype_t type; 
# 95
UntypedMatrix(void *data_, long rows_, long cols_) : rows(rows_), cols(cols_), data(data_) 
# 97
{ 
# 98
} 
# 100
~UntypedMatrix() 
# 101
{ 
# 102
} 
# 105
template< class T> Matrix< T>  
# 106
as() 
# 107
{ 
# 108
return Matrix< T> ((T *)(data), rows, cols); 
# 109
} 
# 110
}; 
# 114
}
# 20 "/usr/include/opencv2/flann/any.h" 3
namespace cvflann { 
# 23
namespace anyimpl { 
# 26
struct bad_any_cast { 
# 28
}; 
# 30
struct empty_any { 
# 32
}; 
# 34
inline std::ostream &operator<<(std::ostream &out, const empty_any &) 
# 35
{ 
# 36
(out << ("[empty_any]")); 
# 37
return out; 
# 38
} 
# 40
struct base_any_policy { 
# 42
virtual void static_delete(void ** x) = 0; 
# 43
virtual void copy_from_value(const void * src, void ** dest) = 0; 
# 44
virtual void clone(void *const * src, void ** dest) = 0; 
# 45
virtual void move(void *const * src, void ** dest) = 0; 
# 46
virtual void *get_value(void ** src) = 0; 
# 47
virtual const void *get_value(void *const * src) = 0; 
# 48
virtual size_t get_size() = 0; 
# 49
virtual const std::type_info &type() = 0; 
# 50
virtual void print(std::ostream & out, void *const * src) = 0; 
# 51
virtual ~base_any_policy() { } 
# 52
}; 
# 54
template< class T> 
# 55
struct typed_base_any_policy : public base_any_policy { 
# 57
virtual size_t get_size() { return sizeof(T); } 
# 58
virtual const std::type_info &type() { return typeid(T); } 
# 60
}; 
# 62
template< class T> 
# 63
struct small_any_policy : public typed_base_any_policy< T>  { 
# 65
virtual void static_delete(void **) { } 
# 66
virtual void copy_from_value(const void *src, void **dest) 
# 67
{ 
# 68
new (dest) (T)(*(reinterpret_cast< const T *>(src))); 
# 69
} 
# 70
virtual void clone(void *const *src, void **dest) { (*dest) = (*src); } 
# 71
virtual void move(void *const *src, void **dest) { (*dest) = (*src); } 
# 72
virtual void *get_value(void **src) { return reinterpret_cast< void *>(src); } 
# 73
virtual const void *get_value(void *const *src) { return reinterpret_cast< const void *>(src); } 
# 74
virtual void print(::std::ostream &out, void *const *src) { out << (*(reinterpret_cast< const T *>(src))); } 
# 75
}; 
# 77
template< class T> 
# 78
struct big_any_policy : public typed_base_any_policy< T>  { 
# 80
virtual void static_delete(void **x) 
# 81
{ 
# 82
if (*x) { delete (*(reinterpret_cast< T **>(x))); }  
# 83
(*x) = (__null); 
# 84
} 
# 85
virtual void copy_from_value(const void *src, void **dest) 
# 86
{ 
# 87
(*dest) = (new (T)(*(reinterpret_cast< const T *>(src)))); 
# 88
} 
# 89
virtual void clone(void *const *src, void **dest) 
# 90
{ 
# 91
(*dest) = (new (T)(*(*(reinterpret_cast< T *const *>(src))))); 
# 92
} 
# 93
virtual void move(void *const *src, void **dest) 
# 94
{ 
# 95
((*(reinterpret_cast< T **>(dest)))->~T()); 
# 96
(*(*(reinterpret_cast< T **>(dest)))) = (*(*(reinterpret_cast< T *const *>(src)))); 
# 97
} 
# 98
virtual void *get_value(void **src) { return *src; } 
# 99
virtual const void *get_value(void *const *src) { return *src; } 
# 100
virtual void print(::std::ostream &out, void *const *src) { out << (*(reinterpret_cast< const T *>(*src))); } 
# 101
}; 
# 103
template<> inline void big_any_policy< flann_centers_init_t> ::print(std::ostream &out, void *const *src) 
# 104
{ 
# 105
(out << ((int)(*(reinterpret_cast< const flann_centers_init_t *>(*src))))); 
# 106
} 
# 108
template<> inline void big_any_policy< flann_algorithm_t> ::print(std::ostream &out, void *const *src) 
# 109
{ 
# 110
(out << ((int)(*(reinterpret_cast< const flann_algorithm_t *>(*src))))); 
# 111
} 
# 113
template<> inline void big_any_policy< cv::String> ::print(std::ostream &out, void *const *src) 
# 114
{ 
# 115
(out << ((*(reinterpret_cast< const cv::String *>(*src))).c_str())); 
# 116
} 
# 118
template< class T> 
# 119
struct choose_policy { 
# 121
typedef big_any_policy< T>  type; 
# 122
}; 
# 124
template< class T> 
# 125
struct choose_policy< T *>  { 
# 127
typedef small_any_policy< T *>  type; 
# 128
}; 
# 130
struct any; 
# 135
template<> struct choose_policy< any>  { 
# 137
typedef void type; 
# 138
}; 
# 146
template<> struct choose_policy< signed char>  { typedef small_any_policy< signed char>  type; }; 
# 147
template<> struct choose_policy< unsigned char>  { typedef small_any_policy< unsigned char>  type; }; 
# 148
template<> struct choose_policy< signed short>  { typedef small_any_policy< signed short>  type; }; 
# 149
template<> struct choose_policy< unsigned short>  { typedef small_any_policy< unsigned short>  type; }; 
# 150
template<> struct choose_policy< signed int>  { typedef small_any_policy< signed int>  type; }; 
# 151
template<> struct choose_policy< unsigned>  { typedef small_any_policy< unsigned>  type; }; 
# 152
template<> struct choose_policy< signed long>  { typedef small_any_policy< signed long>  type; }; 
# 153
template<> struct choose_policy< unsigned long>  { typedef small_any_policy< unsigned long>  type; }; 
# 154
template<> struct choose_policy< float>  { typedef small_any_policy< float>  type; }; 
# 155
template<> struct choose_policy< bool>  { typedef small_any_policy< bool>  type; }; 
# 159
template< class T> 
# 160
class SinglePolicy { 
# 162
SinglePolicy(); 
# 163
SinglePolicy(const SinglePolicy & other); 
# 164
SinglePolicy &operator=(const SinglePolicy & other); 
# 167
public: static inline base_any_policy *get_policy(); 
# 170
private: static typename choose_policy< T> ::type policy; 
# 171
}; 
# 173
template< class T> typename choose_policy< T> ::type 
# 174
SinglePolicy< T> ::policy; 
# 177
template< class T> inline base_any_policy *
# 178
SinglePolicy< T> ::get_policy() { return &policy; } 
# 180
}
# 182
struct any { 
# 186
private: anyimpl::base_any_policy *policy; 
# 187
void *object; 
# 192
public: 
# 191
template< class T> 
# 192
any(const T &x) : policy(anyimpl::SinglePolicy< anyimpl::empty_any> ::get_policy()), object((__null)) 
# 194
{ 
# 195
assign(x); 
# 196
} 
# 199
any() : policy(anyimpl::SinglePolicy< anyimpl::empty_any> ::get_policy()), object((__null)) 
# 201
{ } 
# 204
any(const char *x) : policy(anyimpl::SinglePolicy< anyimpl::empty_any> ::get_policy()), object((__null)) 
# 206
{ 
# 207
this->assign(x); 
# 208
} 
# 211
any(const any &x) : policy(anyimpl::SinglePolicy< anyimpl::empty_any> ::get_policy()), object((__null)) 
# 213
{ 
# 214
this->assign(x); 
# 215
} 
# 218
~any() 
# 219
{ 
# 220
(policy)->static_delete(&(object)); 
# 221
} 
# 224
any &assign(const any &x) 
# 225
{ 
# 226
this->reset(); 
# 227
(policy) = (x.policy); 
# 228
(policy)->clone(&(x.object), &(object)); 
# 229
return *this; 
# 230
} 
# 233
template< class T> any &
# 234
assign(const T &x) 
# 235
{ 
# 236
this->reset(); 
# 237
(policy) = anyimpl::SinglePolicy< T> ::get_policy(); 
# 238
(policy)->copy_from_value(&x, &(object)); 
# 239
return *this; 
# 240
} 
# 243
template< class T> any &
# 244
operator=(const T &x) 
# 245
{ 
# 246
return assign(x); 
# 247
} 
# 250
any &operator=(const any &x) 
# 251
{ 
# 252
return this->assign(x); 
# 253
} 
# 257
any &operator=(const char *x) 
# 258
{ 
# 259
return this->assign(x); 
# 260
} 
# 263
any &swap(any &x) 
# 264
{ 
# 265
std::swap(policy, x.policy); 
# 266
std::swap(object, x.object); 
# 267
return *this; 
# 268
} 
# 271
template< class T> T &
# 272
cast() 
# 273
{ 
# 274
if ((((policy)->type()) != (typeid(T)))) { throw (anyimpl::bad_any_cast()); }  
# 275
T *r = reinterpret_cast< T *>((policy)->get_value(&(object))); 
# 276
return *r; 
# 277
} 
# 280
template< class T> const T &
# 281
cast() const 
# 282
{ 
# 283
if ((((policy)->type()) != (typeid(T)))) { throw (anyimpl::bad_any_cast()); }  
# 284
const T *r = reinterpret_cast< const T *>((policy)->get_value(&(object))); 
# 285
return *r; 
# 286
} 
# 289
bool empty() const 
# 290
{ 
# 291
return (((policy)->type()) == (typeid(anyimpl::empty_any))); 
# 292
} 
# 295
void reset() 
# 296
{ 
# 297
(policy)->static_delete(&(object)); 
# 298
(policy) = anyimpl::SinglePolicy< anyimpl::empty_any> ::get_policy(); 
# 299
} 
# 302
bool compatible(const any &x) const 
# 303
{ 
# 304
return (((policy)->type()) == ((x.policy)->type())); 
# 305
} 
# 308
template< class T> bool 
# 309
has_type() 
# 310
{ 
# 311
return (((policy)->type()) == (typeid(T))); 
# 312
} 
# 314
const std::type_info &type() const 
# 315
{ 
# 316
return (policy)->type(); 
# 317
} 
# 319
friend inline std::ostream &operator<<(std::ostream & out, const any & any_val); 
# 320
}; 
# 322
inline std::ostream &operator<<(std::ostream &out, const any &any_val) 
# 323
{ 
# 324
(any_val.policy)->print(out, &(any_val.object)); 
# 325
return out; 
# 326
} 
# 328
}
# 72 "/usr/include/c++/5/bits/stl_tree.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 92 "/usr/include/c++/5/bits/stl_tree.h" 3
enum _Rb_tree_color { _S_red, _S_black}; 
# 94
struct _Rb_tree_node_base { 
# 96
typedef _Rb_tree_node_base *_Base_ptr; 
# 97
typedef const _Rb_tree_node_base *_Const_Base_ptr; 
# 99
_Rb_tree_color _M_color; 
# 100
_Base_ptr _M_parent; 
# 101
_Base_ptr _M_left; 
# 102
_Base_ptr _M_right; 
# 105
static _Base_ptr _S_minimum(_Base_ptr __x) noexcept 
# 106
{ 
# 107
while ((__x->_M_left) != (0)) { __x = (__x->_M_left); }  
# 108
return __x; 
# 109
} 
# 112
static _Const_Base_ptr _S_minimum(_Const_Base_ptr __x) noexcept 
# 113
{ 
# 114
while ((__x->_M_left) != (0)) { __x = (__x->_M_left); }  
# 115
return __x; 
# 116
} 
# 119
static _Base_ptr _S_maximum(_Base_ptr __x) noexcept 
# 120
{ 
# 121
while ((__x->_M_right) != (0)) { __x = (__x->_M_right); }  
# 122
return __x; 
# 123
} 
# 126
static _Const_Base_ptr _S_maximum(_Const_Base_ptr __x) noexcept 
# 127
{ 
# 128
while ((__x->_M_right) != (0)) { __x = (__x->_M_right); }  
# 129
return __x; 
# 130
} 
# 131
}; 
# 133
template< class _Val> 
# 134
struct _Rb_tree_node : public _Rb_tree_node_base { 
# 136
typedef _Rb_tree_node *_Link_type; 
# 149 "/usr/include/c++/5/bits/stl_tree.h" 3
__gnu_cxx::__aligned_membuf< _Val>  _M_storage; 
# 152
_Val *_M_valptr() 
# 153
{ return ((_M_storage)._M_ptr()); } 
# 156
const _Val *_M_valptr() const 
# 157
{ return ((_M_storage)._M_ptr()); } 
# 159
}; 
# 161
__attribute((__pure__)) _Rb_tree_node_base *
# 162
_Rb_tree_increment(_Rb_tree_node_base * __x) throw(); 
# 164
__attribute((__pure__)) const _Rb_tree_node_base *
# 165
_Rb_tree_increment(const _Rb_tree_node_base * __x) throw(); 
# 167
__attribute((__pure__)) _Rb_tree_node_base *
# 168
_Rb_tree_decrement(_Rb_tree_node_base * __x) throw(); 
# 170
__attribute((__pure__)) const _Rb_tree_node_base *
# 171
_Rb_tree_decrement(const _Rb_tree_node_base * __x) throw(); 
# 173
template< class _Tp> 
# 174
struct _Rb_tree_iterator { 
# 176
typedef _Tp value_type; 
# 177
typedef _Tp &reference; 
# 178
typedef _Tp *pointer; 
# 180
typedef bidirectional_iterator_tag iterator_category; 
# 181
typedef ptrdiff_t difference_type; 
# 183
typedef _Rb_tree_iterator _Self; 
# 184
typedef _Rb_tree_node_base::_Base_ptr _Base_ptr; 
# 185
typedef _Rb_tree_node< _Tp>  *_Link_type; 
# 187
_Rb_tree_iterator() noexcept : _M_node() 
# 188
{ } 
# 191
explicit _Rb_tree_iterator(_Base_ptr __x) noexcept : _M_node(__x) 
# 192
{ } 
# 195
reference operator*() const noexcept 
# 196
{ return *((static_cast< _Link_type>(_M_node))->_M_valptr()); } 
# 199
pointer operator->() const noexcept 
# 200
{ return ((static_cast< _Link_type>(_M_node))->_M_valptr()); } 
# 203
_Self &operator++() noexcept 
# 204
{ 
# 205
(_M_node) = _Rb_tree_increment(_M_node); 
# 206
return *this; 
# 207
} 
# 210
_Self operator++(int) noexcept 
# 211
{ 
# 212
_Self __tmp = *this; 
# 213
(_M_node) = _Rb_tree_increment(_M_node); 
# 214
return __tmp; 
# 215
} 
# 218
_Self &operator--() noexcept 
# 219
{ 
# 220
(_M_node) = _Rb_tree_decrement(_M_node); 
# 221
return *this; 
# 222
} 
# 225
_Self operator--(int) noexcept 
# 226
{ 
# 227
_Self __tmp = *this; 
# 228
(_M_node) = _Rb_tree_decrement(_M_node); 
# 229
return __tmp; 
# 230
} 
# 233
bool operator==(const _Self &__x) const noexcept 
# 234
{ return (_M_node) == (__x._M_node); } 
# 237
bool operator!=(const _Self &__x) const noexcept 
# 238
{ return (_M_node) != (__x._M_node); } 
# 240
_Base_ptr _M_node; 
# 241
}; 
# 243
template< class _Tp> 
# 244
struct _Rb_tree_const_iterator { 
# 246
typedef _Tp value_type; 
# 247
typedef const _Tp &reference; 
# 248
typedef const _Tp *pointer; 
# 250
typedef _Rb_tree_iterator< _Tp>  iterator; 
# 252
typedef bidirectional_iterator_tag iterator_category; 
# 253
typedef ptrdiff_t difference_type; 
# 255
typedef _Rb_tree_const_iterator _Self; 
# 256
typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr; 
# 257
typedef const _Rb_tree_node< _Tp>  *_Link_type; 
# 259
_Rb_tree_const_iterator() noexcept : _M_node() 
# 260
{ } 
# 263
explicit _Rb_tree_const_iterator(_Base_ptr __x) noexcept : _M_node(__x) 
# 264
{ } 
# 266
_Rb_tree_const_iterator(const iterator &__it) noexcept : _M_node(((__it._M_node))) 
# 267
{ } 
# 270
iterator _M_const_cast() const noexcept 
# 271
{ return ((iterator)(const_cast< typename _Rb_tree_iterator< _Tp> ::_Base_ptr>(_M_node))); } 
# 274
reference operator*() const noexcept 
# 275
{ return *((static_cast< _Link_type>(_M_node))->_M_valptr()); } 
# 278
pointer operator->() const noexcept 
# 279
{ return ((static_cast< _Link_type>(_M_node))->_M_valptr()); } 
# 282
_Self &operator++() noexcept 
# 283
{ 
# 284
(_M_node) = _Rb_tree_increment(_M_node); 
# 285
return *this; 
# 286
} 
# 289
_Self operator++(int) noexcept 
# 290
{ 
# 291
_Self __tmp = *this; 
# 292
(_M_node) = _Rb_tree_increment(_M_node); 
# 293
return __tmp; 
# 294
} 
# 297
_Self &operator--() noexcept 
# 298
{ 
# 299
(_M_node) = _Rb_tree_decrement(_M_node); 
# 300
return *this; 
# 301
} 
# 304
_Self operator--(int) noexcept 
# 305
{ 
# 306
_Self __tmp = *this; 
# 307
(_M_node) = _Rb_tree_decrement(_M_node); 
# 308
return __tmp; 
# 309
} 
# 312
bool operator==(const _Self &__x) const noexcept 
# 313
{ return (_M_node) == (__x._M_node); } 
# 316
bool operator!=(const _Self &__x) const noexcept 
# 317
{ return (_M_node) != (__x._M_node); } 
# 319
_Base_ptr _M_node; 
# 320
}; 
# 322
template< class _Val> inline bool 
# 324
operator==(const _Rb_tree_iterator< _Val>  &__x, const _Rb_tree_const_iterator< _Val>  &
# 325
__y) noexcept 
# 326
{ return (__x._M_node) == (__y._M_node); } 
# 328
template< class _Val> inline bool 
# 330
operator!=(const _Rb_tree_iterator< _Val>  &__x, const _Rb_tree_const_iterator< _Val>  &
# 331
__y) noexcept 
# 332
{ return (__x._M_node) != (__y._M_node); } 
# 335
void _Rb_tree_insert_and_rebalance(const bool __insert_left, _Rb_tree_node_base * __x, _Rb_tree_node_base * __p, _Rb_tree_node_base & __header) throw(); 
# 341
_Rb_tree_node_base *_Rb_tree_rebalance_for_erase(_Rb_tree_node_base *const __z, _Rb_tree_node_base & __header) throw(); 
# 345
template< class _Key, class _Val, class _KeyOfValue, class 
# 346
_Compare, class _Alloc = allocator< _Val> > 
# 347
class _Rb_tree { 
# 350
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Rb_tree_node< _Val> > ::other _Node_allocator; 
# 352
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Rb_tree_node< _Val> > ::other>  _Alloc_traits; 
# 355
protected: typedef _Rb_tree_node_base *_Base_ptr; 
# 356
typedef const _Rb_tree_node_base *_Const_Base_ptr; 
# 357
typedef _Rb_tree_node< _Val>  *_Link_type; 
# 358
typedef const _Rb_tree_node< _Val>  *_Const_Link_type; 
# 363
private: struct _Reuse_or_alloc_node { 
# 365
_Reuse_or_alloc_node(_Rb_tree &__t) : _M_root((__t._M_root())), _M_nodes((__t._M_rightmost())), _M_t(__t) 
# 367
{ 
# 368
if (_M_root) 
# 369
{ 
# 370
((_M_root)->_M_parent) = (0); 
# 372
if ((_M_nodes)->_M_left) { 
# 373
(_M_nodes) = ((_M_nodes)->_M_left); }  
# 374
} else { 
# 376
(_M_nodes) = (0); }  
# 377
} 
# 380
_Reuse_or_alloc_node(const _Reuse_or_alloc_node &) = delete;
# 383
~_Reuse_or_alloc_node() 
# 384
{ ((_M_t)._M_erase(static_cast< _Link_type>(_M_root))); } 
# 386
template< class _Arg> _Link_type 
# 391
operator()(_Arg &&__arg) 
# 393
{ 
# 394
_Link_type __node = static_cast< _Link_type>(_M_extract()); 
# 395
if (__node) 
# 396
{ 
# 397
((_M_t)._M_destroy_node(__node)); 
# 398
((_M_t)._M_construct_node(__node, std::forward< _Arg> (__arg))); 
# 399
return __node; 
# 400
}  
# 402
return ((_M_t)._M_create_node(std::forward< _Arg> (__arg))); 
# 403
} 
# 407
private: _Base_ptr _M_extract() 
# 408
{ 
# 409
if (!(_M_nodes)) { 
# 410
return _M_nodes; }  
# 412
_Base_ptr __node = _M_nodes; 
# 413
(_M_nodes) = ((_M_nodes)->_M_parent); 
# 414
if (_M_nodes) 
# 415
{ 
# 416
if (((_M_nodes)->_M_right) == __node) 
# 417
{ 
# 418
((_M_nodes)->_M_right) = (0); 
# 420
if ((_M_nodes)->_M_left) 
# 421
{ 
# 422
(_M_nodes) = ((_M_nodes)->_M_left); 
# 424
while ((_M_nodes)->_M_right) { 
# 425
(_M_nodes) = ((_M_nodes)->_M_right); }  
# 427
if ((_M_nodes)->_M_left) { 
# 428
(_M_nodes) = ((_M_nodes)->_M_left); }  
# 429
}  
# 430
} else { 
# 432
((_M_nodes)->_M_left) = (0); }  
# 433
} else { 
# 435
(_M_root) = (0); }  
# 437
return __node; 
# 438
} 
# 440
_Base_ptr _M_root; 
# 441
_Base_ptr _M_nodes; 
# 442
_Rb_tree &_M_t; 
# 443
}; 
# 447
struct _Alloc_node { 
# 449
_Alloc_node(_Rb_tree &__t) : _M_t(__t) 
# 450
{ } 
# 452
template< class _Arg> _Link_type 
# 457
operator()(_Arg &&__arg) const 
# 459
{ return ((_M_t)._M_create_node(std::forward< _Arg> (__arg))); } 
# 462
private: _Rb_tree &_M_t; 
# 463
}; 
# 466
public: typedef _Key key_type; 
# 467
typedef _Val value_type; 
# 468
typedef value_type *pointer; 
# 469
typedef const value_type *const_pointer; 
# 470
typedef value_type &reference; 
# 471
typedef const value_type &const_reference; 
# 472
typedef size_t size_type; 
# 473
typedef ptrdiff_t difference_type; 
# 474
typedef _Alloc allocator_type; 
# 477
_Node_allocator &_M_get_Node_allocator() noexcept 
# 478
{ return *(static_cast< _Node_allocator *>(&(this->_M_impl))); } 
# 481
const _Node_allocator &_M_get_Node_allocator() const noexcept 
# 482
{ return *(static_cast< const _Node_allocator *>(&(this->_M_impl))); } 
# 485
allocator_type get_allocator() const noexcept 
# 486
{ return (allocator_type)this->_M_get_Node_allocator(); } 
# 490
protected: _Link_type _M_get_node() 
# 491
{ return _Alloc_traits::allocate(this->_M_get_Node_allocator(), 1); } 
# 494
void _M_put_node(_Link_type __p) noexcept 
# 495
{ _Alloc_traits::deallocate(this->_M_get_Node_allocator(), __p, 1); } 
# 522 "/usr/include/c++/5/bits/stl_tree.h" 3
template< class ..._Args> void 
# 524
_M_construct_node(_Link_type __node, _Args &&...__args) 
# 525
{ 
# 526
try 
# 527
{ 
# 528
::new (__node) _Rb_tree_node< _Val> ; 
# 529
_Alloc_traits::construct(this->_M_get_Node_allocator(), (__node->_M_valptr()), std::forward< _Args> (__args)...); 
# 532
} 
# 533
catch (...) 
# 534
{ 
# 535
(__node->~_Rb_tree_node< _Val> ()); 
# 536
_M_put_node(__node); 
# 537
throw; 
# 538
}  
# 539
} 
# 541
template< class ..._Args> _Link_type 
# 543
_M_create_node(_Args &&...__args) 
# 544
{ 
# 545
_Link_type __tmp = _M_get_node(); 
# 546
_M_construct_node(__tmp, std::forward< _Args> (__args)...); 
# 547
return __tmp; 
# 548
} 
# 551
void _M_destroy_node(_Link_type __p) noexcept 
# 552
{ 
# 553
_Alloc_traits::destroy(this->_M_get_Node_allocator(), (__p->_M_valptr())); 
# 554
(__p->~_Rb_tree_node< _Val> ()); 
# 555
} 
# 559
void _M_drop_node(_Link_type __p) noexcept 
# 560
{ 
# 561
_M_destroy_node(__p); 
# 562
_M_put_node(__p); 
# 563
} 
# 565
template< class _NodeGen> _Link_type 
# 567
_M_clone_node(_Const_Link_type __x, _NodeGen &__node_gen) 
# 568
{ 
# 569
_Link_type __tmp = __node_gen(*(__x->_M_valptr())); 
# 570
(__tmp->_M_color) = (__x->_M_color); 
# 571
(__tmp->_M_left) = 0; 
# 572
(__tmp->_M_right) = 0; 
# 573
return __tmp; 
# 574
} 
# 578
template< class _Key_compare, bool 
# 579
 = __is_pod(_Key_compare)> 
# 580
struct _Rb_tree_impl : public _Node_allocator { 
# 582
_Key_compare _M_key_compare; 
# 583
::std::_Rb_tree_node_base _M_header; 
# 584
typename ::std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::size_type _M_node_count; 
# 586
_Rb_tree_impl() : ::std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator(), _M_key_compare(), _M_header(), _M_node_count((0)) 
# 589
{ _M_initialize(); } 
# 591
_Rb_tree_impl(const _Key_compare &__comp, const typename ::std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator &__a) : ::std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator(__a), _M_key_compare(__comp), _M_header(), _M_node_count((0)) 
# 594
{ _M_initialize(); } 
# 597
_Rb_tree_impl(const _Key_compare &__comp, typename ::std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator &&__a) : ::std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator(::std::move(__a)), _M_key_compare(__comp), _M_header(), _M_node_count((0)) 
# 600
{ _M_initialize(); } 
# 604
void _M_reset() 
# 605
{ 
# 606
((this->_M_header)._M_parent) = (0); 
# 607
((this->_M_header)._M_left) = (&(this->_M_header)); 
# 608
((this->_M_header)._M_right) = (&(this->_M_header)); 
# 609
(this->_M_node_count) = (0); 
# 610
} 
# 614
private: void _M_initialize() 
# 615
{ 
# 616
((this->_M_header)._M_color) = _S_red; 
# 617
((this->_M_header)._M_parent) = (0); 
# 618
((this->_M_header)._M_left) = (&(this->_M_header)); 
# 619
((this->_M_header)._M_right) = (&(this->_M_header)); 
# 620
} 
# 621
}; 
# 623
_Rb_tree_impl< _Compare>  _M_impl; 
# 627
_Base_ptr &_M_root() noexcept 
# 628
{ return ((this->_M_impl)._M_header)._M_parent; } 
# 631
_Const_Base_ptr _M_root() const noexcept 
# 632
{ return ((this->_M_impl)._M_header)._M_parent; } 
# 635
_Base_ptr &_M_leftmost() noexcept 
# 636
{ return ((this->_M_impl)._M_header)._M_left; } 
# 639
_Const_Base_ptr _M_leftmost() const noexcept 
# 640
{ return ((this->_M_impl)._M_header)._M_left; } 
# 643
_Base_ptr &_M_rightmost() noexcept 
# 644
{ return ((this->_M_impl)._M_header)._M_right; } 
# 647
_Const_Base_ptr _M_rightmost() const noexcept 
# 648
{ return ((this->_M_impl)._M_header)._M_right; } 
# 651
_Link_type _M_begin() noexcept 
# 652
{ return static_cast< _Link_type>(((this->_M_impl)._M_header)._M_parent); } 
# 655
_Const_Link_type _M_begin() const noexcept 
# 656
{ 
# 657
return static_cast< _Const_Link_type>(((this->_M_impl)._M_header)._M_parent); 
# 659
} 
# 662
_Link_type _M_end() noexcept 
# 663
{ return reinterpret_cast< _Link_type>(&((this->_M_impl)._M_header)); } 
# 666
_Const_Link_type _M_end() const noexcept 
# 667
{ return reinterpret_cast< _Const_Link_type>(&((this->_M_impl)._M_header)); } 
# 670
static const_reference _S_value(_Const_Link_type __x) 
# 671
{ return *(__x->_M_valptr()); } 
# 674
static const _Key &_S_key(_Const_Link_type __x) 
# 675
{ return _KeyOfValue()(_S_value(__x)); } 
# 678
static _Link_type _S_left(_Base_ptr __x) noexcept 
# 679
{ return static_cast< _Link_type>(__x->_M_left); } 
# 682
static _Const_Link_type _S_left(_Const_Base_ptr __x) noexcept 
# 683
{ return static_cast< _Const_Link_type>(__x->_M_left); } 
# 686
static _Link_type _S_right(_Base_ptr __x) noexcept 
# 687
{ return static_cast< _Link_type>(__x->_M_right); } 
# 690
static _Const_Link_type _S_right(_Const_Base_ptr __x) noexcept 
# 691
{ return static_cast< _Const_Link_type>(__x->_M_right); } 
# 694
static const_reference _S_value(_Const_Base_ptr __x) 
# 695
{ return *((static_cast< _Const_Link_type>(__x))->_M_valptr()); } 
# 698
static const _Key &_S_key(_Const_Base_ptr __x) 
# 699
{ return _KeyOfValue()(_S_value(__x)); } 
# 702
static _Base_ptr _S_minimum(_Base_ptr __x) noexcept 
# 703
{ return _Rb_tree_node_base::_S_minimum(__x); } 
# 706
static _Const_Base_ptr _S_minimum(_Const_Base_ptr __x) noexcept 
# 707
{ return _Rb_tree_node_base::_S_minimum(__x); } 
# 710
static _Base_ptr _S_maximum(_Base_ptr __x) noexcept 
# 711
{ return _Rb_tree_node_base::_S_maximum(__x); } 
# 714
static _Const_Base_ptr _S_maximum(_Const_Base_ptr __x) noexcept 
# 715
{ return _Rb_tree_node_base::_S_maximum(__x); } 
# 718
public: typedef _Rb_tree_iterator< _Val>  iterator; 
# 719
typedef _Rb_tree_const_iterator< _Val>  const_iterator; 
# 721
typedef std::reverse_iterator< _Rb_tree_iterator< _Val> >  reverse_iterator; 
# 722
typedef std::reverse_iterator< _Rb_tree_const_iterator< _Val> >  const_reverse_iterator; 
# 726
private: pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_unique_pos(const key_type & __k); 
# 729
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_equal_pos(const key_type & __k); 
# 732
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_hint_unique_pos(const_iterator __pos, const key_type & __k); 
# 736
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_hint_equal_pos(const_iterator __pos, const key_type & __k); 
# 740
template< class _Arg, class _NodeGen> iterator _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg && __v, _NodeGen &); 
# 745
iterator _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z); 
# 747
template< class _Arg> iterator _M_insert_lower(_Base_ptr __y, _Arg && __v); 
# 751
template< class _Arg> iterator _M_insert_equal_lower(_Arg && __x); 
# 756
iterator _M_insert_lower_node(_Base_ptr __p, _Link_type __z); 
# 759
iterator _M_insert_equal_lower_node(_Link_type __z); 
# 775 "/usr/include/c++/5/bits/stl_tree.h" 3
template< class _NodeGen> _Link_type _M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen &); 
# 780
_Link_type _M_copy(_Const_Link_type __x, _Link_type __p) 
# 781
{ 
# 782
_Alloc_node __an(*this); 
# 783
return _M_copy(__x, __p, __an); 
# 784
} 
# 787
void _M_erase(_Link_type __x); 
# 790
iterator _M_lower_bound(_Link_type __x, _Link_type __y, const _Key & __k); 
# 794
const_iterator _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key & __k) const; 
# 798
iterator _M_upper_bound(_Link_type __x, _Link_type __y, const _Key & __k); 
# 802
const_iterator _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key & __k) const; 
# 807
public: _Rb_tree() { } 
# 809
_Rb_tree(const _Compare &__comp, const allocator_type &
# 810
__a = allocator_type()) : _M_impl(__comp, (_Node_allocator)__a) 
# 811
{ } 
# 813
_Rb_tree(const _Rb_tree &__x) : _M_impl(((__x._M_impl)._M_key_compare), _Alloc_traits::_S_select_on_copy((__x._M_get_Node_allocator()))) 
# 816
{ 
# 817
if ((__x._M_root()) != 0) 
# 818
{ 
# 819
this->_M_root() = _M_copy((__x._M_begin()), this->_M_end()); 
# 820
this->_M_leftmost() = _S_minimum(this->_M_root()); 
# 821
this->_M_rightmost() = _S_maximum(this->_M_root()); 
# 822
((_M_impl)._M_node_count) = ((__x._M_impl)._M_node_count); 
# 823
}  
# 824
} 
# 827
_Rb_tree(const allocator_type &__a) : _M_impl(_Compare(), (_Node_allocator)__a) 
# 829
{ } 
# 831
_Rb_tree(const _Rb_tree &__x, const allocator_type &__a) : _M_impl(((__x._M_impl)._M_key_compare), (_Node_allocator)__a) 
# 833
{ 
# 834
if ((__x._M_root()) != nullptr) 
# 835
{ 
# 836
this->_M_root() = _M_copy((__x._M_begin()), this->_M_end()); 
# 837
this->_M_leftmost() = _S_minimum(this->_M_root()); 
# 838
this->_M_rightmost() = _S_maximum(this->_M_root()); 
# 839
((_M_impl)._M_node_count) = ((__x._M_impl)._M_node_count); 
# 840
}  
# 841
} 
# 843
_Rb_tree(_Rb_tree &&__x) : _M_impl(((__x._M_impl)._M_key_compare), (__x._M_get_Node_allocator())) 
# 845
{ 
# 846
if ((__x._M_root()) != 0) { 
# 847
_M_move_data(__x, true_type()); }  
# 848
} 
# 850
_Rb_tree(_Rb_tree &&__x, const allocator_type &__a) : _Rb_tree(std::move(__x), (_Node_allocator)__a) 
# 852
{ } 
# 854
_Rb_tree(_Rb_tree && __x, _Node_allocator && __a); 
# 857
~_Rb_tree() noexcept 
# 858
{ _M_erase(this->_M_begin()); } 
# 861
_Rb_tree &operator=(const _Rb_tree & __x); 
# 865
_Compare key_comp() const 
# 866
{ return (_M_impl)._M_key_compare; } 
# 869
iterator begin() noexcept 
# 870
{ return ((iterator)((((this->_M_impl)._M_header)._M_left))); } 
# 873
const_iterator begin() const noexcept 
# 874
{ return ((const_iterator)((((this->_M_impl)._M_header)._M_left))); } 
# 877
iterator end() noexcept 
# 878
{ return ((iterator)(&((this->_M_impl)._M_header))); } 
# 881
const_iterator end() const noexcept 
# 882
{ return ((const_iterator)(&((this->_M_impl)._M_header))); } 
# 885
reverse_iterator rbegin() noexcept 
# 886
{ return ((reverse_iterator)(this->end())); } 
# 889
const_reverse_iterator rbegin() const noexcept 
# 890
{ return ((const_reverse_iterator)(this->end())); } 
# 893
reverse_iterator rend() noexcept 
# 894
{ return ((reverse_iterator)(this->begin())); } 
# 897
const_reverse_iterator rend() const noexcept 
# 898
{ return ((const_reverse_iterator)(this->begin())); } 
# 901
bool empty() const noexcept 
# 902
{ return ((_M_impl)._M_node_count) == 0; } 
# 905
size_type size() const noexcept 
# 906
{ return (_M_impl)._M_node_count; } 
# 909
size_type max_size() const noexcept 
# 910
{ return _Alloc_traits::max_size(this->_M_get_Node_allocator()); } 
# 914
void swap(_Rb_tree & __t) noexcept(_Alloc_traits::_S_nothrow_swap()); 
# 921
template< class _Arg> pair< _Rb_tree_iterator< _Val> , bool>  _M_insert_unique(_Arg && __x); 
# 925
template< class _Arg> iterator _M_insert_equal(_Arg && __x); 
# 929
template< class _Arg, class _NodeGen> iterator _M_insert_unique_(const_iterator __pos, _Arg && __x, _NodeGen &); 
# 933
template< class _Arg> iterator 
# 935
_M_insert_unique_(const_iterator __pos, _Arg &&__x) 
# 936
{ 
# 937
_Alloc_node __an(*this); 
# 938
return _M_insert_unique_(__pos, std::forward< _Arg> (__x), __an); 
# 939
} 
# 941
template< class _Arg, class _NodeGen> iterator _M_insert_equal_(const_iterator __pos, _Arg && __x, _NodeGen &); 
# 945
template< class _Arg> iterator 
# 947
_M_insert_equal_(const_iterator __pos, _Arg &&__x) 
# 948
{ 
# 949
_Alloc_node __an(*this); 
# 950
return _M_insert_equal_(__pos, std::forward< _Arg> (__x), __an); 
# 951
} 
# 953
template< class ..._Args> pair< _Rb_tree_iterator< _Val> , bool>  _M_emplace_unique(_Args && ...__args); 
# 957
template< class ..._Args> iterator _M_emplace_equal(_Args && ...__args); 
# 961
template< class ..._Args> iterator _M_emplace_hint_unique(const_iterator __pos, _Args && ...__args); 
# 965
template< class ..._Args> iterator _M_emplace_hint_equal(const_iterator __pos, _Args && ...__args); 
# 999 "/usr/include/c++/5/bits/stl_tree.h" 3
template< class _InputIterator> void _M_insert_unique(_InputIterator __first, _InputIterator __last); 
# 1003
template< class _InputIterator> void _M_insert_equal(_InputIterator __first, _InputIterator __last); 
# 1009
private: void _M_erase_aux(const_iterator __position); 
# 1012
void _M_erase_aux(const_iterator __first, const_iterator __last); 
# 1020
public: 
# 1018
__attribute((__abi_tag__("cxx11"))) iterator 
# 1020
erase(const_iterator __position) 
# 1021
{ 
# 1022
const_iterator __result = __position; 
# 1023
++__result; 
# 1024
_M_erase_aux(__position); 
# 1025
return (__result._M_const_cast()); 
# 1026
} 
# 1029
__attribute((__abi_tag__("cxx11"))) iterator 
# 1031
erase(iterator __position) 
# 1032
{ 
# 1033
iterator __result = __position; 
# 1034
++__result; 
# 1035
_M_erase_aux(__position); 
# 1036
return __result; 
# 1037
} 
# 1048 "/usr/include/c++/5/bits/stl_tree.h" 3
size_type erase(const key_type & __x); 
# 1053
__attribute((__abi_tag__("cxx11"))) iterator 
# 1055
erase(const_iterator __first, const_iterator __last) 
# 1056
{ 
# 1057
_M_erase_aux(__first, __last); 
# 1058
return (__last._M_const_cast()); 
# 1059
} 
# 1070 "/usr/include/c++/5/bits/stl_tree.h" 3
void erase(const key_type * __first, const key_type * __last); 
# 1073
void clear() noexcept 
# 1074
{ 
# 1075
_M_erase(this->_M_begin()); 
# 1076
((_M_impl)._M_reset()); 
# 1077
} 
# 1081
iterator find(const key_type & __k); 
# 1084
const_iterator find(const key_type & __k) const; 
# 1087
size_type count(const key_type & __k) const; 
# 1090
iterator lower_bound(const key_type &__k) 
# 1091
{ return _M_lower_bound(this->_M_begin(), this->_M_end(), __k); } 
# 1094
const_iterator lower_bound(const key_type &__k) const 
# 1095
{ return _M_lower_bound(this->_M_begin(), this->_M_end(), __k); } 
# 1098
iterator upper_bound(const key_type &__k) 
# 1099
{ return _M_upper_bound(this->_M_begin(), this->_M_end(), __k); } 
# 1102
const_iterator upper_bound(const key_type &__k) const 
# 1103
{ return _M_upper_bound(this->_M_begin(), this->_M_end(), __k); } 
# 1106
pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> >  equal_range(const key_type & __k); 
# 1109
pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> >  equal_range(const key_type & __k) const; 
# 1244 "/usr/include/c++/5/bits/stl_tree.h" 3
bool __rb_verify() const; 
# 1248
_Rb_tree &operator=(_Rb_tree &&) noexcept(_Alloc_traits::_S_nothrow_move()); 
# 1250
template< class _Iterator> void _M_assign_unique(_Iterator, _Iterator); 
# 1254
template< class _Iterator> void _M_assign_equal(_Iterator, _Iterator); 
# 1261
private: void _M_move_data(_Rb_tree &, true_type); 
# 1266
void _M_move_data(_Rb_tree &, false_type); 
# 1268
}; 
# 1270
template< class _Key, class _Val, class _KeyOfValue, class 
# 1271
_Compare, class _Alloc> inline bool 
# 1273
operator==(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1274
__y) 
# 1275
{ 
# 1276
return ((__x.size()) == (__y.size())) && std::equal((__x.begin()), (__x.end()), (__y.begin())); 
# 1278
} 
# 1280
template< class _Key, class _Val, class _KeyOfValue, class 
# 1281
_Compare, class _Alloc> inline bool 
# 1283
operator<(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1284
__y) 
# 1285
{ 
# 1286
return std::lexicographical_compare((__x.begin()), (__x.end()), (__y.begin()), (__y.end())); 
# 1288
} 
# 1290
template< class _Key, class _Val, class _KeyOfValue, class 
# 1291
_Compare, class _Alloc> inline bool 
# 1293
operator!=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1294
__y) 
# 1295
{ return !(__x == __y); } 
# 1297
template< class _Key, class _Val, class _KeyOfValue, class 
# 1298
_Compare, class _Alloc> inline bool 
# 1300
operator>(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1301
__y) 
# 1302
{ return __y < __x; } 
# 1304
template< class _Key, class _Val, class _KeyOfValue, class 
# 1305
_Compare, class _Alloc> inline bool 
# 1307
operator<=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1308
__y) 
# 1309
{ return !(__y < __x); } 
# 1311
template< class _Key, class _Val, class _KeyOfValue, class 
# 1312
_Compare, class _Alloc> inline bool 
# 1314
operator>=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1315
__y) 
# 1316
{ return !(__x < __y); } 
# 1318
template< class _Key, class _Val, class _KeyOfValue, class 
# 1319
_Compare, class _Alloc> inline void 
# 1321
swap(_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1322
__y) 
# 1323
{ (__x.swap(__y)); } 
# 1326
template< class _Key, class _Val, class _KeyOfValue, class 
# 1327
_Compare, class _Alloc> 
# 1329
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Rb_tree(_Rb_tree &&__x, _Node_allocator &&__a) : _M_impl(((__x._M_impl)._M_key_compare), std::move(__a)) 
# 1331
{ 
# 1332
using __eq = integral_constant< bool, __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Rb_tree_node< _Val> > ::other> ::_S_always_equal()> ; 
# 1333
if ((__x._M_root()) != nullptr) { 
# 1334
_M_move_data(__x, __eq()); }  
# 1335
} 
# 1337
template< class _Key, class _Val, class _KeyOfValue, class 
# 1338
_Compare, class _Alloc> void 
# 1341
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_move_data(_Rb_tree &__x, true_type) 
# 1342
{ 
# 1343
this->_M_root() = (__x._M_root()); 
# 1344
this->_M_leftmost() = (__x._M_leftmost()); 
# 1345
this->_M_rightmost() = (__x._M_rightmost()); 
# 1346
(this->_M_root()->_M_parent) = this->_M_end(); 
# 1348
(__x._M_root()) = 0; 
# 1349
(__x._M_leftmost()) = (__x._M_end()); 
# 1350
(__x._M_rightmost()) = (__x._M_end()); 
# 1352
((this->_M_impl)._M_node_count) = ((__x._M_impl)._M_node_count); 
# 1353
((__x._M_impl)._M_node_count) = 0; 
# 1354
} 
# 1356
template< class _Key, class _Val, class _KeyOfValue, class 
# 1357
_Compare, class _Alloc> void 
# 1360
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_move_data(_Rb_tree &__x, false_type) 
# 1361
{ 
# 1362
if (this->_M_get_Node_allocator() == (__x._M_get_Node_allocator())) { 
# 1363
_M_move_data(__x, true_type()); } else 
# 1365
{ 
# 1366
_Alloc_node __an(*this); 
# 1367
auto __lbd = [&__an](const value_type &
# 1368
__cval) 
# 1369
{ 
# 1370
auto &__val = const_cast< value_type &>(__cval); 
# 1371
return (__an)(std::move_if_noexcept(__val)); 
# 1372
} ; 
# 1373
this->_M_root() = _M_copy((__x._M_begin()), this->_M_end(), __lbd); 
# 1374
this->_M_leftmost() = _S_minimum(this->_M_root()); 
# 1375
this->_M_rightmost() = _S_maximum(this->_M_root()); 
# 1376
((_M_impl)._M_node_count) = ((__x._M_impl)._M_node_count); 
# 1377
}  
# 1378
} 
# 1380
template< class _Key, class _Val, class _KeyOfValue, class 
# 1381
_Compare, class _Alloc> _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1384
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::operator=(_Rb_tree &&__x) noexcept(_Alloc_traits::_S_nothrow_move()) 
# 1386
{ 
# 1387
((_M_impl)._M_key_compare) = ((__x._M_impl)._M_key_compare); 
# 1388
if ((_Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal()) || (this->_M_get_Node_allocator() == (__x._M_get_Node_allocator()))) 
# 1391
{ 
# 1392
clear(); 
# 1393
if ((__x._M_root()) != nullptr) { 
# 1394
_M_move_data(__x, true_type()); }  
# 1395
std::__alloc_on_move(this->_M_get_Node_allocator(), (__x._M_get_Node_allocator())); 
# 1397
return *this; 
# 1398
}  
# 1402
_Reuse_or_alloc_node __roan(*this); 
# 1403
((_M_impl)._M_reset()); 
# 1404
if ((__x._M_root()) != nullptr) 
# 1405
{ 
# 1406
auto __lbd = [&__roan](const value_type &
# 1407
__cval) 
# 1408
{ 
# 1409
auto &__val = const_cast< value_type &>(__cval); 
# 1410
return (__roan)(std::move_if_noexcept(__val)); 
# 1411
} ; 
# 1412
this->_M_root() = _M_copy((__x._M_begin()), this->_M_end(), __lbd); 
# 1413
this->_M_leftmost() = _S_minimum(this->_M_root()); 
# 1414
this->_M_rightmost() = _S_maximum(this->_M_root()); 
# 1415
((_M_impl)._M_node_count) = ((__x._M_impl)._M_node_count); 
# 1416
(__x.clear()); 
# 1417
}  
# 1418
return *this; 
# 1419
} 
# 1421
template< class _Key, class _Val, class _KeyOfValue, class 
# 1422
_Compare, class _Alloc> 
# 1423
template< class _Iterator> void 
# 1426
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_assign_unique(_Iterator __first, _Iterator __last) 
# 1427
{ 
# 1428
_Reuse_or_alloc_node __roan(*this); 
# 1429
((_M_impl)._M_reset()); 
# 1430
for (; __first != __last; ++__first) { 
# 1431
_M_insert_unique_(this->end(), *__first, __roan); }  
# 1432
} 
# 1434
template< class _Key, class _Val, class _KeyOfValue, class 
# 1435
_Compare, class _Alloc> 
# 1436
template< class _Iterator> void 
# 1439
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_assign_equal(_Iterator __first, _Iterator __last) 
# 1440
{ 
# 1441
_Reuse_or_alloc_node __roan(*this); 
# 1442
((_M_impl)._M_reset()); 
# 1443
for (; __first != __last; ++__first) { 
# 1444
_M_insert_equal_(this->end(), *__first, __roan); }  
# 1445
} 
# 1448
template< class _Key, class _Val, class _KeyOfValue, class 
# 1449
_Compare, class _Alloc> _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1452
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::operator=(const _Rb_tree &__x) 
# 1453
{ 
# 1454
if (this != (&__x)) 
# 1455
{ 
# 1458
if (_Alloc_traits::_S_propagate_on_copy_assign()) 
# 1459
{ 
# 1460
auto &__this_alloc = this->_M_get_Node_allocator(); 
# 1461
auto &__that_alloc = (__x._M_get_Node_allocator()); 
# 1462
if ((!_Alloc_traits::_S_always_equal()) && (__this_alloc != __that_alloc)) 
# 1464
{ 
# 1467
clear(); 
# 1468
std::__alloc_on_copy(__this_alloc, __that_alloc); 
# 1469
}  
# 1470
}  
# 1473
_Reuse_or_alloc_node __roan(*this); 
# 1474
((_M_impl)._M_reset()); 
# 1475
((_M_impl)._M_key_compare) = ((__x._M_impl)._M_key_compare); 
# 1476
if ((__x._M_root()) != 0) 
# 1477
{ 
# 1478
this->_M_root() = _M_copy((__x._M_begin()), this->_M_end(), __roan); 
# 1479
this->_M_leftmost() = _S_minimum(this->_M_root()); 
# 1480
this->_M_rightmost() = _S_maximum(this->_M_root()); 
# 1481
((_M_impl)._M_node_count) = ((__x._M_impl)._M_node_count); 
# 1482
}  
# 1483
}  
# 1485
return *this; 
# 1486
} 
# 1488
template< class _Key, class _Val, class _KeyOfValue, class 
# 1489
_Compare, class _Alloc> 
# 1491
template< class _Arg, class _NodeGen> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1497
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_(_Base_ptr __x, _Base_ptr __p, _Arg &&
# 1499
__v, _NodeGen &
# 1503
__node_gen) 
# 1504
{ 
# 1505
bool __insert_left = ((__x != (0)) || (__p == this->_M_end())) || ((_M_impl)._M_key_compare(_KeyOfValue()(__v), _S_key(__p))); 
# 1509
_Link_type __z = __node_gen(std::forward< _Arg> (__v)); 
# 1511
_Rb_tree_insert_and_rebalance(__insert_left, __z, __p, ((this->_M_impl)._M_header)); 
# 1513
++((_M_impl)._M_node_count); 
# 1514
return ((iterator)(__z)); 
# 1515
} 
# 1517
template< class _Key, class _Val, class _KeyOfValue, class 
# 1518
_Compare, class _Alloc> 
# 1520
template< class _Arg> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1525
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_lower(_Base_ptr __p, _Arg &&__v) 
# 1529
{ 
# 1530
bool __insert_left = (__p == this->_M_end()) || (!((_M_impl)._M_key_compare(_S_key(__p), _KeyOfValue()(__v)))); 
# 1534
_Link_type __z = _M_create_node(std::forward< _Arg> (__v)); 
# 1536
_Rb_tree_insert_and_rebalance(__insert_left, __z, __p, ((this->_M_impl)._M_header)); 
# 1538
++((_M_impl)._M_node_count); 
# 1539
return ((iterator)(__z)); 
# 1540
} 
# 1542
template< class _Key, class _Val, class _KeyOfValue, class 
# 1543
_Compare, class _Alloc> 
# 1545
template< class _Arg> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1550
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal_lower(_Arg &&__v) 
# 1554
{ 
# 1555
_Link_type __x = this->_M_begin(); 
# 1556
_Link_type __y = this->_M_end(); 
# 1557
while (__x != 0) 
# 1558
{ 
# 1559
__y = __x; 
# 1560
__x = ((!((_M_impl)._M_key_compare(_S_key(__x), _KeyOfValue()(__v)))) ? _S_left(__x) : _S_right(__x)); 
# 1562
}  
# 1563
return _M_insert_lower(__y, std::forward< _Arg> (__v)); 
# 1564
} 
# 1566
template< class _Key, class _Val, class _KoV, class 
# 1567
_Compare, class _Alloc> 
# 1568
template< class _NodeGen> typename _Rb_tree< _Key, _Val, _KoV, _Compare, _Alloc> ::_Link_type 
# 1571
_Rb_tree< _Key, _Val, _KoV, _Compare, _Alloc> ::_M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen &__node_gen) 
# 1572
{ 
# 1574
_Link_type __top = _M_clone_node(__x, __node_gen); 
# 1575
(__top->_M_parent) = __p; 
# 1577
try 
# 1578
{ 
# 1579
if (__x->_M_right) { 
# 1580
(__top->_M_right) = _M_copy(_S_right(__x), __top, __node_gen); }  
# 1581
__p = __top; 
# 1582
__x = _S_left(__x); 
# 1584
while (__x != 0) 
# 1585
{ 
# 1586
_Link_type __y = _M_clone_node(__x, __node_gen); 
# 1587
(__p->_M_left) = __y; 
# 1588
(__y->_M_parent) = __p; 
# 1589
if (__x->_M_right) { 
# 1590
(__y->_M_right) = _M_copy(_S_right(__x), __y, __node_gen); }  
# 1591
__p = __y; 
# 1592
__x = _S_left(__x); 
# 1593
}  
# 1594
} 
# 1595
catch (...) 
# 1596
{ 
# 1597
_M_erase(__top); 
# 1598
throw; 
# 1599
}  
# 1600
return __top; 
# 1601
} 
# 1603
template< class _Key, class _Val, class _KeyOfValue, class 
# 1604
_Compare, class _Alloc> void 
# 1607
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_erase(_Link_type __x) 
# 1608
{ 
# 1610
while (__x != 0) 
# 1611
{ 
# 1612
_M_erase(_S_right(__x)); 
# 1613
_Link_type __y = _S_left(__x); 
# 1614
_M_drop_node(__x); 
# 1615
__x = __y; 
# 1616
}  
# 1617
} 
# 1619
template< class _Key, class _Val, class _KeyOfValue, class 
# 1620
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1624
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_lower_bound(_Link_type __x, _Link_type __y, const _Key &
# 1625
__k) 
# 1626
{ 
# 1627
while (__x != 0) { 
# 1628
if (!((_M_impl)._M_key_compare(_S_key(__x), __k))) { 
# 1629
(__y = __x), (__x = _S_left(__x)); } else { 
# 1631
__x = _S_right(__x); }  }  
# 1632
return ((iterator)(__y)); 
# 1633
} 
# 1635
template< class _Key, class _Val, class _KeyOfValue, class 
# 1636
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::const_iterator 
# 1640
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_lower_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key &
# 1641
__k) const 
# 1642
{ 
# 1643
while (__x != 0) { 
# 1644
if (!((_M_impl)._M_key_compare(_S_key(__x), __k))) { 
# 1645
(__y = __x), (__x = _S_left(__x)); } else { 
# 1647
__x = _S_right(__x); }  }  
# 1648
return ((const_iterator)(__y)); 
# 1649
} 
# 1651
template< class _Key, class _Val, class _KeyOfValue, class 
# 1652
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1656
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_upper_bound(_Link_type __x, _Link_type __y, const _Key &
# 1657
__k) 
# 1658
{ 
# 1659
while (__x != 0) { 
# 1660
if (((_M_impl)._M_key_compare(__k, _S_key(__x)))) { 
# 1661
(__y = __x), (__x = _S_left(__x)); } else { 
# 1663
__x = _S_right(__x); }  }  
# 1664
return ((iterator)(__y)); 
# 1665
} 
# 1667
template< class _Key, class _Val, class _KeyOfValue, class 
# 1668
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::const_iterator 
# 1672
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_upper_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key &
# 1673
__k) const 
# 1674
{ 
# 1675
while (__x != 0) { 
# 1676
if (((_M_impl)._M_key_compare(__k, _S_key(__x)))) { 
# 1677
(__y = __x), (__x = _S_left(__x)); } else { 
# 1679
__x = _S_right(__x); }  }  
# 1680
return ((const_iterator)(__y)); 
# 1681
} 
# 1683
template< class _Key, class _Val, class _KeyOfValue, class 
# 1684
_Compare, class _Alloc> pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> >  
# 1690
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::equal_range(const _Key &__k) 
# 1691
{ 
# 1692
_Link_type __x = this->_M_begin(); 
# 1693
_Link_type __y = this->_M_end(); 
# 1694
while (__x != 0) 
# 1695
{ 
# 1696
if (((_M_impl)._M_key_compare(_S_key(__x), __k))) { 
# 1697
__x = _S_right(__x); } else { 
# 1698
if (((_M_impl)._M_key_compare(__k, _S_key(__x)))) { 
# 1699
(__y = __x), (__x = _S_left(__x)); } else 
# 1701
{ 
# 1702
_Link_type __xu(__x), __yu(__y); 
# 1703
(__y = __x), (__x = _S_left(__x)); 
# 1704
__xu = _S_right(__xu); 
# 1705
return pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> > (_M_lower_bound(__x, __y, __k), _M_upper_bound(__xu, __yu, __k)); 
# 1708
}  }  
# 1709
}  
# 1710
return pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> > (((iterator)(__y)), ((iterator)(__y))); 
# 1712
} 
# 1714
template< class _Key, class _Val, class _KeyOfValue, class 
# 1715
_Compare, class _Alloc> pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> >  
# 1721
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::equal_range(const _Key &__k) const 
# 1722
{ 
# 1723
_Const_Link_type __x = this->_M_begin(); 
# 1724
_Const_Link_type __y = this->_M_end(); 
# 1725
while (__x != 0) 
# 1726
{ 
# 1727
if (((_M_impl)._M_key_compare(_S_key(__x), __k))) { 
# 1728
__x = _S_right(__x); } else { 
# 1729
if (((_M_impl)._M_key_compare(__k, _S_key(__x)))) { 
# 1730
(__y = __x), (__x = _S_left(__x)); } else 
# 1732
{ 
# 1733
_Const_Link_type __xu(__x), __yu(__y); 
# 1734
(__y = __x), (__x = _S_left(__x)); 
# 1735
__xu = _S_right(__xu); 
# 1736
return pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> > (_M_lower_bound(__x, __y, __k), _M_upper_bound(__xu, __yu, __k)); 
# 1739
}  }  
# 1740
}  
# 1741
return pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> > (((const_iterator)(__y)), ((const_iterator)(__y))); 
# 1743
} 
# 1745
template< class _Key, class _Val, class _KeyOfValue, class 
# 1746
_Compare, class _Alloc> void 
# 1749
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::swap(_Rb_tree &__t) noexcept(_Alloc_traits::_S_nothrow_swap()) 
# 1753
{ 
# 1754
if (this->_M_root() == (0)) 
# 1755
{ 
# 1756
if ((__t._M_root()) != 0) 
# 1757
{ 
# 1758
this->_M_root() = (__t._M_root()); 
# 1759
this->_M_leftmost() = (__t._M_leftmost()); 
# 1760
this->_M_rightmost() = (__t._M_rightmost()); 
# 1761
(this->_M_root()->_M_parent) = this->_M_end(); 
# 1762
((_M_impl)._M_node_count) = ((__t._M_impl)._M_node_count); 
# 1764
((__t._M_impl)._M_reset()); 
# 1765
}  
# 1766
} else { 
# 1767
if ((__t._M_root()) == 0) 
# 1768
{ 
# 1769
(__t._M_root()) = this->_M_root(); 
# 1770
(__t._M_leftmost()) = this->_M_leftmost(); 
# 1771
(__t._M_rightmost()) = this->_M_rightmost(); 
# 1772
((__t._M_root())->_M_parent) = (__t._M_end()); 
# 1773
((__t._M_impl)._M_node_count) = ((_M_impl)._M_node_count); 
# 1775
((_M_impl)._M_reset()); 
# 1776
} else 
# 1778
{ 
# 1779
std::swap(this->_M_root(), (__t._M_root())); 
# 1780
std::swap(this->_M_leftmost(), (__t._M_leftmost())); 
# 1781
std::swap(this->_M_rightmost(), (__t._M_rightmost())); 
# 1783
(this->_M_root()->_M_parent) = this->_M_end(); 
# 1784
((__t._M_root())->_M_parent) = (__t._M_end()); 
# 1785
std::swap(((this->_M_impl)._M_node_count), ((__t._M_impl)._M_node_count)); 
# 1786
}  }  
# 1788
std::swap(((this->_M_impl)._M_key_compare), ((__t._M_impl)._M_key_compare)); 
# 1790
_Alloc_traits::_S_on_swap(this->_M_get_Node_allocator(), (__t._M_get_Node_allocator())); 
# 1792
} 
# 1794
template< class _Key, class _Val, class _KeyOfValue, class 
# 1795
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 1801
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_unique_pos(const key_type &__k) 
# 1802
{ 
# 1803
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 1804
_Link_type __x = this->_M_begin(); 
# 1805
_Link_type __y = this->_M_end(); 
# 1806
bool __comp = true; 
# 1807
while (__x != 0) 
# 1808
{ 
# 1809
__y = __x; 
# 1810
__comp = ((_M_impl)._M_key_compare(__k, _S_key(__x))); 
# 1811
__x = (__comp ? _S_left(__x) : _S_right(__x)); 
# 1812
}  
# 1813
iterator __j = ((iterator)(__y)); 
# 1814
if (__comp) 
# 1815
{ 
# 1816
if (__j == this->begin()) { 
# 1817
return _Res(__x, __y); } else { 
# 1819
--__j; }  
# 1820
}  
# 1821
if (((_M_impl)._M_key_compare(_S_key((__j._M_node)), __k))) { 
# 1822
return _Res(__x, __y); }  
# 1823
return _Res((__j._M_node), 0); 
# 1824
} 
# 1826
template< class _Key, class _Val, class _KeyOfValue, class 
# 1827
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 1833
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_equal_pos(const key_type &__k) 
# 1834
{ 
# 1835
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 1836
_Link_type __x = this->_M_begin(); 
# 1837
_Link_type __y = this->_M_end(); 
# 1838
while (__x != 0) 
# 1839
{ 
# 1840
__y = __x; 
# 1841
__x = ((((_M_impl)._M_key_compare(__k, _S_key(__x)))) ? _S_left(__x) : _S_right(__x)); 
# 1843
}  
# 1844
return _Res(__x, __y); 
# 1845
} 
# 1847
template< class _Key, class _Val, class _KeyOfValue, class 
# 1848
_Compare, class _Alloc> 
# 1850
template< class _Arg> pair< _Rb_tree_iterator< _Val> , bool>  
# 1856
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_unique(_Arg &&__v) 
# 1860
{ 
# 1861
typedef pair< _Rb_tree_iterator< _Val> , bool>  _Res; 
# 1862
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_unique_pos(_KeyOfValue()(__v)); 
# 1865
if (__res.second) 
# 1866
{ 
# 1867
_Alloc_node __an(*this); 
# 1868
return _Res(_M_insert_(__res.first, __res.second, std::forward< _Arg> (__v), __an), true); 
# 1871
}  
# 1873
return _Res(((iterator)(static_cast< _Link_type>(__res.first))), false); 
# 1874
} 
# 1876
template< class _Key, class _Val, class _KeyOfValue, class 
# 1877
_Compare, class _Alloc> 
# 1879
template< class _Arg> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1884
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal(_Arg &&__v) 
# 1888
{ 
# 1889
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_equal_pos(_KeyOfValue()(__v)); 
# 1891
_Alloc_node __an(*this); 
# 1892
return _M_insert_(__res.first, __res.second, std::forward< _Arg> (__v), __an); 
# 1894
} 
# 1896
template< class _Key, class _Val, class _KeyOfValue, class 
# 1897
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 1903
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_hint_unique_pos(const_iterator __position, const key_type &
# 1904
__k) 
# 1905
{ 
# 1906
iterator __pos = (__position._M_const_cast()); 
# 1907
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 1910
if ((__pos._M_node) == this->_M_end()) 
# 1911
{ 
# 1912
if ((size() > 0) && ((_M_impl)._M_key_compare(_S_key(this->_M_rightmost()), __k))) { 
# 1914
return _Res(0, this->_M_rightmost()); } else { 
# 1916
return _M_get_insert_unique_pos(__k); }  
# 1917
} else { 
# 1918
if (((_M_impl)._M_key_compare(__k, _S_key((__pos._M_node))))) 
# 1919
{ 
# 1921
iterator __before = __pos; 
# 1922
if ((__pos._M_node) == this->_M_leftmost()) { 
# 1923
return _Res(this->_M_leftmost(), this->_M_leftmost()); } else { 
# 1924
if (((_M_impl)._M_key_compare(_S_key(((--__before)._M_node)), __k))) 
# 1925
{ 
# 1926
if (_S_right((__before._M_node)) == 0) { 
# 1927
return _Res(0, (__before._M_node)); } else { 
# 1929
return _Res((__pos._M_node), (__pos._M_node)); }  
# 1930
} else { 
# 1932
return _M_get_insert_unique_pos(__k); }  }  
# 1933
} else { 
# 1934
if (((_M_impl)._M_key_compare(_S_key((__pos._M_node)), __k))) 
# 1935
{ 
# 1937
iterator __after = __pos; 
# 1938
if ((__pos._M_node) == this->_M_rightmost()) { 
# 1939
return _Res(0, this->_M_rightmost()); } else { 
# 1940
if (((_M_impl)._M_key_compare(__k, _S_key(((++__after)._M_node))))) 
# 1941
{ 
# 1942
if (_S_right((__pos._M_node)) == 0) { 
# 1943
return _Res(0, (__pos._M_node)); } else { 
# 1945
return _Res((__after._M_node), (__after._M_node)); }  
# 1946
} else { 
# 1948
return _M_get_insert_unique_pos(__k); }  }  
# 1949
} else { 
# 1952
return _Res((__pos._M_node), 0); }  }  }  
# 1953
} 
# 1955
template< class _Key, class _Val, class _KeyOfValue, class 
# 1956
_Compare, class _Alloc> 
# 1958
template< class _Arg, class _NodeGen> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1964
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_unique_(const_iterator __position, _Arg &&
# 1966
__v, _NodeGen &
# 1970
__node_gen) 
# 1971
{ 
# 1972
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v)); 
# 1975
if (__res.second) { 
# 1976
return _M_insert_(__res.first, __res.second, std::forward< _Arg> (__v), __node_gen); }  
# 1979
return ((iterator)(static_cast< _Link_type>(__res.first))); 
# 1980
} 
# 1982
template< class _Key, class _Val, class _KeyOfValue, class 
# 1983
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 1989
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_hint_equal_pos(const_iterator __position, const key_type &__k) 
# 1990
{ 
# 1991
iterator __pos = (__position._M_const_cast()); 
# 1992
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 1995
if ((__pos._M_node) == this->_M_end()) 
# 1996
{ 
# 1997
if ((size() > 0) && (!((_M_impl)._M_key_compare(__k, _S_key(this->_M_rightmost()))))) { 
# 1999
return _Res(0, this->_M_rightmost()); } else { 
# 2001
return _M_get_insert_equal_pos(__k); }  
# 2002
} else { 
# 2003
if (!((_M_impl)._M_key_compare(_S_key((__pos._M_node)), __k))) 
# 2004
{ 
# 2006
iterator __before = __pos; 
# 2007
if ((__pos._M_node) == this->_M_leftmost()) { 
# 2008
return _Res(this->_M_leftmost(), this->_M_leftmost()); } else { 
# 2009
if (!((_M_impl)._M_key_compare(__k, _S_key(((--__before)._M_node))))) 
# 2010
{ 
# 2011
if (_S_right((__before._M_node)) == 0) { 
# 2012
return _Res(0, (__before._M_node)); } else { 
# 2014
return _Res((__pos._M_node), (__pos._M_node)); }  
# 2015
} else { 
# 2017
return _M_get_insert_equal_pos(__k); }  }  
# 2018
} else 
# 2020
{ 
# 2022
iterator __after = __pos; 
# 2023
if ((__pos._M_node) == this->_M_rightmost()) { 
# 2024
return _Res(0, this->_M_rightmost()); } else { 
# 2025
if (!((_M_impl)._M_key_compare(_S_key(((++__after)._M_node)), __k))) 
# 2026
{ 
# 2027
if (_S_right((__pos._M_node)) == 0) { 
# 2028
return _Res(0, (__pos._M_node)); } else { 
# 2030
return _Res((__after._M_node), (__after._M_node)); }  
# 2031
} else { 
# 2033
return _Res(0, 0); }  }  
# 2034
}  }  
# 2035
} 
# 2037
template< class _Key, class _Val, class _KeyOfValue, class 
# 2038
_Compare, class _Alloc> 
# 2040
template< class _Arg, class _NodeGen> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2046
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal_(const_iterator __position, _Arg &&
# 2048
__v, _NodeGen &
# 2052
__node_gen) 
# 2053
{ 
# 2054
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v)); 
# 2057
if (__res.second) { 
# 2058
return _M_insert_(__res.first, __res.second, std::forward< _Arg> (__v), __node_gen); }  
# 2062
return _M_insert_equal_lower(std::forward< _Arg> (__v)); 
# 2063
} 
# 2066
template< class _Key, class _Val, class _KeyOfValue, class 
# 2067
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2070
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z) 
# 2071
{ 
# 2072
bool __insert_left = ((__x != (0)) || (__p == this->_M_end())) || ((_M_impl)._M_key_compare(_S_key(__z), _S_key(__p))); 
# 2076
_Rb_tree_insert_and_rebalance(__insert_left, __z, __p, ((this->_M_impl)._M_header)); 
# 2078
++((_M_impl)._M_node_count); 
# 2079
return ((iterator)(__z)); 
# 2080
} 
# 2082
template< class _Key, class _Val, class _KeyOfValue, class 
# 2083
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2086
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_lower_node(_Base_ptr __p, _Link_type __z) 
# 2087
{ 
# 2088
bool __insert_left = (__p == this->_M_end()) || (!((_M_impl)._M_key_compare(_S_key(__p), _S_key(__z)))); 
# 2092
_Rb_tree_insert_and_rebalance(__insert_left, __z, __p, ((this->_M_impl)._M_header)); 
# 2094
++((_M_impl)._M_node_count); 
# 2095
return ((iterator)(__z)); 
# 2096
} 
# 2098
template< class _Key, class _Val, class _KeyOfValue, class 
# 2099
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2102
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal_lower_node(_Link_type __z) 
# 2103
{ 
# 2104
_Link_type __x = this->_M_begin(); 
# 2105
_Link_type __y = this->_M_end(); 
# 2106
while (__x != 0) 
# 2107
{ 
# 2108
__y = __x; 
# 2109
__x = ((!((_M_impl)._M_key_compare(_S_key(__x), _S_key(__z)))) ? _S_left(__x) : _S_right(__x)); 
# 2111
}  
# 2112
return _M_insert_lower_node(__y, __z); 
# 2113
} 
# 2115
template< class _Key, class _Val, class _KeyOfValue, class 
# 2116
_Compare, class _Alloc> 
# 2117
template< class ..._Args> pair< _Rb_tree_iterator< _Val> , bool>  
# 2121
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_emplace_unique(_Args &&...__args) 
# 2122
{ 
# 2123
_Link_type __z = _M_create_node(std::forward< _Args> (__args)...); 
# 2125
try 
# 2126
{ 
# 2127
typedef pair< _Rb_tree_iterator< _Val> , bool>  _Res; 
# 2128
auto __res = _M_get_insert_unique_pos(_S_key(__z)); 
# 2129
if (__res.second) { 
# 2130
return _Res(_M_insert_node((__res.first), (__res.second), __z), true); }  
# 2132
_M_drop_node(__z); 
# 2133
return _Res(((iterator)(static_cast< _Link_type>(__res.first))), false); 
# 2134
} 
# 2135
catch (...) 
# 2136
{ 
# 2137
_M_drop_node(__z); 
# 2138
throw; 
# 2139
}  
# 2140
} 
# 2142
template< class _Key, class _Val, class _KeyOfValue, class 
# 2143
_Compare, class _Alloc> 
# 2144
template< class ..._Args> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2147
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_emplace_equal(_Args &&...__args) 
# 2148
{ 
# 2149
_Link_type __z = _M_create_node(std::forward< _Args> (__args)...); 
# 2151
try 
# 2152
{ 
# 2153
auto __res = _M_get_insert_equal_pos(_S_key(__z)); 
# 2154
return _M_insert_node((__res.first), (__res.second), __z); 
# 2155
} 
# 2156
catch (...) 
# 2157
{ 
# 2158
_M_drop_node(__z); 
# 2159
throw; 
# 2160
}  
# 2161
} 
# 2163
template< class _Key, class _Val, class _KeyOfValue, class 
# 2164
_Compare, class _Alloc> 
# 2165
template< class ..._Args> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2168
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_emplace_hint_unique(const_iterator __pos, _Args &&...__args) 
# 2169
{ 
# 2170
_Link_type __z = _M_create_node(std::forward< _Args> (__args)...); 
# 2172
try 
# 2173
{ 
# 2174
auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z)); 
# 2176
if (__res.second) { 
# 2177
return _M_insert_node((__res.first), (__res.second), __z); }  
# 2179
_M_drop_node(__z); 
# 2180
return ((iterator)(static_cast< _Link_type>(__res.first))); 
# 2181
} 
# 2182
catch (...) 
# 2183
{ 
# 2184
_M_drop_node(__z); 
# 2185
throw; 
# 2186
}  
# 2187
} 
# 2189
template< class _Key, class _Val, class _KeyOfValue, class 
# 2190
_Compare, class _Alloc> 
# 2191
template< class ..._Args> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2194
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_emplace_hint_equal(const_iterator __pos, _Args &&...__args) 
# 2195
{ 
# 2196
_Link_type __z = _M_create_node(std::forward< _Args> (__args)...); 
# 2198
try 
# 2199
{ 
# 2200
auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z)); 
# 2202
if (__res.second) { 
# 2203
return _M_insert_node((__res.first), (__res.second), __z); }  
# 2205
return _M_insert_equal_lower_node(__z); 
# 2206
} 
# 2207
catch (...) 
# 2208
{ 
# 2209
_M_drop_node(__z); 
# 2210
throw; 
# 2211
}  
# 2212
} 
# 2215
template< class _Key, class _Val, class _KoV, class 
# 2216
_Cmp, class _Alloc> 
# 2217
template< class _II> void 
# 2220
_Rb_tree< _Key, _Val, _KoV, _Cmp, _Alloc> ::_M_insert_unique(_II __first, _II __last) 
# 2221
{ 
# 2222
_Alloc_node __an(*this); 
# 2223
for (; __first != __last; ++__first) { 
# 2224
_M_insert_unique_(this->end(), *__first, __an); }  
# 2225
} 
# 2227
template< class _Key, class _Val, class _KoV, class 
# 2228
_Cmp, class _Alloc> 
# 2229
template< class _II> void 
# 2232
_Rb_tree< _Key, _Val, _KoV, _Cmp, _Alloc> ::_M_insert_equal(_II __first, _II __last) 
# 2233
{ 
# 2234
_Alloc_node __an(*this); 
# 2235
for (; __first != __last; ++__first) { 
# 2236
_M_insert_equal_(this->end(), *__first, __an); }  
# 2237
} 
# 2239
template< class _Key, class _Val, class _KeyOfValue, class 
# 2240
_Compare, class _Alloc> void 
# 2243
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_erase_aux(const_iterator __position) 
# 2244
{ 
# 2245
_Link_type __y = static_cast< _Link_type>(_Rb_tree_rebalance_for_erase(const_cast< _Base_ptr>(__position._M_node), ((this->_M_impl)._M_header))); 
# 2249
_M_drop_node(__y); 
# 2250
--((_M_impl)._M_node_count); 
# 2251
} 
# 2253
template< class _Key, class _Val, class _KeyOfValue, class 
# 2254
_Compare, class _Alloc> void 
# 2257
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_erase_aux(const_iterator __first, const_iterator __last) 
# 2258
{ 
# 2259
if ((__first == this->begin()) && (__last == this->end())) { 
# 2260
clear(); } else { 
# 2262
while (__first != __last) { 
# 2263
erase(__first++); }  }  
# 2264
} 
# 2266
template< class _Key, class _Val, class _KeyOfValue, class 
# 2267
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::size_type 
# 2270
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::erase(const _Key &__x) 
# 2271
{ 
# 2272
pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> >  __p = equal_range(__x); 
# 2273
const size_type __old_size = size(); 
# 2274
erase((__p.first), (__p.second)); 
# 2275
return __old_size - size(); 
# 2276
} 
# 2278
template< class _Key, class _Val, class _KeyOfValue, class 
# 2279
_Compare, class _Alloc> void 
# 2282
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::erase(const _Key *__first, const _Key *__last) 
# 2283
{ 
# 2284
while (__first != __last) { 
# 2285
erase(*(__first++)); }  
# 2286
} 
# 2288
template< class _Key, class _Val, class _KeyOfValue, class 
# 2289
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2293
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::find(const _Key &__k) 
# 2294
{ 
# 2295
iterator __j = _M_lower_bound(this->_M_begin(), this->_M_end(), __k); 
# 2296
return ((__j == this->end()) || ((_M_impl)._M_key_compare(__k, _S_key((__j._M_node))))) ? this->end() : __j; 
# 2299
} 
# 2301
template< class _Key, class _Val, class _KeyOfValue, class 
# 2302
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::const_iterator 
# 2306
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::find(const _Key &__k) const 
# 2307
{ 
# 2308
const_iterator __j = _M_lower_bound(this->_M_begin(), this->_M_end(), __k); 
# 2309
return ((__j == this->end()) || ((_M_impl)._M_key_compare(__k, _S_key((__j._M_node))))) ? this->end() : __j; 
# 2312
} 
# 2314
template< class _Key, class _Val, class _KeyOfValue, class 
# 2315
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::size_type 
# 2318
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::count(const _Key &__k) const 
# 2319
{ 
# 2320
pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> >  __p = equal_range(__k); 
# 2321
const size_type __n = std::distance((__p.first), (__p.second)); 
# 2322
return __n; 
# 2323
} 
# 2325
__attribute((__pure__)) unsigned 
# 2326
_Rb_tree_black_count(const _Rb_tree_node_base * __node, const _Rb_tree_node_base * __root) throw(); 
# 2329
template< class _Key, class _Val, class _KeyOfValue, class 
# 2330
_Compare, class _Alloc> bool 
# 2332
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::__rb_verify() const 
# 2333
{ 
# 2334
if ((((_M_impl)._M_node_count) == 0) || (this->begin() == this->end())) { 
# 2335
return (((_M_impl)._M_node_count) == 0) && (this->begin() == this->end()) && ((((this->_M_impl)._M_header)._M_left) == this->_M_end()) && ((((this->_M_impl)._M_header)._M_right) == this->_M_end()); }  
# 2339
unsigned __len = _Rb_tree_black_count(this->_M_leftmost(), this->_M_root()); 
# 2340
for (const_iterator __it = this->begin(); __it != this->end(); ++__it) 
# 2341
{ 
# 2342
_Const_Link_type __x = static_cast< _Const_Link_type>(__it._M_node); 
# 2343
_Const_Link_type __L = _S_left(__x); 
# 2344
_Const_Link_type __R = _S_right(__x); 
# 2346
if ((__x->_M_color) == _S_red) { 
# 2347
if ((__L && ((__L->_M_color) == _S_red)) || (__R && ((__R->_M_color) == _S_red))) { 
# 2349
return false; }  }  
# 2351
if (__L && ((_M_impl)._M_key_compare(_S_key(__x), _S_key(__L)))) { 
# 2352
return false; }  
# 2353
if (__R && ((_M_impl)._M_key_compare(_S_key(__R), _S_key(__x)))) { 
# 2354
return false; }  
# 2356
if ((!__L) && (!__R) && (_Rb_tree_black_count(__x, this->_M_root()) != __len)) { 
# 2357
return false; }  
# 2358
}  
# 2360
if (this->_M_leftmost() != _Rb_tree_node_base::_S_minimum(this->_M_root())) { 
# 2361
return false; }  
# 2362
if (this->_M_rightmost() != _Rb_tree_node_base::_S_maximum(this->_M_root())) { 
# 2363
return false; }  
# 2364
return true; 
# 2365
} 
# 2368
}
# 66 "/usr/include/c++/5/bits/stl_map.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 94 "/usr/include/c++/5/bits/stl_map.h" 3
template< class _Key, class _Tp, class _Compare = less< _Key> , class 
# 95
_Alloc = allocator< pair< const _Key, _Tp> > > 
# 96
class map { 
# 99
public: typedef _Key key_type; 
# 100
typedef _Tp mapped_type; 
# 101
typedef pair< const _Key, _Tp>  value_type; 
# 102
typedef _Compare key_compare; 
# 103
typedef _Alloc allocator_type; 
# 107
private: typedef typename _Alloc::value_type _Alloc_value_type; 
# 114
public: class value_compare : public binary_function< pair< const _Key, _Tp> , pair< const _Key, _Tp> , bool>  { 
# 117
friend class map; 
# 119
protected: _Compare comp; 
# 121
value_compare(_Compare __c) : comp(__c) 
# 122
{ } 
# 125
public: bool operator()(const typename ::std::map< _Key, _Tp, _Compare, _Alloc> ::value_type &__x, const typename ::std::map< _Key, _Tp, _Compare, _Alloc> ::value_type &__y) const 
# 126
{ return (comp)((__x.first), (__y.first)); } 
# 127
}; 
# 132
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other _Pair_alloc_type; 
# 135
typedef _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other>  _Rep_type; 
# 138
_Rep_type _M_t; 
# 140
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other>  _Alloc_traits; 
# 145
public: typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::pointer pointer; 
# 146
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_pointer const_pointer; 
# 147
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::reference reference; 
# 148
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_reference const_reference; 
# 149
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator iterator; 
# 150
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator const_iterator; 
# 151
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::size_type size_type; 
# 152
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::difference_type difference_type; 
# 153
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::reverse_iterator reverse_iterator; 
# 154
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_reverse_iterator const_reverse_iterator; 
# 162
map() noexcept(is_nothrow_default_constructible< _Alloc> ::value) : _M_t() 
# 166
{ } 
# 174
explicit map(const _Compare &__comp, const allocator_type &
# 175
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 176
{ } 
# 185 "/usr/include/c++/5/bits/stl_map.h" 3
map(const map &__x) : _M_t((__x._M_t)) 
# 186
{ } 
# 196 "/usr/include/c++/5/bits/stl_map.h" 3
map(map &&__x) noexcept(is_nothrow_copy_constructible< _Compare> ::value) : _M_t(std::move((__x._M_t))) 
# 198
{ } 
# 211 "/usr/include/c++/5/bits/stl_map.h" 3
map(initializer_list< pair< const _Key, _Tp> >  __l, const _Compare &
# 212
__comp = _Compare(), const allocator_type &
# 213
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 215
{ ((_M_t)._M_insert_unique((__l.begin()), (__l.end()))); } 
# 219
explicit map(const allocator_type &__a) : _M_t(_Compare(), (_Pair_alloc_type)__a) 
# 220
{ } 
# 223
map(const map &__m, const allocator_type &__a) : _M_t((__m._M_t), (_Pair_alloc_type)__a) 
# 224
{ } 
# 227
map(map &&__m, const allocator_type &__a) noexcept(is_nothrow_copy_constructible< _Compare> ::value && _Alloc_traits::_S_always_equal()) : _M_t(std::move((__m._M_t)), (_Pair_alloc_type)__a) 
# 230
{ } 
# 233
map(initializer_list< pair< const _Key, _Tp> >  __l, const allocator_type &__a) : _M_t(_Compare(), (_Pair_alloc_type)__a) 
# 235
{ ((_M_t)._M_insert_unique((__l.begin()), (__l.end()))); } 
# 238
template< class _InputIterator> 
# 239
map(_InputIterator __first, _InputIterator __last, const allocator_type &
# 240
__a) : _M_t(_Compare(), (_Pair_alloc_type)__a) 
# 242
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 255 "/usr/include/c++/5/bits/stl_map.h" 3
template< class _InputIterator> 
# 256
map(_InputIterator __first, _InputIterator __last) : _M_t() 
# 258
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 272 "/usr/include/c++/5/bits/stl_map.h" 3
template< class _InputIterator> 
# 273
map(_InputIterator __first, _InputIterator __last, const _Compare &
# 274
__comp, const allocator_type &
# 275
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 277
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 296 "/usr/include/c++/5/bits/stl_map.h" 3
map &operator=(const map &__x) 
# 297
{ 
# 298
(_M_t) = (__x._M_t); 
# 299
return *this; 
# 300
} 
# 305
map &operator=(map &&) = default;
# 319 "/usr/include/c++/5/bits/stl_map.h" 3
map &operator=(initializer_list< pair< const _Key, _Tp> >  __l) 
# 320
{ 
# 321
((_M_t)._M_assign_unique((__l.begin()), (__l.end()))); 
# 322
return *this; 
# 323
} 
# 328
allocator_type get_allocator() const noexcept 
# 329
{ return (allocator_type)((_M_t).get_allocator()); } 
# 338
iterator begin() noexcept 
# 339
{ return ((_M_t).begin()); } 
# 347
const_iterator begin() const noexcept 
# 348
{ return ((_M_t).begin()); } 
# 356
iterator end() noexcept 
# 357
{ return ((_M_t).end()); } 
# 365
const_iterator end() const noexcept 
# 366
{ return ((_M_t).end()); } 
# 374
reverse_iterator rbegin() noexcept 
# 375
{ return ((_M_t).rbegin()); } 
# 383
const_reverse_iterator rbegin() const noexcept 
# 384
{ return ((_M_t).rbegin()); } 
# 392
reverse_iterator rend() noexcept 
# 393
{ return ((_M_t).rend()); } 
# 401
const_reverse_iterator rend() const noexcept 
# 402
{ return ((_M_t).rend()); } 
# 411
const_iterator cbegin() const noexcept 
# 412
{ return ((_M_t).begin()); } 
# 420
const_iterator cend() const noexcept 
# 421
{ return ((_M_t).end()); } 
# 429
const_reverse_iterator crbegin() const noexcept 
# 430
{ return ((_M_t).rbegin()); } 
# 438
const_reverse_iterator crend() const noexcept 
# 439
{ return ((_M_t).rend()); } 
# 447
bool empty() const noexcept 
# 448
{ return ((_M_t).empty()); } 
# 452
size_type size() const noexcept 
# 453
{ return ((_M_t).size()); } 
# 457
size_type max_size() const noexcept 
# 458
{ return ((_M_t).max_size()); } 
# 474 "/usr/include/c++/5/bits/stl_map.h" 3
mapped_type &operator[](const key_type &__k) 
# 475
{ 
# 479
iterator __i = lower_bound(__k); 
# 481
if ((__i == this->end()) || key_comp()(__k, ((*__i).first))) { 
# 483
__i = ((_M_t)._M_emplace_hint_unique(__i, std::piecewise_construct, ((tuple< const _Key &> )(__k)), tuple< > ())); }  
# 489
return (*__i).second; 
# 490
} 
# 494
mapped_type &operator[](key_type &&__k) 
# 495
{ 
# 499
iterator __i = lower_bound(__k); 
# 501
if ((__i == this->end()) || key_comp()(__k, ((*__i).first))) { 
# 502
__i = ((_M_t)._M_emplace_hint_unique(__i, std::piecewise_construct, std::forward_as_tuple(std::move(__k)), tuple< > ())); }  
# 505
return (*__i).second; 
# 506
} 
# 519 "/usr/include/c++/5/bits/stl_map.h" 3
mapped_type &at(const key_type &__k) 
# 520
{ 
# 521
iterator __i = lower_bound(__k); 
# 522
if ((__i == this->end()) || key_comp()(__k, ((*__i).first))) { 
# 523
__throw_out_of_range("map::at"); }  
# 524
return (*__i).second; 
# 525
} 
# 528
const mapped_type &at(const key_type &__k) const 
# 529
{ 
# 530
const_iterator __i = lower_bound(__k); 
# 531
if ((__i == this->end()) || key_comp()(__k, ((*__i).first))) { 
# 532
__throw_out_of_range("map::at"); }  
# 533
return (*__i).second; 
# 534
} 
# 556 "/usr/include/c++/5/bits/stl_map.h" 3
template< class ..._Args> pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator, bool>  
# 558
emplace(_Args &&...__args) 
# 559
{ return ((_M_t)._M_emplace_unique(std::forward< _Args> (__args)...)); } 
# 586 "/usr/include/c++/5/bits/stl_map.h" 3
template< class ..._Args> iterator 
# 588
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 589
{ 
# 590
return ((_M_t)._M_emplace_hint_unique(__pos, std::forward< _Args> (__args)...)); 
# 592
} 
# 612 "/usr/include/c++/5/bits/stl_map.h" 3
pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator, bool>  insert(const value_type &__x) 
# 613
{ return ((_M_t)._M_insert_unique(__x)); } 
# 616
template< class _Pair, class  = typename enable_if< is_constructible< pair< const _Key, _Tp> , _Pair &&> ::value> ::type> pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator, bool>  
# 620
insert(_Pair &&__x) 
# 621
{ return ((_M_t)._M_insert_unique(std::forward< _Pair> (__x))); } 
# 633 "/usr/include/c++/5/bits/stl_map.h" 3
void insert(initializer_list< pair< const _Key, _Tp> >  __list) 
# 634
{ insert((__list.begin()), (__list.end())); } 
# 662 "/usr/include/c++/5/bits/stl_map.h" 3
iterator insert(const_iterator __position, const value_type &__x) 
# 666
{ return ((_M_t)._M_insert_unique_(__position, __x)); } 
# 669
template< class _Pair, class  = typename enable_if< is_constructible< pair< const _Key, _Tp> , _Pair &&> ::value> ::type> iterator 
# 673
insert(const_iterator __position, _Pair &&__x) 
# 674
{ return ((_M_t)._M_insert_unique_(__position, std::forward< _Pair> (__x))); 
# 675
} 
# 686 "/usr/include/c++/5/bits/stl_map.h" 3
template< class _InputIterator> void 
# 688
insert(_InputIterator __first, _InputIterator __last) 
# 689
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 708 "/usr/include/c++/5/bits/stl_map.h" 3
iterator erase(const_iterator __position) 
# 709
{ return ((_M_t).erase(__position)); } 
# 712
__attribute((__abi_tag__("cxx11"))) iterator 
# 714
erase(iterator __position) 
# 715
{ return ((_M_t).erase(__position)); } 
# 744 "/usr/include/c++/5/bits/stl_map.h" 3
size_type erase(const key_type &__x) 
# 745
{ return ((_M_t).erase(__x)); } 
# 764 "/usr/include/c++/5/bits/stl_map.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 765
{ return ((_M_t).erase(__first, __last)); } 
# 796 "/usr/include/c++/5/bits/stl_map.h" 3
void swap(map &__x) noexcept(_Alloc_traits::_S_nothrow_swap()) 
# 800
{ ((_M_t).swap((__x._M_t))); } 
# 809
void clear() noexcept 
# 810
{ ((_M_t).clear()); } 
# 818
key_compare key_comp() const 
# 819
{ return ((_M_t).key_comp()); } 
# 826
value_compare value_comp() const 
# 827
{ return (value_compare)((_M_t).key_comp()); } 
# 845 "/usr/include/c++/5/bits/stl_map.h" 3
iterator find(const key_type &__x) 
# 846
{ return ((_M_t).find(__x)); } 
# 870 "/usr/include/c++/5/bits/stl_map.h" 3
const_iterator find(const key_type &__x) const 
# 871
{ return ((_M_t).find(__x)); } 
# 891 "/usr/include/c++/5/bits/stl_map.h" 3
size_type count(const key_type &__x) const 
# 892
{ return (((_M_t).find(__x)) == ((_M_t).end())) ? 0 : 1; } 
# 915 "/usr/include/c++/5/bits/stl_map.h" 3
iterator lower_bound(const key_type &__x) 
# 916
{ return ((_M_t).lower_bound(__x)); } 
# 940 "/usr/include/c++/5/bits/stl_map.h" 3
const_iterator lower_bound(const key_type &__x) const 
# 941
{ return ((_M_t).lower_bound(__x)); } 
# 960 "/usr/include/c++/5/bits/stl_map.h" 3
iterator upper_bound(const key_type &__x) 
# 961
{ return ((_M_t).upper_bound(__x)); } 
# 980 "/usr/include/c++/5/bits/stl_map.h" 3
const_iterator upper_bound(const key_type &__x) const 
# 981
{ return ((_M_t).upper_bound(__x)); } 
# 1009 "/usr/include/c++/5/bits/stl_map.h" 3
pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator, typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator>  equal_range(const key_type &__x) 
# 1010
{ return ((_M_t).equal_range(__x)); } 
# 1038 "/usr/include/c++/5/bits/stl_map.h" 3
pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator, typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator>  equal_range(const key_type &__x) const 
# 1039
{ return ((_M_t).equal_range(__x)); } 
# 1050 "/usr/include/c++/5/bits/stl_map.h" 3
template< class _K1, class _T1, class _C1, class _A1> friend bool operator==(const std::map< _K1, _T1, _C1, _A1>  &, const std::map< _K1, _T1, _C1, _A1>  &); 
# 1055
template< class _K1, class _T1, class _C1, class _A1> friend bool operator<(const std::map< _K1, _T1, _C1, _A1>  &, const std::map< _K1, _T1, _C1, _A1>  &); 
# 1059
}; 
# 1071 "/usr/include/c++/5/bits/stl_map.h" 3
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1073
operator==(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1074
__y) 
# 1075
{ return (__x._M_t) == (__y._M_t); } 
# 1088 "/usr/include/c++/5/bits/stl_map.h" 3
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1090
operator<(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1091
__y) 
# 1092
{ return (__x._M_t) < (__y._M_t); } 
# 1095
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1097
operator!=(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1098
__y) 
# 1099
{ return !(__x == __y); } 
# 1102
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1104
operator>(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1105
__y) 
# 1106
{ return __y < __x; } 
# 1109
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1111
operator<=(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1112
__y) 
# 1113
{ return !(__y < __x); } 
# 1116
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1118
operator>=(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1119
__y) 
# 1120
{ return !(__x < __y); } 
# 1123
template< class _Key, class _Tp, class _Compare, class _Alloc> inline void 
# 1125
swap(map< _Key, _Tp, _Compare, _Alloc>  &__x, map< _Key, _Tp, _Compare, _Alloc>  &
# 1126
__y) 
# 1127
{ (__x.swap(__y)); } 
# 1130
}
# 64 "/usr/include/c++/5/bits/stl_multimap.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 92 "/usr/include/c++/5/bits/stl_multimap.h" 3
template< class _Key, class _Tp, class 
# 93
_Compare = less< _Key> , class 
# 94
_Alloc = allocator< pair< const _Key, _Tp> > > 
# 95
class multimap { 
# 98
public: typedef _Key key_type; 
# 99
typedef _Tp mapped_type; 
# 100
typedef pair< const _Key, _Tp>  value_type; 
# 101
typedef _Compare key_compare; 
# 102
typedef _Alloc allocator_type; 
# 106
private: typedef typename _Alloc::value_type _Alloc_value_type; 
# 113
public: class value_compare : public binary_function< pair< const _Key, _Tp> , pair< const _Key, _Tp> , bool>  { 
# 116
friend class multimap; 
# 118
protected: _Compare comp; 
# 120
value_compare(_Compare __c) : comp(__c) 
# 121
{ } 
# 124
public: bool operator()(const typename ::std::multimap< _Key, _Tp, _Compare, _Alloc> ::value_type &__x, const typename ::std::multimap< _Key, _Tp, _Compare, _Alloc> ::value_type &__y) const 
# 125
{ return (comp)((__x.first), (__y.first)); } 
# 126
}; 
# 131
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other _Pair_alloc_type; 
# 134
typedef _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other>  _Rep_type; 
# 136
_Rep_type _M_t; 
# 138
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other>  _Alloc_traits; 
# 143
public: typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::pointer pointer; 
# 144
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_pointer const_pointer; 
# 145
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::reference reference; 
# 146
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_reference const_reference; 
# 147
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator iterator; 
# 148
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator const_iterator; 
# 149
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::size_type size_type; 
# 150
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::difference_type difference_type; 
# 151
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::reverse_iterator reverse_iterator; 
# 152
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_reverse_iterator const_reverse_iterator; 
# 160
multimap() noexcept(is_nothrow_default_constructible< _Alloc> ::value) : _M_t() 
# 164
{ } 
# 172
explicit multimap(const _Compare &__comp, const allocator_type &
# 173
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 174
{ } 
# 183 "/usr/include/c++/5/bits/stl_multimap.h" 3
multimap(const multimap &__x) : _M_t((__x._M_t)) 
# 184
{ } 
# 194 "/usr/include/c++/5/bits/stl_multimap.h" 3
multimap(multimap &&__x) noexcept(is_nothrow_copy_constructible< _Compare> ::value) : _M_t(std::move((__x._M_t))) 
# 196
{ } 
# 208 "/usr/include/c++/5/bits/stl_multimap.h" 3
multimap(initializer_list< pair< const _Key, _Tp> >  __l, const _Compare &
# 209
__comp = _Compare(), const allocator_type &
# 210
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 212
{ ((_M_t)._M_insert_equal((__l.begin()), (__l.end()))); } 
# 216
explicit multimap(const allocator_type &__a) : _M_t(_Compare(), (_Pair_alloc_type)__a) 
# 217
{ } 
# 220
multimap(const multimap &__m, const allocator_type &__a) : _M_t((__m._M_t), (_Pair_alloc_type)__a) 
# 221
{ } 
# 224
multimap(multimap &&__m, const allocator_type &__a) noexcept(is_nothrow_copy_constructible< _Compare> ::value && _Alloc_traits::_S_always_equal()) : _M_t(std::move((__m._M_t)), (_Pair_alloc_type)__a) 
# 227
{ } 
# 230
multimap(initializer_list< pair< const _Key, _Tp> >  __l, const allocator_type &__a) : _M_t(_Compare(), (_Pair_alloc_type)__a) 
# 232
{ ((_M_t)._M_insert_equal((__l.begin()), (__l.end()))); } 
# 235
template< class _InputIterator> 
# 236
multimap(_InputIterator __first, _InputIterator __last, const allocator_type &
# 237
__a) : _M_t(_Compare(), (_Pair_alloc_type)__a) 
# 239
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 251 "/usr/include/c++/5/bits/stl_multimap.h" 3
template< class _InputIterator> 
# 252
multimap(_InputIterator __first, _InputIterator __last) : _M_t() 
# 254
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 267 "/usr/include/c++/5/bits/stl_multimap.h" 3
template< class _InputIterator> 
# 268
multimap(_InputIterator __first, _InputIterator __last, const _Compare &
# 269
__comp, const allocator_type &
# 270
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 272
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 291 "/usr/include/c++/5/bits/stl_multimap.h" 3
multimap &operator=(const multimap &__x) 
# 292
{ 
# 293
(_M_t) = (__x._M_t); 
# 294
return *this; 
# 295
} 
# 300
multimap &operator=(multimap &&) = default;
# 314 "/usr/include/c++/5/bits/stl_multimap.h" 3
multimap &operator=(initializer_list< pair< const _Key, _Tp> >  __l) 
# 315
{ 
# 316
((_M_t)._M_assign_equal((__l.begin()), (__l.end()))); 
# 317
return *this; 
# 318
} 
# 323
allocator_type get_allocator() const noexcept 
# 324
{ return (allocator_type)((_M_t).get_allocator()); } 
# 333
iterator begin() noexcept 
# 334
{ return ((_M_t).begin()); } 
# 342
const_iterator begin() const noexcept 
# 343
{ return ((_M_t).begin()); } 
# 351
iterator end() noexcept 
# 352
{ return ((_M_t).end()); } 
# 360
const_iterator end() const noexcept 
# 361
{ return ((_M_t).end()); } 
# 369
reverse_iterator rbegin() noexcept 
# 370
{ return ((_M_t).rbegin()); } 
# 378
const_reverse_iterator rbegin() const noexcept 
# 379
{ return ((_M_t).rbegin()); } 
# 387
reverse_iterator rend() noexcept 
# 388
{ return ((_M_t).rend()); } 
# 396
const_reverse_iterator rend() const noexcept 
# 397
{ return ((_M_t).rend()); } 
# 406
const_iterator cbegin() const noexcept 
# 407
{ return ((_M_t).begin()); } 
# 415
const_iterator cend() const noexcept 
# 416
{ return ((_M_t).end()); } 
# 424
const_reverse_iterator crbegin() const noexcept 
# 425
{ return ((_M_t).rbegin()); } 
# 433
const_reverse_iterator crend() const noexcept 
# 434
{ return ((_M_t).rend()); } 
# 440
bool empty() const noexcept 
# 441
{ return ((_M_t).empty()); } 
# 445
size_type size() const noexcept 
# 446
{ return ((_M_t).size()); } 
# 450
size_type max_size() const noexcept 
# 451
{ return ((_M_t).max_size()); } 
# 471 "/usr/include/c++/5/bits/stl_multimap.h" 3
template< class ..._Args> iterator 
# 473
emplace(_Args &&...__args) 
# 474
{ return ((_M_t)._M_emplace_equal(std::forward< _Args> (__args)...)); } 
# 498 "/usr/include/c++/5/bits/stl_multimap.h" 3
template< class ..._Args> iterator 
# 500
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 501
{ 
# 502
return ((_M_t)._M_emplace_hint_equal(__pos, std::forward< _Args> (__args)...)); 
# 504
} 
# 520 "/usr/include/c++/5/bits/stl_multimap.h" 3
iterator insert(const value_type &__x) 
# 521
{ return ((_M_t)._M_insert_equal(__x)); } 
# 524
template< class _Pair, class  = typename enable_if< is_constructible< pair< const _Key, _Tp> , _Pair &&> ::value> ::type> iterator 
# 528
insert(_Pair &&__x) 
# 529
{ return ((_M_t)._M_insert_equal(std::forward< _Pair> (__x))); } 
# 554 "/usr/include/c++/5/bits/stl_multimap.h" 3
iterator insert(const_iterator __position, const value_type &__x) 
# 558
{ return ((_M_t)._M_insert_equal_(__position, __x)); } 
# 561
template< class _Pair, class  = typename enable_if< is_constructible< pair< const _Key, _Tp> , _Pair &&> ::value> ::type> iterator 
# 565
insert(const_iterator __position, _Pair &&__x) 
# 566
{ return ((_M_t)._M_insert_equal_(__position, std::forward< _Pair> (__x))); 
# 567
} 
# 579 "/usr/include/c++/5/bits/stl_multimap.h" 3
template< class _InputIterator> void 
# 581
insert(_InputIterator __first, _InputIterator __last) 
# 582
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 593 "/usr/include/c++/5/bits/stl_multimap.h" 3
void insert(initializer_list< pair< const _Key, _Tp> >  __l) 
# 594
{ (this->insert((__l.begin()), (__l.end()))); } 
# 614 "/usr/include/c++/5/bits/stl_multimap.h" 3
iterator erase(const_iterator __position) 
# 615
{ return ((_M_t).erase(__position)); } 
# 618
__attribute((__abi_tag__("cxx11"))) iterator 
# 620
erase(iterator __position) 
# 621
{ return ((_M_t).erase(__position)); } 
# 650 "/usr/include/c++/5/bits/stl_multimap.h" 3
size_type erase(const key_type &__x) 
# 651
{ return ((_M_t).erase(__x)); } 
# 671 "/usr/include/c++/5/bits/stl_multimap.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 672
{ return ((_M_t).erase(__first, __last)); } 
# 706 "/usr/include/c++/5/bits/stl_multimap.h" 3
void swap(multimap &__x) noexcept(_Alloc_traits::_S_nothrow_swap()) 
# 710
{ ((_M_t).swap((__x._M_t))); } 
# 719
void clear() noexcept 
# 720
{ ((_M_t).clear()); } 
# 728
key_compare key_comp() const 
# 729
{ return ((_M_t).key_comp()); } 
# 736
value_compare value_comp() const 
# 737
{ return (value_compare)((_M_t).key_comp()); } 
# 754 "/usr/include/c++/5/bits/stl_multimap.h" 3
iterator find(const key_type &__x) 
# 755
{ return ((_M_t).find(__x)); } 
# 778 "/usr/include/c++/5/bits/stl_multimap.h" 3
const_iterator find(const key_type &__x) const 
# 779
{ return ((_M_t).find(__x)); } 
# 796 "/usr/include/c++/5/bits/stl_multimap.h" 3
size_type count(const key_type &__x) const 
# 797
{ return ((_M_t).count(__x)); } 
# 820 "/usr/include/c++/5/bits/stl_multimap.h" 3
iterator lower_bound(const key_type &__x) 
# 821
{ return ((_M_t).lower_bound(__x)); } 
# 845 "/usr/include/c++/5/bits/stl_multimap.h" 3
const_iterator lower_bound(const key_type &__x) const 
# 846
{ return ((_M_t).lower_bound(__x)); } 
# 865 "/usr/include/c++/5/bits/stl_multimap.h" 3
iterator upper_bound(const key_type &__x) 
# 866
{ return ((_M_t).upper_bound(__x)); } 
# 885 "/usr/include/c++/5/bits/stl_multimap.h" 3
const_iterator upper_bound(const key_type &__x) const 
# 886
{ return ((_M_t).upper_bound(__x)); } 
# 912 "/usr/include/c++/5/bits/stl_multimap.h" 3
pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator, typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator>  equal_range(const key_type &__x) 
# 913
{ return ((_M_t).equal_range(__x)); } 
# 939 "/usr/include/c++/5/bits/stl_multimap.h" 3
pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator, typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator>  equal_range(const key_type &__x) const 
# 940
{ return ((_M_t).equal_range(__x)); } 
# 951 "/usr/include/c++/5/bits/stl_multimap.h" 3
template< class _K1, class _T1, class _C1, class _A1> friend bool operator==(const std::multimap< _K1, _T1, _C1, _A1>  &, const std::multimap< _K1, _T1, _C1, _A1>  &); 
# 956
template< class _K1, class _T1, class _C1, class _A1> friend bool operator<(const std::multimap< _K1, _T1, _C1, _A1>  &, const std::multimap< _K1, _T1, _C1, _A1>  &); 
# 960
}; 
# 972 "/usr/include/c++/5/bits/stl_multimap.h" 3
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 974
operator==(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 975
__y) 
# 976
{ return (__x._M_t) == (__y._M_t); } 
# 989 "/usr/include/c++/5/bits/stl_multimap.h" 3
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 991
operator<(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 992
__y) 
# 993
{ return (__x._M_t) < (__y._M_t); } 
# 996
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 998
operator!=(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 999
__y) 
# 1000
{ return !(__x == __y); } 
# 1003
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1005
operator>(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1006
__y) 
# 1007
{ return __y < __x; } 
# 1010
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1012
operator<=(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1013
__y) 
# 1014
{ return !(__y < __x); } 
# 1017
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1019
operator>=(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1020
__y) 
# 1021
{ return !(__x < __y); } 
# 1024
template< class _Key, class _Tp, class _Compare, class _Alloc> inline void 
# 1026
swap(multimap< _Key, _Tp, _Compare, _Alloc>  &__x, multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1027
__y) 
# 1028
{ (__x.swap(__y)); } 
# 1031
}
# 39 "/usr/include/opencv2/flann/params.h" 3
namespace cvflann { 
# 42
typedef std::map< cv::String, any>  IndexParams; 
# 44
struct SearchParams : public IndexParams { 
# 46
SearchParams(int checks = 32, float eps = 0, bool sorted = true) 
# 47
{ 
# 49
(((*this)["checks"]) = checks); 
# 51
(((*this)["eps"]) = eps); 
# 53
(((*this)["sorted"]) = sorted); 
# 54
} 
# 55
}; 
# 58
template< class T> T 
# 59
get_param(const IndexParams &params, cv::String name, const T &default_value) 
# 60
{ 
# 61
std::map< cv::String, any> ::const_iterator it = params.find(name); 
# 62
if ((it != (params.end()))) { 
# 63
return ((it->second).template cast< T> ()); 
# 64
} else 
# 65
{ 
# 66
return default_value; 
# 67
}  
# 68
} 
# 70
template< class T> T 
# 71
get_param(const IndexParams &params, cv::String name) 
# 72
{ 
# 73
std::map< cv::String, any> ::const_iterator it = params.find(name); 
# 74
if ((it != (params.end()))) { 
# 75
return ((it->second).template cast< T> ()); 
# 76
} else 
# 77
{ 
# 78
throw ((FLANNException)((((((cv::String)("Missing parameter \'")) + name)) + ((cv::String)("\' in the parameters given"))))); 
# 79
}  
# 80
} 
# 82
inline void print_params(const IndexParams &params, std::ostream &stream) 
# 83
{ 
# 84
std::map< cv::String, any> ::const_iterator it; 
# 86
for (it = params.begin(); (it != (params.end())); (++it)) { 
# 87
(((((((stream << (it->first))) << (" : "))) << (it->second))) << (std::endl)); 
# 88
}  
# 89
} 
# 91
inline void print_params(const IndexParams &params) 
# 92
{ 
# 93
print_params(params, std::cout); 
# 94
} 
# 96
}
# 64 "/usr/include/c++/5/bits/stl_set.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 88 "/usr/include/c++/5/bits/stl_set.h" 3
template< class _Key, class _Compare = less< _Key> , class 
# 89
_Alloc = allocator< _Key> > 
# 90
class set { 
# 93
typedef typename _Alloc::value_type _Alloc_value_type; 
# 103
public: typedef _Key key_type; 
# 104
typedef _Key value_type; 
# 105
typedef _Compare key_compare; 
# 106
typedef _Compare value_compare; 
# 107
typedef _Alloc allocator_type; 
# 112
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other _Key_alloc_type; 
# 115
typedef _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other>  _Rep_type; 
# 116
_Rep_type _M_t; 
# 118
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other>  _Alloc_traits; 
# 123
public: typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::pointer pointer; 
# 124
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_pointer const_pointer; 
# 125
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::reference reference; 
# 126
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reference const_reference; 
# 130
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator iterator; 
# 131
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator const_iterator; 
# 132
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reverse_iterator reverse_iterator; 
# 133
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reverse_iterator const_reverse_iterator; 
# 134
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::size_type size_type; 
# 135
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::difference_type difference_type; 
# 142
set() noexcept(is_nothrow_default_constructible< _Alloc> ::value) : _M_t() 
# 146
{ } 
# 154
explicit set(const _Compare &__comp, const allocator_type &
# 155
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 156
{ } 
# 168 "/usr/include/c++/5/bits/stl_set.h" 3
template< class _InputIterator> 
# 169
set(_InputIterator __first, _InputIterator __last) : _M_t() 
# 171
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 185 "/usr/include/c++/5/bits/stl_set.h" 3
template< class _InputIterator> 
# 186
set(_InputIterator __first, _InputIterator __last, const _Compare &
# 187
__comp, const allocator_type &
# 188
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 190
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 199 "/usr/include/c++/5/bits/stl_set.h" 3
set(const set &__x) : _M_t((__x._M_t)) 
# 200
{ } 
# 210 "/usr/include/c++/5/bits/stl_set.h" 3
set(set &&__x) noexcept(is_nothrow_copy_constructible< _Compare> ::value) : _M_t(std::move((__x._M_t))) 
# 212
{ } 
# 224 "/usr/include/c++/5/bits/stl_set.h" 3
set(initializer_list< _Key>  __l, const _Compare &
# 225
__comp = _Compare(), const allocator_type &
# 226
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 228
{ ((_M_t)._M_insert_unique((__l.begin()), (__l.end()))); } 
# 232
explicit set(const allocator_type &__a) : _M_t(_Compare(), (_Key_alloc_type)__a) 
# 233
{ } 
# 236
set(const set &__x, const allocator_type &__a) : _M_t((__x._M_t), (_Key_alloc_type)__a) 
# 237
{ } 
# 240
set(set &&__x, const allocator_type &__a) noexcept(is_nothrow_copy_constructible< _Compare> ::value && _Alloc_traits::_S_always_equal()) : _M_t(std::move((__x._M_t)), (_Key_alloc_type)__a) 
# 243
{ } 
# 246
set(initializer_list< _Key>  __l, const allocator_type &__a) : _M_t(_Compare(), (_Key_alloc_type)__a) 
# 248
{ ((_M_t)._M_insert_unique((__l.begin()), (__l.end()))); } 
# 251
template< class _InputIterator> 
# 252
set(_InputIterator __first, _InputIterator __last, const allocator_type &
# 253
__a) : _M_t(_Compare(), (_Key_alloc_type)__a) 
# 255
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 266 "/usr/include/c++/5/bits/stl_set.h" 3
set &operator=(const set &__x) 
# 267
{ 
# 268
(_M_t) = (__x._M_t); 
# 269
return *this; 
# 270
} 
# 275
set &operator=(set &&) = default;
# 289 "/usr/include/c++/5/bits/stl_set.h" 3
set &operator=(initializer_list< _Key>  __l) 
# 290
{ 
# 291
((_M_t)._M_assign_unique((__l.begin()), (__l.end()))); 
# 292
return *this; 
# 293
} 
# 300
key_compare key_comp() const 
# 301
{ return ((_M_t).key_comp()); } 
# 304
value_compare value_comp() const 
# 305
{ return ((_M_t).key_comp()); } 
# 308
allocator_type get_allocator() const noexcept 
# 309
{ return (allocator_type)((_M_t).get_allocator()); } 
# 317
iterator begin() const noexcept 
# 318
{ return ((_M_t).begin()); } 
# 326
iterator end() const noexcept 
# 327
{ return ((_M_t).end()); } 
# 335
reverse_iterator rbegin() const noexcept 
# 336
{ return ((_M_t).rbegin()); } 
# 344
reverse_iterator rend() const noexcept 
# 345
{ return ((_M_t).rend()); } 
# 354
iterator cbegin() const noexcept 
# 355
{ return ((_M_t).begin()); } 
# 363
iterator cend() const noexcept 
# 364
{ return ((_M_t).end()); } 
# 372
reverse_iterator crbegin() const noexcept 
# 373
{ return ((_M_t).rbegin()); } 
# 381
reverse_iterator crend() const noexcept 
# 382
{ return ((_M_t).rend()); } 
# 387
bool empty() const noexcept 
# 388
{ return ((_M_t).empty()); } 
# 392
size_type size() const noexcept 
# 393
{ return ((_M_t).size()); } 
# 397
size_type max_size() const noexcept 
# 398
{ return ((_M_t).max_size()); } 
# 412 "/usr/include/c++/5/bits/stl_set.h" 3
void swap(set &__x) noexcept(_Alloc_traits::_S_nothrow_swap()) 
# 416
{ ((_M_t).swap((__x._M_t))); } 
# 433 "/usr/include/c++/5/bits/stl_set.h" 3
template< class ..._Args> pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, bool>  
# 435
emplace(_Args &&...__args) 
# 436
{ return ((_M_t)._M_emplace_unique(std::forward< _Args> (__args)...)); } 
# 459 "/usr/include/c++/5/bits/stl_set.h" 3
template< class ..._Args> iterator 
# 461
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 462
{ 
# 463
return ((_M_t)._M_emplace_hint_unique(__pos, std::forward< _Args> (__args)...)); 
# 465
} 
# 482 "/usr/include/c++/5/bits/stl_set.h" 3
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, bool>  insert(const value_type &__x) 
# 483
{ 
# 484
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::iterator, bool>  __p = ((_M_t)._M_insert_unique(__x)); 
# 486
return pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, bool> ((__p.first), (__p.second)); 
# 487
} 
# 491
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, bool>  insert(value_type &&__x) 
# 492
{ 
# 493
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::iterator, bool>  __p = ((_M_t)._M_insert_unique(std::move(__x))); 
# 495
return pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, bool> ((__p.first), (__p.second)); 
# 496
} 
# 519 "/usr/include/c++/5/bits/stl_set.h" 3
iterator insert(const_iterator __position, const value_type &__x) 
# 520
{ return ((_M_t)._M_insert_unique_(__position, __x)); } 
# 524
iterator insert(const_iterator __position, value_type &&__x) 
# 525
{ return ((_M_t)._M_insert_unique_(__position, std::move(__x))); } 
# 537 "/usr/include/c++/5/bits/stl_set.h" 3
template< class _InputIterator> void 
# 539
insert(_InputIterator __first, _InputIterator __last) 
# 540
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 551 "/usr/include/c++/5/bits/stl_set.h" 3
void insert(initializer_list< _Key>  __l) 
# 552
{ (this->insert((__l.begin()), (__l.end()))); } 
# 571 "/usr/include/c++/5/bits/stl_set.h" 3
__attribute((__abi_tag__("cxx11"))) iterator 
# 573
erase(const_iterator __position) 
# 574
{ return ((_M_t).erase(__position)); } 
# 603 "/usr/include/c++/5/bits/stl_set.h" 3
size_type erase(const key_type &__x) 
# 604
{ return ((_M_t).erase(__x)); } 
# 623 "/usr/include/c++/5/bits/stl_set.h" 3
__attribute((__abi_tag__("cxx11"))) iterator 
# 625
erase(const_iterator __first, const_iterator __last) 
# 626
{ return ((_M_t).erase(__first, __last)); } 
# 652 "/usr/include/c++/5/bits/stl_set.h" 3
void clear() noexcept 
# 653
{ ((_M_t).clear()); } 
# 667 "/usr/include/c++/5/bits/stl_set.h" 3
size_type count(const key_type &__x) const 
# 668
{ return (((_M_t).find(__x)) == ((_M_t).end())) ? 0 : 1; } 
# 694 "/usr/include/c++/5/bits/stl_set.h" 3
iterator find(const key_type &__x) 
# 695
{ return ((_M_t).find(__x)); } 
# 698
const_iterator find(const key_type &__x) const 
# 699
{ return ((_M_t).find(__x)); } 
# 729 "/usr/include/c++/5/bits/stl_set.h" 3
iterator lower_bound(const key_type &__x) 
# 730
{ return ((_M_t).lower_bound(__x)); } 
# 733
const_iterator lower_bound(const key_type &__x) const 
# 734
{ return ((_M_t).lower_bound(__x)); } 
# 759 "/usr/include/c++/5/bits/stl_set.h" 3
iterator upper_bound(const key_type &__x) 
# 760
{ return ((_M_t).upper_bound(__x)); } 
# 763
const_iterator upper_bound(const key_type &__x) const 
# 764
{ return ((_M_t).upper_bound(__x)); } 
# 798 "/usr/include/c++/5/bits/stl_set.h" 3
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator>  equal_range(const key_type &__x) 
# 799
{ return ((_M_t).equal_range(__x)); } 
# 802
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator>  equal_range(const key_type &__x) const 
# 803
{ return ((_M_t).equal_range(__x)); } 
# 820 "/usr/include/c++/5/bits/stl_set.h" 3
template< class _K1, class _C1, class _A1> friend bool operator==(const std::set< _K1, _C1, _A1>  &, const std::set< _K1, _C1, _A1>  &); 
# 824
template< class _K1, class _C1, class _A1> friend bool operator<(const std::set< _K1, _C1, _A1>  &, const std::set< _K1, _C1, _A1>  &); 
# 827
}; 
# 840 "/usr/include/c++/5/bits/stl_set.h" 3
template< class _Key, class _Compare, class _Alloc> inline bool 
# 842
operator==(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 843
__y) 
# 844
{ return (__x._M_t) == (__y._M_t); } 
# 857 "/usr/include/c++/5/bits/stl_set.h" 3
template< class _Key, class _Compare, class _Alloc> inline bool 
# 859
operator<(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 860
__y) 
# 861
{ return (__x._M_t) < (__y._M_t); } 
# 864
template< class _Key, class _Compare, class _Alloc> inline bool 
# 866
operator!=(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 867
__y) 
# 868
{ return !(__x == __y); } 
# 871
template< class _Key, class _Compare, class _Alloc> inline bool 
# 873
operator>(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 874
__y) 
# 875
{ return __y < __x; } 
# 878
template< class _Key, class _Compare, class _Alloc> inline bool 
# 880
operator<=(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 881
__y) 
# 882
{ return !(__y < __x); } 
# 885
template< class _Key, class _Compare, class _Alloc> inline bool 
# 887
operator>=(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 888
__y) 
# 889
{ return !(__x < __y); } 
# 892
template< class _Key, class _Compare, class _Alloc> inline void 
# 894
swap(set< _Key, _Compare, _Alloc>  &__x, set< _Key, _Compare, _Alloc>  &__y) 
# 895
{ (__x.swap(__y)); } 
# 898
}
# 64 "/usr/include/c++/5/bits/stl_multiset.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 90 "/usr/include/c++/5/bits/stl_multiset.h" 3
template< class _Key, class _Compare = less< _Key> , class 
# 91
_Alloc = allocator< _Key> > 
# 92
class multiset { 
# 95
typedef typename _Alloc::value_type _Alloc_value_type; 
# 103
public: typedef _Key key_type; 
# 104
typedef _Key value_type; 
# 105
typedef _Compare key_compare; 
# 106
typedef _Compare value_compare; 
# 107
typedef _Alloc allocator_type; 
# 112
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other _Key_alloc_type; 
# 115
typedef _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other>  _Rep_type; 
# 117
_Rep_type _M_t; 
# 119
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other>  _Alloc_traits; 
# 122
public: typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::pointer pointer; 
# 123
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_pointer const_pointer; 
# 124
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::reference reference; 
# 125
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reference const_reference; 
# 129
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator iterator; 
# 130
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator const_iterator; 
# 131
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reverse_iterator reverse_iterator; 
# 132
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reverse_iterator const_reverse_iterator; 
# 133
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::size_type size_type; 
# 134
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::difference_type difference_type; 
# 140
multiset() noexcept(is_nothrow_default_constructible< _Alloc> ::value) : _M_t() 
# 144
{ } 
# 152
explicit multiset(const _Compare &__comp, const allocator_type &
# 153
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 154
{ } 
# 165 "/usr/include/c++/5/bits/stl_multiset.h" 3
template< class _InputIterator> 
# 166
multiset(_InputIterator __first, _InputIterator __last) : _M_t() 
# 168
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 181 "/usr/include/c++/5/bits/stl_multiset.h" 3
template< class _InputIterator> 
# 182
multiset(_InputIterator __first, _InputIterator __last, const _Compare &
# 183
__comp, const allocator_type &
# 184
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 186
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 195 "/usr/include/c++/5/bits/stl_multiset.h" 3
multiset(const multiset &__x) : _M_t((__x._M_t)) 
# 196
{ } 
# 206 "/usr/include/c++/5/bits/stl_multiset.h" 3
multiset(multiset &&__x) noexcept(is_nothrow_copy_constructible< _Compare> ::value) : _M_t(std::move((__x._M_t))) 
# 208
{ } 
# 220 "/usr/include/c++/5/bits/stl_multiset.h" 3
multiset(initializer_list< _Key>  __l, const _Compare &
# 221
__comp = _Compare(), const allocator_type &
# 222
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 224
{ ((_M_t)._M_insert_equal((__l.begin()), (__l.end()))); } 
# 228
explicit multiset(const allocator_type &__a) : _M_t(_Compare(), (_Key_alloc_type)__a) 
# 229
{ } 
# 232
multiset(const multiset &__m, const allocator_type &__a) : _M_t((__m._M_t), (_Key_alloc_type)__a) 
# 233
{ } 
# 236
multiset(multiset &&__m, const allocator_type &__a) noexcept(is_nothrow_copy_constructible< _Compare> ::value && _Alloc_traits::_S_always_equal()) : _M_t(std::move((__m._M_t)), (_Key_alloc_type)__a) 
# 239
{ } 
# 242
multiset(initializer_list< _Key>  __l, const allocator_type &__a) : _M_t(_Compare(), (_Key_alloc_type)__a) 
# 244
{ ((_M_t)._M_insert_equal((__l.begin()), (__l.end()))); } 
# 247
template< class _InputIterator> 
# 248
multiset(_InputIterator __first, _InputIterator __last, const allocator_type &
# 249
__a) : _M_t(_Compare(), (_Key_alloc_type)__a) 
# 251
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 262 "/usr/include/c++/5/bits/stl_multiset.h" 3
multiset &operator=(const multiset &__x) 
# 263
{ 
# 264
(_M_t) = (__x._M_t); 
# 265
return *this; 
# 266
} 
# 271
multiset &operator=(multiset &&) = default;
# 285 "/usr/include/c++/5/bits/stl_multiset.h" 3
multiset &operator=(initializer_list< _Key>  __l) 
# 286
{ 
# 287
((_M_t)._M_assign_equal((__l.begin()), (__l.end()))); 
# 288
return *this; 
# 289
} 
# 296
key_compare key_comp() const 
# 297
{ return ((_M_t).key_comp()); } 
# 300
value_compare value_comp() const 
# 301
{ return ((_M_t).key_comp()); } 
# 304
allocator_type get_allocator() const noexcept 
# 305
{ return (allocator_type)((_M_t).get_allocator()); } 
# 313
iterator begin() const noexcept 
# 314
{ return ((_M_t).begin()); } 
# 322
iterator end() const noexcept 
# 323
{ return ((_M_t).end()); } 
# 331
reverse_iterator rbegin() const noexcept 
# 332
{ return ((_M_t).rbegin()); } 
# 340
reverse_iterator rend() const noexcept 
# 341
{ return ((_M_t).rend()); } 
# 350
iterator cbegin() const noexcept 
# 351
{ return ((_M_t).begin()); } 
# 359
iterator cend() const noexcept 
# 360
{ return ((_M_t).end()); } 
# 368
reverse_iterator crbegin() const noexcept 
# 369
{ return ((_M_t).rbegin()); } 
# 377
reverse_iterator crend() const noexcept 
# 378
{ return ((_M_t).rend()); } 
# 383
bool empty() const noexcept 
# 384
{ return ((_M_t).empty()); } 
# 388
size_type size() const noexcept 
# 389
{ return ((_M_t).size()); } 
# 393
size_type max_size() const noexcept 
# 394
{ return ((_M_t).max_size()); } 
# 408 "/usr/include/c++/5/bits/stl_multiset.h" 3
void swap(multiset &__x) noexcept(_Alloc_traits::_S_nothrow_swap()) 
# 412
{ ((_M_t).swap((__x._M_t))); } 
# 428 "/usr/include/c++/5/bits/stl_multiset.h" 3
template< class ..._Args> iterator 
# 430
emplace(_Args &&...__args) 
# 431
{ return ((_M_t)._M_emplace_equal(std::forward< _Args> (__args)...)); } 
# 454 "/usr/include/c++/5/bits/stl_multiset.h" 3
template< class ..._Args> iterator 
# 456
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 457
{ 
# 458
return ((_M_t)._M_emplace_hint_equal(__pos, std::forward< _Args> (__args)...)); 
# 460
} 
# 475 "/usr/include/c++/5/bits/stl_multiset.h" 3
iterator insert(const value_type &__x) 
# 476
{ return ((_M_t)._M_insert_equal(__x)); } 
# 480
iterator insert(value_type &&__x) 
# 481
{ return ((_M_t)._M_insert_equal(std::move(__x))); } 
# 505 "/usr/include/c++/5/bits/stl_multiset.h" 3
iterator insert(const_iterator __position, const value_type &__x) 
# 506
{ return ((_M_t)._M_insert_equal_(__position, __x)); } 
# 510
iterator insert(const_iterator __position, value_type &&__x) 
# 511
{ return ((_M_t)._M_insert_equal_(__position, std::move(__x))); } 
# 522 "/usr/include/c++/5/bits/stl_multiset.h" 3
template< class _InputIterator> void 
# 524
insert(_InputIterator __first, _InputIterator __last) 
# 525
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 536 "/usr/include/c++/5/bits/stl_multiset.h" 3
void insert(initializer_list< _Key>  __l) 
# 537
{ (this->insert((__l.begin()), (__l.end()))); } 
# 556 "/usr/include/c++/5/bits/stl_multiset.h" 3
__attribute((__abi_tag__("cxx11"))) iterator 
# 558
erase(const_iterator __position) 
# 559
{ return ((_M_t).erase(__position)); } 
# 588 "/usr/include/c++/5/bits/stl_multiset.h" 3
size_type erase(const key_type &__x) 
# 589
{ return ((_M_t).erase(__x)); } 
# 608 "/usr/include/c++/5/bits/stl_multiset.h" 3
__attribute((__abi_tag__("cxx11"))) iterator 
# 610
erase(const_iterator __first, const_iterator __last) 
# 611
{ return ((_M_t).erase(__first, __last)); } 
# 637 "/usr/include/c++/5/bits/stl_multiset.h" 3
void clear() noexcept 
# 638
{ ((_M_t).clear()); } 
# 649 "/usr/include/c++/5/bits/stl_multiset.h" 3
size_type count(const key_type &__x) const 
# 650
{ return ((_M_t).count(__x)); } 
# 675 "/usr/include/c++/5/bits/stl_multiset.h" 3
iterator find(const key_type &__x) 
# 676
{ return ((_M_t).find(__x)); } 
# 679
const_iterator find(const key_type &__x) const 
# 680
{ return ((_M_t).find(__x)); } 
# 710 "/usr/include/c++/5/bits/stl_multiset.h" 3
iterator lower_bound(const key_type &__x) 
# 711
{ return ((_M_t).lower_bound(__x)); } 
# 714
const_iterator lower_bound(const key_type &__x) const 
# 715
{ return ((_M_t).lower_bound(__x)); } 
# 740 "/usr/include/c++/5/bits/stl_multiset.h" 3
iterator upper_bound(const key_type &__x) 
# 741
{ return ((_M_t).upper_bound(__x)); } 
# 744
const_iterator upper_bound(const key_type &__x) const 
# 745
{ return ((_M_t).upper_bound(__x)); } 
# 779 "/usr/include/c++/5/bits/stl_multiset.h" 3
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator>  equal_range(const key_type &__x) 
# 780
{ return ((_M_t).equal_range(__x)); } 
# 783
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator>  equal_range(const key_type &__x) const 
# 784
{ return ((_M_t).equal_range(__x)); } 
# 801 "/usr/include/c++/5/bits/stl_multiset.h" 3
template< class _K1, class _C1, class _A1> friend bool operator==(const std::multiset< _K1, _C1, _A1>  &, const std::multiset< _K1, _C1, _A1>  &); 
# 806
template< class _K1, class _C1, class _A1> friend bool operator<(const std::multiset< _K1, _C1, _A1>  &, const std::multiset< _K1, _C1, _A1>  &); 
# 810
}; 
# 823 "/usr/include/c++/5/bits/stl_multiset.h" 3
template< class _Key, class _Compare, class _Alloc> inline bool 
# 825
operator==(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 826
__y) 
# 827
{ return (__x._M_t) == (__y._M_t); } 
# 840 "/usr/include/c++/5/bits/stl_multiset.h" 3
template< class _Key, class _Compare, class _Alloc> inline bool 
# 842
operator<(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 843
__y) 
# 844
{ return (__x._M_t) < (__y._M_t); } 
# 847
template< class _Key, class _Compare, class _Alloc> inline bool 
# 849
operator!=(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 850
__y) 
# 851
{ return !(__x == __y); } 
# 854
template< class _Key, class _Compare, class _Alloc> inline bool 
# 856
operator>(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 857
__y) 
# 858
{ return __y < __x; } 
# 861
template< class _Key, class _Compare, class _Alloc> inline bool 
# 863
operator<=(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 864
__y) 
# 865
{ return !(__y < __x); } 
# 868
template< class _Key, class _Compare, class _Alloc> inline bool 
# 870
operator>=(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 871
__y) 
# 872
{ return !(__x < __y); } 
# 875
template< class _Key, class _Compare, class _Alloc> inline void 
# 877
swap(multiset< _Key, _Compare, _Alloc>  &__x, multiset< _Key, _Compare, _Alloc>  &
# 878
__y) 
# 879
{ (__x.swap(__y)); } 
# 882
}
# 41 "/usr/include/opencv2/flann/result_set.h" 3
namespace cvflann { 
# 49
template< class T, class DistanceType> 
# 50
struct BranchStruct { 
# 52
T node; 
# 53
DistanceType mindist; 
# 55
BranchStruct() { } 
# 56
BranchStruct(const T &aNode, DistanceType dist) : node(aNode), mindist(dist) { } 
# 58
bool operator<(const BranchStruct &rhs) const 
# 59
{ 
# 60
return (mindist) < (rhs.mindist); 
# 61
} 
# 62
}; 
# 65
template< class DistanceType> 
# 66
class ResultSet { 
# 69
public: virtual ~ResultSet() { } 
# 71
virtual bool full() const = 0; 
# 73
virtual void addPoint(DistanceType dist, int index) = 0; 
# 75
virtual DistanceType worstDist() const = 0; 
# 77
}; 
# 84
template< class DistanceType> 
# 85
class KNNSimpleResultSet : public ResultSet< DistanceType>  { 
# 87
int *indices; 
# 88
DistanceType *dists; 
# 89
int capacity; 
# 90
int count; 
# 91
DistanceType worst_distance_; 
# 94
public: KNNSimpleResultSet(int capacity_) : capacity(capacity_), count(0) 
# 95
{ 
# 96
} 
# 98
void init(int *indices_, DistanceType *dists_) 
# 99
{ 
# 100
(indices) = indices_; 
# 101
(dists) = dists_; 
# 102
(count) = 0; 
# 103
(worst_distance_) = std::numeric_limits< DistanceType> ::max(); 
# 104
((dists)[(capacity) - 1]) = (worst_distance_); 
# 105
} 
# 107
::size_t size() const 
# 108
{ 
# 109
return count; 
# 110
} 
# 112
bool full() const 
# 113
{ 
# 114
return (count) == (capacity); 
# 115
} 
# 118
void addPoint(DistanceType dist, int index) 
# 119
{ 
# 120
if (dist >= (worst_distance_)) { return; }  
# 121
int i; 
# 122
for (i = (count); i > 0; --i) { 
# 126
if (((dists)[i - 1]) > dist) 
# 128
{ 
# 129
if (i < (capacity)) { 
# 130
((dists)[i]) = ((dists)[i - 1]); 
# 131
((indices)[i]) = ((indices)[i - 1]); 
# 132
}  
# 133
} else { 
# 134
break; }  
# 135
}  
# 136
if ((count) < (capacity)) { ++(count); }  
# 137
((dists)[i]) = dist; 
# 138
((indices)[i]) = index; 
# 139
(worst_distance_) = ((dists)[(capacity) - 1]); 
# 140
} 
# 142
DistanceType worstDist() const 
# 143
{ 
# 144
return worst_distance_; 
# 145
} 
# 146
}; 
# 151
template< class DistanceType> 
# 152
class KNNResultSet : public ResultSet< DistanceType>  { 
# 154
int *indices; 
# 155
DistanceType *dists; 
# 156
int capacity; 
# 157
int count; 
# 158
DistanceType worst_distance_; 
# 161
public: KNNResultSet(int capacity_) : capacity(capacity_), count(0) 
# 162
{ 
# 163
} 
# 165
void init(int *indices_, DistanceType *dists_) 
# 166
{ 
# 167
(indices) = indices_; 
# 168
(dists) = dists_; 
# 169
(count) = 0; 
# 170
(worst_distance_) = std::numeric_limits< DistanceType> ::max(); 
# 171
((dists)[(capacity) - 1]) = (worst_distance_); 
# 172
} 
# 174
::size_t size() const 
# 175
{ 
# 176
return count; 
# 177
} 
# 179
bool full() const 
# 180
{ 
# 181
return (count) == (capacity); 
# 182
} 
# 185
void addPoint(DistanceType dist, int index) 
# 186
{ 
# 187
if (dist >= (worst_distance_)) { return; }  
# 188
int i; 
# 189
for (i = (count); i > 0; --i) { 
# 193
if (((dists)[i - 1]) <= dist) 
# 195
{ 
# 197
int j = i - 1; 
# 198
while ((j >= 0) && (((dists)[j]) == dist)) { 
# 199
if (((indices)[j]) == index) { 
# 200
return; 
# 201
}  
# 202
--j; 
# 203
}  
# 204
break; 
# 205
}  
# 206
}  
# 208
if ((count) < (capacity)) { ++(count); }  
# 209
for (int j = (count) - 1; j > i; --j) { 
# 210
((dists)[j]) = ((dists)[j - 1]); 
# 211
((indices)[j]) = ((indices)[j - 1]); 
# 212
}  
# 213
((dists)[i]) = dist; 
# 214
((indices)[i]) = index; 
# 215
(worst_distance_) = ((dists)[(capacity) - 1]); 
# 216
} 
# 218
DistanceType worstDist() const 
# 219
{ 
# 220
return worst_distance_; 
# 221
} 
# 222
}; 
# 228
template< class DistanceType> 
# 229
class RadiusResultSet : public ResultSet< DistanceType>  { 
# 231
DistanceType radius; 
# 232
int *indices; 
# 233
DistanceType *dists; 
# 234
::size_t capacity; 
# 235
::size_t count; 
# 238
public: RadiusResultSet(DistanceType radius_, int *indices_, DistanceType *dists_, int capacity_) : radius(radius_), indices(indices_), dists(dists_), capacity(capacity_) 
# 240
{ 
# 241
init(); 
# 242
} 
# 244
~RadiusResultSet() 
# 245
{ 
# 246
} 
# 248
void init() 
# 249
{ 
# 250
(count) = (0); 
# 251
} 
# 253
::size_t size() const 
# 254
{ 
# 255
return count; 
# 256
} 
# 258
bool full() const 
# 259
{ 
# 260
return true; 
# 261
} 
# 263
void addPoint(DistanceType dist, int index) 
# 264
{ 
# 265
if (dist < (radius)) { 
# 266
if (((capacity) > (0)) && ((count) < (capacity))) { 
# 267
((dists)[count]) = dist; 
# 268
((indices)[count]) = index; 
# 269
}  
# 270
(count)++; 
# 271
}  
# 272
} 
# 274
DistanceType worstDist() const 
# 275
{ 
# 276
return radius; 
# 277
} 
# 279
}; 
# 286
template< class DistanceType> 
# 287
class UniqueResultSet : public ResultSet< DistanceType>  { 
# 290
public: struct DistIndex { 
# 292
DistIndex(DistanceType dist, unsigned index) : dist_(dist), index_(index) 
# 294
{ 
# 295
} 
# 296
bool operator<(const DistIndex dist_index) const 
# 297
{ 
# 298
return ((dist_) < (dist_index.dist_)) || (((dist_) == (dist_index.dist_)) && ((index_) < (dist_index.index_))); 
# 299
} 
# 300
DistanceType dist_; 
# 301
unsigned index_; 
# 302
}; 
# 305
UniqueResultSet() : is_full_(false), worst_distance_(std::numeric_limits< DistanceType> ::max()) 
# 307
{ 
# 308
} 
# 313
bool full() const 
# 314
{ 
# 315
return is_full_; 
# 316
} 
# 320
virtual void clear() = 0; 
# 327
virtual void copy(int *indices, DistanceType *dist, int n_neighbors = -1) const 
# 328
{ 
# 329
if (n_neighbors < 0) { 
# 330
for (typename ::std::set< DistIndex> ::const_iterator dist_index = ((dist_indices_).begin()), dist_index_end = ((dist_indices_).end()); dist_index != dist_index_end; ((++dist_index), (++indices)), (++dist)) 
# 331
{ 
# 332
(*indices) = (dist_index->index_); 
# 333
(*dist) = (dist_index->dist_); 
# 334
}  
# 335
} else 
# 336
{ 
# 337
int i = 0; 
# 338
for (typename ::std::set< DistIndex> ::const_iterator dist_index = ((dist_indices_).begin()), dist_index_end = ((dist_indices_).end()); (dist_index != dist_index_end) && (i < n_neighbors); (((++dist_index), (++indices)), (++dist)), (++i)) 
# 339
{ 
# 340
(*indices) = (dist_index->index_); 
# 341
(*dist) = (dist_index->dist_); 
# 342
}  
# 343
}  
# 344
} 
# 351
virtual void sortAndCopy(int *indices, DistanceType *dist, int n_neighbors = -1) const 
# 352
{ 
# 353
copy(indices, dist, n_neighbors); 
# 354
} 
# 359
::size_t size() const 
# 360
{ 
# 361
return ((dist_indices_).size()); 
# 362
} 
# 368
DistanceType worstDist() const 
# 369
{ 
# 370
return worst_distance_; 
# 371
} 
# 374
protected: bool is_full_; 
# 377
DistanceType worst_distance_; 
# 380
::std::set< DistIndex>  dist_indices_; 
# 381
}; 
# 388
template< class DistanceType> 
# 389
class KNNUniqueResultSet : public UniqueResultSet< DistanceType>  { 
# 395
public: KNNUniqueResultSet(unsigned capacity) : capacity_(capacity) 
# 396
{ 
# 397
(this->is_full_) = false; 
# 398
this->clear(); 
# 399
} 
# 405
void addPoint(DistanceType dist, int index) 
# 406
{ 
# 408
if (dist >= worst_distance_) { return; }  
# 409
(dist_indices_.insert)(DistIndex(dist, index)); 
# 411
if (is_full_) { 
# 412
if ((dist_indices_.size)() > (capacity_)) { 
# 413
(dist_indices_.erase)(*(dist_indices_.rbegin)()); 
# 414
worst_distance_ = ((dist_indices_.rbegin)()->dist_); 
# 415
}  
# 416
} else { 
# 417
if ((dist_indices_.size)() == (capacity_)) { 
# 418
is_full_ = true; 
# 419
worst_distance_ = ((dist_indices_.rbegin)()->dist_); 
# 420
}  }  
# 421
} 
# 425
void clear() 
# 426
{ 
# 427
(dist_indices_.clear)(); 
# 428
worst_distance_ = std::numeric_limits< DistanceType> ::max(); 
# 429
is_full_ = false; 
# 430
} 
# 433
protected: typedef typename ::cvflann::UniqueResultSet< DistanceType> ::DistIndex DistIndex; 
# 434
using ::cvflann::UniqueResultSet< DistanceType> ::is_full_;
# 435
using ::cvflann::UniqueResultSet< DistanceType> ::worst_distance_;
# 436
using ::cvflann::UniqueResultSet< DistanceType> ::dist_indices_;
# 439
unsigned capacity_; 
# 440
}; 
# 447
template< class DistanceType> 
# 448
class RadiusUniqueResultSet : public UniqueResultSet< DistanceType>  { 
# 454
public: RadiusUniqueResultSet(DistanceType radius) : radius_(radius) 
# 456
{ 
# 457
is_full_ = true; 
# 458
} 
# 464
void addPoint(DistanceType dist, int index) 
# 465
{ 
# 466
if (dist <= (radius_)) { (dist_indices_.insert)(DistIndex(dist, index)); }  
# 467
} 
# 471
void clear() 
# 472
{ 
# 473
(dist_indices_.clear)(); 
# 474
} 
# 480
bool full() const 
# 481
{ 
# 482
return true; 
# 483
} 
# 489
DistanceType worstDist() const 
# 490
{ 
# 491
return radius_; 
# 492
} 
# 494
private: typedef typename ::cvflann::UniqueResultSet< DistanceType> ::DistIndex DistIndex; 
# 495
using ::cvflann::UniqueResultSet< DistanceType> ::dist_indices_;
# 496
using ::cvflann::UniqueResultSet< DistanceType> ::is_full_;
# 499
DistanceType radius_; 
# 500
}; 
# 506
template< class DistanceType> 
# 507
class KNNRadiusUniqueResultSet : public KNNUniqueResultSet< DistanceType>  { 
# 514
public: KNNRadiusUniqueResultSet(unsigned capacity, DistanceType radius) 
# 515
{ 
# 516
(this->capacity_) = capacity; 
# 517
(this->radius_) = radius; 
# 518
((this->dist_indices_).reserve(capacity_)); 
# 519
this->clear(); 
# 520
} 
# 524
void clear() 
# 525
{ 
# 526
(dist_indices_.clear)(); 
# 527
worst_distance_ = (radius_); 
# 528
is_full_ = false; 
# 529
} 
# 531
private: using ::cvflann::KNNUniqueResultSet< DistanceType> ::dist_indices_;
# 532
using ::cvflann::KNNUniqueResultSet< DistanceType> ::is_full_;
# 533
using ::cvflann::KNNUniqueResultSet< DistanceType> ::worst_distance_;
# 536
unsigned capacity_; 
# 539
DistanceType radius_; 
# 540
}; 
# 541
}
# 39 "/usr/include/opencv2/flann/nn_index.h" 3
namespace cvflann { 
# 45
template< class Distance> 
# 46
class NNIndex { 
# 48
typedef typename Distance::ElementType ElementType; 
# 49
typedef typename Distance::ResultType DistanceType; 
# 53
public: virtual ~NNIndex() { } 
# 58
virtual void buildIndex() = 0; 
# 68 "/usr/include/opencv2/flann/nn_index.h" 3
virtual void knnSearch(const Matrix< typename Distance::ElementType>  &queries, Matrix< int>  &indices, Matrix< typename Distance::ResultType>  &dists, int knn, const SearchParams &params) 
# 69
{ 
# 70
((queries.cols) == veclen()) ? static_cast< void>(0) : __assert_fail("queries.cols == veclen()", "/usr/include/opencv2/flann/nn_index.h", 70, __PRETTY_FUNCTION__); 
# 71
((indices.rows) >= (queries.rows)) ? static_cast< void>(0) : __assert_fail("indices.rows >= queries.rows", "/usr/include/opencv2/flann/nn_index.h", 71, __PRETTY_FUNCTION__); 
# 72
((dists.rows) >= (queries.rows)) ? static_cast< void>(0) : __assert_fail("dists.rows >= queries.rows", "/usr/include/opencv2/flann/nn_index.h", 72, __PRETTY_FUNCTION__); 
# 73
(((int)(indices.cols)) >= knn) ? static_cast< void>(0) : __assert_fail("int(indices.cols) >= knn", "/usr/include/opencv2/flann/nn_index.h", 73, __PRETTY_FUNCTION__); 
# 74
(((int)(dists.cols)) >= knn) ? static_cast< void>(0) : __assert_fail("int(dists.cols) >= knn", "/usr/include/opencv2/flann/nn_index.h", 74, __PRETTY_FUNCTION__); 
# 83 "/usr/include/opencv2/flann/nn_index.h" 3
KNNUniqueResultSet< typename Distance::ResultType>  resultSet(knn); 
# 84
for (size_t i = (0); i < (queries.rows); i++) { 
# 85
(resultSet.clear()); 
# 86
findNeighbors(resultSet, queries[i], params); 
# 87
if (get_param(params, "sorted", true)) { (resultSet.sortAndCopy(indices[i], dists[i], knn)); } else { 
# 88
(resultSet.copy(indices[i], dists[i], knn)); }  
# 89
}  
# 91
} 
# 102 "/usr/include/opencv2/flann/nn_index.h" 3
virtual int radiusSearch(const Matrix< typename Distance::ElementType>  &query, Matrix< int>  &indices, Matrix< typename Distance::ResultType>  &dists, float radius, const SearchParams &params) 
# 103
{ 
# 104
if ((query.rows) != 1) { 
# 105
fprintf(stderr, "I can only search one feature at a time for range search\n"); 
# 106
return -1; 
# 107
}  
# 108
((query.cols) == veclen()) ? static_cast< void>(0) : __assert_fail("query.cols == veclen()", "/usr/include/opencv2/flann/nn_index.h", 108, __PRETTY_FUNCTION__); 
# 109
((indices.cols) == (dists.cols)) ? static_cast< void>(0) : __assert_fail("indices.cols == dists.cols", "/usr/include/opencv2/flann/nn_index.h", 109, __PRETTY_FUNCTION__); 
# 111
int n = 0; 
# 112
int *indices_ptr = (__null); 
# 113
DistanceType *dists_ptr = (__null); 
# 114
if ((indices.cols) > (0)) { 
# 115
n = ((int)(indices.cols)); 
# 116
indices_ptr = indices[0]; 
# 117
dists_ptr = (dists[0]); 
# 118
}  
# 120
RadiusUniqueResultSet< typename Distance::ResultType>  resultSet((DistanceType)radius); 
# 121
(resultSet.clear()); 
# 122
findNeighbors(resultSet, query[0], params); 
# 123
if (n > 0) { 
# 124
if (get_param(params, "sorted", true)) { (resultSet.sortAndCopy(indices_ptr, dists_ptr, n)); } else { 
# 125
(resultSet.copy(indices_ptr, dists_ptr, n)); }  
# 126
}  
# 128
return (int)(resultSet.size()); 
# 129
} 
# 135
virtual void saveIndex(FILE * stream) = 0; 
# 141
virtual void loadIndex(FILE * stream) = 0; 
# 146
virtual size_t size() const = 0; 
# 151
virtual size_t veclen() const = 0; 
# 156
virtual int usedMemory() const = 0; 
# 161
virtual flann_algorithm_t getType() const = 0; 
# 166
virtual IndexParams getParameters() const = 0; 
# 172
virtual void findNeighbors(ResultSet< typename Distance::ResultType>  & result, const ElementType * vec, const SearchParams & searchParams) = 0; 
# 173
}; 
# 175
}
# 43 "/usr/include/opencv2/flann/saving.h" 3
namespace cvflann { 
# 46
template< class T> 
# 47
struct Datatype { }; 
# 49
template<> struct Datatype< char>  { static flann_datatype_t type() { return FLANN_INT8; } }; 
# 51
template<> struct Datatype< short>  { static flann_datatype_t type() { return FLANN_INT16; } }; 
# 53
template<> struct Datatype< int>  { static flann_datatype_t type() { return FLANN_INT32; } }; 
# 55
template<> struct Datatype< unsigned char>  { static flann_datatype_t type() { return FLANN_UINT8; } }; 
# 57
template<> struct Datatype< unsigned short>  { static flann_datatype_t type() { return FLANN_UINT16; } }; 
# 59
template<> struct Datatype< unsigned>  { static flann_datatype_t type() { return FLANN_UINT32; } }; 
# 61
template<> struct Datatype< float>  { static flann_datatype_t type() { return FLANN_FLOAT32; } }; 
# 63
template<> struct Datatype< double>  { static flann_datatype_t type() { return FLANN_FLOAT64; } }; 
# 69
struct IndexHeader { 
# 71
char signature[16]; 
# 72
char version[16]; 
# 73
flann_datatype_t data_type; 
# 74
flann_algorithm_t index_type; 
# 75
size_t rows; 
# 76
size_t cols; 
# 77
}; 
# 85
template< class Distance> void 
# 86
save_header(FILE *stream, const NNIndex< Distance>  &index) 
# 87
{ 
# 88
IndexHeader header; 
# 89
memset(header.signature, 0, sizeof (header.signature)); 
# 90
strcpy(header.signature, "FLANN_INDEX"); 
# 91
memset(header.version, 0, sizeof (header.version)); 
# 92
strcpy(header.version, "1.6.10"); 
# 93
(header.data_type) = Datatype< typename Distance::ElementType> ::type(); 
# 94
(header.index_type) = (index.getType()); 
# 95
(header.rows) = (index.size()); 
# 96
(header.cols) = (index.veclen()); 
# 98
std::fwrite(&header, sizeof header, 1, stream); 
# 99
} 
# 107
inline IndexHeader load_header(FILE *stream) 
# 108
{ 
# 109
IndexHeader header; 
# 110
size_t read_size = fread(&header, sizeof header, 1, stream); 
# 112
if (read_size != ((size_t)1)) { 
# 113
throw ((FLANNException)("Invalid index file, cannot read")); 
# 114
}  
# 116
if (strcmp(header.signature, "FLANN_INDEX") != 0) { 
# 117
throw ((FLANNException)("Invalid index file, wrong signature")); 
# 118
}  
# 120
return header; 
# 122
} 
# 125
template< class T> void 
# 126
save_value(FILE *stream, const T &value, size_t count = 1) 
# 127
{ 
# 128
fwrite(&value, sizeof(value), count, stream); 
# 129
} 
# 131
template< class T> void 
# 132
save_value(FILE *stream, const Matrix< T>  &value) 
# 133
{ 
# 134
fwrite(&value, sizeof(value), 1, stream); 
# 135
fwrite((value.data), sizeof(T), (value.rows) * (value.cols), stream); 
# 136
} 
# 138
template< class T> void 
# 139
save_value(FILE *stream, const std::vector< T>  &value) 
# 140
{ 
# 141
size_t size = (value.size()); 
# 142
fwrite(&size, sizeof(size_t), 1, stream); 
# 143
fwrite(&(value[0]), sizeof(T), size, stream); 
# 144
} 
# 146
template< class T> void 
# 147
load_value(FILE *stream, T &value, size_t count = 1) 
# 148
{ 
# 149
size_t read_cnt = fread(&value, sizeof(value), count, stream); 
# 150
if (read_cnt != count) { 
# 151
throw ((FLANNException)("Cannot read from file")); 
# 152
}  
# 153
} 
# 155
template< class T> void 
# 156
load_value(FILE *stream, Matrix< T>  &value) 
# 157
{ 
# 158
size_t read_cnt = fread(&value, sizeof(value), 1, stream); 
# 159
if (read_cnt != (1)) { 
# 160
throw ((FLANNException)("Cannot read from file")); 
# 161
}  
# 162
(value.data) = (new T [(value.rows) * (value.cols)]); 
# 163
read_cnt = fread((value.data), sizeof(T), (value.rows) * (value.cols), stream); 
# 164
if (read_cnt != ((size_t)((value.rows) * (value.cols)))) { 
# 165
throw ((FLANNException)("Cannot read from file")); 
# 166
}  
# 167
} 
# 170
template< class T> void 
# 171
load_value(FILE *stream, std::vector< T>  &value) 
# 172
{ 
# 173
size_t size; 
# 174
size_t read_cnt = fread(&size, sizeof(size_t), 1, stream); 
# 175
if (read_cnt != (1)) { 
# 176
throw ((FLANNException)("Cannot read from file")); 
# 177
}  
# 178
(value.resize(size)); 
# 179
read_cnt = fread(&(value[0]), sizeof(T), size, stream); 
# 180
if (read_cnt != size) { 
# 181
throw ((FLANNException)("Cannot read from file")); 
# 182
}  
# 183
} 
# 185
}
# 54 "/usr/include/opencv2/flann/dist.h" 3
namespace cvflann { 
# 57
template< class T> inline T 
# 58
abs(T x) { return (x < 0) ? -x : x; } 
# 61
template<> inline int abs< int> (int x) { return ::abs(x); } 
# 64
template<> inline float abs< float> (float x) { return fabsf(x); } 
# 67
template<> inline double abs< double> (double x) { return fabs(x); } 
# 69
template< class T> 
# 70
struct Accumulator { typedef T Type; }; 
# 72
template<> struct Accumulator< unsigned char>  { typedef float Type; }; 
# 74
template<> struct Accumulator< unsigned short>  { typedef float Type; }; 
# 76
template<> struct Accumulator< unsigned>  { typedef float Type; }; 
# 78
template<> struct Accumulator< char>  { typedef float Type; }; 
# 80
template<> struct Accumulator< short>  { typedef float Type; }; 
# 82
template<> struct Accumulator< int>  { typedef float Type; }; 
# 87
class True { 
# 89
}; 
# 91
class False { 
# 93
}; 
# 102 "/usr/include/opencv2/flann/dist.h" 3
template< class T> 
# 103
struct L2_Simple { 
# 105
typedef True is_kdtree_distance; 
# 106
typedef True is_vector_space_distance; 
# 108
typedef T ElementType; 
# 109
typedef typename Accumulator< T> ::Type ResultType; 
# 111
template< class Iterator1, class Iterator2> ResultType 
# 112
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const 
# 113
{ 
# 114
ResultType result = (ResultType()); 
# 115
ResultType diff; 
# 116
for (size_t i = (0); i < size; ++i) { 
# 117
diff = ((*(a++)) - (*(b++))); 
# 118
result += (diff * diff); 
# 119
}  
# 120
return result; 
# 121
} 
# 123
template< class U, class V> ResultType 
# 124
accum_dist(const U &a, const V &b, int) const 
# 125
{ 
# 126
return (a - b) * (a - b); 
# 127
} 
# 128
}; 
# 135
template< class T> 
# 136
struct L2 { 
# 138
typedef True is_kdtree_distance; 
# 139
typedef True is_vector_space_distance; 
# 141
typedef T ElementType; 
# 142
typedef typename Accumulator< T> ::Type ResultType; 
# 153 "/usr/include/opencv2/flann/dist.h" 3
template< class Iterator1, class Iterator2> ResultType 
# 154
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 155
{ 
# 156
ResultType result = (ResultType()); 
# 157
ResultType diff0, diff1, diff2, diff3; 
# 158
Iterator1 last = a + size; 
# 159
Iterator1 lastgroup = last - 3; 
# 162
while (a < lastgroup) { 
# 163
diff0 = ((ResultType)((a[0]) - (b[0]))); 
# 164
diff1 = ((ResultType)((a[1]) - (b[1]))); 
# 165
diff2 = ((ResultType)((a[2]) - (b[2]))); 
# 166
diff3 = ((ResultType)((a[3]) - (b[3]))); 
# 167
result += ((((diff0 * diff0) + (diff1 * diff1)) + (diff2 * diff2)) + (diff3 * diff3)); 
# 168
a += 4; 
# 169
b += 4; 
# 171
if ((worst_dist > 0) && (result > worst_dist)) { 
# 172
return result; 
# 173
}  
# 174
}  
# 176
while (a < last) { 
# 177
diff0 = ((ResultType)((*(a++)) - (*(b++)))); 
# 178
result += (diff0 * diff0); 
# 179
}  
# 180
return result; 
# 181
} 
# 189
template< class U, class V> ResultType 
# 190
accum_dist(const U &a, const V &b, int) const 
# 191
{ 
# 192
return (a - b) * (a - b); 
# 193
} 
# 194
}; 
# 200
template< class T> 
# 201
struct L1 { 
# 203
typedef True is_kdtree_distance; 
# 204
typedef True is_vector_space_distance; 
# 206
typedef T ElementType; 
# 207
typedef typename Accumulator< T> ::Type ResultType; 
# 215
template< class Iterator1, class Iterator2> ResultType 
# 216
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 217
{ 
# 218
ResultType result = (ResultType()); 
# 219
ResultType diff0, diff1, diff2, diff3; 
# 220
Iterator1 last = a + size; 
# 221
Iterator1 lastgroup = last - 3; 
# 224
while (a < lastgroup) { 
# 225
diff0 = ((ResultType)abs((a[0]) - (b[0]))); 
# 226
diff1 = ((ResultType)abs((a[1]) - (b[1]))); 
# 227
diff2 = ((ResultType)abs((a[2]) - (b[2]))); 
# 228
diff3 = ((ResultType)abs((a[3]) - (b[3]))); 
# 229
result += (((diff0 + diff1) + diff2) + diff3); 
# 230
a += 4; 
# 231
b += 4; 
# 233
if ((worst_dist > 0) && (result > worst_dist)) { 
# 234
return result; 
# 235
}  
# 236
}  
# 238
while (a < last) { 
# 239
diff0 = ((ResultType)abs((*(a++)) - (*(b++)))); 
# 240
result += diff0; 
# 241
}  
# 242
return result; 
# 243
} 
# 248
template< class U, class V> ResultType 
# 249
accum_dist(const U &a, const V &b, int) const 
# 250
{ 
# 251
return abs(a - b); 
# 252
} 
# 253
}; 
# 257
template< class T> 
# 258
struct MinkowskiDistance { 
# 260
typedef True is_kdtree_distance; 
# 261
typedef True is_vector_space_distance; 
# 263
typedef T ElementType; 
# 264
typedef typename Accumulator< T> ::Type ResultType; 
# 266
int order; 
# 268
MinkowskiDistance(int order_) : order(order_) { } 
# 279 "/usr/include/opencv2/flann/dist.h" 3
template< class Iterator1, class Iterator2> ResultType 
# 280
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 281
{ 
# 282
ResultType result = (ResultType()); 
# 283
ResultType diff0, diff1, diff2, diff3; 
# 284
Iterator1 last = a + size; 
# 285
Iterator1 lastgroup = last - 3; 
# 288
while (a < lastgroup) { 
# 289
diff0 = ((ResultType)abs((a[0]) - (b[0]))); 
# 290
diff1 = ((ResultType)abs((a[1]) - (b[1]))); 
# 291
diff2 = ((ResultType)abs((a[2]) - (b[2]))); 
# 292
diff3 = ((ResultType)abs((a[3]) - (b[3]))); 
# 293
result += (((pow(diff0, order) + pow(diff1, order)) + pow(diff2, order)) + pow(diff3, order)); 
# 294
a += 4; 
# 295
b += 4; 
# 297
if ((worst_dist > 0) && (result > worst_dist)) { 
# 298
return result; 
# 299
}  
# 300
}  
# 302
while (a < last) { 
# 303
diff0 = ((ResultType)abs((*(a++)) - (*(b++)))); 
# 304
result += pow(diff0, order); 
# 305
}  
# 306
return result; 
# 307
} 
# 312
template< class U, class V> ResultType 
# 313
accum_dist(const U &a, const V &b, int) const 
# 314
{ 
# 315
return pow(static_cast< ResultType>(abs(a - b)), order); 
# 316
} 
# 317
}; 
# 321
template< class T> 
# 322
struct MaxDistance { 
# 324
typedef False is_kdtree_distance; 
# 325
typedef True is_vector_space_distance; 
# 327
typedef T ElementType; 
# 328
typedef typename Accumulator< T> ::Type ResultType; 
# 335
template< class Iterator1, class Iterator2> ResultType 
# 336
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 337
{ 
# 338
ResultType result = (ResultType()); 
# 339
ResultType diff0, diff1, diff2, diff3; 
# 340
Iterator1 last = a + size; 
# 341
Iterator1 lastgroup = last - 3; 
# 344
while (a < lastgroup) { 
# 345
diff0 = abs((a[0]) - (b[0])); 
# 346
diff1 = abs((a[1]) - (b[1])); 
# 347
diff2 = abs((a[2]) - (b[2])); 
# 348
diff3 = abs((a[3]) - (b[3])); 
# 349
if (diff0 > result) { result = diff0; }  
# 350
if (diff1 > result) { result = diff1; }  
# 351
if (diff2 > result) { result = diff2; }  
# 352
if (diff3 > result) { result = diff3; }  
# 353
a += 4; 
# 354
b += 4; 
# 356
if ((worst_dist > 0) && (result > worst_dist)) { 
# 357
return result; 
# 358
}  
# 359
}  
# 361
while (a < last) { 
# 362
diff0 = abs((*(a++)) - (*(b++))); 
# 363
result = ((diff0 > result) ? diff0 : result); 
# 364
}  
# 365
return result; 
# 366
} 
# 371
}; 
# 379
struct HammingLUT { 
# 381
typedef False is_kdtree_distance; 
# 382
typedef False is_vector_space_distance; 
# 384
typedef unsigned char ElementType; 
# 385
typedef int ResultType; 
# 389
ResultType operator()(const unsigned char *a, const unsigned char *b, size_t size) const 
# 390
{ 
# 391
static const uchar popCountTable[] = {(0), (1), (1), (2), (1), (2), (2), (3), (1), (2), (2), (3), (2), (3), (3), (4), (1), (2), (2), (3), (2), (3), (3), (4), (2), (3), (3), (4), (3), (4), (4), (5), (1), (2), (2), (3), (2), (3), (3), (4), (2), (3), (3), (4), (3), (4), (4), (5), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (1), (2), (2), (3), (2), (3), (3), (4), (2), (3), (3), (4), (3), (4), (4), (5), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (3), (4), (4), (5), (4), (5), (5), (6), (4), (5), (5), (6), (5), (6), (6), (7), (1), (2), (2), (3), (2), (3), (3), (4), (2), (3), (3), (4), (3), (4), (4), (5), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (3), (4), (4), (5), (4), (5), (5), (6), (4), (5), (5), (6), (5), (6), (6), (7), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (3), (4), (4), (5), (4), (5), (5), (6), (4), (5), (5), (6), (5), (6), (6), (7), (3), (4), (4), (5), (4), (5), (5), (6), (4), (5), (5), (6), (5), (6), (6), (7), (4), (5), (5), (6), (5), (6), (6), (7), (5), (6), (6), (7), (6), (7), (7), (8)}; 
# 402
ResultType result = 0; 
# 403
for (size_t i = (0); i < size; i++) { 
# 404
result += ((popCountTable)[(a[i]) ^ (b[i])]); 
# 405
}  
# 406
return result; 
# 407
} 
# 408
}; 
# 414
template< class T> 
# 415
struct Hamming { 
# 417
typedef False is_kdtree_distance; 
# 418
typedef False is_vector_space_distance; 
# 421
typedef T ElementType; 
# 422
typedef int ResultType; 
# 424
template< class Iterator1, class Iterator2> ResultType 
# 425
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const 
# 426
{ 
# 427
ResultType result = 0; 
# 445 "/usr/include/opencv2/flann/dist.h" 3
{ 
# 447
typedef unsigned long long pop_t; 
# 448
const size_t modulo = size % sizeof(pop_t); 
# 449
const pop_t *a2 = reinterpret_cast< const pop_t *>(a); 
# 450
const pop_t *b2 = reinterpret_cast< const pop_t *>(b); 
# 451
const pop_t *a2_end = a2 + (size / sizeof(pop_t)); 
# 453
for (; a2 != a2_end; (++a2), (++b2)) { result += __builtin_popcountll((*a2) ^ (*b2)); }  
# 455
if (modulo) { 
# 458
pop_t a_final = (0), b_final = (0); 
# 459
memcpy(&a_final, a2, modulo); 
# 460
memcpy(&b_final, b2, modulo); 
# 461
result += __builtin_popcountll(a_final ^ b_final); 
# 462
}  
# 463
} 
# 470
return result; 
# 471
} 
# 472
}; 
# 474
template< class T> 
# 475
struct Hamming2 { 
# 477
typedef False is_kdtree_distance; 
# 478
typedef False is_vector_space_distance; 
# 480
typedef T ElementType; 
# 481
typedef int ResultType; 
# 485
unsigned popcnt32(uint32_t n) const 
# 486
{ 
# 487
n -= ((n >> 1) & (1431655765)); 
# 488
n = ((n & (858993459)) + ((n >> 2) & (858993459))); 
# 489
return (((n + (n >> 4)) & (252645135)) * (16843009)) >> 24; 
# 490
} 
# 501 "/usr/include/opencv2/flann/dist.h" 3
template< class Iterator1, class Iterator2> ResultType 
# 502
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const 
# 503
{ 
# 515 "/usr/include/opencv2/flann/dist.h" 3
const uint32_t *pa = reinterpret_cast< const uint32_t *>(a); 
# 516
const uint32_t *pb = reinterpret_cast< const uint32_t *>(b); 
# 517
ResultType result = 0; 
# 518
size /= (sizeof(uint32_t) / sizeof(unsigned char)); 
# 519
for (size_t i = (0); i < size; ++i) { 
# 520
result += popcnt32((*pa) ^ (*pb)); 
# 521
++pa; 
# 522
++pb; 
# 523
}  
# 525
return result; 
# 526
} 
# 527
}; 
# 533
template< class T> 
# 534
struct HistIntersectionDistance { 
# 536
typedef True is_kdtree_distance; 
# 537
typedef True is_vector_space_distance; 
# 539
typedef T ElementType; 
# 540
typedef typename Accumulator< T> ::Type ResultType; 
# 545
template< class Iterator1, class Iterator2> ResultType 
# 546
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 547
{ 
# 548
ResultType result = (ResultType()); 
# 549
ResultType min0, min1, min2, min3; 
# 550
Iterator1 last = a + size; 
# 551
Iterator1 lastgroup = last - 3; 
# 554
while (a < lastgroup) { 
# 555
min0 = ((ResultType)(((a[0]) < (b[0])) ? a[0] : (b[0]))); 
# 556
min1 = ((ResultType)(((a[1]) < (b[1])) ? a[1] : (b[1]))); 
# 557
min2 = ((ResultType)(((a[2]) < (b[2])) ? a[2] : (b[2]))); 
# 558
min3 = ((ResultType)(((a[3]) < (b[3])) ? a[3] : (b[3]))); 
# 559
result += (((min0 + min1) + min2) + min3); 
# 560
a += 4; 
# 561
b += 4; 
# 562
if ((worst_dist > 0) && (result > worst_dist)) { 
# 563
return result; 
# 564
}  
# 565
}  
# 567
while (a < last) { 
# 568
min0 = ((ResultType)(((*a) < (*b)) ? *a : (*b))); 
# 569
result += min0; 
# 570
++a; 
# 571
++b; 
# 572
}  
# 573
return result; 
# 574
} 
# 579
template< class U, class V> ResultType 
# 580
accum_dist(const U &a, const V &b, int) const 
# 581
{ 
# 582
return (a < b) ? a : b; 
# 583
} 
# 584
}; 
# 588
template< class T> 
# 589
struct HellingerDistance { 
# 591
typedef True is_kdtree_distance; 
# 592
typedef True is_vector_space_distance; 
# 594
typedef T ElementType; 
# 595
typedef typename Accumulator< T> ::Type ResultType; 
# 600
template< class Iterator1, class Iterator2> ResultType 
# 601
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const 
# 602
{ 
# 603
ResultType result = (ResultType()); 
# 604
ResultType diff0, diff1, diff2, diff3; 
# 605
Iterator1 last = a + size; 
# 606
Iterator1 lastgroup = last - 3; 
# 609
while (a < lastgroup) { 
# 610
diff0 = (sqrt(static_cast< ResultType>(a[0])) - sqrt(static_cast< ResultType>(b[0]))); 
# 611
diff1 = (sqrt(static_cast< ResultType>(a[1])) - sqrt(static_cast< ResultType>(b[1]))); 
# 612
diff2 = (sqrt(static_cast< ResultType>(a[2])) - sqrt(static_cast< ResultType>(b[2]))); 
# 613
diff3 = (sqrt(static_cast< ResultType>(a[3])) - sqrt(static_cast< ResultType>(b[3]))); 
# 614
result += ((((diff0 * diff0) + (diff1 * diff1)) + (diff2 * diff2)) + (diff3 * diff3)); 
# 615
a += 4; 
# 616
b += 4; 
# 617
}  
# 618
while (a < last) { 
# 619
diff0 = (sqrt(static_cast< ResultType>(*(a++))) - sqrt(static_cast< ResultType>(*(b++)))); 
# 620
result += (diff0 * diff0); 
# 621
}  
# 622
return result; 
# 623
} 
# 628
template< class U, class V> ResultType 
# 629
accum_dist(const U &a, const V &b, int) const 
# 630
{ 
# 631
ResultType diff = sqrt(static_cast< ResultType>(a)) - sqrt(static_cast< ResultType>(b)); 
# 632
return diff * diff; 
# 633
} 
# 634
}; 
# 637
template< class T> 
# 638
struct ChiSquareDistance { 
# 640
typedef True is_kdtree_distance; 
# 641
typedef True is_vector_space_distance; 
# 643
typedef T ElementType; 
# 644
typedef typename Accumulator< T> ::Type ResultType; 
# 649
template< class Iterator1, class Iterator2> ResultType 
# 650
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 651
{ 
# 652
ResultType result = (ResultType()); 
# 653
ResultType sum, diff; 
# 654
Iterator1 last = a + size; 
# 656
while (a < last) { 
# 657
sum = ((ResultType)((*a) + (*b))); 
# 658
if (sum > 0) { 
# 659
diff = ((ResultType)((*a) - (*b))); 
# 660
result += ((diff * diff) / sum); 
# 661
}  
# 662
++a; 
# 663
++b; 
# 665
if ((worst_dist > 0) && (result > worst_dist)) { 
# 666
return result; 
# 667
}  
# 668
}  
# 669
return result; 
# 670
} 
# 675
template< class U, class V> ResultType 
# 676
accum_dist(const U &a, const V &b, int) const 
# 677
{ 
# 678
ResultType result = (ResultType()); 
# 679
ResultType sum, diff; 
# 681
sum = ((ResultType)(a + b)); 
# 682
if (sum > 0) { 
# 683
diff = ((ResultType)(a - b)); 
# 684
result = ((diff * diff) / sum); 
# 685
}  
# 686
return result; 
# 687
} 
# 688
}; 
# 691
template< class T> 
# 692
struct KL_Divergence { 
# 694
typedef True is_kdtree_distance; 
# 695
typedef True is_vector_space_distance; 
# 697
typedef T ElementType; 
# 698
typedef typename Accumulator< T> ::Type ResultType; 
# 703
template< class Iterator1, class Iterator2> ResultType 
# 704
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 705
{ 
# 706
ResultType result = (ResultType()); 
# 707
Iterator1 last = a + size; 
# 709
while (a < last) { 
# 710
if ((*b) != 0) { 
# 711
ResultType ratio = (ResultType)((*a) / (*b)); 
# 712
if (ratio > 0) { 
# 713
result += ((*a) * log(ratio)); 
# 714
}  
# 715
}  
# 716
++a; 
# 717
++b; 
# 719
if ((worst_dist > 0) && (result > worst_dist)) { 
# 720
return result; 
# 721
}  
# 722
}  
# 723
return result; 
# 724
} 
# 729
template< class U, class V> ResultType 
# 730
accum_dist(const U &a, const V &b, int) const 
# 731
{ 
# 732
ResultType result = (ResultType()); 
# 733
if ((*b) != 0) { 
# 734
ResultType ratio = (ResultType)(a / b); 
# 735
if (ratio > 0) { 
# 736
result = (a * log(ratio)); 
# 737
}  
# 738
}  
# 739
return result; 
# 740
} 
# 741
}; 
# 752 "/usr/include/opencv2/flann/dist.h" 3
template< class T> 
# 753
struct ZeroIterator { 
# 756
T operator*() 
# 757
{ 
# 758
return 0; 
# 759
} 
# 761
T operator[](int) 
# 762
{ 
# 763
return 0; 
# 764
} 
# 766
const ZeroIterator &operator++() 
# 767
{ 
# 768
return *this; 
# 769
} 
# 771
ZeroIterator operator++(int) 
# 772
{ 
# 773
return *this; 
# 774
} 
# 776
ZeroIterator &operator+=(int) 
# 777
{ 
# 778
return *this; 
# 779
} 
# 781
}; 
# 789
template< class Distance, class ElementType> 
# 790
struct squareDistance { 
# 792
typedef typename Distance::ResultType ResultType; 
# 793
ResultType operator()(ResultType dist) { return dist * dist; } 
# 794
}; 
# 797
template< class ElementType> 
# 798
struct squareDistance< L2_Simple< ElementType> , ElementType>  { 
# 800
typedef typename L2_Simple< ElementType> ::ResultType ResultType; 
# 801
ResultType operator()(ResultType dist) { return dist; } 
# 802
}; 
# 804
template< class ElementType> 
# 805
struct squareDistance< L2< ElementType> , ElementType>  { 
# 807
typedef typename L2< ElementType> ::ResultType ResultType; 
# 808
ResultType operator()(ResultType dist) { return dist; } 
# 809
}; 
# 812
template< class ElementType> 
# 813
struct squareDistance< MinkowskiDistance< ElementType> , ElementType>  { 
# 815
typedef typename MinkowskiDistance< ElementType> ::ResultType ResultType; 
# 816
ResultType operator()(ResultType dist) { return dist; } 
# 817
}; 
# 819
template< class ElementType> 
# 820
struct squareDistance< HellingerDistance< ElementType> , ElementType>  { 
# 822
typedef typename HellingerDistance< ElementType> ::ResultType ResultType; 
# 823
ResultType operator()(ResultType dist) { return dist; } 
# 824
}; 
# 826
template< class ElementType> 
# 827
struct squareDistance< ChiSquareDistance< ElementType> , ElementType>  { 
# 829
typedef typename ChiSquareDistance< ElementType> ::ResultType ResultType; 
# 830
ResultType operator()(ResultType dist) { return dist; } 
# 831
}; 
# 834
template< class Distance> typename Distance::ResultType 
# 835
ensureSquareDistance(typename Distance::ResultType dist) 
# 836
{ 
# 837
typedef typename Distance::ElementType ElementType; 
# 839
squareDistance< Distance, typename Distance::ElementType>  dummy; 
# 840
return dummy(dist); 
# 841
} 
# 849
template< class Distance, class ElementType> 
# 850
struct simpleDistance { 
# 852
typedef typename Distance::ResultType ResultType; 
# 853
ResultType operator()(ResultType dist) { return dist; } 
# 854
}; 
# 857
template< class ElementType> 
# 858
struct simpleDistance< L2_Simple< ElementType> , ElementType>  { 
# 860
typedef typename L2_Simple< ElementType> ::ResultType ResultType; 
# 861
ResultType operator()(ResultType dist) { return sqrt(dist); } 
# 862
}; 
# 864
template< class ElementType> 
# 865
struct simpleDistance< L2< ElementType> , ElementType>  { 
# 867
typedef typename L2< ElementType> ::ResultType ResultType; 
# 868
ResultType operator()(ResultType dist) { return sqrt(dist); } 
# 869
}; 
# 872
template< class ElementType> 
# 873
struct simpleDistance< MinkowskiDistance< ElementType> , ElementType>  { 
# 875
typedef typename MinkowskiDistance< ElementType> ::ResultType ResultType; 
# 876
ResultType operator()(ResultType dist) { return sqrt(dist); } 
# 877
}; 
# 879
template< class ElementType> 
# 880
struct simpleDistance< HellingerDistance< ElementType> , ElementType>  { 
# 882
typedef typename HellingerDistance< ElementType> ::ResultType ResultType; 
# 883
ResultType operator()(ResultType dist) { return sqrt(dist); } 
# 884
}; 
# 886
template< class ElementType> 
# 887
struct simpleDistance< ChiSquareDistance< ElementType> , ElementType>  { 
# 889
typedef typename ChiSquareDistance< ElementType> ::ResultType ResultType; 
# 890
ResultType operator()(ResultType dist) { return sqrt(dist); } 
# 891
}; 
# 894
template< class Distance> typename Distance::ResultType 
# 895
ensureSimpleDistance(typename Distance::ResultType dist) 
# 896
{ 
# 897
typedef typename Distance::ElementType ElementType; 
# 899
simpleDistance< Distance, typename Distance::ElementType>  dummy; 
# 900
return dummy(dist); 
# 901
} 
# 903
}
# 51 "/usr/include/opencv2/flann/dynamic_bitset.h" 3
namespace cvflann { 
# 57
class DynamicBitset { 
# 62
public: DynamicBitset() : size_((0)) 
# 63
{ 
# 64
} 
# 69
DynamicBitset(size_t sz) 
# 70
{ 
# 71
this->resize(sz); 
# 72
this->reset(); 
# 73
} 
# 77
void clear() 
# 78
{ 
# 79
std::fill((bitset_).begin(), (bitset_).end(), 0); 
# 80
} 
# 85
bool empty() const 
# 86
{ 
# 87
return (bitset_).empty(); 
# 88
} 
# 92
void reset() 
# 93
{ 
# 94
std::fill((bitset_).begin(), (bitset_).end(), 0); 
# 95
} 
# 100
void reset(size_t index) 
# 101
{ 
# 102
(bitset_)[index / cell_bit_size_] &= (~(((size_t)1) << (index % cell_bit_size_))); 
# 103
} 
# 111
void reset_block(size_t index) 
# 112
{ 
# 113
(bitset_)[index / cell_bit_size_] = (0); 
# 114
} 
# 119
void resize(size_t sz) 
# 120
{ 
# 121
(size_) = sz; 
# 122
(bitset_).resize((sz / cell_bit_size_) + (1)); 
# 123
} 
# 128
void set(size_t index) 
# 129
{ 
# 130
(bitset_)[index / cell_bit_size_] |= (((size_t)1) << (index % cell_bit_size_)); 
# 131
} 
# 135
size_t size() const 
# 136
{ 
# 137
return size_; 
# 138
} 
# 144
bool test(size_t index) const 
# 145
{ 
# 146
return ((bitset_)[index / cell_bit_size_] & (((size_t)1) << (index % cell_bit_size_))) != (0); 
# 147
} 
# 150
private: std::vector< unsigned long>  bitset_; 
# 151
size_t size_; 
# 152
static const unsigned cell_bit_size_ = ((8) * sizeof(size_t)); 
# 153
}; 
# 155
}
# 37 "/usr/include/opencv2/flann/heap.h" 3
namespace cvflann { 
# 47 "/usr/include/opencv2/flann/heap.h" 3
template< class T> 
# 48
class Heap { 
# 55
std::vector< T>  heap; 
# 56
int length; 
# 61
int count; 
# 73
public: Heap(int sz) 
# 74
{ 
# 75
(length) = sz; 
# 76
((heap).reserve(length)); 
# 77
(count) = 0; 
# 78
} 
# 84
int size() 
# 85
{ 
# 86
return count; 
# 87
} 
# 94
bool empty() 
# 95
{ 
# 96
return size() == 0; 
# 97
} 
# 102
void clear() 
# 103
{ 
# 104
((heap).clear()); 
# 105
(count) = 0; 
# 106
} 
# 108
struct CompareT { 
# 110
bool operator()(const T &t_1, const T &t_2) const 
# 111
{ 
# 112
return t_2 < t_1; 
# 113
} 
# 114
}; 
# 125 "/usr/include/opencv2/flann/heap.h" 3
void insert(T value) 
# 126
{ 
# 128
if ((count) == (length)) { 
# 129
return; 
# 130
}  
# 132
((heap).push_back(value)); 
# 133
static CompareT compareT; 
# 134
std::push_heap(((heap).begin()), ((heap).end()), compareT); 
# 135
++(count); 
# 136
} 
# 147 "/usr/include/opencv2/flann/heap.h" 3
bool popMin(T &value) 
# 148
{ 
# 149
if ((count) == 0) { 
# 150
return false; 
# 151
}  
# 153
value = ((heap)[0]); 
# 154
static CompareT compareT; 
# 155
std::pop_heap(((heap).begin()), ((heap).end()), compareT); 
# 156
((heap).pop_back()); 
# 157
--(count); 
# 159
return true; 
# 160
} 
# 161
}; 
# 163
}
# 38 "/usr/include/opencv2/flann/allocator.h" 3
namespace cvflann { 
# 48 "/usr/include/opencv2/flann/allocator.h" 3
template< class T> T *
# 49
allocate(size_t count = 1) 
# 50
{ 
# 51
T *mem = (T *)::malloc(sizeof(T) * count); 
# 52
return mem; 
# 53
} 
# 71 "/usr/include/opencv2/flann/allocator.h" 3
const size_t WORDSIZE = (16); 
# 72
const size_t BLOCKSIZE = (8192); 
# 74
class PooledAllocator { 
# 82
int remaining; 
# 83
void *base; 
# 84
void *loc; 
# 85
int blocksize; 
# 89
public: int usedMemory; 
# 90
int wastedMemory; 
# 95
PooledAllocator(int blockSize = BLOCKSIZE) 
# 96
{ 
# 97
(blocksize) = blockSize; 
# 98
(remaining) = 0; 
# 99
(base) = (__null); 
# 100
(loc) = (__null); 
# 102
(usedMemory) = 0; 
# 103
(wastedMemory) = 0; 
# 104
} 
# 109
~PooledAllocator() 
# 110
{ 
# 111
void *prev; 
# 113
while ((base) != (__null)) { 
# 114
prev = (*((void **)(base))); 
# 115
::free(base); 
# 116
(base) = prev; 
# 117
}  
# 118
} 
# 124
void *allocateMemory(int size) 
# 125
{ 
# 126
int blockSize; 
# 132
size = ((size + (WORDSIZE - (1))) & (~(WORDSIZE - (1)))); 
# 137
if (size > (remaining)) { 
# 139
(wastedMemory) += (remaining); 
# 142
blockSize = ((((size + sizeof(void *)) + (WORDSIZE - (1))) > BLOCKSIZE) ? (size + sizeof(void *)) + (WORDSIZE - (1)) : BLOCKSIZE); 
# 146
void *m = ::malloc(blockSize); 
# 147
if (!m) { 
# 148
fprintf(stderr, "Failed to allocate memory.\n"); 
# 149
return __null; 
# 150
}  
# 153
(((void **)m)[0]) = (base); 
# 154
(base) = m; 
# 156
int shift = 0; 
# 159
(remaining) = ((blockSize - sizeof(void *)) - shift); 
# 160
(loc) = ((((char *)m) + sizeof(void *)) + shift); 
# 161
}  
# 162
void *rloc = loc; 
# 163
(loc) = (((char *)(loc)) + size); 
# 164
(remaining) -= size; 
# 166
(usedMemory) += size; 
# 168
return rloc; 
# 169
} 
# 178 "/usr/include/opencv2/flann/allocator.h" 3
template< class T> T *
# 179
allocate(size_t count = 1) 
# 180
{ 
# 181
T *mem = (T *)this->allocateMemory((int)(sizeof(T) * count)); 
# 182
return mem; 
# 183
} 
# 186
private: PooledAllocator(const PooledAllocator &); 
# 187
PooledAllocator &operator=(const PooledAllocator &); 
# 188
}; 
# 190
}
# 40 "/usr/include/opencv2/flann/random.h" 3
namespace cvflann { 
# 43
inline int rand() 
# 44
{ 
# 47
int v = cv::theRNG().next() & (2147483647); 
# 54
return v; 
# 55
} 
# 61
inline void seed_random(unsigned seed) 
# 62
{ 
# 64
cv::theRNG() = ((cv::RNG)(seed)); 
# 68
} 
# 79 "/usr/include/opencv2/flann/random.h" 3
inline double rand_double(double high = (1.0), double low = 0) 
# 80
{ 
# 81
return low + ((high - low) * ((rand()) / ((2147483647) + (1.0)))); 
# 82
} 
# 90
inline int rand_int(int high = 2147483647, int low = 0) 
# 91
{ 
# 92
return low + ((int)(((double)(high - low)) * ((rand()) / ((2147483647) + (1.0))))); 
# 93
} 
# 99
class UniqueRandom { 
# 101
std::vector< int>  vals_; 
# 102
int size_; 
# 103
int counter_; 
# 111
public: UniqueRandom(int n) 
# 112
{ 
# 113
this->init(n); 
# 114
} 
# 120
void init(int n) 
# 121
{ 
# 123
(vals_).resize(n); 
# 124
(size_) = n; 
# 125
for (int i = 0; i < (size_); ++i) { (vals_)[i] = i; }  
# 129
cv::randShuffle(vals_); 
# 134
(counter_) = 0; 
# 135
} 
# 142
int next() 
# 143
{ 
# 144
if ((counter_) == (size_)) { 
# 145
return -1; 
# 146
} else 
# 147
{ 
# 148
return (vals_)[(counter_)++]; 
# 149
}  
# 150
} 
# 151
}; 
# 153
}
# 50 "/usr/include/opencv2/flann/kdtree_index.h" 3
namespace cvflann { 
# 53
struct KDTreeIndexParams : public IndexParams { 
# 55
KDTreeIndexParams(int trees = 4) 
# 56
{ 
# 57
(((*this)["algorithm"]) = (FLANN_INDEX_KDTREE)); 
# 58
(((*this)["trees"]) = trees); 
# 59
} 
# 60
}; 
# 69 "/usr/include/opencv2/flann/kdtree_index.h" 3
template< class Distance> 
# 70
class KDTreeIndex : public NNIndex< Distance>  { 
# 73
public: typedef typename Distance::ElementType ElementType; 
# 74
typedef typename Distance::ResultType DistanceType; 
# 84 "/usr/include/opencv2/flann/kdtree_index.h" 3
KDTreeIndex(const Matrix< typename Distance::ElementType>  &inputData, const ::cvflann::IndexParams &params = ::cvflann::KDTreeIndexParams(), Distance 
# 85
d = Distance()) : dataset_(inputData), index_params_(params), distance_(d) 
# 87
{ 
# 88
(size_) = ((dataset_).rows); 
# 89
(veclen_) = ((dataset_).cols); 
# 91
(trees_) = get_param(index_params_, "trees", 4); 
# 92
(tree_roots_) = (new NodePtr [trees_]); 
# 95
(vind_).resize(size_); 
# 96
for (::size_t i = (0); i < (size_); ++i) { 
# 97
(vind_)[i] = ((int)i); 
# 98
}  
# 100
(mean_) = (new DistanceType [veclen_]); 
# 101
(var_) = (new DistanceType [veclen_]); 
# 102
} 
# 105
KDTreeIndex(const KDTreeIndex &); 
# 106
KDTreeIndex &operator=(const KDTreeIndex &); 
# 111
~KDTreeIndex() 
# 112
{ 
# 113
if ((tree_roots_) != __null) { 
# 114
delete [] (tree_roots_); 
# 115
}  
# 116
delete [] (mean_); 
# 117
delete [] (var_); 
# 118
} 
# 123
void buildIndex() 
# 124
{ 
# 126
for (int i = 0; i < (trees_); i++) { 
# 129
cv::randShuffle(vind_); 
# 134
((tree_roots_)[i]) = divideTree(&(vind_)[0], (int)(size_)); 
# 135
}  
# 136
} 
# 139
::cvflann::flann_algorithm_t getType() const 
# 140
{ 
# 141
return FLANN_INDEX_KDTREE; 
# 142
} 
# 145
void saveIndex(::FILE *stream) 
# 146
{ 
# 147
save_value(stream, trees_); 
# 148
for (int i = 0; i < (trees_); ++i) { 
# 149
save_tree(stream, (tree_roots_)[i]); 
# 150
}  
# 151
} 
# 155
void loadIndex(::FILE *stream) 
# 156
{ 
# 157
load_value(stream, trees_); 
# 158
if ((tree_roots_) != __null) { 
# 159
delete [] (tree_roots_); 
# 160
}  
# 161
(tree_roots_) = (new NodePtr [trees_]); 
# 162
for (int i = 0; i < (trees_); ++i) { 
# 163
load_tree(stream, (tree_roots_)[i]); 
# 164
}  
# 166
(index_params_)["algorithm"] = getType(); 
# 167
(index_params_)["trees"] = (tree_roots_); 
# 168
} 
# 173
::size_t size() const 
# 174
{ 
# 175
return size_; 
# 176
} 
# 181
::size_t veclen() const 
# 182
{ 
# 183
return veclen_; 
# 184
} 
# 190
int usedMemory() const 
# 191
{ 
# 192
return (int)((((pool_).usedMemory) + ((pool_).wastedMemory)) + (((dataset_).rows) * sizeof(int))); 
# 193
} 
# 204 "/usr/include/opencv2/flann/kdtree_index.h" 3
void findNeighbors(ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, const ::cvflann::SearchParams &searchParams) 
# 205
{ 
# 206
int maxChecks = get_param(searchParams, "checks", 32); 
# 207
float epsError = (1) + get_param(searchParams, "eps", (0.0F)); 
# 209
if (maxChecks == (FLANN_CHECKS_UNLIMITED)) { 
# 210
getExactNeighbors(result, vec, epsError); 
# 211
} else 
# 212
{ 
# 213
getNeighbors(result, vec, maxChecks, epsError); 
# 214
}  
# 215
} 
# 217
::cvflann::IndexParams getParameters() const 
# 218
{ 
# 219
return index_params_; 
# 220
} 
# 226
private: struct Node { 
# 231
int divfeat; 
# 235
DistanceType divval; 
# 239
Node *child1, *child2; 
# 240
}; 
# 241
typedef Node *NodePtr; 
# 242
typedef BranchStruct< Node *, typename Distance::ResultType>  BranchSt; 
# 243
typedef BranchSt *Branch; 
# 247
void save_tree(::FILE *stream, NodePtr tree) 
# 248
{ 
# 249
save_value(stream, *tree); 
# 250
if ((tree->child1) != __null) { 
# 251
save_tree(stream, (tree->child1)); 
# 252
}  
# 253
if ((tree->child2) != __null) { 
# 254
save_tree(stream, (tree->child2)); 
# 255
}  
# 256
} 
# 259
void load_tree(::FILE *stream, NodePtr &tree) 
# 260
{ 
# 261
tree = ((pool_).template allocate< Node> ()); 
# 262
load_value(stream, *tree); 
# 263
if ((tree->child1) != __null) { 
# 264
load_tree(stream, (tree->child1)); 
# 265
}  
# 266
if ((tree->child2) != __null) { 
# 267
load_tree(stream, (tree->child2)); 
# 268
}  
# 269
} 
# 281 "/usr/include/opencv2/flann/kdtree_index.h" 3
NodePtr divideTree(int *ind, int count) 
# 282
{ 
# 283
NodePtr node = ((pool_).template allocate< Node> ()); 
# 286
if (count == 1) { 
# 287
(node->child1) = ((node->child2) = __null); 
# 288
(node->divfeat) = (*ind); 
# 289
} else 
# 290
{ 
# 291
int idx; 
# 292
int cutfeat; 
# 293
DistanceType cutval; 
# 294
meanSplit(ind, count, idx, cutfeat, cutval); 
# 296
(node->divfeat) = cutfeat; 
# 297
(node->divval) = cutval; 
# 298
(node->child1) = divideTree(ind, idx); 
# 299
(node->child2) = divideTree(ind + idx, count - idx); 
# 300
}  
# 302
return node; 
# 303
} 
# 311
void meanSplit(int *ind, int count, int &index, int &cutfeat, DistanceType &cutval) 
# 312
{ 
# 313
memset(mean_, 0, (veclen_) * sizeof(DistanceType)); 
# 314
memset(var_, 0, (veclen_) * sizeof(DistanceType)); 
# 319
int cnt = ::std::min(((int)(SAMPLE_MEAN)) + 1, count); 
# 320
for (int j = 0; j < cnt; ++j) { 
# 321
ElementType *v = (dataset_)[ind[j]]; 
# 322
for (::size_t k = (0); k < (veclen_); ++k) { 
# 323
((mean_)[k]) += (v[k]); 
# 324
}  
# 325
}  
# 326
for (::size_t k = (0); k < (veclen_); ++k) { 
# 327
((mean_)[k]) /= cnt; 
# 328
}  
# 331
for (int j = 0; j < cnt; ++j) { 
# 332
ElementType *v = (dataset_)[ind[j]]; 
# 333
for (::size_t k = (0); k < (veclen_); ++k) { 
# 334
DistanceType dist = (v[k]) - ((mean_)[k]); 
# 335
((var_)[k]) += (dist * dist); 
# 336
}  
# 337
}  
# 339
cutfeat = selectDivision(var_); 
# 340
cutval = ((mean_)[cutfeat]); 
# 342
int lim1, lim2; 
# 343
planeSplit(ind, count, cutfeat, cutval, lim1, lim2); 
# 345
if (lim1 > (count / 2)) { index = lim1; } else { 
# 346
if (lim2 < (count / 2)) { index = lim2; } else { 
# 347
index = (count / 2); }  }  
# 352
if ((lim1 == count) || (lim2 == 0)) { index = (count / 2); }  
# 353
} 
# 360
int selectDivision(DistanceType *v) 
# 361
{ 
# 362
int num = 0; 
# 363
::size_t topind[RAND_DIM]; 
# 366
for (::size_t i = (0); i < (veclen_); ++i) { 
# 367
if ((num < (RAND_DIM)) || ((v[i]) > (v[(topind)[num - 1]]))) { 
# 369
if (num < (RAND_DIM)) { 
# 370
((topind)[num++]) = i; 
# 371
} else 
# 372
{ 
# 373
((topind)[num - 1]) = i; 
# 374
}  
# 376
int j = num - 1; 
# 377
while ((j > 0) && ((v[(topind)[j]]) > (v[(topind)[j - 1]]))) { 
# 378
::std::swap((topind)[j], (topind)[j - 1]); 
# 379
--j; 
# 380
}  
# 381
}  
# 382
}  
# 384
int rnd = rand_int(num); 
# 385
return (int)((topind)[rnd]); 
# 386
} 
# 398 "/usr/include/opencv2/flann/kdtree_index.h" 3
void planeSplit(int *ind, int count, int cutfeat, DistanceType cutval, int &lim1, int &lim2) 
# 399
{ 
# 401
int left = 0; 
# 402
int right = count - 1; 
# 403
for (; ;) { 
# 404
while ((left <= right) && ((((dataset_)[ind[left]])[cutfeat]) < cutval)) { ++left; }  
# 405
while ((left <= right) && ((((dataset_)[ind[right]])[cutfeat]) >= cutval)) { --right; }  
# 406
if (left > right) { break; }  
# 407
std::swap(ind[left], ind[right]); ++left; --right; 
# 408
}  
# 409
lim1 = left; 
# 410
right = (count - 1); 
# 411
for (; ;) { 
# 412
while ((left <= right) && ((((dataset_)[ind[left]])[cutfeat]) <= cutval)) { ++left; }  
# 413
while ((left <= right) && ((((dataset_)[ind[right]])[cutfeat]) > cutval)) { --right; }  
# 414
if (left > right) { break; }  
# 415
std::swap(ind[left], ind[right]); ++left; --right; 
# 416
}  
# 417
lim2 = left; 
# 418
} 
# 424
void getExactNeighbors(ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, float epsError) 
# 425
{ 
# 428
if ((trees_) > 1) { 
# 429
fprintf(stderr, "It doesn\'t make any sense to use more than one tree for exact search"); 
# 430
}  
# 431
if ((trees_) > 0) { 
# 432
searchLevelExact(result, vec, (tree_roots_)[0], (0.0), epsError); 
# 433
}  
# 434
((result.full())) ? static_cast< void>(0) : __assert_fail("result.full()", "/usr/include/opencv2/flann/kdtree_index.h", 434, __PRETTY_FUNCTION__); 
# 435
} 
# 442
void getNeighbors(ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, int maxCheck, float epsError) 
# 443
{ 
# 444
int i; 
# 445
BranchSt branch; 
# 447
int checkCount = 0; 
# 448
Heap< BranchStruct< Node *, typename Distance::ResultType> >  *heap = new Heap< BranchStruct< Node *, typename Distance::ResultType> > ((int)(size_)); 
# 449
::cvflann::DynamicBitset checked(size_); 
# 452
for (i = 0; i < (trees_); ++i) { 
# 453
searchLevel(result, vec, (tree_roots_)[i], 0, checkCount, maxCheck, epsError, heap, checked); 
# 454
}  
# 457
while ((heap->popMin(branch)) && ((checkCount < maxCheck) || (!(result.full())))) { 
# 458
searchLevel(result, vec, (branch.node), (branch.mindist), checkCount, maxCheck, epsError, heap, checked); 
# 459
}  
# 461
delete heap; 
# 463
((result.full())) ? static_cast< void>(0) : __assert_fail("result.full()", "/usr/include/opencv2/flann/kdtree_index.h", 463, __PRETTY_FUNCTION__); 
# 464
} 
# 472
void searchLevel(ResultSet< typename Distance::ResultType>  &result_set, const ElementType *vec, NodePtr node, DistanceType mindist, int &checkCount, int maxCheck, float 
# 473
epsError, Heap< BranchStruct< Node *, typename Distance::ResultType> >  *heap, ::cvflann::DynamicBitset &checked) 
# 474
{ 
# 475
if ((result_set.worstDist()) < mindist) { 
# 477
return; 
# 478
}  
# 481
if (((node->child1) == __null) && ((node->child2) == __null)) { 
# 486
int index = ((node->divfeat)); 
# 487
if (checked.test(index) || ((checkCount >= maxCheck) && (result_set.full()))) { return; }  
# 488
checked.set(index); 
# 489
checkCount++; 
# 491
DistanceType dist = (distance_)((dataset_)[index], vec, veclen_); 
# 492
(result_set.addPoint(dist, index)); 
# 494
return; 
# 495
}  
# 498
ElementType val = vec[node->divfeat]; 
# 499
DistanceType diff = val - (node->divval); 
# 500
NodePtr bestChild = (diff < 0) ? node->child1 : (node->child2); 
# 501
NodePtr otherChild = (diff < 0) ? node->child2 : (node->child1); 
# 511 "/usr/include/opencv2/flann/kdtree_index.h" 3
DistanceType new_distsq = mindist + ((distance_).accum_dist(val, (node->divval), (node->divfeat))); 
# 513
if (((new_distsq * epsError) < (result_set.worstDist())) || (!(result_set.full()))) { 
# 514
(heap->insert(BranchSt(otherChild, new_distsq))); 
# 515
}  
# 518
searchLevel(result_set, vec, bestChild, mindist, checkCount, maxCheck, epsError, heap, checked); 
# 519
} 
# 524
void searchLevelExact(ResultSet< typename Distance::ResultType>  &result_set, const ElementType *vec, Node *const node, DistanceType mindist, const float epsError) 
# 525
{ 
# 527
if (((node->child1) == __null) && ((node->child2) == __null)) { 
# 528
int index = ((node->divfeat)); 
# 529
DistanceType dist = (distance_)((dataset_)[index], vec, veclen_); 
# 530
(result_set.addPoint(dist, index)); 
# 531
return; 
# 532
}  
# 535
ElementType val = vec[node->divfeat]; 
# 536
DistanceType diff = val - (node->divval); 
# 537
NodePtr bestChild = (diff < 0) ? node->child1 : (node->child2); 
# 538
NodePtr otherChild = (diff < 0) ? node->child2 : (node->child1); 
# 548 "/usr/include/opencv2/flann/kdtree_index.h" 3
DistanceType new_distsq = mindist + ((distance_).accum_dist(val, (node->divval), (node->divfeat))); 
# 551
searchLevelExact(result_set, vec, bestChild, mindist, epsError); 
# 553
if ((new_distsq * epsError) <= (result_set.worstDist())) { 
# 554
searchLevelExact(result_set, vec, otherChild, new_distsq, epsError); 
# 555
}  
# 556
} 
# 562
enum { 
# 568
SAMPLE_MEAN = 100, 
# 576
RAND_DIM = 5
# 577
}; 
# 583
int trees_; 
# 588
::std::vector< int>  vind_; 
# 593
const Matrix< typename Distance::ElementType>  dataset_; 
# 595
::cvflann::IndexParams index_params_; 
# 597
::size_t size_; 
# 598
::size_t veclen_; 
# 601
DistanceType *mean_; 
# 602
DistanceType *var_; 
# 608
NodePtr *tree_roots_; 
# 617 "/usr/include/opencv2/flann/kdtree_index.h" 3
::cvflann::PooledAllocator pool_; 
# 619
Distance distance_; 
# 622
}; 
# 624
}
# 48 "/usr/include/opencv2/flann/kdtree_single_index.h" 3
namespace cvflann { 
# 51
struct KDTreeSingleIndexParams : public IndexParams { 
# 53
KDTreeSingleIndexParams(int leaf_max_size = 10, bool reorder = true, int dim = -1) 
# 54
{ 
# 55
(((*this)["algorithm"]) = (FLANN_INDEX_KDTREE_SINGLE)); 
# 56
(((*this)["leaf_max_size"]) = leaf_max_size); 
# 57
(((*this)["reorder"]) = reorder); 
# 58
(((*this)["dim"]) = dim); 
# 59
} 
# 60
}; 
# 69 "/usr/include/opencv2/flann/kdtree_single_index.h" 3
template< class Distance> 
# 70
class KDTreeSingleIndex : public NNIndex< Distance>  { 
# 73
public: typedef typename Distance::ElementType ElementType; 
# 74
typedef typename Distance::ResultType DistanceType; 
# 84 "/usr/include/opencv2/flann/kdtree_single_index.h" 3
KDTreeSingleIndex(const Matrix< typename Distance::ElementType>  &inputData, const ::cvflann::IndexParams &params = ::cvflann::KDTreeSingleIndexParams(), Distance 
# 85
d = Distance()) : dataset_(inputData), index_params_(params), distance_(d) 
# 87
{ 
# 88
(size_) = ((dataset_).rows); 
# 89
(dim_) = ((dataset_).cols); 
# 90
(root_node_) = 0; 
# 91
int dim_param = get_param(params, "dim", -1); 
# 92
if (dim_param > 0) { (dim_) = dim_param; }  
# 93
(leaf_max_size_) = get_param(params, "leaf_max_size", 10); 
# 94
(reorder_) = get_param(params, "reorder", true); 
# 97
(vind_).resize(size_); 
# 98
for (::size_t i = (0); i < (size_); i++) { 
# 99
(vind_)[i] = ((int)i); 
# 100
}  
# 101
} 
# 103
KDTreeSingleIndex(const KDTreeSingleIndex &); 
# 104
KDTreeSingleIndex &operator=(const KDTreeSingleIndex &); 
# 109
~KDTreeSingleIndex() 
# 110
{ 
# 111
if (reorder_) { delete [] ((data_).data); }  
# 112
} 
# 117
void buildIndex() 
# 118
{ 
# 119
computeBoundingBox(root_bbox_); 
# 120
(root_node_) = divideTree(0, (int)(size_), root_bbox_); 
# 122
if (reorder_) { 
# 123
delete [] ((data_).data); 
# 124
(data_) = Matrix< typename Distance::ElementType> (new ElementType [(size_) * (dim_)], size_, dim_); 
# 125
for (::size_t i = (0); i < (size_); ++i) { 
# 126
for (::size_t j = (0); j < (dim_); ++j) { 
# 127
(((data_)[i])[j]) = (((dataset_)[(vind_)[i]])[j]); 
# 128
}  
# 129
}  
# 130
} else 
# 131
{ 
# 132
(data_) = (dataset_); 
# 133
}  
# 134
} 
# 136
::cvflann::flann_algorithm_t getType() const 
# 137
{ 
# 138
return FLANN_INDEX_KDTREE_SINGLE; 
# 139
} 
# 142
void saveIndex(::FILE *stream) 
# 143
{ 
# 144
save_value(stream, size_); 
# 145
save_value(stream, dim_); 
# 146
save_value(stream, root_bbox_); 
# 147
save_value(stream, reorder_); 
# 148
save_value(stream, leaf_max_size_); 
# 149
save_value(stream, vind_); 
# 150
if (reorder_) { 
# 151
save_value(stream, data_); 
# 152
}  
# 153
save_tree(stream, root_node_); 
# 154
} 
# 157
void loadIndex(::FILE *stream) 
# 158
{ 
# 159
load_value(stream, size_); 
# 160
load_value(stream, dim_); 
# 161
load_value(stream, root_bbox_); 
# 162
load_value(stream, reorder_); 
# 163
load_value(stream, leaf_max_size_); 
# 164
load_value(stream, vind_); 
# 165
if (reorder_) { 
# 166
load_value(stream, data_); 
# 167
} else 
# 168
{ 
# 169
(data_) = (dataset_); 
# 170
}  
# 171
load_tree(stream, root_node_); 
# 174
(index_params_)["algorithm"] = getType(); 
# 175
(((index_params_)["leaf_max_size"]) = (leaf_max_size_)); 
# 176
(((index_params_)["reorder"]) = (reorder_)); 
# 177
} 
# 182
::size_t size() const 
# 183
{ 
# 184
return size_; 
# 185
} 
# 190
::size_t veclen() const 
# 191
{ 
# 192
return dim_; 
# 193
} 
# 199
int usedMemory() const 
# 200
{ 
# 201
return (int)((((pool_).usedMemory) + ((pool_).wastedMemory)) + (((dataset_).rows) * sizeof(int))); 
# 202
} 
# 213 "/usr/include/opencv2/flann/kdtree_single_index.h" 3
void knnSearch(const Matrix< typename Distance::ElementType>  &queries, ::cvflann::Matrix< int>  &indices, Matrix< typename Distance::ResultType>  &dists, int knn, const ::cvflann::SearchParams &params) 
# 214
{ 
# 215
((queries.cols) == veclen()) ? static_cast< void>(0) : __assert_fail("queries.cols == veclen()", "/usr/include/opencv2/flann/kdtree_single_index.h", 215, __PRETTY_FUNCTION__); 
# 216
((indices.rows) >= (queries.rows)) ? static_cast< void>(0) : __assert_fail("indices.rows >= queries.rows", "/usr/include/opencv2/flann/kdtree_single_index.h", 216, __PRETTY_FUNCTION__); 
# 217
((dists.rows) >= (queries.rows)) ? static_cast< void>(0) : __assert_fail("dists.rows >= queries.rows", "/usr/include/opencv2/flann/kdtree_single_index.h", 217, __PRETTY_FUNCTION__); 
# 218
(((int)(indices.cols)) >= knn) ? static_cast< void>(0) : __assert_fail("int(indices.cols) >= knn", "/usr/include/opencv2/flann/kdtree_single_index.h", 218, __PRETTY_FUNCTION__); 
# 219
(((int)(dists.cols)) >= knn) ? static_cast< void>(0) : __assert_fail("int(dists.cols) >= knn", "/usr/include/opencv2/flann/kdtree_single_index.h", 219, __PRETTY_FUNCTION__); 
# 221
KNNSimpleResultSet< typename Distance::ResultType>  resultSet(knn); 
# 222
for (::size_t i = (0); i < (queries.rows); i++) { 
# 223
(resultSet.init(indices[i], dists[i])); 
# 224
findNeighbors(resultSet, queries[i], params); 
# 225
}  
# 226
} 
# 228
::cvflann::IndexParams getParameters() const 
# 229
{ 
# 230
return index_params_; 
# 231
} 
# 242 "/usr/include/opencv2/flann/kdtree_single_index.h" 3
void findNeighbors(ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, const ::cvflann::SearchParams &searchParams) 
# 243
{ 
# 244
float epsError = (1) + get_param(searchParams, "eps", (0.0F)); 
# 246
::std::vector< typename Distance::ResultType>  dists(dim_, 0); 
# 247
DistanceType distsq = computeInitialDistances(vec, dists); 
# 248
searchLevel(result, vec, root_node_, distsq, dists, epsError); 
# 249
} 
# 255
private: struct Node { 
# 260
int left, right; 
# 264
int divfeat; 
# 268
DistanceType divlow, divhigh; 
# 272
Node *child1, *child2; 
# 273
}; 
# 274
typedef Node *NodePtr; 
# 277
struct Interval { 
# 279
DistanceType low, high; 
# 280
}; 
# 282
typedef ::std::vector< Interval>  BoundingBox; 
# 284
typedef BranchStruct< Node *, typename Distance::ResultType>  BranchSt; 
# 285
typedef BranchSt *Branch; 
# 290
void save_tree(::FILE *stream, NodePtr tree) 
# 291
{ 
# 292
save_value(stream, *tree); 
# 293
if ((tree->child1) != __null) { 
# 294
save_tree(stream, (tree->child1)); 
# 295
}  
# 296
if ((tree->child2) != __null) { 
# 297
save_tree(stream, (tree->child2)); 
# 298
}  
# 299
} 
# 302
void load_tree(::FILE *stream, NodePtr &tree) 
# 303
{ 
# 304
tree = ((pool_).template allocate< Node> ()); 
# 305
load_value(stream, *tree); 
# 306
if ((tree->child1) != __null) { 
# 307
load_tree(stream, (tree->child1)); 
# 308
}  
# 309
if ((tree->child2) != __null) { 
# 310
load_tree(stream, (tree->child2)); 
# 311
}  
# 312
} 
# 315
void computeBoundingBox(BoundingBox &bbox) 
# 316
{ 
# 317
(bbox.resize(dim_)); 
# 318
for (::size_t i = (0); i < (dim_); ++i) { 
# 319
((bbox[i]).low) = ((DistanceType)(((dataset_)[0])[i])); 
# 320
((bbox[i]).high) = ((DistanceType)(((dataset_)[0])[i])); 
# 321
}  
# 322
for (::size_t k = (1); k < ((dataset_).rows); ++k) { 
# 323
for (::size_t i = (0); i < (dim_); ++i) { 
# 324
if ((((dataset_)[k])[i]) < ((bbox[i]).low)) { ((bbox[i]).low) = ((DistanceType)(((dataset_)[k])[i])); }  
# 325
if ((((dataset_)[k])[i]) > ((bbox[i]).high)) { ((bbox[i]).high) = ((DistanceType)(((dataset_)[k])[i])); }  
# 326
}  
# 327
}  
# 328
} 
# 340 "/usr/include/opencv2/flann/kdtree_single_index.h" 3
NodePtr divideTree(int left, int right, BoundingBox &bbox) 
# 341
{ 
# 342
NodePtr node = ((pool_).template allocate< Node> ()); 
# 345
if ((right - left) <= (leaf_max_size_)) { 
# 346
(node->child1) = ((node->child2) = __null); 
# 347
(node->left) = left; 
# 348
(node->right) = right; 
# 351
for (::size_t i = (0); i < (dim_); ++i) { 
# 352
((bbox[i]).low) = ((DistanceType)(((dataset_)[(vind_)[left]])[i])); 
# 353
((bbox[i]).high) = ((DistanceType)(((dataset_)[(vind_)[left]])[i])); 
# 354
}  
# 355
for (int k = left + 1; k < right; ++k) { 
# 356
for (::size_t i = (0); i < (dim_); ++i) { 
# 357
if (((bbox[i]).low) > (((dataset_)[(vind_)[k]])[i])) { ((bbox[i]).low) = ((DistanceType)(((dataset_)[(vind_)[k]])[i])); }  
# 358
if (((bbox[i]).high) < (((dataset_)[(vind_)[k]])[i])) { ((bbox[i]).high) = ((DistanceType)(((dataset_)[(vind_)[k]])[i])); }  
# 359
}  
# 360
}  
# 361
} else 
# 362
{ 
# 363
int idx; 
# 364
int cutfeat; 
# 365
DistanceType cutval; 
# 366
middleSplit_((&(vind_)[0]) + left, right - left, idx, cutfeat, cutval, bbox); 
# 368
(node->divfeat) = cutfeat; 
# 370
BoundingBox left_bbox(bbox); 
# 371
((left_bbox[cutfeat]).high) = cutval; 
# 372
(node->child1) = divideTree(left, left + idx, left_bbox); 
# 374
BoundingBox right_bbox(bbox); 
# 375
((right_bbox[cutfeat]).low) = cutval; 
# 376
(node->child2) = divideTree(left + idx, right, right_bbox); 
# 378
(node->divlow) = ((left_bbox[cutfeat]).high); 
# 379
(node->divhigh) = ((right_bbox[cutfeat]).low); 
# 381
for (::size_t i = (0); i < (dim_); ++i) { 
# 382
((bbox[i]).low) = ::std::min(((left_bbox[i]).low), ((right_bbox[i]).low)); 
# 383
((bbox[i]).high) = ::std::max(((left_bbox[i]).high), ((right_bbox[i]).high)); 
# 384
}  
# 385
}  
# 387
return node; 
# 388
} 
# 390
void computeMinMax(int *ind, int count, int dim, ElementType &min_elem, ElementType &max_elem) 
# 391
{ 
# 392
min_elem = (((dataset_)[ind[0]])[dim]); 
# 393
max_elem = (((dataset_)[ind[0]])[dim]); 
# 394
for (int i = 1; i < count; ++i) { 
# 395
ElementType val = ((dataset_)[ind[i]])[dim]; 
# 396
if (val < min_elem) { min_elem = val; }  
# 397
if (val > max_elem) { max_elem = val; }  
# 398
}  
# 399
} 
# 401
void middleSplit(int *ind, int count, int &index, int &cutfeat, DistanceType &cutval, const BoundingBox &bbox) 
# 402
{ 
# 404
ElementType max_span = ((bbox[0]).high) - ((bbox[0]).low); 
# 405
cutfeat = 0; 
# 406
cutval = ((((bbox[0]).high) + ((bbox[0]).low)) / 2); 
# 407
for (::size_t i = (1); i < (dim_); ++i) { 
# 408
ElementType span = ((bbox[i]).high) - ((bbox[i]).low); 
# 409
if (span > max_span) { 
# 410
max_span = span; 
# 411
cutfeat = i; 
# 412
cutval = ((((bbox[i]).high) + ((bbox[i]).low)) / 2); 
# 413
}  
# 414
}  
# 417
ElementType min_elem, max_elem; 
# 418
computeMinMax(ind, count, cutfeat, min_elem, max_elem); 
# 419
cutval = ((min_elem + max_elem) / 2); 
# 420
max_span = (max_elem - min_elem); 
# 423
::size_t k = cutfeat; 
# 424
for (::size_t i = (0); i < (dim_); ++i) { { 
# 425
if (i == k) { continue; }  
# 426
ElementType span = ((bbox[i]).high) - ((bbox[i]).low); 
# 427
if (span > max_span) { 
# 428
computeMinMax(ind, count, i, min_elem, max_elem); 
# 429
span = (max_elem - min_elem); 
# 430
if (span > max_span) { 
# 431
max_span = span; 
# 432
cutfeat = i; 
# 433
cutval = ((min_elem + max_elem) / 2); 
# 434
}  
# 435
}  
# 436
} }  
# 437
int lim1, lim2; 
# 438
planeSplit(ind, count, cutfeat, cutval, lim1, lim2); 
# 440
if (lim1 > (count / 2)) { index = lim1; } else { 
# 441
if (lim2 < (count / 2)) { index = lim2; } else { 
# 442
index = (count / 2); }  }  
# 443
} 
# 446
void middleSplit_(int *ind, int count, int &index, int &cutfeat, DistanceType &cutval, const BoundingBox &bbox) 
# 447
{ 
# 448
const float EPS = (9.999999747e-06F); 
# 449
DistanceType max_span = ((bbox[0]).high) - ((bbox[0]).low); 
# 450
for (::size_t i = (1); i < (dim_); ++i) { 
# 451
DistanceType span = ((bbox[i]).high) - ((bbox[i]).low); 
# 452
if (span > max_span) { 
# 453
max_span = span; 
# 454
}  
# 455
}  
# 456
DistanceType max_spread = (-1); 
# 457
cutfeat = 0; 
# 458
for (::size_t i = (0); i < (dim_); ++i) { 
# 459
DistanceType span = ((bbox[i]).high) - ((bbox[i]).low); 
# 460
if (span > ((DistanceType)(((1) - EPS) * max_span))) { 
# 461
ElementType min_elem, max_elem; 
# 462
computeMinMax(ind, count, cutfeat, min_elem, max_elem); 
# 463
DistanceType spread = (DistanceType)(max_elem - min_elem); 
# 464
if (spread > max_spread) { 
# 465
cutfeat = ((int)i); 
# 466
max_spread = spread; 
# 467
}  
# 468
}  
# 469
}  
# 471
DistanceType split_val = (((bbox[cutfeat]).low) + ((bbox[cutfeat]).high)) / 2; 
# 472
ElementType min_elem, max_elem; 
# 473
computeMinMax(ind, count, cutfeat, min_elem, max_elem); 
# 475
if (split_val < min_elem) { cutval = ((DistanceType)min_elem); } else { 
# 476
if (split_val > max_elem) { cutval = ((DistanceType)max_elem); } else { 
# 477
cutval = split_val; }  }  
# 479
int lim1, lim2; 
# 480
planeSplit(ind, count, cutfeat, cutval, lim1, lim2); 
# 482
if (lim1 > (count / 2)) { index = lim1; } else { 
# 483
if (lim2 < (count / 2)) { index = lim2; } else { 
# 484
index = (count / 2); }  }  
# 485
} 
# 497 "/usr/include/opencv2/flann/kdtree_single_index.h" 3
void planeSplit(int *ind, int count, int cutfeat, DistanceType cutval, int &lim1, int &lim2) 
# 498
{ 
# 500
int left = 0; 
# 501
int right = count - 1; 
# 502
for (; ;) { 
# 503
while ((left <= right) && ((((dataset_)[ind[left]])[cutfeat]) < cutval)) { ++left; }  
# 504
while ((left <= right) && ((((dataset_)[ind[right]])[cutfeat]) >= cutval)) { --right; }  
# 505
if (left > right) { break; }  
# 506
std::swap(ind[left], ind[right]); ++left; --right; 
# 507
}  
# 511
lim1 = left; 
# 512
right = (count - 1); 
# 513
for (; ;) { 
# 514
while ((left <= right) && ((((dataset_)[ind[left]])[cutfeat]) <= cutval)) { ++left; }  
# 515
while ((left <= right) && ((((dataset_)[ind[right]])[cutfeat]) > cutval)) { --right; }  
# 516
if (left > right) { break; }  
# 517
std::swap(ind[left], ind[right]); ++left; --right; 
# 518
}  
# 519
lim2 = left; 
# 520
} 
# 522
DistanceType computeInitialDistances(const ElementType *vec, ::std::vector< typename Distance::ResultType>  &dists) 
# 523
{ 
# 524
DistanceType distsq = ((0.0)); 
# 526
for (::size_t i = (0); i < (dim_); ++i) { 
# 527
if ((vec[i]) < (((root_bbox_)[i]).low)) { 
# 528
(dists[i]) = ((distance_).accum_dist(vec[i], (((root_bbox_)[i]).low), (int)i)); 
# 529
distsq += (dists[i]); 
# 530
}  
# 531
if ((vec[i]) > (((root_bbox_)[i]).high)) { 
# 532
(dists[i]) = ((distance_).accum_dist(vec[i], (((root_bbox_)[i]).high), (int)i)); 
# 533
distsq += (dists[i]); 
# 534
}  
# 535
}  
# 537
return distsq; 
# 538
} 
# 543
void searchLevel(ResultSet< typename Distance::ResultType>  &result_set, const ElementType *vec, Node *const node, DistanceType mindistsq, ::std::vector< typename Distance::ResultType>  &
# 544
dists, const float epsError) 
# 545
{ 
# 547
if (((node->child1) == __null) && ((node->child2) == __null)) { 
# 548
DistanceType worst_dist = (result_set.worstDist()); 
# 549
for (int i = ((node->left)); i < (node->right); ++i) { 
# 550
int index = (reorder_) ? i : (vind_)[i]; 
# 551
DistanceType dist = (distance_)(vec, (data_)[index], dim_, worst_dist); 
# 552
if (dist < worst_dist) { 
# 553
(result_set.addPoint(dist, (vind_)[i])); 
# 554
}  
# 555
}  
# 556
return; 
# 557
}  
# 560
int idx = ((node->divfeat)); 
# 561
ElementType val = vec[idx]; 
# 562
DistanceType diff1 = val - (node->divlow); 
# 563
DistanceType diff2 = val - (node->divhigh); 
# 565
NodePtr bestChild; 
# 566
NodePtr otherChild; 
# 567
DistanceType cut_dist; 
# 568
if ((diff1 + diff2) < 0) { 
# 569
bestChild = (node->child1); 
# 570
otherChild = (node->child2); 
# 571
cut_dist = ((distance_).accum_dist(val, (node->divhigh), idx)); 
# 572
} else 
# 573
{ 
# 574
bestChild = (node->child2); 
# 575
otherChild = (node->child1); 
# 576
cut_dist = ((distance_).accum_dist(val, (node->divlow), idx)); 
# 577
}  
# 580
searchLevel(result_set, vec, bestChild, mindistsq, dists, epsError); 
# 582
DistanceType dst = dists[idx]; 
# 583
mindistsq = ((mindistsq + cut_dist) - dst); 
# 584
(dists[idx]) = cut_dist; 
# 585
if ((mindistsq * epsError) <= (result_set.worstDist())) { 
# 586
searchLevel(result_set, vec, otherChild, mindistsq, dists, epsError); 
# 587
}  
# 588
(dists[idx]) = dst; 
# 589
} 
# 596
const Matrix< typename Distance::ElementType>  dataset_; 
# 598
::cvflann::IndexParams index_params_; 
# 600
int leaf_max_size_; 
# 601
bool reorder_; 
# 607
::std::vector< int>  vind_; 
# 609
Matrix< typename Distance::ElementType>  data_; 
# 611
::size_t size_; 
# 612
::size_t dim_; 
# 617
NodePtr root_node_; 
# 619
BoundingBox root_bbox_; 
# 628 "/usr/include/opencv2/flann/kdtree_single_index.h" 3
::cvflann::PooledAllocator pool_; 
# 630
Distance distance_; 
# 631
}; 
# 633
}
# 40 "/usr/include/opencv2/flann/logger.h" 3
namespace cvflann { 
# 43
class Logger { 
# 45
Logger() : stream(stdout), logLevel((FLANN_LOG_WARN)) { } 
# 47
~Logger() 
# 48
{ 
# 49
if (((stream) != (__null)) && ((stream) != stdout)) { 
# 50
fclose(stream); 
# 51
}  
# 52
} 
# 54
static Logger &instance() 
# 55
{ 
# 56
static Logger logger; 
# 57
return logger; 
# 58
} 
# 60
void _setDestination(const char *name) 
# 61
{ 
# 62
if (name == (__null)) { 
# 63
(stream) = stdout; 
# 64
} else 
# 65
{ 
# 70
(stream) = fopen(name, "w"); 
# 72
if ((stream) == (__null)) { 
# 73
(stream) = stdout; 
# 74
}  
# 75
}  
# 76
} 
# 78
int _log(int level, const char *fmt, va_list arglist) 
# 79
{ 
# 80
if (level > (logLevel)) { return -1; }  
# 81
int ret = vfprintf(stream, fmt, arglist); 
# 82
return ret; 
# 83
} 
# 90
public: static void setLevel(int level) { (instance().logLevel) = level; } 
# 96
static void setDestination(const char *name) { instance()._setDestination(name); } 
# 104
static int log(int level, const char *fmt, ...) 
# 105
{ 
# 106
va_list arglist; 
# 107
__builtin_va_start(arglist,fmt); 
# 108
int ret = instance()._log(level, fmt, arglist); 
# 109
__builtin_va_end(arglist); 
# 110
return ret; 
# 111
} 
# 123 "/usr/include/opencv2/flann/logger.h" 3
static int fatal(const char *fmt, ...) { va_list ap; __builtin_va_start(ap,fmt); int ret = instance()._log(FLANN_LOG_FATAL, fmt, ap); __builtin_va_end(ap); return ret; } 
# 124
static int error(const char *fmt, ...) { va_list ap; __builtin_va_start(ap,fmt); int ret = instance()._log(FLANN_LOG_ERROR, fmt, ap); __builtin_va_end(ap); return ret; } 
# 125
static int warn(const char *fmt, ...) { va_list ap; __builtin_va_start(ap,fmt); int ret = instance()._log(FLANN_LOG_WARN, fmt, ap); __builtin_va_end(ap); return ret; } 
# 126
static int info(const char *fmt, ...) { va_list ap; __builtin_va_start(ap,fmt); int ret = instance()._log(FLANN_LOG_INFO, fmt, ap); __builtin_va_end(ap); return ret; } 
# 129
private: FILE *stream; 
# 130
int logLevel; 
# 131
}; 
# 133
}
# 52 "/usr/include/opencv2/flann/kmeans_index.h" 3
namespace cvflann { 
# 55
struct KMeansIndexParams : public IndexParams { 
# 57
KMeansIndexParams(int branching = 32, int iterations = 11, flann_centers_init_t 
# 58
centers_init = FLANN_CENTERS_RANDOM, float cb_index = (0.2000000000000000111)) 
# 59
{ 
# 60
(((*this)["algorithm"]) = (FLANN_INDEX_KMEANS)); 
# 62
(((*this)["branching"]) = branching); 
# 64
(((*this)["iterations"]) = iterations); 
# 66
(((*this)["centers_init"]) = centers_init); 
# 68
(((*this)["cb_index"]) = cb_index); 
# 69
} 
# 70
}; 
# 79 "/usr/include/opencv2/flann/kmeans_index.h" 3
template< class Distance> 
# 80
class KMeansIndex : public NNIndex< Distance>  { 
# 83
public: typedef typename Distance::ElementType ElementType; 
# 84
typedef typename Distance::ResultType DistanceType; 
# 88
typedef void (::cvflann::KMeansIndex< Distance> ::*centersAlgFunction)(int, int *, int, int *, int &); 
# 93
centersAlgFunction chooseCenters; 
# 107 "/usr/include/opencv2/flann/kmeans_index.h" 3
void chooseCentersRandom(int k, int *indices, int indices_length, int *centers, int &centers_length) 
# 108
{ 
# 109
::cvflann::UniqueRandom r(indices_length); 
# 111
int index; 
# 112
for (index = 0; index < k; ++index) { 
# 113
bool duplicate = true; 
# 114
int rnd; 
# 115
while (duplicate) { 
# 116
duplicate = false; 
# 117
rnd = r.next(); 
# 118
if (rnd < 0) { 
# 119
centers_length = index; 
# 120
return; 
# 121
}  
# 123
(centers[index]) = (indices[rnd]); 
# 125
for (int j = 0; j < index; ++j) { 
# 126
DistanceType sq = (distance_)((dataset_)[centers[index]], (dataset_)[centers[j]], ((dataset_).cols)); 
# 127
if (sq < (9.999999999999999791e-17)) { 
# 128
duplicate = true; 
# 129
}  
# 130
}  
# 131
}  
# 132
}  
# 134
centers_length = index; 
# 135
} 
# 148 "/usr/include/opencv2/flann/kmeans_index.h" 3
void chooseCentersGonzales(int k, int *indices, int indices_length, int *centers, int &centers_length) 
# 149
{ 
# 150
int n = indices_length; 
# 152
int rnd = rand_int(n); 
# 153
((rnd >= 0) && (rnd < n)) ? static_cast< void>(0) : __assert_fail("rnd >=0 && rnd < n", "/usr/include/opencv2/flann/kmeans_index.h", 153, __PRETTY_FUNCTION__); 
# 155
(centers[0]) = (indices[rnd]); 
# 157
int index; 
# 158
for (index = 1; index < k; ++index) { 
# 160
int best_index = (-1); 
# 161
DistanceType best_val = (0); 
# 162
for (int j = 0; j < n; ++j) { 
# 163
DistanceType dist = (distance_)((dataset_)[centers[0]], (dataset_)[indices[j]], ((dataset_).cols)); 
# 164
for (int i = 1; i < index; ++i) { 
# 165
DistanceType tmp_dist = (distance_)((dataset_)[centers[i]], (dataset_)[indices[j]], ((dataset_).cols)); 
# 166
if (tmp_dist < dist) { 
# 167
dist = tmp_dist; 
# 168
}  
# 169
}  
# 170
if (dist > best_val) { 
# 171
best_val = dist; 
# 172
best_index = j; 
# 173
}  
# 174
}  
# 175
if (best_index != (-1)) { 
# 176
(centers[index]) = (indices[best_index]); 
# 177
} else 
# 178
{ 
# 179
break; 
# 180
}  
# 181
}  
# 182
centers_length = index; 
# 183
} 
# 199 "/usr/include/opencv2/flann/kmeans_index.h" 3
void chooseCentersKMeanspp(int k, int *indices, int indices_length, int *centers, int &centers_length) 
# 200
{ 
# 201
int n = indices_length; 
# 203
double currentPot = (0); 
# 204
DistanceType *closestDistSq = new DistanceType [n]; 
# 207
int index = rand_int(n); 
# 208
((index >= 0) && (index < n)) ? static_cast< void>(0) : __assert_fail("index >=0 && index < n", "/usr/include/opencv2/flann/kmeans_index.h", 208, __PRETTY_FUNCTION__); 
# 209
(centers[0]) = (indices[index]); 
# 211
for (int i = 0; i < n; i++) { 
# 212
(closestDistSq[i]) = (distance_)((dataset_)[indices[i]], (dataset_)[indices[index]], ((dataset_).cols)); 
# 213
(closestDistSq[i]) = ensureSquareDistance< Distance> (closestDistSq[i]); 
# 214
currentPot += (closestDistSq[i]); 
# 215
}  
# 218
const int numLocalTries = 1; 
# 221
int centerCount; 
# 222
for (centerCount = 1; centerCount < k; centerCount++) { 
# 225
double bestNewPot = (-1); 
# 226
int bestNewIndex = (-1); 
# 227
for (int localTrial = 0; localTrial < numLocalTries; localTrial++) { 
# 231
double randVal = rand_double(currentPot); 
# 232
for (index = 0; index < (n - 1); index++) { 
# 233
if (randVal <= (closestDistSq[index])) { break; } else { 
# 234
randVal -= (closestDistSq[index]); }  
# 235
}  
# 238
double newPot = (0); 
# 239
for (int i = 0; i < n; i++) { 
# 240
DistanceType dist = (distance_)((dataset_)[indices[i]], (dataset_)[indices[index]], ((dataset_).cols)); 
# 241
newPot += ::std::min(ensureSquareDistance< Distance> (dist), closestDistSq[i]); 
# 242
}  
# 245
if ((bestNewPot < (0)) || (newPot < bestNewPot)) { 
# 246
bestNewPot = newPot; 
# 247
bestNewIndex = index; 
# 248
}  
# 249
}  
# 252
(centers[centerCount]) = (indices[bestNewIndex]); 
# 253
currentPot = bestNewPot; 
# 254
for (int i = 0; i < n; i++) { 
# 255
DistanceType dist = (distance_)((dataset_)[indices[i]], (dataset_)[indices[bestNewIndex]], ((dataset_).cols)); 
# 256
(closestDistSq[i]) = ::std::min(ensureSquareDistance< Distance> (dist), closestDistSq[i]); 
# 257
}  
# 258
}  
# 260
centers_length = centerCount; 
# 262
delete [] closestDistSq; 
# 263
} 
# 269
::cvflann::flann_algorithm_t getType() const 
# 270
{ 
# 271
return FLANN_INDEX_KMEANS; 
# 272
} 
# 274
class KMeansDistanceComputer : public ::cv::ParallelLoopBody { 
# 277
public: KMeansDistanceComputer(Distance _distance, const Matrix< typename Distance::ElementType>  &_dataset, const int 
# 278
_branching, const int *_indices, const ::cvflann::Matrix< double>  &_dcenters, const ::size_t _veclen, int *
# 279
_count, int *_belongs_to, ::std::vector< typename Distance::ResultType>  &_radiuses, bool &_converged, ::cv::Mutex &_mtx) : distance(_distance), dataset(_dataset), branching(_branching), indices(_indices), dcenters(_dcenters), veclen(_veclen), count(_count), belongs_to(_belongs_to), radiuses(_radiuses), converged(_converged), mtx(_mtx) 
# 291
{ 
# 292
} 
# 294
virtual void operator()(const ::cv::Range &range) const 
# 295
{ 
# 296
const int begin = range.start; 
# 297
const int end = range.end; 
# 299
for (int i = begin; i < end; ++i) 
# 300
{ 
# 301
DistanceType sq_dist = (distance)((dataset)[(indices)[i]], (dcenters)[0], veclen); 
# 302
int new_centroid = 0; 
# 303
for (int j = 1; j < (branching); ++j) { 
# 304
DistanceType new_sq_dist = (distance)((dataset)[(indices)[i]], (dcenters)[j], veclen); 
# 305
if (sq_dist > new_sq_dist) { 
# 306
new_centroid = j; 
# 307
sq_dist = new_sq_dist; 
# 308
}  
# 309
}  
# 310
if (sq_dist > ((radiuses)[new_centroid])) { 
# 311
((radiuses)[new_centroid]) = sq_dist; 
# 312
}  
# 313
if (new_centroid != ((belongs_to)[i])) { 
# 314
((count)[(belongs_to)[i]])--; 
# 315
((count)[new_centroid])++; 
# 316
((belongs_to)[i]) = new_centroid; 
# 317
(mtx).lock(); 
# 318
(converged) = false; 
# 319
(mtx).unlock(); 
# 320
}  
# 321
}  
# 322
} 
# 325
private: Distance distance; 
# 326
const Matrix< typename Distance::ElementType>  &dataset; 
# 327
const int branching; 
# 328
const int *indices; 
# 329
const ::cvflann::Matrix< double>  &dcenters; 
# 330
const ::size_t veclen; 
# 331
int *count; 
# 332
int *belongs_to; 
# 333
::std::vector< typename Distance::ResultType>  &radiuses; 
# 334
bool &converged; 
# 335
::cv::Mutex &mtx; 
# 336
KMeansDistanceComputer &operator=(const KMeansDistanceComputer &) { return *this; } 
# 337
}; 
# 346 "/usr/include/opencv2/flann/kmeans_index.h" 3
KMeansIndex(const Matrix< typename Distance::ElementType>  &inputData, const ::cvflann::IndexParams &params = ::cvflann::KMeansIndexParams(), Distance 
# 347
d = Distance()) : dataset_(inputData), index_params_(params), root_((__null)), indices_((__null)), distance_(d) 
# 349
{ 
# 350
(memoryCounter_) = 0; 
# 352
(size_) = ((dataset_).rows); 
# 353
(veclen_) = ((dataset_).cols); 
# 355
(branching_) = get_param(params, "branching", 32); 
# 356
(iterations_) = get_param(params, "iterations", 11); 
# 357
if ((iterations_) < 0) { 
# 358
(iterations_) = std::numeric_limits< int> ::max(); 
# 359
}  
# 360
(centers_init_) = get_param(params, "centers_init", FLANN_CENTERS_RANDOM); 
# 362
if ((centers_init_) == (FLANN_CENTERS_RANDOM)) { 
# 363
(chooseCenters) = (&::cvflann::KMeansIndex< Distance> ::chooseCentersRandom); 
# 364
} else { 
# 365
if ((centers_init_) == (FLANN_CENTERS_GONZALES)) { 
# 366
(chooseCenters) = (&::cvflann::KMeansIndex< Distance> ::chooseCentersGonzales); 
# 367
} else { 
# 368
if ((centers_init_) == (FLANN_CENTERS_KMEANSPP)) { 
# 369
(chooseCenters) = (&::cvflann::KMeansIndex< Distance> ::chooseCentersKMeanspp); 
# 370
} else 
# 371
{ 
# 372
throw ((::cvflann::FLANNException)("Unknown algorithm for choosing initial centers.")); 
# 373
}  }  }  
# 374
(cb_index_) = (0.400000006F); 
# 376
} 
# 379
KMeansIndex(const KMeansIndex &); 
# 380
KMeansIndex &operator=(const KMeansIndex &); 
# 388
virtual ~KMeansIndex() 
# 389
{ 
# 390
if ((root_) != __null) { 
# 391
free_centers(root_); 
# 392
}  
# 393
if ((indices_) != (__null)) { 
# 394
delete [] (indices_); 
# 395
}  
# 396
} 
# 401
::size_t size() const 
# 402
{ 
# 403
return size_; 
# 404
} 
# 409
::size_t veclen() const 
# 410
{ 
# 411
return veclen_; 
# 412
} 
# 415
void set_cb_index(float index) 
# 416
{ 
# 417
(cb_index_) = index; 
# 418
} 
# 424
int usedMemory() const 
# 425
{ 
# 426
return (((pool_).usedMemory) + ((pool_).wastedMemory)) + (memoryCounter_); 
# 427
} 
# 432
void buildIndex() 
# 433
{ 
# 434
if ((branching_) < 2) { 
# 435
throw ((::cvflann::FLANNException)("Branching factor must be at least 2")); 
# 436
}  
# 438
(indices_) = (new int [size_]); 
# 439
for (::size_t i = (0); i < (size_); ++i) { 
# 440
((indices_)[i]) = ((int)i); 
# 441
}  
# 443
(root_) = ((pool_).template allocate< KMeansNode> ()); 
# 444
::std::memset(root_, 0, sizeof(KMeansNode)); 
# 446
computeNodeStatistics(root_, indices_, (int)(size_)); 
# 447
computeClustering(root_, indices_, (int)(size_), branching_, 0); 
# 448
} 
# 451
void saveIndex(::FILE *stream) 
# 452
{ 
# 453
save_value(stream, branching_); 
# 454
save_value(stream, iterations_); 
# 455
save_value(stream, memoryCounter_); 
# 456
save_value(stream, cb_index_); 
# 457
save_value(stream, *(indices_), (int)(size_)); 
# 459
save_tree(stream, root_); 
# 460
} 
# 463
void loadIndex(::FILE *stream) 
# 464
{ 
# 465
load_value(stream, branching_); 
# 466
load_value(stream, iterations_); 
# 467
load_value(stream, memoryCounter_); 
# 468
load_value(stream, cb_index_); 
# 469
if ((indices_) != (__null)) { 
# 470
delete [] (indices_); 
# 471
}  
# 472
(indices_) = (new int [size_]); 
# 473
load_value(stream, *(indices_), size_); 
# 475
if ((root_) != __null) { 
# 476
free_centers(root_); 
# 477
}  
# 478
load_tree(stream, root_); 
# 480
(index_params_)["algorithm"] = getType(); 
# 481
(((index_params_)["branching"]) = (branching_)); 
# 482
(((index_params_)["iterations"]) = (iterations_)); 
# 483
(((index_params_)["centers_init"]) = (centers_init_)); 
# 484
(((index_params_)["cb_index"]) = (cb_index_)); 
# 486
} 
# 498 "/usr/include/opencv2/flann/kmeans_index.h" 3
void findNeighbors(ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, const ::cvflann::SearchParams &searchParams) 
# 499
{ 
# 501
int maxChecks = get_param(searchParams, "checks", 32); 
# 503
if (maxChecks == (FLANN_CHECKS_UNLIMITED)) { 
# 504
findExactNN(root_, result, vec); 
# 505
} else 
# 506
{ 
# 508
Heap< BranchStruct< KMeansNode *, typename Distance::ResultType> >  *heap = new Heap< BranchStruct< KMeansNode *, typename Distance::ResultType> > ((int)(size_)); 
# 510
int checks = 0; 
# 511
findNN(root_, result, vec, checks, maxChecks, heap); 
# 513
BranchSt branch; 
# 514
while ((heap->popMin(branch)) && ((checks < maxChecks) || (!(result.full())))) { 
# 515
KMeansNodePtr node = ((branch.node)); 
# 516
findNN(node, result, vec, checks, maxChecks, heap); 
# 517
}  
# 518
((result.full())) ? static_cast< void>(0) : __assert_fail("result.full()", "/usr/include/opencv2/flann/kmeans_index.h", 518, __PRETTY_FUNCTION__); 
# 520
delete heap; 
# 521
}  
# 523
} 
# 532 "/usr/include/opencv2/flann/kmeans_index.h" 3
int getClusterCenters(Matrix< typename Distance::ResultType>  &centers) 
# 533
{ 
# 534
int numClusters = ((centers.rows)); 
# 535
if (numClusters < 1) { 
# 536
throw ((::cvflann::FLANNException)("Number of clusters must be at least 1")); 
# 537
}  
# 539
DistanceType variance; 
# 540
KMeansNodePtr *clusters = new KMeansNodePtr [numClusters]; 
# 542
int clusterCount = getMinVarianceClusters(root_, clusters, numClusters, variance); 
# 544
Logger::info("Clusters requested: %d, returning %d\n", numClusters, clusterCount); 
# 546
for (int i = 0; i < clusterCount; ++i) { 
# 547
DistanceType *center = (((clusters[i])->pivot)); 
# 548
for (::size_t j = (0); j < (veclen_); ++j) { 
# 549
((centers[i])[j]) = (center[j]); 
# 550
}  
# 551
}  
# 552
delete [] clusters; 
# 554
return clusterCount; 
# 555
} 
# 557
::cvflann::IndexParams getParameters() const 
# 558
{ 
# 559
return index_params_; 
# 560
} 
# 567
private: struct KMeansNode { 
# 572
DistanceType *pivot; 
# 576
DistanceType radius; 
# 580
DistanceType mean_radius; 
# 584
DistanceType variance; 
# 588
int size; 
# 592
KMeansNode **childs; 
# 596
int *indices; 
# 600
int level; 
# 601
}; 
# 602
typedef KMeansNode *KMeansNodePtr; 
# 607
typedef BranchStruct< KMeansNode *, typename Distance::ResultType>  BranchSt; 
# 612
void save_tree(::FILE *stream, KMeansNodePtr node) 
# 613
{ 
# 614
save_value(stream, *node); 
# 615
save_value(stream, *(node->pivot), (int)(veclen_)); 
# 616
if ((node->childs) == __null) { 
# 617
int indices_offset = (int)((node->indices) - (indices_)); 
# 618
save_value(stream, indices_offset); 
# 619
} else 
# 620
{ 
# 621
for (int i = 0; i < (branching_); ++i) { 
# 622
save_tree(stream, (node->childs)[i]); 
# 623
}  
# 624
}  
# 625
} 
# 628
void load_tree(::FILE *stream, KMeansNodePtr &node) 
# 629
{ 
# 630
node = ((pool_).template allocate< KMeansNode> ()); 
# 631
load_value(stream, *node); 
# 632
(node->pivot) = (new DistanceType [veclen_]); 
# 633
load_value(stream, *(node->pivot), (int)(veclen_)); 
# 634
if ((node->childs) == __null) { 
# 635
int indices_offset; 
# 636
load_value(stream, indices_offset); 
# 637
(node->indices) = ((indices_) + indices_offset); 
# 638
} else 
# 639
{ 
# 640
(node->childs) = ((pool_).template allocate< KMeansNodePtr> (branching_)); 
# 641
for (int i = 0; i < (branching_); ++i) { 
# 642
load_tree(stream, (node->childs)[i]); 
# 643
}  
# 644
}  
# 645
} 
# 651
void free_centers(KMeansNodePtr node) 
# 652
{ 
# 653
delete [] (node->pivot); 
# 654
if ((node->childs) != __null) { 
# 655
for (int k = 0; k < (branching_); ++k) { 
# 656
free_centers((node->childs)[k]); 
# 657
}  
# 658
}  
# 659
} 
# 668 "/usr/include/opencv2/flann/kmeans_index.h" 3
void computeNodeStatistics(KMeansNodePtr node, int *indices, int indices_length) 
# 669
{ 
# 671
DistanceType radius = (0); 
# 672
DistanceType variance = (0); 
# 673
DistanceType *mean = new DistanceType [veclen_]; 
# 674
(memoryCounter_) += ((int)((veclen_) * sizeof(DistanceType))); 
# 676
memset(mean, 0, (veclen_) * sizeof(DistanceType)); 
# 678
for (::size_t i = (0); i < (size_); ++i) { 
# 679
ElementType *vec = (dataset_)[indices[i]]; 
# 680
for (::size_t j = (0); j < (veclen_); ++j) { 
# 681
(mean[j]) += (vec[j]); 
# 682
}  
# 683
variance += (distance_)(vec, ZeroIterator< typename Distance::ElementType> (), veclen_); 
# 684
}  
# 685
for (::size_t j = (0); j < (veclen_); ++j) { 
# 686
(mean[j]) /= (size_); 
# 687
}  
# 688
variance /= (size_); 
# 689
variance -= (distance_)(mean, ZeroIterator< typename Distance::ElementType> (), veclen_); 
# 691
DistanceType tmp = (0); 
# 692
for (int i = 0; i < indices_length; ++i) { 
# 693
tmp = (distance_)(mean, (dataset_)[indices[i]], veclen_); 
# 694
if (tmp > radius) { 
# 695
radius = tmp; 
# 696
}  
# 697
}  
# 699
(node->variance) = variance; 
# 700
(node->radius) = radius; 
# 701
(node->pivot) = mean; 
# 702
} 
# 716 "/usr/include/opencv2/flann/kmeans_index.h" 3
void computeClustering(KMeansNodePtr node, int *indices, int indices_length, int branching, int level) 
# 717
{ 
# 718
(node->size) = indices_length; 
# 719
(node->level) = level; 
# 721
if (indices_length < branching) { 
# 722
(node->indices) = indices; 
# 723
::std::sort((node->indices), (node->indices) + indices_length); 
# 724
(node->childs) = __null; 
# 725
return; 
# 726
}  
# 728
::cv::AutoBuffer< int>  centers_idx_buf(branching); 
# 729
int *centers_idx = (int *)centers_idx_buf; 
# 730
int centers_length; 
# 731
(this->*(chooseCenters))(branching, indices, indices_length, centers_idx, centers_length); 
# 733
if (centers_length < branching) { 
# 734
(node->indices) = indices; 
# 735
::std::sort((node->indices), (node->indices) + indices_length); 
# 736
(node->childs) = __null; 
# 737
return; 
# 738
}  
# 741
::cv::AutoBuffer< double>  dcenters_buf(branching * (veclen_)); 
# 742
::cvflann::Matrix< double>  dcenters((double *)dcenters_buf, branching, veclen_); 
# 743
for (int i = 0; i < centers_length; ++i) { 
# 744
ElementType *vec = (dataset_)[centers_idx[i]]; 
# 745
for (::size_t k = (0); k < (veclen_); ++k) { 
# 746
(dcenters[i][k]) = ((double)(vec[k])); 
# 747
}  
# 748
}  
# 750
::std::vector< typename Distance::ResultType>  radiuses(branching); 
# 751
::cv::AutoBuffer< int>  count_buf(branching); 
# 752
int *count = (int *)count_buf; 
# 753
for (int i = 0; i < branching; ++i) { 
# 754
(radiuses[i]) = 0; 
# 755
(count[i]) = 0; 
# 756
}  
# 759
::cv::AutoBuffer< int>  belongs_to_buf(indices_length); 
# 760
int *belongs_to = (int *)belongs_to_buf; 
# 761
for (int i = 0; i < indices_length; ++i) { 
# 763
DistanceType sq_dist = (distance_)((dataset_)[indices[i]], dcenters[0], veclen_); 
# 764
(belongs_to[i]) = 0; 
# 765
for (int j = 1; j < branching; ++j) { 
# 766
DistanceType new_sq_dist = (distance_)((dataset_)[indices[i]], dcenters[j], veclen_); 
# 767
if (sq_dist > new_sq_dist) { 
# 768
(belongs_to[i]) = j; 
# 769
sq_dist = new_sq_dist; 
# 770
}  
# 771
}  
# 772
if (sq_dist > (radiuses[belongs_to[i]])) { 
# 773
(radiuses[belongs_to[i]]) = sq_dist; 
# 774
}  
# 775
(count[belongs_to[i]])++; 
# 776
}  
# 778
bool converged = false; 
# 779
int iteration = 0; 
# 780
while ((!converged) && (iteration < (iterations_))) { 
# 781
converged = true; 
# 782
iteration++; 
# 785
for (int i = 0; i < branching; ++i) { 
# 786
memset(dcenters[i], 0, sizeof(double) * (veclen_)); 
# 787
(radiuses[i]) = 0; 
# 788
}  
# 789
for (int i = 0; i < indices_length; ++i) { 
# 790
ElementType *vec = (dataset_)[indices[i]]; 
# 791
double *center = dcenters[belongs_to[i]]; 
# 792
for (::size_t k = (0); k < (veclen_); ++k) { 
# 793
(center[k]) += (vec[k]); 
# 794
}  
# 795
}  
# 796
for (int i = 0; i < branching; ++i) { 
# 797
int cnt = count[i]; 
# 798
for (::size_t k = (0); k < (veclen_); ++k) { 
# 799
(dcenters[i][k]) /= cnt; 
# 800
}  
# 801
}  
# 804
::cv::Mutex mtx; 
# 805
KMeansDistanceComputer invoker(distance_, dataset_, branching, indices, dcenters, veclen_, count, belongs_to, radiuses, converged, mtx); 
# 806
parallel_for_(::cv::Range(0, (int)indices_length), invoker); 
# 808
for (int i = 0; i < branching; ++i) { 
# 811
if ((count[i]) == 0) { 
# 812
int j = (i + 1) % branching; 
# 813
while ((count[j]) <= 1) { 
# 814
j = ((j + 1) % branching); 
# 815
}  
# 817
for (int k = 0; k < indices_length; ++k) { 
# 818
if ((belongs_to[k]) == j) { 
# 820
if ((distance_)((dataset_)[indices[k]], dcenters[j], veclen_) == (radiuses[j])) { 
# 821
(belongs_to[k]) = i; 
# 822
(count[j])--; 
# 823
(count[i])++; 
# 824
break; 
# 825
}  
# 826
}  
# 827
}  
# 828
converged = false; 
# 829
}  
# 830
}  
# 832
}  
# 834
DistanceType **centers = new DistanceType *[branching]; 
# 836
for (int i = 0; i < branching; ++i) { 
# 837
(centers[i]) = (new DistanceType [veclen_]); 
# 838
(memoryCounter_) += ((int)((veclen_) * sizeof(DistanceType))); 
# 839
for (::size_t k = (0); k < (veclen_); ++k) { 
# 840
((centers[i])[k]) = ((DistanceType)(dcenters[i][k])); 
# 841
}  
# 842
}  
# 846
(node->childs) = ((pool_).template allocate< KMeansNodePtr> (branching)); 
# 847
int start = 0; 
# 848
int end = start; 
# 849
for (int c = 0; c < branching; ++c) { 
# 850
int s = count[c]; 
# 852
DistanceType variance = (0); 
# 853
DistanceType mean_radius = (0); 
# 854
for (int i = 0; i < indices_length; ++i) { 
# 855
if ((belongs_to[i]) == c) { 
# 856
DistanceType d = (distance_)((dataset_)[indices[i]], ZeroIterator< typename Distance::ElementType> (), veclen_); 
# 857
variance += d; 
# 858
mean_radius += sqrt(d); 
# 859
std::swap(indices[i], indices[end]); 
# 860
std::swap(belongs_to[i], belongs_to[end]); 
# 861
end++; 
# 862
}  
# 863
}  
# 864
variance /= s; 
# 865
mean_radius /= s; 
# 866
variance -= (distance_)(centers[c], ZeroIterator< typename Distance::ElementType> (), veclen_); 
# 868
((node->childs)[c]) = ((pool_).template allocate< KMeansNode> ()); 
# 869
::std::memset((node->childs)[c], 0, sizeof(KMeansNode)); 
# 870
(((node->childs)[c])->radius) = (radiuses[c]); 
# 871
(((node->childs)[c])->pivot) = (centers[c]); 
# 872
(((node->childs)[c])->variance) = variance; 
# 873
(((node->childs)[c])->mean_radius) = mean_radius; 
# 874
computeClustering((node->childs)[c], indices + start, end - start, branching, level + 1); 
# 875
start = end; 
# 876
}  
# 878
delete [] centers; 
# 879
} 
# 896 "/usr/include/opencv2/flann/kmeans_index.h" 3
void findNN(KMeansNodePtr node, ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, int &checks, int maxChecks, Heap< BranchStruct< KMeansNode *, typename Distance::ResultType> >  *
# 897
heap) 
# 898
{ 
# 900
{ 
# 901
DistanceType bsq = (distance_)(vec, (node->pivot), veclen_); 
# 902
DistanceType rsq = ((node->radius)); 
# 903
DistanceType wsq = (result.worstDist()); 
# 905
DistanceType val = (bsq - rsq) - wsq; 
# 906
DistanceType val2 = (val * val) - ((4 * rsq) * wsq); 
# 909
if ((val > 0) && (val2 > 0)) { 
# 910
return; 
# 911
}  
# 912
} 
# 914
if ((node->childs) == __null) { 
# 915
if (checks >= maxChecks) { 
# 916
if ((result.full())) { return; }  
# 917
}  
# 918
checks += (node->size); 
# 919
for (int i = 0; i < (node->size); ++i) { 
# 920
int index = (node->indices)[i]; 
# 921
DistanceType dist = (distance_)((dataset_)[index], vec, veclen_); 
# 922
(result.addPoint(dist, index)); 
# 923
}  
# 924
} else 
# 925
{ 
# 926
DistanceType *domain_distances = new DistanceType [branching_]; 
# 927
int closest_center = exploreNodeBranches(node, vec, domain_distances, heap); 
# 928
delete [] domain_distances; 
# 929
findNN((node->childs)[closest_center], result, vec, checks, maxChecks, heap); 
# 930
}  
# 931
} 
# 941 "/usr/include/opencv2/flann/kmeans_index.h" 3
int exploreNodeBranches(KMeansNodePtr node, const ElementType *q, DistanceType *domain_distances, Heap< BranchStruct< KMeansNode *, typename Distance::ResultType> >  *heap) 
# 942
{ 
# 944
int best_index = 0; 
# 945
(domain_distances[best_index]) = (distance_)(q, (((node->childs)[best_index])->pivot), veclen_); 
# 946
for (int i = 1; i < (branching_); ++i) { 
# 947
(domain_distances[i]) = (distance_)(q, (((node->childs)[i])->pivot), veclen_); 
# 948
if ((domain_distances[i]) < (domain_distances[best_index])) { 
# 949
best_index = i; 
# 950
}  
# 951
}  
# 954
for (int i = 0; i < (branching_); ++i) { 
# 955
if (i != best_index) { 
# 956
(domain_distances[i]) -= ((cb_index_) * (((node->childs)[i])->variance)); 
# 962
(heap->insert(BranchSt((node->childs)[i], domain_distances[i]))); 
# 963
}  
# 964
}  
# 966
return best_index; 
# 967
} 
# 973
void findExactNN(KMeansNodePtr node, ResultSet< typename Distance::ResultType>  &result, const ElementType *vec) 
# 974
{ 
# 976
{ 
# 977
DistanceType bsq = (distance_)(vec, (node->pivot), veclen_); 
# 978
DistanceType rsq = ((node->radius)); 
# 979
DistanceType wsq = (result.worstDist()); 
# 981
DistanceType val = (bsq - rsq) - wsq; 
# 982
DistanceType val2 = (val * val) - ((4 * rsq) * wsq); 
# 985
if ((val > 0) && (val2 > 0)) { 
# 986
return; 
# 987
}  
# 988
} 
# 991
if ((node->childs) == __null) { 
# 992
for (int i = 0; i < (node->size); ++i) { 
# 993
int index = (node->indices)[i]; 
# 994
DistanceType dist = (distance_)((dataset_)[index], vec, veclen_); 
# 995
(result.addPoint(dist, index)); 
# 996
}  
# 997
} else 
# 998
{ 
# 999
int *sort_indices = new int [branching_]; 
# 1001
getCenterOrdering(node, vec, sort_indices); 
# 1003
for (int i = 0; i < (branching_); ++i) { 
# 1004
findExactNN((node->childs)[sort_indices[i]], result, vec); 
# 1005
}  
# 1007
delete [] sort_indices; 
# 1008
}  
# 1009
} 
# 1017
void getCenterOrdering(KMeansNodePtr node, const ElementType *q, int *sort_indices) 
# 1018
{ 
# 1019
DistanceType *domain_distances = new DistanceType [branching_]; 
# 1020
for (int i = 0; i < (branching_); ++i) { 
# 1021
DistanceType dist = (distance_)(q, (((node->childs)[i])->pivot), veclen_); 
# 1023
int j = 0; 
# 1024
while (((domain_distances[j]) < dist) && (j < i)) { j++; }  
# 1025
for (int k = i; k > j; --k) { 
# 1026
(domain_distances[k]) = (domain_distances[k - 1]); 
# 1027
(sort_indices[k]) = (sort_indices[k - 1]); 
# 1028
}  
# 1029
(domain_distances[j]) = dist; 
# 1030
(sort_indices[j]) = i; 
# 1031
}  
# 1032
delete [] domain_distances; 
# 1033
} 
# 1040
DistanceType getDistanceToBorder(DistanceType *p, DistanceType *c, DistanceType *q) 
# 1041
{ 
# 1042
DistanceType sum = (0); 
# 1043
DistanceType sum2 = (0); 
# 1045
for (int i = 0; i < (veclen_); ++i) { 
# 1046
DistanceType t = (c[i]) - (p[i]); 
# 1047
sum += (t * ((q[i]) - (((c[i]) + (p[i])) / 2))); 
# 1048
sum2 += (t * t); 
# 1049
}  
# 1051
return (sum * sum) / sum2; 
# 1052
} 
# 1064 "/usr/include/opencv2/flann/kmeans_index.h" 3
int getMinVarianceClusters(KMeansNodePtr root, KMeansNodePtr *clusters, int clusters_length, DistanceType &varianceValue) 
# 1065
{ 
# 1066
int clusterCount = 1; 
# 1067
(clusters[0]) = root; 
# 1069
DistanceType meanVariance = (root->variance) * (root->size); 
# 1071
while (clusterCount < clusters_length) { 
# 1072
DistanceType minVariance = std::numeric_limits< typename Distance::ResultType> ::max(); 
# 1073
int splitIndex = (-1); 
# 1075
for (int i = 0; i < clusterCount; ++i) { 
# 1076
if (((clusters[i])->childs) != __null) { 
# 1078
DistanceType variance = meanVariance - (((clusters[i])->variance) * ((clusters[i])->size)); 
# 1080
for (int j = 0; j < (branching_); ++j) { 
# 1081
variance += (((((clusters[i])->childs)[j])->variance) * ((((clusters[i])->childs)[j])->size)); 
# 1082
}  
# 1083
if (variance < minVariance) { 
# 1084
minVariance = variance; 
# 1085
splitIndex = i; 
# 1086
}  
# 1087
}  
# 1088
}  
# 1090
if (splitIndex == (-1)) { break; }  
# 1091
if ((((branching_) + clusterCount) - 1) > clusters_length) { break; }  
# 1093
meanVariance = minVariance; 
# 1096
KMeansNodePtr toSplit = clusters[splitIndex]; 
# 1097
(clusters[splitIndex]) = ((toSplit->childs)[0]); 
# 1098
for (int i = 1; i < (branching_); ++i) { 
# 1099
(clusters[clusterCount++]) = ((toSplit->childs)[i]); 
# 1100
}  
# 1101
}  
# 1103
varianceValue = (meanVariance / (root->size)); 
# 1104
return clusterCount; 
# 1105
} 
# 1109
int branching_; 
# 1112
int iterations_; 
# 1115
::cvflann::flann_centers_init_t centers_init_; 
# 1123
float cb_index_; 
# 1128
const Matrix< typename Distance::ElementType>  dataset_; 
# 1131
::cvflann::IndexParams index_params_; 
# 1136
::size_t size_; 
# 1141
::size_t veclen_; 
# 1146
KMeansNodePtr root_; 
# 1151
int *indices_; 
# 1156
Distance distance_; 
# 1161
::cvflann::PooledAllocator pool_; 
# 1166
int memoryCounter_; 
# 1167
}; 
# 1169
}
# 39 "/usr/include/opencv2/flann/composite_index.h" 3
namespace cvflann { 
# 45
struct CompositeIndexParams : public IndexParams { 
# 47
CompositeIndexParams(int trees = 4, int branching = 32, int iterations = 11, flann_centers_init_t 
# 48
centers_init = FLANN_CENTERS_RANDOM, float cb_index = (0.2000000000000000111)) 
# 49
{ 
# 50
(((*this)["algorithm"]) = (FLANN_INDEX_KMEANS)); 
# 52
(((*this)["trees"]) = trees); 
# 54
(((*this)["branching"]) = branching); 
# 56
(((*this)["iterations"]) = iterations); 
# 58
(((*this)["centers_init"]) = centers_init); 
# 60
(((*this)["cb_index"]) = cb_index); 
# 61
} 
# 62
}; 
# 70
template< class Distance> 
# 71
class CompositeIndex : public NNIndex< Distance>  { 
# 74
public: typedef typename Distance::ElementType ElementType; 
# 75
typedef typename Distance::ResultType DistanceType; 
# 84 "/usr/include/opencv2/flann/composite_index.h" 3
CompositeIndex(const Matrix< typename Distance::ElementType>  &inputData, const ::cvflann::IndexParams &params = ::cvflann::CompositeIndexParams(), Distance 
# 85
d = Distance()) : index_params_(params) 
# 86
{ 
# 87
(kdtree_index_) = (new KDTreeIndex< Distance> (inputData, params, d)); 
# 88
(kmeans_index_) = (new KMeansIndex< Distance> (inputData, params, d)); 
# 90
} 
# 92
CompositeIndex(const CompositeIndex &); 
# 93
CompositeIndex &operator=(const CompositeIndex &); 
# 95
virtual ~CompositeIndex() 
# 96
{ 
# 97
delete (kdtree_index_); 
# 98
delete (kmeans_index_); 
# 99
} 
# 104
::cvflann::flann_algorithm_t getType() const 
# 105
{ 
# 106
return FLANN_INDEX_COMPOSITE; 
# 107
} 
# 112
::size_t size() const 
# 113
{ 
# 114
return ((kdtree_index_)->size()); 
# 115
} 
# 120
::size_t veclen() const 
# 121
{ 
# 122
return ((kdtree_index_)->veclen()); 
# 123
} 
# 128
int usedMemory() const 
# 129
{ 
# 130
return ((kmeans_index_)->usedMemory()) + ((kdtree_index_)->usedMemory()); 
# 131
} 
# 136
void buildIndex() 
# 137
{ 
# 138
Logger::info("Building kmeans tree...\n"); 
# 139
((kmeans_index_)->buildIndex()); 
# 140
Logger::info("Building kdtree tree...\n"); 
# 141
((kdtree_index_)->buildIndex()); 
# 142
} 
# 148
void saveIndex(::FILE *stream) 
# 149
{ 
# 150
((kmeans_index_)->saveIndex(stream)); 
# 151
((kdtree_index_)->saveIndex(stream)); 
# 152
} 
# 158
void loadIndex(::FILE *stream) 
# 159
{ 
# 160
((kmeans_index_)->loadIndex(stream)); 
# 161
((kdtree_index_)->loadIndex(stream)); 
# 162
} 
# 167
::cvflann::IndexParams getParameters() const 
# 168
{ 
# 169
return index_params_; 
# 170
} 
# 175
void findNeighbors(ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, const ::cvflann::SearchParams &searchParams) 
# 176
{ 
# 177
((kmeans_index_)->findNeighbors(result, vec, searchParams)); 
# 178
((kdtree_index_)->findNeighbors(result, vec, searchParams)); 
# 179
} 
# 183
private: KMeansIndex< Distance>  *kmeans_index_; 
# 186
KDTreeIndex< Distance>  *kdtree_index_; 
# 189
const ::cvflann::IndexParams index_params_; 
# 190
}; 
# 192
}
# 37 "/usr/include/opencv2/flann/linear_index.h" 3
namespace cvflann { 
# 40
struct LinearIndexParams : public IndexParams { 
# 42
LinearIndexParams() 
# 43
{ 
# 44
(((*this)["algorithm"]) = (FLANN_INDEX_LINEAR)); 
# 45
} 
# 46
}; 
# 48
template< class Distance> 
# 49
class LinearIndex : public NNIndex< Distance>  { 
# 53
public: typedef typename Distance::ElementType ElementType; 
# 54
typedef typename Distance::ResultType DistanceType; 
# 57
LinearIndex(const Matrix< typename Distance::ElementType>  &inputData, const ::cvflann::IndexParams &params = ::cvflann::LinearIndexParams(), Distance 
# 58
d = Distance()) : dataset_(inputData), index_params_(params), distance_(d) 
# 60
{ 
# 61
} 
# 63
LinearIndex(const LinearIndex &); 
# 64
LinearIndex &operator=(const LinearIndex &); 
# 66
::cvflann::flann_algorithm_t getType() const 
# 67
{ 
# 68
return FLANN_INDEX_LINEAR; 
# 69
} 
# 72
::size_t size() const 
# 73
{ 
# 74
return (dataset_).rows; 
# 75
} 
# 77
::size_t veclen() const 
# 78
{ 
# 79
return (dataset_).cols; 
# 80
} 
# 83
int usedMemory() const 
# 84
{ 
# 85
return 0; 
# 86
} 
# 88
void buildIndex() 
# 89
{ 
# 91
} 
# 93
void saveIndex(::FILE *) 
# 94
{ 
# 96
} 
# 99
void loadIndex(::FILE *) 
# 100
{ 
# 103
(index_params_)["algorithm"] = getType(); 
# 104
} 
# 106
void findNeighbors(ResultSet< typename Distance::ResultType>  &resultSet, const ElementType *vec, const ::cvflann::SearchParams &) 
# 107
{ 
# 108
ElementType *data = (((dataset_).data)); 
# 109
for (::size_t i = (0); i < ((dataset_).rows); (++i), (data += ((dataset_).cols))) { 
# 110
DistanceType dist = (distance_)(data, vec, ((dataset_).cols)); 
# 111
(resultSet.addPoint(dist, (int)i)); 
# 112
}  
# 113
} 
# 115
::cvflann::IndexParams getParameters() const 
# 116
{ 
# 117
return index_params_; 
# 118
} 
# 122
private: const Matrix< typename Distance::ElementType>  dataset_; 
# 124
::cvflann::IndexParams index_params_; 
# 126
Distance distance_; 
# 128
}; 
# 130
}
# 51 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
namespace cvflann { 
# 54
struct HierarchicalClusteringIndexParams : public IndexParams { 
# 56
HierarchicalClusteringIndexParams(int branching = 32, flann_centers_init_t 
# 57
centers_init = FLANN_CENTERS_RANDOM, int 
# 58
trees = 4, int leaf_size = 100) 
# 59
{ 
# 60
(((*this)["algorithm"]) = (FLANN_INDEX_HIERARCHICAL)); 
# 62
(((*this)["branching"]) = branching); 
# 64
(((*this)["centers_init"]) = centers_init); 
# 66
(((*this)["trees"]) = trees); 
# 68
(((*this)["leaf_size"]) = leaf_size); 
# 69
} 
# 70
}; 
# 79 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
template< class Distance> 
# 80
class HierarchicalClusteringIndex : public NNIndex< Distance>  { 
# 83
public: typedef typename Distance::ElementType ElementType; 
# 84
typedef typename Distance::ResultType DistanceType; 
# 89
private: typedef void (::cvflann::HierarchicalClusteringIndex< Distance> ::*centersAlgFunction)(int, int *, int, int *, int &); 
# 94
centersAlgFunction chooseCenters; 
# 108 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
void chooseCentersRandom(int k, int *dsindices, int indices_length, int *centers, int &centers_length) 
# 109
{ 
# 110
::cvflann::UniqueRandom r(indices_length); 
# 112
int index; 
# 113
for (index = 0; index < k; ++index) { 
# 114
bool duplicate = true; 
# 115
int rnd; 
# 116
while (duplicate) { 
# 117
duplicate = false; 
# 118
rnd = r.next(); 
# 119
if (rnd < 0) { 
# 120
centers_length = index; 
# 121
return; 
# 122
}  
# 124
(centers[index]) = (dsindices[rnd]); 
# 126
for (int j = 0; j < index; ++j) { 
# 127
DistanceType sq = (distance)((dataset)[centers[index]], (dataset)[centers[j]], ((dataset).cols)); 
# 128
if (sq < (9.999999999999999791e-17)) { 
# 129
duplicate = true; 
# 130
}  
# 131
}  
# 132
}  
# 133
}  
# 135
centers_length = index; 
# 136
} 
# 149 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
void chooseCentersGonzales(int k, int *dsindices, int indices_length, int *centers, int &centers_length) 
# 150
{ 
# 151
int n = indices_length; 
# 153
int rnd = rand_int(n); 
# 154
((rnd >= 0) && (rnd < n)) ? static_cast< void>(0) : __assert_fail("rnd >=0 && rnd < n", "/usr/include/opencv2/flann/hierarchical_clustering_index.h", 154, __PRETTY_FUNCTION__); 
# 156
(centers[0]) = (dsindices[rnd]); 
# 158
int index; 
# 159
for (index = 1; index < k; ++index) { 
# 161
int best_index = (-1); 
# 162
DistanceType best_val = (0); 
# 163
for (int j = 0; j < n; ++j) { 
# 164
DistanceType dist = (distance)((dataset)[centers[0]], (dataset)[dsindices[j]], ((dataset).cols)); 
# 165
for (int i = 1; i < index; ++i) { 
# 166
DistanceType tmp_dist = (distance)((dataset)[centers[i]], (dataset)[dsindices[j]], ((dataset).cols)); 
# 167
if (tmp_dist < dist) { 
# 168
dist = tmp_dist; 
# 169
}  
# 170
}  
# 171
if (dist > best_val) { 
# 172
best_val = dist; 
# 173
best_index = j; 
# 174
}  
# 175
}  
# 176
if (best_index != (-1)) { 
# 177
(centers[index]) = (dsindices[best_index]); 
# 178
} else 
# 179
{ 
# 180
break; 
# 181
}  
# 182
}  
# 183
centers_length = index; 
# 184
} 
# 200 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
void chooseCentersKMeanspp(int k, int *dsindices, int indices_length, int *centers, int &centers_length) 
# 201
{ 
# 202
int n = indices_length; 
# 204
double currentPot = (0); 
# 205
DistanceType *closestDistSq = new DistanceType [n]; 
# 208
int index = rand_int(n); 
# 209
((index >= 0) && (index < n)) ? static_cast< void>(0) : __assert_fail("index >=0 && index < n", "/usr/include/opencv2/flann/hierarchical_clustering_index.h", 209, __PRETTY_FUNCTION__); 
# 210
(centers[0]) = (dsindices[index]); 
# 214
for (int i = 0; i < n; i++) { 
# 215
(closestDistSq[i]) = (distance)((dataset)[dsindices[i]], (dataset)[dsindices[index]], ((dataset).cols)); 
# 216
(closestDistSq[i]) = ensureSquareDistance< Distance> (closestDistSq[i]); 
# 217
currentPot += (closestDistSq[i]); 
# 218
}  
# 221
const int numLocalTries = 1; 
# 224
int centerCount; 
# 225
for (centerCount = 1; centerCount < k; centerCount++) { 
# 228
double bestNewPot = (-1); 
# 229
int bestNewIndex = 0; 
# 230
for (int localTrial = 0; localTrial < numLocalTries; localTrial++) { 
# 234
double randVal = rand_double(currentPot); 
# 235
for (index = 0; index < (n - 1); index++) { 
# 236
if (randVal <= (closestDistSq[index])) { break; } else { 
# 237
randVal -= (closestDistSq[index]); }  
# 238
}  
# 241
double newPot = (0); 
# 242
for (int i = 0; i < n; i++) { 
# 243
DistanceType dist = (distance)((dataset)[dsindices[i]], (dataset)[dsindices[index]], ((dataset).cols)); 
# 244
newPot += ::std::min(ensureSquareDistance< Distance> (dist), closestDistSq[i]); 
# 245
}  
# 248
if ((bestNewPot < (0)) || (newPot < bestNewPot)) { 
# 249
bestNewPot = newPot; 
# 250
bestNewIndex = index; 
# 251
}  
# 252
}  
# 255
(centers[centerCount]) = (dsindices[bestNewIndex]); 
# 256
currentPot = bestNewPot; 
# 257
for (int i = 0; i < n; i++) { 
# 258
DistanceType dist = (distance)((dataset)[dsindices[i]], (dataset)[dsindices[bestNewIndex]], ((dataset).cols)); 
# 259
(closestDistSq[i]) = ::std::min(ensureSquareDistance< Distance> (dist), closestDistSq[i]); 
# 260
}  
# 261
}  
# 263
centers_length = centerCount; 
# 265
delete [] closestDistSq; 
# 266
} 
# 286 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
void GroupWiseCenterChooser(int k, int *dsindices, int indices_length, int *centers, int &centers_length) 
# 287
{ 
# 288
const float kSpeedUpFactor = (1.299999952F); 
# 290
int n = indices_length; 
# 292
DistanceType *closestDistSq = new DistanceType [n]; 
# 295
int index = rand_int(n); 
# 296
((index >= 0) && (index < n)) ? static_cast< void>(0) : __assert_fail("index >=0 && index < n", "/usr/include/opencv2/flann/hierarchical_clustering_index.h", 296, __PRETTY_FUNCTION__); 
# 297
(centers[0]) = (dsindices[index]); 
# 299
for (int i = 0; i < n; i++) { 
# 300
(closestDistSq[i]) = (distance)((dataset)[dsindices[i]], (dataset)[dsindices[index]], ((dataset).cols)); 
# 301
}  
# 305
int centerCount; 
# 306
for (centerCount = 1; centerCount < k; centerCount++) { 
# 309
double bestNewPot = (-1); 
# 310
int bestNewIndex = 0; 
# 311
DistanceType furthest = (0); 
# 312
for (index = 0; index < n; index++) { 
# 315
if ((closestDistSq[index]) > (kSpeedUpFactor * ((float)furthest))) { 
# 318
double newPot = (0); 
# 319
for (int i = 0; i < n; i++) { 
# 320
newPot += ::std::min((distance)((dataset)[dsindices[i]], (dataset)[dsindices[index]], ((dataset).cols)), closestDistSq[i]); 
# 322
}  
# 325
if ((bestNewPot < (0)) || (newPot <= bestNewPot)) { 
# 326
bestNewPot = newPot; 
# 327
bestNewIndex = index; 
# 328
furthest = (closestDistSq[index]); 
# 329
}  
# 330
}  
# 331
}  
# 334
(centers[centerCount]) = (dsindices[bestNewIndex]); 
# 335
for (int i = 0; i < n; i++) { 
# 336
(closestDistSq[i]) = ::std::min((distance)((dataset)[dsindices[i]], (dataset)[dsindices[bestNewIndex]], ((dataset).cols)), closestDistSq[i]); 
# 338
}  
# 339
}  
# 341
centers_length = centerCount; 
# 343
delete [] closestDistSq; 
# 344
} 
# 357 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
public: HierarchicalClusteringIndex(const Matrix< typename Distance::ElementType>  &inputData, const ::cvflann::IndexParams &index_params = ::cvflann::HierarchicalClusteringIndexParams(), Distance 
# 358
d = Distance()) : dataset(inputData), params(index_params), root((__null)), indices((__null)), distance(d) 
# 360
{ 
# 361
(memoryCounter) = 0; 
# 363
(size_) = ((dataset).rows); 
# 364
(veclen_) = ((dataset).cols); 
# 366
(branching_) = get_param(params, "branching", 32); 
# 367
(centers_init_) = get_param(params, "centers_init", FLANN_CENTERS_RANDOM); 
# 368
(trees_) = get_param(params, "trees", 4); 
# 369
(leaf_size_) = get_param(params, "leaf_size", 100); 
# 371
if ((centers_init_) == (FLANN_CENTERS_RANDOM)) { 
# 372
(chooseCenters) = (&::cvflann::HierarchicalClusteringIndex< Distance> ::chooseCentersRandom); 
# 373
} else { 
# 374
if ((centers_init_) == (FLANN_CENTERS_GONZALES)) { 
# 375
(chooseCenters) = (&::cvflann::HierarchicalClusteringIndex< Distance> ::chooseCentersGonzales); 
# 376
} else { 
# 377
if ((centers_init_) == (FLANN_CENTERS_KMEANSPP)) { 
# 378
(chooseCenters) = (&::cvflann::HierarchicalClusteringIndex< Distance> ::chooseCentersKMeanspp); 
# 379
} else { 
# 380
if ((centers_init_) == (FLANN_CENTERS_GROUPWISE)) { 
# 381
(chooseCenters) = (&::cvflann::HierarchicalClusteringIndex< Distance> ::GroupWiseCenterChooser); 
# 382
} else 
# 383
{ 
# 384
throw ((::cvflann::FLANNException)("Unknown algorithm for choosing initial centers.")); 
# 385
}  }  }  }  
# 387
(trees_) = get_param(params, "trees", 4); 
# 388
(root) = (new NodePtr [trees_]); 
# 389
(indices) = (new int *[trees_]); 
# 391
for (int i = 0; i < (trees_); ++i) { 
# 392
((root)[i]) = __null; 
# 393
((indices)[i]) = (__null); 
# 394
}  
# 395
} 
# 397
HierarchicalClusteringIndex(const HierarchicalClusteringIndex &); 
# 398
HierarchicalClusteringIndex &operator=(const HierarchicalClusteringIndex &); 
# 405
virtual ~HierarchicalClusteringIndex() 
# 406
{ 
# 407
free_elements(); 
# 409
if ((root) != __null) { 
# 410
delete [] (root); 
# 411
}  
# 413
if ((indices) != (__null)) { 
# 414
delete [] (indices); 
# 415
}  
# 416
} 
# 422
void free_elements() 
# 423
{ 
# 424
if ((indices) != (__null)) { 
# 425
for (int i = 0; i < (trees_); ++i) { 
# 426
if (((indices)[i]) != (__null)) { 
# 427
delete [] ((indices)[i]); 
# 428
((indices)[i]) = (__null); 
# 429
}  
# 430
}  
# 431
}  
# 432
} 
# 438
::size_t size() const 
# 439
{ 
# 440
return size_; 
# 441
} 
# 446
::size_t veclen() const 
# 447
{ 
# 448
return veclen_; 
# 449
} 
# 456
int usedMemory() const 
# 457
{ 
# 458
return (((pool).usedMemory) + ((pool).wastedMemory)) + (memoryCounter); 
# 459
} 
# 464
void buildIndex() 
# 465
{ 
# 466
if ((branching_) < 2) { 
# 467
throw ((::cvflann::FLANNException)("Branching factor must be at least 2")); 
# 468
}  
# 470
free_elements(); 
# 472
for (int i = 0; i < (trees_); ++i) { 
# 473
((indices)[i]) = (new int [size_]); 
# 474
for (::size_t j = (0); j < (size_); ++j) { 
# 475
(((indices)[i])[j]) = ((int)j); 
# 476
}  
# 477
((root)[i]) = ((pool).template allocate< Node> ()); 
# 478
computeClustering((root)[i], (indices)[i], (int)(size_), branching_, 0); 
# 479
}  
# 480
} 
# 483
::cvflann::flann_algorithm_t getType() const 
# 484
{ 
# 485
return FLANN_INDEX_HIERARCHICAL; 
# 486
} 
# 489
void saveIndex(::FILE *stream) 
# 490
{ 
# 491
save_value(stream, branching_); 
# 492
save_value(stream, trees_); 
# 493
save_value(stream, centers_init_); 
# 494
save_value(stream, leaf_size_); 
# 495
save_value(stream, memoryCounter); 
# 496
for (int i = 0; i < (trees_); ++i) { 
# 497
save_value(stream, *((indices)[i]), size_); 
# 498
save_tree(stream, (root)[i], i); 
# 499
}  
# 501
} 
# 504
void loadIndex(::FILE *stream) 
# 505
{ 
# 506
free_elements(); 
# 508
if ((root) != __null) { 
# 509
delete [] (root); 
# 510
}  
# 512
if ((indices) != (__null)) { 
# 513
delete [] (indices); 
# 514
}  
# 516
load_value(stream, branching_); 
# 517
load_value(stream, trees_); 
# 518
load_value(stream, centers_init_); 
# 519
load_value(stream, leaf_size_); 
# 520
load_value(stream, memoryCounter); 
# 522
(indices) = (new int *[trees_]); 
# 523
(root) = (new NodePtr [trees_]); 
# 524
for (int i = 0; i < (trees_); ++i) { 
# 525
((indices)[i]) = (new int [size_]); 
# 526
load_value(stream, *((indices)[i]), size_); 
# 527
load_tree(stream, (root)[i], i); 
# 528
}  
# 530
(params)["algorithm"] = getType(); 
# 531
(((params)["branching"]) = (branching_)); 
# 532
(((params)["trees"]) = (trees_)); 
# 533
(((params)["centers_init"]) = (centers_init_)); 
# 534
(((params)["leaf_size"]) = (leaf_size_)); 
# 535
} 
# 547 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
void findNeighbors(ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, const ::cvflann::SearchParams &searchParams) 
# 548
{ 
# 550
int maxChecks = get_param(searchParams, "checks", 32); 
# 553
Heap< BranchStruct< Node *, typename Distance::ResultType> >  *heap = new Heap< BranchStruct< Node *, typename Distance::ResultType> > ((int)(size_)); 
# 555
::std::vector< bool>  checked(size_, false); 
# 556
int checks = 0; 
# 557
for (int i = 0; i < (trees_); ++i) { 
# 558
findNN((root)[i], result, vec, checks, maxChecks, heap, checked); 
# 559
}  
# 561
BranchSt branch; 
# 562
while ((heap->popMin(branch)) && ((checks < maxChecks) || (!(result.full())))) { 
# 563
NodePtr node = ((branch.node)); 
# 564
findNN(node, result, vec, checks, maxChecks, heap, checked); 
# 565
}  
# 566
((result.full())) ? static_cast< void>(0) : __assert_fail("result.full()", "/usr/include/opencv2/flann/hierarchical_clustering_index.h", 566, __PRETTY_FUNCTION__); 
# 568
delete heap; 
# 570
} 
# 572
::cvflann::IndexParams getParameters() const 
# 573
{ 
# 574
return params; 
# 575
} 
# 583
private: struct Node { 
# 588
int pivot; 
# 592
int size; 
# 596
Node **childs; 
# 600
int *indices; 
# 604
int level; 
# 605
}; 
# 606
typedef Node *NodePtr; 
# 613
typedef BranchStruct< Node *, typename Distance::ResultType>  BranchSt; 
# 617
void save_tree(::FILE *stream, NodePtr node, int num) 
# 618
{ 
# 619
save_value(stream, *node); 
# 620
if ((node->childs) == __null) { 
# 621
int indices_offset = (int)((node->indices) - ((indices)[num])); 
# 622
save_value(stream, indices_offset); 
# 623
} else 
# 624
{ 
# 625
for (int i = 0; i < (branching_); ++i) { 
# 626
save_tree(stream, (node->childs)[i], num); 
# 627
}  
# 628
}  
# 629
} 
# 632
void load_tree(::FILE *stream, NodePtr &node, int num) 
# 633
{ 
# 634
node = ((pool).template allocate< Node> ()); 
# 635
load_value(stream, *node); 
# 636
if ((node->childs) == __null) { 
# 637
int indices_offset; 
# 638
load_value(stream, indices_offset); 
# 639
(node->indices) = (((indices)[num]) + indices_offset); 
# 640
} else 
# 641
{ 
# 642
(node->childs) = ((pool).template allocate< NodePtr> (branching_)); 
# 643
for (int i = 0; i < (branching_); ++i) { 
# 644
load_tree(stream, (node->childs)[i], num); 
# 645
}  
# 646
}  
# 647
} 
# 652
void computeLabels(int *dsindices, int indices_length, int *centers, int centers_length, int *labels, DistanceType &cost) 
# 653
{ 
# 654
cost = 0; 
# 655
for (int i = 0; i < indices_length; ++i) { 
# 656
ElementType *point = (dataset)[dsindices[i]]; 
# 657
DistanceType dist = (distance)(point, (dataset)[centers[0]], veclen_); 
# 658
(labels[i]) = 0; 
# 659
for (int j = 1; j < centers_length; ++j) { 
# 660
DistanceType new_dist = (distance)(point, (dataset)[centers[j]], veclen_); 
# 661
if (dist > new_dist) { 
# 662
(labels[i]) = j; 
# 663
dist = new_dist; 
# 664
}  
# 665
}  
# 666
cost += dist; 
# 667
}  
# 668
} 
# 681 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
void computeClustering(NodePtr node, int *dsindices, int indices_length, int branching, int level) 
# 682
{ 
# 683
(node->size) = indices_length; 
# 684
(node->level) = level; 
# 686
if (indices_length < (leaf_size_)) { 
# 687
(node->indices) = dsindices; 
# 688
::std::sort((node->indices), (node->indices) + indices_length); 
# 689
(node->childs) = __null; 
# 690
return; 
# 691
}  
# 693
::std::vector< int>  centers(branching); 
# 694
::std::vector< int>  labels(indices_length); 
# 696
int centers_length; 
# 697
(this->*(chooseCenters))(branching, dsindices, indices_length, &centers[0], centers_length); 
# 699
if (centers_length < branching) { 
# 700
(node->indices) = dsindices; 
# 701
::std::sort((node->indices), (node->indices) + indices_length); 
# 702
(node->childs) = __null; 
# 703
return; 
# 704
}  
# 708
DistanceType cost; 
# 709
computeLabels(dsindices, indices_length, &centers[0], centers_length, &labels[0], cost); 
# 711
(node->childs) = ((pool).template allocate< NodePtr> (branching)); 
# 712
int start = 0; 
# 713
int end = start; 
# 714
for (int i = 0; i < branching; ++i) { 
# 715
for (int j = 0; j < indices_length; ++j) { 
# 716
if (labels[j] == i) { 
# 717
std::swap(dsindices[j], dsindices[end]); 
# 718
std::swap(labels[j], labels[end]); 
# 719
end++; 
# 720
}  
# 721
}  
# 723
((node->childs)[i]) = ((pool).template allocate< Node> ()); 
# 724
(((node->childs)[i])->pivot) = centers[i]; 
# 725
(((node->childs)[i])->indices) = __null; 
# 726
computeClustering((node->childs)[i], dsindices + start, end - start, branching, level + 1); 
# 727
start = end; 
# 728
}  
# 729
} 
# 746 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
void findNN(NodePtr node, ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, int &checks, int maxChecks, Heap< BranchStruct< Node *, typename Distance::ResultType> >  *
# 747
heap, ::std::vector< bool>  &checked) 
# 748
{ 
# 749
if ((node->childs) == __null) { 
# 750
if (checks >= maxChecks) { 
# 751
if ((result.full())) { return; }  
# 752
}  
# 753
for (int i = 0; i < (node->size); ++i) { 
# 754
int index = (node->indices)[i]; 
# 755
if (!checked[index]) { 
# 756
DistanceType dist = (distance)((dataset)[index], vec, veclen_); 
# 757
(result.addPoint(dist, index)); 
# 758
((checked[index]) = (true)); 
# 759
++checks; 
# 760
}  
# 761
}  
# 762
} else 
# 763
{ 
# 764
DistanceType *domain_distances = new DistanceType [branching_]; 
# 765
int best_index = 0; 
# 766
(domain_distances[best_index]) = (distance)(vec, (dataset)[((node->childs)[best_index])->pivot], veclen_); 
# 767
for (int i = 1; i < (branching_); ++i) { 
# 768
(domain_distances[i]) = (distance)(vec, (dataset)[((node->childs)[i])->pivot], veclen_); 
# 769
if ((domain_distances[i]) < (domain_distances[best_index])) { 
# 770
best_index = i; 
# 771
}  
# 772
}  
# 773
for (int i = 0; i < (branching_); ++i) { 
# 774
if (i != best_index) { 
# 775
(heap->insert(BranchSt((node->childs)[i], domain_distances[i]))); 
# 776
}  
# 777
}  
# 778
delete [] domain_distances; 
# 779
findNN((node->childs)[best_index], result, vec, checks, maxChecks, heap, checked); 
# 780
}  
# 781
} 
# 789
const Matrix< typename Distance::ElementType>  dataset; 
# 794
::cvflann::IndexParams params; 
# 800
::size_t size_; 
# 805
::size_t veclen_; 
# 810
NodePtr *root; 
# 815
int **indices; 
# 821
Distance distance; 
# 830 "/usr/include/opencv2/flann/hierarchical_clustering_index.h" 3
::cvflann::PooledAllocator pool; 
# 835
int memoryCounter; 
# 838
int branching_; 
# 839
int trees_; 
# 840
::cvflann::flann_centers_init_t centers_init_; 
# 841
int leaf_size_; 
# 844
}; 
# 846
}
# 41 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 52 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
class time_base { 
# 55
public: enum dateorder { no_order, dmy, mdy, ymd, ydm}; 
# 56
}; 
# 58
template< class _CharT> 
# 59
struct __timepunct_cache : public locale::facet { 
# 62
static const _CharT *_S_timezones[14]; 
# 64
const _CharT *_M_date_format; 
# 65
const _CharT *_M_date_era_format; 
# 66
const _CharT *_M_time_format; 
# 67
const _CharT *_M_time_era_format; 
# 68
const _CharT *_M_date_time_format; 
# 69
const _CharT *_M_date_time_era_format; 
# 70
const _CharT *_M_am; 
# 71
const _CharT *_M_pm; 
# 72
const _CharT *_M_am_pm_format; 
# 75
const _CharT *_M_day1; 
# 76
const _CharT *_M_day2; 
# 77
const _CharT *_M_day3; 
# 78
const _CharT *_M_day4; 
# 79
const _CharT *_M_day5; 
# 80
const _CharT *_M_day6; 
# 81
const _CharT *_M_day7; 
# 84
const _CharT *_M_aday1; 
# 85
const _CharT *_M_aday2; 
# 86
const _CharT *_M_aday3; 
# 87
const _CharT *_M_aday4; 
# 88
const _CharT *_M_aday5; 
# 89
const _CharT *_M_aday6; 
# 90
const _CharT *_M_aday7; 
# 93
const _CharT *_M_month01; 
# 94
const _CharT *_M_month02; 
# 95
const _CharT *_M_month03; 
# 96
const _CharT *_M_month04; 
# 97
const _CharT *_M_month05; 
# 98
const _CharT *_M_month06; 
# 99
const _CharT *_M_month07; 
# 100
const _CharT *_M_month08; 
# 101
const _CharT *_M_month09; 
# 102
const _CharT *_M_month10; 
# 103
const _CharT *_M_month11; 
# 104
const _CharT *_M_month12; 
# 107
const _CharT *_M_amonth01; 
# 108
const _CharT *_M_amonth02; 
# 109
const _CharT *_M_amonth03; 
# 110
const _CharT *_M_amonth04; 
# 111
const _CharT *_M_amonth05; 
# 112
const _CharT *_M_amonth06; 
# 113
const _CharT *_M_amonth07; 
# 114
const _CharT *_M_amonth08; 
# 115
const _CharT *_M_amonth09; 
# 116
const _CharT *_M_amonth10; 
# 117
const _CharT *_M_amonth11; 
# 118
const _CharT *_M_amonth12; 
# 120
bool _M_allocated; 
# 122
__timepunct_cache(size_t __refs = 0) : locale::facet(__refs), _M_date_format((0)), _M_date_era_format((0)), _M_time_format((0)), _M_time_era_format((0)), _M_date_time_format((0)), _M_date_time_era_format((0)), _M_am((0)), _M_pm((0)), _M_am_pm_format((0)), _M_day1((0)), _M_day2((0)), _M_day3((0)), _M_day4((0)), _M_day5((0)), _M_day6((0)), _M_day7((0)), _M_aday1((0)), _M_aday2((0)), _M_aday3((0)), _M_aday4((0)), _M_aday5((0)), _M_aday6((0)), _M_aday7((0)), _M_month01((0)), _M_month02((0)), _M_month03((0)), _M_month04((0)), _M_month05((0)), _M_month06((0)), _M_month07((0)), _M_month08((0)), _M_month09((0)), _M_month10((0)), _M_month11((0)), _M_month12((0)), _M_amonth01((0)), _M_amonth02((0)), _M_amonth03((0)), _M_amonth04((0)), _M_amonth05((0)), _M_amonth06((0)), _M_amonth07((0)), _M_amonth08((0)), _M_amonth09((0)), _M_amonth10((0)), _M_amonth11((0)), _M_amonth12((0)), _M_allocated(false) 
# 137
{ } 
# 139
virtual ~__timepunct_cache(); 
# 143
private: __timepunct_cache &operator=(const __timepunct_cache &); 
# 146
explicit __timepunct_cache(const __timepunct_cache &); 
# 147
}; 
# 149
template< class _CharT> 
# 150
__timepunct_cache< _CharT> ::~__timepunct_cache() 
# 151
{ 
# 152
if (_M_allocated) 
# 153
{ 
# 155
}  
# 156
} 
# 161
template<> const char *__timepunct_cache< char> ::_S_timezones[14]; 
# 166
template<> const wchar_t *__timepunct_cache< wchar_t> ::_S_timezones[14]; 
# 170
template< class _CharT> const _CharT *
# 171
__timepunct_cache< _CharT> ::_S_timezones[14]; 
# 173
template< class _CharT> 
# 174
class __timepunct : public locale::facet { 
# 178
public: typedef _CharT __char_type; 
# 179
typedef __timepunct_cache< _CharT>  __cache_type; 
# 182
protected: __cache_type *_M_data; 
# 183
__c_locale _M_c_locale_timepunct; 
# 184
const char *_M_name_timepunct; 
# 188
public: static locale::id id; 
# 191
explicit __timepunct(size_t __refs = 0); 
# 194
explicit __timepunct(__cache_type * __cache, size_t __refs = 0); 
# 207 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
explicit __timepunct(__c_locale __cloc, const char * __s, size_t __refs = 0); 
# 212
void _M_put(_CharT * __s, size_t __maxlen, const _CharT * __format, const tm * __tm) const throw(); 
# 216
void _M_date_formats(const _CharT **__date) const 
# 217
{ 
# 219
(__date[0]) = ((_M_data)->_M_date_format); 
# 220
(__date[1]) = ((_M_data)->_M_date_era_format); 
# 221
} 
# 224
void _M_time_formats(const _CharT **__time) const 
# 225
{ 
# 227
(__time[0]) = ((_M_data)->_M_time_format); 
# 228
(__time[1]) = ((_M_data)->_M_time_era_format); 
# 229
} 
# 232
void _M_date_time_formats(const _CharT **__dt) const 
# 233
{ 
# 235
(__dt[0]) = ((_M_data)->_M_date_time_format); 
# 236
(__dt[1]) = ((_M_data)->_M_date_time_era_format); 
# 237
} 
# 240
void _M_am_pm_format(const _CharT *__ampm) const 
# 241
{ __ampm = ((_M_data)->_M_am_pm_format); } 
# 244
void _M_am_pm(const _CharT **__ampm) const 
# 245
{ 
# 246
(__ampm[0]) = ((_M_data)->_M_am); 
# 247
(__ampm[1]) = ((_M_data)->_M_pm); 
# 248
} 
# 251
void _M_days(const _CharT **__days) const 
# 252
{ 
# 253
(__days[0]) = ((_M_data)->_M_day1); 
# 254
(__days[1]) = ((_M_data)->_M_day2); 
# 255
(__days[2]) = ((_M_data)->_M_day3); 
# 256
(__days[3]) = ((_M_data)->_M_day4); 
# 257
(__days[4]) = ((_M_data)->_M_day5); 
# 258
(__days[5]) = ((_M_data)->_M_day6); 
# 259
(__days[6]) = ((_M_data)->_M_day7); 
# 260
} 
# 263
void _M_days_abbreviated(const _CharT **__days) const 
# 264
{ 
# 265
(__days[0]) = ((_M_data)->_M_aday1); 
# 266
(__days[1]) = ((_M_data)->_M_aday2); 
# 267
(__days[2]) = ((_M_data)->_M_aday3); 
# 268
(__days[3]) = ((_M_data)->_M_aday4); 
# 269
(__days[4]) = ((_M_data)->_M_aday5); 
# 270
(__days[5]) = ((_M_data)->_M_aday6); 
# 271
(__days[6]) = ((_M_data)->_M_aday7); 
# 272
} 
# 275
void _M_months(const _CharT **__months) const 
# 276
{ 
# 277
(__months[0]) = ((_M_data)->_M_month01); 
# 278
(__months[1]) = ((_M_data)->_M_month02); 
# 279
(__months[2]) = ((_M_data)->_M_month03); 
# 280
(__months[3]) = ((_M_data)->_M_month04); 
# 281
(__months[4]) = ((_M_data)->_M_month05); 
# 282
(__months[5]) = ((_M_data)->_M_month06); 
# 283
(__months[6]) = ((_M_data)->_M_month07); 
# 284
(__months[7]) = ((_M_data)->_M_month08); 
# 285
(__months[8]) = ((_M_data)->_M_month09); 
# 286
(__months[9]) = ((_M_data)->_M_month10); 
# 287
(__months[10]) = ((_M_data)->_M_month11); 
# 288
(__months[11]) = ((_M_data)->_M_month12); 
# 289
} 
# 292
void _M_months_abbreviated(const _CharT **__months) const 
# 293
{ 
# 294
(__months[0]) = ((_M_data)->_M_amonth01); 
# 295
(__months[1]) = ((_M_data)->_M_amonth02); 
# 296
(__months[2]) = ((_M_data)->_M_amonth03); 
# 297
(__months[3]) = ((_M_data)->_M_amonth04); 
# 298
(__months[4]) = ((_M_data)->_M_amonth05); 
# 299
(__months[5]) = ((_M_data)->_M_amonth06); 
# 300
(__months[6]) = ((_M_data)->_M_amonth07); 
# 301
(__months[7]) = ((_M_data)->_M_amonth08); 
# 302
(__months[8]) = ((_M_data)->_M_amonth09); 
# 303
(__months[9]) = ((_M_data)->_M_amonth10); 
# 304
(__months[10]) = ((_M_data)->_M_amonth11); 
# 305
(__months[11]) = ((_M_data)->_M_amonth12); 
# 306
} 
# 310
protected: virtual ~__timepunct(); 
# 314
void _M_initialize_timepunct(__c_locale __cloc = 0); 
# 315
}; 
# 317
template< class _CharT> locale::id 
# 318
__timepunct< _CharT> ::id; 
# 323
template<> void __timepunct< char> ::_M_initialize_timepunct(__c_locale __cloc); 
# 327
template<> void __timepunct< char> ::_M_put(char *, size_t, const char *, const tm *) const throw(); 
# 332
template<> void __timepunct< wchar_t> ::_M_initialize_timepunct(__c_locale __cloc); 
# 336
template<> void __timepunct< wchar_t> ::_M_put(wchar_t *, size_t, const wchar_t *, const tm *) const throw(); 
# 341
}
# 37 "/usr/include/aarch64-linux-gnu/c++/5/bits/time_members.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
template< class _CharT> 
# 42
__timepunct< _CharT> ::__timepunct(size_t __refs) : locale::facet(__refs), _M_data((0)), _M_c_locale_timepunct((0)), _M_name_timepunct(_S_get_c_name()) 
# 45
{ _M_initialize_timepunct(); } 
# 47
template< class _CharT> 
# 48
__timepunct< _CharT> ::__timepunct(__cache_type *__cache, size_t __refs) : locale::facet(__refs), _M_data(__cache), _M_c_locale_timepunct((0)), _M_name_timepunct(_S_get_c_name()) 
# 51
{ _M_initialize_timepunct(); } 
# 53
template< class _CharT> 
# 54
__timepunct< _CharT> ::__timepunct(__c_locale __cloc, const char *__s, size_t 
# 55
__refs) : locale::facet(__refs), _M_data((0)), _M_c_locale_timepunct((0)), _M_name_timepunct((0)) 
# 58
{ 
# 59
if (__builtin_strcmp(__s, _S_get_c_name()) != 0) 
# 60
{ 
# 61
const size_t __len = __builtin_strlen(__s) + (1); 
# 62
char *__tmp = new char [__len]; 
# 63
__builtin_memcpy(__tmp, __s, __len); 
# 64
(_M_name_timepunct) = __tmp; 
# 65
} else { 
# 67
(_M_name_timepunct) = _S_get_c_name(); }  
# 69
try 
# 70
{ _M_initialize_timepunct(__cloc); } 
# 71
catch (...) 
# 72
{ 
# 73
if ((_M_name_timepunct) != _S_get_c_name()) { 
# 74
delete [] (_M_name_timepunct); }  
# 75
throw; 
# 76
}  
# 77
} 
# 79
template< class _CharT> 
# 80
__timepunct< _CharT> ::~__timepunct() 
# 81
{ 
# 82
if ((_M_name_timepunct) != _S_get_c_name()) { 
# 83
delete [] (_M_name_timepunct); }  
# 84
delete (_M_data); 
# 85
_S_destroy_c_locale(_M_c_locale_timepunct); 
# 86
} 
# 89
}
# 346 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 350
inline namespace __cxx11 { 
# 365 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
template< class _CharT, class _InIter> 
# 366
class time_get : public locale::facet, public time_base { 
# 372
public: typedef _CharT char_type; 
# 373
typedef _InIter iter_type; 
# 377
static locale::id id; 
# 387 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
explicit time_get(size_t __refs = 0) : locale::facet(__refs) 
# 388
{ } 
# 404 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
dateorder date_order() const 
# 405
{ return this->do_date_order(); } 
# 428 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type get_time(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 429
__err, tm *__tm) const 
# 430
{ return this->do_get_time(__beg, __end, __io, __err, __tm); } 
# 453 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type get_date(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 454
__err, tm *__tm) const 
# 455
{ return this->do_get_date(__beg, __end, __io, __err, __tm); } 
# 481 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type get_weekday(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 482
__err, tm *__tm) const 
# 483
{ return this->do_get_weekday(__beg, __end, __io, __err, __tm); } 
# 510 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type get_monthname(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 511
__err, tm *__tm) const 
# 512
{ return this->do_get_monthname(__beg, __end, __io, __err, __tm); } 
# 536 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type get_year(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 537
__err, tm *__tm) const 
# 538
{ return this->do_get_year(__beg, __end, __io, __err, __tm); } 
# 557 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type get(iter_type __s, iter_type __end, ios_base &__io, ios_base::iostate &
# 558
__err, tm *__tm, char __format, char 
# 559
__modifier = 0) const 
# 560
{ 
# 561
return this->do_get(__s, __end, __io, __err, __tm, __format, __modifier); 
# 563
} 
# 583 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
inline iter_type get(iter_type __s, iter_type __end, ios_base & __io, ios_base::iostate & __err, tm * __tm, const char_type * __fmt, const char_type * __fmtend) const; 
# 591
protected: virtual ~time_get() { } 
# 604 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual dateorder do_date_order() const; 
# 622 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual iter_type do_get_time(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, tm * __tm) const; 
# 641 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual iter_type do_get_date(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, tm * __tm) const; 
# 660 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual iter_type do_get_weekday(iter_type __beg, iter_type __end, ios_base &, ios_base::iostate & __err, tm * __tm) const; 
# 679 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual iter_type do_get_monthname(iter_type __beg, iter_type __end, ios_base &, ios_base::iostate & __err, tm * __tm) const; 
# 698 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual iter_type do_get_year(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, tm * __tm) const; 
# 723 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
inline virtual iter_type do_get(iter_type __s, iter_type __end, ios_base & __f, ios_base::iostate & __err, tm * __tm, char __format, char __modifier) const; 
# 730
iter_type _M_extract_num(iter_type __beg, iter_type __end, int & __member, int __min, int __max, size_t __len, ios_base & __io, ios_base::iostate & __err) const; 
# 736
iter_type _M_extract_name(iter_type __beg, iter_type __end, int & __member, const _CharT ** __names, size_t __indexlen, ios_base & __io, ios_base::iostate & __err) const; 
# 742
iter_type _M_extract_wday_or_month(iter_type __beg, iter_type __end, int & __member, const _CharT ** __names, size_t __indexlen, ios_base & __io, ios_base::iostate & __err) const; 
# 748
iter_type _M_extract_via_format(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, tm * __tm, const _CharT * __format) const; 
# 751
}; 
# 753
template< class _CharT, class _InIter> locale::id 
# 754
time_get< _CharT, _InIter> ::id; 
# 757
template< class _CharT, class _InIter> 
# 758
class time_get_byname : public time_get< _CharT, _InIter>  { 
# 762
public: typedef _CharT char_type; 
# 763
typedef _InIter iter_type; 
# 766
explicit time_get_byname(const char *, ::std::size_t __refs = 0) : ::std::__cxx11::time_get< _CharT, _InIter> (__refs) 
# 767
{ } 
# 771
explicit time_get_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs = 0) : time_get_byname(__s.c_str(), __refs) 
# 772
{ } 
# 777
protected: virtual ~time_get_byname() { } 
# 778
}; 
# 780
}
# 794 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
template< class _CharT, class _OutIter> 
# 795
class time_put : public locale::facet { 
# 801
public: typedef _CharT char_type; 
# 802
typedef _OutIter iter_type; 
# 806
static locale::id id; 
# 816 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
explicit time_put(size_t __refs = 0) : locale::facet(__refs) 
# 817
{ } 
# 835 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type put(iter_type __s, ios_base & __io, char_type __fill, const tm * __tm, const _CharT * __beg, const _CharT * __end) const; 
# 855 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type put(iter_type __s, ios_base &__io, char_type __fill, const tm *
# 856
__tm, char __format, char __mod = 0) const 
# 857
{ return this->do_put(__s, __io, __fill, __tm, __format, __mod); } 
# 862
protected: virtual ~time_put() 
# 863
{ } 
# 882 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual iter_type do_put(iter_type __s, ios_base & __io, char_type __fill, const tm * __tm, char __format, char __mod) const; 
# 884
}; 
# 886
template< class _CharT, class _OutIter> locale::id 
# 887
time_put< _CharT, _OutIter> ::id; 
# 890
template< class _CharT, class _OutIter> 
# 891
class time_put_byname : public time_put< _CharT, _OutIter>  { 
# 895
public: typedef _CharT char_type; 
# 896
typedef _OutIter iter_type; 
# 899
explicit time_put_byname(const char *, ::std::size_t __refs = 0) : ::std::time_put< _CharT, _OutIter> (__refs) 
# 901
{ } 
# 905
explicit time_put_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs = 0) : time_put_byname(__s.c_str(), __refs) 
# 906
{ } 
# 911
protected: virtual ~time_put_byname() { } 
# 912
}; 
# 926 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
class money_base { 
# 929
public: enum part { none, space, symbol, sign, value}; 
# 930
struct pattern { char field[4]; }; 
# 932
static const pattern _S_default_pattern; 
# 935
enum { 
# 936
_S_minus, 
# 937
_S_zero, 
# 938
_S_end = 11
# 939
}; 
# 943
static const char *_S_atoms; 
# 947
__attribute((const)) static pattern 
# 948
_S_construct_pattern(char __precedes, char __space, char __posn) throw(); 
# 949
}; 
# 951
template< class _CharT, bool _Intl> 
# 952
struct __moneypunct_cache : public locale::facet { 
# 954
const char *_M_grouping; 
# 955
size_t _M_grouping_size; 
# 956
bool _M_use_grouping; 
# 957
_CharT _M_decimal_point; 
# 958
_CharT _M_thousands_sep; 
# 959
const _CharT *_M_curr_symbol; 
# 960
size_t _M_curr_symbol_size; 
# 961
const _CharT *_M_positive_sign; 
# 962
size_t _M_positive_sign_size; 
# 963
const _CharT *_M_negative_sign; 
# 964
size_t _M_negative_sign_size; 
# 965
int _M_frac_digits; 
# 966
money_base::pattern _M_pos_format; 
# 967
money_base::pattern _M_neg_format; 
# 972
_CharT _M_atoms[money_base::_S_end]; 
# 974
bool _M_allocated; 
# 976
__moneypunct_cache(size_t __refs = 0) : locale::facet(__refs), _M_grouping((0)), _M_grouping_size((0)), _M_use_grouping(false), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_curr_symbol((0)), _M_curr_symbol_size((0)), _M_positive_sign((0)), _M_positive_sign_size((0)), _M_negative_sign((0)), _M_negative_sign_size((0)), _M_frac_digits(0), _M_pos_format((money_base::pattern())), _M_neg_format((money_base::pattern())), _M_allocated(false) 
# 985
{ } 
# 987
virtual ~__moneypunct_cache(); 
# 990
void _M_cache(const locale & __loc); 
# 994
private: __moneypunct_cache &operator=(const __moneypunct_cache &); 
# 997
explicit __moneypunct_cache(const __moneypunct_cache &); 
# 998
}; 
# 1000
template< class _CharT, bool _Intl> 
# 1001
__moneypunct_cache< _CharT, _Intl> ::~__moneypunct_cache() 
# 1002
{ 
# 1003
if (_M_allocated) 
# 1004
{ 
# 1005
delete [] (_M_grouping); 
# 1006
delete [] (_M_curr_symbol); 
# 1007
delete [] (_M_positive_sign); 
# 1008
delete [] (_M_negative_sign); 
# 1009
}  
# 1010
} 
# 1012
inline namespace __cxx11 { 
# 1021 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
template< class _CharT, bool _Intl> 
# 1022
class moneypunct : public locale::facet, public money_base { 
# 1028
public: typedef _CharT char_type; 
# 1029
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 1031
typedef __moneypunct_cache< _CharT, _Intl>  __cache_type; 
# 1034
private: __cache_type *_M_data; 
# 1039
public: static const bool intl = _Intl; 
# 1041
static locale::id id; 
# 1051 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
explicit moneypunct(size_t __refs = 0) : locale::facet(__refs), _M_data((0)) 
# 1053
{ _M_initialize_moneypunct(); } 
# 1064 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
explicit moneypunct(__cache_type *__cache, size_t __refs = 0) : locale::facet(__refs), _M_data(__cache) 
# 1066
{ _M_initialize_moneypunct(); } 
# 1079 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
explicit moneypunct(__c_locale __cloc, const char *__s, size_t __refs = 0) : locale::facet(__refs), _M_data((0)) 
# 1081
{ _M_initialize_moneypunct(__cloc, __s); } 
# 1093 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
char_type decimal_point() const 
# 1094
{ return this->do_decimal_point(); } 
# 1106 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
char_type thousands_sep() const 
# 1107
{ return this->do_thousands_sep(); } 
# 1136 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
string grouping() const 
# 1137
{ return this->do_grouping(); } 
# 1149 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
string_type curr_symbol() const 
# 1150
{ return this->do_curr_symbol(); } 
# 1166 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
string_type positive_sign() const 
# 1167
{ return this->do_positive_sign(); } 
# 1183 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
string_type negative_sign() const 
# 1184
{ return this->do_negative_sign(); } 
# 1199 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
int frac_digits() const 
# 1200
{ return this->do_frac_digits(); } 
# 1235 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
pattern pos_format() const 
# 1236
{ return this->do_pos_format(); } 
# 1239
pattern neg_format() const 
# 1240
{ return this->do_neg_format(); } 
# 1246
protected: virtual ~moneypunct(); 
# 1257 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual char_type do_decimal_point() const 
# 1258
{ return (_M_data)->_M_decimal_point; } 
# 1269 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual char_type do_thousands_sep() const 
# 1270
{ return (_M_data)->_M_thousands_sep; } 
# 1282 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual string do_grouping() const 
# 1283
{ return ((_M_data)->_M_grouping); } 
# 1295 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual string_type do_curr_symbol() const 
# 1296
{ return ((_M_data)->_M_curr_symbol); } 
# 1308 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual string_type do_positive_sign() const 
# 1309
{ return ((_M_data)->_M_positive_sign); } 
# 1321 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual string_type do_negative_sign() const 
# 1322
{ return ((_M_data)->_M_negative_sign); } 
# 1335 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual int do_frac_digits() const 
# 1336
{ return (_M_data)->_M_frac_digits; } 
# 1349 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual pattern do_pos_format() const 
# 1350
{ return ((_M_data)->_M_pos_format); } 
# 1363 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual pattern do_neg_format() const 
# 1364
{ return ((_M_data)->_M_neg_format); } 
# 1368
void _M_initialize_moneypunct(__c_locale __cloc = 0, const char * __name = 0); 
# 1370
}; 
# 1372
template< class _CharT, bool _Intl> locale::id 
# 1373
moneypunct< _CharT, _Intl> ::id; 
# 1375
template< class _CharT, bool _Intl> const bool 
# 1376
moneypunct< _CharT, _Intl> ::intl; 
# 1379
template<> moneypunct< char, true> ::~moneypunct(); 
# 1382
template<> moneypunct< char, false> ::~moneypunct(); 
# 1386
template<> void moneypunct< char, true> ::_M_initialize_moneypunct(__c_locale, const char *); 
# 1390
template<> void moneypunct< char, false> ::_M_initialize_moneypunct(__c_locale, const char *); 
# 1394
template<> moneypunct< wchar_t, true> ::~moneypunct(); 
# 1397
template<> moneypunct< wchar_t, false> ::~moneypunct(); 
# 1401
template<> void moneypunct< wchar_t, true> ::_M_initialize_moneypunct(__c_locale, const char *); 
# 1406
template<> void moneypunct< wchar_t, false> ::_M_initialize_moneypunct(__c_locale, const char *); 
# 1411
template< class _CharT, bool _Intl> 
# 1412
class moneypunct_byname : public moneypunct< _CharT, _Intl>  { 
# 1415
public: typedef _CharT char_type; 
# 1416
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 1418
static const bool intl = _Intl; 
# 1421
explicit moneypunct_byname(const char *__s, ::std::size_t __refs = 0) : ::std::__cxx11::moneypunct< _CharT, _Intl> (__refs) 
# 1423
{ 
# 1424
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 1426
{ 
# 1427
::std::__c_locale __tmp; 
# 1428
(this->_S_create_c_locale(__tmp, __s)); 
# 1429
(this->_M_initialize_moneypunct(__tmp)); 
# 1430
(this->_S_destroy_c_locale(__tmp)); 
# 1431
}  
# 1432
} 
# 1436
explicit moneypunct_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs = 0) : moneypunct_byname(__s.c_str(), __refs) 
# 1437
{ } 
# 1442
protected: virtual ~moneypunct_byname() { } 
# 1443
}; 
# 1445
template< class _CharT, bool _Intl> const bool 
# 1446
moneypunct_byname< _CharT, _Intl> ::intl; 
# 1448
}
# 1450
inline namespace __cxx11 { 
# 1465 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
template< class _CharT, class _InIter> 
# 1466
class money_get : public locale::facet { 
# 1472
public: typedef _CharT char_type; 
# 1473
typedef _InIter iter_type; 
# 1474
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 1478
static locale::id id; 
# 1488 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
explicit money_get(size_t __refs = 0) : locale::facet(__refs) { } 
# 1518 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type get(iter_type __s, iter_type __end, bool __intl, ios_base &__io, ios_base::iostate &
# 1519
__err, long double &__units) const 
# 1520
{ return (this->do_get(__s, __end, __intl, __io, __err, __units)); } 
# 1549 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type get(iter_type __s, iter_type __end, bool __intl, ios_base &__io, ios_base::iostate &
# 1550
__err, string_type &__digits) const 
# 1551
{ return (this->do_get(__s, __end, __intl, __io, __err, __digits)); } 
# 1556
protected: virtual ~money_get() { } 
# 1573 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual iter_type do_get(iter_type __s, iter_type __end, bool __intl, ios_base & __io, ios_base::iostate & __err, long double & __units) const; 
# 1585 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual iter_type do_get(iter_type __s, iter_type __end, bool __intl, ios_base & __io, ios_base::iostate & __err, string_type & __digits) const; 
# 1596 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
template< bool _Intl> iter_type _M_extract(iter_type __s, iter_type __end, ios_base & __io, ios_base::iostate & __err, string & __digits) const; 
# 1600
}; 
# 1602
template< class _CharT, class _InIter> locale::id 
# 1603
money_get< _CharT, _InIter> ::id; 
# 1618 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
template< class _CharT, class _OutIter> 
# 1619
class money_put : public locale::facet { 
# 1624
public: typedef _CharT char_type; 
# 1625
typedef _OutIter iter_type; 
# 1626
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 1630
static locale::id id; 
# 1640 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
explicit money_put(size_t __refs = 0) : locale::facet(__refs) { } 
# 1660 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type put(iter_type __s, bool __intl, ios_base &__io, char_type 
# 1661
__fill, long double __units) const 
# 1662
{ return (this->do_put(__s, __intl, __io, __fill, __units)); } 
# 1683 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
iter_type put(iter_type __s, bool __intl, ios_base &__io, char_type 
# 1684
__fill, const string_type &__digits) const 
# 1685
{ return (this->do_put(__s, __intl, __io, __fill, __digits)); } 
# 1690
protected: virtual ~money_put() { } 
# 1718 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual iter_type do_put(iter_type __s, bool __intl, ios_base & __io, char_type __fill, long double __units) const; 
# 1742 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual iter_type do_put(iter_type __s, bool __intl, ios_base & __io, char_type __fill, const string_type & __digits) const; 
# 1753 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
template< bool _Intl> iter_type _M_insert(iter_type __s, ios_base & __io, char_type __fill, const string_type & __digits) const; 
# 1757
}; 
# 1759
template< class _CharT, class _OutIter> locale::id 
# 1760
money_put< _CharT, _OutIter> ::id; 
# 1762
}
# 1768
struct messages_base { 
# 1770
typedef int catalog; 
# 1771
}; 
# 1773
inline namespace __cxx11 { 
# 1796 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
template< class _CharT> 
# 1797
class messages : public locale::facet, public messages_base { 
# 1803
public: typedef _CharT char_type; 
# 1804
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 1810
protected: __c_locale _M_c_locale_messages; 
# 1811
const char *_M_name_messages; 
# 1815
public: static locale::id id; 
# 1825 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
explicit messages(size_t __refs = 0); 
# 1839 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
explicit messages(__c_locale __cloc, const char * __s, size_t __refs = 0); 
# 1852 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
catalog open(const basic_string< char, char_traits< char> , allocator< char> >  &__s, const locale &__loc) const 
# 1853
{ return this->do_open(__s, __loc); } 
# 1870 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
catalog open(const basic_string< char, char_traits< char> , allocator< char> >  &, const locale &, const char *) const; 
# 1888 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
string_type get(catalog __c, int __set, int __msgid, const string_type &__s) const 
# 1889
{ return this->do_get(__c, __set, __msgid, __s); } 
# 1899 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
void close(catalog __c) const 
# 1900
{ return this->do_close(__c); } 
# 1905
protected: virtual ~messages(); 
# 1919 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual catalog do_open(const basic_string< char, char_traits< char> , allocator< char> >  &, const locale &) const; 
# 1938 "/usr/include/c++/5/bits/locale_facets_nonio.h" 3
virtual string_type do_get(catalog, int, int, const string_type & __dfault) const; 
# 1946
virtual void do_close(catalog) const; 
# 1950
char *_M_convert_to_char(const string_type &__msg) const 
# 1951
{ 
# 1953
return reinterpret_cast< char *>(const_cast< _CharT *>((__msg.c_str()))); 
# 1954
} 
# 1958
string_type _M_convert_from_char(char *) const 
# 1959
{ 
# 1961
return string_type(); 
# 1962
} 
# 1963
}; 
# 1965
template< class _CharT> locale::id 
# 1966
messages< _CharT> ::id; 
# 1971
template<> string messages< char> ::do_get(catalog, int, int, const string &) const; 
# 1976
template<> wstring messages< wchar_t> ::do_get(catalog, int, int, const wstring &) const; 
# 1980
template< class _CharT> 
# 1981
class messages_byname : public messages< _CharT>  { 
# 1984
public: typedef _CharT char_type; 
# 1985
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 1988
explicit messages_byname(const char * __s, ::std::size_t __refs = 0); 
# 1992
explicit messages_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs = 0) : messages_byname(__s.c_str(), __refs) 
# 1993
{ } 
# 1998
protected: virtual ~messages_byname() 
# 1999
{ } 
# 2000
}; 
# 2002
}
# 2005
}
# 34 "/usr/include/libintl.h" 3
extern "C" {
# 39
extern char *gettext(const char * __msgid) throw()
# 40
 __attribute((__format_arg__(1))); 
# 44
extern char *dgettext(const char * __domainname, const char * __msgid) throw()
# 45
 __attribute((__format_arg__(2))); 
# 46
extern char *__dgettext(const char * __domainname, const char * __msgid) throw()
# 47
 __attribute((__format_arg__(2))); 
# 51
extern char *dcgettext(const char * __domainname, const char * __msgid, int __category) throw()
# 53
 __attribute((__format_arg__(2))); 
# 54
extern char *__dcgettext(const char * __domainname, const char * __msgid, int __category) throw()
# 56
 __attribute((__format_arg__(2))); 
# 61
extern char *ngettext(const char * __msgid1, const char * __msgid2, unsigned long __n) throw()
# 63
 __attribute((__format_arg__(1))) __attribute((__format_arg__(2))); 
# 67
extern char *dngettext(const char * __domainname, const char * __msgid1, const char * __msgid2, unsigned long __n) throw()
# 69
 __attribute((__format_arg__(2))) __attribute((__format_arg__(3))); 
# 73
extern char *dcngettext(const char * __domainname, const char * __msgid1, const char * __msgid2, unsigned long __n, int __category) throw()
# 76
 __attribute((__format_arg__(2))) __attribute((__format_arg__(3))); 
# 82
extern char *textdomain(const char * __domainname) throw(); 
# 86
extern char *bindtextdomain(const char * __domainname, const char * __dirname) throw(); 
# 91
extern char *bind_textdomain_codeset(const char * __domainname, const char * __codeset) throw(); 
# 121 "/usr/include/libintl.h" 3
}
# 38 "/usr/include/aarch64-linux-gnu/c++/5/bits/messages_members.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _CharT> 
# 44
__cxx11::messages< _CharT> ::messages(size_t __refs) : locale::facet(__refs), _M_c_locale_messages(_S_get_c_locale()), _M_name_messages(_S_get_c_name()) 
# 47
{ } 
# 49
template< class _CharT> 
# 50
__cxx11::messages< _CharT> ::messages(__c_locale __cloc, const char *__s, size_t 
# 51
__refs) : locale::facet(__refs), _M_c_locale_messages((0)), _M_name_messages((0)) 
# 53
{ 
# 54
if (__builtin_strcmp(__s, _S_get_c_name()) != 0) 
# 55
{ 
# 56
const size_t __len = __builtin_strlen(__s) + (1); 
# 57
char *__tmp = new char [__len]; 
# 58
__builtin_memcpy(__tmp, __s, __len); 
# 59
(_M_name_messages) = __tmp; 
# 60
} else { 
# 62
(_M_name_messages) = _S_get_c_name(); }  
# 65
(_M_c_locale_messages) = _S_clone_c_locale(__cloc); 
# 66
} 
# 68
template< class _CharT> messages_base::catalog 
# 70
__cxx11::messages< _CharT> ::open(const basic_string< char, char_traits< char> , allocator< char> >  &__s, const locale &__loc, const char *
# 71
__dir) const 
# 72
{ 
# 73
bindtextdomain(__s.c_str(), __dir); 
# 74
return this->do_open(__s, __loc); 
# 75
} 
# 78
template< class _CharT> 
# 79
__cxx11::messages< _CharT> ::~messages() 
# 80
{ 
# 81
if ((_M_name_messages) != _S_get_c_name()) { 
# 82
delete [] (_M_name_messages); }  
# 83
_S_destroy_c_locale(_M_c_locale_messages); 
# 84
} 
# 86
template< class _CharT> messages_base::catalog 
# 88
__cxx11::messages< _CharT> ::do_open(const basic_string< char, char_traits< char> , allocator< char> >  &__s, const locale &) const 
# 90
{ 
# 93
textdomain(__s.c_str()); 
# 94
return 0; 
# 95
} 
# 97
template< class _CharT> void 
# 99
__cxx11::messages< _CharT> ::do_close(catalog) const 
# 100
{ } 
# 103
template< class _CharT> 
# 104
__cxx11::messages_byname< _CharT> ::messages_byname(const char *__s, ::std::size_t __refs) : ::std::__cxx11::messages< _CharT> (__refs) 
# 106
{ 
# 107
if ((this->_M_name_messages) != locale::facet::_S_get_c_name()) 
# 108
{ 
# 109
delete [] (this->_M_name_messages); 
# 110
if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0) 
# 111
{ 
# 112
const ::std::size_t __len = __builtin_strlen(__s) + (1); 
# 113
char *__tmp = new char [__len]; 
# 114
__builtin_memcpy(__tmp, __s, __len); 
# 115
(this->_M_name_messages) = __tmp; 
# 116
} else { 
# 118
(this->_M_name_messages) = locale::facet::_S_get_c_name(); }  
# 119
}  
# 121
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 123
{ 
# 124
(this->_S_destroy_c_locale((this->_M_c_locale_messages))); 
# 125
(this->_S_create_c_locale((this->_M_c_locale_messages), __s)); 
# 126
}  
# 127
} 
# 132
template<> messages_base::catalog messages< char> ::do_open(const basic_string< char, char_traits< char> , allocator< char> >  &, const locale &) const; 
# 137
template<> void messages< char> ::do_close(catalog) const; 
# 142
template<> messages_base::catalog messages< wchar_t> ::do_open(const basic_string< char, char_traits< char> , allocator< char> >  &, const locale &) const; 
# 147
template<> void messages< wchar_t> ::do_close(catalog) const; 
# 151
}
# 41 "/usr/include/c++/5/bits/codecvt.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 46
class codecvt_base { 
# 49
public: enum result { 
# 51
ok, 
# 52
partial, 
# 53
error, 
# 54
noconv
# 55
}; 
# 56
}; 
# 67 "/usr/include/c++/5/bits/codecvt.h" 3
template< class _InternT, class _ExternT, class _StateT> 
# 68
class __codecvt_abstract_base : public locale::facet, public codecvt_base { 
# 73
public: typedef codecvt_base::result result; 
# 74
typedef _InternT intern_type; 
# 75
typedef _ExternT extern_type; 
# 76
typedef _StateT state_type; 
# 116 "/usr/include/c++/5/bits/codecvt.h" 3
result out(state_type &__state, const intern_type *__from, const intern_type *
# 117
__from_end, const intern_type *&__from_next, extern_type *
# 118
__to, extern_type *__to_end, extern_type *&
# 119
__to_next) const 
# 120
{ 
# 121
return this->do_out(__state, __from, __from_end, __from_next, __to, __to_end, __to_next); 
# 123
} 
# 155 "/usr/include/c++/5/bits/codecvt.h" 3
result unshift(state_type &__state, extern_type *__to, extern_type *__to_end, extern_type *&
# 156
__to_next) const 
# 157
{ return this->do_unshift(__state, __to, __to_end, __to_next); } 
# 196 "/usr/include/c++/5/bits/codecvt.h" 3
result in(state_type &__state, const extern_type *__from, const extern_type *
# 197
__from_end, const extern_type *&__from_next, intern_type *
# 198
__to, intern_type *__to_end, intern_type *&
# 199
__to_next) const 
# 200
{ 
# 201
return this->do_in(__state, __from, __from_end, __from_next, __to, __to_end, __to_next); 
# 203
} 
# 206
int encoding() const throw() 
# 207
{ return this->do_encoding(); } 
# 210
bool always_noconv() const throw() 
# 211
{ return this->do_always_noconv(); } 
# 214
int length(state_type &__state, const extern_type *__from, const extern_type *
# 215
__end, size_t __max) const 
# 216
{ return this->do_length(__state, __from, __end, __max); } 
# 219
int max_length() const throw() 
# 220
{ return this->do_max_length(); } 
# 224
protected: explicit __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { } 
# 227
virtual ~__codecvt_abstract_base() { } 
# 237 "/usr/include/c++/5/bits/codecvt.h" 3
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const = 0; 
# 243
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const = 0; 
# 247
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const = 0; 
# 253
virtual int do_encoding() const throw() = 0; 
# 256
virtual bool do_always_noconv() const throw() = 0; 
# 259
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const = 0; 
# 263
virtual int do_max_length() const throw() = 0; 
# 264
}; 
# 273 "/usr/include/c++/5/bits/codecvt.h" 3
template< class _InternT, class _ExternT, class _StateT> 
# 274
class codecvt : public __codecvt_abstract_base< _InternT, _ExternT, _StateT>  { 
# 279
public: typedef ::std::codecvt_base::result result; 
# 280
typedef _InternT intern_type; 
# 281
typedef _ExternT extern_type; 
# 282
typedef _StateT state_type; 
# 285
protected: ::std::__c_locale _M_c_locale_codecvt; 
# 288
public: static ::std::locale::id id; 
# 291
explicit codecvt(::std::size_t __refs = 0) : ::std::__codecvt_abstract_base< _InternT, _ExternT, _StateT> (__refs), _M_c_locale_codecvt((0)) 
# 294
{ } 
# 297
explicit codecvt(::std::__c_locale __cloc, ::std::size_t __refs = 0); 
# 301
protected: virtual ~codecvt() { } 
# 304
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 310
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 314
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 320
virtual int do_encoding() const throw(); 
# 323
virtual bool do_always_noconv() const throw(); 
# 326
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, ::std::size_t __max) const; 
# 330
virtual int do_max_length() const throw(); 
# 331
}; 
# 333
template< class _InternT, class _ExternT, class _StateT> locale::id 
# 334
codecvt< _InternT, _ExternT, _StateT> ::id; 
# 338
template<> class codecvt< char, char, __mbstate_t>  : public __codecvt_abstract_base< char, char, __mbstate_t>  { 
# 341
friend class __cxx11::messages< char> ; 
# 345
public: typedef char intern_type; 
# 346
typedef char extern_type; 
# 347
typedef mbstate_t state_type; 
# 350
protected: __c_locale _M_c_locale_codecvt; 
# 353
public: static locale::id id; 
# 356
explicit codecvt(size_t __refs = 0); 
# 359
explicit codecvt(__c_locale __cloc, size_t __refs = 0); 
# 363
protected: virtual ~codecvt(); 
# 366
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 372
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 376
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 382
virtual int do_encoding() const throw(); 
# 385
virtual bool do_always_noconv() const throw(); 
# 388
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 
# 392
virtual int do_max_length() const throw(); 
# 393
}; 
# 401
template<> class codecvt< wchar_t, char, __mbstate_t>  : public __codecvt_abstract_base< wchar_t, char, __mbstate_t>  { 
# 404
friend class __cxx11::messages< wchar_t> ; 
# 408
public: typedef wchar_t intern_type; 
# 409
typedef char extern_type; 
# 410
typedef mbstate_t state_type; 
# 413
protected: __c_locale _M_c_locale_codecvt; 
# 416
public: static locale::id id; 
# 419
explicit codecvt(size_t __refs = 0); 
# 422
explicit codecvt(__c_locale __cloc, size_t __refs = 0); 
# 426
protected: virtual ~codecvt(); 
# 429
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 435
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 440
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 447
virtual int do_encoding() const throw(); 
# 450
virtual bool do_always_noconv() const throw(); 
# 453
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 
# 457
virtual int do_max_length() const throw(); 
# 458
}; 
# 468 "/usr/include/c++/5/bits/codecvt.h" 3
template<> class codecvt< char16_t, char, __mbstate_t>  : public __codecvt_abstract_base< char16_t, char, __mbstate_t>  { 
# 473
public: typedef char16_t intern_type; 
# 474
typedef char extern_type; 
# 475
typedef mbstate_t state_type; 
# 478
static locale::id id; 
# 481
explicit codecvt(size_t __refs = 0) : std::__codecvt_abstract_base< char16_t, char, __mbstate_t> (__refs) 
# 482
{ } 
# 486
protected: virtual ~codecvt(); 
# 489
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 495
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 500
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 507
virtual int do_encoding() const throw(); 
# 510
virtual bool do_always_noconv() const throw(); 
# 513
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 
# 517
virtual int do_max_length() const throw(); 
# 518
}; 
# 525
template<> class codecvt< char32_t, char, __mbstate_t>  : public __codecvt_abstract_base< char32_t, char, __mbstate_t>  { 
# 530
public: typedef char32_t intern_type; 
# 531
typedef char extern_type; 
# 532
typedef mbstate_t state_type; 
# 535
static locale::id id; 
# 538
explicit codecvt(size_t __refs = 0) : std::__codecvt_abstract_base< char32_t, char, __mbstate_t> (__refs) 
# 539
{ } 
# 543
protected: virtual ~codecvt(); 
# 546
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 552
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 557
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 564
virtual int do_encoding() const throw(); 
# 567
virtual bool do_always_noconv() const throw(); 
# 570
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 
# 574
virtual int do_max_length() const throw(); 
# 575
}; 
# 581
template< class _InternT, class _ExternT, class _StateT> 
# 582
class codecvt_byname : public codecvt< _InternT, _ExternT, _StateT>  { 
# 586
public: explicit codecvt_byname(const char *__s, ::std::size_t __refs = 0) : ::std::codecvt< _InternT, _ExternT, _StateT> (__refs) 
# 588
{ 
# 589
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 591
{ 
# 592
(this->_S_destroy_c_locale((this->_M_c_locale_codecvt))); 
# 593
(this->_S_create_c_locale((this->_M_c_locale_codecvt), __s)); 
# 594
}  
# 595
} 
# 599
explicit codecvt_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs = 0) : codecvt_byname(__s.c_str(), __refs) 
# 600
{ } 
# 605
protected: virtual ~codecvt_byname() { } 
# 606
}; 
# 610
template<> class codecvt_byname< char16_t, char, __mbstate_t>  : public codecvt< char16_t, char, __mbstate_t>  { 
# 615
public: explicit codecvt_byname(const char *__s, size_t __refs = 0) : std::codecvt< char16_t, char, __mbstate_t> (__refs) 
# 616
{ } 
# 619
explicit codecvt_byname(const __cxx11::string &__s, size_t __refs = 0) : codecvt_byname(__s.c_str(), __refs) 
# 620
{ } 
# 624
protected: virtual ~codecvt_byname() { } 
# 625
}; 
# 628
template<> class codecvt_byname< char32_t, char, __mbstate_t>  : public codecvt< char32_t, char, __mbstate_t>  { 
# 633
public: explicit codecvt_byname(const char *__s, size_t __refs = 0) : std::codecvt< char32_t, char, __mbstate_t> (__refs) 
# 634
{ } 
# 637
explicit codecvt_byname(const __cxx11::string &__s, size_t __refs = 0) : codecvt_byname(__s.c_str(), __refs) 
# 638
{ } 
# 642
protected: virtual ~codecvt_byname() { } 
# 643
}; 
# 649
extern template class codecvt_byname< char, char, __mbstate_t> ;
# 651
extern template const codecvt< char, char, __mbstate_t>  &use_facet< codecvt< char, char, __mbstate_t> > (const locale &);
# 655
extern template bool has_facet< codecvt< char, char, __mbstate_t> > (const locale &) throw();
# 660
extern template class codecvt_byname< wchar_t, char, __mbstate_t> ;
# 662
extern template const codecvt< wchar_t, char, __mbstate_t>  &use_facet< codecvt< wchar_t, char, __mbstate_t> > (const locale &);
# 666
extern template bool has_facet< codecvt< wchar_t, char, __mbstate_t> > (const locale &) throw();
# 679
}
# 35 "/usr/include/c++/5/bits/locale_facets_nonio.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 39
template< class _CharT, bool _Intl> 
# 40
struct __use_cache< __moneypunct_cache< _CharT, _Intl> >  { 
# 43
const __moneypunct_cache< _CharT, _Intl>  *operator()(const locale &__loc) const 
# 44
{ 
# 45
const size_t __i = (moneypunct< _CharT, _Intl> ::id._M_id)(); 
# 46
const locale::facet **__caches = (__loc._M_impl)->_M_caches; 
# 47
if (!(__caches[__i])) 
# 48
{ 
# 49
__moneypunct_cache< _CharT, _Intl>  *__tmp = (0); 
# 50
try 
# 51
{ 
# 52
__tmp = (new __moneypunct_cache< _CharT, _Intl> ); 
# 53
(__tmp->_M_cache(__loc)); 
# 54
} 
# 55
catch (...) 
# 56
{ 
# 57
delete __tmp; 
# 58
throw; 
# 59
}  
# 60
(__loc._M_impl)->_M_install_cache(__tmp, __i); 
# 61
}  
# 62
return static_cast< const __moneypunct_cache< _CharT, _Intl>  *>(__caches[__i]); 
# 64
} 
# 65
}; 
# 67
template< class _CharT, bool _Intl> void 
# 69
__moneypunct_cache< _CharT, _Intl> ::_M_cache(const locale &__loc) 
# 70
{ 
# 71
const __cxx11::moneypunct< _CharT, _Intl>  &__mp = use_facet< __cxx11::moneypunct< _CharT, _Intl> > (__loc); 
# 74
(_M_decimal_point) = (__mp.decimal_point()); 
# 75
(_M_thousands_sep) = (__mp.thousands_sep()); 
# 76
(_M_frac_digits) = (__mp.frac_digits()); 
# 78
char *__grouping = (0); 
# 79
_CharT *__curr_symbol = (0); 
# 80
_CharT *__positive_sign = (0); 
# 81
_CharT *__negative_sign = (0); 
# 82
try 
# 83
{ 
# 84
const __cxx11::string &__g = (__mp.grouping()); 
# 85
(_M_grouping_size) = __g.size(); 
# 86
__grouping = (new char [_M_grouping_size]); 
# 87
__g.copy(__grouping, _M_grouping_size); 
# 88
(_M_use_grouping) = ((_M_grouping_size) && ((static_cast< signed char>(__grouping[0])) > 0) && ((__grouping[0]) != __gnu_cxx::__numeric_traits_integer< char> ::__max)); 
# 93
const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &__cs = (__mp.curr_symbol()); 
# 94
(_M_curr_symbol_size) = (__cs.size()); 
# 95
__curr_symbol = (new _CharT [_M_curr_symbol_size]); 
# 96
(__cs.copy(__curr_symbol, _M_curr_symbol_size)); 
# 98
const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &__ps = (__mp.positive_sign()); 
# 99
(_M_positive_sign_size) = (__ps.size()); 
# 100
__positive_sign = (new _CharT [_M_positive_sign_size]); 
# 101
(__ps.copy(__positive_sign, _M_positive_sign_size)); 
# 103
const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &__ns = (__mp.negative_sign()); 
# 104
(_M_negative_sign_size) = (__ns.size()); 
# 105
__negative_sign = (new _CharT [_M_negative_sign_size]); 
# 106
(__ns.copy(__negative_sign, _M_negative_sign_size)); 
# 108
(_M_pos_format) = (__mp.pos_format()); 
# 109
(_M_neg_format) = (__mp.neg_format()); 
# 111
const ctype< _CharT>  &__ct = use_facet< ctype< _CharT> > (__loc); 
# 112
(__ct.widen(money_base::_S_atoms, money_base::_S_atoms + money_base::_S_end, _M_atoms)); 
# 115
(_M_grouping) = __grouping; 
# 116
(_M_curr_symbol) = __curr_symbol; 
# 117
(_M_positive_sign) = __positive_sign; 
# 118
(_M_negative_sign) = __negative_sign; 
# 119
(_M_allocated) = true; 
# 120
} 
# 121
catch (...) 
# 122
{ 
# 123
delete [] __grouping; 
# 124
delete [] __curr_symbol; 
# 125
delete [] __positive_sign; 
# 126
delete [] __negative_sign; 
# 127
throw; 
# 128
}  
# 129
} 
# 131
inline namespace __cxx11 { 
# 133
template< class _CharT, class _InIter> 
# 134
template< bool _Intl> _InIter 
# 137
money_get< _CharT, _InIter> ::_M_extract(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 138
__err, string &__units) const 
# 139
{ 
# 140
typedef char_traits< _CharT>  __traits_type; 
# 141
typedef typename basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> > ::size_type size_type; 
# 142
typedef money_base::part part; 
# 143
typedef __moneypunct_cache< _CharT, _Intl>  __cache_type; 
# 145
const locale &__loc = __io._M_getloc(); 
# 146
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 148
__use_cache< __moneypunct_cache< _CharT, _Intl> >  __uc; 
# 149
const __cache_type *__lc = __uc(__loc); 
# 150
const char_type *__lit = ((__lc->_M_atoms)); 
# 153
bool __negative = false; 
# 155
size_type __sign_size = (0); 
# 157
const bool __mandatory_sign = (__lc->_M_positive_sign_size) && (__lc->_M_negative_sign_size); 
# 160
string __grouping_tmp; 
# 161
if (__lc->_M_use_grouping) { 
# 162
__grouping_tmp.reserve(32); }  
# 164
int __last_pos = 0; 
# 166
int __n = 0; 
# 168
bool __testvalid = true; 
# 170
bool __testdecfound = false; 
# 173
string __res; 
# 174
__res.reserve(32); 
# 176
const char_type *__lit_zero = __lit + money_base::_S_zero; 
# 177
const money_base::pattern __p = ((__lc->_M_neg_format)); 
# 178
for (int __i = 0; (__i < 4) && __testvalid; ++__i) 
# 179
{ 
# 180
const part __which = static_cast< part>((__p.field)[__i]); 
# 181
switch (__which) 
# 182
{ 
# 183
case money_base::symbol:  
# 188
if (((((((__io.flags()) & ios_base::showbase)) || (__sign_size > 1)) || (__i == 0)) || ((__i == 1) && ((__mandatory_sign || ((static_cast< part>((__p.field)[0])) == (money_base::sign))) || ((static_cast< part>((__p.field)[2])) == (money_base::space))))) || ((__i == 2) && (((static_cast< part>((__p.field)[3])) == (money_base::value)) || (__mandatory_sign && ((static_cast< part>((__p.field)[3])) == (money_base::sign)))))) 
# 200
{ 
# 201
const size_type __len = ((__lc->_M_curr_symbol_size)); 
# 202
size_type __j = (0); 
# 203
for (; (__beg != __end) && (__j < __len) && ((*__beg) == ((__lc->_M_curr_symbol)[__j])); (++__beg), (++__j)) { 
# 205
; }  
# 206
if ((__j != __len) && (__j || (((__io.flags()) & ios_base::showbase)))) { 
# 208
__testvalid = false; }  
# 209
}  
# 210
break; 
# 211
case money_base::sign:  
# 213
if ((__lc->_M_positive_sign_size) && (__beg != __end) && ((*__beg) == ((__lc->_M_positive_sign)[0]))) 
# 215
{ 
# 216
__sign_size = (__lc->_M_positive_sign_size); 
# 217
++__beg; 
# 218
} else { 
# 219
if ((__lc->_M_negative_sign_size) && (__beg != __end) && ((*__beg) == ((__lc->_M_negative_sign)[0]))) 
# 221
{ 
# 222
__negative = true; 
# 223
__sign_size = (__lc->_M_negative_sign_size); 
# 224
++__beg; 
# 225
} else { 
# 226
if ((__lc->_M_positive_sign_size) && (!(__lc->_M_negative_sign_size))) { 
# 230
__negative = true; } else { 
# 231
if (__mandatory_sign) { 
# 232
__testvalid = false; }  }  }  }  
# 233
break; 
# 234
case money_base::value:  
# 237
for (; __beg != __end; ++__beg) 
# 238
{ 
# 239
const char_type __c = *__beg; 
# 240
const char_type *__q = __traits_type::find(__lit_zero, 10, __c); 
# 242
if (__q != 0) 
# 243
{ 
# 244
__res += (money_base::_S_atoms[__q - __lit]); 
# 245
++__n; 
# 246
} else { 
# 247
if ((__c == (__lc->_M_decimal_point)) && (!__testdecfound)) 
# 249
{ 
# 250
if ((__lc->_M_frac_digits) <= 0) { 
# 251
break; }  
# 253
__last_pos = __n; 
# 254
__n = 0; 
# 255
__testdecfound = true; 
# 256
} else { 
# 257
if ((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)) && (!__testdecfound)) 
# 260
{ 
# 261
if (__n) 
# 262
{ 
# 264
(__grouping_tmp += (static_cast< char>(__n))); 
# 265
__n = 0; 
# 266
} else 
# 268
{ 
# 269
__testvalid = false; 
# 270
break; 
# 271
}  
# 272
} else { 
# 274
break; }  }  }  
# 275
}  
# 276
if (__res.empty()) { 
# 277
__testvalid = false; }  
# 278
break; 
# 279
case money_base::space:  
# 281
if ((__beg != __end) && (__ctype.is(ctype_base::space, *__beg))) { 
# 282
++__beg; } else { 
# 284
__testvalid = false; }  
# 285
case money_base::none:  
# 287
if (__i != 3) { 
# 288
for (; (__beg != __end) && (__ctype.is(ctype_base::space, *__beg)); ++__beg) { 
# 289
; }  }  
# 290
break; 
# 291
}  
# 292
}  
# 295
if ((__sign_size > 1) && __testvalid) 
# 296
{ 
# 297
const char_type *__sign = __negative ? __lc->_M_negative_sign : (__lc->_M_positive_sign); 
# 299
size_type __i = (1); 
# 300
for (; (__beg != __end) && (__i < __sign_size) && ((*__beg) == (__sign[__i])); (++__beg), (++__i)) { 
# 301
; }  
# 303
if (__i != __sign_size) { 
# 304
__testvalid = false; }  
# 305
}  
# 307
if (__testvalid) 
# 308
{ 
# 310
if (__res.size() > (1)) 
# 311
{ 
# 312
const size_type __first = __res.find_first_not_of('0'); 
# 313
const bool __only_zeros = __first == string::npos; 
# 314
if (__first) { 
# 315
(__res.erase(0, __only_zeros ? __res.size() - (1) : __first)); }  
# 316
}  
# 319
if (__negative && ((__res[0]) != ('0'))) { 
# 320
__res.insert(__res.begin(), '-'); }  
# 323
if (__grouping_tmp.size()) 
# 324
{ 
# 326
(__grouping_tmp += (static_cast< char>(__testdecfound ? __last_pos : __n))); 
# 328
if (!std::__verify_grouping((__lc->_M_grouping), (__lc->_M_grouping_size), __grouping_tmp)) { 
# 331
(__err |= ios_base::failbit); }  
# 332
}  
# 335
if (__testdecfound && (__n != (__lc->_M_frac_digits))) { 
# 336
__testvalid = false; }  
# 337
}  
# 340
if (!__testvalid) { 
# 341
(__err |= ios_base::failbit); } else { 
# 343
__units.swap(__res); }  
# 346
if (__beg == __end) { 
# 347
(__err |= ios_base::eofbit); }  
# 348
return __beg; 
# 349
} 
# 367 "/usr/include/c++/5/bits/locale_facets_nonio.tcc" 3
template< class _CharT, class _InIter> _InIter 
# 370
money_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, bool __intl, ios_base &__io, ios_base::iostate &
# 371
__err, long double &__units) const 
# 372
{ 
# 373
string __str; 
# 374
__beg = (__intl ? _M_extract< true> (__beg, __end, __io, __err, __str) : _M_extract< false> (__beg, __end, __io, __err, __str)); 
# 376
std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale()); 
# 377
return __beg; 
# 378
} 
# 380
template< class _CharT, class _InIter> _InIter 
# 383
money_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, bool __intl, ios_base &__io, ios_base::iostate &
# 384
__err, string_type &__digits) const 
# 385
{ 
# 386
typedef basic_string< char, char_traits< char> , allocator< char> > ::size_type size_type; 
# 388
const locale &__loc = __io._M_getloc(); 
# 389
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 391
string __str; 
# 392
__beg = (__intl ? _M_extract< true> (__beg, __end, __io, __err, __str) : _M_extract< false> (__beg, __end, __io, __err, __str)); 
# 394
const size_type __len = __str.size(); 
# 395
if (__len) 
# 396
{ 
# 397
(__digits.resize(__len)); 
# 398
(__ctype.widen(__str.data(), __str.data() + __len, &(__digits[0]))); 
# 399
}  
# 400
return __beg; 
# 401
} 
# 403
template< class _CharT, class _OutIter> 
# 404
template< bool _Intl> _OutIter 
# 407
money_put< _CharT, _OutIter> ::_M_insert(iter_type __s, ios_base &__io, char_type __fill, const string_type &
# 408
__digits) const 
# 409
{ 
# 410
typedef typename basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> > ::size_type size_type; 
# 411
typedef money_base::part part; 
# 412
typedef __moneypunct_cache< _CharT, _Intl>  __cache_type; 
# 414
const locale &__loc = __io._M_getloc(); 
# 415
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 417
__use_cache< __moneypunct_cache< _CharT, _Intl> >  __uc; 
# 418
const __cache_type *__lc = __uc(__loc); 
# 419
const char_type *__lit = ((__lc->_M_atoms)); 
# 423
const char_type *__beg = (__digits.data()); 
# 425
money_base::pattern __p; 
# 426
const char_type *__sign; 
# 427
size_type __sign_size; 
# 428
if (!((*__beg) == (__lit[money_base::_S_minus]))) 
# 429
{ 
# 430
__p = (__lc->_M_pos_format); 
# 431
__sign = (__lc->_M_positive_sign); 
# 432
__sign_size = (__lc->_M_positive_sign_size); 
# 433
} else 
# 435
{ 
# 436
__p = (__lc->_M_neg_format); 
# 437
__sign = (__lc->_M_negative_sign); 
# 438
__sign_size = (__lc->_M_negative_sign_size); 
# 439
if ((__digits.size())) { 
# 440
++__beg; }  
# 441
}  
# 444
size_type __len = (__ctype.scan_not(ctype_base::digit, __beg, __beg + (__digits.size()))) - __beg; 
# 446
if (__len) 
# 447
{ 
# 451
string_type __value; 
# 452
(__value.reserve(2 * __len)); 
# 456
long __paddec = __len - (__lc->_M_frac_digits); 
# 457
if (__paddec > (0)) 
# 458
{ 
# 459
if ((__lc->_M_frac_digits) < 0) { 
# 460
__paddec = __len; }  
# 461
if (__lc->_M_grouping_size) 
# 462
{ 
# 463
(__value.assign((2) * __paddec, char_type())); 
# 464
_CharT *__vend = std::__add_grouping(&(__value[0]), (__lc->_M_thousands_sep), (__lc->_M_grouping), (__lc->_M_grouping_size), __beg, __beg + __paddec); 
# 469
(__value.erase(__vend - (&(__value[0])))); 
# 470
} else { 
# 472
(__value.assign(__beg, __paddec)); }  
# 473
}  
# 476
if ((__lc->_M_frac_digits) > 0) 
# 477
{ 
# 478
__value += (__lc->_M_decimal_point); 
# 479
if (__paddec >= (0)) { 
# 480
(__value.append(__beg + __paddec, (__lc->_M_frac_digits))); } else 
# 482
{ 
# 484
(__value.append(-__paddec, __lit[money_base::_S_zero])); 
# 485
(__value.append(__beg, __len)); 
# 486
}  
# 487
}  
# 490
const ios_base::fmtflags __f = ((__io.flags()) & ios_base::adjustfield); 
# 492
__len = ((__value.size()) + __sign_size); 
# 493
__len += ((((__io.flags()) & ios_base::showbase)) ? __lc->_M_curr_symbol_size : 0); 
# 496
string_type __res; 
# 497
(__res.reserve(2 * __len)); 
# 499
const size_type __width = static_cast< size_type>(__io.width()); 
# 500
const bool __testipad = (__f == ios_base::internal) && (__len < __width); 
# 503
for (int __i = 0; __i < 4; ++__i) 
# 504
{ 
# 505
const part __which = static_cast< part>((__p.field)[__i]); 
# 506
switch (__which) 
# 507
{ 
# 508
case money_base::symbol:  
# 509
if (((__io.flags()) & ios_base::showbase)) { 
# 510
(__res.append((__lc->_M_curr_symbol), (__lc->_M_curr_symbol_size))); }  
# 512
break; 
# 513
case money_base::sign:  
# 517
if (__sign_size) { 
# 518
__res += (__sign[0]); }  
# 519
break; 
# 520
case money_base::value:  
# 521
__res += __value; 
# 522
break; 
# 523
case money_base::space:  
# 527
if (__testipad) { 
# 528
(__res.append(__width - __len, __fill)); } else { 
# 530
__res += __fill; }  
# 531
break; 
# 532
case money_base::none:  
# 533
if (__testipad) { 
# 534
(__res.append(__width - __len, __fill)); }  
# 535
break; 
# 536
}  
# 537
}  
# 540
if (__sign_size > 1) { 
# 541
(__res.append(__sign + 1, __sign_size - 1)); }  
# 544
__len = (__res.size()); 
# 545
if (__width > __len) 
# 546
{ 
# 547
if (__f == ios_base::left) { 
# 549
(__res.append(__width - __len, __fill)); } else { 
# 552
(__res.insert(0, __width - __len, __fill)); }  
# 553
__len = __width; 
# 554
}  
# 557
__s = std::__write(__s, (__res.data()), __len); 
# 558
}  
# 559
__io.width(0); 
# 560
return __s; 
# 561
} 
# 573 "/usr/include/c++/5/bits/locale_facets_nonio.tcc" 3
template< class _CharT, class _OutIter> _OutIter 
# 576
money_put< _CharT, _OutIter> ::do_put(iter_type __s, bool __intl, ios_base &__io, char_type __fill, long double 
# 577
__units) const 
# 578
{ 
# 579
const locale __loc = __io.getloc(); 
# 580
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 583
int __cs_size = 64; 
# 584
char *__cs = static_cast< char *>(__builtin_alloca(__cs_size)); 
# 587
int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, "%.*Lf", 0, __units); 
# 590
if (__len >= __cs_size) 
# 591
{ 
# 592
__cs_size = (__len + 1); 
# 593
__cs = (static_cast< char *>(__builtin_alloca(__cs_size))); 
# 594
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, "%.*Lf", 0, __units); 
# 596
}  
# 605 "/usr/include/c++/5/bits/locale_facets_nonio.tcc" 3
string_type __digits(__len, char_type()); 
# 606
(__ctype.widen(__cs, __cs + __len, &(__digits[0]))); 
# 607
return __intl ? _M_insert< true> (__s, __io, __fill, __digits) : _M_insert< false> (__s, __io, __fill, __digits); 
# 609
} 
# 611
template< class _CharT, class _OutIter> _OutIter 
# 614
money_put< _CharT, _OutIter> ::do_put(iter_type __s, bool __intl, ios_base &__io, char_type __fill, const string_type &
# 615
__digits) const 
# 616
{ return __intl ? _M_insert< true> (__s, __io, __fill, __digits) : _M_insert< false> (__s, __io, __fill, __digits); 
# 617
} 
# 619
}
# 624
template< class _CharT, class _InIter> time_base::dateorder 
# 626
__cxx11::time_get< _CharT, _InIter> ::do_date_order() const 
# 627
{ return time_base::no_order; } 
# 631
template< class _CharT, class _InIter> _InIter 
# 634
__cxx11::time_get< _CharT, _InIter> ::_M_extract_via_format(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 635
__err, tm *__tm, const _CharT *
# 636
__format) const 
# 637
{ 
# 638
const locale &__loc = __io._M_getloc(); 
# 639
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 640
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 641
const size_t __len = char_traits< _CharT> ::length(__format); 
# 643
ios_base::iostate __tmperr = ios_base::goodbit; 
# 644
size_t __i = (0); 
# 645
for (; (__beg != __end) && (__i < __len) && (!__tmperr); ++__i) 
# 646
{ 
# 647
if ((__ctype.narrow(__format[__i], 0)) == '%') 
# 648
{ 
# 650
char __c = (__ctype.narrow(__format[++__i], 0)); 
# 651
int __mem = 0; 
# 652
if ((__c == ('E')) || (__c == ('O'))) { 
# 653
__c = (__ctype.narrow(__format[++__i], 0)); }  
# 654
switch (__c) 
# 655
{ 
# 656
const char *__cs; 
# 657
_CharT __wcs[10]; 
# 658
case 'a':  
# 660
const char_type *__days1[7]; 
# 661
(__tp._M_days_abbreviated(__days1)); 
# 662
__beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1, 7, __io, __tmperr); 
# 664
break; 
# 665
case 'A':  
# 667
const char_type *__days2[7]; 
# 668
(__tp._M_days(__days2)); 
# 669
__beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2, 7, __io, __tmperr); 
# 671
break; 
# 672
case 'h':  
# 673
case 'b':  
# 675
const char_type *__months1[12]; 
# 676
(__tp._M_months_abbreviated(__months1)); 
# 677
__beg = _M_extract_name(__beg, __end, __tm->tm_mon, __months1, 12, __io, __tmperr); 
# 679
break; 
# 680
case 'B':  
# 682
const char_type *__months2[12]; 
# 683
(__tp._M_months(__months2)); 
# 684
__beg = _M_extract_name(__beg, __end, __tm->tm_mon, __months2, 12, __io, __tmperr); 
# 686
break; 
# 687
case 'c':  
# 689
const char_type *__dt[2]; 
# 690
(__tp._M_date_time_formats(__dt)); 
# 691
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, (__dt)[0]); 
# 693
break; 
# 694
case 'd':  
# 696
__beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2, __io, __tmperr); 
# 698
break; 
# 699
case 'e':  
# 702
if ((__ctype.is(ctype_base::space, *__beg))) { 
# 703
__beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9, 1, __io, __tmperr); } else { 
# 706
__beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31, 2, __io, __tmperr); }  
# 708
break; 
# 709
case 'D':  
# 711
__cs = ("%m/%d/%y"); 
# 712
(__ctype.widen(__cs, __cs + 9, __wcs)); 
# 713
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __wcs); 
# 715
break; 
# 716
case 'H':  
# 718
__beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2, __io, __tmperr); 
# 720
break; 
# 721
case 'I':  
# 723
__beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2, __io, __tmperr); 
# 725
break; 
# 726
case 'm':  
# 728
__beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2, __io, __tmperr); 
# 730
if (!__tmperr) { 
# 731
(__tm->tm_mon) = (__mem - 1); }  
# 732
break; 
# 733
case 'M':  
# 735
__beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2, __io, __tmperr); 
# 737
break; 
# 738
case 'n':  
# 739
if ((__ctype.narrow(*__beg, 0)) == '\n') { 
# 740
++__beg; } else { 
# 742
(__tmperr |= ios_base::failbit); }  
# 743
break; 
# 744
case 'R':  
# 746
__cs = ("%H:%M"); 
# 747
(__ctype.widen(__cs, __cs + 6, __wcs)); 
# 748
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __wcs); 
# 750
break; 
# 751
case 'S':  
# 755
__beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2, __io, __tmperr); 
# 760
break; 
# 761
case 't':  
# 762
if ((__ctype.narrow(*__beg, 0)) == '\t') { 
# 763
++__beg; } else { 
# 765
(__tmperr |= ios_base::failbit); }  
# 766
break; 
# 767
case 'T':  
# 769
__cs = ("%H:%M:%S"); 
# 770
(__ctype.widen(__cs, __cs + 9, __wcs)); 
# 771
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __wcs); 
# 773
break; 
# 774
case 'x':  
# 776
const char_type *__dates[2]; 
# 777
(__tp._M_date_formats(__dates)); 
# 778
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, (__dates)[0]); 
# 780
break; 
# 781
case 'X':  
# 783
const char_type *__times[2]; 
# 784
(__tp._M_time_formats(__times)); 
# 785
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, (__times)[0]); 
# 787
break; 
# 788
case 'y':  
# 789
case 'C':  
# 791
case 'Y':  
# 796
__beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4, __io, __tmperr); 
# 798
if (!__tmperr) { 
# 799
(__tm->tm_year) = ((__mem < 0) ? __mem + 100 : (__mem - 1900)); }  
# 800
break; 
# 801
case 'Z':  
# 803
if ((__ctype.is(ctype_base::upper, *__beg))) 
# 804
{ 
# 805
int __tmp; 
# 806
__beg = _M_extract_name(__beg, __end, __tmp, __timepunct_cache< _CharT> ::_S_timezones, 14, __io, __tmperr); 
# 811
if ((__beg != __end) && (!__tmperr) && (__tmp == 0) && (((*__beg) == (__ctype.widen('-'))) || ((*__beg) == (__ctype.widen('+'))))) 
# 814
{ 
# 815
__beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2, __io, __tmperr); 
# 817
__beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2, __io, __tmperr); 
# 819
}  
# 820
} else { 
# 822
(__tmperr |= ios_base::failbit); }  
# 823
break; 
# 824
default:  
# 826
(__tmperr |= ios_base::failbit); 
# 827
}  
# 828
} else 
# 830
{ 
# 832
if ((__format[__i]) == (*__beg)) { 
# 833
++__beg; } else { 
# 835
(__tmperr |= ios_base::failbit); }  
# 836
}  
# 837
}  
# 839
if (__tmperr || (__i != __len)) { 
# 840
(__err |= ios_base::failbit); }  
# 842
return __beg; 
# 843
} 
# 845
template< class _CharT, class _InIter> _InIter 
# 848
__cxx11::time_get< _CharT, _InIter> ::_M_extract_num(iter_type __beg, iter_type __end, int &__member, int 
# 849
__min, int __max, size_t __len, ios_base &
# 850
__io, ios_base::iostate &__err) const 
# 851
{ 
# 852
const locale &__loc = __io._M_getloc(); 
# 853
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 856
int __mult = (__len == (2)) ? 10 : ((__len == (4)) ? 1000 : 1); 
# 858
++__min; 
# 859
size_t __i = (0); 
# 860
int __value = 0; 
# 861
for (; (__beg != __end) && (__i < __len); (++__beg), (++__i)) 
# 862
{ 
# 863
const char __c = (__ctype.narrow(*__beg, '*')); 
# 864
if ((__c >= ('0')) && (__c <= ('9'))) 
# 865
{ 
# 866
__value = ((__value * 10) + (__c - ('0'))); 
# 867
const int __valuec = __value * __mult; 
# 868
if ((__valuec > __max) || ((__valuec + __mult) < __min)) { 
# 869
break; }  
# 870
__mult /= 10; 
# 871
} else { 
# 873
break; }  
# 874
}  
# 875
if (__i == __len) { 
# 876
__member = __value; } else { 
# 878
if ((__len == (4)) && (__i == (2))) { 
# 879
__member = (__value - 100); } else { 
# 881
(__err |= ios_base::failbit); }  }  
# 883
return __beg; 
# 884
} 
# 888
template< class _CharT, class _InIter> _InIter 
# 891
__cxx11::time_get< _CharT, _InIter> ::_M_extract_name(iter_type __beg, iter_type __end, int &__member, const _CharT **
# 892
__names, size_t __indexlen, ios_base &
# 893
__io, ios_base::iostate &__err) const 
# 894
{ 
# 895
typedef char_traits< _CharT>  __traits_type; 
# 896
const locale &__loc = __io._M_getloc(); 
# 897
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 899
int *__matches = static_cast< int *>(__builtin_alloca(sizeof(int) * __indexlen)); 
# 901
size_t __nmatches = (0); 
# 902
size_t __pos = (0); 
# 903
bool __testvalid = true; 
# 904
const char_type *__name; 
# 910
if (__beg != __end) 
# 911
{ 
# 912
const char_type __c = *__beg; 
# 913
for (size_t __i1 = (0); __i1 < __indexlen; ++__i1) { 
# 914
if ((__c == ((__names[__i1])[0])) || (__c == (__ctype.toupper((__names[__i1])[0])))) { 
# 916
(__matches[__nmatches++]) = __i1; }  }  
# 917
}  
# 919
while (__nmatches > (1)) 
# 920
{ 
# 922
size_t __minlen = __traits_type::length(__names[__matches[0]]); 
# 923
for (size_t __i2 = (1); __i2 < __nmatches; ++__i2) { 
# 924
__minlen = std::min(__minlen, __traits_type::length(__names[__matches[__i2]])); }  
# 926
(++__beg), (++__pos); 
# 927
if ((__pos < __minlen) && (__beg != __end)) { 
# 928
for (size_t __i3 = (0); __i3 < __nmatches;) 
# 929
{ 
# 930
__name = (__names[__matches[__i3]]); 
# 931
if (!((__name[__pos]) == (*__beg))) { 
# 932
(__matches[__i3]) = (__matches[--__nmatches]); } else { 
# 934
++__i3; }  
# 935
}  } else { 
# 937
break; }  
# 938
}  
# 940
if (__nmatches == (1)) 
# 941
{ 
# 943
(++__beg), (++__pos); 
# 944
__name = (__names[__matches[0]]); 
# 945
const size_t __len = __traits_type::length(__name); 
# 946
while ((__pos < __len) && (__beg != __end) && ((__name[__pos]) == (*__beg))) { 
# 947
(++__beg), (++__pos); }  
# 949
if (__len == __pos) { 
# 950
__member = (__matches[0]); } else { 
# 952
__testvalid = false; }  
# 953
} else { 
# 955
__testvalid = false; }  
# 956
if (!__testvalid) { 
# 957
(__err |= ios_base::failbit); }  
# 959
return __beg; 
# 960
} 
# 962
template< class _CharT, class _InIter> _InIter 
# 965
__cxx11::time_get< _CharT, _InIter> ::_M_extract_wday_or_month(iter_type __beg, iter_type __end, int &__member, const _CharT **
# 966
__names, size_t __indexlen, ios_base &
# 967
__io, ios_base::iostate &__err) const 
# 968
{ 
# 969
typedef char_traits< _CharT>  __traits_type; 
# 970
const locale &__loc = __io._M_getloc(); 
# 971
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 973
int *__matches = static_cast< int *>(__builtin_alloca(((2) * sizeof(int)) * __indexlen)); 
# 975
size_t __nmatches = (0); 
# 976
size_t *__matches_lengths = (0); 
# 977
size_t __pos = (0); 
# 979
if (__beg != __end) 
# 980
{ 
# 981
const char_type __c = *__beg; 
# 982
for (size_t __i = (0); __i < ((2) * __indexlen); ++__i) { 
# 983
if ((__c == ((__names[__i])[0])) || (__c == (__ctype.toupper((__names[__i])[0])))) { 
# 985
(__matches[__nmatches++]) = __i; }  }  
# 986
}  
# 988
if (__nmatches) 
# 989
{ 
# 990
(++__beg), (++__pos); 
# 992
__matches_lengths = (static_cast< size_t *>(__builtin_alloca(sizeof(size_t) * __nmatches))); 
# 995
for (size_t __i = (0); __i < __nmatches; ++__i) { 
# 996
(__matches_lengths[__i]) = __traits_type::length(__names[__matches[__i]]); }  
# 998
}  
# 1000
for (; __beg != __end; (++__beg), (++__pos)) 
# 1001
{ 
# 1002
size_t __nskipped = (0); 
# 1003
const char_type __c = *__beg; 
# 1004
for (size_t __i = (0); __i < __nmatches;) 
# 1005
{ 
# 1006
const char_type *__name = __names[__matches[__i]]; 
# 1007
if (__pos >= (__matches_lengths[__i])) { 
# 1008
(++__nskipped), (++__i); } else { 
# 1009
if (!((__name[__pos]) == __c)) 
# 1010
{ 
# 1011
--__nmatches; 
# 1012
(__matches[__i]) = (__matches[__nmatches]); 
# 1013
(__matches_lengths[__i]) = (__matches_lengths[__nmatches]); 
# 1014
} else { 
# 1016
++__i; }  }  
# 1017
}  
# 1018
if (__nskipped == __nmatches) { 
# 1019
break; }  
# 1020
}  
# 1022
if (((__nmatches == (1)) && ((__matches_lengths[0]) == __pos)) || ((__nmatches == (2)) && (((__matches_lengths[0]) == __pos) || ((__matches_lengths[1]) == __pos)))) { 
# 1025
__member = (((__matches[0]) >= __indexlen) ? (__matches[0]) - __indexlen : (__matches[0])); } else { 
# 1028
(__err |= ios_base::failbit); }  
# 1030
return __beg; 
# 1031
} 
# 1033
template< class _CharT, class _InIter> _InIter 
# 1036
__cxx11::time_get< _CharT, _InIter> ::do_get_time(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 1037
__err, tm *__tm) const 
# 1038
{ 
# 1039
const locale &__loc = __io._M_getloc(); 
# 1040
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 1041
const char_type *__times[2]; 
# 1042
(__tp._M_time_formats(__times)); 
# 1043
__beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, (__times)[0]); 
# 1045
if (__beg == __end) { 
# 1046
(__err |= ios_base::eofbit); }  
# 1047
return __beg; 
# 1048
} 
# 1050
template< class _CharT, class _InIter> _InIter 
# 1053
__cxx11::time_get< _CharT, _InIter> ::do_get_date(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 1054
__err, tm *__tm) const 
# 1055
{ 
# 1056
const locale &__loc = __io._M_getloc(); 
# 1057
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 1058
const char_type *__dates[2]; 
# 1059
(__tp._M_date_formats(__dates)); 
# 1060
__beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, (__dates)[0]); 
# 1062
if (__beg == __end) { 
# 1063
(__err |= ios_base::eofbit); }  
# 1064
return __beg; 
# 1065
} 
# 1067
template< class _CharT, class _InIter> _InIter 
# 1070
__cxx11::time_get< _CharT, _InIter> ::do_get_weekday(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 1071
__err, tm *__tm) const 
# 1072
{ 
# 1073
const locale &__loc = __io._M_getloc(); 
# 1074
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 1075
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1076
const char_type *__days[14]; 
# 1077
(__tp._M_days_abbreviated(__days)); 
# 1078
(__tp._M_days((__days) + 7)); 
# 1079
int __tmpwday; 
# 1080
ios_base::iostate __tmperr = ios_base::goodbit; 
# 1082
__beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7, __io, __tmperr); 
# 1084
if (!__tmperr) { 
# 1085
(__tm->tm_wday) = __tmpwday; } else { 
# 1087
(__err |= ios_base::failbit); }  
# 1089
if (__beg == __end) { 
# 1090
(__err |= ios_base::eofbit); }  
# 1091
return __beg; 
# 1092
} 
# 1094
template< class _CharT, class _InIter> _InIter 
# 1097
__cxx11::time_get< _CharT, _InIter> ::do_get_monthname(iter_type __beg, iter_type __end, ios_base &
# 1098
__io, ios_base::iostate &__err, tm *__tm) const 
# 1099
{ 
# 1100
const locale &__loc = __io._M_getloc(); 
# 1101
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 1102
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1103
const char_type *__months[24]; 
# 1104
(__tp._M_months_abbreviated(__months)); 
# 1105
(__tp._M_months((__months) + 12)); 
# 1106
int __tmpmon; 
# 1107
ios_base::iostate __tmperr = ios_base::goodbit; 
# 1109
__beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12, __io, __tmperr); 
# 1111
if (!__tmperr) { 
# 1112
(__tm->tm_mon) = __tmpmon; } else { 
# 1114
(__err |= ios_base::failbit); }  
# 1116
if (__beg == __end) { 
# 1117
(__err |= ios_base::eofbit); }  
# 1118
return __beg; 
# 1119
} 
# 1121
template< class _CharT, class _InIter> _InIter 
# 1124
__cxx11::time_get< _CharT, _InIter> ::do_get_year(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 1125
__err, tm *__tm) const 
# 1126
{ 
# 1127
const locale &__loc = __io._M_getloc(); 
# 1128
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1129
int __tmpyear; 
# 1130
ios_base::iostate __tmperr = ios_base::goodbit; 
# 1132
__beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4, __io, __tmperr); 
# 1134
if (!__tmperr) { 
# 1135
(__tm->tm_year) = ((__tmpyear < 0) ? __tmpyear + 100 : (__tmpyear - 1900)); } else { 
# 1137
(__err |= ios_base::failbit); }  
# 1139
if (__beg == __end) { 
# 1140
(__err |= ios_base::eofbit); }  
# 1141
return __beg; 
# 1142
} 
# 1145
template< class _CharT, class _InIter> inline _InIter 
# 1149
__cxx11::time_get< _CharT, _InIter> ::get(iter_type __s, iter_type __end, ios_base &__io, ios_base::iostate &
# 1150
__err, tm *__tm, const char_type *__fmt, const char_type *
# 1151
__fmtend) const 
# 1152
{ 
# 1153
const locale &__loc = __io._M_getloc(); 
# 1154
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1155
__err = ios_base::goodbit; 
# 1156
while ((__fmt != __fmtend) && (__err == ios_base::goodbit)) 
# 1158
{ 
# 1159
if (__s == __end) 
# 1160
{ 
# 1161
__err = ((ios_base::eofbit | ios_base::failbit)); 
# 1162
break; 
# 1163
} else { 
# 1164
if ((__ctype.narrow(*__fmt, 0)) == '%') 
# 1165
{ 
# 1166
char __format; 
# 1167
char __mod = (0); 
# 1168
if ((++__fmt) == __fmtend) 
# 1169
{ 
# 1170
__err = ios_base::failbit; 
# 1171
break; 
# 1172
}  
# 1173
const char __c = (__ctype.narrow(*__fmt, 0)); 
# 1174
if ((__c != ('E')) && (__c != ('O'))) { 
# 1175
__format = __c; } else { 
# 1176
if ((++__fmt) != __fmtend) 
# 1177
{ 
# 1178
__mod = __c; 
# 1179
__format = (__ctype.narrow(*__fmt, 0)); 
# 1180
} else 
# 1182
{ 
# 1183
__err = ios_base::failbit; 
# 1184
break; 
# 1185
}  }  
# 1186
__s = this->do_get(__s, __end, __io, __err, __tm, __format, __mod); 
# 1188
++__fmt; 
# 1189
} else { 
# 1190
if ((__ctype.is(ctype_base::space, *__fmt))) 
# 1191
{ 
# 1192
++__fmt; 
# 1193
while ((__fmt != __fmtend) && (__ctype.is(ctype_base::space, *__fmt))) { 
# 1195
++__fmt; }  
# 1197
while ((__s != __end) && (__ctype.is(ctype_base::space, *__s))) { 
# 1199
++__s; }  
# 1200
} else { 
# 1202
if (((__ctype.tolower(*__s)) == (__ctype.tolower(*__fmt))) || ((__ctype.toupper(*__s)) == (__ctype.toupper(*__fmt)))) 
# 1204
{ 
# 1205
++__s; 
# 1206
++__fmt; 
# 1207
} else 
# 1209
{ 
# 1210
__err = ios_base::failbit; 
# 1211
break; 
# 1212
}  }  }  }  
# 1213
}  
# 1214
return __s; 
# 1215
} 
# 1217
template< class _CharT, class _InIter> inline _InIter 
# 1221
__cxx11::time_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 1222
__err, tm *__tm, char 
# 1223
__format, char __mod) const 
# 1224
{ 
# 1225
const locale &__loc = __io._M_getloc(); 
# 1226
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1227
__err = ios_base::goodbit; 
# 1229
char_type __fmt[4]; 
# 1230
((__fmt)[0]) = (__ctype.widen('%')); 
# 1231
if (!__mod) 
# 1232
{ 
# 1233
((__fmt)[1]) = __format; 
# 1234
((__fmt)[2]) = char_type(); 
# 1235
} else 
# 1237
{ 
# 1238
((__fmt)[1]) = __mod; 
# 1239
((__fmt)[2]) = __format; 
# 1240
((__fmt)[3]) = char_type(); 
# 1241
}  
# 1243
__beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __fmt); 
# 1244
if (__beg == __end) { 
# 1245
(__err |= ios_base::eofbit); }  
# 1246
return __beg; 
# 1247
} 
# 1251
template< class _CharT, class _OutIter> _OutIter 
# 1254
time_put< _CharT, _OutIter> ::put(iter_type __s, ios_base &__io, char_type __fill, const tm *__tm, const _CharT *
# 1255
__beg, const _CharT *__end) const 
# 1256
{ 
# 1257
const locale &__loc = __io._M_getloc(); 
# 1258
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1259
for (; __beg != __end; ++__beg) { 
# 1260
if ((__ctype.narrow(*__beg, 0)) != '%') 
# 1261
{ 
# 1262
(*__s) = (*__beg); 
# 1263
++__s; 
# 1264
} else { 
# 1265
if ((++__beg) != __end) 
# 1266
{ 
# 1267
char __format; 
# 1268
char __mod = (0); 
# 1269
const char __c = (__ctype.narrow(*__beg, 0)); 
# 1270
if ((__c != ('E')) && (__c != ('O'))) { 
# 1271
__format = __c; } else { 
# 1272
if ((++__beg) != __end) 
# 1273
{ 
# 1274
__mod = __c; 
# 1275
__format = (__ctype.narrow(*__beg, 0)); 
# 1276
} else { 
# 1278
break; }  }  
# 1279
__s = this->do_put(__s, __io, __fill, __tm, __format, __mod); 
# 1280
} else { 
# 1282
break; }  }  }  
# 1283
return __s; 
# 1284
} 
# 1286
template< class _CharT, class _OutIter> _OutIter 
# 1289
time_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type, const tm *__tm, char 
# 1290
__format, char __mod) const 
# 1291
{ 
# 1292
const locale &__loc = __io._M_getloc(); 
# 1293
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1294
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 1298
const size_t __maxlen = (128); 
# 1299
char_type __res[__maxlen]; 
# 1306
char_type __fmt[4]; 
# 1307
((__fmt)[0]) = (__ctype.widen('%')); 
# 1308
if (!__mod) 
# 1309
{ 
# 1310
((__fmt)[1]) = __format; 
# 1311
((__fmt)[2]) = char_type(); 
# 1312
} else 
# 1314
{ 
# 1315
((__fmt)[1]) = __mod; 
# 1316
((__fmt)[2]) = __format; 
# 1317
((__fmt)[3]) = char_type(); 
# 1318
}  
# 1320
(__tp._M_put(__res, __maxlen, __fmt, __tm)); 
# 1323
return std::__write(__s, __res, char_traits< _CharT> ::length(__res)); 
# 1324
} 
# 1330
extern template class __cxx11::moneypunct< char, false> ;
# 1331
extern template class __cxx11::moneypunct< char, true> ;
# 1332
extern template class __cxx11::moneypunct_byname< char, false> ;
# 1333
extern template class __cxx11::moneypunct_byname< char, true> ;
# 1334
extern template class __cxx11::money_get< char, istreambuf_iterator< char, char_traits< char> > > ;
# 1335
extern template class __cxx11::money_put< char, ostreambuf_iterator< char, char_traits< char> > > ;
# 1336
extern template class __timepunct< char> ;
# 1337
extern template class time_put< char, ostreambuf_iterator< char, char_traits< char> > > ;
# 1338
extern template class time_put_byname< char, ostreambuf_iterator< char, char_traits< char> > > ;
# 1339
extern template class __cxx11::time_get< char, istreambuf_iterator< char, char_traits< char> > > ;
# 1340
extern template class __cxx11::time_get_byname< char, istreambuf_iterator< char, char_traits< char> > > ;
# 1341
extern template class __cxx11::messages< char> ;
# 1342
extern template class __cxx11::messages_byname< char> ;
# 1344
extern template const __cxx11::moneypunct< char, true>  &use_facet< __cxx11::moneypunct< char, true> > (const locale &);
# 1348
extern template const __cxx11::moneypunct< char, false>  &use_facet< __cxx11::moneypunct< char, false> > (const locale &);
# 1352
extern template const __cxx11::money_put< char, ostreambuf_iterator< char, char_traits< char> > >  &use_facet< __cxx11::money_put< char, ostreambuf_iterator< char, char_traits< char> > > > (const locale &);
# 1356
extern template const __cxx11::money_get< char, istreambuf_iterator< char, char_traits< char> > >  &use_facet< __cxx11::money_get< char, istreambuf_iterator< char, char_traits< char> > > > (const locale &);
# 1360
extern template const __timepunct< char>  &use_facet< __timepunct< char> > (const locale &);
# 1364
extern template const time_put< char, ostreambuf_iterator< char, char_traits< char> > >  &use_facet< time_put< char, ostreambuf_iterator< char, char_traits< char> > > > (const locale &);
# 1368
extern template const __cxx11::time_get< char, istreambuf_iterator< char, char_traits< char> > >  &use_facet< __cxx11::time_get< char, istreambuf_iterator< char, char_traits< char> > > > (const locale &);
# 1372
extern template const __cxx11::messages< char>  &use_facet< __cxx11::messages< char> > (const locale &);
# 1376
extern template bool has_facet< __cxx11::moneypunct< char, false> > (const locale &) throw();
# 1380
extern template bool has_facet< __cxx11::money_put< char, ostreambuf_iterator< char, char_traits< char> > > > (const locale &) throw();
# 1384
extern template bool has_facet< __cxx11::money_get< char, istreambuf_iterator< char, char_traits< char> > > > (const locale &) throw();
# 1388
extern template bool has_facet< __timepunct< char> > (const locale &) throw();
# 1392
extern template bool has_facet< time_put< char, ostreambuf_iterator< char, char_traits< char> > > > (const locale &) throw();
# 1396
extern template bool has_facet< __cxx11::time_get< char, istreambuf_iterator< char, char_traits< char> > > > (const locale &) throw();
# 1400
extern template bool has_facet< __cxx11::messages< char> > (const locale &) throw();
# 1405
extern template class __cxx11::moneypunct< wchar_t, false> ;
# 1406
extern template class __cxx11::moneypunct< wchar_t, true> ;
# 1407
extern template class __cxx11::moneypunct_byname< wchar_t, false> ;
# 1408
extern template class __cxx11::moneypunct_byname< wchar_t, true> ;
# 1409
extern template class __cxx11::money_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > ;
# 1410
extern template class __cxx11::money_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > ;
# 1411
extern template class __timepunct< wchar_t> ;
# 1412
extern template class time_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > ;
# 1413
extern template class time_put_byname< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > ;
# 1414
extern template class __cxx11::time_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > ;
# 1415
extern template class __cxx11::time_get_byname< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > ;
# 1416
extern template class __cxx11::messages< wchar_t> ;
# 1417
extern template class __cxx11::messages_byname< wchar_t> ;
# 1419
extern template const __cxx11::moneypunct< wchar_t, true>  &use_facet< __cxx11::moneypunct< wchar_t, true> > (const locale &);
# 1423
extern template const __cxx11::moneypunct< wchar_t, false>  &use_facet< __cxx11::moneypunct< wchar_t, false> > (const locale &);
# 1427
extern template const __cxx11::money_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > >  &use_facet< __cxx11::money_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &);
# 1431
extern template const __cxx11::money_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > >  &use_facet< __cxx11::money_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &);
# 1435
extern template const __timepunct< wchar_t>  &use_facet< __timepunct< wchar_t> > (const locale &);
# 1439
extern template const time_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > >  &use_facet< time_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &);
# 1443
extern template const __cxx11::time_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > >  &use_facet< __cxx11::time_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &);
# 1447
extern template const __cxx11::messages< wchar_t>  &use_facet< __cxx11::messages< wchar_t> > (const locale &);
# 1451
extern template bool has_facet< __cxx11::moneypunct< wchar_t, false> > (const locale &) throw();
# 1455
extern template bool has_facet< __cxx11::money_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &) throw();
# 1459
extern template bool has_facet< __cxx11::money_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &) throw();
# 1463
extern template bool has_facet< __timepunct< wchar_t> > (const locale &) throw();
# 1467
extern template bool has_facet< time_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &) throw();
# 1471
extern template bool has_facet< __cxx11::time_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &) throw();
# 1475
extern template bool has_facet< __cxx11::messages< wchar_t> > (const locale &) throw();
# 1482
}
# 43 "/usr/include/c++/5/bits/locale_conv.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 52
template< class _OutStr, class _InChar, class _Codecvt, class 
# 53
_State, class _Fn> bool 
# 55
__do_str_codecvt(const _InChar *__first, const _InChar *__last, _OutStr &
# 56
__outstr, const _Codecvt &__cvt, _State &__state, size_t &
# 57
__count, _Fn __fn) 
# 58
{ 
# 59
if (__first == __last) 
# 60
{ 
# 61
(__outstr.clear()); 
# 62
__count = (0); 
# 63
return true; 
# 64
}  
# 66
size_t __outchars = (0); 
# 67
auto __next = __first; 
# 68
const auto __maxlen = (__cvt.max_length()) + 1; 
# 70
codecvt_base::result __result; 
# 71
do 
# 72
{ 
# 73
(__outstr.resize((__outstr.size()) + ((__last - __next) * __maxlen))); 
# 74
auto __outnext = (&(__outstr.front())) + __outchars; 
# 75
const auto __outlast = ((&(__outstr.back())) + 1); 
# 76
__result = (__cvt.*__fn)(__state, __next, __last, __next, __outnext, __outlast, __outnext); 
# 78
__outchars = (__outnext - (&(__outstr.front()))); 
# 79
} 
# 80
while ((__result == (codecvt_base::partial)) && (__next != __last) && (((__outstr.size()) - __outchars) < __maxlen)); 
# 83
if (__result == (codecvt_base::error)) { 
# 84
return false; }  
# 86
if (__result == (codecvt_base::noconv)) 
# 87
{ 
# 88
(__outstr.assign(__first, __last)); 
# 89
__count = (__last - __first); 
# 90
} else 
# 92
{ 
# 93
(__outstr.resize(__outchars)); 
# 94
__count = (__next - __first); 
# 95
}  
# 97
return true; 
# 98
} 
# 101
template< class _CharT, class _Traits, class _Alloc, class _State> inline bool 
# 103
__str_codecvt_in(const char *__first, const char *__last, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 104
__outstr, const codecvt< _CharT, char, _State>  &
# 105
__cvt, _State &
# 106
__state, size_t &__count) 
# 107
{ 
# 108
using _Codecvt = codecvt< _CharT, char, _State> ; 
# 109
using _ConvFn = codecvt_base::result (codecvt< _CharT, char, _State> ::*)(_State &, const char *, const char *, const char *&, _CharT *, _CharT *, _CharT *&) const; 
# 113
_ConvFn __fn = (&codecvt< _CharT, char, _State> ::in); 
# 114
return __do_str_codecvt(__first, __last, __outstr, __cvt, __state, __count, __fn); 
# 116
} 
# 118
template< class _CharT, class _Traits, class _Alloc, class _State> inline bool 
# 120
__str_codecvt_in(const char *__first, const char *__last, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 121
__outstr, const codecvt< _CharT, char, _State>  &
# 122
__cvt) 
# 123
{ 
# 124
_State __state = {}; 
# 125
size_t __n; 
# 126
return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n); 
# 127
} 
# 130
template< class _CharT, class _Traits, class _Alloc, class _State> inline bool 
# 132
__str_codecvt_out(const _CharT *__first, const _CharT *__last, __cxx11::basic_string< char, _Traits, _Alloc>  &
# 133
__outstr, const codecvt< _CharT, char, _State>  &
# 134
__cvt, _State &
# 135
__state, size_t &__count) 
# 136
{ 
# 137
using _Codecvt = codecvt< _CharT, char, _State> ; 
# 138
using _ConvFn = codecvt_base::result (codecvt< _CharT, char, _State> ::*)(_State &, const _CharT *, const _CharT *, const _CharT *&, char *, char *, char *&) const; 
# 142
_ConvFn __fn = (&codecvt< _CharT, char, _State> ::out); 
# 143
return __do_str_codecvt(__first, __last, __outstr, __cvt, __state, __count, __fn); 
# 145
} 
# 147
template< class _CharT, class _Traits, class _Alloc, class _State> inline bool 
# 149
__str_codecvt_out(const _CharT *__first, const _CharT *__last, __cxx11::basic_string< char, _Traits, _Alloc>  &
# 150
__outstr, const codecvt< _CharT, char, _State>  &
# 151
__cvt) 
# 152
{ 
# 153
_State __state = {}; 
# 154
size_t __n; 
# 155
return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n); 
# 156
} 
# 160
inline namespace __cxx11 { 
# 163
template< class _Codecvt, class _Elem = wchar_t, class 
# 164
_Wide_alloc = allocator< _Elem> , class 
# 165
_Byte_alloc = allocator< char> > 
# 166
class wstring_convert { 
# 169
public: typedef basic_string< char, char_traits< char> , _Byte_alloc>  byte_string; 
# 170
typedef basic_string< _Elem, char_traits< _Elem> , _Wide_alloc>  wide_string; 
# 171
typedef typename _Codecvt::state_type state_type; 
# 172
typedef typename basic_string< _Elem, char_traits< _Elem> , _Wide_alloc> ::traits_type::int_type int_type; 
# 181
explicit wstring_convert(_Codecvt *__pcvt = new (_Codecvt)()) : _M_cvt(__pcvt) 
# 182
{ 
# 183
if (!(_M_cvt)) { 
# 184
__throw_logic_error("wstring_convert"); }  
# 185
} 
# 195 "/usr/include/c++/5/bits/locale_conv.h" 3
wstring_convert(_Codecvt *__pcvt, state_type __state) : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true) 
# 197
{ 
# 198
if (!(_M_cvt)) { 
# 199
__throw_logic_error("wstring_convert"); }  
# 200
} 
# 208
explicit wstring_convert(const byte_string &__byte_err, const wide_string &
# 209
__wide_err = wide_string()) : _M_cvt(new (_Codecvt)), _M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err), _M_with_strings(true) 
# 213
{ 
# 214
if (!(_M_cvt)) { 
# 215
__throw_logic_error("wstring_convert"); }  
# 216
} 
# 218
~wstring_convert() = default;
# 222
wstring_convert(const wstring_convert &) = delete;
# 223
wstring_convert &operator=(const wstring_convert &) = delete;
# 227
wide_string from_bytes(char __byte) 
# 228
{ 
# 229
char __bytes[2] = {__byte}; 
# 230
return from_bytes(__bytes, (__bytes) + 1); 
# 231
} 
# 234
wide_string from_bytes(const char *__ptr) 
# 235
{ return from_bytes(__ptr, __ptr + char_traits< char> ::length(__ptr)); } 
# 238
wide_string from_bytes(const byte_string &__str) 
# 239
{ 
# 240
auto __ptr = (__str.data()); 
# 241
return from_bytes(__ptr, __ptr + (__str.size())); 
# 242
} 
# 245
wide_string from_bytes(const char *__first, const char *__last) 
# 246
{ 
# 247
if (!(_M_with_cvtstate)) { 
# 248
(_M_state) = state_type(); }  
# 249
wide_string __out{((_M_wide_err_string).get_allocator())}; 
# 250
if (__str_codecvt_in(__first, __last, __out, *(_M_cvt), _M_state, _M_count)) { 
# 252
return __out; }  
# 253
if (_M_with_strings) { 
# 254
return _M_wide_err_string; }  
# 255
__throw_range_error("wstring_convert::from_bytes"); 
# 256
} 
# 261
byte_string to_bytes(_Elem __wchar) 
# 262
{ 
# 263
_Elem __wchars[2] = {__wchar}; 
# 264
return to_bytes(__wchars, (__wchars) + 1); 
# 265
} 
# 268
byte_string to_bytes(const _Elem *__ptr) 
# 269
{ 
# 270
return to_bytes(__ptr, __ptr + wide_string::traits_type::length(__ptr)); 
# 271
} 
# 274
byte_string to_bytes(const wide_string &__wstr) 
# 275
{ 
# 276
auto __ptr = (__wstr.data()); 
# 277
return to_bytes(__ptr, __ptr + (__wstr.size())); 
# 278
} 
# 281
byte_string to_bytes(const _Elem *__first, const _Elem *__last) 
# 282
{ 
# 283
if (!(_M_with_cvtstate)) { 
# 284
(_M_state) = state_type(); }  
# 285
byte_string __out{((_M_byte_err_string).get_allocator())}; 
# 286
if (__str_codecvt_out(__first, __last, __out, *(_M_cvt), _M_state, _M_count)) { 
# 288
return __out; }  
# 289
if (_M_with_strings) { 
# 290
return _M_byte_err_string; }  
# 291
__throw_range_error("wstring_convert::to_bytes"); 
# 292
} 
# 298
size_t converted() const noexcept { return _M_count; } 
# 301
state_type state() const { return _M_state; } 
# 304
private: unique_ptr< _Codecvt>  _M_cvt; 
# 305
byte_string _M_byte_err_string; 
# 306
wide_string _M_wide_err_string; 
# 307
state_type _M_state = (state_type()); 
# 308
size_t _M_count = (0); 
# 309
bool _M_with_cvtstate = false; 
# 310
bool _M_with_strings = false; 
# 311
}; 
# 313
}
# 316
template< class _Codecvt, class _Elem = wchar_t, class 
# 317
_Tr = char_traits< _Elem> > 
# 318
class wbuffer_convert : public basic_streambuf< _Elem, _Tr>  { 
# 320
typedef ::std::basic_streambuf< _Elem, _Tr>  _Wide_streambuf; 
# 323
public: typedef typename _Codecvt::state_type state_type; 
# 334 "/usr/include/c++/5/bits/locale_conv.h" 3
explicit wbuffer_convert(::std::streambuf *__bytebuf = 0, _Codecvt *__pcvt = new (_Codecvt), state_type 
# 335
__state = state_type()) : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state) 
# 337
{ 
# 338
if (!(_M_cvt)) { 
# 339
__throw_logic_error("wbuffer_convert"); }  
# 341
(_M_always_noconv) = ((_M_cvt)->always_noconv()); 
# 343
if (_M_buf) 
# 344
{ 
# 345
(this->setp(_M_put_area, (_M_put_area) + _S_buffer_length)); 
# 346
(this->setg((_M_get_area) + _S_putback_length, (_M_get_area) + _S_putback_length, (_M_get_area) + _S_putback_length)); 
# 349
}  
# 350
} 
# 352
~wbuffer_convert() = default;
# 356
wbuffer_convert(const wbuffer_convert &) = delete;
# 357
wbuffer_convert &operator=(const wbuffer_convert &) = delete;
# 359
::std::streambuf *rdbuf() const noexcept { return _M_buf; } 
# 362
::std::streambuf *rdbuf(::std::streambuf *__bytebuf) noexcept 
# 363
{ 
# 364
auto __prev = _M_buf; 
# 365
(_M_buf) = __bytebuf; 
# 366
return __prev; 
# 367
} 
# 370
state_type state() const noexcept { return _M_state; } 
# 374
protected: int sync() 
# 375
{ return ((_M_buf) && _M_conv_put() && (_M_buf)->pubsync()) ? 0 : (-1); } 
# 378
typename ::std::basic_streambuf< _Elem, _Tr> ::int_type overflow(typename ::std::basic_streambuf< _Elem, _Tr> ::int_type __out) 
# 379
{ 
# 380
if ((!(_M_buf)) || (!_M_conv_put())) { 
# 381
return _Tr::eof(); } else { 
# 382
if (!_Tr::eq_int_type(__out, _Tr::eof())) { 
# 383
return (this->sputc(__out)); }  }  
# 384
return _Tr::not_eof(__out); 
# 385
} 
# 388
typename ::std::basic_streambuf< _Elem, _Tr> ::int_type underflow() 
# 389
{ 
# 390
if (!(_M_buf)) { 
# 391
return _Tr::eof(); }  
# 393
if (((this->gptr()) < (this->egptr())) || ((_M_buf) && _M_conv_get())) { 
# 394
return _Tr::to_int_type(*(this->gptr())); } else { 
# 396
return _Tr::eof(); }  
# 397
} 
# 400
::std::streamsize xsputn(const typename ::std::basic_streambuf< _Elem, _Tr> ::char_type *__s, ::std::streamsize __n) 
# 401
{ 
# 402
if ((!(_M_buf)) || (__n == (0))) { 
# 403
return 0; }  
# 404
::std::streamsize __done = (0); 
# 405
do 
# 406
{ 
# 407
auto __nn = ::std::min< ::std::streamsize> ((this->epptr()) - (this->pptr()), __n - __done); 
# 409
_Tr::copy((this->pptr()), __s + __done, __nn); 
# 410
(this->pbump(__nn)); 
# 411
__done += __nn; 
# 412
} while ((__done < __n) && _M_conv_put()); 
# 413
return __done; 
# 414
} 
# 419
private: bool _M_conv_get() 
# 420
{ 
# 421
const ::std::streamsize __pb1 = (this->gptr()) - (this->eback()); 
# 422
const ::std::streamsize __pb2 = _S_putback_length; 
# 423
const ::std::streamsize __npb = std::min(__pb1, __pb2); 
# 425
_Tr::move(((_M_get_area) + _S_putback_length) - __npb, (this->gptr()) - __npb, __npb); 
# 428
::std::streamsize __nbytes = sizeof((_M_get_buf)) - (_M_unconv); 
# 429
__nbytes = std::min(__nbytes, (_M_buf)->in_avail()); 
# 430
if (__nbytes < (1)) { 
# 431
__nbytes == (1); }  
# 432
__nbytes = (_M_buf)->sgetn((_M_get_buf) + (_M_unconv), __nbytes); 
# 433
if (__nbytes < (1)) { 
# 434
return false; }  
# 435
__nbytes += (_M_unconv); 
# 439
_Elem *__outbuf = (_M_get_area) + _S_putback_length; 
# 440
_Elem *__outnext = __outbuf; 
# 441
const char *__bnext = _M_get_buf; 
# 443
::std::codecvt_base::result __result; 
# 444
if (_M_always_noconv) { 
# 445
__result = codecvt_base::noconv; } else 
# 447
{ 
# 448
_Elem *__outend = (_M_get_area) + _S_buffer_length; 
# 450
__result = ((_M_cvt)->in(_M_state, __bnext, __bnext + __nbytes, __bnext, __outbuf, __outend, __outnext)); 
# 453
}  
# 455
if (__result == (codecvt_base::noconv)) 
# 456
{ 
# 458
auto __get_buf = reinterpret_cast< const _Elem *>(_M_get_buf); 
# 459
_Tr::copy(__outbuf, __get_buf, __nbytes); 
# 460
(_M_unconv) = (0); 
# 461
return true; 
# 462
}  
# 464
if (((_M_unconv) = (((_M_get_buf) + __nbytes) - __bnext))) { 
# 465
char_traits< char> ::move(_M_get_buf, __bnext, _M_unconv); }  
# 467
(this->setg(__outbuf, __outbuf, __outnext)); 
# 469
return __result != (codecvt_base::error); 
# 470
} 
# 474
bool _M_put(...) 
# 475
{ return false; } 
# 478
bool _M_put(const char *__p, ::std::streamsize __n) 
# 479
{ 
# 480
if ((_M_buf)->sputn(__p, __n) < __n) { 
# 481
return false; }  
# 482
} 
# 486
bool _M_conv_put() 
# 487
{ 
# 488
_Elem *const __first = (this->pbase()); 
# 489
const _Elem *const __last = (this->pptr()); 
# 490
const ::std::streamsize __pending = (__last - __first); 
# 492
if (_M_always_noconv) { 
# 493
return _M_put(__first, __pending); }  
# 495
char __outbuf[2L * 32L]; 
# 497
const _Elem *__next = (__first); 
# 498
const _Elem *__start; 
# 499
do 
# 500
{ 
# 501
__start = __next; 
# 502
char *__outnext = __outbuf; 
# 503
char *const __outlast = (__outbuf) + sizeof __outbuf; 
# 504
auto __result = ((_M_cvt)->out(_M_state, __next, __last, __next, __outnext, __outlast, __outnext)); 
# 506
if (__result == codecvt_base::error) { 
# 507
return false; } else { 
# 508
if (__result == codecvt_base::noconv) { 
# 509
return _M_put(__next, __pending); }  }  
# 511
if (!this->_M_put(__outbuf, __outnext - (__outbuf))) { 
# 512
return false; }  
# 513
} 
# 514
while ((__next != __last) && (__next != __start)); 
# 516
if (__next != __last) { 
# 517
_Tr::move(__first, __next, __last - __next); }  
# 519
(this->pbump(__first - __next)); 
# 520
return __next != __first; 
# 521
} 
# 523
::std::streambuf *_M_buf; 
# 524
unique_ptr< _Codecvt>  _M_cvt; 
# 525
state_type _M_state; 
# 527
static const ::std::streamsize _S_buffer_length = (32); 
# 528
static const ::std::streamsize _S_putback_length = (3); 
# 529
_Elem _M_put_area[_S_buffer_length]; 
# 530
_Elem _M_get_area[_S_buffer_length]; 
# 531
::std::streamsize _M_unconv = (0); 
# 532
char _M_get_buf[_S_buffer_length - _S_putback_length]; 
# 533
bool _M_always_noconv; 
# 534
}; 
# 541
}
# 49 "/usr/include/c++/5/iomanip" 3
namespace std __attribute((__visibility__("default"))) { 
# 56
struct _Resetiosflags { ios_base::fmtflags _M_mask; }; 
# 66 "/usr/include/c++/5/iomanip" 3
inline _Resetiosflags resetiosflags(ios_base::fmtflags __mask) 
# 67
{ return {__mask}; } 
# 69
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 71
operator>>(basic_istream< _CharT, _Traits>  &__is, _Resetiosflags __f) 
# 72
{ 
# 73
(__is.setf((ios_base::fmtflags)0, __f._M_mask)); 
# 74
return __is; 
# 75
} 
# 77
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 79
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Resetiosflags __f) 
# 80
{ 
# 81
(__os.setf((ios_base::fmtflags)0, __f._M_mask)); 
# 82
return __os; 
# 83
} 
# 86
struct _Setiosflags { ios_base::fmtflags _M_mask; }; 
# 96 "/usr/include/c++/5/iomanip" 3
inline _Setiosflags setiosflags(ios_base::fmtflags __mask) 
# 97
{ return {__mask}; } 
# 99
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 101
operator>>(basic_istream< _CharT, _Traits>  &__is, _Setiosflags __f) 
# 102
{ 
# 103
(__is.setf(__f._M_mask)); 
# 104
return __is; 
# 105
} 
# 107
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 109
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Setiosflags __f) 
# 110
{ 
# 111
(__os.setf(__f._M_mask)); 
# 112
return __os; 
# 113
} 
# 116
struct _Setbase { int _M_base; }; 
# 127 "/usr/include/c++/5/iomanip" 3
inline _Setbase setbase(int __base) 
# 128
{ return {__base}; } 
# 130
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 132
operator>>(basic_istream< _CharT, _Traits>  &__is, _Setbase __f) 
# 133
{ 
# 134
(__is.setf(((__f._M_base) == 8) ? ios_base::oct : (((__f._M_base) == 10) ? ios_base::dec : (((__f._M_base) == 16) ? ios_base::hex : ((ios_base::fmtflags)0))), ios_base::basefield)); 
# 138
return __is; 
# 139
} 
# 141
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 143
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Setbase __f) 
# 144
{ 
# 145
(__os.setf(((__f._M_base) == 8) ? ios_base::oct : (((__f._M_base) == 10) ? ios_base::dec : (((__f._M_base) == 16) ? ios_base::hex : ((ios_base::fmtflags)0))), ios_base::basefield)); 
# 149
return __os; 
# 150
} 
# 153
template< class _CharT> 
# 154
struct _Setfill { _CharT _M_c; }; 
# 163 "/usr/include/c++/5/iomanip" 3
template< class _CharT> inline _Setfill< _CharT>  
# 165
setfill(_CharT __c) 
# 166
{ return {__c}; } 
# 168
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 170
operator>>(basic_istream< _CharT, _Traits>  &__is, _Setfill< _CharT>  __f) 
# 171
{ 
# 172
(__is.fill((__f._M_c))); 
# 173
return __is; 
# 174
} 
# 176
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 178
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Setfill< _CharT>  __f) 
# 179
{ 
# 180
(__os.fill((__f._M_c))); 
# 181
return __os; 
# 182
} 
# 185
struct _Setprecision { int _M_n; }; 
# 195 "/usr/include/c++/5/iomanip" 3
inline _Setprecision setprecision(int __n) 
# 196
{ return {__n}; } 
# 198
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 200
operator>>(basic_istream< _CharT, _Traits>  &__is, _Setprecision __f) 
# 201
{ 
# 202
(__is.precision(__f._M_n)); 
# 203
return __is; 
# 204
} 
# 206
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 208
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Setprecision __f) 
# 209
{ 
# 210
(__os.precision(__f._M_n)); 
# 211
return __os; 
# 212
} 
# 215
struct _Setw { int _M_n; }; 
# 225 "/usr/include/c++/5/iomanip" 3
inline _Setw setw(int __n) 
# 226
{ return {__n}; } 
# 228
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 230
operator>>(basic_istream< _CharT, _Traits>  &__is, _Setw __f) 
# 231
{ 
# 232
(__is.width(__f._M_n)); 
# 233
return __is; 
# 234
} 
# 236
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 238
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Setw __f) 
# 239
{ 
# 240
(__os.width(__f._M_n)); 
# 241
return __os; 
# 242
} 
# 246
template< class _MoneyT> 
# 247
struct _Get_money { _MoneyT &_M_mon; bool _M_intl; }; 
# 257 "/usr/include/c++/5/iomanip" 3
template< class _MoneyT> inline _Get_money< _MoneyT>  
# 259
get_money(_MoneyT &__mon, bool __intl = false) 
# 260
{ return {__mon, __intl}; } 
# 262
template< class _CharT, class _Traits, class _MoneyT> basic_istream< _CharT, _Traits>  &
# 264
operator>>(basic_istream< _CharT, _Traits>  &__is, _Get_money< _MoneyT>  __f) 
# 265
{ 
# 266
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__is, false); 
# 267
if (__cerb) 
# 268
{ 
# 269
ios_base::iostate __err = ios_base::goodbit; 
# 270
try 
# 271
{ 
# 272
typedef istreambuf_iterator< _CharT, _Traits>  _Iter; 
# 273
typedef __cxx11::money_get< _CharT, istreambuf_iterator< _CharT, _Traits> >  _MoneyGet; 
# 275
const _MoneyGet &__mg = use_facet< __cxx11::money_get< _CharT, istreambuf_iterator< _CharT, _Traits> > > ((__is.getloc())); 
# 276
(__mg.get(((_Iter)((__is.rdbuf()))), _Iter(), (__f._M_intl), __is, __err, (__f._M_mon))); 
# 278
} 
# 279
catch (__cxxabiv1::__forced_unwind &) 
# 280
{ 
# 281
(__is._M_setstate(ios_base::badbit)); 
# 282
throw; 
# 283
} 
# 284
catch (...) 
# 285
{ (__is._M_setstate(ios_base::badbit)); }  
# 286
if (__err) { 
# 287
(__is.setstate(__err)); }  
# 288
}  
# 289
return __is; 
# 290
} 
# 293
template< class _MoneyT> 
# 294
struct _Put_money { const _MoneyT &_M_mon; bool _M_intl; }; 
# 304 "/usr/include/c++/5/iomanip" 3
template< class _MoneyT> inline _Put_money< _MoneyT>  
# 306
put_money(const _MoneyT &__mon, bool __intl = false) 
# 307
{ return {__mon, __intl}; } 
# 309
template< class _CharT, class _Traits, class _MoneyT> basic_ostream< _CharT, _Traits>  &
# 311
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Put_money< _MoneyT>  __f) 
# 312
{ 
# 313
typename basic_ostream< _CharT, _Traits> ::sentry __cerb(__os); 
# 314
if (__cerb) 
# 315
{ 
# 316
ios_base::iostate __err = ios_base::goodbit; 
# 317
try 
# 318
{ 
# 319
typedef ostreambuf_iterator< _CharT, _Traits>  _Iter; 
# 320
typedef __cxx11::money_put< _CharT, ostreambuf_iterator< _CharT, _Traits> >  _MoneyPut; 
# 322
const _MoneyPut &__mp = use_facet< __cxx11::money_put< _CharT, ostreambuf_iterator< _CharT, _Traits> > > ((__os.getloc())); 
# 323
if (((__mp.put(((_Iter)((__os.rdbuf()))), (__f._M_intl), __os, (__os.fill()), (__f._M_mon))).failed())) { 
# 325
(__err |= ios_base::badbit); }  
# 326
} 
# 327
catch (__cxxabiv1::__forced_unwind &) 
# 328
{ 
# 329
(__os._M_setstate(ios_base::badbit)); 
# 330
throw; 
# 331
} 
# 332
catch (...) 
# 333
{ (__os._M_setstate(ios_base::badbit)); }  
# 334
if (__err) { 
# 335
(__os.setstate(__err)); }  
# 336
}  
# 337
return __os; 
# 338
} 
# 340
template< class _CharT> 
# 341
struct _Put_time { 
# 343
const tm *_M_tmb; 
# 344
const _CharT *_M_fmt; 
# 345
}; 
# 356 "/usr/include/c++/5/iomanip" 3
template< class _CharT> inline _Put_time< _CharT>  
# 358
put_time(const tm *__tmb, const _CharT *__fmt) 
# 359
{ return {__tmb, __fmt}; } 
# 361
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 363
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Put_time< _CharT>  __f) 
# 364
{ 
# 365
typename basic_ostream< _CharT, _Traits> ::sentry __cerb(__os); 
# 366
if (__cerb) 
# 367
{ 
# 368
ios_base::iostate __err = ios_base::goodbit; 
# 369
try 
# 370
{ 
# 371
typedef ostreambuf_iterator< _CharT, _Traits>  _Iter; 
# 372
typedef time_put< _CharT, ostreambuf_iterator< _CharT, _Traits> >  _TimePut; 
# 374
const _CharT *const __fmt_end = (__f._M_fmt) + _Traits::length((__f._M_fmt)); 
# 377
const _TimePut &__mp = use_facet< time_put< _CharT, ostreambuf_iterator< _CharT, _Traits> > > ((__os.getloc())); 
# 378
if (((__mp.put(((_Iter)((__os.rdbuf()))), __os, (__os.fill()), (__f._M_tmb), (__f._M_fmt), __fmt_end)).failed())) { 
# 380
(__err |= ios_base::badbit); }  
# 381
} 
# 382
catch (__cxxabiv1::__forced_unwind &) 
# 383
{ 
# 384
(__os._M_setstate(ios_base::badbit)); 
# 385
throw; 
# 386
} 
# 387
catch (...) 
# 388
{ (__os._M_setstate(ios_base::badbit)); }  
# 389
if (__err) { 
# 390
(__os.setstate(__err)); }  
# 391
}  
# 392
return __os; 
# 393
} 
# 395
template< class _CharT> 
# 396
struct _Get_time { 
# 398
tm *_M_tmb; 
# 399
const _CharT *_M_fmt; 
# 400
}; 
# 411 "/usr/include/c++/5/iomanip" 3
template< class _CharT> inline _Get_time< _CharT>  
# 413
get_time(tm *__tmb, const _CharT *__fmt) 
# 414
{ return {__tmb, __fmt}; } 
# 416
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 418
operator>>(basic_istream< _CharT, _Traits>  &__is, _Get_time< _CharT>  __f) 
# 419
{ 
# 420
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__is, false); 
# 421
if (__cerb) 
# 422
{ 
# 423
ios_base::iostate __err = ios_base::goodbit; 
# 424
try 
# 425
{ 
# 426
typedef istreambuf_iterator< _CharT, _Traits>  _Iter; 
# 427
typedef __cxx11::time_get< _CharT, istreambuf_iterator< _CharT, _Traits> >  _TimeGet; 
# 429
const _CharT *const __fmt_end = (__f._M_fmt) + _Traits::length((__f._M_fmt)); 
# 432
const _TimeGet &__mg = use_facet< __cxx11::time_get< _CharT, istreambuf_iterator< _CharT, _Traits> > > ((__is.getloc())); 
# 433
(__mg.get(((_Iter)((__is.rdbuf()))), _Iter(), __is, __err, (__f._M_tmb), (__f._M_fmt), __fmt_end)); 
# 435
} 
# 436
catch (__cxxabiv1::__forced_unwind &) 
# 437
{ 
# 438
(__is._M_setstate(ios_base::badbit)); 
# 439
throw; 
# 440
} 
# 441
catch (...) 
# 442
{ (__is._M_setstate(ios_base::badbit)); }  
# 443
if (__err) { 
# 444
(__is.setstate(__err)); }  
# 445
}  
# 446
return __is; 
# 447
} 
# 496 "/usr/include/c++/5/iomanip" 3
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __os, _Setfill< char>  __f);
# 497
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __os, _Setiosflags __f);
# 498
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __os, _Resetiosflags __f);
# 499
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __os, _Setbase __f);
# 500
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __os, _Setprecision __f);
# 501
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __os, _Setw __f);
# 502
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __is, _Setfill< char>  __f);
# 503
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __is, _Setiosflags __f);
# 504
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __is, _Resetiosflags __f);
# 505
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __is, _Setbase __f);
# 506
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __is, _Setprecision __f);
# 507
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __is, _Setw __f);
# 510
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os, _Setfill< wchar_t>  __f);
# 511
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os, _Setiosflags __f);
# 512
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os, _Resetiosflags __f);
# 513
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os, _Setbase __f);
# 514
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os, _Setprecision __f);
# 515
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os, _Setw __f);
# 516
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __is, _Setfill< wchar_t>  __f);
# 517
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __is, _Setiosflags __f);
# 518
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __is, _Resetiosflags __f);
# 519
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __is, _Setbase __f);
# 520
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __is, _Setprecision __f);
# 521
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __is, _Setw __f);
# 526
}
# 34 "/usr/include/c++/5/bits/hashtable_policy.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 38
template< class _Key, class _Value, class _Alloc, class 
# 39
_ExtractKey, class _Equal, class 
# 40
_H1, class _H2, class _Hash, class 
# 41
_RehashPolicy, class _Traits> class _Hashtable; 
# 46
namespace __detail { 
# 55
template< class _Key, class _Value, class 
# 56
_ExtractKey, class _Equal, class 
# 57
_H1, class _H2, class _Hash, class _Traits> struct _Hashtable_base; 
# 62
template< class _Iterator> inline typename iterator_traits< _Iterator> ::difference_type 
# 64
__distance_fw(_Iterator __first, _Iterator __last, input_iterator_tag) 
# 66
{ return 0; } 
# 68
template< class _Iterator> inline typename iterator_traits< _Iterator> ::difference_type 
# 70
__distance_fw(_Iterator __first, _Iterator __last, forward_iterator_tag) 
# 72
{ return std::distance(__first, __last); } 
# 74
template< class _Iterator> inline typename iterator_traits< _Iterator> ::difference_type 
# 76
__distance_fw(_Iterator __first, _Iterator __last) 
# 77
{ 
# 78
typedef typename iterator_traits< _Iterator> ::iterator_category _Tag; 
# 79
return __distance_fw(__first, __last, _Tag()); 
# 80
} 
# 83
template< class _Key, class _Hash> 
# 84
struct __is_noexcept_hash : public __bool_constant< noexcept(declval< const _Hash &> ()(declval< const _Key &> ()))>  { 
# 86
}; 
# 88
struct _Identity { 
# 90
template< class _Tp> _Tp &&
# 92
operator()(_Tp &&__x) const 
# 93
{ return std::forward< _Tp> (__x); } 
# 94
}; 
# 96
struct _Select1st { 
# 98
template< class _Tp> auto 
# 100
operator()(_Tp &&__x) const->__decltype((std::get< 0> (std::forward< _Tp> (__x)))) 
# 102
{ return std::get< 0> (std::forward< _Tp> (__x)); } 
# 103
}; 
# 105
template< class _NodeAlloc> struct _Hashtable_alloc; 
# 110
template< class _NodeAlloc> 
# 111
struct _ReuseOrAllocNode { 
# 114
private: using __node_alloc_type = _NodeAlloc; 
# 115
using __hashtable_alloc = _Hashtable_alloc< _NodeAlloc> ; 
# 116
using __value_alloc_type = typename _Hashtable_alloc< _NodeAlloc> ::__value_alloc_type; 
# 117
using __value_alloc_traits = typename _Hashtable_alloc< _NodeAlloc> ::__value_alloc_traits; 
# 119
using __node_alloc_traits = typename _Hashtable_alloc< _NodeAlloc> ::__node_alloc_traits; 
# 121
using __node_type = typename _Hashtable_alloc< _NodeAlloc> ::__node_type; 
# 124
public: _ReuseOrAllocNode(__node_type *__nodes, __hashtable_alloc &__h) : _M_nodes(__nodes), _M_h(__h) 
# 125
{ } 
# 126
_ReuseOrAllocNode(const _ReuseOrAllocNode &) = delete;
# 128
~_ReuseOrAllocNode() 
# 129
{ ((_M_h)._M_deallocate_nodes(_M_nodes)); } 
# 131
template< class _Arg> __node_type *
# 133
operator()(_Arg &&__arg) const 
# 134
{ 
# 135
if (_M_nodes) 
# 136
{ 
# 137
__node_type *__node = _M_nodes; 
# 138
(_M_nodes) = ((_M_nodes)->_M_next()); 
# 139
(__node->_M_nxt) = nullptr; 
# 140
__value_alloc_type __a(((_M_h)._M_node_allocator())); 
# 141
__value_alloc_traits::destroy(__a, (__node->_M_valptr())); 
# 142
try 
# 143
{ 
# 144
__value_alloc_traits::construct(__a, (__node->_M_valptr()), std::forward< _Arg> (__arg)); 
# 146
} 
# 147
catch (...) 
# 148
{ 
# 149
(__node->~__node_type()); 
# 150
__node_alloc_traits::deallocate(((_M_h)._M_node_allocator()), __node, 1); 
# 152
throw; 
# 153
}  
# 154
return __node; 
# 155
}  
# 156
return ((_M_h)._M_allocate_node(std::forward< _Arg> (__arg))); 
# 157
} 
# 160
private: mutable __node_type *_M_nodes; 
# 161
__hashtable_alloc &_M_h; 
# 162
}; 
# 166
template< class _NodeAlloc> 
# 167
struct _AllocNode { 
# 170
private: using __hashtable_alloc = _Hashtable_alloc< _NodeAlloc> ; 
# 171
using __node_type = typename _Hashtable_alloc< _NodeAlloc> ::__node_type; 
# 174
public: _AllocNode(__hashtable_alloc &__h) : _M_h(__h) 
# 175
{ } 
# 177
template< class _Arg> __node_type *
# 179
operator()(_Arg &&__arg) const 
# 180
{ return ((_M_h)._M_allocate_node(std::forward< _Arg> (__arg))); } 
# 183
private: __hashtable_alloc &_M_h; 
# 184
}; 
# 211 "/usr/include/c++/5/bits/hashtable_policy.h" 3
template< bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys> 
# 212
struct _Hashtable_traits { 
# 214
using __hash_cached = __bool_constant< _Cache_hash_code> ; 
# 215
using __constant_iterators = __bool_constant< _Constant_iterators> ; 
# 216
using __unique_keys = __bool_constant< _Unique_keys> ; 
# 217
}; 
# 227 "/usr/include/c++/5/bits/hashtable_policy.h" 3
struct _Hash_node_base { 
# 229
_Hash_node_base *_M_nxt; 
# 231
_Hash_node_base() noexcept : _M_nxt() { } 
# 233
_Hash_node_base(_Hash_node_base *__next) noexcept : _M_nxt(__next) { } 
# 234
}; 
# 241
template< class _Value> 
# 242
struct _Hash_node_value_base : public _Hash_node_base { 
# 244
typedef _Value value_type; 
# 246
__gnu_cxx::__aligned_buffer< _Value>  _M_storage; 
# 249
_Value *_M_valptr() noexcept 
# 250
{ return ((_M_storage)._M_ptr()); } 
# 253
const _Value *_M_valptr() const noexcept 
# 254
{ return ((_M_storage)._M_ptr()); } 
# 257
_Value &_M_v() noexcept 
# 258
{ return *this->_M_valptr(); } 
# 261
const _Value &_M_v() const noexcept 
# 262
{ return *this->_M_valptr(); } 
# 263
}; 
# 268
template< class _Value, bool _Cache_hash_code> struct _Hash_node; 
# 276
template< class _Value> 
# 277
struct _Hash_node< _Value, true>  : public _Hash_node_value_base< _Value>  { 
# 279
::std::size_t _M_hash_code; 
# 282
::std::__detail::_Hash_node< _Value, true>  *_M_next() const noexcept 
# 283
{ return static_cast< ::std::__detail::_Hash_node< _Value, true>  *>(this->_M_nxt); } 
# 284
}; 
# 291
template< class _Value> 
# 292
struct _Hash_node< _Value, false>  : public _Hash_node_value_base< _Value>  { 
# 295
::std::__detail::_Hash_node< _Value, false>  *_M_next() const noexcept 
# 296
{ return static_cast< ::std::__detail::_Hash_node< _Value, false>  *>(this->_M_nxt); } 
# 297
}; 
# 300
template< class _Value, bool _Cache_hash_code> 
# 301
struct _Node_iterator_base { 
# 303
using __node_type = _Hash_node< _Value, _Cache_hash_code> ; 
# 305
__node_type *_M_cur; 
# 307
_Node_iterator_base(__node_type *__p) noexcept : _M_cur(__p) 
# 308
{ } 
# 311
void _M_incr() noexcept 
# 312
{ (_M_cur) = ((_M_cur)->_M_next()); } 
# 313
}; 
# 315
template< class _Value, bool _Cache_hash_code> inline bool 
# 317
operator==(const _Node_iterator_base< _Value, _Cache_hash_code>  &__x, const _Node_iterator_base< _Value, _Cache_hash_code>  &
# 318
__y) noexcept 
# 320
{ return (__x._M_cur) == (__y._M_cur); } 
# 322
template< class _Value, bool _Cache_hash_code> inline bool 
# 324
operator!=(const _Node_iterator_base< _Value, _Cache_hash_code>  &__x, const _Node_iterator_base< _Value, _Cache_hash_code>  &
# 325
__y) noexcept 
# 327
{ return (__x._M_cur) != (__y._M_cur); } 
# 330
template< class _Value, bool __constant_iterators, bool __cache> 
# 331
struct _Node_iterator : public _Node_iterator_base< _Value, __cache>  { 
# 335
private: using __base_type = ::std::__detail::_Node_iterator_base< _Value, __cache> ; 
# 336
using __node_type = typename ::std::__detail::_Node_iterator_base< _Value, __cache> ::__node_type; 
# 339
public: typedef _Value value_type; 
# 340
typedef ::std::ptrdiff_t difference_type; 
# 341
typedef ::std::forward_iterator_tag iterator_category; 
# 343
using pointer = typename conditional< __constant_iterators, const _Value *, _Value *> ::type; 
# 346
using reference = typename conditional< __constant_iterators, const _Value &, _Value &> ::type; 
# 349
_Node_iterator() noexcept : __base_type(0) 
# 350
{ } 
# 353
explicit _Node_iterator(__node_type *__p) noexcept : __base_type(__p) 
# 354
{ } 
# 357
reference operator*() const noexcept 
# 358
{ return ((this->_M_cur)->_M_v()); } 
# 361
pointer operator->() const noexcept 
# 362
{ return ((this->_M_cur)->_M_valptr()); } 
# 365
_Node_iterator &operator++() noexcept 
# 366
{ 
# 367
(this->_M_incr()); 
# 368
return *this; 
# 369
} 
# 372
_Node_iterator operator++(int) noexcept 
# 373
{ 
# 374
_Node_iterator __tmp(*this); 
# 375
(this->_M_incr()); 
# 376
return __tmp; 
# 377
} 
# 378
}; 
# 381
template< class _Value, bool __constant_iterators, bool __cache> 
# 382
struct _Node_const_iterator : public _Node_iterator_base< _Value, __cache>  { 
# 386
private: using __base_type = ::std::__detail::_Node_iterator_base< _Value, __cache> ; 
# 387
using __node_type = typename ::std::__detail::_Node_iterator_base< _Value, __cache> ::__node_type; 
# 390
public: typedef _Value value_type; 
# 391
typedef ::std::ptrdiff_t difference_type; 
# 392
typedef ::std::forward_iterator_tag iterator_category; 
# 394
typedef const _Value *pointer; 
# 395
typedef const _Value &reference; 
# 397
_Node_const_iterator() noexcept : __base_type(0) 
# 398
{ } 
# 401
explicit _Node_const_iterator(__node_type *__p) noexcept : __base_type(__p) 
# 402
{ } 
# 404
_Node_const_iterator(const _Node_iterator< _Value, __constant_iterators, __cache>  &
# 405
__x) noexcept : __base_type((__x._M_cur)) 
# 406
{ } 
# 409
reference operator*() const noexcept 
# 410
{ return ((this->_M_cur)->_M_v()); } 
# 413
pointer operator->() const noexcept 
# 414
{ return ((this->_M_cur)->_M_valptr()); } 
# 417
_Node_const_iterator &operator++() noexcept 
# 418
{ 
# 419
(this->_M_incr()); 
# 420
return *this; 
# 421
} 
# 424
_Node_const_iterator operator++(int) noexcept 
# 425
{ 
# 426
_Node_const_iterator __tmp(*this); 
# 427
(this->_M_incr()); 
# 428
return __tmp; 
# 429
} 
# 430
}; 
# 437
struct _Mod_range_hashing { 
# 439
typedef size_t first_argument_type; 
# 440
typedef size_t second_argument_type; 
# 441
typedef size_t result_type; 
# 444
result_type operator()(first_argument_type __num, second_argument_type 
# 445
__den) const noexcept 
# 446
{ return __num % __den; } 
# 447
}; 
# 454
struct _Default_ranged_hash { }; 
# 458
struct _Prime_rehash_policy { 
# 460
_Prime_rehash_policy(float __z = (1.0)) noexcept : _M_max_load_factor(__z), _M_next_resize((0)) 
# 461
{ } 
# 464
float max_load_factor() const noexcept 
# 465
{ return _M_max_load_factor; } 
# 469
size_t _M_next_bkt(size_t __n) const; 
# 473
size_t _M_bkt_for_elements(size_t __n) const 
# 474
{ return __builtin_ceil(__n / ((long double)(_M_max_load_factor))); } 
# 481
pair< bool, unsigned long>  _M_need_rehash(size_t __n_bkt, size_t __n_elt, size_t __n_ins) const; 
# 484
typedef size_t _State; 
# 487
_State _M_state() const 
# 488
{ return _M_next_resize; } 
# 491
void _M_reset() noexcept 
# 492
{ (_M_next_resize) = (0); } 
# 495
void _M_reset(_State __state) 
# 496
{ (_M_next_resize) = __state; } 
# 498
enum { _S_n_primes = 304}; 
# 500
static const size_t _S_growth_factor = (2); 
# 502
float _M_max_load_factor; 
# 503
mutable size_t _M_next_resize; 
# 504
}; 
# 524 "/usr/include/c++/5/bits/hashtable_policy.h" 3
template< class _Key, class _Value, class _Alloc, class 
# 525
_ExtractKey, class _Equal, class 
# 526
_H1, class _H2, class _Hash, class 
# 527
_RehashPolicy, class _Traits, bool 
# 528
_Unique_keys = _Traits::__unique_keys::value> 
# 529
struct _Map_base { }; 
# 532
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 533
_H1, class _H2, class _Hash, class 
# 534
_RehashPolicy, class _Traits> 
# 535
struct _Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false>  { 
# 538
using mapped_type = typename tuple_element< 1UL, _Pair> ::type; 
# 539
}; 
# 542
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 543
_H1, class _H2, class _Hash, class 
# 544
_RehashPolicy, class _Traits> 
# 545
struct _Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>  { 
# 549
private: using __hashtable_base = _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ; 
# 554
using __hashtable = _Hashtable< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 558
using __hash_code = typename _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ::__hash_code; 
# 559
using __node_type = typename _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ::__node_type; 
# 562
public: using key_type = typename _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ::key_type; 
# 563
using iterator = typename _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ::iterator; 
# 564
using mapped_type = typename tuple_element< 1UL, _Pair> ::type; 
# 567
mapped_type &operator[](const key_type & __k); 
# 570
mapped_type &operator[](key_type && __k); 
# 575
mapped_type &at(const key_type & __k); 
# 578
const mapped_type &at(const key_type & __k) const; 
# 579
}; 
# 581
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 582
_H1, class _H2, class _Hash, class 
# 583
_RehashPolicy, class _Traits> auto 
# 587
_Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> ::operator[](const key_type &__k)->mapped_type & 
# 589
{ 
# 590
__hashtable *__h = static_cast< __hashtable *>(this); 
# 591
__hash_code __code = (__h->_M_hash_code(__k)); 
# 592
size_t __n = (__h->_M_bucket_index(__k, __code)); 
# 593
__node_type *__p = (__h->_M_find_node(__n, __k, __code)); 
# 595
if (!__p) 
# 596
{ 
# 597
__p = (__h->_M_allocate_node(std::piecewise_construct, ((tuple< const typename _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ::key_type &> )(__k)), tuple< > ())); 
# 600
return (__h->_M_insert_unique_node(__n, __code, __p))->second; 
# 601
}  
# 603
return (__p->_M_v()).second; 
# 604
} 
# 606
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 607
_H1, class _H2, class _Hash, class 
# 608
_RehashPolicy, class _Traits> auto 
# 612
_Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> ::operator[](key_type &&__k)->mapped_type & 
# 614
{ 
# 615
__hashtable *__h = static_cast< __hashtable *>(this); 
# 616
__hash_code __code = (__h->_M_hash_code(__k)); 
# 617
size_t __n = (__h->_M_bucket_index(__k, __code)); 
# 618
__node_type *__p = (__h->_M_find_node(__n, __k, __code)); 
# 620
if (!__p) 
# 621
{ 
# 622
__p = (__h->_M_allocate_node(std::piecewise_construct, std::forward_as_tuple(std::move(__k)), tuple< > ())); 
# 625
return (__h->_M_insert_unique_node(__n, __code, __p))->second; 
# 626
}  
# 628
return (__p->_M_v()).second; 
# 629
} 
# 631
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 632
_H1, class _H2, class _Hash, class 
# 633
_RehashPolicy, class _Traits> auto 
# 637
_Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> ::at(const key_type &__k)->mapped_type & 
# 639
{ 
# 640
__hashtable *__h = static_cast< __hashtable *>(this); 
# 641
__hash_code __code = (__h->_M_hash_code(__k)); 
# 642
size_t __n = (__h->_M_bucket_index(__k, __code)); 
# 643
__node_type *__p = (__h->_M_find_node(__n, __k, __code)); 
# 645
if (!__p) { 
# 646
__throw_out_of_range("_Map_base::at"); }  
# 647
return (__p->_M_v()).second; 
# 648
} 
# 650
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 651
_H1, class _H2, class _Hash, class 
# 652
_RehashPolicy, class _Traits> auto 
# 656
_Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> ::at(const key_type &__k) const->const mapped_type & 
# 658
{ 
# 659
const __hashtable *__h = static_cast< const __hashtable *>(this); 
# 660
__hash_code __code = (__h->_M_hash_code(__k)); 
# 661
size_t __n = (__h->_M_bucket_index(__k, __code)); 
# 662
__node_type *__p = (__h->_M_find_node(__n, __k, __code)); 
# 664
if (!__p) { 
# 665
__throw_out_of_range("_Map_base::at"); }  
# 666
return (__p->_M_v()).second; 
# 667
} 
# 674
template< class _Key, class _Value, class _Alloc, class 
# 675
_ExtractKey, class _Equal, class 
# 676
_H1, class _H2, class _Hash, class 
# 677
_RehashPolicy, class _Traits> 
# 678
struct _Insert_base { 
# 681
protected: using __hashtable = _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 685
using __hashtable_base = _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ; 
# 689
using value_type = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::value_type; 
# 690
using iterator = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator; 
# 691
using const_iterator = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::const_iterator; 
# 692
using size_type = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::size_type; 
# 694
using __unique_keys = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__unique_keys; 
# 695
using __ireturn_type = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__ireturn_type; 
# 696
using __node_type = _Hash_node< _Value, _Traits::__hash_cached::value> ; 
# 697
using __node_alloc_type = __alloc_rebind< _Alloc, _Hash_node< _Value, _Traits::__hash_cached::value> > ; 
# 698
using __node_gen_type = _AllocNode< __alloc_rebind< _Alloc, _Hash_node< _Value, _Traits::__hash_cached::value> > > ; 
# 701
__hashtable &_M_conjure_hashtable() 
# 702
{ return *(static_cast< __hashtable *>(this)); } 
# 704
template< class _InputIterator, class _NodeGetter> void _M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &); 
# 711
public: __ireturn_type insert(const value_type &__v) 
# 712
{ 
# 713
__hashtable &__h = _M_conjure_hashtable(); 
# 714
__node_gen_type __node_gen(__h); 
# 715
return (__h._M_insert(__v, __node_gen, __unique_keys())); 
# 716
} 
# 719
iterator insert(const_iterator __hint, const value_type &__v) 
# 720
{ 
# 721
__hashtable &__h = _M_conjure_hashtable(); 
# 722
__node_gen_type __node_gen(__h); 
# 723
return (__h._M_insert(__hint, __v, __node_gen, __unique_keys())); 
# 724
} 
# 727
void insert(initializer_list< typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::value_type>  __l) 
# 728
{ (this->insert((__l.begin()), (__l.end()))); } 
# 730
template< class _InputIterator> void 
# 732
insert(_InputIterator __first, _InputIterator __last) 
# 733
{ 
# 734
__hashtable &__h = _M_conjure_hashtable(); 
# 735
__node_gen_type __node_gen(__h); 
# 736
return _M_insert_range(__first, __last, __node_gen); 
# 737
} 
# 738
}; 
# 740
template< class _Key, class _Value, class _Alloc, class 
# 741
_ExtractKey, class _Equal, class 
# 742
_H1, class _H2, class _Hash, class 
# 743
_RehashPolicy, class _Traits> 
# 744
template< class _InputIterator, class _NodeGetter> void 
# 748
_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &
# 749
__node_gen) 
# 750
{ 
# 751
using __rehash_type = typename _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__rehash_type; 
# 752
using __rehash_state = typename _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__rehash_state; 
# 753
using pair_type = pair< bool, unsigned long> ; 
# 755
size_type __n_elt = __detail::__distance_fw(__first, __last); 
# 757
__hashtable &__h = _M_conjure_hashtable(); 
# 758
__rehash_type &__rehash = ((__h._M_rehash_policy)); 
# 759
const __rehash_state &__saved_state = (__rehash._M_state()); 
# 760
pair_type __do_rehash = (__rehash._M_need_rehash((__h._M_bucket_count), (__h._M_element_count), __n_elt)); 
# 764
if (__do_rehash.first) { 
# 765
(__h._M_rehash(__do_rehash.second, __saved_state)); }  
# 767
for (; __first != __last; ++__first) { 
# 768
(__h._M_insert(*__first, __node_gen, __unique_keys())); }  
# 769
} 
# 776
template< class _Key, class _Value, class _Alloc, class 
# 777
_ExtractKey, class _Equal, class 
# 778
_H1, class _H2, class _Hash, class 
# 779
_RehashPolicy, class _Traits, bool 
# 780
_Constant_iterators = _Traits::__constant_iterators::value, bool 
# 781
_Unique_keys = _Traits::__unique_keys::value> struct _Insert; 
# 785
template< class _Key, class _Value, class _Alloc, class 
# 786
_ExtractKey, class _Equal, class 
# 787
_H1, class _H2, class _Hash, class 
# 788
_RehashPolicy, class _Traits> 
# 789
struct _Insert< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true, true>  : public _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>  { 
# 794
using __base_type = ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 797
using value_type = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::value_type; 
# 798
using iterator = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::iterator; 
# 799
using const_iterator = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::const_iterator; 
# 801
using __unique_keys = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__unique_keys; 
# 802
using __hashtable = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__hashtable; 
# 803
using __node_gen_type = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__node_gen_type; 
# 805
using ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::insert;
# 808
pair< typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::iterator, bool>  insert(value_type &&__v) 
# 809
{ 
# 810
__hashtable &__h = (this->_M_conjure_hashtable()); 
# 811
__node_gen_type __node_gen(__h); 
# 812
return (__h._M_insert(::std::move(__v), __node_gen, __unique_keys())); 
# 813
} 
# 816
iterator insert(const_iterator __hint, value_type &&__v) 
# 817
{ 
# 818
__hashtable &__h = (this->_M_conjure_hashtable()); 
# 819
__node_gen_type __node_gen(__h); 
# 820
return (__h._M_insert(__hint, ::std::move(__v), __node_gen, __unique_keys())); 
# 822
} 
# 823
}; 
# 826
template< class _Key, class _Value, class _Alloc, class 
# 827
_ExtractKey, class _Equal, class 
# 828
_H1, class _H2, class _Hash, class 
# 829
_RehashPolicy, class _Traits> 
# 830
struct _Insert< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true, false>  : public _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>  { 
# 835
using __base_type = ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 838
using value_type = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::value_type; 
# 839
using iterator = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::iterator; 
# 840
using const_iterator = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::const_iterator; 
# 842
using __unique_keys = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__unique_keys; 
# 843
using __hashtable = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__hashtable; 
# 844
using __node_gen_type = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__node_gen_type; 
# 846
using ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::insert;
# 849
iterator insert(value_type &&__v) 
# 850
{ 
# 851
__hashtable &__h = (this->_M_conjure_hashtable()); 
# 852
__node_gen_type __node_gen(__h); 
# 853
return (__h._M_insert(::std::move(__v), __node_gen, __unique_keys())); 
# 854
} 
# 857
iterator insert(const_iterator __hint, value_type &&__v) 
# 858
{ 
# 859
__hashtable &__h = (this->_M_conjure_hashtable()); 
# 860
__node_gen_type __node_gen(__h); 
# 861
return (__h._M_insert(__hint, ::std::move(__v), __node_gen, __unique_keys())); 
# 863
} 
# 864
}; 
# 867
template< class _Key, class _Value, class _Alloc, class 
# 868
_ExtractKey, class _Equal, class 
# 869
_H1, class _H2, class _Hash, class 
# 870
_RehashPolicy, class _Traits, bool _Unique_keys> 
# 871
struct _Insert< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false, _Unique_keys>  : public _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>  { 
# 876
using __base_type = ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 879
using value_type = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::value_type; 
# 880
using iterator = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::iterator; 
# 881
using const_iterator = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::const_iterator; 
# 883
using __unique_keys = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__unique_keys; 
# 884
using __hashtable = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__hashtable; 
# 885
using __ireturn_type = typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__ireturn_type; 
# 887
using ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::insert;
# 889
template< class _Pair> using __is_cons = is_constructible< typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::value_type, _Pair &&> ; 
# 892
template< class _Pair> using _IFcons = enable_if< is_constructible< typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::value_type, _Pair &&> ::value> ; 
# 895
template< class _Pair> using _IFconsp = typename enable_if< is_constructible< typename ::std::__detail::_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::value_type, _Pair &&> ::value> ::type; 
# 898
template< class _Pair, class  = _IFconsp< _Pair> > __ireturn_type 
# 900
insert(_Pair &&__v) 
# 901
{ 
# 902
__hashtable &__h = (this->_M_conjure_hashtable()); 
# 903
return (__h._M_emplace(__unique_keys(), ::std::forward< _Pair> (__v))); 
# 904
} 
# 906
template< class _Pair, class  = _IFconsp< _Pair> > iterator 
# 908
insert(const_iterator __hint, _Pair &&__v) 
# 909
{ 
# 910
__hashtable &__h = (this->_M_conjure_hashtable()); 
# 911
return (__h._M_emplace(__hint, __unique_keys(), ::std::forward< _Pair> (__v))); 
# 913
} 
# 914
}; 
# 922
template< class _Key, class _Value, class _Alloc, class 
# 923
_ExtractKey, class _Equal, class 
# 924
_H1, class _H2, class _Hash, class 
# 925
_RehashPolicy, class _Traits> struct _Rehash_base; 
# 929
template< class _Key, class _Value, class _Alloc, class 
# 930
_ExtractKey, class _Equal, class 
# 931
_H1, class _H2, class _Hash, class _Traits> 
# 932
struct _Rehash_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _Prime_rehash_policy, _Traits>  { 
# 935
using __hashtable = _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _Prime_rehash_policy, _Traits> ; 
# 940
float max_load_factor() const noexcept 
# 941
{ 
# 942
const __hashtable *__this = static_cast< const __hashtable *>(this); 
# 943
return ((__this->__rehash_policy()).max_load_factor()); 
# 944
} 
# 947
void max_load_factor(float __z) 
# 948
{ 
# 949
__hashtable *__this = static_cast< __hashtable *>(this); 
# 950
(__this->__rehash_policy(((_Prime_rehash_policy)(__z)))); 
# 951
} 
# 954
void reserve(size_t __n) 
# 955
{ 
# 956
__hashtable *__this = static_cast< __hashtable *>(this); 
# 957
(__this->rehash(__builtin_ceil(__n / this->max_load_factor()))); 
# 958
} 
# 959
}; 
# 967
template< int _Nm, class _Tp, bool 
# 968
__use_ebo = (!__is_final(_Tp)) && __is_empty(_Tp)> struct _Hashtable_ebo_helper; 
# 972
template< int _Nm, class _Tp> 
# 973
struct _Hashtable_ebo_helper< _Nm, _Tp, true>  : private _Tp { 
# 976
_Hashtable_ebo_helper() = default;
# 978
template< class _OtherTp> 
# 979
_Hashtable_ebo_helper(_OtherTp &&__tp) : _Tp(::std::forward< _OtherTp> (__tp)) 
# 981
{ } 
# 984
static const _Tp &_S_cget(const ::std::__detail::_Hashtable_ebo_helper< _Nm, _Tp, true>  &__eboh) 
# 985
{ return static_cast< const _Tp &>(__eboh); } 
# 988
static _Tp &_S_get(::std::__detail::_Hashtable_ebo_helper< _Nm, _Tp, true>  &__eboh) 
# 989
{ return static_cast< _Tp &>(__eboh); } 
# 990
}; 
# 993
template< int _Nm, class _Tp> 
# 994
struct _Hashtable_ebo_helper< _Nm, _Tp, false>  { 
# 996
_Hashtable_ebo_helper() = default;
# 998
template< class _OtherTp> 
# 999
_Hashtable_ebo_helper(_OtherTp &&__tp) : _M_tp(std::forward< _OtherTp> (__tp)) 
# 1001
{ } 
# 1004
static const _Tp &_S_cget(const __detail::_Hashtable_ebo_helper< _Nm, _Tp, false>  &__eboh) 
# 1005
{ return __eboh._M_tp; } 
# 1008
static _Tp &_S_get(__detail::_Hashtable_ebo_helper< _Nm, _Tp, false>  &__eboh) 
# 1009
{ return __eboh._M_tp; } 
# 1012
private: _Tp _M_tp; 
# 1013
}; 
# 1021
template< class _Key, class _Value, class _ExtractKey, class 
# 1022
_H1, class _H2, class _Hash, bool 
# 1023
__cache_hash_code> struct _Local_iterator_base; 
# 1046 "/usr/include/c++/5/bits/hashtable_policy.h" 3
template< class _Key, class _Value, class _ExtractKey, class 
# 1047
_H1, class _H2, class _Hash, bool 
# 1048
__cache_hash_code> struct _Hash_code_base; 
# 1053
template< class _Key, class _Value, class _ExtractKey, class 
# 1054
_H1, class _H2, class _Hash> 
# 1055
struct _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  : private _Hashtable_ebo_helper< 0, _ExtractKey> , private _Hashtable_ebo_helper< 1, _Hash>  { 
# 1060
private: using __ebo_extract_key = _Hashtable_ebo_helper< 0, _ExtractKey> ; 
# 1061
using __ebo_hash = _Hashtable_ebo_helper< 1, _Hash> ; 
# 1064
protected: typedef void *__hash_code; 
# 1065
typedef _Hash_node< _Value, false>  __node_type; 
# 1069
_Hash_code_base() = default;
# 1071
_Hash_code_base(const _ExtractKey &__ex, const _H1 &, const _H2 &, const _Hash &
# 1072
__h) : __ebo_extract_key(__ex), __ebo_hash(__h) 
# 1073
{ } 
# 1076
__hash_code _M_hash_code(const _Key &__key) const 
# 1077
{ return 0; } 
# 1080
::std::size_t _M_bucket_index(const _Key &__k, __hash_code, ::std::size_t __n) const 
# 1081
{ return this->_M_ranged_hash()(__k, __n); } 
# 1084
::std::size_t _M_bucket_index(const __node_type *__p, ::std::size_t __n) const noexcept(noexcept(declval< const _Hash &> ()(declval< const _Key &> (), (::std::size_t)0))) 
# 1087
{ return this->_M_ranged_hash()(this->_M_extract()((__p->_M_v())), __n); } 
# 1090
void _M_store_code(__node_type *, __hash_code) const 
# 1091
{ } 
# 1094
void _M_copy_code(__node_type *, const __node_type *) const 
# 1095
{ } 
# 1098
void _M_swap(::std::__detail::_Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  &__x) 
# 1099
{ 
# 1100
::std::swap(this->_M_extract(), (__x._M_extract())); 
# 1101
::std::swap(this->_M_ranged_hash(), (__x._M_ranged_hash())); 
# 1102
} 
# 1105
const _ExtractKey &_M_extract() const { return __ebo_extract_key::_S_cget(*this); } 
# 1108
_ExtractKey &_M_extract() { return __ebo_extract_key::_S_get(*this); } 
# 1111
const _Hash &_M_ranged_hash() const { return __ebo_hash::_S_cget(*this); } 
# 1114
_Hash &_M_ranged_hash() { return __ebo_hash::_S_get(*this); } 
# 1115
}; 
# 1123
template< class _Key, class _Value, class _ExtractKey, class 
# 1124
_H1, class _H2, class _Hash> struct _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, true> ; 
# 1130
template< class _Key, class _Value, class _ExtractKey, class 
# 1131
_H1, class _H2> 
# 1132
struct _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, false>  : private _Hashtable_ebo_helper< 0, _ExtractKey> , private _Hashtable_ebo_helper< 1, _H1> , private _Hashtable_ebo_helper< 2, _H2>  { 
# 1139
private: using __ebo_extract_key = _Hashtable_ebo_helper< 0, _ExtractKey> ; 
# 1140
using __ebo_h1 = _Hashtable_ebo_helper< 1, _H1> ; 
# 1141
using __ebo_h2 = _Hashtable_ebo_helper< 2, _H2> ; 
# 1144
friend struct _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, ::std::__detail::_Default_ranged_hash, false> ; 
# 1148
public: typedef _H1 hasher; 
# 1151
hasher hash_function() const 
# 1152
{ return this->_M_h1(); } 
# 1155
protected: typedef ::std::size_t __hash_code; 
# 1156
typedef _Hash_node< _Value, false>  __node_type; 
# 1160
_Hash_code_base() = default;
# 1162
_Hash_code_base(const _ExtractKey &__ex, const _H1 &
# 1163
__h1, const _H2 &__h2, const ::std::__detail::_Default_ranged_hash &) : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) 
# 1165
{ } 
# 1168
__hash_code _M_hash_code(const _Key &__k) const 
# 1169
{ return this->_M_h1()(__k); } 
# 1172
::std::size_t _M_bucket_index(const _Key &, __hash_code __c, ::std::size_t __n) const 
# 1173
{ return this->_M_h2()(__c, __n); } 
# 1176
::std::size_t _M_bucket_index(const __node_type *__p, ::std::size_t __n) const noexcept(noexcept(declval< const _H1 &> ()(declval< const _Key &> ())) && noexcept(declval< const _H2 &> ()((__hash_code)0, (::std::size_t)0))) 
# 1180
{ return this->_M_h2()(this->_M_h1()(this->_M_extract()((__p->_M_v()))), __n); } 
# 1183
void _M_store_code(__node_type *, __hash_code) const 
# 1184
{ } 
# 1187
void _M_copy_code(__node_type *, const __node_type *) const 
# 1188
{ } 
# 1191
void _M_swap(::std::__detail::_Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, ::std::__detail::_Default_ranged_hash, false>  &__x) 
# 1192
{ 
# 1193
::std::swap(this->_M_extract(), (__x._M_extract())); 
# 1194
::std::swap(this->_M_h1(), (__x._M_h1())); 
# 1195
::std::swap(this->_M_h2(), (__x._M_h2())); 
# 1196
} 
# 1199
const _ExtractKey &_M_extract() const { return __ebo_extract_key::_S_cget(*this); } 
# 1202
_ExtractKey &_M_extract() { return __ebo_extract_key::_S_get(*this); } 
# 1205
const _H1 &_M_h1() const { return __ebo_h1::_S_cget(*this); } 
# 1208
_H1 &_M_h1() { return __ebo_h1::_S_get(*this); } 
# 1211
const _H2 &_M_h2() const { return __ebo_h2::_S_cget(*this); } 
# 1214
_H2 &_M_h2() { return __ebo_h2::_S_get(*this); } 
# 1215
}; 
# 1220
template< class _Key, class _Value, class _ExtractKey, class 
# 1221
_H1, class _H2> 
# 1222
struct _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, true>  : private _Hashtable_ebo_helper< 0, _ExtractKey> , private _Hashtable_ebo_helper< 1, _H1> , private _Hashtable_ebo_helper< 2, _H2>  { 
# 1230
friend struct _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, ::std::__detail::_Default_ranged_hash, true> ; 
# 1233
private: using __ebo_extract_key = _Hashtable_ebo_helper< 0, _ExtractKey> ; 
# 1234
using __ebo_h1 = _Hashtable_ebo_helper< 1, _H1> ; 
# 1235
using __ebo_h2 = _Hashtable_ebo_helper< 2, _H2> ; 
# 1238
public: typedef _H1 hasher; 
# 1241
hasher hash_function() const 
# 1242
{ return this->_M_h1(); } 
# 1245
protected: typedef ::std::size_t __hash_code; 
# 1246
typedef _Hash_node< _Value, true>  __node_type; 
# 1249
_Hash_code_base() = default;
# 1250
_Hash_code_base(const _ExtractKey &__ex, const _H1 &
# 1251
__h1, const _H2 &__h2, const ::std::__detail::_Default_ranged_hash &) : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) 
# 1253
{ } 
# 1256
__hash_code _M_hash_code(const _Key &__k) const 
# 1257
{ return this->_M_h1()(__k); } 
# 1260
::std::size_t _M_bucket_index(const _Key &, __hash_code __c, ::std::size_t 
# 1261
__n) const 
# 1262
{ return this->_M_h2()(__c, __n); } 
# 1265
::std::size_t _M_bucket_index(const __node_type *__p, ::std::size_t __n) const noexcept(noexcept(declval< const _H2 &> ()((__hash_code)0, (::std::size_t)0))) 
# 1268
{ return this->_M_h2()((__p->_M_hash_code), __n); } 
# 1271
void _M_store_code(__node_type *__n, __hash_code __c) const 
# 1272
{ (__n->_M_hash_code) = __c; } 
# 1275
void _M_copy_code(__node_type *__to, const __node_type *__from) const 
# 1276
{ (__to->_M_hash_code) = (__from->_M_hash_code); } 
# 1279
void _M_swap(::std::__detail::_Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, ::std::__detail::_Default_ranged_hash, true>  &__x) 
# 1280
{ 
# 1281
::std::swap(this->_M_extract(), (__x._M_extract())); 
# 1282
::std::swap(this->_M_h1(), (__x._M_h1())); 
# 1283
::std::swap(this->_M_h2(), (__x._M_h2())); 
# 1284
} 
# 1287
const _ExtractKey &_M_extract() const { return __ebo_extract_key::_S_cget(*this); } 
# 1290
_ExtractKey &_M_extract() { return __ebo_extract_key::_S_get(*this); } 
# 1293
const _H1 &_M_h1() const { return __ebo_h1::_S_cget(*this); } 
# 1296
_H1 &_M_h1() { return __ebo_h1::_S_get(*this); } 
# 1299
const _H2 &_M_h2() const { return __ebo_h2::_S_cget(*this); } 
# 1302
_H2 &_M_h2() { return __ebo_h2::_S_get(*this); } 
# 1303
}; 
# 1309
template< class _Key, class _Value, class _ExtractKey, class 
# 1310
_Equal, class _HashCodeType, bool 
# 1311
__cache_hash_code> struct _Equal_helper; 
# 1315
template< class _Key, class _Value, class _ExtractKey, class 
# 1316
_Equal, class _HashCodeType> 
# 1317
struct _Equal_helper< _Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>  { 
# 1320
static bool _S_equals(const _Equal &__eq, const _ExtractKey &__extract, const _Key &
# 1321
__k, _HashCodeType __c, _Hash_node< _Value, true>  *__n) 
# 1322
{ return (__c == (__n->_M_hash_code)) && __eq(__k, __extract((__n->_M_v()))); } 
# 1323
}; 
# 1326
template< class _Key, class _Value, class _ExtractKey, class 
# 1327
_Equal, class _HashCodeType> 
# 1328
struct _Equal_helper< _Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>  { 
# 1331
static bool _S_equals(const _Equal &__eq, const _ExtractKey &__extract, const _Key &
# 1332
__k, _HashCodeType, _Hash_node< _Value, false>  *__n) 
# 1333
{ return __eq(__k, __extract((__n->_M_v()))); } 
# 1334
}; 
# 1338
template< class _Key, class _Value, class _ExtractKey, class 
# 1339
_H1, class _H2, class _Hash> 
# 1340
struct _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>  : private _Hashtable_ebo_helper< 0, _H2>  { 
# 1345
protected: using __base_type = _Hashtable_ebo_helper< 0, _H2> ; 
# 1346
using __hash_code_base = _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, true> ; 
# 1349
_Local_iterator_base() = default;
# 1350
_Local_iterator_base(const __hash_code_base &__base, _Hash_node< _Value, true>  *
# 1351
__p, ::std::size_t 
# 1352
__bkt, ::std::size_t __bkt_count) : __base_type((__base._M_h2())), _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) 
# 1354
{ } 
# 1357
void _M_incr() 
# 1358
{ 
# 1359
(_M_cur) = ((_M_cur)->_M_next()); 
# 1360
if (_M_cur) 
# 1361
{ 
# 1362
::std::size_t __bkt = __base_type::_S_get(*this)(((_M_cur)->_M_hash_code), _M_bucket_count); 
# 1365
if (__bkt != (_M_bucket)) { 
# 1366
(_M_cur) = nullptr; }  
# 1367
}  
# 1368
} 
# 1370
_Hash_node< _Value, true>  *_M_cur; 
# 1371
::std::size_t _M_bucket; 
# 1372
::std::size_t _M_bucket_count; 
# 1376
public: const void *_M_curr() const { return _M_cur; } 
# 1379
::std::size_t _M_get_bucket() const { return _M_bucket; } 
# 1380
}; 
# 1386
template< class _Tp, bool _IsEmpty = std::is_empty< _Tp> ::value> 
# 1387
struct _Hash_code_storage { 
# 1389
__gnu_cxx::__aligned_buffer< _Tp>  _M_storage; 
# 1392
_Tp *_M_h() { return ((_M_storage)._M_ptr()); } 
# 1395
const _Tp *_M_h() const { return ((_M_storage)._M_ptr()); } 
# 1396
}; 
# 1399
template< class _Tp> 
# 1400
struct _Hash_code_storage< _Tp, true>  { 
# 1402
static_assert((std::is_empty< _Tp> ::value), "Type must be empty");
# 1407
_Tp *_M_h() { return reinterpret_cast< _Tp *>(this); } 
# 1410
const _Tp *_M_h() const { return reinterpret_cast< const _Tp *>(this); } 
# 1411
}; 
# 1413
template< class _Key, class _Value, class _ExtractKey, class 
# 1414
_H1, class _H2, class _Hash> using __hash_code_for_local_iter = _Hash_code_storage< _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false> > ; 
# 1420
template< class _Key, class _Value, class _ExtractKey, class 
# 1421
_H1, class _H2, class _Hash> 
# 1422
struct _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  : public __hash_code_for_local_iter< _Key, _Value, _ExtractKey, _H1, _H2, _Hash>  { 
# 1427
protected: using __hash_code_base = _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false> ; 
# 1430
_Local_iterator_base() : _M_bucket_count((-1)) { } 
# 1432
_Local_iterator_base(const __hash_code_base &__base, _Hash_node< _Value, false>  *
# 1433
__p, ::std::size_t 
# 1434
__bkt, ::std::size_t __bkt_count) : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) 
# 1436
{ _M_init(__base); } 
# 1438
~_Local_iterator_base() 
# 1439
{ 
# 1440
if ((_M_bucket_count) != (-1)) { 
# 1441
_M_destroy(); }  
# 1442
} 
# 1444
_Local_iterator_base(const ::std::__detail::_Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  &__iter) : _M_cur(((__iter._M_cur))), _M_bucket(((__iter._M_bucket))), _M_bucket_count(((__iter._M_bucket_count))) 
# 1447
{ 
# 1448
if ((_M_bucket_count) != (-1)) { 
# 1449
_M_init(*(__iter._M_h())); }  
# 1450
} 
# 1453
::std::__detail::_Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  &operator=(const ::std::__detail::_Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  &__iter) 
# 1454
{ 
# 1455
if ((_M_bucket_count) != (-1)) { 
# 1456
_M_destroy(); }  
# 1457
(_M_cur) = (__iter._M_cur); 
# 1458
(_M_bucket) = (__iter._M_bucket); 
# 1459
(_M_bucket_count) = (__iter._M_bucket_count); 
# 1460
if ((_M_bucket_count) != (-1)) { 
# 1461
_M_init(*(__iter._M_h())); }  
# 1462
return *this; 
# 1463
} 
# 1466
void _M_incr() 
# 1467
{ 
# 1468
(_M_cur) = ((_M_cur)->_M_next()); 
# 1469
if (_M_cur) 
# 1470
{ 
# 1471
::std::size_t __bkt = ((this->_M_h())->_M_bucket_index(_M_cur, _M_bucket_count)); 
# 1473
if (__bkt != (_M_bucket)) { 
# 1474
(_M_cur) = nullptr; }  
# 1475
}  
# 1476
} 
# 1478
_Hash_node< _Value, false>  *_M_cur; 
# 1479
::std::size_t _M_bucket; 
# 1480
::std::size_t _M_bucket_count; 
# 1483
void _M_init(const __hash_code_base &__base) 
# 1484
{ ::new ((this->_M_h())) __hash_code_base(__base); } 
# 1487
void _M_destroy() { ((this->_M_h())->~__hash_code_base()); } 
# 1491
public: const void *_M_curr() const { return _M_cur; } 
# 1494
::std::size_t _M_get_bucket() const { return _M_bucket; } 
# 1495
}; 
# 1497
template< class _Key, class _Value, class _ExtractKey, class 
# 1498
_H1, class _H2, class _Hash, bool __cache> inline bool 
# 1500
operator==(const _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  &
# 1501
__x, const _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  &
# 1503
__y) 
# 1504
{ return (__x._M_curr()) == (__y._M_curr()); } 
# 1506
template< class _Key, class _Value, class _ExtractKey, class 
# 1507
_H1, class _H2, class _Hash, bool __cache> inline bool 
# 1509
operator!=(const _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  &
# 1510
__x, const _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  &
# 1512
__y) 
# 1513
{ return (__x._M_curr()) != (__y._M_curr()); } 
# 1516
template< class _Key, class _Value, class _ExtractKey, class 
# 1517
_H1, class _H2, class _Hash, bool 
# 1518
__constant_iterators, bool __cache> 
# 1519
struct _Local_iterator : public _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  { 
# 1524
private: using __base_type = _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> ; 
# 1526
using __hash_code_base = typename _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> ::__hash_code_base; 
# 1528
public: typedef _Value value_type; 
# 1531
typedef typename conditional< __constant_iterators, const _Value *, _Value *> ::type pointer; 
# 1534
typedef typename conditional< __constant_iterators, const _Value &, _Value &> ::type reference; 
# 1535
typedef ::std::ptrdiff_t difference_type; 
# 1536
typedef ::std::forward_iterator_tag iterator_category; 
# 1538
_Local_iterator() = default;
# 1540
_Local_iterator(const __hash_code_base &__base, _Hash_node< _Value, __cache>  *
# 1541
__p, ::std::size_t 
# 1542
__bkt, ::std::size_t __bkt_count) : __base_type(__base, __p, __bkt, __bkt_count) 
# 1544
{ } 
# 1547
reference operator*() const 
# 1548
{ return ((this->_M_cur)->_M_v()); } 
# 1551
pointer operator->() const 
# 1552
{ return ((this->_M_cur)->_M_valptr()); } 
# 1555
_Local_iterator &operator++() 
# 1556
{ 
# 1557
(this->_M_incr()); 
# 1558
return *this; 
# 1559
} 
# 1562
_Local_iterator operator++(int) 
# 1563
{ 
# 1564
_Local_iterator __tmp(*this); 
# 1565
(this->_M_incr()); 
# 1566
return __tmp; 
# 1567
} 
# 1568
}; 
# 1571
template< class _Key, class _Value, class _ExtractKey, class 
# 1572
_H1, class _H2, class _Hash, bool 
# 1573
__constant_iterators, bool __cache> 
# 1574
struct _Local_const_iterator : public _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  { 
# 1579
private: using __base_type = _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> ; 
# 1581
using __hash_code_base = typename _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> ::__hash_code_base; 
# 1584
public: typedef _Value value_type; 
# 1585
typedef const _Value *pointer; 
# 1586
typedef const _Value &reference; 
# 1587
typedef ::std::ptrdiff_t difference_type; 
# 1588
typedef ::std::forward_iterator_tag iterator_category; 
# 1590
_Local_const_iterator() = default;
# 1592
_Local_const_iterator(const __hash_code_base &__base, _Hash_node< _Value, __cache>  *
# 1593
__p, ::std::size_t 
# 1594
__bkt, ::std::size_t __bkt_count) : __base_type(__base, __p, __bkt, __bkt_count) 
# 1596
{ } 
# 1598
_Local_const_iterator(const _Local_iterator< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache>  &
# 1601
__x) : __base_type(__x) 
# 1603
{ } 
# 1606
reference operator*() const 
# 1607
{ return ((this->_M_cur)->_M_v()); } 
# 1610
pointer operator->() const 
# 1611
{ return ((this->_M_cur)->_M_valptr()); } 
# 1614
_Local_const_iterator &operator++() 
# 1615
{ 
# 1616
(this->_M_incr()); 
# 1617
return *this; 
# 1618
} 
# 1621
_Local_const_iterator operator++(int) 
# 1622
{ 
# 1623
_Local_const_iterator __tmp(*this); 
# 1624
(this->_M_incr()); 
# 1625
return __tmp; 
# 1626
} 
# 1627
}; 
# 1639 "/usr/include/c++/5/bits/hashtable_policy.h" 3
template< class _Key, class _Value, class 
# 1640
_ExtractKey, class _Equal, class 
# 1641
_H1, class _H2, class _Hash, class _Traits> 
# 1642
struct _Hashtable_base : public _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__hash_cached::value> , private _Hashtable_ebo_helper< 0, _Equal>  { 
# 1648
typedef _Key key_type; 
# 1649
typedef _Value value_type; 
# 1650
typedef _Equal key_equal; 
# 1651
typedef ::std::size_t size_type; 
# 1652
typedef ::std::ptrdiff_t difference_type; 
# 1654
using __traits_type = _Traits; 
# 1655
using __hash_cached = typename _Traits::__hash_cached; 
# 1656
using __constant_iterators = typename _Traits::__constant_iterators; 
# 1657
using __unique_keys = typename _Traits::__unique_keys; 
# 1659
using __hash_code_base = _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__hash_cached::value> ; 
# 1663
using __hash_code = typename _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__hash_cached::value> ::__hash_code; 
# 1664
using __node_type = typename _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__hash_cached::value> ::__node_type; 
# 1666
using iterator = _Node_iterator< _Value, _Traits::__constant_iterators::value, _Traits::__hash_cached::value> ; 
# 1670
using const_iterator = _Node_const_iterator< _Value, _Traits::__constant_iterators::value, _Traits::__hash_cached::value> ; 
# 1674
using local_iterator = _Local_iterator< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__constant_iterators::value, _Traits::__hash_cached::value> ; 
# 1679
using const_local_iterator = _Local_const_iterator< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__constant_iterators::value, _Traits::__hash_cached::value> ; 
# 1685
using __ireturn_type = typename conditional< _Traits::__unique_keys::value, pair< _Node_iterator< _Value, _Traits::__constant_iterators::value, _Traits::__hash_cached::value> , bool> , _Node_iterator< _Value, _Traits::__constant_iterators::value, _Traits::__hash_cached::value> > ::type; 
# 1689
private: using _EqualEBO = _Hashtable_ebo_helper< 0, _Equal> ; 
# 1690
using _EqualHelper = _Equal_helper< _Key, _Value, _ExtractKey, _Equal, typename _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__hash_cached::value> ::__hash_code, _Traits::__hash_cached::value> ; 
# 1694
protected: _Hashtable_base() = default;
# 1695
_Hashtable_base(const _ExtractKey &__ex, const _H1 &__h1, const _H2 &__h2, const _Hash &
# 1696
__hash, const _Equal &__eq) : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq) 
# 1698
{ } 
# 1701
bool _M_equals(const _Key &__k, __hash_code __c, __node_type *__n) const 
# 1702
{ 
# 1703
return _EqualHelper::_S_equals(this->_M_eq(), (this->_M_extract()), __k, __c, __n); 
# 1705
} 
# 1708
void _M_swap(_Hashtable_base &__x) 
# 1709
{ 
# 1710
__hash_code_base::_M_swap(__x); 
# 1711
::std::swap(this->_M_eq(), (__x._M_eq())); 
# 1712
} 
# 1715
const _Equal &_M_eq() const { return _EqualEBO::_S_cget(*this); } 
# 1718
_Equal &_M_eq() { return _EqualEBO::_S_get(*this); } 
# 1719
}; 
# 1726
struct _Equality_base { 
# 1729
protected: template< class _Uiterator> static bool _S_is_permutation(_Uiterator, _Uiterator, _Uiterator); 
# 1732
}; 
# 1735
template< class _Uiterator> bool 
# 1738
_Equality_base::_S_is_permutation(_Uiterator __first1, _Uiterator __last1, _Uiterator 
# 1739
__first2) 
# 1740
{ 
# 1741
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 1742
if (!((*__first1) == (*__first2))) { 
# 1743
break; }  }  
# 1745
if (__first1 == __last1) { 
# 1746
return true; }  
# 1748
_Uiterator __last2 = __first2; 
# 1749
std::advance(__last2, std::distance(__first1, __last1)); 
# 1751
for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1) { 
# 1752
{ 
# 1753
_Uiterator __tmp = __first1; 
# 1754
while ((__tmp != __it1) && (!((bool)((*__tmp) == (*__it1))))) { 
# 1755
++__tmp; }  
# 1758
if (__tmp != __it1) { 
# 1759
continue; }  
# 1761
ptrdiff_t __n2 = (0); 
# 1762
for (__tmp = __first2; __tmp != __last2; ++__tmp) { 
# 1763
if ((*__tmp) == (*__it1)) { 
# 1764
++__n2; }  }  
# 1766
if (!__n2) { 
# 1767
return false; }  
# 1769
ptrdiff_t __n1 = (0); 
# 1770
for (__tmp = __it1; __tmp != __last1; ++__tmp) { 
# 1771
if ((*__tmp) == (*__it1)) { 
# 1772
++__n1; }  }  
# 1774
if (__n1 != __n2) { 
# 1775
return false; }  
# 1776
} }  
# 1777
return true; 
# 1778
} 
# 1788 "/usr/include/c++/5/bits/hashtable_policy.h" 3
template< class _Key, class _Value, class _Alloc, class 
# 1789
_ExtractKey, class _Equal, class 
# 1790
_H1, class _H2, class _Hash, class 
# 1791
_RehashPolicy, class _Traits, bool 
# 1792
_Unique_keys = _Traits::__unique_keys::value> struct _Equality; 
# 1796
template< class _Key, class _Value, class _Alloc, class 
# 1797
_ExtractKey, class _Equal, class 
# 1798
_H1, class _H2, class _Hash, class 
# 1799
_RehashPolicy, class _Traits> 
# 1800
struct _Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>  { 
# 1803
using __hashtable = _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 1807
bool _M_equal(const __hashtable &) const; 
# 1808
}; 
# 1810
template< class _Key, class _Value, class _Alloc, class 
# 1811
_ExtractKey, class _Equal, class 
# 1812
_H1, class _H2, class _Hash, class 
# 1813
_RehashPolicy, class _Traits> bool 
# 1817
_Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> ::_M_equal(const __hashtable &__other) const 
# 1818
{ 
# 1819
const __hashtable *__this = static_cast< const __hashtable *>(this); 
# 1821
if ((__this->size()) != (__other.size())) { 
# 1822
return false; }  
# 1824
for (auto __itx = (__this->begin()); __itx != (__this->end()); ++__itx) 
# 1825
{ 
# 1826
const auto __ity = (__other.find(_ExtractKey()(*__itx))); 
# 1827
if ((__ity == (__other.end())) || (!((bool)((*__ity) == (*__itx))))) { 
# 1828
return false; }  
# 1829
}  
# 1830
return true; 
# 1831
} 
# 1834
template< class _Key, class _Value, class _Alloc, class 
# 1835
_ExtractKey, class _Equal, class 
# 1836
_H1, class _H2, class _Hash, class 
# 1837
_RehashPolicy, class _Traits> 
# 1838
struct _Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false>  : public _Equality_base { 
# 1842
using __hashtable = _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 1846
bool _M_equal(const __hashtable &) const; 
# 1847
}; 
# 1849
template< class _Key, class _Value, class _Alloc, class 
# 1850
_ExtractKey, class _Equal, class 
# 1851
_H1, class _H2, class _Hash, class 
# 1852
_RehashPolicy, class _Traits> bool 
# 1856
_Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false> ::_M_equal(const __hashtable &__other) const 
# 1857
{ 
# 1858
const __hashtable *__this = static_cast< const __hashtable *>(this); 
# 1860
if ((__this->size()) != (__other.size())) { 
# 1861
return false; }  
# 1863
for (auto __itx = (__this->begin()); __itx != (__this->end());) 
# 1864
{ 
# 1865
const auto __xrange = (__this->equal_range(_ExtractKey()(*__itx))); 
# 1866
const auto __yrange = (__other.equal_range(_ExtractKey()(*__itx))); 
# 1868
if (std::distance((__xrange.first), (__xrange.second)) != std::distance((__yrange.first), (__yrange.second))) { 
# 1870
return false; }  
# 1872
if (!_S_is_permutation((__xrange.first), (__xrange.second), (__yrange.first))) { 
# 1874
return false; }  
# 1876
__itx = (__xrange.second); 
# 1877
}  
# 1878
return true; 
# 1879
} 
# 1885
template< class _NodeAlloc> 
# 1886
struct _Hashtable_alloc : private _Hashtable_ebo_helper< 0, _NodeAlloc>  { 
# 1889
private: using __ebo_node_alloc = _Hashtable_ebo_helper< 0, _NodeAlloc> ; 
# 1891
public: using __node_type = typename _NodeAlloc::value_type; 
# 1892
using __node_alloc_type = _NodeAlloc; 
# 1894
using __node_alloc_traits = ::__gnu_cxx::__alloc_traits< _NodeAlloc> ; 
# 1896
using __value_type = typename _NodeAlloc::value_type::value_type; 
# 1897
using __value_alloc_type = ::std::__alloc_rebind< _NodeAlloc, typename _NodeAlloc::value_type::value_type> ; 
# 1899
using __value_alloc_traits = allocator_traits< ::std::__alloc_rebind< _NodeAlloc, typename _NodeAlloc::value_type::value_type> > ; 
# 1901
using __node_base = ::std::__detail::_Hash_node_base; 
# 1902
using __bucket_type = __node_base *; 
# 1903
using __bucket_alloc_type = ::std::__alloc_rebind< _NodeAlloc, ::std::__detail::_Hash_node_base *> ; 
# 1905
using __bucket_alloc_traits = allocator_traits< ::std::__alloc_rebind< _NodeAlloc, ::std::__detail::_Hash_node_base *> > ; 
# 1907
_Hashtable_alloc() = default;
# 1908
_Hashtable_alloc(const _Hashtable_alloc &) = default;
# 1909
_Hashtable_alloc(_Hashtable_alloc &&) = default;
# 1911
template< class _Alloc> 
# 1912
_Hashtable_alloc(_Alloc &&__a) : __ebo_node_alloc(::std::forward< _Alloc> (__a)) 
# 1914
{ } 
# 1917
__node_alloc_type &_M_node_allocator() 
# 1918
{ return __ebo_node_alloc::_S_get(*this); } 
# 1921
const __node_alloc_type &_M_node_allocator() const 
# 1922
{ return __ebo_node_alloc::_S_cget(*this); } 
# 1924
template< class ..._Args> __node_type *_M_allocate_node(_Args && ...__args); 
# 1929
void _M_deallocate_node(__node_type * __n); 
# 1933
void _M_deallocate_nodes(__node_type * __n); 
# 1936
__bucket_type *_M_allocate_buckets(::std::size_t __n); 
# 1939
void _M_deallocate_buckets(__bucket_type *, ::std::size_t __n); 
# 1940
}; 
# 1944
template< class _NodeAlloc> 
# 1945
template< class ..._Args> typename _Hashtable_alloc< _NodeAlloc> ::__node_type *
# 1947
_Hashtable_alloc< _NodeAlloc> ::_M_allocate_node(_Args &&...__args) 
# 1948
{ 
# 1949
auto __nptr = __node_alloc_traits::allocate(this->_M_node_allocator(), 1); 
# 1950
__node_type *__n = ::std::__addressof(*__nptr); 
# 1951
try 
# 1952
{ 
# 1953
__value_alloc_type __a(this->_M_node_allocator()); 
# 1954
::new ((void *)__n) __node_type; 
# 1955
__value_alloc_traits::construct(__a, (__n->_M_valptr()), ::std::forward< _Args> (__args)...); 
# 1957
return __n; 
# 1958
} 
# 1959
catch (...) 
# 1960
{ 
# 1961
__node_alloc_traits::deallocate(this->_M_node_allocator(), __nptr, 1); 
# 1962
throw; 
# 1963
}  
# 1964
} 
# 1966
template< class _NodeAlloc> void 
# 1968
_Hashtable_alloc< _NodeAlloc> ::_M_deallocate_node(__node_type *__n) 
# 1969
{ 
# 1970
typedef typename ::__gnu_cxx::__alloc_traits< _NodeAlloc> ::pointer _Ptr; 
# 1971
auto __ptr = std::pointer_traits< typename ::__gnu_cxx::__alloc_traits< _NodeAlloc> ::pointer> ::pointer_to(*__n); 
# 1972
__value_alloc_type __a(this->_M_node_allocator()); 
# 1973
__value_alloc_traits::destroy(__a, (__n->_M_valptr())); 
# 1974
(__n->~__node_type()); 
# 1975
__node_alloc_traits::deallocate(this->_M_node_allocator(), __ptr, 1); 
# 1976
} 
# 1978
template< class _NodeAlloc> void 
# 1980
_Hashtable_alloc< _NodeAlloc> ::_M_deallocate_nodes(__node_type *__n) 
# 1981
{ 
# 1982
while (__n) 
# 1983
{ 
# 1984
__node_type *__tmp = __n; 
# 1985
__n = (__n->_M_next()); 
# 1986
_M_deallocate_node(__tmp); 
# 1987
}  
# 1988
} 
# 1990
template< class _NodeAlloc> typename _Hashtable_alloc< _NodeAlloc> ::__bucket_type *
# 1992
_Hashtable_alloc< _NodeAlloc> ::_M_allocate_buckets(::std::size_t __n) 
# 1993
{ 
# 1994
__bucket_alloc_type __alloc(this->_M_node_allocator()); 
# 1996
auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n); 
# 1997
__bucket_type *__p = ::std::__addressof(*__ptr); 
# 1998
__builtin_memset(__p, 0, __n * sizeof(__bucket_type)); 
# 1999
return __p; 
# 2000
} 
# 2002
template< class _NodeAlloc> void 
# 2004
_Hashtable_alloc< _NodeAlloc> ::_M_deallocate_buckets(__bucket_type *__bkts, ::std::size_t 
# 2005
__n) 
# 2006
{ 
# 2007
typedef typename allocator_traits< ::std::__alloc_rebind< _NodeAlloc, ::std::__detail::_Hash_node_base *> > ::pointer _Ptr; 
# 2008
auto __ptr = std::pointer_traits< typename allocator_traits< ::std::__alloc_rebind< _NodeAlloc, ::std::__detail::_Hash_node_base *> > ::pointer> ::pointer_to(*__bkts); 
# 2009
__bucket_alloc_type __alloc(this->_M_node_allocator()); 
# 2010
__bucket_alloc_traits::deallocate(__alloc, __ptr, __n); 
# 2011
} 
# 2015
}
# 2016
}
# 37 "/usr/include/c++/5/bits/hashtable.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
template< class _Tp, class _Hash> using __cache_default = __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Tp, _Hash> > > ; 
# 166 "/usr/include/c++/5/bits/hashtable.h" 3
template< class _Key, class _Value, class _Alloc, class 
# 167
_ExtractKey, class _Equal, class 
# 168
_H1, class _H2, class _Hash, class 
# 169
_RehashPolicy, class _Traits> 
# 170
class _Hashtable : public __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> , public __detail::_Map_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> , public __detail::_Insert< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> , public __detail::_Rehash_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> , public __detail::_Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> , private __detail::_Hashtable_alloc< typename __alloctr_rebind< _Alloc, __detail::_Hash_node< _Value, _Traits::__hash_cached::value> > ::__type>  { 
# 186
using __traits_type = _Traits; 
# 187
using __hash_cached = typename _Traits::__hash_cached; 
# 188
using __node_type = ::std::__detail::_Hash_node< _Value, _Traits::__hash_cached::value> ; 
# 189
using __node_alloc_type = typename __alloctr_rebind< _Alloc, ::std::__detail::_Hash_node< _Value, _Traits::__hash_cached::value> > ::__type; 
# 192
using __hashtable_alloc = ::std::__detail::_Hashtable_alloc< typename __alloctr_rebind< _Alloc, ::std::__detail::_Hash_node< _Value, _Traits::__hash_cached::value> > ::__type> ; 
# 194
using __value_alloc_traits = typename ::std::__detail::_Hashtable_alloc< typename __alloctr_rebind< _Alloc, ::std::__detail::_Hash_node< _Value, _Traits::__hash_cached::value> > ::__type> ::__value_alloc_traits; 
# 196
using __node_alloc_traits = typename ::std::__detail::_Hashtable_alloc< typename __alloctr_rebind< _Alloc, ::std::__detail::_Hash_node< _Value, _Traits::__hash_cached::value> > ::__type> ::__node_alloc_traits; 
# 198
using __node_base = typename ::std::__detail::_Hashtable_alloc< typename __alloctr_rebind< _Alloc, ::std::__detail::_Hash_node< _Value, _Traits::__hash_cached::value> > ::__type> ::__node_base; 
# 199
using __bucket_type = typename ::std::__detail::_Hashtable_alloc< typename __alloctr_rebind< _Alloc, ::std::__detail::_Hash_node< _Value, _Traits::__hash_cached::value> > ::__type> ::__bucket_type; 
# 202
public: typedef _Key key_type; 
# 203
typedef _Value value_type; 
# 204
typedef _Alloc allocator_type; 
# 205
typedef _Equal key_equal; 
# 209
typedef typename ::std::__detail::_Hashtable_alloc< typename __alloctr_rebind< _Alloc, ::std::__detail::_Hash_node< _Value, _Traits::__hash_cached::value> > ::__type> ::__value_alloc_traits::pointer pointer; 
# 210
typedef typename ::std::__detail::_Hashtable_alloc< typename __alloctr_rebind< _Alloc, ::std::__detail::_Hash_node< _Value, _Traits::__hash_cached::value> > ::__type> ::__value_alloc_traits::const_pointer const_pointer; 
# 211
typedef value_type &reference; 
# 212
typedef const value_type &const_reference; 
# 215
private: using __rehash_type = _RehashPolicy; 
# 216
using __rehash_state = typename _RehashPolicy::_State; 
# 218
using __constant_iterators = typename _Traits::__constant_iterators; 
# 219
using __unique_keys = typename _Traits::__unique_keys; 
# 221
using __key_extract = typename conditional< _Traits::__constant_iterators::value, ::std::__detail::_Identity, ::std::__detail::_Select1st> ::type; 
# 226
using __hashtable_base = ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ; 
# 230
using __hash_code_base = typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__hash_code_base; 
# 231
using __hash_code = typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__hash_code; 
# 232
using __ireturn_type = typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__ireturn_type; 
# 234
using __map_base = ::std::__detail::_Map_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 238
using __rehash_base = ::std::__detail::_Rehash_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 243
using __eq_base = ::std::__detail::_Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 247
using __reuse_or_alloc_node_type = ::std::__detail::_ReuseOrAllocNode< typename __alloctr_rebind< _Alloc, ::std::__detail::_Hash_node< _Value, _Traits::__hash_cached::value> > ::__type> ; 
# 251
template< class _Cond> using __if_hash_cached = __or_< __not_< typename _Traits::__hash_cached> , _Cond> ; 
# 254
template< class _Cond> using __if_hash_not_cached = __or_< typename _Traits::__hash_cached, _Cond> ; 
# 261
struct __hash_code_base_access : public __hash_code_base { 
# 262
using ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__hash_code_base::_M_bucket_index;}; 
# 266
static_assert(noexcept((declval< const __hash_code_base_access &> ()._M_bucket_index((const __node_type *)nullptr, (::std::size_t)0))), "Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept");
# 277
static_assert((__if_hash_cached< is_default_constructible< _H2> > ::value), "Functor used to map hash code to bucket index must be default constructible");
# 281
template< class _Keya, class _Valuea, class _Alloca, class 
# 282
_ExtractKeya, class _Equala, class 
# 283
_H1a, class _H2a, class _Hasha, class 
# 284
_RehashPolicya, class _Traitsa, bool 
# 285
_Unique_keysa> friend struct ::std::__detail::_Map_base; 
# 288
template< class _Keya, class _Valuea, class _Alloca, class 
# 289
_ExtractKeya, class _Equala, class 
# 290
_H1a, class _H2a, class _Hasha, class 
# 291
_RehashPolicya, class _Traitsa> friend struct ::std::__detail::_Insert_base; 
# 294
template< class _Keya, class _Valuea, class _Alloca, class 
# 295
_ExtractKeya, class _Equala, class 
# 296
_H1a, class _H2a, class _Hasha, class 
# 297
_RehashPolicya, class _Traitsa, bool 
# 298
_Constant_iteratorsa, bool _Unique_keysa> friend struct ::std::__detail::_Insert; 
# 302
public: using size_type = typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::size_type; 
# 303
using difference_type = typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::difference_type; 
# 305
using iterator = typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator; 
# 306
using const_iterator = typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::const_iterator; 
# 308
using local_iterator = typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::local_iterator; 
# 309
using const_local_iterator = typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::const_local_iterator; 
# 313
private: __bucket_type *_M_buckets = (&(_M_single_bucket)); 
# 314
size_type _M_bucket_count = (1); 
# 315
__node_base _M_before_begin; 
# 316
size_type _M_element_count = (0); 
# 317
_RehashPolicy _M_rehash_policy; 
# 325
__bucket_type _M_single_bucket = (nullptr); 
# 328
bool _M_uses_single_bucket(__bucket_type *__bkts) const 
# 329
{ return __builtin_expect(__bkts == (&(_M_single_bucket)), false); } 
# 332
bool _M_uses_single_bucket() const 
# 333
{ return _M_uses_single_bucket(_M_buckets); } 
# 336
__hashtable_alloc &_M_base_alloc() { return *this; } 
# 339
__bucket_type *_M_allocate_buckets(size_type __n) 
# 340
{ 
# 341
if (__builtin_expect(__n == 1, false)) 
# 342
{ 
# 343
(_M_single_bucket) = nullptr; 
# 344
return &(_M_single_bucket); 
# 345
}  
# 347
return __hashtable_alloc::_M_allocate_buckets(__n); 
# 348
} 
# 351
void _M_deallocate_buckets(__bucket_type *__bkts, size_type __n) 
# 352
{ 
# 353
if (_M_uses_single_bucket(__bkts)) { 
# 354
return; }  
# 356
__hashtable_alloc::_M_deallocate_buckets(__bkts, __n); 
# 357
} 
# 360
void _M_deallocate_buckets() 
# 361
{ _M_deallocate_buckets(_M_buckets, _M_bucket_count); } 
# 366
__node_type *_M_bucket_begin(size_type __bkt) const; 
# 369
__node_type *_M_begin() const 
# 370
{ return static_cast< __node_type *>((_M_before_begin)._M_nxt); } 
# 372
template< class _NodeGenerator> void _M_assign(const _Hashtable &, const _NodeGenerator &); 
# 377
void _M_move_assign(_Hashtable &&, ::std::true_type); 
# 380
void _M_move_assign(_Hashtable &&, ::std::false_type); 
# 383
void _M_reset() noexcept; 
# 385
_Hashtable(const _H1 &__h1, const _H2 &__h2, const _Hash &__h, const _Equal &
# 386
__eq, const _ExtractKey &__exk, const allocator_type &
# 387
__a) : __hashtable_base(__exk, __h1, __h2, __h, __eq), __hashtable_alloc((__node_alloc_type)__a) 
# 390
{ } 
# 394
public: _Hashtable() = default;
# 395
_Hashtable(size_type __bucket_hint, const _H1 &, const _H2 &, const _Hash &, const _Equal &, const _ExtractKey &, const allocator_type &); 
# 400
template< class _InputIterator> _Hashtable(_InputIterator __first, _InputIterator __last, size_type __bucket_hint, const _H1 &, const _H2 &, const _Hash &, const _Equal &, const _ExtractKey &, const allocator_type &); 
# 407
_Hashtable(const _Hashtable &); 
# 409
_Hashtable(_Hashtable &&) noexcept; 
# 411
_Hashtable(const _Hashtable &, const allocator_type &); 
# 413
_Hashtable(_Hashtable &&, const allocator_type &); 
# 417
explicit _Hashtable(const allocator_type &__a) : __hashtable_alloc((__node_alloc_type)__a) 
# 419
{ } 
# 422
explicit _Hashtable(size_type __n, const _H1 &
# 423
__hf = _H1(), const key_equal &
# 424
__eql = key_equal(), const allocator_type &
# 425
__a = allocator_type()) : _Hashtable(__n, __hf, _H2(), _Hash(), __eql, __key_extract(), __a) 
# 428
{ } 
# 430
template< class _InputIterator> 
# 431
_Hashtable(_InputIterator __f, _InputIterator __l, size_type 
# 432
__n = 0, const _H1 &
# 433
__hf = _H1(), const key_equal &
# 434
__eql = key_equal(), const allocator_type &
# 435
__a = allocator_type()) : _Hashtable(__f, __l, __n, __hf, _H2(), _Hash(), __eql, __key_extract(), __a) 
# 438
{ } 
# 440
_Hashtable(initializer_list< _Value>  __l, size_type 
# 441
__n = 0, const _H1 &
# 442
__hf = _H1(), const key_equal &
# 443
__eql = key_equal(), const allocator_type &
# 444
__a = allocator_type()) : _Hashtable((__l.begin()), (__l.end()), __n, __hf, _H2(), _Hash(), __eql, __key_extract(), __a) 
# 447
{ } 
# 450
_Hashtable &operator=(const _Hashtable & __ht); 
# 453
_Hashtable &operator=(_Hashtable &&__ht) noexcept(__node_alloc_traits::_S_nothrow_move()) 
# 455
{ 
# 456
constexpr bool __move_storage = (__node_alloc_traits::_S_propagate_on_move_assign() || __node_alloc_traits::_S_always_equal()); 
# 459
_M_move_assign(::std::move(__ht), integral_constant< bool, __move_storage> ()); 
# 461
return *this; 
# 462
} 
# 465
_Hashtable &operator=(initializer_list< _Value>  __l) 
# 466
{ 
# 467
__reuse_or_alloc_node_type __roan(_M_begin(), *this); 
# 468
((_M_before_begin)._M_nxt) = nullptr; 
# 469
clear(); 
# 470
(this->_M_insert_range((__l.begin()), (__l.end()), __roan)); 
# 471
return *this; 
# 472
} 
# 474
~_Hashtable() noexcept; 
# 477
void swap(_Hashtable &) noexcept(__node_alloc_traits::_S_nothrow_swap()); 
# 482
iterator begin() noexcept 
# 483
{ return (iterator)_M_begin(); } 
# 486
const_iterator begin() const noexcept 
# 487
{ return (const_iterator)_M_begin(); } 
# 490
iterator end() noexcept 
# 491
{ return (iterator)nullptr; } 
# 494
const_iterator end() const noexcept 
# 495
{ return (const_iterator)nullptr; } 
# 498
const_iterator cbegin() const noexcept 
# 499
{ return (const_iterator)_M_begin(); } 
# 502
const_iterator cend() const noexcept 
# 503
{ return (const_iterator)nullptr; } 
# 506
size_type size() const noexcept 
# 507
{ return _M_element_count; } 
# 510
bool empty() const noexcept 
# 511
{ return size() == 0; } 
# 514
allocator_type get_allocator() const noexcept 
# 515
{ return (allocator_type)(this->_M_node_allocator()); } 
# 518
size_type max_size() const noexcept 
# 519
{ return __node_alloc_traits::max_size((this->_M_node_allocator())); } 
# 523
key_equal key_eq() const 
# 524
{ return (this->_M_eq()); } 
# 530
size_type bucket_count() const noexcept 
# 531
{ return _M_bucket_count; } 
# 534
size_type max_bucket_count() const noexcept 
# 535
{ return max_size(); } 
# 538
size_type bucket_size(size_type __n) const 
# 539
{ return ::std::distance(begin(__n), end(__n)); } 
# 542
size_type bucket(const key_type &__k) const 
# 543
{ return _M_bucket_index(__k, (this->_M_hash_code(__k))); } 
# 546
local_iterator begin(size_type __n) 
# 547
{ 
# 548
return local_iterator(*this, _M_bucket_begin(__n), __n, _M_bucket_count); 
# 550
} 
# 553
local_iterator end(size_type __n) 
# 554
{ return local_iterator(*this, nullptr, __n, _M_bucket_count); } 
# 557
const_local_iterator begin(size_type __n) const 
# 558
{ 
# 559
return const_local_iterator(*this, _M_bucket_begin(__n), __n, _M_bucket_count); 
# 561
} 
# 564
const_local_iterator end(size_type __n) const 
# 565
{ return const_local_iterator(*this, nullptr, __n, _M_bucket_count); } 
# 569
const_local_iterator cbegin(size_type __n) const 
# 570
{ 
# 571
return const_local_iterator(*this, _M_bucket_begin(__n), __n, _M_bucket_count); 
# 573
} 
# 576
const_local_iterator cend(size_type __n) const 
# 577
{ return const_local_iterator(*this, nullptr, __n, _M_bucket_count); } 
# 580
float load_factor() const noexcept 
# 581
{ 
# 582
return (static_cast< float>(size())) / (static_cast< float>(bucket_count())); 
# 583
} 
# 591
const _RehashPolicy &__rehash_policy() const 
# 592
{ return _M_rehash_policy; } 
# 595
void __rehash_policy(const _RehashPolicy &); 
# 599
iterator find(const key_type & __k); 
# 602
const_iterator find(const key_type & __k) const; 
# 605
size_type count(const key_type & __k) const; 
# 608
pair< typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator, typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator>  equal_range(const key_type & __k); 
# 611
pair< typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::const_iterator, typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::const_iterator>  equal_range(const key_type & __k) const; 
# 616
protected: size_type _M_bucket_index(__node_type *__n) const noexcept 
# 617
{ return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); } 
# 620
size_type _M_bucket_index(const key_type &__k, __hash_code __c) const 
# 621
{ return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); } 
# 626
__node_base *_M_find_before_node(size_type, const key_type &, __hash_code) const; 
# 629
__node_type *_M_find_node(size_type __bkt, const key_type &__key, __hash_code 
# 630
__c) const 
# 631
{ 
# 632
__node_base *__before_n = _M_find_before_node(__bkt, __key, __c); 
# 633
if (__before_n) { 
# 634
return static_cast< __node_type *>(__before_n->_M_nxt); }  
# 635
return nullptr; 
# 636
} 
# 640
void _M_insert_bucket_begin(size_type, __node_type *); 
# 644
void _M_remove_bucket_begin(size_type __bkt, __node_type * __next_n, size_type __next_bkt); 
# 649
__node_base *_M_get_previous_node(size_type __bkt, __node_base * __n); 
# 655
iterator _M_insert_unique_node(size_type __bkt, __hash_code __code, __node_type * __n); 
# 661
iterator _M_insert_multi_node(__node_type * __hint, __hash_code __code, __node_type * __n); 
# 664
template< class ..._Args> pair< typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator, bool>  _M_emplace(::std::true_type, _Args && ...__args); 
# 668
template< class ..._Args> iterator 
# 670
_M_emplace(::std::false_type __uk, _Args &&...__args) 
# 671
{ return _M_emplace(cend(), __uk, ::std::forward< _Args> (__args)...); } 
# 674
template< class ..._Args> iterator 
# 676
_M_emplace(const_iterator, ::std::true_type __uk, _Args &&...__args) 
# 677
{ return _M_emplace(__uk, ::std::forward< _Args> (__args)...).first; } 
# 679
template< class ..._Args> iterator _M_emplace(const_iterator, ::std::false_type, _Args && ...__args); 
# 683
template< class _Arg, class _NodeGenerator> pair< typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator, bool>  _M_insert(_Arg &&, const _NodeGenerator &, ::std::true_type); 
# 687
template< class _Arg, class _NodeGenerator> iterator 
# 689
_M_insert(_Arg &&__arg, const _NodeGenerator &__node_gen, ::std::false_type 
# 690
__uk) 
# 691
{ 
# 692
return _M_insert(cend(), ::std::forward< _Arg> (__arg), __node_gen, __uk); 
# 694
} 
# 697
template< class _Arg, class _NodeGenerator> iterator 
# 699
_M_insert(const_iterator, _Arg &&__arg, const _NodeGenerator &
# 700
__node_gen, ::std::true_type __uk) 
# 701
{ 
# 702
return _M_insert(::std::forward< _Arg> (__arg), __node_gen, __uk).first; 
# 704
} 
# 707
template< class _Arg, class _NodeGenerator> iterator _M_insert(const_iterator, _Arg &&, const _NodeGenerator &, ::std::false_type); 
# 713
size_type _M_erase(::std::true_type, const key_type &); 
# 716
size_type _M_erase(::std::false_type, const key_type &); 
# 719
iterator _M_erase(size_type __bkt, __node_base * __prev_n, __node_type * __n); 
# 725
public: 
# 723
template< class ..._Args> __ireturn_type 
# 725
emplace(_Args &&...__args) 
# 726
{ return _M_emplace(__unique_keys(), ::std::forward< _Args> (__args)...); } 
# 728
template< class ..._Args> iterator 
# 730
emplace_hint(const_iterator __hint, _Args &&...__args) 
# 731
{ 
# 732
return _M_emplace(__hint, __unique_keys(), ::std::forward< _Args> (__args)...); 
# 734
} 
# 740
iterator erase(const_iterator); 
# 744
iterator erase(iterator __it) 
# 745
{ return erase((const_iterator)__it); } 
# 748
size_type erase(const key_type &__k) 
# 749
{ return _M_erase(__unique_keys(), __k); } 
# 752
iterator erase(const_iterator, const_iterator); 
# 755
void clear() noexcept; 
# 758
void rehash(size_type __n); 
# 765
private: void _M_rehash_aux(size_type __n, ::std::true_type); 
# 768
void _M_rehash_aux(size_type __n, ::std::false_type); 
# 772
void _M_rehash(size_type __n, const __rehash_state & __state); 
# 773
}; 
# 777
template< class _Key, class _Value, class 
# 778
_Alloc, class _ExtractKey, class _Equal, class 
# 779
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 780
_Traits> auto 
# 784
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_bucket_begin(size_type __bkt) const->__node_type * 
# 786
{ 
# 787
__node_base *__n = (_M_buckets)[__bkt]; 
# 788
return (__n) ? static_cast< __node_type *>(__n->_M_nxt) : nullptr; 
# 789
} 
# 791
template< class _Key, class _Value, class 
# 792
_Alloc, class _ExtractKey, class _Equal, class 
# 793
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 794
_Traits> 
# 797
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(size_type __bucket_hint, const _H1 &
# 798
__h1, const _H2 &__h2, const _Hash &__h, const _Equal &
# 799
__eq, const _ExtractKey &__exk, const allocator_type &
# 800
__a) : _Hashtable(__h1, __h2, __h, __eq, __exk, __a) 
# 802
{ 
# 803
auto __bkt = ((_M_rehash_policy)._M_next_bkt(__bucket_hint)); 
# 804
if (__bkt > (_M_bucket_count)) 
# 805
{ 
# 806
(_M_buckets) = _M_allocate_buckets(__bkt); 
# 807
(_M_bucket_count) = __bkt; 
# 808
}  
# 809
} 
# 811
template< class _Key, class _Value, class 
# 812
_Alloc, class _ExtractKey, class _Equal, class 
# 813
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 814
_Traits> 
# 815
template< class _InputIterator> 
# 818
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(_InputIterator __f, _InputIterator __l, size_type 
# 819
__bucket_hint, const _H1 &
# 820
__h1, const _H2 &__h2, const _Hash &__h, const _Equal &
# 821
__eq, const _ExtractKey &__exk, const allocator_type &
# 822
__a) : _Hashtable(__h1, __h2, __h, __eq, __exk, __a) 
# 824
{ 
# 825
auto __nb_elems = ::std::__detail::__distance_fw(__f, __l); 
# 826
auto __bkt_count = ((_M_rehash_policy)._M_next_bkt(::std::max(((_M_rehash_policy)._M_bkt_for_elements(__nb_elems)), __bucket_hint))); 
# 831
if (__bkt_count > (_M_bucket_count)) 
# 832
{ 
# 833
(_M_buckets) = _M_allocate_buckets(__bkt_count); 
# 834
(_M_bucket_count) = __bkt_count; 
# 835
}  
# 837
try 
# 838
{ 
# 839
for (; __f != __l; ++__f) { 
# 840
(this->insert(*__f)); }  
# 841
} 
# 842
catch (...) 
# 843
{ 
# 844
clear(); 
# 845
_M_deallocate_buckets(); 
# 846
throw; 
# 847
}  
# 848
} 
# 850
template< class _Key, class _Value, class 
# 851
_Alloc, class _ExtractKey, class _Equal, class 
# 852
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 853
_Traits> auto 
# 857
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::operator=(const _Hashtable &__ht)->_Hashtable & 
# 859
{ 
# 860
if ((&__ht) == this) { 
# 861
return *this; }  
# 863
if (__node_alloc_traits::_S_propagate_on_copy_assign()) 
# 864
{ 
# 865
auto &__this_alloc = (this->_M_node_allocator()); 
# 866
auto &__that_alloc = (__ht._M_node_allocator()); 
# 867
if ((!__node_alloc_traits::_S_always_equal()) && (__this_alloc != __that_alloc)) 
# 869
{ 
# 871
(this->_M_deallocate_nodes(_M_begin())); 
# 872
((_M_before_begin)._M_nxt) = nullptr; 
# 873
_M_deallocate_buckets(); 
# 874
(_M_buckets) = nullptr; 
# 875
::std::__alloc_on_copy(__this_alloc, __that_alloc); 
# 876
::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::operator=(__ht); 
# 877
(_M_bucket_count) = (__ht._M_bucket_count); 
# 878
(_M_element_count) = (__ht._M_element_count); 
# 879
(_M_rehash_policy) = (__ht._M_rehash_policy); 
# 880
try 
# 881
{ 
# 882
_M_assign(__ht, [this](const __node_type *
# 883
__n) 
# 884
{ return ((this)->_M_allocate_node((__n->_M_v()))); } ); 
# 885
} 
# 886
catch (...) 
# 887
{ 
# 890
_M_reset(); 
# 891
throw; 
# 892
}  
# 893
return *this; 
# 894
}  
# 895
::std::__alloc_on_copy(__this_alloc, __that_alloc); 
# 896
}  
# 899
__bucket_type *__former_buckets = (nullptr); 
# 900
::std::size_t __former_bucket_count = _M_bucket_count; 
# 901
const __rehash_state &__former_state = ((_M_rehash_policy)._M_state()); 
# 903
if ((_M_bucket_count) != (__ht._M_bucket_count)) 
# 904
{ 
# 905
__former_buckets = (_M_buckets); 
# 906
(_M_buckets) = _M_allocate_buckets((__ht._M_bucket_count)); 
# 907
(_M_bucket_count) = (__ht._M_bucket_count); 
# 908
} else { 
# 910
__builtin_memset(_M_buckets, 0, (_M_bucket_count) * sizeof(__bucket_type)); }  
# 913
try 
# 914
{ 
# 915
::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::operator=(__ht); 
# 916
(_M_element_count) = (__ht._M_element_count); 
# 917
(_M_rehash_policy) = (__ht._M_rehash_policy); 
# 918
__reuse_or_alloc_node_type __roan(_M_begin(), *this); 
# 919
((_M_before_begin)._M_nxt) = nullptr; 
# 920
_M_assign(__ht, [&__roan](const __node_type *
# 921
__n) 
# 922
{ return (__roan)((__n->_M_v())); } ); 
# 923
if (__former_buckets) { 
# 924
_M_deallocate_buckets(__former_buckets, __former_bucket_count); }  
# 925
} 
# 926
catch (...) 
# 927
{ 
# 928
if (__former_buckets) 
# 929
{ 
# 931
_M_deallocate_buckets(); 
# 932
((_M_rehash_policy)._M_reset(__former_state)); 
# 933
(_M_buckets) = __former_buckets; 
# 934
(_M_bucket_count) = __former_bucket_count; 
# 935
}  
# 936
__builtin_memset(_M_buckets, 0, (_M_bucket_count) * sizeof(__bucket_type)); 
# 938
throw; 
# 939
}  
# 940
return *this; 
# 941
} 
# 943
template< class _Key, class _Value, class 
# 944
_Alloc, class _ExtractKey, class _Equal, class 
# 945
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 946
_Traits> 
# 947
template< class _NodeGenerator> void 
# 951
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_assign(const _Hashtable &__ht, const _NodeGenerator &__node_gen) 
# 952
{ 
# 953
__bucket_type *__buckets = (nullptr); 
# 954
if (!(_M_buckets)) { 
# 955
(_M_buckets) = (__buckets = _M_allocate_buckets(_M_bucket_count)); }  
# 957
try 
# 958
{ 
# 959
if (!((__ht._M_before_begin)._M_nxt)) { 
# 960
return; }  
# 964
__node_type *__ht_n = (__ht._M_begin()); 
# 965
__node_type *__this_n = __node_gen(__ht_n); 
# 966
(this->_M_copy_code(__this_n, __ht_n)); 
# 967
((_M_before_begin)._M_nxt) = __this_n; 
# 968
((_M_buckets)[_M_bucket_index(__this_n)]) = (&(_M_before_begin)); 
# 971
__node_base *__prev_n = __this_n; 
# 972
for (__ht_n = (__ht_n->_M_next()); __ht_n; __ht_n = (__ht_n->_M_next())) 
# 973
{ 
# 974
__this_n = __node_gen(__ht_n); 
# 975
(__prev_n->_M_nxt) = __this_n; 
# 976
(this->_M_copy_code(__this_n, __ht_n)); 
# 977
size_type __bkt = _M_bucket_index(__this_n); 
# 978
if (!((_M_buckets)[__bkt])) { 
# 979
((_M_buckets)[__bkt]) = __prev_n; }  
# 980
__prev_n = __this_n; 
# 981
}  
# 982
} 
# 983
catch (...) 
# 984
{ 
# 985
clear(); 
# 986
if (__buckets) { 
# 987
_M_deallocate_buckets(); }  
# 988
throw; 
# 989
}  
# 990
} 
# 992
template< class _Key, class _Value, class 
# 993
_Alloc, class _ExtractKey, class _Equal, class 
# 994
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 995
_Traits> void 
# 999
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_reset() noexcept 
# 1000
{ 
# 1001
((_M_rehash_policy)._M_reset()); 
# 1002
(_M_bucket_count) = 1; 
# 1003
(_M_single_bucket) = nullptr; 
# 1004
(_M_buckets) = (&(_M_single_bucket)); 
# 1005
((_M_before_begin)._M_nxt) = nullptr; 
# 1006
(_M_element_count) = 0; 
# 1007
} 
# 1009
template< class _Key, class _Value, class 
# 1010
_Alloc, class _ExtractKey, class _Equal, class 
# 1011
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1012
_Traits> void 
# 1016
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_move_assign(_Hashtable &&__ht, ::std::true_type) 
# 1017
{ 
# 1018
(this->_M_deallocate_nodes(_M_begin())); 
# 1019
_M_deallocate_buckets(); 
# 1020
::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::operator=(::std::move(__ht)); 
# 1021
(_M_rehash_policy) = (__ht._M_rehash_policy); 
# 1022
if (!(__ht._M_uses_single_bucket())) { 
# 1023
(_M_buckets) = (__ht._M_buckets); } else 
# 1025
{ 
# 1026
(_M_buckets) = (&(_M_single_bucket)); 
# 1027
(_M_single_bucket) = (__ht._M_single_bucket); 
# 1028
}  
# 1029
(_M_bucket_count) = (__ht._M_bucket_count); 
# 1030
((_M_before_begin)._M_nxt) = ((__ht._M_before_begin)._M_nxt); 
# 1031
(_M_element_count) = (__ht._M_element_count); 
# 1032
::std::__alloc_on_move((this->_M_node_allocator()), (__ht._M_node_allocator())); 
# 1036
if (_M_begin()) { 
# 1037
((_M_buckets)[_M_bucket_index(_M_begin())]) = (&(_M_before_begin)); }  
# 1038
(__ht._M_reset()); 
# 1039
} 
# 1041
template< class _Key, class _Value, class 
# 1042
_Alloc, class _ExtractKey, class _Equal, class 
# 1043
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1044
_Traits> void 
# 1048
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_move_assign(_Hashtable &&__ht, ::std::false_type) 
# 1049
{ 
# 1050
if ((__ht._M_node_allocator()) == (this->_M_node_allocator())) { 
# 1051
_M_move_assign(::std::move(__ht), ::std::true_type()); } else 
# 1053
{ 
# 1055
__bucket_type *__former_buckets = (nullptr); 
# 1056
size_type __former_bucket_count = _M_bucket_count; 
# 1057
const __rehash_state &__former_state = ((_M_rehash_policy)._M_state()); 
# 1059
if ((_M_bucket_count) != (__ht._M_bucket_count)) 
# 1060
{ 
# 1061
__former_buckets = (_M_buckets); 
# 1062
(_M_buckets) = _M_allocate_buckets((__ht._M_bucket_count)); 
# 1063
(_M_bucket_count) = (__ht._M_bucket_count); 
# 1064
} else { 
# 1066
__builtin_memset(_M_buckets, 0, (_M_bucket_count) * sizeof(__bucket_type)); }  
# 1069
try 
# 1070
{ 
# 1071
::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::operator=(::std::move(__ht)); 
# 1072
(_M_element_count) = (__ht._M_element_count); 
# 1073
(_M_rehash_policy) = (__ht._M_rehash_policy); 
# 1074
__reuse_or_alloc_node_type __roan(_M_begin(), *this); 
# 1075
((_M_before_begin)._M_nxt) = nullptr; 
# 1076
_M_assign(__ht, [&__roan](__node_type *
# 1077
__n) 
# 1078
{ return (__roan)(::std::move_if_noexcept((__n->_M_v()))); } ); 
# 1079
(__ht.clear()); 
# 1080
} 
# 1081
catch (...) 
# 1082
{ 
# 1083
if (__former_buckets) 
# 1084
{ 
# 1085
_M_deallocate_buckets(); 
# 1086
((_M_rehash_policy)._M_reset(__former_state)); 
# 1087
(_M_buckets) = __former_buckets; 
# 1088
(_M_bucket_count) = __former_bucket_count; 
# 1089
}  
# 1090
__builtin_memset(_M_buckets, 0, (_M_bucket_count) * sizeof(__bucket_type)); 
# 1092
throw; 
# 1093
}  
# 1094
}  
# 1095
} 
# 1097
template< class _Key, class _Value, class 
# 1098
_Alloc, class _ExtractKey, class _Equal, class 
# 1099
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1100
_Traits> 
# 1103
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(const _Hashtable &__ht) : __hashtable_base(__ht), __map_base(__ht), __rehash_base(__ht), __hashtable_alloc(__node_alloc_traits::_S_select_on_copy((__ht._M_node_allocator()))), _M_buckets((nullptr)), _M_bucket_count((__ht._M_bucket_count)), _M_element_count((__ht._M_element_count)), _M_rehash_policy((__ht._M_rehash_policy)) 
# 1113
{ 
# 1114
_M_assign(__ht, [this](const __node_type *
# 1115
__n) 
# 1116
{ return ((this)->_M_allocate_node((__n->_M_v()))); } ); 
# 1117
} 
# 1119
template< class _Key, class _Value, class 
# 1120
_Alloc, class _ExtractKey, class _Equal, class 
# 1121
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1122
_Traits> 
# 1125
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(_Hashtable &&__ht) noexcept : __hashtable_base(__ht), __map_base(__ht), __rehash_base(__ht), __hashtable_alloc(::std::move((__ht._M_base_alloc()))), _M_buckets(((__ht._M_buckets))), _M_bucket_count((__ht._M_bucket_count)), _M_before_begin(((__ht._M_before_begin)._M_nxt)), _M_element_count((__ht._M_element_count)), _M_rehash_policy((__ht._M_rehash_policy)) 
# 1135
{ 
# 1137
if ((__ht._M_uses_single_bucket())) 
# 1138
{ 
# 1139
(_M_buckets) = (&(_M_single_bucket)); 
# 1140
(_M_single_bucket) = (__ht._M_single_bucket); 
# 1141
}  
# 1145
if (_M_begin()) { 
# 1146
((_M_buckets)[_M_bucket_index(_M_begin())]) = (&(_M_before_begin)); }  
# 1148
(__ht._M_reset()); 
# 1149
} 
# 1151
template< class _Key, class _Value, class 
# 1152
_Alloc, class _ExtractKey, class _Equal, class 
# 1153
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1154
_Traits> 
# 1157
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(const _Hashtable &__ht, const allocator_type &__a) : __hashtable_base(__ht), __map_base(__ht), __rehash_base(__ht), __hashtable_alloc((__node_alloc_type)__a), _M_buckets(), _M_bucket_count((__ht._M_bucket_count)), _M_element_count((__ht._M_element_count)), _M_rehash_policy((__ht._M_rehash_policy)) 
# 1166
{ 
# 1167
_M_assign(__ht, [this](const __node_type *
# 1168
__n) 
# 1169
{ return ((this)->_M_allocate_node((__n->_M_v()))); } ); 
# 1170
} 
# 1172
template< class _Key, class _Value, class 
# 1173
_Alloc, class _ExtractKey, class _Equal, class 
# 1174
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1175
_Traits> 
# 1178
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(_Hashtable &&__ht, const allocator_type &__a) : __hashtable_base(__ht), __map_base(__ht), __rehash_base(__ht), __hashtable_alloc((__node_alloc_type)__a), _M_buckets((nullptr)), _M_bucket_count((__ht._M_bucket_count)), _M_element_count((__ht._M_element_count)), _M_rehash_policy((__ht._M_rehash_policy)) 
# 1187
{ 
# 1188
if ((__ht._M_node_allocator()) == (this->_M_node_allocator())) 
# 1189
{ 
# 1190
if ((__ht._M_uses_single_bucket())) 
# 1191
{ 
# 1192
(_M_buckets) = (&(_M_single_bucket)); 
# 1193
(_M_single_bucket) = (__ht._M_single_bucket); 
# 1194
} else { 
# 1196
(_M_buckets) = (__ht._M_buckets); }  
# 1198
((_M_before_begin)._M_nxt) = ((__ht._M_before_begin)._M_nxt); 
# 1201
if (_M_begin()) { 
# 1202
((_M_buckets)[_M_bucket_index(_M_begin())]) = (&(_M_before_begin)); }  
# 1203
(__ht._M_reset()); 
# 1204
} else 
# 1206
{ 
# 1207
_M_assign(__ht, [this](__node_type *
# 1208
__n) 
# 1209
{ 
# 1210
return ((this)->_M_allocate_node(::std::move_if_noexcept((__n->_M_v())))); 
# 1212
} ); 
# 1213
(__ht.clear()); 
# 1214
}  
# 1215
} 
# 1217
template< class _Key, class _Value, class 
# 1218
_Alloc, class _ExtractKey, class _Equal, class 
# 1219
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1220
_Traits> 
# 1223
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::~_Hashtable() noexcept 
# 1224
{ 
# 1225
clear(); 
# 1226
_M_deallocate_buckets(); 
# 1227
} 
# 1229
template< class _Key, class _Value, class 
# 1230
_Alloc, class _ExtractKey, class _Equal, class 
# 1231
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1232
_Traits> void 
# 1236
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::swap(_Hashtable &__x) noexcept(__node_alloc_traits::_S_nothrow_swap()) 
# 1238
{ 
# 1242
(this->_M_swap(__x)); 
# 1244
::std::__alloc_on_swap((this->_M_node_allocator()), (__x._M_node_allocator())); 
# 1245
::std::swap(_M_rehash_policy, (__x._M_rehash_policy)); 
# 1248
if ((this->_M_uses_single_bucket())) 
# 1249
{ 
# 1250
if (!(__x._M_uses_single_bucket())) 
# 1251
{ 
# 1252
(_M_buckets) = (__x._M_buckets); 
# 1253
(__x._M_buckets) = (&(__x._M_single_bucket)); 
# 1254
}  
# 1255
} else { 
# 1256
if ((__x._M_uses_single_bucket())) 
# 1257
{ 
# 1258
(__x._M_buckets) = (_M_buckets); 
# 1259
(_M_buckets) = (&(_M_single_bucket)); 
# 1260
} else { 
# 1262
::std::swap(_M_buckets, (__x._M_buckets)); }  }  
# 1264
::std::swap(_M_bucket_count, (__x._M_bucket_count)); 
# 1265
::std::swap(((_M_before_begin)._M_nxt), ((__x._M_before_begin)._M_nxt)); 
# 1266
::std::swap(_M_element_count, (__x._M_element_count)); 
# 1267
::std::swap(_M_single_bucket, (__x._M_single_bucket)); 
# 1271
if (_M_begin()) { 
# 1272
((_M_buckets)[_M_bucket_index(_M_begin())]) = (&(_M_before_begin)); }  
# 1274
if ((__x._M_begin())) { 
# 1275
((__x._M_buckets)[(__x._M_bucket_index((__x._M_begin())))]) = (&(__x._M_before_begin)); }  
# 1277
} 
# 1279
template< class _Key, class _Value, class 
# 1280
_Alloc, class _ExtractKey, class _Equal, class 
# 1281
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1282
_Traits> void 
# 1286
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__rehash_policy(const _RehashPolicy &__pol) 
# 1287
{ 
# 1288
auto __do_rehash = (__pol._M_need_rehash(_M_bucket_count, _M_element_count, 0)); 
# 1290
if (__do_rehash.first) { 
# 1291
_M_rehash((__do_rehash.second), ((_M_rehash_policy)._M_state())); }  
# 1292
(_M_rehash_policy) = __pol; 
# 1293
} 
# 1295
template< class _Key, class _Value, class 
# 1296
_Alloc, class _ExtractKey, class _Equal, class 
# 1297
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1298
_Traits> auto 
# 1302
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::find(const key_type &__k)->iterator 
# 1304
{ 
# 1305
__hash_code __code = (this->_M_hash_code(__k)); 
# 1306
::std::size_t __n = _M_bucket_index(__k, __code); 
# 1307
__node_type *__p = _M_find_node(__n, __k, __code); 
# 1308
return (__p) ? (iterator)__p : end(); 
# 1309
} 
# 1311
template< class _Key, class _Value, class 
# 1312
_Alloc, class _ExtractKey, class _Equal, class 
# 1313
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1314
_Traits> auto 
# 1318
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::find(const key_type &__k) const->const_iterator 
# 1320
{ 
# 1321
__hash_code __code = (this->_M_hash_code(__k)); 
# 1322
::std::size_t __n = _M_bucket_index(__k, __code); 
# 1323
__node_type *__p = _M_find_node(__n, __k, __code); 
# 1324
return (__p) ? (const_iterator)__p : end(); 
# 1325
} 
# 1327
template< class _Key, class _Value, class 
# 1328
_Alloc, class _ExtractKey, class _Equal, class 
# 1329
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1330
_Traits> auto 
# 1334
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::count(const key_type &__k) const->size_type 
# 1336
{ 
# 1337
__hash_code __code = (this->_M_hash_code(__k)); 
# 1338
::std::size_t __n = _M_bucket_index(__k, __code); 
# 1339
__node_type *__p = _M_bucket_begin(__n); 
# 1340
if (!__p) { 
# 1341
return 0; }  
# 1343
::std::size_t __result = (0); 
# 1344
for (; ; __p = (__p->_M_next())) 
# 1345
{ 
# 1346
if ((this->_M_equals(__k, __code, __p))) { 
# 1347
++__result; } else { 
# 1348
if (__result) { 
# 1352
break; }  }  
# 1353
if ((!(__p->_M_nxt)) || (_M_bucket_index((__p->_M_next())) != __n)) { 
# 1354
break; }  
# 1355
}  
# 1356
return __result; 
# 1357
} 
# 1359
template< class _Key, class _Value, class 
# 1360
_Alloc, class _ExtractKey, class _Equal, class 
# 1361
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1362
_Traits> auto 
# 1366
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::equal_range(const key_type &__k)->pair< typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator, typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator>  
# 1368
{ 
# 1369
__hash_code __code = (this->_M_hash_code(__k)); 
# 1370
::std::size_t __n = _M_bucket_index(__k, __code); 
# 1371
__node_type *__p = _M_find_node(__n, __k, __code); 
# 1373
if (__p) 
# 1374
{ 
# 1375
__node_type *__p1 = (__p->_M_next()); 
# 1376
while (__p1 && (_M_bucket_index(__p1) == __n) && (this->_M_equals(__k, __code, __p1))) { 
# 1378
__p1 = (__p1->_M_next()); }  
# 1380
return ::std::make_pair((iterator)__p, (iterator)__p1); 
# 1381
} else { 
# 1383
return ::std::make_pair(end(), end()); }  
# 1384
} 
# 1386
template< class _Key, class _Value, class 
# 1387
_Alloc, class _ExtractKey, class _Equal, class 
# 1388
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1389
_Traits> auto 
# 1393
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::equal_range(const key_type &__k) const->pair< typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::const_iterator, typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::const_iterator>  
# 1395
{ 
# 1396
__hash_code __code = (this->_M_hash_code(__k)); 
# 1397
::std::size_t __n = _M_bucket_index(__k, __code); 
# 1398
__node_type *__p = _M_find_node(__n, __k, __code); 
# 1400
if (__p) 
# 1401
{ 
# 1402
__node_type *__p1 = (__p->_M_next()); 
# 1403
while (__p1 && (_M_bucket_index(__p1) == __n) && (this->_M_equals(__k, __code, __p1))) { 
# 1405
__p1 = (__p1->_M_next()); }  
# 1407
return ::std::make_pair((const_iterator)__p, (const_iterator)__p1); 
# 1408
} else { 
# 1410
return ::std::make_pair(end(), end()); }  
# 1411
} 
# 1415
template< class _Key, class _Value, class 
# 1416
_Alloc, class _ExtractKey, class _Equal, class 
# 1417
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1418
_Traits> auto 
# 1422
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_find_before_node(size_type __n, const key_type &__k, __hash_code 
# 1423
__code) const->__node_base * 
# 1425
{ 
# 1426
__node_base *__prev_p = (_M_buckets)[__n]; 
# 1427
if (!__prev_p) { 
# 1428
return nullptr; }  
# 1430
for (__node_type *__p = static_cast< __node_type *>(__prev_p->_M_nxt); ; __p = (__p->_M_next())) 
# 1432
{ 
# 1433
if ((this->_M_equals(__k, __code, __p))) { 
# 1434
return __prev_p; }  
# 1436
if ((!(__p->_M_nxt)) || (_M_bucket_index((__p->_M_next())) != __n)) { 
# 1437
break; }  
# 1438
__prev_p = __p; 
# 1439
}  
# 1440
return nullptr; 
# 1441
} 
# 1443
template< class _Key, class _Value, class 
# 1444
_Alloc, class _ExtractKey, class _Equal, class 
# 1445
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1446
_Traits> void 
# 1450
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert_bucket_begin(size_type __bkt, __node_type *__node) 
# 1451
{ 
# 1452
if ((_M_buckets)[__bkt]) 
# 1453
{ 
# 1456
(__node->_M_nxt) = (((_M_buckets)[__bkt])->_M_nxt); 
# 1457
(((_M_buckets)[__bkt])->_M_nxt) = __node; 
# 1458
} else 
# 1460
{ 
# 1464
(__node->_M_nxt) = ((_M_before_begin)._M_nxt); 
# 1465
((_M_before_begin)._M_nxt) = __node; 
# 1466
if (__node->_M_nxt) { 
# 1469
((_M_buckets)[_M_bucket_index((__node->_M_next()))]) = __node; }  
# 1470
((_M_buckets)[__bkt]) = (&(_M_before_begin)); 
# 1471
}  
# 1472
} 
# 1474
template< class _Key, class _Value, class 
# 1475
_Alloc, class _ExtractKey, class _Equal, class 
# 1476
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1477
_Traits> void 
# 1481
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_remove_bucket_begin(size_type __bkt, __node_type *__next, size_type 
# 1482
__next_bkt) 
# 1483
{ 
# 1484
if ((!__next) || (__next_bkt != __bkt)) 
# 1485
{ 
# 1488
if (__next) { 
# 1489
((_M_buckets)[__next_bkt]) = ((_M_buckets)[__bkt]); }  
# 1492
if ((&(_M_before_begin)) == ((_M_buckets)[__bkt])) { 
# 1493
((_M_before_begin)._M_nxt) = __next; }  
# 1494
((_M_buckets)[__bkt]) = nullptr; 
# 1495
}  
# 1496
} 
# 1498
template< class _Key, class _Value, class 
# 1499
_Alloc, class _ExtractKey, class _Equal, class 
# 1500
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1501
_Traits> auto 
# 1505
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_get_previous_node(size_type __bkt, __node_base *__n)->__node_base * 
# 1507
{ 
# 1508
__node_base *__prev_n = (_M_buckets)[__bkt]; 
# 1509
while ((__prev_n->_M_nxt) != __n) { 
# 1510
__prev_n = (__prev_n->_M_nxt); }  
# 1511
return __prev_n; 
# 1512
} 
# 1514
template< class _Key, class _Value, class 
# 1515
_Alloc, class _ExtractKey, class _Equal, class 
# 1516
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1517
_Traits> 
# 1518
template< class ..._Args> auto 
# 1522
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_emplace(::std::true_type, _Args &&...__args)->pair< typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator, bool>  
# 1524
{ 
# 1526
__node_type *__node = (this->_M_allocate_node(::std::forward< _Args> (__args)...)); 
# 1527
const key_type &__k = (this->_M_extract())((__node->_M_v())); 
# 1528
__hash_code __code; 
# 1529
try 
# 1530
{ 
# 1531
__code = (this->_M_hash_code(__k)); 
# 1532
} 
# 1533
catch (...) 
# 1534
{ 
# 1535
(this->_M_deallocate_node(__node)); 
# 1536
throw; 
# 1537
}  
# 1539
size_type __bkt = _M_bucket_index(__k, __code); 
# 1540
if (__node_type *__p = _M_find_node(__bkt, __k, __code)) 
# 1541
{ 
# 1543
(this->_M_deallocate_node(__node)); 
# 1544
return ::std::make_pair((iterator)__p, false); 
# 1545
}  
# 1548
return ::std::make_pair(_M_insert_unique_node(__bkt, __code, __node), true); 
# 1550
} 
# 1552
template< class _Key, class _Value, class 
# 1553
_Alloc, class _ExtractKey, class _Equal, class 
# 1554
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1555
_Traits> 
# 1556
template< class ..._Args> auto 
# 1560
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_emplace(const_iterator __hint, ::std::false_type, _Args &&...__args)->iterator 
# 1562
{ 
# 1564
__node_type *__node = (this->_M_allocate_node(::std::forward< _Args> (__args)...)); 
# 1567
__hash_code __code; 
# 1568
try 
# 1569
{ 
# 1570
__code = (this->_M_hash_code((this->_M_extract())((__node->_M_v())))); 
# 1571
} 
# 1572
catch (...) 
# 1573
{ 
# 1574
(this->_M_deallocate_node(__node)); 
# 1575
throw; 
# 1576
}  
# 1578
return _M_insert_multi_node((__hint._M_cur), __code, __node); 
# 1579
} 
# 1581
template< class _Key, class _Value, class 
# 1582
_Alloc, class _ExtractKey, class _Equal, class 
# 1583
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1584
_Traits> auto 
# 1588
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert_unique_node(size_type __bkt, __hash_code __code, __node_type *
# 1589
__node)->iterator 
# 1591
{ 
# 1592
const __rehash_state &__saved_state = ((_M_rehash_policy)._M_state()); 
# 1593
::std::pair< bool, unsigned long>  __do_rehash = ((_M_rehash_policy)._M_need_rehash(_M_bucket_count, _M_element_count, 1)); 
# 1596
try 
# 1597
{ 
# 1598
if (__do_rehash.first) 
# 1599
{ 
# 1600
_M_rehash(__do_rehash.second, __saved_state); 
# 1601
__bkt = _M_bucket_index((this->_M_extract())((__node->_M_v())), __code); 
# 1602
}  
# 1604
(this->_M_store_code(__node, __code)); 
# 1607
_M_insert_bucket_begin(__bkt, __node); 
# 1608
++(_M_element_count); 
# 1609
return (iterator)__node; 
# 1610
} 
# 1611
catch (...) 
# 1612
{ 
# 1613
(this->_M_deallocate_node(__node)); 
# 1614
throw; 
# 1615
}  
# 1616
} 
# 1620
template< class _Key, class _Value, class 
# 1621
_Alloc, class _ExtractKey, class _Equal, class 
# 1622
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1623
_Traits> auto 
# 1627
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert_multi_node(__node_type *__hint, __hash_code __code, __node_type *
# 1628
__node)->iterator 
# 1630
{ 
# 1631
const __rehash_state &__saved_state = ((_M_rehash_policy)._M_state()); 
# 1632
::std::pair< bool, unsigned long>  __do_rehash = ((_M_rehash_policy)._M_need_rehash(_M_bucket_count, _M_element_count, 1)); 
# 1635
try 
# 1636
{ 
# 1637
if (__do_rehash.first) { 
# 1638
_M_rehash(__do_rehash.second, __saved_state); }  
# 1640
(this->_M_store_code(__node, __code)); 
# 1641
const key_type &__k = (this->_M_extract())((__node->_M_v())); 
# 1642
size_type __bkt = _M_bucket_index(__k, __code); 
# 1646
__node_base *__prev = (__builtin_expect(__hint != nullptr, false) && (this->_M_equals(__k, __code, __hint))) ? __hint : _M_find_before_node(__bkt, __k, __code); 
# 1651
if (__prev) 
# 1652
{ 
# 1654
(__node->_M_nxt) = (__prev->_M_nxt); 
# 1655
(__prev->_M_nxt) = __node; 
# 1656
if (__builtin_expect(__prev == __hint, false)) { 
# 1659
if ((__node->_M_nxt) && (!(this->_M_equals(__k, __code, (__node->_M_next()))))) 
# 1661
{ 
# 1662
size_type __next_bkt = _M_bucket_index((__node->_M_next())); 
# 1663
if (__next_bkt != __bkt) { 
# 1664
((_M_buckets)[__next_bkt]) = __node; }  
# 1665
}  }  
# 1666
} else { 
# 1672
_M_insert_bucket_begin(__bkt, __node); }  
# 1673
++(_M_element_count); 
# 1674
return (iterator)__node; 
# 1675
} 
# 1676
catch (...) 
# 1677
{ 
# 1678
(this->_M_deallocate_node(__node)); 
# 1679
throw; 
# 1680
}  
# 1681
} 
# 1684
template< class _Key, class _Value, class 
# 1685
_Alloc, class _ExtractKey, class _Equal, class 
# 1686
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1687
_Traits> 
# 1688
template< class _Arg, class _NodeGenerator> auto 
# 1692
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert(_Arg &&__v, const _NodeGenerator &__node_gen, ::std::true_type)->pair< typename ::std::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator, bool>  
# 1694
{ 
# 1695
const key_type &__k = (this->_M_extract())(__v); 
# 1696
__hash_code __code = (this->_M_hash_code(__k)); 
# 1697
size_type __bkt = _M_bucket_index(__k, __code); 
# 1699
__node_type *__n = _M_find_node(__bkt, __k, __code); 
# 1700
if (__n) { 
# 1701
return ::std::make_pair((iterator)__n, false); }  
# 1703
__n = __node_gen(::std::forward< _Arg> (__v)); 
# 1704
return ::std::make_pair(_M_insert_unique_node(__bkt, __code, __n), true); 
# 1705
} 
# 1708
template< class _Key, class _Value, class 
# 1709
_Alloc, class _ExtractKey, class _Equal, class 
# 1710
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1711
_Traits> 
# 1712
template< class _Arg, class _NodeGenerator> auto 
# 1716
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert(const_iterator __hint, _Arg &&__v, const _NodeGenerator &
# 1717
__node_gen, ::std::false_type)->iterator 
# 1719
{ 
# 1722
__hash_code __code = (this->_M_hash_code((this->_M_extract())(__v))); 
# 1725
__node_type *__node = __node_gen(::std::forward< _Arg> (__v)); 
# 1727
return _M_insert_multi_node((__hint._M_cur), __code, __node); 
# 1728
} 
# 1730
template< class _Key, class _Value, class 
# 1731
_Alloc, class _ExtractKey, class _Equal, class 
# 1732
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1733
_Traits> auto 
# 1737
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::erase(const_iterator __it)->iterator 
# 1739
{ 
# 1740
__node_type *__n = ((__it._M_cur)); 
# 1741
::std::size_t __bkt = _M_bucket_index(__n); 
# 1746
__node_base *__prev_n = _M_get_previous_node(__bkt, __n); 
# 1747
return _M_erase(__bkt, __prev_n, __n); 
# 1748
} 
# 1750
template< class _Key, class _Value, class 
# 1751
_Alloc, class _ExtractKey, class _Equal, class 
# 1752
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1753
_Traits> auto 
# 1757
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_erase(size_type __bkt, __node_base *__prev_n, __node_type *__n)->iterator 
# 1759
{ 
# 1760
if (__prev_n == ((_M_buckets)[__bkt])) { 
# 1761
_M_remove_bucket_begin(__bkt, (__n->_M_next()), (__n->_M_nxt) ? _M_bucket_index((__n->_M_next())) : 0); } else { 
# 1763
if (__n->_M_nxt) 
# 1764
{ 
# 1765
size_type __next_bkt = _M_bucket_index((__n->_M_next())); 
# 1766
if (__next_bkt != __bkt) { 
# 1767
((_M_buckets)[__next_bkt]) = __prev_n; }  
# 1768
}  }  
# 1770
(__prev_n->_M_nxt) = (__n->_M_nxt); 
# 1771
iterator __result((__n->_M_next())); 
# 1772
(this->_M_deallocate_node(__n)); 
# 1773
--(_M_element_count); 
# 1775
return __result; 
# 1776
} 
# 1778
template< class _Key, class _Value, class 
# 1779
_Alloc, class _ExtractKey, class _Equal, class 
# 1780
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1781
_Traits> auto 
# 1785
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_erase(::std::true_type, const key_type &__k)->size_type 
# 1787
{ 
# 1788
__hash_code __code = (this->_M_hash_code(__k)); 
# 1789
::std::size_t __bkt = _M_bucket_index(__k, __code); 
# 1792
__node_base *__prev_n = _M_find_before_node(__bkt, __k, __code); 
# 1793
if (!__prev_n) { 
# 1794
return 0; }  
# 1797
__node_type *__n = static_cast< __node_type *>(__prev_n->_M_nxt); 
# 1798
_M_erase(__bkt, __prev_n, __n); 
# 1799
return 1; 
# 1800
} 
# 1802
template< class _Key, class _Value, class 
# 1803
_Alloc, class _ExtractKey, class _Equal, class 
# 1804
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1805
_Traits> auto 
# 1809
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_erase(::std::false_type, const key_type &__k)->size_type 
# 1811
{ 
# 1812
__hash_code __code = (this->_M_hash_code(__k)); 
# 1813
::std::size_t __bkt = _M_bucket_index(__k, __code); 
# 1816
__node_base *__prev_n = _M_find_before_node(__bkt, __k, __code); 
# 1817
if (!__prev_n) { 
# 1818
return 0; }  
# 1826
__node_type *__n = static_cast< __node_type *>(__prev_n->_M_nxt); 
# 1827
__node_type *__n_last = __n; 
# 1828
::std::size_t __n_last_bkt = __bkt; 
# 1829
do 
# 1830
{ 
# 1831
__n_last = (__n_last->_M_next()); 
# 1832
if (!__n_last) { 
# 1833
break; }  
# 1834
__n_last_bkt = _M_bucket_index(__n_last); 
# 1835
} 
# 1836
while ((__n_last_bkt == __bkt) && (this->_M_equals(__k, __code, __n_last))); 
# 1839
size_type __result = (0); 
# 1840
do 
# 1841
{ 
# 1842
__node_type *__p = (__n->_M_next()); 
# 1843
(this->_M_deallocate_node(__n)); 
# 1844
__n = __p; 
# 1845
++__result; 
# 1846
--(_M_element_count); 
# 1847
} 
# 1848
while (__n != __n_last); 
# 1850
if (__prev_n == ((_M_buckets)[__bkt])) { 
# 1851
_M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt); } else { 
# 1852
if (__n_last && (__n_last_bkt != __bkt)) { 
# 1853
((_M_buckets)[__n_last_bkt]) = __prev_n; }  }  
# 1854
(__prev_n->_M_nxt) = __n_last; 
# 1855
return __result; 
# 1856
} 
# 1858
template< class _Key, class _Value, class 
# 1859
_Alloc, class _ExtractKey, class _Equal, class 
# 1860
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1861
_Traits> auto 
# 1865
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::erase(const_iterator __first, const_iterator __last)->iterator 
# 1867
{ 
# 1868
__node_type *__n = ((__first._M_cur)); 
# 1869
__node_type *__last_n = ((__last._M_cur)); 
# 1870
if (__n == __last_n) { 
# 1871
return (iterator)__n; }  
# 1873
::std::size_t __bkt = _M_bucket_index(__n); 
# 1875
__node_base *__prev_n = _M_get_previous_node(__bkt, __n); 
# 1876
bool __is_bucket_begin = __n == _M_bucket_begin(__bkt); 
# 1877
::std::size_t __n_bkt = __bkt; 
# 1878
for (; ;) 
# 1879
{ 
# 1880
do 
# 1881
{ 
# 1882
__node_type *__tmp = __n; 
# 1883
__n = (__n->_M_next()); 
# 1884
(this->_M_deallocate_node(__tmp)); 
# 1885
--(_M_element_count); 
# 1886
if (!__n) { 
# 1887
break; }  
# 1888
__n_bkt = _M_bucket_index(__n); 
# 1889
} 
# 1890
while ((__n != __last_n) && (__n_bkt == __bkt)); 
# 1891
if (__is_bucket_begin) { 
# 1892
_M_remove_bucket_begin(__bkt, __n, __n_bkt); }  
# 1893
if (__n == __last_n) { 
# 1894
break; }  
# 1895
__is_bucket_begin = true; 
# 1896
__bkt = __n_bkt; 
# 1897
}  
# 1899
if (__n && ((__n_bkt != __bkt) || __is_bucket_begin)) { 
# 1900
((_M_buckets)[__n_bkt]) = __prev_n; }  
# 1901
(__prev_n->_M_nxt) = __n; 
# 1902
return (iterator)__n; 
# 1903
} 
# 1905
template< class _Key, class _Value, class 
# 1906
_Alloc, class _ExtractKey, class _Equal, class 
# 1907
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1908
_Traits> void 
# 1912
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::clear() noexcept 
# 1913
{ 
# 1914
(this->_M_deallocate_nodes(_M_begin())); 
# 1915
__builtin_memset(_M_buckets, 0, (_M_bucket_count) * sizeof(__bucket_type)); 
# 1916
(_M_element_count) = 0; 
# 1917
((_M_before_begin)._M_nxt) = nullptr; 
# 1918
} 
# 1920
template< class _Key, class _Value, class 
# 1921
_Alloc, class _ExtractKey, class _Equal, class 
# 1922
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1923
_Traits> void 
# 1927
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::rehash(size_type __n) 
# 1928
{ 
# 1929
const __rehash_state &__saved_state = ((_M_rehash_policy)._M_state()); 
# 1930
::std::size_t __buckets = ::std::max(((_M_rehash_policy)._M_bkt_for_elements((_M_element_count) + 1)), __n); 
# 1933
__buckets = ((_M_rehash_policy)._M_next_bkt(__buckets)); 
# 1935
if (__buckets != (_M_bucket_count)) { 
# 1936
_M_rehash(__buckets, __saved_state); } else { 
# 1939
((_M_rehash_policy)._M_reset(__saved_state)); }  
# 1940
} 
# 1942
template< class _Key, class _Value, class 
# 1943
_Alloc, class _ExtractKey, class _Equal, class 
# 1944
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1945
_Traits> void 
# 1949
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_rehash(size_type __n, const __rehash_state &__state) 
# 1950
{ 
# 1951
try 
# 1952
{ 
# 1953
_M_rehash_aux(__n, __unique_keys()); 
# 1954
} 
# 1955
catch (...) 
# 1956
{ 
# 1959
((_M_rehash_policy)._M_reset(__state)); 
# 1960
throw; 
# 1961
}  
# 1962
} 
# 1965
template< class _Key, class _Value, class 
# 1966
_Alloc, class _ExtractKey, class _Equal, class 
# 1967
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1968
_Traits> void 
# 1972
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_rehash_aux(size_type __n, ::std::true_type) 
# 1973
{ 
# 1974
__bucket_type *__new_buckets = _M_allocate_buckets(__n); 
# 1975
__node_type *__p = _M_begin(); 
# 1976
((_M_before_begin)._M_nxt) = nullptr; 
# 1977
::std::size_t __bbegin_bkt = (0); 
# 1978
while (__p) 
# 1979
{ 
# 1980
__node_type *__next = (__p->_M_next()); 
# 1981
::std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n); 
# 1982
if (!(__new_buckets[__bkt])) 
# 1983
{ 
# 1984
(__p->_M_nxt) = ((_M_before_begin)._M_nxt); 
# 1985
((_M_before_begin)._M_nxt) = __p; 
# 1986
(__new_buckets[__bkt]) = (&(_M_before_begin)); 
# 1987
if (__p->_M_nxt) { 
# 1988
(__new_buckets[__bbegin_bkt]) = __p; }  
# 1989
__bbegin_bkt = __bkt; 
# 1990
} else 
# 1992
{ 
# 1993
(__p->_M_nxt) = ((__new_buckets[__bkt])->_M_nxt); 
# 1994
((__new_buckets[__bkt])->_M_nxt) = __p; 
# 1995
}  
# 1996
__p = __next; 
# 1997
}  
# 1999
_M_deallocate_buckets(); 
# 2000
(_M_bucket_count) = __n; 
# 2001
(_M_buckets) = __new_buckets; 
# 2002
} 
# 2006
template< class _Key, class _Value, class 
# 2007
_Alloc, class _ExtractKey, class _Equal, class 
# 2008
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 2009
_Traits> void 
# 2013
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_rehash_aux(size_type __n, ::std::false_type) 
# 2014
{ 
# 2015
__bucket_type *__new_buckets = _M_allocate_buckets(__n); 
# 2017
__node_type *__p = _M_begin(); 
# 2018
((_M_before_begin)._M_nxt) = nullptr; 
# 2019
::std::size_t __bbegin_bkt = (0); 
# 2020
::std::size_t __prev_bkt = (0); 
# 2021
__node_type *__prev_p = (nullptr); 
# 2022
bool __check_bucket = false; 
# 2024
while (__p) 
# 2025
{ 
# 2026
__node_type *__next = (__p->_M_next()); 
# 2027
::std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n); 
# 2029
if (__prev_p && (__prev_bkt == __bkt)) 
# 2030
{ 
# 2034
(__p->_M_nxt) = (__prev_p->_M_nxt); 
# 2035
(__prev_p->_M_nxt) = __p; 
# 2042
__check_bucket = true; 
# 2043
} else 
# 2045
{ 
# 2046
if (__check_bucket) 
# 2047
{ 
# 2050
if (__prev_p->_M_nxt) 
# 2051
{ 
# 2052
::std::size_t __next_bkt = __hash_code_base::_M_bucket_index((__prev_p->_M_next()), __n); 
# 2055
if (__next_bkt != __prev_bkt) { 
# 2056
(__new_buckets[__next_bkt]) = __prev_p; }  
# 2057
}  
# 2058
__check_bucket = false; 
# 2059
}  
# 2061
if (!(__new_buckets[__bkt])) 
# 2062
{ 
# 2063
(__p->_M_nxt) = ((_M_before_begin)._M_nxt); 
# 2064
((_M_before_begin)._M_nxt) = __p; 
# 2065
(__new_buckets[__bkt]) = (&(_M_before_begin)); 
# 2066
if (__p->_M_nxt) { 
# 2067
(__new_buckets[__bbegin_bkt]) = __p; }  
# 2068
__bbegin_bkt = __bkt; 
# 2069
} else 
# 2071
{ 
# 2072
(__p->_M_nxt) = ((__new_buckets[__bkt])->_M_nxt); 
# 2073
((__new_buckets[__bkt])->_M_nxt) = __p; 
# 2074
}  
# 2075
}  
# 2076
__prev_p = __p; 
# 2077
__prev_bkt = __bkt; 
# 2078
__p = __next; 
# 2079
}  
# 2081
if (__check_bucket && (__prev_p->_M_nxt)) 
# 2082
{ 
# 2083
::std::size_t __next_bkt = __hash_code_base::_M_bucket_index((__prev_p->_M_next()), __n); 
# 2085
if (__next_bkt != __prev_bkt) { 
# 2086
(__new_buckets[__next_bkt]) = __prev_p; }  
# 2087
}  
# 2089
_M_deallocate_buckets(); 
# 2090
(_M_bucket_count) = __n; 
# 2091
(_M_buckets) = __new_buckets; 
# 2092
} 
# 2095
}
# 33 "/usr/include/c++/5/bits/unordered_map.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 38
template< bool _Cache> using __umap_traits = __detail::_Hashtable_traits< _Cache, false, true> ; 
# 41
template< class _Key, class 
# 42
_Tp, class 
# 43
_Hash = hash< _Key> , class 
# 44
_Pred = equal_to< _Key> , class 
# 45
_Alloc = allocator< pair< const _Key, _Tp> > , class 
# 46
_Tr = __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > using __umap_hashtable = _Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, _Tr> ; 
# 55
template< bool _Cache> using __ummap_traits = __detail::_Hashtable_traits< _Cache, false, false> ; 
# 58
template< class _Key, class 
# 59
_Tp, class 
# 60
_Hash = hash< _Key> , class 
# 61
_Pred = equal_to< _Key> , class 
# 62
_Alloc = allocator< pair< const _Key, _Tp> > , class 
# 63
_Tr = __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > using __ummap_hashtable = _Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, _Tr> ; 
# 94 "/usr/include/c++/5/bits/unordered_map.h" 3
template< class _Key, class _Tp, class 
# 95
_Hash = hash< _Key> , class 
# 96
_Pred = equal_to< _Key> , class 
# 97
_Alloc = allocator< pair< const _Key, _Tp> > > 
# 98
class unordered_map { 
# 100
typedef __umap_hashtable< _Key, _Tp, _Hash, _Pred, _Alloc, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> >  _Hashtable; 
# 101
_Hashtable _M_h; 
# 107
public: typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::key_type key_type; 
# 108
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type value_type; 
# 109
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::mapped_type mapped_type; 
# 110
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::hasher hasher; 
# 111
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::key_equal key_equal; 
# 112
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::allocator_type allocator_type; 
# 117
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::pointer pointer; 
# 118
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_pointer const_pointer; 
# 119
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::reference reference; 
# 120
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_reference const_reference; 
# 121
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::iterator iterator; 
# 122
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_iterator const_iterator; 
# 123
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::local_iterator local_iterator; 
# 124
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_local_iterator const_local_iterator; 
# 125
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::size_type size_type; 
# 126
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::difference_type difference_type; 
# 132
unordered_map() = default;
# 142 "/usr/include/c++/5/bits/unordered_map.h" 3
explicit unordered_map(size_type __n, const hasher &
# 143
__hf = hasher(), const key_equal &
# 144
__eql = key_equal(), const allocator_type &
# 145
__a = allocator_type()) : _M_h(__n, __hf, __eql, __a) 
# 147
{ } 
# 162 "/usr/include/c++/5/bits/unordered_map.h" 3
template< class _InputIterator> 
# 163
unordered_map(_InputIterator __first, _InputIterator __last, size_type 
# 164
__n = 0, const hasher &
# 165
__hf = hasher(), const key_equal &
# 166
__eql = key_equal(), const allocator_type &
# 167
__a = allocator_type()) : _M_h(__first, __last, __n, __hf, __eql, __a) 
# 169
{ } 
# 172
unordered_map(const unordered_map &) = default;
# 175
unordered_map(unordered_map &&) = default;
# 182
explicit unordered_map(const allocator_type &__a) : _M_h(__a) 
# 184
{ } 
# 191
unordered_map(const unordered_map &__umap, const allocator_type &
# 192
__a) : _M_h((__umap._M_h), __a) 
# 194
{ } 
# 201
unordered_map(unordered_map &&__umap, const allocator_type &
# 202
__a) : _M_h(std::move((__umap._M_h)), __a) 
# 204
{ } 
# 217 "/usr/include/c++/5/bits/unordered_map.h" 3
unordered_map(initializer_list< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type>  __l, size_type 
# 218
__n = 0, const hasher &
# 219
__hf = hasher(), const key_equal &
# 220
__eql = key_equal(), const allocator_type &
# 221
__a = allocator_type()) : _M_h(__l, __n, __hf, __eql, __a) 
# 223
{ } 
# 225
unordered_map(size_type __n, const allocator_type &__a) : unordered_map(__n, hasher(), key_equal(), __a) 
# 227
{ } 
# 229
unordered_map(size_type __n, const hasher &__hf, const allocator_type &
# 230
__a) : unordered_map(__n, __hf, key_equal(), __a) 
# 232
{ } 
# 234
template< class _InputIterator> 
# 235
unordered_map(_InputIterator __first, _InputIterator __last, size_type 
# 236
__n, const allocator_type &
# 237
__a) : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) 
# 239
{ } 
# 241
template< class _InputIterator> 
# 242
unordered_map(_InputIterator __first, _InputIterator __last, size_type 
# 243
__n, const hasher &__hf, const allocator_type &
# 244
__a) : unordered_map(__first, __last, __n, __hf, key_equal(), __a) 
# 246
{ } 
# 248
unordered_map(initializer_list< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type>  __l, size_type 
# 249
__n, const allocator_type &
# 250
__a) : unordered_map(__l, __n, hasher(), key_equal(), __a) 
# 252
{ } 
# 254
unordered_map(initializer_list< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type>  __l, size_type 
# 255
__n, const hasher &__hf, const allocator_type &
# 256
__a) : unordered_map(__l, __n, __hf, key_equal(), __a) 
# 258
{ } 
# 262
unordered_map &operator=(const unordered_map &) = default;
# 266
unordered_map &operator=(unordered_map &&) = default;
# 280 "/usr/include/c++/5/bits/unordered_map.h" 3
unordered_map &operator=(initializer_list< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type>  __l) 
# 281
{ 
# 282
(_M_h) = __l; 
# 283
return *this; 
# 284
} 
# 289
allocator_type get_allocator() const noexcept 
# 290
{ return ((_M_h).get_allocator()); } 
# 296
bool empty() const noexcept 
# 297
{ return ((_M_h).empty()); } 
# 301
size_type size() const noexcept 
# 302
{ return ((_M_h).size()); } 
# 306
size_type max_size() const noexcept 
# 307
{ return ((_M_h).max_size()); } 
# 316
iterator begin() noexcept 
# 317
{ return ((_M_h).begin()); } 
# 325
const_iterator begin() const noexcept 
# 326
{ return ((_M_h).begin()); } 
# 329
const_iterator cbegin() const noexcept 
# 330
{ return ((_M_h).begin()); } 
# 338
iterator end() noexcept 
# 339
{ return ((_M_h).end()); } 
# 347
const_iterator end() const noexcept 
# 348
{ return ((_M_h).end()); } 
# 351
const_iterator cend() const noexcept 
# 352
{ return ((_M_h).end()); } 
# 377 "/usr/include/c++/5/bits/unordered_map.h" 3
template< class ..._Args> pair< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::iterator, bool>  
# 379
emplace(_Args &&...__args) 
# 380
{ return ((_M_h).emplace(std::forward< _Args> (__args)...)); } 
# 408 "/usr/include/c++/5/bits/unordered_map.h" 3
template< class ..._Args> iterator 
# 410
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 411
{ return ((_M_h).emplace_hint(__pos, std::forward< _Args> (__args)...)); } 
# 432 "/usr/include/c++/5/bits/unordered_map.h" 3
pair< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::iterator, bool>  insert(const value_type &__x) 
# 433
{ return ((_M_h).insert(__x)); } 
# 435
template< class _Pair, class  = typename enable_if< is_constructible< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type, _Pair &&> ::value> ::type> pair< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::iterator, bool>  
# 439
insert(_Pair &&__x) 
# 440
{ return ((_M_h).insert(std::forward< _Pair> (__x))); } 
# 466 "/usr/include/c++/5/bits/unordered_map.h" 3
iterator insert(const_iterator __hint, const value_type &__x) 
# 467
{ return ((_M_h).insert(__hint, __x)); } 
# 469
template< class _Pair, class  = typename enable_if< is_constructible< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type, _Pair &&> ::value> ::type> iterator 
# 473
insert(const_iterator __hint, _Pair &&__x) 
# 474
{ return ((_M_h).insert(__hint, std::forward< _Pair> (__x))); } 
# 486 "/usr/include/c++/5/bits/unordered_map.h" 3
template< class _InputIterator> void 
# 488
insert(_InputIterator __first, _InputIterator __last) 
# 489
{ ((_M_h).insert(__first, __last)); } 
# 499 "/usr/include/c++/5/bits/unordered_map.h" 3
void insert(initializer_list< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type>  __l) 
# 500
{ ((_M_h).insert(__l)); } 
# 517 "/usr/include/c++/5/bits/unordered_map.h" 3
iterator erase(const_iterator __position) 
# 518
{ return ((_M_h).erase(__position)); } 
# 522
iterator erase(iterator __position) 
# 523
{ return ((_M_h).erase(__position)); } 
# 539 "/usr/include/c++/5/bits/unordered_map.h" 3
size_type erase(const key_type &__x) 
# 540
{ return ((_M_h).erase(__x)); } 
# 557 "/usr/include/c++/5/bits/unordered_map.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 558
{ return ((_M_h).erase(__first, __last)); } 
# 567
void clear() noexcept 
# 568
{ ((_M_h).clear()); } 
# 581 "/usr/include/c++/5/bits/unordered_map.h" 3
void swap(unordered_map &__x) noexcept(noexcept(((_M_h).swap((__x._M_h))))) 
# 583
{ ((_M_h).swap((__x._M_h))); } 
# 590
hasher hash_function() const 
# 591
{ return ((_M_h).hash_function()); } 
# 596
key_equal key_eq() const 
# 597
{ return ((_M_h).key_eq()); } 
# 614 "/usr/include/c++/5/bits/unordered_map.h" 3
iterator find(const key_type &__x) 
# 615
{ return ((_M_h).find(__x)); } 
# 618
const_iterator find(const key_type &__x) const 
# 619
{ return ((_M_h).find(__x)); } 
# 632 "/usr/include/c++/5/bits/unordered_map.h" 3
size_type count(const key_type &__x) const 
# 633
{ return ((_M_h).count(__x)); } 
# 645 "/usr/include/c++/5/bits/unordered_map.h" 3
pair< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::iterator, typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::iterator>  equal_range(const key_type &__x) 
# 646
{ return ((_M_h).equal_range(__x)); } 
# 649
pair< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_iterator, typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_iterator>  equal_range(const key_type &__x) const 
# 650
{ return ((_M_h).equal_range(__x)); } 
# 667 "/usr/include/c++/5/bits/unordered_map.h" 3
mapped_type &operator[](const key_type &__k) 
# 668
{ return (_M_h)[__k]; } 
# 671
mapped_type &operator[](key_type &&__k) 
# 672
{ return (_M_h)[std::move(__k)]; } 
# 684 "/usr/include/c++/5/bits/unordered_map.h" 3
mapped_type &at(const key_type &__k) 
# 685
{ return ((_M_h).at(__k)); } 
# 688
const mapped_type &at(const key_type &__k) const 
# 689
{ return ((_M_h).at(__k)); } 
# 696
size_type bucket_count() const noexcept 
# 697
{ return ((_M_h).bucket_count()); } 
# 701
size_type max_bucket_count() const noexcept 
# 702
{ return ((_M_h).max_bucket_count()); } 
# 710
size_type bucket_size(size_type __n) const 
# 711
{ return ((_M_h).bucket_size(__n)); } 
# 719
size_type bucket(const key_type &__key) const 
# 720
{ return ((_M_h).bucket(__key)); } 
# 729
local_iterator begin(size_type __n) 
# 730
{ return ((_M_h).begin(__n)); } 
# 740 "/usr/include/c++/5/bits/unordered_map.h" 3
const_local_iterator begin(size_type __n) const 
# 741
{ return ((_M_h).begin(__n)); } 
# 744
const_local_iterator cbegin(size_type __n) const 
# 745
{ return ((_M_h).cbegin(__n)); } 
# 755 "/usr/include/c++/5/bits/unordered_map.h" 3
local_iterator end(size_type __n) 
# 756
{ return ((_M_h).end(__n)); } 
# 766 "/usr/include/c++/5/bits/unordered_map.h" 3
const_local_iterator end(size_type __n) const 
# 767
{ return ((_M_h).end(__n)); } 
# 770
const_local_iterator cend(size_type __n) const 
# 771
{ return ((_M_h).cend(__n)); } 
# 778
float load_factor() const noexcept 
# 779
{ return ((_M_h).load_factor()); } 
# 784
float max_load_factor() const noexcept 
# 785
{ return ((_M_h).max_load_factor()); } 
# 792
void max_load_factor(float __z) 
# 793
{ ((_M_h).max_load_factor(__z)); } 
# 803 "/usr/include/c++/5/bits/unordered_map.h" 3
void rehash(size_type __n) 
# 804
{ ((_M_h).rehash(__n)); } 
# 814 "/usr/include/c++/5/bits/unordered_map.h" 3
void reserve(size_type __n) 
# 815
{ ((_M_h).reserve(__n)); } 
# 817
template< class _Key1, class _Tp1, class _Hash1, class _Pred1, class 
# 818
_Alloc1> friend bool 
# 817
operator==(const std::unordered_map< _Key1, _Tp1, _Hash1, _Pred1, _Alloc1>  &, const std::unordered_map< _Key1, _Tp1, _Hash1, _Pred1, _Alloc1>  &); 
# 822
}; 
# 847 "/usr/include/c++/5/bits/unordered_map.h" 3
template< class _Key, class _Tp, class 
# 848
_Hash = hash< _Key> , class 
# 849
_Pred = equal_to< _Key> , class 
# 850
_Alloc = allocator< pair< const _Key, _Tp> > > 
# 851
class unordered_multimap { 
# 853
typedef __ummap_hashtable< _Key, _Tp, _Hash, _Pred, _Alloc, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> >  _Hashtable; 
# 854
_Hashtable _M_h; 
# 860
public: typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::key_type key_type; 
# 861
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type value_type; 
# 862
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::mapped_type mapped_type; 
# 863
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::hasher hasher; 
# 864
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::key_equal key_equal; 
# 865
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::allocator_type allocator_type; 
# 870
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::pointer pointer; 
# 871
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_pointer const_pointer; 
# 872
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::reference reference; 
# 873
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_reference const_reference; 
# 874
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::iterator iterator; 
# 875
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_iterator const_iterator; 
# 876
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::local_iterator local_iterator; 
# 877
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_local_iterator const_local_iterator; 
# 878
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::size_type size_type; 
# 879
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::difference_type difference_type; 
# 885
unordered_multimap() = default;
# 895 "/usr/include/c++/5/bits/unordered_map.h" 3
explicit unordered_multimap(size_type __n, const hasher &
# 896
__hf = hasher(), const key_equal &
# 897
__eql = key_equal(), const allocator_type &
# 898
__a = allocator_type()) : _M_h(__n, __hf, __eql, __a) 
# 900
{ } 
# 915 "/usr/include/c++/5/bits/unordered_map.h" 3
template< class _InputIterator> 
# 916
unordered_multimap(_InputIterator __first, _InputIterator __last, size_type 
# 917
__n = 0, const hasher &
# 918
__hf = hasher(), const key_equal &
# 919
__eql = key_equal(), const allocator_type &
# 920
__a = allocator_type()) : _M_h(__first, __last, __n, __hf, __eql, __a) 
# 922
{ } 
# 925
unordered_multimap(const unordered_multimap &) = default;
# 928
unordered_multimap(unordered_multimap &&) = default;
# 935
explicit unordered_multimap(const allocator_type &__a) : _M_h(__a) 
# 937
{ } 
# 944
unordered_multimap(const unordered_multimap &__ummap, const allocator_type &
# 945
__a) : _M_h((__ummap._M_h), __a) 
# 947
{ } 
# 954
unordered_multimap(unordered_multimap &&__ummap, const allocator_type &
# 955
__a) : _M_h(std::move((__ummap._M_h)), __a) 
# 957
{ } 
# 970 "/usr/include/c++/5/bits/unordered_map.h" 3
unordered_multimap(initializer_list< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type>  __l, size_type 
# 971
__n = 0, const hasher &
# 972
__hf = hasher(), const key_equal &
# 973
__eql = key_equal(), const allocator_type &
# 974
__a = allocator_type()) : _M_h(__l, __n, __hf, __eql, __a) 
# 976
{ } 
# 978
unordered_multimap(size_type __n, const allocator_type &__a) : unordered_multimap(__n, hasher(), key_equal(), __a) 
# 980
{ } 
# 982
unordered_multimap(size_type __n, const hasher &__hf, const allocator_type &
# 983
__a) : unordered_multimap(__n, __hf, key_equal(), __a) 
# 985
{ } 
# 987
template< class _InputIterator> 
# 988
unordered_multimap(_InputIterator __first, _InputIterator __last, size_type 
# 989
__n, const allocator_type &
# 990
__a) : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) 
# 992
{ } 
# 994
template< class _InputIterator> 
# 995
unordered_multimap(_InputIterator __first, _InputIterator __last, size_type 
# 996
__n, const hasher &__hf, const allocator_type &
# 997
__a) : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) 
# 999
{ } 
# 1001
unordered_multimap(initializer_list< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type>  __l, size_type 
# 1002
__n, const allocator_type &
# 1003
__a) : unordered_multimap(__l, __n, hasher(), key_equal(), __a) 
# 1005
{ } 
# 1007
unordered_multimap(initializer_list< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type>  __l, size_type 
# 1008
__n, const hasher &__hf, const allocator_type &
# 1009
__a) : unordered_multimap(__l, __n, __hf, key_equal(), __a) 
# 1011
{ } 
# 1015
unordered_multimap &operator=(const unordered_multimap &) = default;
# 1019
unordered_multimap &operator=(unordered_multimap &&) = default;
# 1033 "/usr/include/c++/5/bits/unordered_map.h" 3
unordered_multimap &operator=(initializer_list< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type>  __l) 
# 1034
{ 
# 1035
(_M_h) = __l; 
# 1036
return *this; 
# 1037
} 
# 1042
allocator_type get_allocator() const noexcept 
# 1043
{ return ((_M_h).get_allocator()); } 
# 1049
bool empty() const noexcept 
# 1050
{ return ((_M_h).empty()); } 
# 1054
size_type size() const noexcept 
# 1055
{ return ((_M_h).size()); } 
# 1059
size_type max_size() const noexcept 
# 1060
{ return ((_M_h).max_size()); } 
# 1069
iterator begin() noexcept 
# 1070
{ return ((_M_h).begin()); } 
# 1078
const_iterator begin() const noexcept 
# 1079
{ return ((_M_h).begin()); } 
# 1082
const_iterator cbegin() const noexcept 
# 1083
{ return ((_M_h).begin()); } 
# 1091
iterator end() noexcept 
# 1092
{ return ((_M_h).end()); } 
# 1100
const_iterator end() const noexcept 
# 1101
{ return ((_M_h).end()); } 
# 1104
const_iterator cend() const noexcept 
# 1105
{ return ((_M_h).end()); } 
# 1125 "/usr/include/c++/5/bits/unordered_map.h" 3
template< class ..._Args> iterator 
# 1127
emplace(_Args &&...__args) 
# 1128
{ return ((_M_h).emplace(std::forward< _Args> (__args)...)); } 
# 1152 "/usr/include/c++/5/bits/unordered_map.h" 3
template< class ..._Args> iterator 
# 1154
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 1155
{ return ((_M_h).emplace_hint(__pos, std::forward< _Args> (__args)...)); } 
# 1168 "/usr/include/c++/5/bits/unordered_map.h" 3
iterator insert(const value_type &__x) 
# 1169
{ return ((_M_h).insert(__x)); } 
# 1171
template< class _Pair, class  = typename enable_if< is_constructible< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type, _Pair &&> ::value> ::type> iterator 
# 1175
insert(_Pair &&__x) 
# 1176
{ return ((_M_h).insert(std::forward< _Pair> (__x))); } 
# 1200 "/usr/include/c++/5/bits/unordered_map.h" 3
iterator insert(const_iterator __hint, const value_type &__x) 
# 1201
{ return ((_M_h).insert(__hint, __x)); } 
# 1203
template< class _Pair, class  = typename enable_if< is_constructible< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type, _Pair &&> ::value> ::type> iterator 
# 1207
insert(const_iterator __hint, _Pair &&__x) 
# 1208
{ return ((_M_h).insert(__hint, std::forward< _Pair> (__x))); } 
# 1220 "/usr/include/c++/5/bits/unordered_map.h" 3
template< class _InputIterator> void 
# 1222
insert(_InputIterator __first, _InputIterator __last) 
# 1223
{ ((_M_h).insert(__first, __last)); } 
# 1234 "/usr/include/c++/5/bits/unordered_map.h" 3
void insert(initializer_list< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::value_type>  __l) 
# 1235
{ ((_M_h).insert(__l)); } 
# 1252 "/usr/include/c++/5/bits/unordered_map.h" 3
iterator erase(const_iterator __position) 
# 1253
{ return ((_M_h).erase(__position)); } 
# 1257
iterator erase(iterator __position) 
# 1258
{ return ((_M_h).erase(__position)); } 
# 1273 "/usr/include/c++/5/bits/unordered_map.h" 3
size_type erase(const key_type &__x) 
# 1274
{ return ((_M_h).erase(__x)); } 
# 1292 "/usr/include/c++/5/bits/unordered_map.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 1293
{ return ((_M_h).erase(__first, __last)); } 
# 1302
void clear() noexcept 
# 1303
{ ((_M_h).clear()); } 
# 1316 "/usr/include/c++/5/bits/unordered_map.h" 3
void swap(unordered_multimap &__x) noexcept(noexcept(((_M_h).swap((__x._M_h))))) 
# 1318
{ ((_M_h).swap((__x._M_h))); } 
# 1325
hasher hash_function() const 
# 1326
{ return ((_M_h).hash_function()); } 
# 1331
key_equal key_eq() const 
# 1332
{ return ((_M_h).key_eq()); } 
# 1349 "/usr/include/c++/5/bits/unordered_map.h" 3
iterator find(const key_type &__x) 
# 1350
{ return ((_M_h).find(__x)); } 
# 1353
const_iterator find(const key_type &__x) const 
# 1354
{ return ((_M_h).find(__x)); } 
# 1363
size_type count(const key_type &__x) const 
# 1364
{ return ((_M_h).count(__x)); } 
# 1374 "/usr/include/c++/5/bits/unordered_map.h" 3
pair< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::iterator, typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::iterator>  equal_range(const key_type &__x) 
# 1375
{ return ((_M_h).equal_range(__x)); } 
# 1378
pair< typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_iterator, typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __detail::__is_noexcept_hash< _Key, _Hash> > > ::value> > ::const_iterator>  equal_range(const key_type &__x) const 
# 1379
{ return ((_M_h).equal_range(__x)); } 
# 1386
size_type bucket_count() const noexcept 
# 1387
{ return ((_M_h).bucket_count()); } 
# 1391
size_type max_bucket_count() const noexcept 
# 1392
{ return ((_M_h).max_bucket_count()); } 
# 1400
size_type bucket_size(size_type __n) const 
# 1401
{ return ((_M_h).bucket_size(__n)); } 
# 1409
size_type bucket(const key_type &__key) const 
# 1410
{ return ((_M_h).bucket(__key)); } 
# 1419
local_iterator begin(size_type __n) 
# 1420
{ return ((_M_h).begin(__n)); } 
# 1430 "/usr/include/c++/5/bits/unordered_map.h" 3
const_local_iterator begin(size_type __n) const 
# 1431
{ return ((_M_h).begin(__n)); } 
# 1434
const_local_iterator cbegin(size_type __n) const 
# 1435
{ return ((_M_h).cbegin(__n)); } 
# 1445 "/usr/include/c++/5/bits/unordered_map.h" 3
local_iterator end(size_type __n) 
# 1446
{ return ((_M_h).end(__n)); } 
# 1456 "/usr/include/c++/5/bits/unordered_map.h" 3
const_local_iterator end(size_type __n) const 
# 1457
{ return ((_M_h).end(__n)); } 
# 1460
const_local_iterator cend(size_type __n) const 
# 1461
{ return ((_M_h).cend(__n)); } 
# 1468
float load_factor() const noexcept 
# 1469
{ return ((_M_h).load_factor()); } 
# 1474
float max_load_factor() const noexcept 
# 1475
{ return ((_M_h).max_load_factor()); } 
# 1482
void max_load_factor(float __z) 
# 1483
{ ((_M_h).max_load_factor(__z)); } 
# 1493 "/usr/include/c++/5/bits/unordered_map.h" 3
void rehash(size_type __n) 
# 1494
{ ((_M_h).rehash(__n)); } 
# 1504 "/usr/include/c++/5/bits/unordered_map.h" 3
void reserve(size_type __n) 
# 1505
{ ((_M_h).reserve(__n)); } 
# 1507
template< class _Key1, class _Tp1, class _Hash1, class _Pred1, class 
# 1508
_Alloc1> friend bool 
# 1507
operator==(const std::unordered_multimap< _Key1, _Tp1, _Hash1, _Pred1, _Alloc1>  &, const std::unordered_multimap< _Key1, _Tp1, _Hash1, _Pred1, _Alloc1>  &); 
# 1514
}; 
# 1516
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline void 
# 1518
swap(unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 1519
__y) 
# 1520
{ (__x.swap(__y)); } 
# 1522
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline void 
# 1524
swap(unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 1525
__y) 
# 1526
{ (__x.swap(__y)); } 
# 1528
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool 
# 1530
operator==(const unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, const unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 1531
__y) 
# 1532
{ return ((__x._M_h)._M_equal((__y._M_h))); } 
# 1534
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool 
# 1536
operator!=(const unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, const unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 1537
__y) 
# 1538
{ return !(__x == __y); } 
# 1540
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool 
# 1542
operator==(const unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, const unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 1543
__y) 
# 1544
{ return ((__x._M_h)._M_equal((__y._M_h))); } 
# 1546
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool 
# 1548
operator!=(const unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, const unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 1549
__y) 
# 1550
{ return !(__x == __y); } 
# 1553
}
# 59 "/usr/include/opencv2/flann/lsh_table.h" 3
namespace cvflann { 
# 62
namespace lsh { 
# 69
typedef uint32_t FeatureIndex; 
# 72
typedef unsigned BucketKey; 
# 76
typedef std::vector< unsigned>  Bucket; 
# 82
struct LshStats { 
# 84
std::vector< unsigned>  bucket_sizes_; 
# 85
size_t n_buckets_; 
# 86
size_t bucket_size_mean_; 
# 87
size_t bucket_size_median_; 
# 88
size_t bucket_size_min_; 
# 89
size_t bucket_size_max_; 
# 90
size_t bucket_size_std_dev; 
# 93
std::vector< std::vector< unsigned> >  size_histogram_; 
# 94
}; 
# 101
inline std::ostream &operator<<(std::ostream &out, const LshStats &stats) 
# 102
{ 
# 103
int w = 20; 
# 104
(((((((((((((((((((((((((((((((((((((((((((((((((((((((out << ("Lsh Table Stats:\n"))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("N buckets : "))) << (stats.n_buckets_))) << ("\n"))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("mean size : "))) << (std::setiosflags(std::ios_base::left)))) << (stats.bucket_size_mean_))) << ("\n"))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("median size : "))) << (stats.bucket_size_median_))) << ("\n"))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("min size : "))) << (std::setiosflags(std::ios_base::left)))) << (stats.bucket_size_min_))) << ("\n"))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("max size : "))) << (std::setiosflags(std::ios_base::left)))) << (stats.bucket_size_max_)); 
# 113
(((((((((out << (std::endl))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("histogram : "))) << (std::setiosflags(std::ios_base::left))); 
# 115
for (std::vector< std::vector< unsigned> > ::const_iterator iterator = (stats.size_histogram_).begin(), end = (stats.size_histogram_).end(); (iterator != end); (++iterator)) { 
# 116
(((((((((((out << (((*iterator))[0]))) << ("-"))) << (((*iterator))[1]))) << (": "))) << (((*iterator))[2]))) << (",  ")); }  
# 118
return out; 
# 119
} 
# 129 "/usr/include/opencv2/flann/lsh_table.h" 3
template< class ElementType> 
# 130
class LshTable { 
# 136
public: typedef std::unordered_map< unsigned, std::vector< unsigned> >  BucketsSpace; 
# 143
typedef std::vector< std::vector< unsigned> >  BucketsSpeed; 
# 147
LshTable() 
# 148
{ 
# 149
(key_size_) = (0); 
# 150
(feature_size_) = (0); 
# 151
(speed_level_) = (kArray); 
# 152
} 
# 159
LshTable(unsigned feature_size, unsigned key_size) 
# 160
{ 
# 161
(feature_size_) = feature_size; 
# 162
(void)key_size; 
# 163
(((std::cerr << ("LSH is not implemented for that type"))) << (std::endl)); 
# 164
(0) ? static_cast< void>(0) : __assert_fail("0", "/usr/include/opencv2/flann/lsh_table.h", 164, __PRETTY_FUNCTION__); 
# 165
} 
# 171
void add(unsigned value, const ElementType *feature) 
# 172
{ 
# 174
BucketKey key = (BucketKey)getKey(feature); 
# 176
switch (speed_level_) { 
# 177
case kArray:  
# 179
(buckets_speed_)[key].push_back(value); 
# 180
break; 
# 181
case kBitsetHash:  
# 183
(key_bitset_).set(key); 
# 184
(buckets_space_)[key].push_back(value); 
# 185
break; 
# 186
case kHash:  
# 187
{ 
# 189
(buckets_space_)[key].push_back(value); 
# 190
break; 
# 191
} 
# 192
}  
# 193
} 
# 198
void add(Matrix< ElementType>  dataset) 
# 199
{ 
# 201
(buckets_space_).rehash(((buckets_space_).size() + (dataset.rows)) * (1.199999999999999956)); 
# 204
for (unsigned i = (0); i < (dataset.rows); ++i) { add(i, dataset[i]); }  
# 206
optimize(); 
# 207
} 
# 213
const Bucket *getBucketFromKey(BucketKey key) const 
# 214
{ 
# 216
switch (speed_level_) { 
# 217
case kArray:  
# 219
return &(buckets_speed_)[key]; 
# 220
break; 
# 221
case kBitsetHash:  
# 223
if ((key_bitset_).test(key)) { return &(((buckets_space_).find(key))->second); } else { 
# 224
return 0; }  
# 225
break; 
# 226
case kHash:  
# 227
{ 
# 229
std::unordered_map< unsigned, std::vector< unsigned> > ::const_iterator bucket_it, bucket_end = (buckets_space_).end(); 
# 230
bucket_it = (buckets_space_).find(key); 
# 232
if ((bucket_it == bucket_end)) { return 0; } else { 
# 233
return &(bucket_it->second); }  
# 234
break; 
# 235
} 
# 236
}  
# 237
return 0; 
# 238
} 
# 242
size_t getKey(const ElementType *) const 
# 243
{ 
# 244
(((std::cerr << ("LSH is not implemented for that type"))) << (std::endl)); 
# 245
(0) ? static_cast< void>(0) : __assert_fail("0", "/usr/include/opencv2/flann/lsh_table.h", 245, __PRETTY_FUNCTION__); 
# 246
return 1; 
# 247
} 
# 252
LshStats getStats() const; 
# 260
private: enum SpeedLevel { 
# 262
kArray, kBitsetHash, kHash
# 263
}; 
# 267
void initialize(size_t key_size) 
# 268
{ 
# 269
const size_t key_size_lower_bound = (1); 
# 271
const size_t key_size_upper_bound = (std::min)((sizeof(BucketKey) * (8)) + (1), sizeof(size_t) * (8)); 
# 272
if ((key_size < key_size_lower_bound) || (key_size >= key_size_upper_bound)) 
# 273
{ 
# 274
cv::error(cv::Error::StsBadArg, cv::format("Invalid key_size (=%d). Valid values for your system are %d <= key_size < %d.", (int)key_size, (int)key_size_lower_bound, (int)key_size_upper_bound), __func__, "/usr/include/opencv2/flann/lsh_table.h", 274); 
# 275
}  
# 277
(speed_level_) = (kHash); 
# 278
(key_size_) = ((unsigned)key_size); 
# 279
} 
# 283
void optimize() 
# 284
{ 
# 286
if ((speed_level_) == (kArray)) { return; }  
# 289
if ((buckets_space_).size() > ((((size_t)1) << (key_size_)) / (2))) { 
# 290
(speed_level_) = (kArray); 
# 292
(buckets_speed_).resize(((size_t)1) << (key_size_)); 
# 293
for (std::unordered_map< unsigned, std::vector< unsigned> > ::const_iterator key_bucket = (buckets_space_).begin(); (key_bucket != ((buckets_space_).end())); (++key_bucket)) { (((buckets_speed_)[key_bucket->first]) = (key_bucket->second)); }  
# 296
(buckets_space_).clear(); 
# 297
return; 
# 298
}  
# 302
if ((((((std::max((buckets_space_).size(), (buckets_speed_).size()) * (8)) * (3)) * sizeof(BucketKey)) / (10)) >= (((size_t)1) << (key_size_))) || ((key_size_) <= (32))) 
# 303
{ 
# 304
(speed_level_) = (kBitsetHash); 
# 305
(key_bitset_).resize(((size_t)1) << (key_size_)); 
# 306
(key_bitset_).reset(); 
# 308
for (std::unordered_map< unsigned, std::vector< unsigned> > ::const_iterator key_bucket = (buckets_space_).begin(); (key_bucket != ((buckets_space_).end())); (++key_bucket)) { (key_bitset_).set(key_bucket->first); }  
# 309
} else 
# 310
{ 
# 311
(speed_level_) = (kHash); 
# 312
(key_bitset_).clear(); 
# 313
}  
# 314
} 
# 318
BucketsSpeed buckets_speed_; 
# 322
BucketsSpace buckets_space_; 
# 325
SpeedLevel speed_level_; 
# 330
DynamicBitset key_bitset_; 
# 334
unsigned key_size_; 
# 336
unsigned feature_size_; 
# 342
std::vector< unsigned long>  mask_; 
# 343
}; 
# 349
template<> inline LshTable< unsigned char> ::LshTable(unsigned feature_size, unsigned subsignature_size) 
# 350
{ 
# 351
(feature_size_) = feature_size; 
# 352
this->initialize(subsignature_size); 
# 354
((mask_) = std::vector< unsigned long> ((((feature_size * sizeof(char)) + sizeof(size_t)) - (1)) / sizeof(size_t), 0)); 
# 357
std::vector< int>  indices(feature_size * (8)); 
# 358
for (size_t i = (0); i < (feature_size * (8)); ++i) { indices[i] = ((int)i); }  
# 360
cv::randShuffle(indices); 
# 366
for (unsigned i = (0); i < (key_size_); ++i) { 
# 367
size_t index = indices[i]; 
# 370
size_t divisor = ((8) * sizeof(size_t)); 
# 371
size_t idx = index / divisor; 
# 372
(mask_)[idx] |= (((size_t)1) << (index % divisor)); 
# 373
}  
# 389 "/usr/include/opencv2/flann/lsh_table.h" 3
} 
# 395
template<> inline size_t LshTable< unsigned char> ::getKey(const unsigned char *feature) const 
# 396
{ 
# 400
const size_t *feature_block_ptr = reinterpret_cast< const size_t *>((const void *)feature); 
# 405
size_t subsignature = (0); 
# 406
size_t bit_index = (1); 
# 408
for (unsigned i = (0); i < (feature_size_); i += sizeof(size_t)) { 
# 410
size_t feature_block; 
# 411
if (i <= ((feature_size_) - sizeof(size_t))) 
# 412
{ 
# 413
feature_block = (*feature_block_ptr); 
# 414
} else 
# 416
{ 
# 417
size_t tmp = (0); 
# 418
memcpy(&tmp, feature_block_ptr, (feature_size_) - i); 
# 419
feature_block = tmp; 
# 420
}  
# 421
size_t mask_block = (mask_)[i / sizeof(size_t)]; 
# 422
while (mask_block) { 
# 424
size_t lowest_bit = mask_block & (-((ptrdiff_t)mask_block)); 
# 426
subsignature += ((feature_block & lowest_bit) ? bit_index : (0)); 
# 428
mask_block ^= lowest_bit; 
# 430
bit_index <<= 1; 
# 431
}  
# 433
++feature_block_ptr; 
# 434
}  
# 435
return subsignature; 
# 436
} 
# 439
template<> inline LshStats LshTable< unsigned char> ::getStats() const 
# 440
{ 
# 441
LshStats stats; 
# 442
(stats.bucket_size_mean_) = (0); 
# 443
if ((buckets_speed_).empty() && (buckets_space_).empty()) { 
# 444
(stats.n_buckets_) = (0); 
# 445
(stats.bucket_size_median_) = (0); 
# 446
(stats.bucket_size_min_) = (0); 
# 447
(stats.bucket_size_max_) = (0); 
# 448
return stats; 
# 449
}  
# 451
if (!(buckets_speed_).empty()) { 
# 452
for (std::vector< std::vector< unsigned> > ::const_iterator pbucket = (buckets_speed_).begin(); (pbucket != ((buckets_speed_).end())); (++pbucket)) { 
# 453
(stats.bucket_sizes_).push_back((FeatureIndex)pbucket->size()); 
# 454
(stats.bucket_size_mean_) += pbucket->size(); 
# 455
}  
# 456
(stats.bucket_size_mean_) /= (buckets_speed_).size(); 
# 457
(stats.n_buckets_) = (buckets_speed_).size(); 
# 458
} else 
# 459
{ 
# 460
for (std::unordered_map< unsigned, std::vector< unsigned> > ::const_iterator x = (buckets_space_).begin(); (x != ((buckets_space_).end())); (++x)) { 
# 461
(stats.bucket_sizes_).push_back((FeatureIndex)(x->second).size()); 
# 462
(stats.bucket_size_mean_) += (x->second).size(); 
# 463
}  
# 464
(stats.bucket_size_mean_) /= (buckets_space_).size(); 
# 465
(stats.n_buckets_) = (buckets_space_).size(); 
# 466
}  
# 468
std::sort((stats.bucket_sizes_).begin(), (stats.bucket_sizes_).end()); 
# 473
(stats.bucket_size_median_) = ((stats.bucket_sizes_)[(stats.bucket_sizes_).size() / (2)]); 
# 474
(stats.bucket_size_min_) = ((stats.bucket_sizes_).front()); 
# 475
(stats.bucket_size_max_) = ((stats.bucket_sizes_).back()); 
# 483
unsigned bin_start = (0); 
# 484
unsigned bin_end = (20); 
# 485
bool is_new_bin = true; 
# 486
for (std::vector< unsigned> ::iterator iterator = (stats.bucket_sizes_).begin(), end = (stats.bucket_sizes_).end(); (iterator != end);) { 
# 488
if ((*iterator) < bin_end) { 
# 489
if (is_new_bin) { 
# 490
(stats.size_histogram_).push_back(std::vector< unsigned> (3, 0)); 
# 491
((stats.size_histogram_).back())[0] = bin_start; 
# 492
((stats.size_histogram_).back())[1] = (bin_end - (1)); 
# 493
is_new_bin = false; 
# 494
}  
# 495
++((stats.size_histogram_).back())[2]; 
# 496
(++iterator); 
# 497
} else 
# 498
{ 
# 499
bin_start += (20); 
# 500
bin_end += (20); 
# 501
is_new_bin = true; 
# 502
}  }  
# 504
return stats; 
# 505
} 
# 508
}
# 509
}
# 54 "/usr/include/opencv2/flann/lsh_index.h" 3
namespace cvflann { 
# 57
struct LshIndexParams : public IndexParams { 
# 59
LshIndexParams(unsigned table_number = 12, unsigned key_size = 20, unsigned multi_probe_level = 2) 
# 60
{ 
# 61
(((*this)["algorithm"]) = (FLANN_INDEX_LSH)); 
# 63
(((*this)["table_number"]) = table_number); 
# 65
(((*this)["key_size"]) = key_size); 
# 67
(((*this)["multi_probe_level"]) = multi_probe_level); 
# 68
} 
# 69
}; 
# 77
template< class Distance> 
# 78
class LshIndex : public NNIndex< Distance>  { 
# 81
public: typedef typename Distance::ElementType ElementType; 
# 82
typedef typename Distance::ResultType DistanceType; 
# 89
LshIndex(const Matrix< typename Distance::ElementType>  &input_data, const ::cvflann::IndexParams &params = ::cvflann::LshIndexParams(), Distance 
# 90
d = Distance()) : dataset_(input_data), index_params_(params), distance_(d) 
# 92
{ 
# 95
(table_number_) = ((unsigned)get_param< int> (index_params_, "table_number", 12)); 
# 96
(key_size_) = ((unsigned)get_param< int> (index_params_, "key_size", 20)); 
# 97
(multi_probe_level_) = ((unsigned)get_param< int> (index_params_, "multi_probe_level", 2)); 
# 99
(feature_size_) = ((unsigned)((dataset_).cols)); 
# 100
fill_xor_mask(0, key_size_, multi_probe_level_, xor_masks_); 
# 101
} 
# 104
LshIndex(const LshIndex &); 
# 105
LshIndex &operator=(const LshIndex &); 
# 110
void buildIndex() 
# 111
{ 
# 112
((tables_).resize(table_number_)); 
# 113
for (unsigned i = (0); i < (table_number_); ++i) { 
# 114
::cvflann::lsh::LshTable< typename Distance::ElementType>  &table = (tables_)[i]; 
# 115
table = ::cvflann::lsh::LshTable< typename Distance::ElementType> (feature_size_, key_size_); 
# 118
(table.add(dataset_)); 
# 119
}  
# 120
} 
# 122
::cvflann::flann_algorithm_t getType() const 
# 123
{ 
# 124
return FLANN_INDEX_LSH; 
# 125
} 
# 128
void saveIndex(::FILE *stream) 
# 129
{ 
# 130
save_value(stream, table_number_); 
# 131
save_value(stream, key_size_); 
# 132
save_value(stream, multi_probe_level_); 
# 133
save_value(stream, dataset_); 
# 134
} 
# 136
void loadIndex(::FILE *stream) 
# 137
{ 
# 138
load_value(stream, table_number_); 
# 139
load_value(stream, key_size_); 
# 140
load_value(stream, multi_probe_level_); 
# 141
load_value(stream, dataset_); 
# 143
buildIndex(); 
# 145
(index_params_)["algorithm"] = getType(); 
# 146
(((index_params_)["table_number"]) = (table_number_)); 
# 147
(((index_params_)["key_size"]) = (key_size_)); 
# 148
(((index_params_)["multi_probe_level"]) = (multi_probe_level_)); 
# 149
} 
# 154
::size_t size() const 
# 155
{ 
# 156
return (dataset_).rows; 
# 157
} 
# 162
::size_t veclen() const 
# 163
{ 
# 164
return feature_size_; 
# 165
} 
# 171
int usedMemory() const 
# 172
{ 
# 173
return (int)(((dataset_).rows) * sizeof(int)); 
# 174
} 
# 177
::cvflann::IndexParams getParameters() const 
# 178
{ 
# 179
return index_params_; 
# 180
} 
# 190 "/usr/include/opencv2/flann/lsh_index.h" 3
virtual void knnSearch(const Matrix< typename Distance::ElementType>  &queries, ::cvflann::Matrix< int>  &indices, Matrix< typename Distance::ResultType>  &dists, int knn, const ::cvflann::SearchParams &params) 
# 191
{ 
# 192
((queries.cols) == veclen()) ? static_cast< void>(0) : __assert_fail("queries.cols == veclen()", "/usr/include/opencv2/flann/lsh_index.h", 192, __PRETTY_FUNCTION__); 
# 193
((indices.rows) >= (queries.rows)) ? static_cast< void>(0) : __assert_fail("indices.rows >= queries.rows", "/usr/include/opencv2/flann/lsh_index.h", 193, __PRETTY_FUNCTION__); 
# 194
((dists.rows) >= (queries.rows)) ? static_cast< void>(0) : __assert_fail("dists.rows >= queries.rows", "/usr/include/opencv2/flann/lsh_index.h", 194, __PRETTY_FUNCTION__); 
# 195
(((int)(indices.cols)) >= knn) ? static_cast< void>(0) : __assert_fail("int(indices.cols) >= knn", "/usr/include/opencv2/flann/lsh_index.h", 195, __PRETTY_FUNCTION__); 
# 196
(((int)(dists.cols)) >= knn) ? static_cast< void>(0) : __assert_fail("int(dists.cols) >= knn", "/usr/include/opencv2/flann/lsh_index.h", 196, __PRETTY_FUNCTION__); 
# 199
KNNUniqueResultSet< typename Distance::ResultType>  resultSet(knn); 
# 200
for (::size_t i = (0); i < (queries.rows); i++) { 
# 201
(resultSet.clear()); 
# 202
std::fill_n(indices[i], knn, -1); 
# 203
::std::fill_n(dists[i], knn, std::numeric_limits< typename Distance::ResultType> ::max()); 
# 204
findNeighbors(resultSet, queries[i], params); 
# 205
if (get_param(params, "sorted", true)) { (resultSet.sortAndCopy(indices[i], dists[i], knn)); } else { 
# 206
(resultSet.copy(indices[i], dists[i], knn)); }  
# 207
}  
# 208
} 
# 220 "/usr/include/opencv2/flann/lsh_index.h" 3
void findNeighbors(ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, const ::cvflann::SearchParams &) 
# 221
{ 
# 222
getNeighbors(vec, result); 
# 223
} 
# 228
private: typedef ::std::pair< float, unsigned>  ScoreIndexPair; 
# 229
struct SortScoreIndexPairOnSecond { 
# 231
bool operator()(const ScoreIndexPair &left, const ScoreIndexPair &right) const 
# 232
{ 
# 233
return (left.second) < (right.second); 
# 234
} 
# 235
}; 
# 243
void fill_xor_mask(::cvflann::lsh::BucketKey key, int lowest_index, unsigned level, ::std::vector< unsigned>  &
# 244
xor_masks) 
# 245
{ 
# 246
xor_masks.push_back(key); 
# 247
if (level == (0)) { return; }  
# 248
for (int index = lowest_index - 1; index >= 0; --index) { 
# 250
::cvflann::lsh::BucketKey new_key = key | (1 << index); 
# 251
fill_xor_mask(new_key, index, level - (1), xor_masks); 
# 252
}  
# 253
} 
# 263 "/usr/include/opencv2/flann/lsh_index.h" 3
void getNeighbors(const ElementType *vec, bool, float radius, bool do_k, unsigned k_nn, float &) 
# 265
{ 
# 266
static ::std::vector< ::std::pair< float, unsigned> >  score_index_heap; 
# 268
if (do_k) { 
# 269
unsigned worst_score = std::numeric_limits< unsigned> ::max(); 
# 270
typename ::std::vector< ::cvflann::lsh::LshTable< typename Distance::ElementType> > ::const_iterator table = ((tables_).begin()); 
# 271
typename ::std::vector< ::cvflann::lsh::LshTable< typename Distance::ElementType> > ::const_iterator table_end = ((tables_).end()); 
# 272
for (; table != table_end; ++table) { 
# 273
::size_t key = (table->getKey)(vec); 
# 274
::std::vector< unsigned> ::const_iterator xor_mask = (xor_masks_).begin(); 
# 275
::std::vector< unsigned> ::const_iterator xor_mask_end = (xor_masks_).end(); 
# 276
for (; (xor_mask != xor_mask_end); (++xor_mask)) { { 
# 277
::size_t sub_key = key ^ ((*xor_mask)); 
# 278
const ::cvflann::lsh::Bucket *bucket = (table->getBucketFromKey)(sub_key); 
# 279
if (bucket == (0)) { continue; }  
# 282
::std::vector< unsigned> ::const_iterator training_index = bucket->begin(); 
# 283
::std::vector< unsigned> ::const_iterator last_training_index = bucket->end(); 
# 284
DistanceType hamming_distance; 
# 287
for (; (training_index < last_training_index); (++training_index)) { 
# 288
hamming_distance = (distance_)(vec, (dataset_)[(*training_index)], ((dataset_).cols)); 
# 290
if (hamming_distance < worst_score) { 
# 292
score_index_heap.push_back(ScoreIndexPair(hamming_distance, training_index)); 
# 293
std::push_heap(score_index_heap.begin(), score_index_heap.end()); 
# 295
if (score_index_heap.size() > ((unsigned)k_nn)) { 
# 297
std::pop_heap(score_index_heap.begin(), score_index_heap.end()); 
# 298
score_index_heap.pop_back(); 
# 300
worst_score = (score_index_heap.front().first); 
# 301
}  
# 302
}  
# 303
}  
# 304
} }  
# 305
}  
# 306
} else 
# 307
{ 
# 308
typename ::std::vector< ::cvflann::lsh::LshTable< typename Distance::ElementType> > ::const_iterator table = ((tables_).begin()); 
# 309
typename ::std::vector< ::cvflann::lsh::LshTable< typename Distance::ElementType> > ::const_iterator table_end = ((tables_).end()); 
# 310
for (; table != table_end; ++table) { 
# 311
::size_t key = (table->getKey)(vec); 
# 312
::std::vector< unsigned> ::const_iterator xor_mask = (xor_masks_).begin(); 
# 313
::std::vector< unsigned> ::const_iterator xor_mask_end = (xor_masks_).end(); 
# 314
for (; (xor_mask != xor_mask_end); (++xor_mask)) { { 
# 315
::size_t sub_key = key ^ ((*xor_mask)); 
# 316
const ::cvflann::lsh::Bucket *bucket = (table->getBucketFromKey)(sub_key); 
# 317
if (bucket == (0)) { continue; }  
# 320
::std::vector< unsigned> ::const_iterator training_index = bucket->begin(); 
# 321
::std::vector< unsigned> ::const_iterator last_training_index = bucket->end(); 
# 322
DistanceType hamming_distance; 
# 325
for (; (training_index < last_training_index); (++training_index)) { 
# 327
hamming_distance = (distance_)(vec, (dataset_)[(*training_index)], ((dataset_).cols)); 
# 328
if (hamming_distance < radius) { score_index_heap.push_back(ScoreIndexPair(hamming_distance, training_index)); }  
# 329
}  
# 330
} }  
# 331
}  
# 332
}  
# 333
} 
# 339
void getNeighbors(const ElementType *vec, ResultSet< typename Distance::ResultType>  &result) 
# 340
{ 
# 341
typename ::std::vector< ::cvflann::lsh::LshTable< typename Distance::ElementType> > ::const_iterator table = ((tables_).begin()); 
# 342
typename ::std::vector< ::cvflann::lsh::LshTable< typename Distance::ElementType> > ::const_iterator table_end = ((tables_).end()); 
# 343
for (; table != table_end; ++table) { 
# 344
::size_t key = (table->getKey)(vec); 
# 345
::std::vector< unsigned> ::const_iterator xor_mask = (xor_masks_).begin(); 
# 346
::std::vector< unsigned> ::const_iterator xor_mask_end = (xor_masks_).end(); 
# 347
for (; (xor_mask != xor_mask_end); (++xor_mask)) { { 
# 348
::size_t sub_key = key ^ ((*xor_mask)); 
# 349
const ::cvflann::lsh::Bucket *bucket = (table->getBucketFromKey)((::cvflann::lsh::BucketKey)sub_key); 
# 350
if (bucket == (0)) { continue; }  
# 353
::std::vector< unsigned> ::const_iterator training_index = bucket->begin(); 
# 354
::std::vector< unsigned> ::const_iterator last_training_index = bucket->end(); 
# 355
DistanceType hamming_distance; 
# 358
for (; (training_index < last_training_index); (++training_index)) { 
# 360
hamming_distance = (distance_)(vec, (dataset_)[(*training_index)], (int)((dataset_).cols)); 
# 361
(result.addPoint(hamming_distance, (*training_index))); 
# 362
}  
# 363
} }  
# 364
}  
# 365
} 
# 368
::std::vector< ::cvflann::lsh::LshTable< typename Distance::ElementType> >  tables_; 
# 371
Matrix< typename Distance::ElementType>  dataset_; 
# 374
unsigned feature_size_; 
# 376
::cvflann::IndexParams index_params_; 
# 379
unsigned table_number_; 
# 381
unsigned key_size_; 
# 383
unsigned multi_probe_level_; 
# 386
::std::vector< unsigned>  xor_masks_; 
# 388
Distance distance_; 
# 389
}; 
# 390
}
# 38 "/usr/include/opencv2/flann/ground_truth.h" 3
namespace cvflann { 
# 41
template< class Distance> void 
# 42
find_nearest(const Matrix< typename Distance::ElementType>  &dataset, typename Distance::ElementType *query, int *matches, int nn, int 
# 43
skip = 0, Distance distance = Distance()) 
# 44
{ 
# 45
typedef typename Distance::ResultType DistanceType; 
# 46
int n = nn + skip; 
# 48
std::vector< int>  match(n); 
# 49
std::vector< typename Distance::ResultType>  dists(n); 
# 51
(dists[0]) = distance(dataset[0], query, (dataset.cols)); 
# 52
match[0] = 0; 
# 53
int dcnt = 1; 
# 55
for (size_t i = (1); i < (dataset.rows); ++i) { 
# 56
DistanceType tmp = distance(dataset[i], query, (dataset.cols)); 
# 58
if (dcnt < n) { 
# 59
match[dcnt] = ((int)i); 
# 60
(dists[dcnt++]) = tmp; 
# 61
} else { 
# 62
if (tmp < (dists[dcnt - 1])) { 
# 63
(dists[dcnt - 1]) = tmp; 
# 64
match[dcnt - 1] = ((int)i); 
# 65
}  }  
# 67
int j = dcnt - 1; 
# 69
while ((j >= 1) && ((dists[j]) < (dists[j - 1]))) { 
# 70
std::swap(dists[j], dists[j - 1]); 
# 71
std::swap(match[j], match[j - 1]); 
# 72
j--; 
# 73
}  
# 74
}  
# 76
for (int i = 0; i < nn; ++i) { 
# 77
(matches[i]) = match[i + skip]; 
# 78
}  
# 79
} 
# 82
template< class Distance> void 
# 83
compute_ground_truth(const Matrix< typename Distance::ElementType>  &dataset, const Matrix< typename Distance::ElementType>  &testset, Matrix< int>  &matches, int 
# 84
skip = 0, Distance d = Distance()) 
# 85
{ 
# 86
for (size_t i = (0); i < (testset.rows); ++i) { 
# 87
find_nearest< Distance> (dataset, testset[i], matches[i], (int)(matches.cols), skip, d); 
# 88
}  
# 89
} 
# 92
}
# 38 "/usr/include/opencv2/flann/timer.h" 3
namespace cvflann { 
# 46
class StartStopTimer { 
# 48
int64 startTime; 
# 54
public: double value; 
# 60
StartStopTimer() 
# 61
{ 
# 62
this->reset(); 
# 63
} 
# 68
void start() 
# 69
{ 
# 70
(startTime) = cv::getTickCount(); 
# 71
} 
# 76
void stop() 
# 77
{ 
# 78
int64 stopTime = cv::getTickCount(); 
# 79
(value) += ((((double)stopTime) - (startTime)) / cv::getTickFrequency()); 
# 80
} 
# 85
void reset() 
# 86
{ 
# 87
(value) = (0); 
# 88
} 
# 90
}; 
# 92
}
# 45 "/usr/include/opencv2/flann/index_testing.h" 3
namespace cvflann { 
# 48
inline int countCorrectMatches(int *neighbors, int *groundTruth, int n) 
# 49
{ 
# 50
int count = 0; 
# 51
for (int i = 0; i < n; ++i) { 
# 52
for (int k = 0; k < n; ++k) { 
# 53
if ((neighbors[i]) == (groundTruth[k])) { 
# 54
count++; 
# 55
break; 
# 56
}  
# 57
}  
# 58
}  
# 59
return count; 
# 60
} 
# 63
template< class Distance> typename Distance::ResultType 
# 64
computeDistanceRaport(const Matrix< typename Distance::ElementType>  &inputData, typename Distance::ElementType *target, int *
# 65
neighbors, int *groundTruth, int veclen, int n, const Distance &distance) 
# 66
{ 
# 67
typedef typename Distance::ResultType DistanceType; 
# 69
DistanceType ret = (0); 
# 70
for (int i = 0; i < n; ++i) { 
# 71
DistanceType den = distance(inputData[groundTruth[i]], target, veclen); 
# 72
DistanceType num = distance(inputData[neighbors[i]], target, veclen); 
# 74
if ((den == 0) && (num == 0)) { 
# 75
ret += 1; 
# 76
} else 
# 77
{ 
# 78
ret += (num / den); 
# 79
}  
# 80
}  
# 82
return ret; 
# 83
} 
# 85
template< class Distance> float 
# 86
search_with_ground_truth(NNIndex< Distance>  &index, const Matrix< typename Distance::ElementType>  &inputData, const Matrix< typename Distance::ElementType>  &
# 87
testData, const Matrix< int>  &matches, int nn, int checks, float &
# 88
time, typename Distance::ResultType &dist, const Distance &distance, int skipMatches) 
# 89
{ 
# 90
typedef typename Distance::ResultType DistanceType; 
# 92
if ((matches.cols) < ((size_t)nn)) { 
# 93
Logger::info("matches.cols=%d, nn=%d\n", matches.cols, nn); 
# 95
throw ((FLANNException)("Ground truth is not computed for as many neighbors as requested")); 
# 96
}  
# 98
KNNResultSet< typename Distance::ResultType>  resultSet(nn + skipMatches); 
# 99
SearchParams searchParams(checks); 
# 101
std::vector< int>  indices(nn + skipMatches); 
# 102
std::vector< typename Distance::ResultType>  dists(nn + skipMatches); 
# 103
int *neighbors = &indices[skipMatches]; 
# 105
int correct = 0; 
# 106
DistanceType distR = (0); 
# 107
StartStopTimer t; 
# 108
int repeats = 0; 
# 109
while ((t.value) < (0.2000000000000000111)) { 
# 110
repeats++; 
# 111
t.start(); 
# 112
correct = 0; 
# 113
distR = 0; 
# 114
for (size_t i = (0); i < (testData.rows); i++) { 
# 115
(resultSet.init(&indices[0], &(dists[0]))); 
# 116
(index.findNeighbors(resultSet, testData[i], searchParams)); 
# 118
correct += countCorrectMatches(neighbors, matches[i], nn); 
# 119
distR += computeDistanceRaport< Distance> (inputData, testData[i], neighbors, matches[i], (int)(testData.cols), nn, distance); 
# 120
}  
# 121
t.stop(); 
# 122
}  
# 123
time = ((float)((t.value) / repeats)); 
# 125
float precicion = ((float)correct) / (nn * (testData.rows)); 
# 127
dist = (distR / ((testData.rows) * nn)); 
# 129
Logger::info("%8d %10.4g %10.5g %10.5g %10.5g\n", checks, precicion, time, ((1000.0) * time) / (testData.rows), dist); 
# 132
return precicion; 
# 133
} 
# 136
template< class Distance> float 
# 137
test_index_checks(NNIndex< Distance>  &index, const Matrix< typename Distance::ElementType>  &inputData, const Matrix< typename Distance::ElementType>  &
# 138
testData, const Matrix< int>  &matches, int 
# 139
checks, float &precision, const Distance &distance, int nn = 1, int skipMatches = 0) 
# 140
{ 
# 141
typedef typename Distance::ResultType DistanceType; 
# 143
Logger::info("  Nodes  Precision(%)   Time(s)   Time/vec(ms)  Mean dist\n"); 
# 144
Logger::info("---------------------------------------------------------\n"); 
# 146
float time = (0); 
# 147
DistanceType dist = (0); 
# 148
precision = search_with_ground_truth(index, inputData, testData, matches, nn, checks, time, dist, distance, skipMatches); 
# 150
return time; 
# 151
} 
# 153
template< class Distance> float 
# 154
test_index_precision(NNIndex< Distance>  &index, const Matrix< typename Distance::ElementType>  &inputData, const Matrix< typename Distance::ElementType>  &
# 155
testData, const Matrix< int>  &matches, float 
# 156
precision, int &checks, const Distance &distance, int nn = 1, int skipMatches = 0) 
# 157
{ 
# 158
typedef typename Distance::ResultType DistanceType; 
# 159
const float SEARCH_EPS = (0.001000000047F); 
# 161
Logger::info("  Nodes  Precision(%)   Time(s)   Time/vec(ms)  Mean dist\n"); 
# 162
Logger::info("---------------------------------------------------------\n"); 
# 164
int c2 = 1; 
# 165
float p2; 
# 166
int c1 = 1; 
# 168
float time; 
# 169
DistanceType dist; 
# 171
p2 = search_with_ground_truth(index, inputData, testData, matches, nn, c2, time, dist, distance, skipMatches); 
# 173
if (p2 > precision) { 
# 174
Logger::info("Got as close as I can\n"); 
# 175
checks = c2; 
# 176
return time; 
# 177
}  
# 179
while (p2 < precision) { 
# 180
c1 = c2; 
# 182
c2 *= 2; 
# 183
p2 = search_with_ground_truth(index, inputData, testData, matches, nn, c2, time, dist, distance, skipMatches); 
# 184
}  
# 186
int cx; 
# 187
float realPrecision; 
# 188
if (fabs(p2 - precision) > SEARCH_EPS) { 
# 189
Logger::info("Start linear estimation\n"); 
# 193
cx = ((c1 + c2) / 2); 
# 194
realPrecision = search_with_ground_truth(index, inputData, testData, matches, nn, cx, time, dist, distance, skipMatches); 
# 195
while (fabs(realPrecision - precision) > SEARCH_EPS) { 
# 197
if (realPrecision < precision) { 
# 198
c1 = cx; 
# 199
} else 
# 200
{ 
# 201
c2 = cx; 
# 202
}  
# 203
cx = ((c1 + c2) / 2); 
# 204
if (cx == c1) { 
# 205
Logger::info("Got as close as I can\n"); 
# 206
break; 
# 207
}  
# 208
realPrecision = search_with_ground_truth(index, inputData, testData, matches, nn, cx, time, dist, distance, skipMatches); 
# 209
}  
# 211
c2 = cx; 
# 212
p2 = realPrecision; 
# 214
} else 
# 215
{ 
# 216
Logger::info("No need for linear estimation\n"); 
# 217
cx = c2; 
# 218
realPrecision = p2; 
# 219
}  
# 221
checks = cx; 
# 222
return time; 
# 223
} 
# 226
template< class Distance> void 
# 227
test_index_precisions(NNIndex< Distance>  &index, const Matrix< typename Distance::ElementType>  &inputData, const Matrix< typename Distance::ElementType>  &
# 228
testData, const Matrix< int>  &matches, float *
# 229
precisions, int precisions_length, const Distance &distance, int nn = 1, int skipMatches = 0, float maxTime = 0) 
# 230
{ 
# 231
typedef typename Distance::ResultType DistanceType; 
# 233
const float SEARCH_EPS = ((0.001000000000000000021)); 
# 236
std::sort(precisions, precisions + precisions_length); 
# 238
int pindex = 0; 
# 239
float precision = precisions[pindex]; 
# 241
Logger::info("  Nodes  Precision(%)   Time(s)   Time/vec(ms)  Mean dist\n"); 
# 242
Logger::info("---------------------------------------------------------\n"); 
# 244
int c2 = 1; 
# 245
float p2; 
# 247
int c1 = 1; 
# 248
float p1; 
# 250
float time; 
# 251
DistanceType dist; 
# 253
p2 = search_with_ground_truth(index, inputData, testData, matches, nn, c2, time, dist, distance, skipMatches); 
# 258
while (((precisions[pindex]) < p2) && (pindex < precisions_length)) { 
# 259
pindex++; 
# 260
}  
# 262
if (pindex == precisions_length) { 
# 263
Logger::info("Got as close as I can\n"); 
# 264
return; 
# 265
}  
# 267
for (int i = pindex; i < precisions_length; ++i) { 
# 269
precision = (precisions[i]); 
# 270
while (p2 < precision) { 
# 271
c1 = c2; 
# 272
p1 = p2; 
# 273
c2 *= 2; 
# 274
p2 = search_with_ground_truth(index, inputData, testData, matches, nn, c2, time, dist, distance, skipMatches); 
# 275
if ((maxTime > (0)) && (time > maxTime) && (p2 < precision)) { return; }  
# 276
}  
# 278
int cx; 
# 279
float realPrecision; 
# 280
if (fabs(p2 - precision) > SEARCH_EPS) { 
# 281
Logger::info("Start linear estimation\n"); 
# 285
cx = ((c1 + c2) / 2); 
# 286
realPrecision = search_with_ground_truth(index, inputData, testData, matches, nn, cx, time, dist, distance, skipMatches); 
# 287
while (fabs(realPrecision - precision) > SEARCH_EPS) { 
# 289
if (realPrecision < precision) { 
# 290
c1 = cx; 
# 291
} else 
# 292
{ 
# 293
c2 = cx; 
# 294
}  
# 295
cx = ((c1 + c2) / 2); 
# 296
if (cx == c1) { 
# 297
Logger::info("Got as close as I can\n"); 
# 298
break; 
# 299
}  
# 300
realPrecision = search_with_ground_truth(index, inputData, testData, matches, nn, cx, time, dist, distance, skipMatches); 
# 301
}  
# 303
c2 = cx; 
# 304
p2 = realPrecision; 
# 306
} else 
# 307
{ 
# 308
Logger::info("No need for linear estimation\n"); 
# 309
cx = c2; 
# 310
realPrecision = p2; 
# 311
}  
# 313
}  
# 314
} 
# 316
}
# 36 "/usr/include/opencv2/flann/sampling.h" 3
namespace cvflann { 
# 39
template< class T> Matrix< T>  
# 40
random_sample(Matrix< T>  &srcMatrix, long size, bool remove = false) 
# 41
{ 
# 42
Matrix< T>  newSet(new T [size * (srcMatrix.cols)], size, (srcMatrix.cols)); 
# 44
T *src, *dest; 
# 45
for (long i = (0); i < size; ++i) { 
# 46
long r = rand_int((int)((srcMatrix.rows) - i)); 
# 47
dest = (newSet[i]); 
# 48
src = (srcMatrix[r]); 
# 49
std::copy(src, src + (srcMatrix.cols), dest); 
# 50
if (remove) { 
# 51
src = (srcMatrix[((srcMatrix.rows) - i) - 1]); 
# 52
dest = (srcMatrix[r]); 
# 53
std::copy(src, src + (srcMatrix.cols), dest); 
# 54
}  
# 55
}  
# 56
if (remove) { 
# 57
(srcMatrix.rows) -= size; 
# 58
}  
# 59
return newSet; 
# 60
} 
# 62
template< class T> Matrix< T>  
# 63
random_sample(const Matrix< T>  &srcMatrix, size_t size) 
# 64
{ 
# 65
UniqueRandom rand((int)(srcMatrix.rows)); 
# 66
Matrix< T>  newSet(new T [size * (srcMatrix.cols)], size, (srcMatrix.cols)); 
# 68
T *src, *dest; 
# 69
for (size_t i = (0); i < size; ++i) { 
# 70
long r = rand.next(); 
# 71
dest = (newSet[i]); 
# 72
src = (srcMatrix[r]); 
# 73
std::copy(src, src + (srcMatrix.cols), dest); 
# 74
}  
# 75
return newSet; 
# 76
} 
# 78
}
# 47 "/usr/include/opencv2/flann/autotuned_index.h" 3
namespace cvflann { 
# 50
template< class Distance> NNIndex< Distance>  *create_index_by_type(const Matrix< typename Distance::ElementType>  & dataset, const IndexParams & params, const Distance & distance); 
# 54
struct AutotunedIndexParams : public IndexParams { 
# 56
AutotunedIndexParams(float target_precision = (0.8000000000000000444), float build_weight = (0.01000000000000000021), float memory_weight = 0, float sample_fraction = (0.1000000000000000056)) 
# 57
{ 
# 58
(((*this)["algorithm"]) = (FLANN_INDEX_AUTOTUNED)); 
# 60
(((*this)["target_precision"]) = target_precision); 
# 62
(((*this)["build_weight"]) = build_weight); 
# 64
(((*this)["memory_weight"]) = memory_weight); 
# 66
(((*this)["sample_fraction"]) = sample_fraction); 
# 67
} 
# 68
}; 
# 71
template< class Distance> 
# 72
class AutotunedIndex : public NNIndex< Distance>  { 
# 75
public: typedef typename Distance::ElementType ElementType; 
# 76
typedef typename Distance::ResultType DistanceType; 
# 78
AutotunedIndex(const Matrix< typename Distance::ElementType>  &inputData, const ::cvflann::IndexParams &params = ::cvflann::AutotunedIndexParams(), Distance d = Distance()) : dataset_(inputData), distance_(d) 
# 80
{ 
# 81
(target_precision_) = get_param(params, "target_precision", (0.8000000119F)); 
# 82
(build_weight_) = get_param(params, "build_weight", (0.009999999776F)); 
# 83
(memory_weight_) = get_param(params, "memory_weight", (0.0F)); 
# 84
(sample_fraction_) = get_param(params, "sample_fraction", (0.1000000015F)); 
# 85
(bestIndex_) = __null; 
# 86
(speedup_) = (0); 
# 87
} 
# 89
AutotunedIndex(const AutotunedIndex &); 
# 90
AutotunedIndex &operator=(const AutotunedIndex &); 
# 92
virtual ~AutotunedIndex() 
# 93
{ 
# 94
if ((bestIndex_) != __null) { 
# 95
delete (bestIndex_); 
# 96
(bestIndex_) = __null; 
# 97
}  
# 98
} 
# 103
virtual void buildIndex() 
# 104
{ 
# 105
::std::ostringstream stream; 
# 106
(bestParams_) = estimateBuildParams(); 
# 107
print_params(bestParams_, stream); 
# 108
Logger::info("----------------------------------------------------\n"); 
# 109
Logger::info("Autotuned parameters:\n"); 
# 110
Logger::info("%s", (stream.str()).c_str()); 
# 111
Logger::info("----------------------------------------------------\n"); 
# 113
(bestIndex_) = create_index_by_type(dataset_, bestParams_, distance_); 
# 114
((bestIndex_)->buildIndex()); 
# 115
(speedup_) = estimateSearchParams(bestSearchParams_); 
# 116
stream.str(::std::__cxx11::string()); 
# 117
print_params(bestSearchParams_, stream); 
# 118
Logger::info("----------------------------------------------------\n"); 
# 119
Logger::info("Search parameters:\n"); 
# 120
Logger::info("%s", (stream.str()).c_str()); 
# 121
Logger::info("----------------------------------------------------\n"); 
# 122
} 
# 127
virtual void saveIndex(::FILE *stream) 
# 128
{ 
# 129
save_value(stream, (int)((bestIndex_)->getType())); 
# 130
((bestIndex_)->saveIndex(stream)); 
# 131
save_value(stream, get_param< int> (bestSearchParams_, "checks")); 
# 132
} 
# 137
virtual void loadIndex(::FILE *stream) 
# 138
{ 
# 139
int index_type; 
# 141
load_value(stream, index_type); 
# 142
::cvflann::IndexParams params; 
# 143
((params["algorithm"]) = ((::cvflann::flann_algorithm_t)index_type)); 
# 144
(bestIndex_) = create_index_by_type< Distance> (dataset_, params, distance_); 
# 145
((bestIndex_)->loadIndex(stream)); 
# 146
int checks; 
# 147
load_value(stream, checks); 
# 148
(((bestSearchParams_)["checks"]) = checks); 
# 149
} 
# 154
virtual void findNeighbors(ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, const ::cvflann::SearchParams &searchParams) 
# 155
{ 
# 156
int checks = get_param< int> (searchParams, "checks", FLANN_CHECKS_AUTOTUNED); 
# 157
if (checks == (FLANN_CHECKS_AUTOTUNED)) { 
# 158
((bestIndex_)->findNeighbors(result, vec, bestSearchParams_)); 
# 159
} else 
# 160
{ 
# 161
((bestIndex_)->findNeighbors(result, vec, searchParams)); 
# 162
}  
# 163
} 
# 166
::cvflann::IndexParams getParameters() const 
# 167
{ 
# 168
return ((bestIndex_)->getParameters()); 
# 169
} 
# 171
::cvflann::SearchParams getSearchParameters() const 
# 172
{ 
# 173
return bestSearchParams_; 
# 174
} 
# 176
float getSpeedup() const 
# 177
{ 
# 178
return speedup_; 
# 179
} 
# 185
virtual ::size_t size() const 
# 186
{ 
# 187
return ((bestIndex_)->size()); 
# 188
} 
# 193
virtual ::size_t veclen() const 
# 194
{ 
# 195
return ((bestIndex_)->veclen()); 
# 196
} 
# 201
virtual int usedMemory() const 
# 202
{ 
# 203
return ((bestIndex_)->usedMemory()); 
# 204
} 
# 209
virtual ::cvflann::flann_algorithm_t getType() const 
# 210
{ 
# 211
return FLANN_INDEX_AUTOTUNED; 
# 212
} 
# 216
private: struct CostData { 
# 218
float searchTimeCost; 
# 219
float buildTimeCost; 
# 220
float memoryCost; 
# 221
float totalCost; 
# 222
::cvflann::IndexParams params; 
# 223
}; 
# 225
void evaluate_kmeans(CostData &cost) 
# 226
{ 
# 227
::cvflann::StartStopTimer t; 
# 228
int checks; 
# 229
const int nn = 1; 
# 231
Logger::info("KMeansTree using params: max_iterations=%d, branching=%d\n", get_param< int> ((cost.params), "iterations"), get_param< int> ((cost.params), "branching")); 
# 234
KMeansIndex< Distance>  kmeans(sampledDataset_, (cost.params), distance_); 
# 236
t.start(); 
# 237
(kmeans.buildIndex()); 
# 238
t.stop(); 
# 239
float buildTime = (float)(t.value); 
# 242
float searchTime = test_index_precision(kmeans, sampledDataset_, testDataset_, gt_matches_, target_precision_, checks, distance_, nn); 
# 244
float datasetMemory = (float)((((sampledDataset_).rows) * ((sampledDataset_).cols)) * sizeof(float)); 
# 245
(cost.memoryCost) = (((kmeans.usedMemory()) + datasetMemory) / datasetMemory); 
# 246
(cost.searchTimeCost) = searchTime; 
# 247
(cost.buildTimeCost) = buildTime; 
# 248
Logger::info("KMeansTree buildTime=%g, searchTime=%g, build_weight=%g\n", buildTime, searchTime, build_weight_); 
# 249
} 
# 252
void evaluate_kdtree(CostData &cost) 
# 253
{ 
# 254
::cvflann::StartStopTimer t; 
# 255
int checks; 
# 256
const int nn = 1; 
# 258
Logger::info("KDTree using params: trees=%d\n", get_param< int> ((cost.params), "trees")); 
# 259
KDTreeIndex< Distance>  kdtree(sampledDataset_, (cost.params), distance_); 
# 261
t.start(); 
# 262
(kdtree.buildIndex()); 
# 263
t.stop(); 
# 264
float buildTime = (float)(t.value); 
# 267
float searchTime = test_index_precision(kdtree, sampledDataset_, testDataset_, gt_matches_, target_precision_, checks, distance_, nn); 
# 269
float datasetMemory = (float)((((sampledDataset_).rows) * ((sampledDataset_).cols)) * sizeof(float)); 
# 270
(cost.memoryCost) = (((kdtree.usedMemory()) + datasetMemory) / datasetMemory); 
# 271
(cost.searchTimeCost) = searchTime; 
# 272
(cost.buildTimeCost) = buildTime; 
# 273
Logger::info("KDTree buildTime=%g, searchTime=%g\n", buildTime, searchTime); 
# 274
} 
# 325 "/usr/include/opencv2/flann/autotuned_index.h" 3
void optimizeKMeans(::std::vector< CostData>  &costs) 
# 326
{ 
# 327
Logger::info("KMEANS, Step 1: Exploring parameter space\n"); 
# 330
int maxIterations[] = {1, 5, 10, 15}; 
# 331
int branchingFactors[] = {16, 32, 64, 128, 256}; 
# 333
int kmeansParamSpaceSize = ((sizeof maxIterations / sizeof ((maxIterations)[0])) * (sizeof branchingFactors / sizeof ((branchingFactors)[0]))); 
# 334
(costs.reserve((costs.size()) + kmeansParamSpaceSize)); 
# 337
for (::size_t i = (0); i < (sizeof maxIterations / sizeof ((maxIterations)[0])); ++i) { 
# 338
for (::size_t j = (0); j < (sizeof branchingFactors / sizeof ((branchingFactors)[0])); ++j) { 
# 339
CostData cost; 
# 340
((cost.params)["algorithm"]) = FLANN_INDEX_KMEANS; 
# 341
((cost.params)["centers_init"]) = FLANN_CENTERS_RANDOM; 
# 342
((cost.params)["iterations"]) = ((maxIterations)[i]); 
# 343
((cost.params)["branching"]) = ((branchingFactors)[j]); 
# 345
evaluate_kmeans(cost); 
# 346
(costs.push_back(cost)); 
# 347
}  
# 348
}  
# 370 "/usr/include/opencv2/flann/autotuned_index.h" 3
} 
# 373
void optimizeKDTree(::std::vector< CostData>  &costs) 
# 374
{ 
# 375
Logger::info("KD-TREE, Step 1: Exploring parameter space\n"); 
# 378
int testTrees[] = {1, 4, 8, 16, 32}; 
# 381
for (::size_t i = (0); i < (sizeof testTrees / sizeof ((testTrees)[0])); ++i) { 
# 382
CostData cost; 
# 383
((cost.params)["algorithm"]) = FLANN_INDEX_KDTREE; 
# 384
((cost.params)["trees"]) = ((testTrees)[i]); 
# 386
evaluate_kdtree(cost); 
# 387
(costs.push_back(cost)); 
# 388
}  
# 408 "/usr/include/opencv2/flann/autotuned_index.h" 3
} 
# 415
::cvflann::IndexParams estimateBuildParams() 
# 416
{ 
# 417
::std::vector< CostData>  costs; 
# 419
int sampleSize = (int)((sample_fraction_) * ((dataset_).rows)); 
# 420
int testSampleSize = std::min(sampleSize / 10, 1000); 
# 422
Logger::info("Entering autotuning, dataset size: %d, sampleSize: %d, testSampleSize: %d, target precision: %g\n", ((dataset_).rows), sampleSize, testSampleSize, target_precision_); 
# 426
if (testSampleSize < 10) { 
# 427
Logger::info("Choosing linear, dataset too small\n"); 
# 428
return ::cvflann::LinearIndexParams(); 
# 429
}  
# 432
(sampledDataset_) = random_sample(dataset_, sampleSize); 
# 434
(testDataset_) = random_sample(sampledDataset_, testSampleSize, true); 
# 437
Logger::info("Computing ground truth... \n"); 
# 438
(gt_matches_) = ::cvflann::Matrix< int> ((new int [(testDataset_).rows]), ((testDataset_).rows), 1); 
# 439
::cvflann::StartStopTimer t; 
# 440
t.start(); 
# 441
compute_ground_truth< Distance> (sampledDataset_, testDataset_, gt_matches_, 0, distance_); 
# 442
t.stop(); 
# 444
CostData linear_cost; 
# 445
(linear_cost.searchTimeCost) = ((float)(t.value)); 
# 446
(linear_cost.buildTimeCost) = 0; 
# 447
(linear_cost.memoryCost) = 0; 
# 448
((linear_cost.params)["algorithm"]) = FLANN_INDEX_LINEAR; 
# 450
(costs.push_back(linear_cost)); 
# 453
Logger::info("Autotuning parameters...\n"); 
# 455
optimizeKMeans(costs); 
# 456
optimizeKDTree(costs); 
# 458
float bestTimeCost = (((costs[0]).searchTimeCost)); 
# 459
for (::size_t i = (0); i < (costs.size()); ++i) { 
# 460
float timeCost = (((costs[i]).buildTimeCost) * (build_weight_)) + ((costs[i]).searchTimeCost); 
# 461
if (timeCost < bestTimeCost) { 
# 462
bestTimeCost = timeCost; 
# 463
}  
# 464
}  
# 466
float bestCost = ((costs[0]).searchTimeCost) / bestTimeCost; 
# 467
::cvflann::IndexParams bestParams = (((costs[0]).params)); 
# 468
if (bestTimeCost > (0)) { 
# 469
for (::size_t i = (0); i < (costs.size()); ++i) { 
# 470
float crtCost = (((((costs[i]).buildTimeCost) * (build_weight_)) + ((costs[i]).searchTimeCost)) / bestTimeCost) + ((memory_weight_) * ((costs[i]).memoryCost)); 
# 472
if (crtCost < bestCost) { 
# 473
bestCost = crtCost; 
# 474
bestParams = ((costs[i]).params); 
# 475
}  
# 476
}  
# 477
}  
# 479
delete [] ((gt_matches_).data); 
# 480
delete [] ((testDataset_).data); 
# 481
delete [] ((sampledDataset_).data); 
# 483
return bestParams; 
# 484
} 
# 493 "/usr/include/opencv2/flann/autotuned_index.h" 3
float estimateSearchParams(::cvflann::SearchParams &searchParams) 
# 494
{ 
# 495
const int nn = 1; 
# 496
const ::size_t SAMPLE_COUNT = (1000); 
# 498
((bestIndex_) != __null) ? static_cast< void>(0) : __assert_fail("bestIndex_ != NULL", "/usr/include/opencv2/flann/autotuned_index.h", 498, __PRETTY_FUNCTION__); 
# 500
float speedup = (0); 
# 502
int samples = (int)::std::min(((dataset_).rows) / 10, SAMPLE_COUNT); 
# 503
if (samples > 0) { 
# 504
Matrix< typename Distance::ElementType>  testDataset = random_sample(dataset_, samples); 
# 506
Logger::info("Computing ground truth\n"); 
# 509
::cvflann::Matrix< int>  gt_matches((new int [testDataset.rows]), (testDataset.rows), 1); 
# 510
::cvflann::StartStopTimer t; 
# 511
t.start(); 
# 512
compute_ground_truth< Distance> (dataset_, testDataset, gt_matches, 1, distance_); 
# 513
t.stop(); 
# 514
float linear = (float)(t.value); 
# 516
int checks; 
# 517
Logger::info("Estimating number of checks\n"); 
# 519
float searchTime; 
# 520
float cb_index; 
# 521
if (((bestIndex_)->getType()) == FLANN_INDEX_KMEANS) { 
# 522
Logger::info("KMeans algorithm, estimating cluster border factor\n"); 
# 523
KMeansIndex< Distance>  *kmeans = (KMeansIndex< Distance>  *)(bestIndex_); 
# 524
float bestSearchTime = (-1); 
# 525
float best_cb_index = (-1); 
# 526
int best_checks = (-1); 
# 527
for (cb_index = (0); cb_index < (1.100000024F); cb_index += (0.200000003F)) { 
# 528
(kmeans->set_cb_index(cb_index)); 
# 529
searchTime = test_index_precision(*kmeans, dataset_, testDataset, gt_matches, target_precision_, checks, distance_, nn, 1); 
# 530
if ((searchTime < bestSearchTime) || (bestSearchTime == (-1))) { 
# 531
bestSearchTime = searchTime; 
# 532
best_cb_index = cb_index; 
# 533
best_checks = checks; 
# 534
}  
# 535
}  
# 536
searchTime = bestSearchTime; 
# 537
cb_index = best_cb_index; 
# 538
checks = best_checks; 
# 540
(kmeans->set_cb_index(best_cb_index)); 
# 541
Logger::info("Optimum cb_index: %g\n", cb_index); 
# 542
(((bestParams_)["cb_index"]) = cb_index); 
# 543
} else 
# 544
{ 
# 545
searchTime = test_index_precision(*(bestIndex_), dataset_, testDataset, gt_matches, target_precision_, checks, distance_, nn, 1); 
# 546
}  
# 548
Logger::info("Required number of checks: %d \n", checks); 
# 549
((searchParams["checks"]) = checks); 
# 551
speedup = (linear / searchTime); 
# 553
delete [] (gt_matches.data); 
# 554
delete [] (testDataset.data); 
# 555
}  
# 557
return speedup; 
# 558
} 
# 561
::cvflann::NNIndex< Distance>  *bestIndex_; 
# 563
::cvflann::IndexParams bestParams_; 
# 564
::cvflann::SearchParams bestSearchParams_; 
# 566
Matrix< typename Distance::ElementType>  sampledDataset_; 
# 567
Matrix< typename Distance::ElementType>  testDataset_; 
# 568
::cvflann::Matrix< int>  gt_matches_; 
# 570
float speedup_; 
# 575
const Matrix< typename Distance::ElementType>  dataset_; 
# 580
float target_precision_; 
# 581
float build_weight_; 
# 582
float memory_weight_; 
# 583
float sample_fraction_; 
# 585
Distance distance_; 
# 588
}; 
# 589
}
# 46 "/usr/include/opencv2/flann/all_indices.h" 3
namespace cvflann { 
# 49
template< class KDTreeCapability, class VectorSpace, class Distance> 
# 50
struct index_creator { 
# 52
static NNIndex< Distance>  *create(const Matrix< typename Distance::ElementType>  &dataset, const IndexParams &params, const Distance &distance) 
# 53
{ 
# 54
flann_algorithm_t index_type = get_param< flann_algorithm_t> (params, "algorithm"); 
# 56
NNIndex< Distance>  *nnIndex; 
# 57
switch (index_type) { 
# 58
case FLANN_INDEX_LINEAR:  
# 59
nnIndex = (new LinearIndex< Distance> (dataset, params, distance)); 
# 60
break; 
# 61
case FLANN_INDEX_KDTREE_SINGLE:  
# 62
nnIndex = (new KDTreeSingleIndex< Distance> (dataset, params, distance)); 
# 63
break; 
# 64
case FLANN_INDEX_KDTREE:  
# 65
nnIndex = (new KDTreeIndex< Distance> (dataset, params, distance)); 
# 66
break; 
# 67
case FLANN_INDEX_KMEANS:  
# 68
nnIndex = (new KMeansIndex< Distance> (dataset, params, distance)); 
# 69
break; 
# 70
case FLANN_INDEX_COMPOSITE:  
# 71
nnIndex = (new CompositeIndex< Distance> (dataset, params, distance)); 
# 72
break; 
# 73
case FLANN_INDEX_AUTOTUNED:  
# 74
nnIndex = (new AutotunedIndex< Distance> (dataset, params, distance)); 
# 75
break; 
# 76
case FLANN_INDEX_HIERARCHICAL:  
# 77
nnIndex = (new HierarchicalClusteringIndex< Distance> (dataset, params, distance)); 
# 78
break; 
# 79
case FLANN_INDEX_LSH:  
# 80
nnIndex = (new LshIndex< Distance> (dataset, params, distance)); 
# 81
break; 
# 82
default:  
# 83
throw ((FLANNException)("Unknown index type")); 
# 84
}  
# 86
return nnIndex; 
# 87
} 
# 88
}; 
# 90
template< class VectorSpace, class Distance> 
# 91
struct index_creator< False, VectorSpace, Distance>  { 
# 93
static NNIndex< Distance>  *create(const Matrix< typename Distance::ElementType>  &dataset, const IndexParams &params, const Distance &distance) 
# 94
{ 
# 95
flann_algorithm_t index_type = get_param< flann_algorithm_t> (params, "algorithm"); 
# 97
NNIndex< Distance>  *nnIndex; 
# 98
switch (index_type) { 
# 99
case FLANN_INDEX_LINEAR:  
# 100
nnIndex = (new LinearIndex< Distance> (dataset, params, distance)); 
# 101
break; 
# 102
case FLANN_INDEX_KMEANS:  
# 103
nnIndex = (new KMeansIndex< Distance> (dataset, params, distance)); 
# 104
break; 
# 105
case FLANN_INDEX_HIERARCHICAL:  
# 106
nnIndex = (new HierarchicalClusteringIndex< Distance> (dataset, params, distance)); 
# 107
break; 
# 108
case FLANN_INDEX_LSH:  
# 109
nnIndex = (new LshIndex< Distance> (dataset, params, distance)); 
# 110
break; 
# 111
default:  
# 112
throw ((FLANNException)("Unknown index type")); 
# 113
}  
# 115
return nnIndex; 
# 116
} 
# 117
}; 
# 119
template< class Distance> 
# 120
struct index_creator< False, False, Distance>  { 
# 122
static NNIndex< Distance>  *create(const Matrix< typename Distance::ElementType>  &dataset, const IndexParams &params, const Distance &distance) 
# 123
{ 
# 124
flann_algorithm_t index_type = get_param< flann_algorithm_t> (params, "algorithm"); 
# 126
NNIndex< Distance>  *nnIndex; 
# 127
switch (index_type) { 
# 128
case FLANN_INDEX_LINEAR:  
# 129
nnIndex = (new LinearIndex< Distance> (dataset, params, distance)); 
# 130
break; 
# 131
case FLANN_INDEX_HIERARCHICAL:  
# 132
nnIndex = (new HierarchicalClusteringIndex< Distance> (dataset, params, distance)); 
# 133
break; 
# 134
case FLANN_INDEX_LSH:  
# 135
nnIndex = (new LshIndex< Distance> (dataset, params, distance)); 
# 136
break; 
# 137
default:  
# 138
throw ((FLANNException)("Unknown index type")); 
# 139
}  
# 141
return nnIndex; 
# 142
} 
# 143
}; 
# 145
template< class Distance> NNIndex< Distance>  *
# 146
create_index_by_type(const Matrix< typename Distance::ElementType>  &dataset, const IndexParams &params, const Distance &distance) 
# 147
{ 
# 148
return index_creator< typename Distance::is_kdtree_distance, typename Distance::is_vector_space_distance, Distance> ::create(dataset, params, distance); 
# 151
} 
# 153
}
# 45 "/usr/include/opencv2/flann/flann_base.hpp" 3
namespace cvflann { 
# 52
inline void log_verbosity(int level) 
# 53
{ 
# 54
if (level >= 0) { 
# 55
Logger::setLevel(level); 
# 56
}  
# 57
} 
# 62
struct SavedIndexParams : public IndexParams { 
# 64
SavedIndexParams(cv::String filename) 
# 65
{ 
# 66
(((*this)["algorithm"]) = (FLANN_INDEX_SAVED)); 
# 67
(((*this)["filename"]) = filename); 
# 68
} 
# 69
}; 
# 72
template< class Distance> NNIndex< Distance>  *
# 73
load_saved_index(const Matrix< typename Distance::ElementType>  &dataset, const cv::String &filename, Distance distance) 
# 74
{ 
# 75
typedef typename Distance::ElementType ElementType; 
# 77
FILE *fin = fopen(filename.c_str(), "rb"); 
# 78
if (fin == (__null)) { 
# 79
return __null; 
# 80
}  
# 81
IndexHeader header = load_header(fin); 
# 82
if ((header.data_type) != Datatype< typename Distance::ElementType> ::type()) { 
# 83
fclose(fin); 
# 84
throw ((FLANNException)("Datatype of saved index is different than of the one to be created.")); 
# 85
}  
# 86
if ((((size_t)(header.rows)) != (dataset.rows)) || (((size_t)(header.cols)) != (dataset.cols))) { 
# 87
fclose(fin); 
# 88
throw ((FLANNException)("The index saved belongs to a different dataset")); 
# 89
}  
# 91
IndexParams params; 
# 92
((params["algorithm"]) = (header.index_type)); 
# 93
NNIndex< Distance>  *nnIndex = create_index_by_type< Distance> (dataset, params, distance); 
# 94
(nnIndex->loadIndex(fin)); 
# 95
fclose(fin); 
# 97
return nnIndex; 
# 98
} 
# 101
template< class Distance> 
# 102
class Index : public NNIndex< Distance>  { 
# 105
public: typedef typename Distance::ElementType ElementType; 
# 106
typedef typename Distance::ResultType DistanceType; 
# 108
Index(const Matrix< typename Distance::ElementType>  &features, const ::cvflann::IndexParams &params, Distance distance = Distance()) : index_params_(params) 
# 110
{ 
# 111
::cvflann::flann_algorithm_t index_type = get_param< ::cvflann::flann_algorithm_t> (params, "algorithm"); 
# 112
(loaded_) = false; 
# 114
if (index_type == (FLANN_INDEX_SAVED)) { 
# 115
(nnIndex_) = load_saved_index< Distance> (features, get_param< ::cv::String> (params, "filename"), distance); 
# 116
(loaded_) = true; 
# 117
} else 
# 118
{ 
# 119
(nnIndex_) = create_index_by_type< Distance> (features, params, distance); 
# 120
}  
# 121
} 
# 123
~Index() 
# 124
{ 
# 125
delete (nnIndex_); 
# 126
} 
# 131
void buildIndex() 
# 132
{ 
# 133
if (!(loaded_)) { 
# 134
((nnIndex_)->buildIndex()); 
# 135
}  
# 136
} 
# 138
void save(::cv::String filename) 
# 139
{ 
# 140
::FILE *fout = fopen(filename.c_str(), "wb"); 
# 141
if (fout == (__null)) { 
# 142
throw ((::cvflann::FLANNException)("Cannot open file")); 
# 143
}  
# 144
save_header(fout, *(nnIndex_)); 
# 145
saveIndex(fout); 
# 146
fclose(fout); 
# 147
} 
# 153
virtual void saveIndex(::FILE *stream) 
# 154
{ 
# 155
((nnIndex_)->saveIndex(stream)); 
# 156
} 
# 162
virtual void loadIndex(::FILE *stream) 
# 163
{ 
# 164
((nnIndex_)->loadIndex(stream)); 
# 165
} 
# 170
::size_t veclen() const 
# 171
{ 
# 172
return ((nnIndex_)->veclen()); 
# 173
} 
# 178
::size_t size() const 
# 179
{ 
# 180
return ((nnIndex_)->size()); 
# 181
} 
# 186
::cvflann::flann_algorithm_t getType() const 
# 187
{ 
# 188
return ((nnIndex_)->getType()); 
# 189
} 
# 194
virtual int usedMemory() const 
# 195
{ 
# 196
return ((nnIndex_)->usedMemory()); 
# 197
} 
# 203
::cvflann::IndexParams getParameters() const 
# 204
{ 
# 205
return ((nnIndex_)->getParameters()); 
# 206
} 
# 216 "/usr/include/opencv2/flann/flann_base.hpp" 3
void knnSearch(const Matrix< typename Distance::ElementType>  &queries, ::cvflann::Matrix< int>  &indices, Matrix< typename Distance::ResultType>  &dists, int knn, const ::cvflann::SearchParams &params) 
# 217
{ 
# 218
((nnIndex_)->knnSearch(queries, indices, dists, knn, params)); 
# 219
} 
# 230 "/usr/include/opencv2/flann/flann_base.hpp" 3
int radiusSearch(const Matrix< typename Distance::ElementType>  &query, ::cvflann::Matrix< int>  &indices, Matrix< typename Distance::ResultType>  &dists, float radius, const ::cvflann::SearchParams &params) 
# 231
{ 
# 232
return ((nnIndex_)->radiusSearch(query, indices, dists, radius, params)); 
# 233
} 
# 238
void findNeighbors(ResultSet< typename Distance::ResultType>  &result, const ElementType *vec, const ::cvflann::SearchParams &searchParams) 
# 239
{ 
# 240
((nnIndex_)->findNeighbors(result, vec, searchParams)); 
# 241
} 
# 246
__attribute((deprecated)) ::cvflann::NNIndex< Distance>  *getIndex() 
# 247
{ 
# 248
return nnIndex_; 
# 249
} 
# 255
__attribute((deprecated)) const ::cvflann::IndexParams *getIndexParameters() 
# 256
{ 
# 257
return &(index_params_); 
# 258
} 
# 262
private: ::cvflann::NNIndex< Distance>  *nnIndex_; 
# 264
bool loaded_; 
# 266
::cvflann::IndexParams index_params_; 
# 268
Index(const Index &); 
# 269
Index &operator=(const Index &); 
# 270
}; 
# 283 "/usr/include/opencv2/flann/flann_base.hpp" 3
template< class Distance> int 
# 284
hierarchicalClustering(const Matrix< typename Distance::ElementType>  &points, Matrix< typename Distance::ResultType>  &centers, const KMeansIndexParams &
# 285
params, Distance d = Distance()) 
# 286
{ 
# 287
KMeansIndex< Distance>  kmeans(points, params, d); 
# 288
(kmeans.buildIndex()); 
# 290
int clusterNum = (kmeans.getClusterCenters(centers)); 
# 291
return clusterNum; 
# 292
} 
# 294
}
# 59 "/usr/include/opencv2/flann.hpp" 3
namespace cvflann { 
# 61
__attribute((visibility("default"))) flann_distance_t flann_distance_type(); 
# 62
__attribute((deprecated)) __attribute((visibility("default"))) void set_distance_type(flann_distance_t distance_type, int order); 
# 63
}
# 66
namespace cv { 
# 68
namespace flann { 
# 75
template< class T> struct CvType { }; 
# 76
template<> struct CvType< unsigned char>  { static int type() { return 0; } }; 
# 77
template<> struct CvType< char>  { static int type() { return 1; } }; 
# 78
template<> struct CvType< unsigned short>  { static int type() { return 2; } }; 
# 79
template<> struct CvType< short>  { static int type() { return 3; } }; 
# 80
template<> struct CvType< int>  { static int type() { return 4; } }; 
# 81
template<> struct CvType< float>  { static int type() { return 5; } }; 
# 82
template<> struct CvType< double>  { static int type() { return 6; } }; 
# 86
using cvflann::get_param;
# 87
using cvflann::print_params;
# 90
using cvflann::L2_Simple;
# 91
using cvflann::L2;
# 92
using cvflann::L1;
# 93
using cvflann::MinkowskiDistance;
# 94
using cvflann::MaxDistance;
# 95
using cvflann::HammingLUT;
# 96
using cvflann::Hamming;
# 97
using cvflann::Hamming2;
# 98
using cvflann::HistIntersectionDistance;
# 99
using cvflann::HellingerDistance;
# 100
using cvflann::ChiSquareDistance;
# 101
using cvflann::KL_Divergence;
# 107
template< class Distance> 
# 108
class GenericIndex { 
# 111
public: typedef typename Distance::ElementType ElementType; 
# 112
typedef typename Distance::ResultType DistanceType; 
# 202 "/usr/include/opencv2/flann.hpp" 3
GenericIndex(const Mat & features, const cvflann::IndexParams & params, Distance distance = Distance()); 
# 204
~GenericIndex(); 
# 216 "/usr/include/opencv2/flann.hpp" 3
void knnSearch(const std::vector< typename Distance::ElementType>  & query, std::vector< int>  & indices, std::vector< typename Distance::ResultType>  & dists, int knn, const cvflann::SearchParams & params); 
# 218
void knnSearch(const Mat & queries, Mat & indices, Mat & dists, int knn, const cvflann::SearchParams & params); 
# 220
int radiusSearch(const std::vector< typename Distance::ElementType>  & query, std::vector< int>  & indices, std::vector< typename Distance::ResultType>  & dists, DistanceType radius, const cvflann::SearchParams & params); 
# 222
int radiusSearch(const Mat & query, Mat & indices, Mat & dists, DistanceType radius, const cvflann::SearchParams & params); 
# 225
void save(String filename) { ((nnIndex)->save(filename)); } 
# 227
int veclen() const { return ((nnIndex)->veclen()); } 
# 229
int size() const { return ((nnIndex)->size()); } 
# 231
cvflann::IndexParams getParameters() { return ((nnIndex)->getParameters()); } 
# 233
__attribute((deprecated)) const cvflann::IndexParams *getIndexParameters() { return ((nnIndex)->getIndexParameters()); } 
# 236
private: cvflann::Index< Distance>  *nnIndex; 
# 237
}; 
# 250 "/usr/include/opencv2/flann.hpp" 3
template< class Distance> 
# 251
GenericIndex< Distance> ::GenericIndex(const Mat &dataset, const cvflann::IndexParams &params, Distance distance) 
# 252
{ 
# 253
if (!(!(dataset.type() == CvType< typename Distance::ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dataset.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 253); }  
# 254
if (!(!dataset.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dataset.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 254); }  
# 255
cvflann::Matrix< typename Distance::ElementType>  m_dataset((ElementType *)(dataset.template ptr< ElementType> (0)), dataset.rows, dataset.cols); 
# 257
(nnIndex) = (new cvflann::Index< Distance> (m_dataset, params, distance)); 
# 259
if ((::cvflann::flann_distance_type()) != (cvflann::FLANN_DIST_L2)) { printf("[WARNING] You are using cv::flann::Index (or cv::flann::GenericIndex) and have also changed the distance using cvflann::set_dist" "ance_type. This is no longer working as expected (cv::flann::Index always uses L2). You should create the index templated on the" " distance, for example for L1 distance use: GenericIndex< L1<float> > \n"); }  
# 261
((nnIndex)->buildIndex()); 
# 262
} 
# 264
template< class Distance> 
# 265
GenericIndex< Distance> ::~GenericIndex() 
# 266
{ 
# 267
delete (nnIndex); 
# 268
} 
# 270
template< class Distance> void 
# 271
GenericIndex< Distance> ::knnSearch(const std::vector< typename Distance::ElementType>  &query, std::vector< int>  &indices, std::vector< typename Distance::ResultType>  &dists, int knn, const cvflann::SearchParams &searchParams) 
# 272
{ 
# 273
cvflann::Matrix< typename Distance::ElementType>  m_query((ElementType *)(&(query[0])), 1, (query.size())); 
# 274
cvflann::Matrix< int>  m_indices(&indices[0], 1, indices.size()); 
# 275
cvflann::Matrix< typename Distance::ResultType>  m_dists(&(dists[0]), 1, (dists.size())); 
# 277
if ((::cvflann::flann_distance_type()) != (cvflann::FLANN_DIST_L2)) { printf("[WARNING] You are using cv::flann::Index (or cv::flann::GenericIndex) and have also changed the distance using cvflann::set_dist" "ance_type. This is no longer working as expected (cv::flann::Index always uses L2). You should create the index templated on the" " distance, for example for L1 distance use: GenericIndex< L1<float> > \n"); }  
# 279
((nnIndex)->knnSearch(m_query, m_indices, m_dists, knn, searchParams)); 
# 280
} 
# 283
template< class Distance> void 
# 284
GenericIndex< Distance> ::knnSearch(const Mat &queries, Mat &indices, Mat &dists, int knn, const cvflann::SearchParams &searchParams) 
# 285
{ 
# 286
if (!(!(queries.type() == CvType< typename Distance::ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "queries.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 286); }  
# 287
if (!(!queries.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "queries.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 287); }  
# 288
cvflann::Matrix< typename Distance::ElementType>  m_queries((ElementType *)(queries.template ptr< ElementType> (0)), queries.rows, queries.cols); 
# 290
if (!(!(indices.type() == 4))) { ; } else { cv::error(cv::Error::StsAssert, "indices.type() == 4", __func__, "/usr/include/opencv2/flann.hpp", 290); }  
# 291
if (!(!indices.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "indices.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 291); }  
# 292
cvflann::Matrix< int>  m_indices((int *)indices.template ptr< int> (0), indices.rows, indices.cols); 
# 294
if (!(!(dists.type() == CvType< typename Distance::ResultType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dists.type() == CvType<DistanceType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 294); }  
# 295
if (!(!dists.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dists.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 295); }  
# 296
cvflann::Matrix< typename Distance::ResultType>  m_dists((DistanceType *)(dists.template ptr< DistanceType> (0)), dists.rows, dists.cols); 
# 298
if ((::cvflann::flann_distance_type()) != (cvflann::FLANN_DIST_L2)) { printf("[WARNING] You are using cv::flann::Index (or cv::flann::GenericIndex) and have also changed the distance using cvflann::set_dist" "ance_type. This is no longer working as expected (cv::flann::Index always uses L2). You should create the index templated on the" " distance, for example for L1 distance use: GenericIndex< L1<float> > \n"); }  
# 300
((nnIndex)->knnSearch(m_queries, m_indices, m_dists, knn, searchParams)); 
# 301
} 
# 303
template< class Distance> int 
# 304
GenericIndex< Distance> ::radiusSearch(const std::vector< typename Distance::ElementType>  &query, std::vector< int>  &indices, std::vector< typename Distance::ResultType>  &dists, DistanceType radius, const cvflann::SearchParams &searchParams) 
# 305
{ 
# 306
cvflann::Matrix< typename Distance::ElementType>  m_query((ElementType *)(&(query[0])), 1, (query.size())); 
# 307
cvflann::Matrix< int>  m_indices(&indices[0], 1, indices.size()); 
# 308
cvflann::Matrix< typename Distance::ResultType>  m_dists(&(dists[0]), 1, (dists.size())); 
# 310
if ((::cvflann::flann_distance_type()) != (cvflann::FLANN_DIST_L2)) { printf("[WARNING] You are using cv::flann::Index (or cv::flann::GenericIndex) and have also changed the distance using cvflann::set_dist" "ance_type. This is no longer working as expected (cv::flann::Index always uses L2). You should create the index templated on the" " distance, for example for L1 distance use: GenericIndex< L1<float> > \n"); }  
# 312
return ((nnIndex)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams)); 
# 313
} 
# 315
template< class Distance> int 
# 316
GenericIndex< Distance> ::radiusSearch(const Mat &query, Mat &indices, Mat &dists, DistanceType radius, const cvflann::SearchParams &searchParams) 
# 317
{ 
# 318
if (!(!(query.type() == CvType< typename Distance::ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "query.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 318); }  
# 319
if (!(!query.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "query.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 319); }  
# 320
cvflann::Matrix< typename Distance::ElementType>  m_query((ElementType *)(query.template ptr< ElementType> (0)), query.rows, query.cols); 
# 322
if (!(!(indices.type() == 4))) { ; } else { cv::error(cv::Error::StsAssert, "indices.type() == 4", __func__, "/usr/include/opencv2/flann.hpp", 322); }  
# 323
if (!(!indices.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "indices.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 323); }  
# 324
cvflann::Matrix< int>  m_indices((int *)indices.template ptr< int> (0), indices.rows, indices.cols); 
# 326
if (!(!(dists.type() == CvType< typename Distance::ResultType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dists.type() == CvType<DistanceType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 326); }  
# 327
if (!(!dists.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dists.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 327); }  
# 328
cvflann::Matrix< typename Distance::ResultType>  m_dists((DistanceType *)(dists.template ptr< DistanceType> (0)), dists.rows, dists.cols); 
# 330
if ((::cvflann::flann_distance_type()) != (cvflann::FLANN_DIST_L2)) { printf("[WARNING] You are using cv::flann::Index (or cv::flann::GenericIndex) and have also changed the distance using cvflann::set_dist" "ance_type. This is no longer working as expected (cv::flann::Index always uses L2). You should create the index templated on the" " distance, for example for L1 distance use: GenericIndex< L1<float> > \n"); }  
# 332
return ((nnIndex)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams)); 
# 333
} 
# 340
template< class T> 
# 341
class Index_ { 
# 344
public: typedef typename cvflann::L2< T> ::ElementType ElementType; 
# 345
typedef typename cvflann::L2< T> ::ResultType DistanceType; 
# 347
__attribute((deprecated)) Index_(const Mat &dataset, const cvflann::IndexParams &params) 
# 348
{ 
# 349
printf("[WARNING] The cv::flann::Index_<T> class is deperecated, use cv::flann::GenericIndex<Distance> instead\n"); 
# 351
if (!(!(dataset.type() == CvType< typename cvflann::L2< T> ::ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dataset.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 351); }  
# 352
if (!(!dataset.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dataset.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 352); }  
# 353
cvflann::Matrix< typename cvflann::L2< T> ::ElementType>  m_dataset((ElementType *)(dataset.template ptr< ElementType> (0)), dataset.rows, dataset.cols); 
# 355
if ((::cvflann::flann_distance_type()) == (cvflann::FLANN_DIST_L2)) { 
# 356
(nnIndex_L1) = __null; 
# 357
(nnIndex_L2) = (new cvflann::Index< cvflann::L2< typename cvflann::L2< T> ::ElementType> > (m_dataset, params)); 
# 358
} else { 
# 359
if ((::cvflann::flann_distance_type()) == (cvflann::FLANN_DIST_L1)) { 
# 360
(nnIndex_L1) = (new cvflann::Index< cvflann::L1< typename cvflann::L2< T> ::ElementType> > (m_dataset, params)); 
# 361
(nnIndex_L2) = __null; 
# 362
} else 
# 363
{ 
# 364
printf("[ERROR] cv::flann::Index_<T> only provides backwards compatibility for the L1 and L2 distances. For other distance types you mus" "t use cv::flann::GenericIndex<Distance>\n"); 
# 366
if (!(!(0))) { ; } else { cv::error(cv::Error::StsAssert, "0", __func__, "/usr/include/opencv2/flann.hpp", 366); }  
# 367
}  }  
# 368
if (nnIndex_L1) { ((nnIndex_L1)->buildIndex()); }  
# 369
if (nnIndex_L2) { ((nnIndex_L2)->buildIndex()); }  
# 370
} 
# 371
__attribute((deprecated)) ~Index_() 
# 372
{ 
# 373
if (nnIndex_L1) { delete (nnIndex_L1); }  
# 374
if (nnIndex_L2) { delete (nnIndex_L2); }  
# 375
} 
# 377
__attribute((deprecated)) void knnSearch(const std::vector< typename cvflann::L2< T> ::ElementType>  &query, std::vector< int>  &indices, std::vector< typename cvflann::L2< T> ::ResultType>  &dists, int knn, const cvflann::SearchParams &searchParams) 
# 378
{ 
# 379
cvflann::Matrix< typename cvflann::L2< T> ::ElementType>  m_query((ElementType *)(&(query[0])), 1, (query.size())); 
# 380
cvflann::Matrix< int>  m_indices(&indices[0], 1, indices.size()); 
# 381
cvflann::Matrix< typename cvflann::L2< T> ::ResultType>  m_dists(&(dists[0]), 1, (dists.size())); 
# 383
if (nnIndex_L1) { ((nnIndex_L1)->knnSearch(m_query, m_indices, m_dists, knn, searchParams)); }  
# 384
if (nnIndex_L2) { ((nnIndex_L2)->knnSearch(m_query, m_indices, m_dists, knn, searchParams)); }  
# 385
} 
# 386
__attribute((deprecated)) void knnSearch(const Mat &queries, Mat &indices, Mat &dists, int knn, const cvflann::SearchParams &searchParams) 
# 387
{ 
# 388
if (!(!(queries.type() == CvType< typename cvflann::L2< T> ::ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "queries.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 388); }  
# 389
if (!(!queries.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "queries.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 389); }  
# 390
cvflann::Matrix< typename cvflann::L2< T> ::ElementType>  m_queries((ElementType *)(queries.template ptr< ElementType> (0)), queries.rows, queries.cols); 
# 392
if (!(!(indices.type() == 4))) { ; } else { cv::error(cv::Error::StsAssert, "indices.type() == 4", __func__, "/usr/include/opencv2/flann.hpp", 392); }  
# 393
if (!(!indices.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "indices.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 393); }  
# 394
cvflann::Matrix< int>  m_indices((int *)indices.template ptr< int> (0), indices.rows, indices.cols); 
# 396
if (!(!(dists.type() == CvType< typename cvflann::L2< T> ::ResultType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dists.type() == CvType<DistanceType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 396); }  
# 397
if (!(!dists.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dists.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 397); }  
# 398
cvflann::Matrix< typename cvflann::L2< T> ::ResultType>  m_dists((DistanceType *)(dists.template ptr< DistanceType> (0)), dists.rows, dists.cols); 
# 400
if (nnIndex_L1) { ((nnIndex_L1)->knnSearch(m_queries, m_indices, m_dists, knn, searchParams)); }  
# 401
if (nnIndex_L2) { ((nnIndex_L2)->knnSearch(m_queries, m_indices, m_dists, knn, searchParams)); }  
# 402
} 
# 404
__attribute((deprecated)) int radiusSearch(const std::vector< typename cvflann::L2< T> ::ElementType>  &query, std::vector< int>  &indices, std::vector< typename cvflann::L2< T> ::ResultType>  &dists, DistanceType radius, const cvflann::SearchParams &searchParams) 
# 405
{ 
# 406
cvflann::Matrix< typename cvflann::L2< T> ::ElementType>  m_query((ElementType *)(&(query[0])), 1, (query.size())); 
# 407
cvflann::Matrix< int>  m_indices(&indices[0], 1, indices.size()); 
# 408
cvflann::Matrix< typename cvflann::L2< T> ::ResultType>  m_dists(&(dists[0]), 1, (dists.size())); 
# 410
if (nnIndex_L1) { return ((nnIndex_L1)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams)); }  
# 411
if (nnIndex_L2) { return ((nnIndex_L2)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams)); }  
# 412
} 
# 414
__attribute((deprecated)) int radiusSearch(const Mat &query, Mat &indices, Mat &dists, DistanceType radius, const cvflann::SearchParams &searchParams) 
# 415
{ 
# 416
if (!(!(query.type() == CvType< typename cvflann::L2< T> ::ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "query.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 416); }  
# 417
if (!(!query.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "query.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 417); }  
# 418
cvflann::Matrix< typename cvflann::L2< T> ::ElementType>  m_query((ElementType *)(query.template ptr< ElementType> (0)), query.rows, query.cols); 
# 420
if (!(!(indices.type() == 4))) { ; } else { cv::error(cv::Error::StsAssert, "indices.type() == 4", __func__, "/usr/include/opencv2/flann.hpp", 420); }  
# 421
if (!(!indices.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "indices.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 421); }  
# 422
cvflann::Matrix< int>  m_indices((int *)indices.template ptr< int> (0), indices.rows, indices.cols); 
# 424
if (!(!(dists.type() == CvType< typename cvflann::L2< T> ::ResultType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dists.type() == CvType<DistanceType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 424); }  
# 425
if (!(!dists.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dists.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 425); }  
# 426
cvflann::Matrix< typename cvflann::L2< T> ::ResultType>  m_dists((DistanceType *)(dists.template ptr< DistanceType> (0)), dists.rows, dists.cols); 
# 428
if (nnIndex_L1) { return ((nnIndex_L1)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams)); }  
# 429
if (nnIndex_L2) { return ((nnIndex_L2)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams)); }  
# 430
} 
# 432
__attribute((deprecated)) void save(String filename) 
# 433
{ 
# 434
if (nnIndex_L1) { ((nnIndex_L1)->save(filename)); }  
# 435
if (nnIndex_L2) { ((nnIndex_L2)->save(filename)); }  
# 436
} 
# 438
__attribute((deprecated)) int veclen() const 
# 439
{ 
# 440
if (nnIndex_L1) { return ((nnIndex_L1)->veclen()); }  
# 441
if (nnIndex_L2) { return ((nnIndex_L2)->veclen()); }  
# 442
} 
# 444
__attribute((deprecated)) int size() const 
# 445
{ 
# 446
if (nnIndex_L1) { return ((nnIndex_L1)->size()); }  
# 447
if (nnIndex_L2) { return ((nnIndex_L2)->size()); }  
# 448
} 
# 450
__attribute((deprecated)) cvflann::IndexParams getParameters() 
# 451
{ 
# 452
if (nnIndex_L1) { return ((nnIndex_L1)->getParameters()); }  
# 453
if (nnIndex_L2) { return ((nnIndex_L2)->getParameters()); }  
# 455
} 
# 457
__attribute((deprecated)) const cvflann::IndexParams *getIndexParameters() 
# 458
{ 
# 459
if (nnIndex_L1) { return ((nnIndex_L1)->getIndexParameters()); }  
# 460
if (nnIndex_L2) { return ((nnIndex_L2)->getIndexParameters()); }  
# 461
} 
# 465
private: cvflann::Index< cvflann::L2< typename cvflann::L2< T> ::ElementType> >  *nnIndex_L2; 
# 466
cvflann::Index< cvflann::L1< typename cvflann::L2< T> ::ElementType> >  *nnIndex_L1; 
# 467
}; 
# 487 "/usr/include/opencv2/flann.hpp" 3
template< class Distance> int 
# 488
hierarchicalClustering(const Mat &features, Mat &centers, const cvflann::KMeansIndexParams &params, Distance 
# 489
d = Distance()) 
# 490
{ 
# 491
typedef typename Distance::ElementType ElementType; 
# 492
typedef typename Distance::ResultType DistanceType; 
# 494
if (!(!(features.type() == CvType< typename Distance::ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "features.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 494); }  
# 495
if (!(!features.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "features.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 495); }  
# 496
cvflann::Matrix< typename Distance::ElementType>  m_features((ElementType *)(features.template ptr< typename Distance::ElementType> (0)), features.rows, features.cols); 
# 498
if (!(!(centers.type() == CvType< typename Distance::ResultType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "centers.type() == CvType<DistanceType>::type()", __func__, "/usr/include/opencv2/flann.hpp", 498); }  
# 499
if (!(!centers.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "centers.isContinuous()", __func__, "/usr/include/opencv2/flann.hpp", 499); }  
# 500
cvflann::Matrix< typename Distance::ResultType>  m_centers((DistanceType *)(centers.template ptr< typename Distance::ResultType> (0)), centers.rows, centers.cols); 
# 502
return cvflann::hierarchicalClustering< Distance> (m_features, m_centers, params, d); 
# 503
} 
# 507
template< class ELEM_TYPE, class DIST_TYPE> 
# 508
__attribute((deprecated)) int hierarchicalClustering(const Mat &features, Mat &centers, const cvflann::KMeansIndexParams &params) 
# 509
{ 
# 510
printf("[WARNING] cv::flann::hierarchicalClustering<ELEM_TYPE,DIST_TYPE> is deprecated, use cv::flann::hierarchicalClustering<Distance> " "instead\n"); 
# 513
if ((::cvflann::flann_distance_type()) == (cvflann::FLANN_DIST_L2)) { 
# 514
return hierarchicalClustering< cvflann::L2< ELEM_TYPE> > (features, centers, params); 
# 515
} else { 
# 516
if ((::cvflann::flann_distance_type()) == (cvflann::FLANN_DIST_L1)) { 
# 517
return hierarchicalClustering< cvflann::L1< ELEM_TYPE> > (features, centers, params); 
# 518
} else 
# 519
{ 
# 520
printf("[ERROR] cv::flann::hierarchicalClustering<ELEM_TYPE,DIST_TYPE> only provides backwards compatibility for the L1 and L2 distances" ". For other distance types you must use cv::flann::hierarchicalClustering<Distance>\n"); 
# 523
if (!(!(0))) { ; } else { cv::error(cv::Error::StsAssert, "0", __func__, "/usr/include/opencv2/flann.hpp", 523); }  
# 524
}  }  
# 525
} 
# 529
}}
# 57 "/usr/include/opencv2/imgcodecs.hpp" 3
namespace cv { 
# 64
enum ImreadModes { 
# 65
IMREAD_UNCHANGED = (-1), 
# 66
IMREAD_GRAYSCALE = 0, 
# 67
IMREAD_COLOR, 
# 68
IMREAD_ANYDEPTH, 
# 69
IMREAD_ANYCOLOR = 4, 
# 70
IMREAD_LOAD_GDAL = 8, 
# 71
IMREAD_REDUCED_GRAYSCALE_2 = 16, 
# 72
IMREAD_REDUCED_COLOR_2, 
# 73
IMREAD_REDUCED_GRAYSCALE_4 = 32, 
# 74
IMREAD_REDUCED_COLOR_4, 
# 75
IMREAD_REDUCED_GRAYSCALE_8 = 64, 
# 76
IMREAD_REDUCED_COLOR_8, 
# 77
IMREAD_IGNORE_ORIENTATION = 128
# 78
}; 
# 81
enum ImwriteFlags { 
# 82
IMWRITE_JPEG_QUALITY = 1, 
# 83
IMWRITE_JPEG_PROGRESSIVE, 
# 84
IMWRITE_JPEG_OPTIMIZE, 
# 85
IMWRITE_JPEG_RST_INTERVAL, 
# 86
IMWRITE_JPEG_LUMA_QUALITY, 
# 87
IMWRITE_JPEG_CHROMA_QUALITY, 
# 88
IMWRITE_PNG_COMPRESSION = 16, 
# 89
IMWRITE_PNG_STRATEGY, 
# 90
IMWRITE_PNG_BILEVEL, 
# 91
IMWRITE_PXM_BINARY = 32, 
# 92
IMWRITE_WEBP_QUALITY = 64, 
# 93
IMWRITE_PAM_TUPLETYPE = 128
# 94
}; 
# 104 "/usr/include/opencv2/imgcodecs.hpp" 3
enum ImwritePNGFlags { 
# 105
IMWRITE_PNG_STRATEGY_DEFAULT, 
# 106
IMWRITE_PNG_STRATEGY_FILTERED, 
# 107
IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY, 
# 108
IMWRITE_PNG_STRATEGY_RLE, 
# 109
IMWRITE_PNG_STRATEGY_FIXED
# 110
}; 
# 113
enum ImwritePAMFlags { 
# 114
IMWRITE_PAM_FORMAT_NULL, 
# 115
IMWRITE_PAM_FORMAT_BLACKANDWHITE, 
# 116
IMWRITE_PAM_FORMAT_GRAYSCALE, 
# 117
IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA, 
# 118
IMWRITE_PAM_FORMAT_RGB, 
# 119
IMWRITE_PAM_FORMAT_RGB_ALPHA
# 120
}; 
# 166 "/usr/include/opencv2/imgcodecs.hpp" 3
__attribute((visibility("default"))) Mat imread(const String & filename, int flags = IMREAD_COLOR); 
# 176 "/usr/include/opencv2/imgcodecs.hpp" 3
__attribute((visibility("default"))) bool imreadmulti(const String & filename, std::vector< Mat>  & mats, int flags = IMREAD_ANYCOLOR); 
# 239 "/usr/include/opencv2/imgcodecs.hpp" 3
__attribute((visibility("default"))) bool imwrite(const String & filename, InputArray img, const std::vector< int>  & params = std::vector< int> ()); 
# 253 "/usr/include/opencv2/imgcodecs.hpp" 3
__attribute((visibility("default"))) Mat imdecode(InputArray buf, int flags); 
# 261
__attribute((visibility("default"))) Mat imdecode(InputArray buf, int flags, Mat * dst); 
# 273 "/usr/include/opencv2/imgcodecs.hpp" 3
__attribute((visibility("default"))) bool imencode(const String & ext, InputArray img, std::vector< unsigned char>  & buf, const std::vector< int>  & params = std::vector< int> ()); 
# 279
}
# 67 "/usr/include/opencv2/videoio.hpp" 3
typedef struct CvCapture CvCapture; 
# 68
typedef struct CvVideoWriter CvVideoWriter; 
# 70
namespace cv { 
# 88 "/usr/include/opencv2/videoio.hpp" 3
enum VideoCaptureAPIs { 
# 89
CAP_ANY, 
# 90
CAP_VFW = 200, 
# 91
CAP_V4L = 200, 
# 92
CAP_V4L2 = 200, 
# 93
CAP_FIREWIRE = 300, 
# 94
CAP_FIREWARE = 300, 
# 95
CAP_IEEE1394 = 300, 
# 96
CAP_DC1394 = 300, 
# 97
CAP_CMU1394 = 300, 
# 98
CAP_QT = 500, 
# 99
CAP_UNICAP = 600, 
# 100
CAP_DSHOW = 700, 
# 101
CAP_PVAPI = 800, 
# 102
CAP_OPENNI = 900, 
# 103
CAP_OPENNI_ASUS = 910, 
# 104
CAP_ANDROID = 1000, 
# 105
CAP_XIAPI = 1100, 
# 106
CAP_AVFOUNDATION = 1200, 
# 107
CAP_GIGANETIX = 1300, 
# 108
CAP_MSMF = 1400, 
# 109
CAP_WINRT = 1410, 
# 110
CAP_INTELPERC = 1500, 
# 111
CAP_OPENNI2 = 1600, 
# 112
CAP_OPENNI2_ASUS = 1610, 
# 113
CAP_GPHOTO2 = 1700, 
# 114
CAP_GSTREAMER = 1800, 
# 115
CAP_FFMPEG = 1900, 
# 116
CAP_IMAGES = 2000, 
# 117
CAP_ARAVIS = 2100, 
# 118
CAP_OPENCV_MJPEG = 2200, 
# 119
CAP_INTEL_MFX = 2300
# 120
}; 
# 128
enum VideoCaptureProperties { 
# 129
CAP_PROP_POS_MSEC, 
# 130
CAP_PROP_POS_FRAMES, 
# 131
CAP_PROP_POS_AVI_RATIO, 
# 132
CAP_PROP_FRAME_WIDTH, 
# 133
CAP_PROP_FRAME_HEIGHT, 
# 134
CAP_PROP_FPS, 
# 135
CAP_PROP_FOURCC, 
# 136
CAP_PROP_FRAME_COUNT, 
# 137
CAP_PROP_FORMAT, 
# 138
CAP_PROP_MODE, 
# 139
CAP_PROP_BRIGHTNESS, 
# 140
CAP_PROP_CONTRAST, 
# 141
CAP_PROP_SATURATION, 
# 142
CAP_PROP_HUE, 
# 143
CAP_PROP_GAIN, 
# 144
CAP_PROP_EXPOSURE, 
# 145
CAP_PROP_CONVERT_RGB, 
# 146
CAP_PROP_WHITE_BALANCE_BLUE_U, 
# 147
CAP_PROP_RECTIFICATION, 
# 148
CAP_PROP_MONOCHROME, 
# 149
CAP_PROP_SHARPNESS, 
# 150
CAP_PROP_AUTO_EXPOSURE, 
# 151
CAP_PROP_GAMMA, 
# 152
CAP_PROP_TEMPERATURE, 
# 153
CAP_PROP_TRIGGER, 
# 154
CAP_PROP_TRIGGER_DELAY, 
# 155
CAP_PROP_WHITE_BALANCE_RED_V, 
# 156
CAP_PROP_ZOOM, 
# 157
CAP_PROP_FOCUS, 
# 158
CAP_PROP_GUID, 
# 159
CAP_PROP_ISO_SPEED, 
# 160
CAP_PROP_BACKLIGHT = 32, 
# 161
CAP_PROP_PAN, 
# 162
CAP_PROP_TILT, 
# 163
CAP_PROP_ROLL, 
# 164
CAP_PROP_IRIS, 
# 165
CAP_PROP_SETTINGS, 
# 166
CAP_PROP_BUFFERSIZE, 
# 167
CAP_PROP_AUTOFOCUS
# 168
}; 
# 174
enum VideoCaptureModes { 
# 175
CAP_MODE_BGR, 
# 176
CAP_MODE_RGB, 
# 177
CAP_MODE_GRAY, 
# 178
CAP_MODE_YUYV
# 179
}; 
# 184
enum VideoWriterProperties { 
# 185
VIDEOWRITER_PROP_QUALITY = 1, 
# 186
VIDEOWRITER_PROP_FRAMEBYTES, 
# 187
VIDEOWRITER_PROP_NSTRIPES
# 188
}; 
# 203 "/usr/include/opencv2/videoio.hpp" 3
enum { CAP_PROP_DC1394_OFF = (-4), 
# 204
CAP_PROP_DC1394_MODE_MANUAL, 
# 205
CAP_PROP_DC1394_MODE_AUTO, 
# 206
CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO, 
# 207
CAP_PROP_DC1394_MAX = 31
# 208
}; 
# 217 "/usr/include/opencv2/videoio.hpp" 3
enum { CAP_OPENNI_DEPTH_GENERATOR = (-2147483647-1), 
# 218
CAP_OPENNI_IMAGE_GENERATOR = 1073741824, 
# 219
CAP_OPENNI_IR_GENERATOR = 536870912, 
# 220
CAP_OPENNI_GENERATORS_MASK = (-536870912)
# 221
}; 
# 224
enum { CAP_PROP_OPENNI_OUTPUT_MODE = 100, 
# 225
CAP_PROP_OPENNI_FRAME_MAX_DEPTH, 
# 226
CAP_PROP_OPENNI_BASELINE, 
# 227
CAP_PROP_OPENNI_FOCAL_LENGTH, 
# 228
CAP_PROP_OPENNI_REGISTRATION, 
# 231
CAP_PROP_OPENNI_REGISTRATION_ON = 104, 
# 232
CAP_PROP_OPENNI_APPROX_FRAME_SYNC, 
# 233
CAP_PROP_OPENNI_MAX_BUFFER_SIZE, 
# 234
CAP_PROP_OPENNI_CIRCLE_BUFFER, 
# 235
CAP_PROP_OPENNI_MAX_TIME_DURATION, 
# 236
CAP_PROP_OPENNI_GENERATOR_PRESENT, 
# 237
CAP_PROP_OPENNI2_SYNC, 
# 238
CAP_PROP_OPENNI2_MIRROR
# 239
}; 
# 242
enum { CAP_OPENNI_IMAGE_GENERATOR_PRESENT = 1073741933, 
# 243
CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE = 1073741924, 
# 244
CAP_OPENNI_DEPTH_GENERATOR_PRESENT = (-2147483539), 
# 245
CAP_OPENNI_DEPTH_GENERATOR_BASELINE = (-2147483546), 
# 246
CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH, 
# 247
CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION, 
# 248
CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON = (-2147483544), 
# 249
CAP_OPENNI_IR_GENERATOR_PRESENT = 536871021
# 250
}; 
# 253
enum { CAP_OPENNI_DEPTH_MAP, 
# 254
CAP_OPENNI_POINT_CLOUD_MAP, 
# 255
CAP_OPENNI_DISPARITY_MAP, 
# 256
CAP_OPENNI_DISPARITY_MAP_32F, 
# 257
CAP_OPENNI_VALID_DEPTH_MASK, 
# 259
CAP_OPENNI_BGR_IMAGE, 
# 260
CAP_OPENNI_GRAY_IMAGE, 
# 262
CAP_OPENNI_IR_IMAGE
# 263
}; 
# 266
enum { CAP_OPENNI_VGA_30HZ, 
# 267
CAP_OPENNI_SXGA_15HZ, 
# 268
CAP_OPENNI_SXGA_30HZ, 
# 269
CAP_OPENNI_QVGA_30HZ, 
# 270
CAP_OPENNI_QVGA_60HZ
# 271
}; 
# 279
enum { CAP_PROP_GSTREAMER_QUEUE_LENGTH = 200
# 280
}; 
# 289 "/usr/include/opencv2/videoio.hpp" 3
enum { CAP_PROP_PVAPI_MULTICASTIP = 300, 
# 290
CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE, 
# 291
CAP_PROP_PVAPI_DECIMATIONHORIZONTAL, 
# 292
CAP_PROP_PVAPI_DECIMATIONVERTICAL, 
# 293
CAP_PROP_PVAPI_BINNINGX, 
# 294
CAP_PROP_PVAPI_BINNINGY, 
# 295
CAP_PROP_PVAPI_PIXELFORMAT
# 296
}; 
# 299
enum { CAP_PVAPI_FSTRIGMODE_FREERUN, 
# 300
CAP_PVAPI_FSTRIGMODE_SYNCIN1, 
# 301
CAP_PVAPI_FSTRIGMODE_SYNCIN2, 
# 302
CAP_PVAPI_FSTRIGMODE_FIXEDRATE, 
# 303
CAP_PVAPI_FSTRIGMODE_SOFTWARE
# 304
}; 
# 307
enum { CAP_PVAPI_DECIMATION_OFF = 1, 
# 308
CAP_PVAPI_DECIMATION_2OUTOF4, 
# 309
CAP_PVAPI_DECIMATION_2OUTOF8 = 4, 
# 310
CAP_PVAPI_DECIMATION_2OUTOF16 = 8
# 311
}; 
# 314
enum { CAP_PVAPI_PIXELFORMAT_MONO8 = 1, 
# 315
CAP_PVAPI_PIXELFORMAT_MONO16, 
# 316
CAP_PVAPI_PIXELFORMAT_BAYER8, 
# 317
CAP_PVAPI_PIXELFORMAT_BAYER16, 
# 318
CAP_PVAPI_PIXELFORMAT_RGB24, 
# 319
CAP_PVAPI_PIXELFORMAT_BGR24, 
# 320
CAP_PVAPI_PIXELFORMAT_RGBA32, 
# 321
CAP_PVAPI_PIXELFORMAT_BGRA32
# 322
}; 
# 331 "/usr/include/opencv2/videoio.hpp" 3
enum { CAP_PROP_XI_DOWNSAMPLING = 400, 
# 332
CAP_PROP_XI_DATA_FORMAT, 
# 333
CAP_PROP_XI_OFFSET_X, 
# 334
CAP_PROP_XI_OFFSET_Y, 
# 335
CAP_PROP_XI_TRG_SOURCE, 
# 336
CAP_PROP_XI_TRG_SOFTWARE, 
# 337
CAP_PROP_XI_GPI_SELECTOR, 
# 338
CAP_PROP_XI_GPI_MODE, 
# 339
CAP_PROP_XI_GPI_LEVEL, 
# 340
CAP_PROP_XI_GPO_SELECTOR, 
# 341
CAP_PROP_XI_GPO_MODE, 
# 342
CAP_PROP_XI_LED_SELECTOR, 
# 343
CAP_PROP_XI_LED_MODE, 
# 344
CAP_PROP_XI_MANUAL_WB, 
# 345
CAP_PROP_XI_AUTO_WB, 
# 346
CAP_PROP_XI_AEAG, 
# 347
CAP_PROP_XI_EXP_PRIORITY, 
# 348
CAP_PROP_XI_AE_MAX_LIMIT, 
# 349
CAP_PROP_XI_AG_MAX_LIMIT, 
# 350
CAP_PROP_XI_AEAG_LEVEL, 
# 351
CAP_PROP_XI_TIMEOUT, 
# 352
CAP_PROP_XI_EXPOSURE, 
# 353
CAP_PROP_XI_EXPOSURE_BURST_COUNT, 
# 354
CAP_PROP_XI_GAIN_SELECTOR, 
# 355
CAP_PROP_XI_GAIN, 
# 356
CAP_PROP_XI_DOWNSAMPLING_TYPE = 426, 
# 357
CAP_PROP_XI_BINNING_SELECTOR, 
# 358
CAP_PROP_XI_BINNING_VERTICAL, 
# 359
CAP_PROP_XI_BINNING_HORIZONTAL, 
# 360
CAP_PROP_XI_BINNING_PATTERN, 
# 361
CAP_PROP_XI_DECIMATION_SELECTOR, 
# 362
CAP_PROP_XI_DECIMATION_VERTICAL, 
# 363
CAP_PROP_XI_DECIMATION_HORIZONTAL, 
# 364
CAP_PROP_XI_DECIMATION_PATTERN, 
# 365
CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR = 587, 
# 366
CAP_PROP_XI_TEST_PATTERN, 
# 367
CAP_PROP_XI_IMAGE_DATA_FORMAT = 435, 
# 368
CAP_PROP_XI_SHUTTER_TYPE, 
# 369
CAP_PROP_XI_SENSOR_TAPS, 
# 370
CAP_PROP_XI_AEAG_ROI_OFFSET_X = 439, 
# 371
CAP_PROP_XI_AEAG_ROI_OFFSET_Y, 
# 372
CAP_PROP_XI_AEAG_ROI_WIDTH, 
# 373
CAP_PROP_XI_AEAG_ROI_HEIGHT, 
# 374
CAP_PROP_XI_BPC = 445, 
# 375
CAP_PROP_XI_WB_KR = 448, 
# 376
CAP_PROP_XI_WB_KG, 
# 377
CAP_PROP_XI_WB_KB, 
# 378
CAP_PROP_XI_WIDTH, 
# 379
CAP_PROP_XI_HEIGHT, 
# 380
CAP_PROP_XI_REGION_SELECTOR = 589, 
# 381
CAP_PROP_XI_REGION_MODE = 595, 
# 382
CAP_PROP_XI_LIMIT_BANDWIDTH = 459, 
# 383
CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH, 
# 384
CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH, 
# 385
CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH, 
# 386
CAP_PROP_XI_OUTPUT_DATA_PACKING, 
# 387
CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE, 
# 388
CAP_PROP_XI_IS_COOLED, 
# 389
CAP_PROP_XI_COOLING, 
# 390
CAP_PROP_XI_TARGET_TEMP, 
# 391
CAP_PROP_XI_CHIP_TEMP, 
# 392
CAP_PROP_XI_HOUS_TEMP, 
# 393
CAP_PROP_XI_HOUS_BACK_SIDE_TEMP = 590, 
# 394
CAP_PROP_XI_SENSOR_BOARD_TEMP = 596, 
# 395
CAP_PROP_XI_CMS = 470, 
# 396
CAP_PROP_XI_APPLY_CMS, 
# 397
CAP_PROP_XI_IMAGE_IS_COLOR = 474, 
# 398
CAP_PROP_XI_COLOR_FILTER_ARRAY, 
# 399
CAP_PROP_XI_GAMMAY, 
# 400
CAP_PROP_XI_GAMMAC, 
# 401
CAP_PROP_XI_SHARPNESS, 
# 402
CAP_PROP_XI_CC_MATRIX_00, 
# 403
CAP_PROP_XI_CC_MATRIX_01, 
# 404
CAP_PROP_XI_CC_MATRIX_02, 
# 405
CAP_PROP_XI_CC_MATRIX_03, 
# 406
CAP_PROP_XI_CC_MATRIX_10, 
# 407
CAP_PROP_XI_CC_MATRIX_11, 
# 408
CAP_PROP_XI_CC_MATRIX_12, 
# 409
CAP_PROP_XI_CC_MATRIX_13, 
# 410
CAP_PROP_XI_CC_MATRIX_20, 
# 411
CAP_PROP_XI_CC_MATRIX_21, 
# 412
CAP_PROP_XI_CC_MATRIX_22, 
# 413
CAP_PROP_XI_CC_MATRIX_23, 
# 414
CAP_PROP_XI_CC_MATRIX_30, 
# 415
CAP_PROP_XI_CC_MATRIX_31, 
# 416
CAP_PROP_XI_CC_MATRIX_32, 
# 417
CAP_PROP_XI_CC_MATRIX_33, 
# 418
CAP_PROP_XI_DEFAULT_CC_MATRIX, 
# 419
CAP_PROP_XI_TRG_SELECTOR = 498, 
# 420
CAP_PROP_XI_ACQ_FRAME_BURST_COUNT, 
# 421
CAP_PROP_XI_DEBOUNCE_EN = 507, 
# 422
CAP_PROP_XI_DEBOUNCE_T0, 
# 423
CAP_PROP_XI_DEBOUNCE_T1, 
# 424
CAP_PROP_XI_DEBOUNCE_POL, 
# 425
CAP_PROP_XI_LENS_MODE, 
# 426
CAP_PROP_XI_LENS_APERTURE_VALUE, 
# 427
CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE, 
# 428
CAP_PROP_XI_LENS_FOCUS_MOVE, 
# 429
CAP_PROP_XI_LENS_FOCUS_DISTANCE, 
# 430
CAP_PROP_XI_LENS_FOCAL_LENGTH, 
# 431
CAP_PROP_XI_LENS_FEATURE_SELECTOR, 
# 432
CAP_PROP_XI_LENS_FEATURE, 
# 433
CAP_PROP_XI_DEVICE_MODEL_ID = 521, 
# 434
CAP_PROP_XI_DEVICE_SN, 
# 435
CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA = 529, 
# 436
CAP_PROP_XI_IMAGE_PAYLOAD_SIZE, 
# 437
CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT, 
# 438
CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ, 
# 439
CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX, 
# 440
CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT, 
# 441
CAP_PROP_XI_FRAMERATE, 
# 442
CAP_PROP_XI_COUNTER_SELECTOR, 
# 443
CAP_PROP_XI_COUNTER_VALUE, 
# 444
CAP_PROP_XI_ACQ_TIMING_MODE, 
# 445
CAP_PROP_XI_AVAILABLE_BANDWIDTH, 
# 446
CAP_PROP_XI_BUFFER_POLICY, 
# 447
CAP_PROP_XI_LUT_EN, 
# 448
CAP_PROP_XI_LUT_INDEX, 
# 449
CAP_PROP_XI_LUT_VALUE, 
# 450
CAP_PROP_XI_TRG_DELAY, 
# 451
CAP_PROP_XI_TS_RST_MODE, 
# 452
CAP_PROP_XI_TS_RST_SOURCE, 
# 453
CAP_PROP_XI_IS_DEVICE_EXIST, 
# 454
CAP_PROP_XI_ACQ_BUFFER_SIZE, 
# 455
CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT, 
# 456
CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE, 
# 457
CAP_PROP_XI_BUFFERS_QUEUE_SIZE, 
# 458
CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT, 
# 459
CAP_PROP_XI_RECENT_FRAME, 
# 460
CAP_PROP_XI_DEVICE_RESET, 
# 461
CAP_PROP_XI_COLUMN_FPN_CORRECTION, 
# 462
CAP_PROP_XI_ROW_FPN_CORRECTION = 591, 
# 463
CAP_PROP_XI_SENSOR_MODE = 558, 
# 464
CAP_PROP_XI_HDR, 
# 465
CAP_PROP_XI_HDR_KNEEPOINT_COUNT, 
# 466
CAP_PROP_XI_HDR_T1, 
# 467
CAP_PROP_XI_HDR_T2, 
# 468
CAP_PROP_XI_KNEEPOINT1, 
# 469
CAP_PROP_XI_KNEEPOINT2, 
# 470
CAP_PROP_XI_IMAGE_BLACK_LEVEL, 
# 471
CAP_PROP_XI_HW_REVISION = 571, 
# 472
CAP_PROP_XI_DEBUG_LEVEL, 
# 473
CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION, 
# 474
CAP_PROP_XI_FFS_FILE_ID = 594, 
# 475
CAP_PROP_XI_FFS_FILE_SIZE = 580, 
# 476
CAP_PROP_XI_FREE_FFS_SIZE, 
# 477
CAP_PROP_XI_USED_FFS_SIZE, 
# 478
CAP_PROP_XI_FFS_ACCESS_KEY, 
# 479
CAP_PROP_XI_SENSOR_FEATURE_SELECTOR = 585, 
# 480
CAP_PROP_XI_SENSOR_FEATURE_VALUE
# 481
}; 
# 491 "/usr/include/opencv2/videoio.hpp" 3
enum { CAP_PROP_IOS_DEVICE_FOCUS = 9001, 
# 492
CAP_PROP_IOS_DEVICE_EXPOSURE, 
# 493
CAP_PROP_IOS_DEVICE_FLASH, 
# 494
CAP_PROP_IOS_DEVICE_WHITEBALANCE, 
# 495
CAP_PROP_IOS_DEVICE_TORCH
# 496
}; 
# 504
enum { CAP_PROP_GIGA_FRAME_OFFSET_X = 10001, 
# 505
CAP_PROP_GIGA_FRAME_OFFSET_Y, 
# 506
CAP_PROP_GIGA_FRAME_WIDTH_MAX, 
# 507
CAP_PROP_GIGA_FRAME_HEIGH_MAX, 
# 508
CAP_PROP_GIGA_FRAME_SENS_WIDTH, 
# 509
CAP_PROP_GIGA_FRAME_SENS_HEIGH
# 510
}; 
# 517
enum { CAP_PROP_INTELPERC_PROFILE_COUNT = 11001, 
# 518
CAP_PROP_INTELPERC_PROFILE_IDX, 
# 519
CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE, 
# 520
CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE, 
# 521
CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD, 
# 522
CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ, 
# 523
CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT
# 524
}; 
# 527
enum { CAP_INTELPERC_DEPTH_GENERATOR = 536870912, 
# 528
CAP_INTELPERC_IMAGE_GENERATOR = 268435456, 
# 529
CAP_INTELPERC_GENERATORS_MASK = 805306368
# 530
}; 
# 532
enum { CAP_INTELPERC_DEPTH_MAP, 
# 533
CAP_INTELPERC_UVDEPTH_MAP, 
# 534
CAP_INTELPERC_IR_MAP, 
# 535
CAP_INTELPERC_IMAGE
# 536
}; 
# 550 "/usr/include/opencv2/videoio.hpp" 3
enum { CAP_PROP_GPHOTO2_PREVIEW = 17001, 
# 551
CAP_PROP_GPHOTO2_WIDGET_ENUMERATE, 
# 552
CAP_PROP_GPHOTO2_RELOAD_CONFIG, 
# 553
CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE, 
# 554
CAP_PROP_GPHOTO2_COLLECT_MSGS, 
# 555
CAP_PROP_GPHOTO2_FLUSH_MSGS, 
# 556
CAP_PROP_SPEED, 
# 557
CAP_PROP_APERTURE, 
# 558
CAP_PROP_EXPOSUREPROGRAM, 
# 559
CAP_PROP_VIEWFINDER
# 560
}; 
# 572 "/usr/include/opencv2/videoio.hpp" 3
enum { CAP_PROP_IMAGES_BASE = 18000, 
# 573
CAP_PROP_IMAGES_LAST = 19000
# 574
}; 
# 581
class IVideoCapture; 
# 601 "/usr/include/opencv2/videoio.hpp" 3
class __attribute((visibility("default"))) VideoCapture { 
# 609
public: VideoCapture(); 
# 616
VideoCapture(const String & filename); 
# 631 "/usr/include/opencv2/videoio.hpp" 3
VideoCapture(const String & filename, int apiPreference); 
# 642 "/usr/include/opencv2/videoio.hpp" 3
VideoCapture(int index); 
# 648
virtual ~VideoCapture(); 
# 659 "/usr/include/opencv2/videoio.hpp" 3
virtual bool open(const String & filename); 
# 670 "/usr/include/opencv2/videoio.hpp" 3
virtual bool open(int index); 
# 680 "/usr/include/opencv2/videoio.hpp" 3
bool open(int cameraNum, int apiPreference); 
# 687
virtual bool isOpened() const; 
# 696 "/usr/include/opencv2/videoio.hpp" 3
virtual void release(); 
# 717 "/usr/include/opencv2/videoio.hpp" 3
virtual bool grab(); 
# 735 "/usr/include/opencv2/videoio.hpp" 3
virtual bool retrieve(OutputArray image, int flag = 0); 
# 740
virtual VideoCapture &operator>>(Mat & image); 
# 745
virtual VideoCapture &operator>>(UMat & image); 
# 761 "/usr/include/opencv2/videoio.hpp" 3
virtual bool read(OutputArray image); 
# 772 "/usr/include/opencv2/videoio.hpp" 3
virtual bool set(int propId, double value); 
# 791 "/usr/include/opencv2/videoio.hpp" 3
virtual double get(int propId) const; 
# 802 "/usr/include/opencv2/videoio.hpp" 3
virtual bool open(const String & filename, int apiPreference); 
# 805
protected: Ptr< CvCapture>  cap; 
# 806
Ptr< IVideoCapture>  icap; 
# 807
}; 
# 809
class IVideoWriter; 
# 818 "/usr/include/opencv2/videoio.hpp" 3
class __attribute((visibility("default"))) VideoWriter { 
# 828
public: VideoWriter(); 
# 851 "/usr/include/opencv2/videoio.hpp" 3
VideoWriter(const String & filename, int fourcc, double fps, Size frameSize, bool isColor = true); 
# 858
VideoWriter(const String & filename, int apiPreference, int fourcc, double fps, Size frameSize, bool isColor = true); 
# 865
virtual ~VideoWriter(); 
# 875 "/usr/include/opencv2/videoio.hpp" 3
virtual bool open(const String & filename, int fourcc, double fps, Size frameSize, bool isColor = true); 
# 880
bool open(const String & filename, int apiPreference, int fourcc, double fps, Size frameSize, bool isColor = true); 
# 885
virtual bool isOpened() const; 
# 892
virtual void release(); 
# 897
virtual VideoWriter &operator<<(const Mat & image); 
# 906 "/usr/include/opencv2/videoio.hpp" 3
virtual void write(const Mat & image); 
# 916 "/usr/include/opencv2/videoio.hpp" 3
virtual bool set(int propId, double value); 
# 926 "/usr/include/opencv2/videoio.hpp" 3
virtual double get(int propId) const; 
# 935 "/usr/include/opencv2/videoio.hpp" 3
static int fourcc(char c1, char c2, char c3, char c4); 
# 938
protected: Ptr< CvVideoWriter>  writer; 
# 939
Ptr< IVideoWriter>  iwriter; 
# 941
static Ptr< IVideoWriter>  create(const String & filename, int fourcc, double fps, Size frameSize, bool isColor = true); 
# 943
}; 
# 945
template<> __attribute((visibility("default"))) void DefaultDeleter< CvCapture> ::operator()(CvCapture * obj) const; 
# 946
template<> __attribute((visibility("default"))) void DefaultDeleter< CvVideoWriter> ::operator()(CvVideoWriter * obj) const; 
# 950
}
# 175 "/usr/include/opencv2/highgui.hpp" 3
namespace cv { 
# 182
enum WindowFlags { 
# 183
WINDOW_NORMAL, 
# 184
WINDOW_AUTOSIZE, 
# 185
WINDOW_OPENGL = 4096, 
# 187
WINDOW_FULLSCREEN = 1, 
# 188
WINDOW_FREERATIO = 256, 
# 189
WINDOW_KEEPRATIO = 0, 
# 190
WINDOW_GUI_EXPANDED = 0, 
# 191
WINDOW_GUI_NORMAL = 16
# 192
}; 
# 195
enum WindowPropertyFlags { 
# 196
WND_PROP_FULLSCREEN, 
# 197
WND_PROP_AUTOSIZE, 
# 198
WND_PROP_ASPECT_RATIO, 
# 199
WND_PROP_OPENGL, 
# 200
WND_PROP_VISIBLE
# 201
}; 
# 204
enum MouseEventTypes { 
# 205
EVENT_MOUSEMOVE, 
# 206
EVENT_LBUTTONDOWN, 
# 207
EVENT_RBUTTONDOWN, 
# 208
EVENT_MBUTTONDOWN, 
# 209
EVENT_LBUTTONUP, 
# 210
EVENT_RBUTTONUP, 
# 211
EVENT_MBUTTONUP, 
# 212
EVENT_LBUTTONDBLCLK, 
# 213
EVENT_RBUTTONDBLCLK, 
# 214
EVENT_MBUTTONDBLCLK, 
# 215
EVENT_MOUSEWHEEL, 
# 216
EVENT_MOUSEHWHEEL
# 217
}; 
# 220
enum MouseEventFlags { 
# 221
EVENT_FLAG_LBUTTON = 1, 
# 222
EVENT_FLAG_RBUTTON, 
# 223
EVENT_FLAG_MBUTTON = 4, 
# 224
EVENT_FLAG_CTRLKEY = 8, 
# 225
EVENT_FLAG_SHIFTKEY = 16, 
# 226
EVENT_FLAG_ALTKEY = 32
# 227
}; 
# 230
enum QtFontWeights { 
# 231
QT_FONT_LIGHT = 25, 
# 232
QT_FONT_NORMAL = 50, 
# 233
QT_FONT_DEMIBOLD = 63, 
# 234
QT_FONT_BOLD = 75, 
# 235
QT_FONT_BLACK = 87
# 236
}; 
# 239
enum QtFontStyles { 
# 240
QT_STYLE_NORMAL, 
# 241
QT_STYLE_ITALIC, 
# 242
QT_STYLE_OBLIQUE
# 243
}; 
# 246
enum QtButtonTypes { 
# 247
QT_PUSH_BUTTON, 
# 248
QT_CHECKBOX, 
# 249
QT_RADIOBOX, 
# 250
QT_NEW_BUTTONBAR = 1024
# 251
}; 
# 260 "/usr/include/opencv2/highgui.hpp" 3
typedef void (*MouseCallback)(int event, int x, int y, int flags, void * userdata); 
# 266
typedef void (*TrackbarCallback)(int pos, void * userdata); 
# 271
typedef void (*OpenGlDrawCallback)(void * userdata); 
# 277
typedef void (*ButtonCallback)(int state, void * userdata); 
# 305 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void namedWindow(const String & winname, int flags = WINDOW_AUTOSIZE); 
# 313
__attribute((visibility("default"))) void destroyWindow(const String & winname); 
# 319
__attribute((visibility("default"))) void destroyAllWindows(); 
# 321
__attribute((visibility("default"))) int startWindowThread(); 
# 330 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) int waitKeyEx(int delay = 0); 
# 353 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) int waitKey(int delay = 0); 
# 389 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void imshow(const String & winname, InputArray mat); 
# 402 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void resizeWindow(const String & winname, int width, int height); 
# 408
__attribute((visibility("default"))) void resizeWindow(const String & winname, const Size & size); 
# 416
__attribute((visibility("default"))) void moveWindow(const String & winname, int x, int y); 
# 426 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void setWindowProperty(const String & winname, int prop_id, double prop_value); 
# 432
__attribute((visibility("default"))) void setWindowTitle(const String & winname, const String & title); 
# 443 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) double getWindowProperty(const String & winname, int prop_id); 
# 453 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void setMouseCallback(const String & winname, MouseCallback onMouse, void * userdata = 0); 
# 475 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) int getMouseWheelDelta(int flags); 
# 491 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) Rect selectROI(const String & windowName, InputArray img, bool showCrosshair = true, bool fromCenter = false); 
# 495
__attribute((visibility("default"))) Rect selectROI(InputArray img, bool showCrosshair = true, bool fromCenter = false); 
# 512 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void selectROIs(const String & windowName, InputArray img, std::vector< Rect_< int> >  & boundingBoxes, bool showCrosshair = true, bool fromCenter = false); 
# 541 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) int createTrackbar(const String & trackbarname, const String & winname, int * value, int count, TrackbarCallback onChange = 0, void * userdata = 0); 
# 558 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) int getTrackbarPos(const String & trackbarname, const String & winname); 
# 573 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void setTrackbarPos(const String & trackbarname, const String & winname, int pos); 
# 588 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void setTrackbarMax(const String & trackbarname, const String & winname, int maxval); 
# 603 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void setTrackbarMin(const String & trackbarname, const String & winname, int minval); 
# 613 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void imshow(const String & winname, const ogl::Texture2D & tex); 
# 655 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void setOpenGlDrawCallback(const String & winname, OpenGlDrawCallback onOpenGlDraw, void * userdata = 0); 
# 661
__attribute((visibility("default"))) void setOpenGlContext(const String & winname); 
# 667
__attribute((visibility("default"))) void updateWindow(const String & winname); 
# 676 "/usr/include/opencv2/highgui.hpp" 3
struct QtFont { 
# 678
const char *nameFont; 
# 679
Scalar color; 
# 680
int font_face; 
# 681
const int *ascii; 
# 682
const int *greek; 
# 683
const int *cyrillic; 
# 684
float hscale, vscale; 
# 685
float shear; 
# 686
int thickness; 
# 687
float dx; 
# 688
int line_type; 
# 689
}; 
# 711 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) QtFont fontQt(const String & nameFont, int pointSize = -1, Scalar color = Scalar::all(0), int weight = QT_FONT_NORMAL, int style = QT_STYLE_NORMAL, int spacing = 0); 
# 725 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void addText(const Mat & img, const String & text, Point org, const QtFont & font); 
# 741 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void addText(const Mat & img, const String & text, Point org, const String & nameFont, int pointSize = -1, Scalar color = Scalar::all(0), int weight = QT_FONT_NORMAL, int style = QT_STYLE_NORMAL, int spacing = 0); 
# 756 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void displayOverlay(const String & winname, const String & text, int delayms = 0); 
# 770 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void displayStatusBar(const String & winname, const String & text, int delayms = 0); 
# 779 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void saveWindowParameters(const String & windowName); 
# 788 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) void loadWindowParameters(const String & windowName); 
# 790
__attribute((visibility("default"))) int startLoop(int (* pt2Func)(int argc, char * argv[]), int argc, char * argv[]); 
# 792
__attribute((visibility("default"))) void stopLoop(); 
# 820 "/usr/include/opencv2/highgui.hpp" 3
__attribute((visibility("default"))) int createButton(const String & bar_name, ButtonCallback on_change, void * userdata = 0, int type = QT_PUSH_BUTTON, bool initial_button_state = false); 
# 828
}
# 49 "/usr/include/opencv2/imgproc/types_c.h" 3
extern "C" {
# 65
typedef 
# 57
struct CvConnectedComp { 
# 59
double area; 
# 60
CvScalar value; 
# 61
CvRect rect; 
# 62
CvSeq *contour; 
# 65
} CvConnectedComp; 
# 68
enum SmoothMethod_c { 
# 73
CV_BLUR_NO_SCALE, 
# 76
CV_BLUR, 
# 78
CV_GAUSSIAN, 
# 80
CV_MEDIAN, 
# 84
CV_BILATERAL
# 85
}; 
# 89
enum { 
# 90
CV_GAUSSIAN_5x5 = 7
# 91
}; 
# 95
enum { 
# 96
CV_SCHARR = (-1), 
# 97
CV_MAX_SOBEL_KSIZE = 7
# 98
}; 
# 102
enum { 
# 103
CV_BGR2BGRA, 
# 104
CV_RGB2RGBA = 0, 
# 106
CV_BGRA2BGR, 
# 107
CV_RGBA2RGB = 1, 
# 109
CV_BGR2RGBA, 
# 110
CV_RGB2BGRA = 2, 
# 112
CV_RGBA2BGR, 
# 113
CV_BGRA2RGB = 3, 
# 115
CV_BGR2RGB, 
# 116
CV_RGB2BGR = 4, 
# 118
CV_BGRA2RGBA, 
# 119
CV_RGBA2BGRA = 5, 
# 121
CV_BGR2GRAY, 
# 122
CV_RGB2GRAY, 
# 123
CV_GRAY2BGR, 
# 124
CV_GRAY2RGB = 8, 
# 125
CV_GRAY2BGRA, 
# 126
CV_GRAY2RGBA = 9, 
# 127
CV_BGRA2GRAY, 
# 128
CV_RGBA2GRAY, 
# 130
CV_BGR2BGR565, 
# 131
CV_RGB2BGR565, 
# 132
CV_BGR5652BGR, 
# 133
CV_BGR5652RGB, 
# 134
CV_BGRA2BGR565, 
# 135
CV_RGBA2BGR565, 
# 136
CV_BGR5652BGRA, 
# 137
CV_BGR5652RGBA, 
# 139
CV_GRAY2BGR565, 
# 140
CV_BGR5652GRAY, 
# 142
CV_BGR2BGR555, 
# 143
CV_RGB2BGR555, 
# 144
CV_BGR5552BGR, 
# 145
CV_BGR5552RGB, 
# 146
CV_BGRA2BGR555, 
# 147
CV_RGBA2BGR555, 
# 148
CV_BGR5552BGRA, 
# 149
CV_BGR5552RGBA, 
# 151
CV_GRAY2BGR555, 
# 152
CV_BGR5552GRAY, 
# 154
CV_BGR2XYZ, 
# 155
CV_RGB2XYZ, 
# 156
CV_XYZ2BGR, 
# 157
CV_XYZ2RGB, 
# 159
CV_BGR2YCrCb, 
# 160
CV_RGB2YCrCb, 
# 161
CV_YCrCb2BGR, 
# 162
CV_YCrCb2RGB, 
# 164
CV_BGR2HSV, 
# 165
CV_RGB2HSV, 
# 167
CV_BGR2Lab = 44, 
# 168
CV_RGB2Lab, 
# 170
CV_BayerBG2BGR, 
# 171
CV_BayerGB2BGR, 
# 172
CV_BayerRG2BGR, 
# 173
CV_BayerGR2BGR, 
# 175
CV_BayerBG2RGB = 48, 
# 176
CV_BayerGB2RGB, 
# 177
CV_BayerRG2RGB = 46, 
# 178
CV_BayerGR2RGB, 
# 180
CV_BGR2Luv = 50, 
# 181
CV_RGB2Luv, 
# 182
CV_BGR2HLS, 
# 183
CV_RGB2HLS, 
# 185
CV_HSV2BGR, 
# 186
CV_HSV2RGB, 
# 188
CV_Lab2BGR, 
# 189
CV_Lab2RGB, 
# 190
CV_Luv2BGR, 
# 191
CV_Luv2RGB, 
# 192
CV_HLS2BGR, 
# 193
CV_HLS2RGB, 
# 195
CV_BayerBG2BGR_VNG, 
# 196
CV_BayerGB2BGR_VNG, 
# 197
CV_BayerRG2BGR_VNG, 
# 198
CV_BayerGR2BGR_VNG, 
# 200
CV_BayerBG2RGB_VNG = 64, 
# 201
CV_BayerGB2RGB_VNG, 
# 202
CV_BayerRG2RGB_VNG = 62, 
# 203
CV_BayerGR2RGB_VNG, 
# 205
CV_BGR2HSV_FULL = 66, 
# 206
CV_RGB2HSV_FULL, 
# 207
CV_BGR2HLS_FULL, 
# 208
CV_RGB2HLS_FULL, 
# 210
CV_HSV2BGR_FULL, 
# 211
CV_HSV2RGB_FULL, 
# 212
CV_HLS2BGR_FULL, 
# 213
CV_HLS2RGB_FULL, 
# 215
CV_LBGR2Lab, 
# 216
CV_LRGB2Lab, 
# 217
CV_LBGR2Luv, 
# 218
CV_LRGB2Luv, 
# 220
CV_Lab2LBGR, 
# 221
CV_Lab2LRGB, 
# 222
CV_Luv2LBGR, 
# 223
CV_Luv2LRGB, 
# 225
CV_BGR2YUV, 
# 226
CV_RGB2YUV, 
# 227
CV_YUV2BGR, 
# 228
CV_YUV2RGB, 
# 230
CV_BayerBG2GRAY, 
# 231
CV_BayerGB2GRAY, 
# 232
CV_BayerRG2GRAY, 
# 233
CV_BayerGR2GRAY, 
# 236
CV_YUV2RGB_NV12, 
# 237
CV_YUV2BGR_NV12, 
# 238
CV_YUV2RGB_NV21, 
# 239
CV_YUV2BGR_NV21, 
# 240
CV_YUV420sp2RGB = 92, 
# 241
CV_YUV420sp2BGR, 
# 243
CV_YUV2RGBA_NV12, 
# 244
CV_YUV2BGRA_NV12, 
# 245
CV_YUV2RGBA_NV21, 
# 246
CV_YUV2BGRA_NV21, 
# 247
CV_YUV420sp2RGBA = 96, 
# 248
CV_YUV420sp2BGRA, 
# 250
CV_YUV2RGB_YV12, 
# 251
CV_YUV2BGR_YV12, 
# 252
CV_YUV2RGB_IYUV, 
# 253
CV_YUV2BGR_IYUV, 
# 254
CV_YUV2RGB_I420 = 100, 
# 255
CV_YUV2BGR_I420, 
# 256
CV_YUV420p2RGB = 98, 
# 257
CV_YUV420p2BGR, 
# 259
CV_YUV2RGBA_YV12 = 102, 
# 260
CV_YUV2BGRA_YV12, 
# 261
CV_YUV2RGBA_IYUV, 
# 262
CV_YUV2BGRA_IYUV, 
# 263
CV_YUV2RGBA_I420 = 104, 
# 264
CV_YUV2BGRA_I420, 
# 265
CV_YUV420p2RGBA = 102, 
# 266
CV_YUV420p2BGRA, 
# 268
CV_YUV2GRAY_420 = 106, 
# 269
CV_YUV2GRAY_NV21 = 106, 
# 270
CV_YUV2GRAY_NV12 = 106, 
# 271
CV_YUV2GRAY_YV12 = 106, 
# 272
CV_YUV2GRAY_IYUV = 106, 
# 273
CV_YUV2GRAY_I420 = 106, 
# 274
CV_YUV420sp2GRAY = 106, 
# 275
CV_YUV420p2GRAY = 106, 
# 278
CV_YUV2RGB_UYVY, 
# 279
CV_YUV2BGR_UYVY, 
# 282
CV_YUV2RGB_Y422 = 107, 
# 283
CV_YUV2BGR_Y422, 
# 284
CV_YUV2RGB_UYNV = 107, 
# 285
CV_YUV2BGR_UYNV, 
# 287
CV_YUV2RGBA_UYVY = 111, 
# 288
CV_YUV2BGRA_UYVY, 
# 291
CV_YUV2RGBA_Y422 = 111, 
# 292
CV_YUV2BGRA_Y422, 
# 293
CV_YUV2RGBA_UYNV = 111, 
# 294
CV_YUV2BGRA_UYNV, 
# 296
CV_YUV2RGB_YUY2 = 115, 
# 297
CV_YUV2BGR_YUY2, 
# 298
CV_YUV2RGB_YVYU, 
# 299
CV_YUV2BGR_YVYU, 
# 300
CV_YUV2RGB_YUYV = 115, 
# 301
CV_YUV2BGR_YUYV, 
# 302
CV_YUV2RGB_YUNV = 115, 
# 303
CV_YUV2BGR_YUNV, 
# 305
CV_YUV2RGBA_YUY2 = 119, 
# 306
CV_YUV2BGRA_YUY2, 
# 307
CV_YUV2RGBA_YVYU, 
# 308
CV_YUV2BGRA_YVYU, 
# 309
CV_YUV2RGBA_YUYV = 119, 
# 310
CV_YUV2BGRA_YUYV, 
# 311
CV_YUV2RGBA_YUNV = 119, 
# 312
CV_YUV2BGRA_YUNV, 
# 314
CV_YUV2GRAY_UYVY = 123, 
# 315
CV_YUV2GRAY_YUY2, 
# 317
CV_YUV2GRAY_Y422 = 123, 
# 318
CV_YUV2GRAY_UYNV = 123, 
# 319
CV_YUV2GRAY_YVYU, 
# 320
CV_YUV2GRAY_YUYV = 124, 
# 321
CV_YUV2GRAY_YUNV = 124, 
# 324
CV_RGBA2mRGBA, 
# 325
CV_mRGBA2RGBA, 
# 327
CV_RGB2YUV_I420, 
# 328
CV_BGR2YUV_I420, 
# 329
CV_RGB2YUV_IYUV = 127, 
# 330
CV_BGR2YUV_IYUV, 
# 332
CV_RGBA2YUV_I420, 
# 333
CV_BGRA2YUV_I420, 
# 334
CV_RGBA2YUV_IYUV = 129, 
# 335
CV_BGRA2YUV_IYUV, 
# 336
CV_RGB2YUV_YV12, 
# 337
CV_BGR2YUV_YV12, 
# 338
CV_RGBA2YUV_YV12, 
# 339
CV_BGRA2YUV_YV12, 
# 342
CV_BayerBG2BGR_EA, 
# 343
CV_BayerGB2BGR_EA, 
# 344
CV_BayerRG2BGR_EA, 
# 345
CV_BayerGR2BGR_EA, 
# 347
CV_BayerBG2RGB_EA = 137, 
# 348
CV_BayerGB2RGB_EA, 
# 349
CV_BayerRG2RGB_EA = 135, 
# 350
CV_BayerGR2RGB_EA, 
# 352
CV_BayerBG2BGRA = 139, 
# 353
CV_BayerGB2BGRA, 
# 354
CV_BayerRG2BGRA, 
# 355
CV_BayerGR2BGRA, 
# 357
CV_BayerBG2RGBA = 141, 
# 358
CV_BayerGB2RGBA, 
# 359
CV_BayerRG2RGBA = 139, 
# 360
CV_BayerGR2RGBA, 
# 362
CV_COLORCVT_MAX = 143
# 363
}; 
# 368
enum { 
# 369
CV_INTER_NN, 
# 370
CV_INTER_LINEAR, 
# 371
CV_INTER_CUBIC, 
# 372
CV_INTER_AREA, 
# 373
CV_INTER_LANCZOS4
# 374
}; 
# 378
enum { 
# 379
CV_WARP_FILL_OUTLIERS = 8, 
# 380
CV_WARP_INVERSE_MAP = 16
# 381
}; 
# 386
enum MorphShapes_c { 
# 388
CV_SHAPE_RECT, 
# 389
CV_SHAPE_CROSS, 
# 390
CV_SHAPE_ELLIPSE, 
# 391
CV_SHAPE_CUSTOM = 100
# 392
}; 
# 396
enum { 
# 397
CV_MOP_ERODE, 
# 398
CV_MOP_DILATE, 
# 399
CV_MOP_OPEN, 
# 400
CV_MOP_CLOSE, 
# 401
CV_MOP_GRADIENT, 
# 402
CV_MOP_TOPHAT, 
# 403
CV_MOP_BLACKHAT
# 404
}; 
# 431
typedef 
# 407
struct CvMoments { 
# 409
double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; 
# 410
double mu20, mu11, mu02, mu30, mu21, mu12, mu03; 
# 411
double inv_sqrt_m00; 
# 414
CvMoments() { } 
# 415
CvMoments(const cv::Moments &m) 
# 416
{ 
# 417
(m00) = (m.m00); (m10) = (m.m10); (m01) = (m.m01); 
# 418
(m20) = (m.m20); (m11) = (m.m11); (m02) = (m.m02); 
# 419
(m30) = (m.m30); (m21) = (m.m21); (m12) = (m.m12); (m03) = (m.m03); 
# 420
(mu20) = (m.mu20); (mu11) = (m.mu11); (mu02) = (m.mu02); 
# 421
(mu30) = (m.mu30); (mu21) = (m.mu21); (mu12) = (m.mu12); (mu03) = (m.mu03); 
# 422
double am00 = std::abs(m.m00); 
# 423
(inv_sqrt_m00) = ((am00 > ((double)(2.220446049250313081e-16L))) ? (1.0) / std::sqrt(am00) : (0)); 
# 424
} 
# 425
operator cv::Moments() const 
# 426
{ 
# 427
return cv::Moments(m00, m10, m01, m20, m11, m02, m30, m21, m12, m03); 
# 428
} 
# 431
} CvMoments; 
# 438
typedef 
# 434
struct CvHuMoments { 
# 436
double hu1, hu2, hu3, hu4, hu5, hu6, hu7; 
# 438
} CvHuMoments; 
# 442
enum { 
# 443
CV_TM_SQDIFF, 
# 444
CV_TM_SQDIFF_NORMED, 
# 445
CV_TM_CCORR, 
# 446
CV_TM_CCORR_NORMED, 
# 447
CV_TM_CCOEFF, 
# 448
CV_TM_CCOEFF_NORMED
# 449
}; 
# 451
typedef float (*CvDistanceFunction)(const float * a, const float * b, void * user_param); 
# 455
enum { 
# 456
CV_RETR_EXTERNAL, 
# 457
CV_RETR_LIST, 
# 458
CV_RETR_CCOMP, 
# 459
CV_RETR_TREE, 
# 460
CV_RETR_FLOODFILL
# 461
}; 
# 465
enum { 
# 466
CV_CHAIN_CODE, 
# 467
CV_CHAIN_APPROX_NONE, 
# 468
CV_CHAIN_APPROX_SIMPLE, 
# 469
CV_CHAIN_APPROX_TC89_L1, 
# 470
CV_CHAIN_APPROX_TC89_KCOS, 
# 471
CV_LINK_RUNS
# 472
}; 
# 478
typedef struct _CvContourScanner *CvContourScanner; 
# 488
typedef 
# 481
struct CvChainPtReader { 
# 483
int header_size; CvSeq *seq; CvSeqBlock *block; schar *ptr; schar *block_min; schar *block_max; int delta_index; schar *prev_elem; 
# 484
char code; 
# 485
CvPoint pt; 
# 486
schar deltas[8][2]; 
# 488
} CvChainPtReader; 
# 500 "/usr/include/opencv2/imgproc/types_c.h" 3
enum { 
# 501
CV_POLY_APPROX_DP
# 502
}; 
# 506
enum { 
# 507
CV_CONTOURS_MATCH_I1 = 1, 
# 508
CV_CONTOURS_MATCH_I2, 
# 509
CV_CONTOURS_MATCH_I3
# 510
}; 
# 514
enum { 
# 515
CV_CLOCKWISE = 1, 
# 516
CV_COUNTER_CLOCKWISE
# 517
}; 
# 527
typedef 
# 521
struct CvConvexityDefect { 
# 523
CvPoint *start; 
# 524
CvPoint *end; 
# 525
CvPoint *depth_point; 
# 526
float depth; 
# 527
} CvConvexityDefect; 
# 532
enum { 
# 533
CV_COMP_CORREL, 
# 534
CV_COMP_CHISQR, 
# 535
CV_COMP_INTERSECT, 
# 536
CV_COMP_BHATTACHARYYA, 
# 537
CV_COMP_HELLINGER = 3, 
# 538
CV_COMP_CHISQR_ALT, 
# 539
CV_COMP_KL_DIV
# 540
}; 
# 544
enum { 
# 545
CV_DIST_MASK_3 = 3, 
# 546
CV_DIST_MASK_5 = 5, 
# 547
CV_DIST_MASK_PRECISE = 0
# 548
}; 
# 552
enum { 
# 553
CV_DIST_LABEL_CCOMP, 
# 554
CV_DIST_LABEL_PIXEL
# 555
}; 
# 559
enum { 
# 560
CV_DIST_USER = (-1), 
# 561
CV_DIST_L1 = 1, 
# 562
CV_DIST_L2, 
# 563
CV_DIST_C, 
# 564
CV_DIST_L12, 
# 565
CV_DIST_FAIR, 
# 566
CV_DIST_WELSCH, 
# 567
CV_DIST_HUBER
# 568
}; 
# 573
enum { 
# 574
CV_THRESH_BINARY, 
# 575
CV_THRESH_BINARY_INV, 
# 576
CV_THRESH_TRUNC, 
# 577
CV_THRESH_TOZERO, 
# 578
CV_THRESH_TOZERO_INV, 
# 579
CV_THRESH_MASK = 7, 
# 580
CV_THRESH_OTSU, 
# 582
CV_THRESH_TRIANGLE = 16
# 585
}; 
# 589
enum { 
# 590
CV_ADAPTIVE_THRESH_MEAN_C, 
# 591
CV_ADAPTIVE_THRESH_GAUSSIAN_C
# 592
}; 
# 596
enum { 
# 597
CV_FLOODFILL_FIXED_RANGE = 65536, 
# 598
CV_FLOODFILL_MASK_ONLY = 131072
# 599
}; 
# 604
enum { 
# 605
CV_CANNY_L2_GRADIENT = (-2147483647-1)
# 606
}; 
# 610
enum { 
# 611
CV_HOUGH_STANDARD, 
# 612
CV_HOUGH_PROBABILISTIC, 
# 613
CV_HOUGH_MULTI_SCALE, 
# 614
CV_HOUGH_GRADIENT
# 615
}; 
# 619
struct CvFeatureTree; 
# 620
struct CvLSH; 
# 621
struct CvLSHOperations; 
# 626
}
# 49 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
extern "C" {
# 61 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvAcc(const CvArr * image, CvArr * sum, const CvArr * mask = 0); 
# 67
__attribute((visibility("default"))) void cvSquareAcc(const CvArr * image, CvArr * sqsum, const CvArr * mask = 0); 
# 73
__attribute((visibility("default"))) void cvMultiplyAcc(const CvArr * image1, const CvArr * image2, CvArr * acc, const CvArr * mask = 0); 
# 79
__attribute((visibility("default"))) void cvRunningAvg(const CvArr * image, CvArr * acc, double alpha, const CvArr * mask = 0); 
# 88
__attribute((visibility("default"))) void cvCopyMakeBorder(const CvArr * src, CvArr * dst, CvPoint offset, int bordertype, CvScalar value = cvScalarAll(0)); 
# 111 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvSmooth(const CvArr * src, CvArr * dst, int smoothtype = CV_GAUSSIAN, int size1 = 3, int size2 = 0, double sigma1 = 0, double sigma2 = 0); 
# 131 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvFilter2D(const CvArr * src, CvArr * dst, const CvMat * kernel, CvPoint anchor = cvPoint(-1, -1)); 
# 137
__attribute((visibility("default"))) void cvIntegral(const CvArr * image, CvArr * sum, CvArr * sqsum = 0, CvArr * tilted_sum = 0); 
# 147
__attribute((visibility("default"))) void cvPyrDown(const CvArr * src, CvArr * dst, int filter = CV_GAUSSIAN_5x5); 
# 156
__attribute((visibility("default"))) void cvPyrUp(const CvArr * src, CvArr * dst, int filter = CV_GAUSSIAN_5x5); 
# 162
__attribute((visibility("default"))) CvMat **cvCreatePyramid(const CvArr * img, int extra_layers, double rate, const CvSize * layer_sizes = 0, CvArr * bufarr = 0, int calc = 1, int filter = CV_GAUSSIAN_5x5); 
# 169
__attribute((visibility("default"))) void cvReleasePyramid(CvMat *** pyramid, int extra_layers); 
# 175
__attribute((visibility("default"))) void cvPyrMeanShiftFiltering(const CvArr * src, CvArr * dst, double sp, double sr, int max_level = 1, CvTermCriteria termcrit = cvTermCriteria(1 + 2, 5, 1)); 
# 182
__attribute((visibility("default"))) void cvWatershed(const CvArr * image, CvArr * markers); 
# 190
__attribute((visibility("default"))) void cvSobel(const CvArr * src, CvArr * dst, int xorder, int yorder, int aperture_size = 3); 
# 197
__attribute((visibility("default"))) void cvLaplace(const CvArr * src, CvArr * dst, int aperture_size = 3); 
# 203
__attribute((visibility("default"))) void cvCvtColor(const CvArr * src, CvArr * dst, int code); 
# 209
__attribute((visibility("default"))) void cvResize(const CvArr * src, CvArr * dst, int interpolation = CV_INTER_LINEAR); 
# 217
__attribute((visibility("default"))) void cvWarpAffine(const CvArr * src, CvArr * dst, const CvMat * map_matrix, int flags = (CV_INTER_LINEAR) + (CV_WARP_FILL_OUTLIERS), CvScalar fillval = cvScalarAll(0)); 
# 224
__attribute((visibility("default"))) CvMat *cvGetAffineTransform(const CvPoint2D32f * src, const CvPoint2D32f * dst, CvMat * map_matrix); 
# 231
__attribute((visibility("default"))) CvMat *cv2DRotationMatrix(CvPoint2D32f center, double angle, double scale, CvMat * map_matrix); 
# 237
__attribute((visibility("default"))) void cvWarpPerspective(const CvArr * src, CvArr * dst, const CvMat * map_matrix, int flags = (CV_INTER_LINEAR) + (CV_WARP_FILL_OUTLIERS), CvScalar fillval = cvScalarAll(0)); 
# 244
__attribute((visibility("default"))) CvMat *cvGetPerspectiveTransform(const CvPoint2D32f * src, const CvPoint2D32f * dst, CvMat * map_matrix); 
# 251
__attribute((visibility("default"))) void cvRemap(const CvArr * src, CvArr * dst, const CvArr * mapx, const CvArr * mapy, int flags = (CV_INTER_LINEAR) + (CV_WARP_FILL_OUTLIERS), CvScalar fillval = cvScalarAll(0)); 
# 259
__attribute((visibility("default"))) void cvConvertMaps(const CvArr * mapx, const CvArr * mapy, CvArr * mapxy, CvArr * mapalpha); 
# 265
__attribute((visibility("default"))) void cvLogPolar(const CvArr * src, CvArr * dst, CvPoint2D32f center, double M, int flags = (CV_INTER_LINEAR) + (CV_WARP_FILL_OUTLIERS)); 
# 272
__attribute((visibility("default"))) void cvLinearPolar(const CvArr * src, CvArr * dst, CvPoint2D32f center, double maxRadius, int flags = (CV_INTER_LINEAR) + (CV_WARP_FILL_OUTLIERS)); 
# 279
__attribute((visibility("default"))) void cvUndistort2(const CvArr * src, CvArr * dst, const CvMat * camera_matrix, const CvMat * distortion_coeffs, const CvMat * new_camera_matrix = 0); 
# 287
__attribute((visibility("default"))) void cvInitUndistortMap(const CvMat * camera_matrix, const CvMat * distortion_coeffs, CvArr * mapx, CvArr * mapy); 
# 294
__attribute((visibility("default"))) void cvInitUndistortRectifyMap(const CvMat * camera_matrix, const CvMat * dist_coeffs, const CvMat * R, const CvMat * new_camera_matrix, CvArr * mapx, CvArr * mapy); 
# 303
__attribute((visibility("default"))) void cvUndistortPoints(const CvMat * src, CvMat * dst, const CvMat * camera_matrix, const CvMat * dist_coeffs, const CvMat * R = 0, const CvMat * P = 0); 
# 324 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) IplConvKernel *cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, int * values = 0); 
# 331
__attribute((visibility("default"))) void cvReleaseStructuringElement(IplConvKernel ** element); 
# 337
__attribute((visibility("default"))) void cvErode(const CvArr * src, CvArr * dst, IplConvKernel * element = 0, int iterations = 1); 
# 346
__attribute((visibility("default"))) void cvDilate(const CvArr * src, CvArr * dst, IplConvKernel * element = 0, int iterations = 1); 
# 353
__attribute((visibility("default"))) void cvMorphologyEx(const CvArr * src, CvArr * dst, CvArr * temp, IplConvKernel * element, int operation, int iterations = 1); 
# 360
__attribute((visibility("default"))) void cvMoments(const CvArr * arr, CvMoments * moments, int binary = 0); 
# 363
__attribute((visibility("default"))) double cvGetSpatialMoment(CvMoments * moments, int x_order, int y_order); 
# 365
__attribute((visibility("default"))) double cvGetCentralMoment(CvMoments * moments, int x_order, int y_order); 
# 367
__attribute((visibility("default"))) double cvGetNormalizedCentralMoment(CvMoments * moments, int x_order, int y_order); 
# 373
__attribute((visibility("default"))) void cvGetHuMoments(CvMoments * moments, CvHuMoments * hu_moments); 
# 382 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) int cvSampleLine(const CvArr * image, CvPoint pt1, CvPoint pt2, void * buffer, int connectivity = 8); 
# 391
__attribute((visibility("default"))) void cvGetRectSubPix(const CvArr * src, CvArr * dst, CvPoint2D32f center); 
# 401 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvGetQuadrangleSubPix(const CvArr * src, CvArr * dst, const CvMat * map_matrix); 
# 408
__attribute((visibility("default"))) void cvMatchTemplate(const CvArr * image, const CvArr * templ, CvArr * result, int method); 
# 415
__attribute((visibility("default"))) float cvCalcEMD2(const CvArr * signature1, const CvArr * signature2, int distance_type, CvDistanceFunction distance_func = 0, const CvArr * cost_matrix = 0, CvArr * flow = 0, float * lower_bound = 0, void * userdata = 0); 
# 432 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) int cvFindContours(CvArr * image, CvMemStorage * storage, CvSeq ** first_contour, int header_size = sizeof(CvContour), int mode = CV_RETR_LIST, int method = CV_CHAIN_APPROX_SIMPLE, CvPoint offset = cvPoint(0, 0)); 
# 446 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) CvContourScanner cvStartFindContours(CvArr * image, CvMemStorage * storage, int header_size = sizeof(CvContour), int mode = CV_RETR_LIST, int method = CV_CHAIN_APPROX_SIMPLE, CvPoint offset = cvPoint(0, 0)); 
# 455
__attribute((visibility("default"))) CvSeq *cvFindNextContour(CvContourScanner scanner); 
# 463
__attribute((visibility("default"))) void cvSubstituteContour(CvContourScanner scanner, CvSeq * new_contour); 
# 469
__attribute((visibility("default"))) CvSeq *cvEndFindContours(CvContourScanner * scanner); 
# 488 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) CvSeq *cvApproxChains(CvSeq * src_seq, CvMemStorage * storage, int method = CV_CHAIN_APPROX_SIMPLE, double parameter = 0, int minimal_perimeter = 0, int recursive = 0); 
# 500
__attribute((visibility("default"))) void cvStartReadChainPoints(CvChain * chain, CvChainPtReader * reader); 
# 505
__attribute((visibility("default"))) CvPoint cvReadChainPoint(CvChainPtReader * reader); 
# 516 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) CvSeq *cvApproxPoly(const void * src_seq, int header_size, CvMemStorage * storage, int method, double eps, int recursive = 0); 
# 524
__attribute((visibility("default"))) double cvArcLength(const void * curve, CvSlice slice = cvSlice(0, 1073741823), int is_closed = -1); 
# 530
static inline double cvContourPerimeter(const void *contour) 
# 531
{ 
# 532
return cvArcLength(contour, cvSlice(0, 1073741823), 1); 
# 533
} 
# 540
__attribute((visibility("default"))) CvRect cvBoundingRect(CvArr * points, int update = 0); 
# 545
__attribute((visibility("default"))) double cvContourArea(const CvArr * contour, CvSlice slice = cvSlice(0, 1073741823), int oriented = 0); 
# 552
__attribute((visibility("default"))) CvBox2D cvMinAreaRect2(const CvArr * points, CvMemStorage * storage = 0); 
# 558
__attribute((visibility("default"))) int cvMinEnclosingCircle(const CvArr * points, CvPoint2D32f * center, float * radius); 
# 564
__attribute((visibility("default"))) double cvMatchShapes(const void * object1, const void * object2, int method, double parameter = 0); 
# 570
__attribute((visibility("default"))) CvSeq *cvConvexHull2(const CvArr * input, void * hull_storage = 0, int orientation = CV_CLOCKWISE, int return_points = 0); 
# 578
__attribute((visibility("default"))) int cvCheckContourConvexity(const CvArr * contour); 
# 584
__attribute((visibility("default"))) CvSeq *cvConvexityDefects(const CvArr * contour, const CvArr * convexhull, CvMemStorage * storage = 0); 
# 590
__attribute((visibility("default"))) CvBox2D cvFitEllipse2(const CvArr * points); 
# 593
__attribute((visibility("default"))) CvRect cvMaxRect(const CvRect * rect1, const CvRect * rect2); 
# 596
__attribute((visibility("default"))) void cvBoxPoints(CvBox2D box, CvPoint2D32f  pt[4]); 
# 601
__attribute((visibility("default"))) CvSeq *cvPointSeqFromMat(int seq_kind, const CvArr * mat, CvContour * contour_header, CvSeqBlock * block); 
# 612 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) double cvPointPolygonTest(const CvArr * contour, CvPoint2D32f pt, int measure_dist); 
# 646 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) CvHistogram *cvCreateHist(int dims, int * sizes, int type, float ** ranges = 0, int uniform = 1); 
# 661 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvSetHistBinRanges(CvHistogram * hist, float ** ranges, int uniform = 1); 
# 677 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) CvHistogram *cvMakeHistHeaderForArray(int dims, int * sizes, CvHistogram * hist, float * data, float ** ranges = 0, int uniform = 1); 
# 689 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvReleaseHist(CvHistogram ** hist); 
# 698 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvClearHist(CvHistogram * hist); 
# 713 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvGetMinMaxHistValue(const CvHistogram * hist, float * min_value, float * max_value, int * min_idx = 0, int * max_idx = 0); 
# 727 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvNormalizeHist(CvHistogram * hist, double factor); 
# 737 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvThreshHist(CvHistogram * hist, double threshold); 
# 741
__attribute((visibility("default"))) double cvCompareHist(const CvHistogram * hist1, const CvHistogram * hist2, int method); 
# 755 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvCopyHist(const CvHistogram * src, CvHistogram ** dst); 
# 760
__attribute((visibility("default"))) void cvCalcBayesianProb(CvHistogram ** src, int number, CvHistogram ** dst); 
# 766
__attribute((visibility("default"))) void cvCalcArrHist(CvArr ** arr, CvHistogram * hist, int accumulate = 0, const CvArr * mask = 0); 
# 771
static inline void cvCalcHist(IplImage **image, CvHistogram *hist, int 
# 772
accumulate = 0, const CvArr *
# 773
mask = 0) 
# 774
{ 
# 775
cvCalcArrHist((CvArr **)image, hist, accumulate, mask); 
# 776
} 
# 781
__attribute((visibility("default"))) void cvCalcArrBackProject(CvArr ** image, CvArr * dst, const CvHistogram * hist); 
# 806 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvCalcArrBackProjectPatch(CvArr ** image, CvArr * dst, CvSize range, CvHistogram * hist, int method, double factor); 
# 825 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvCalcProbDensity(const CvHistogram * hist1, const CvHistogram * hist2, CvHistogram * dst_hist, double scale = 255); 
# 831
__attribute((visibility("default"))) void cvEqualizeHist(const CvArr * src, CvArr * dst); 
# 837
__attribute((visibility("default"))) void cvDistTransform(const CvArr * src, CvArr * dst, int distance_type = CV_DIST_L2, int mask_size = 3, const float * mask = 0, CvArr * labels = 0, int labelType = CV_DIST_LABEL_CCOMP); 
# 850
__attribute((visibility("default"))) double cvThreshold(const CvArr * src, CvArr * dst, double threshold, double max_value, int threshold_type); 
# 862 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvAdaptiveThreshold(const CvArr * src, CvArr * dst, double max_value, int adaptive_method = CV_ADAPTIVE_THRESH_MEAN_C, int threshold_type = CV_THRESH_BINARY, int block_size = 3, double param1 = 5); 
# 871
__attribute((visibility("default"))) void cvFloodFill(CvArr * image, CvPoint seed_point, CvScalar new_val, CvScalar lo_diff = cvScalarAll(0), CvScalar up_diff = cvScalarAll(0), CvConnectedComp * comp = 0, int flags = 4, CvArr * mask = 0); 
# 885 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvCanny(const CvArr * image, CvArr * edges, double threshold1, double threshold2, int aperture_size = 3); 
# 894
__attribute((visibility("default"))) void cvPreCornerDetect(const CvArr * image, CvArr * corners, int aperture_size = 3); 
# 901
__attribute((visibility("default"))) void cvCornerEigenValsAndVecs(const CvArr * image, CvArr * eigenvv, int block_size, int aperture_size = 3); 
# 908
__attribute((visibility("default"))) void cvCornerMinEigenVal(const CvArr * image, CvArr * eigenval, int block_size, int aperture_size = 3); 
# 916
__attribute((visibility("default"))) void cvCornerHarris(const CvArr * image, CvArr * harris_response, int block_size, int aperture_size = 3, double k = (0.04000000000000000083)); 
# 923
__attribute((visibility("default"))) void cvFindCornerSubPix(const CvArr * image, CvPoint2D32f * corners, int count, CvSize win, CvSize zero_zone, CvTermCriteria criteria); 
# 931
__attribute((visibility("default"))) void cvGoodFeaturesToTrack(const CvArr * image, CvArr * eig_image, CvArr * temp_image, CvPoint2D32f * corners, int * corner_count, double quality_level, double min_distance, const CvArr * mask = 0, int block_size = 3, int use_harris = 0, double k = (0.04000000000000000083)); 
# 950 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) CvSeq *cvHoughLines2(CvArr * image, void * line_storage, int method, double rho, double theta, int threshold, double param1 = 0, double param2 = 0, double min_theta = 0, double max_theta = (3.141592653589793116)); 
# 958
__attribute((visibility("default"))) CvSeq *cvHoughCircles(CvArr * image, void * circle_storage, int method, double dp, double min_dist, double param1 = 100, double param2 = 100, int min_radius = 0, int max_radius = 0); 
# 968
__attribute((visibility("default"))) void cvFitLine(const CvArr * points, int dist_type, double param, double reps, double aeps, float * line); 
# 993 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvLine(CvArr * img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness = 1, int line_type = 8, int shift = 0); 
# 1002
__attribute((visibility("default"))) void cvRectangle(CvArr * img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness = 1, int line_type = 8, int shift = 0); 
# 1010
__attribute((visibility("default"))) void cvRectangleR(CvArr * img, CvRect r, CvScalar color, int thickness = 1, int line_type = 8, int shift = 0); 
# 1021
__attribute((visibility("default"))) void cvCircle(CvArr * img, CvPoint center, int radius, CvScalar color, int thickness = 1, int line_type = 8, int shift = 0); 
# 1031
__attribute((visibility("default"))) void cvEllipse(CvArr * img, CvPoint center, CvSize axes, double angle, double start_angle, double end_angle, CvScalar color, int thickness = 1, int line_type = 8, int shift = 0); 
# 1036
static inline void cvEllipseBox(CvArr *img, CvBox2D box, CvScalar color, int 
# 1037
thickness = 1, int 
# 1038
line_type = 8, int shift = 0) 
# 1039
{ 
# 1040
CvSize axes; 
# 1041
(axes.width) = cvRound(((box.size).width) * (0.5)); 
# 1042
(axes.height) = cvRound(((box.size).height) * (0.5)); 
# 1044
cvEllipse(img, cvPointFrom32f(box.center), axes, box.angle, 0, 360, color, thickness, line_type, shift); 
# 1046
} 
# 1051
__attribute((visibility("default"))) void cvFillConvexPoly(CvArr * img, const CvPoint * pts, int npts, CvScalar color, int line_type = 8, int shift = 0); 
# 1057
__attribute((visibility("default"))) void cvFillPoly(CvArr * img, CvPoint ** pts, const int * npts, int contours, CvScalar color, int line_type = 8, int shift = 0); 
# 1064
__attribute((visibility("default"))) void cvPolyLine(CvArr * img, CvPoint ** pts, const int * npts, int contours, int is_closed, CvScalar color, int thickness = 1, int line_type = 8, int shift = 0); 
# 1080 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) int cvClipLine(CvSize img_size, CvPoint * pt1, CvPoint * pt2); 
# 1088
__attribute((visibility("default"))) int cvInitLineIterator(const CvArr * image, CvPoint pt1, CvPoint pt2, CvLineIterator * line_iterator, int connectivity = 8, int left_to_right = 0); 
# 1132 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
typedef 
# 1118
struct CvFont { 
# 1120
const char *nameFont; 
# 1121
CvScalar color; 
# 1122
int font_face; 
# 1123
const int *ascii; 
# 1124
const int *greek; 
# 1125
const int *cyrillic; 
# 1126
float hscale, vscale; 
# 1127
float shear; 
# 1128
int thickness; 
# 1129
float dx; 
# 1130
int line_type; 
# 1132
} CvFont; 
# 1151 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) void cvInitFont(CvFont * font, int font_face, double hscale, double vscale, double shear = 0, int thickness = 1, int line_type = 8); 
# 1157
static inline CvFont cvFont(double scale, int thickness = 1) 
# 1158
{ 
# 1159
CvFont font; 
# 1160
cvInitFont(&font, 1, scale, scale, 0, thickness, 16); 
# 1161
return font; 
# 1162
} 
# 1168
__attribute((visibility("default"))) void cvPutText(CvArr * img, const char * text, CvPoint org, const CvFont * font, CvScalar color); 
# 1174
__attribute((visibility("default"))) void cvGetTextSize(const char * text_string, const CvFont * font, CvSize * text_size, int * baseline); 
# 1182
__attribute((visibility("default"))) CvScalar cvColorToScalar(double packed_color, int arrtype); 
# 1192 "/usr/include/opencv2/imgproc/imgproc_c.h" 3
__attribute((visibility("default"))) int cvEllipse2Poly(CvPoint center, CvSize axes, int angle, int arc_start, int arc_end, CvPoint * pts, int delta); 
# 1198
__attribute((visibility("default"))) void cvDrawContours(CvArr * img, CvSeq * contour, CvScalar external_color, CvScalar hole_color, int max_level, int thickness = 1, int line_type = 8, CvPoint offset = cvPoint(0, 0)); 
# 1207
}
# 48 "/usr/include/opencv2/imgcodecs/imgcodecs_c.h" 3
extern "C" {
# 56
enum { 
# 58
CV_LOAD_IMAGE_UNCHANGED = (-1), 
# 60
CV_LOAD_IMAGE_GRAYSCALE = 0, 
# 62
CV_LOAD_IMAGE_COLOR, 
# 64
CV_LOAD_IMAGE_ANYDEPTH, 
# 66
CV_LOAD_IMAGE_ANYCOLOR = 4, 
# 68
CV_LOAD_IMAGE_IGNORE_ORIENTATION = 128
# 69
}; 
# 77
__attribute((visibility("default"))) IplImage *cvLoadImage(const char * filename, int iscolor = CV_LOAD_IMAGE_COLOR); 
# 78
__attribute((visibility("default"))) CvMat *cvLoadImageM(const char * filename, int iscolor = CV_LOAD_IMAGE_COLOR); 
# 81
enum { 
# 82
CV_IMWRITE_JPEG_QUALITY = 1, 
# 83
CV_IMWRITE_JPEG_PROGRESSIVE, 
# 84
CV_IMWRITE_JPEG_OPTIMIZE, 
# 85
CV_IMWRITE_JPEG_RST_INTERVAL, 
# 86
CV_IMWRITE_JPEG_LUMA_QUALITY, 
# 87
CV_IMWRITE_JPEG_CHROMA_QUALITY, 
# 88
CV_IMWRITE_PNG_COMPRESSION = 16, 
# 89
CV_IMWRITE_PNG_STRATEGY, 
# 90
CV_IMWRITE_PNG_BILEVEL, 
# 91
CV_IMWRITE_PNG_STRATEGY_DEFAULT = 0, 
# 92
CV_IMWRITE_PNG_STRATEGY_FILTERED, 
# 93
CV_IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY, 
# 94
CV_IMWRITE_PNG_STRATEGY_RLE, 
# 95
CV_IMWRITE_PNG_STRATEGY_FIXED, 
# 96
CV_IMWRITE_PXM_BINARY = 32, 
# 97
CV_IMWRITE_WEBP_QUALITY = 64, 
# 98
CV_IMWRITE_PAM_TUPLETYPE = 128, 
# 99
CV_IMWRITE_PAM_FORMAT_NULL = 0, 
# 100
CV_IMWRITE_PAM_FORMAT_BLACKANDWHITE, 
# 101
CV_IMWRITE_PAM_FORMAT_GRAYSCALE, 
# 102
CV_IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA, 
# 103
CV_IMWRITE_PAM_FORMAT_RGB, 
# 104
CV_IMWRITE_PAM_FORMAT_RGB_ALPHA
# 105
}; 
# 110
__attribute((visibility("default"))) int cvSaveImage(const char * filename, const CvArr * image, const int * params = 0); 
# 114
__attribute((visibility("default"))) IplImage *cvDecodeImage(const CvMat * buf, int iscolor = CV_LOAD_IMAGE_COLOR); 
# 115
__attribute((visibility("default"))) CvMat *cvDecodeImageM(const CvMat * buf, int iscolor = CV_LOAD_IMAGE_COLOR); 
# 118
__attribute((visibility("default"))) CvMat *cvEncodeImage(const char * ext, const CvArr * image, const int * params = 0); 
# 122
enum { 
# 123
CV_CVTIMG_FLIP = 1, 
# 124
CV_CVTIMG_SWAP_RB
# 125
}; 
# 128
__attribute((visibility("default"))) void cvConvertImage(const CvArr * src, CvArr * dst, int flags = 0); 
# 130
__attribute((visibility("default"))) int cvHaveImageReader(const char * filename); 
# 131
__attribute((visibility("default"))) int cvHaveImageWriter(const char * filename); 
# 145 "/usr/include/opencv2/imgcodecs/imgcodecs_c.h" 3
}
# 48 "/usr/include/opencv2/videoio/videoio_c.h" 3
extern "C" {
# 64 "/usr/include/opencv2/videoio/videoio_c.h" 3
typedef CvCapture CvCapture; 
# 68
__attribute((visibility("default"))) CvCapture *cvCreateFileCapture(const char * filename); 
# 72
__attribute((visibility("default"))) CvCapture *cvCreateFileCaptureWithPreference(const char * filename, int apiPreference); 
# 75
enum { 
# 76
CV_CAP_ANY, 
# 78
CV_CAP_MIL = 100, 
# 80
CV_CAP_VFW = 200, 
# 81
CV_CAP_V4L = 200, 
# 82
CV_CAP_V4L2 = 200, 
# 84
CV_CAP_FIREWARE = 300, 
# 85
CV_CAP_FIREWIRE = 300, 
# 86
CV_CAP_IEEE1394 = 300, 
# 87
CV_CAP_DC1394 = 300, 
# 88
CV_CAP_CMU1394 = 300, 
# 90
CV_CAP_STEREO = 400, 
# 91
CV_CAP_TYZX = 400, 
# 92
CV_TYZX_LEFT = 400, 
# 93
CV_TYZX_RIGHT, 
# 94
CV_TYZX_COLOR, 
# 95
CV_TYZX_Z, 
# 97
CV_CAP_QT = 500, 
# 99
CV_CAP_UNICAP = 600, 
# 101
CV_CAP_DSHOW = 700, 
# 102
CV_CAP_MSMF = 1400, 
# 104
CV_CAP_PVAPI = 800, 
# 106
CV_CAP_OPENNI = 900, 
# 107
CV_CAP_OPENNI_ASUS = 910, 
# 109
CV_CAP_ANDROID = 1000, 
# 110
CV_CAP_ANDROID_BACK = 1099, 
# 111
CV_CAP_ANDROID_FRONT = 1098, 
# 113
CV_CAP_XIAPI = 1100, 
# 115
CV_CAP_AVFOUNDATION = 1200, 
# 117
CV_CAP_GIGANETIX = 1300, 
# 119
CV_CAP_INTELPERC = 1500, 
# 121
CV_CAP_OPENNI2 = 1600, 
# 122
CV_CAP_GPHOTO2 = 1700, 
# 123
CV_CAP_GSTREAMER = 1800, 
# 124
CV_CAP_FFMPEG = 1900, 
# 125
CV_CAP_IMAGES = 2000, 
# 127
CV_CAP_ARAVIS = 2100
# 128
}; 
# 132
__attribute((visibility("default"))) CvCapture *cvCreateCameraCapture(int index); 
# 138
__attribute((visibility("default"))) int cvGrabFrame(CvCapture * capture); 
# 146
__attribute((visibility("default"))) IplImage *cvRetrieveFrame(CvCapture * capture, int streamIdx = 0); 
# 152
__attribute((visibility("default"))) IplImage *cvQueryFrame(CvCapture * capture); 
# 156
__attribute((visibility("default"))) void cvReleaseCapture(CvCapture ** capture); 
# 159
enum { 
# 162
CV_CAP_PROP_DC1394_OFF = (-4), 
# 163
CV_CAP_PROP_DC1394_MODE_MANUAL, 
# 164
CV_CAP_PROP_DC1394_MODE_AUTO, 
# 165
CV_CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO, 
# 166
CV_CAP_PROP_POS_MSEC = 0, 
# 167
CV_CAP_PROP_POS_FRAMES, 
# 168
CV_CAP_PROP_POS_AVI_RATIO, 
# 169
CV_CAP_PROP_FRAME_WIDTH, 
# 170
CV_CAP_PROP_FRAME_HEIGHT, 
# 171
CV_CAP_PROP_FPS, 
# 172
CV_CAP_PROP_FOURCC, 
# 173
CV_CAP_PROP_FRAME_COUNT, 
# 174
CV_CAP_PROP_FORMAT, 
# 175
CV_CAP_PROP_MODE, 
# 176
CV_CAP_PROP_BRIGHTNESS, 
# 177
CV_CAP_PROP_CONTRAST, 
# 178
CV_CAP_PROP_SATURATION, 
# 179
CV_CAP_PROP_HUE, 
# 180
CV_CAP_PROP_GAIN, 
# 181
CV_CAP_PROP_EXPOSURE, 
# 182
CV_CAP_PROP_CONVERT_RGB, 
# 183
CV_CAP_PROP_WHITE_BALANCE_BLUE_U, 
# 184
CV_CAP_PROP_RECTIFICATION, 
# 185
CV_CAP_PROP_MONOCHROME, 
# 186
CV_CAP_PROP_SHARPNESS, 
# 187
CV_CAP_PROP_AUTO_EXPOSURE, 
# 190
CV_CAP_PROP_GAMMA, 
# 191
CV_CAP_PROP_TEMPERATURE, 
# 192
CV_CAP_PROP_TRIGGER, 
# 193
CV_CAP_PROP_TRIGGER_DELAY, 
# 194
CV_CAP_PROP_WHITE_BALANCE_RED_V, 
# 195
CV_CAP_PROP_ZOOM, 
# 196
CV_CAP_PROP_FOCUS, 
# 197
CV_CAP_PROP_GUID, 
# 198
CV_CAP_PROP_ISO_SPEED, 
# 199
CV_CAP_PROP_MAX_DC1394, 
# 200
CV_CAP_PROP_BACKLIGHT, 
# 201
CV_CAP_PROP_PAN, 
# 202
CV_CAP_PROP_TILT, 
# 203
CV_CAP_PROP_ROLL, 
# 204
CV_CAP_PROP_IRIS, 
# 205
CV_CAP_PROP_SETTINGS, 
# 206
CV_CAP_PROP_BUFFERSIZE, 
# 207
CV_CAP_PROP_AUTOFOCUS, 
# 208
CV_CAP_PROP_SAR_NUM, 
# 209
CV_CAP_PROP_SAR_DEN, 
# 211
CV_CAP_PROP_AUTOGRAB = 1024, 
# 212
CV_CAP_PROP_SUPPORTED_PREVIEW_SIZES_STRING, 
# 213
CV_CAP_PROP_PREVIEW_FORMAT, 
# 216
CV_CAP_OPENNI_DEPTH_GENERATOR = (-2147483647-1), 
# 217
CV_CAP_OPENNI_IMAGE_GENERATOR = 1073741824, 
# 218
CV_CAP_OPENNI_IR_GENERATOR = 536870912, 
# 219
CV_CAP_OPENNI_GENERATORS_MASK = (-536870912), 
# 222
CV_CAP_PROP_OPENNI_OUTPUT_MODE = 100, 
# 223
CV_CAP_PROP_OPENNI_FRAME_MAX_DEPTH, 
# 224
CV_CAP_PROP_OPENNI_BASELINE, 
# 225
CV_CAP_PROP_OPENNI_FOCAL_LENGTH, 
# 226
CV_CAP_PROP_OPENNI_REGISTRATION, 
# 227
CV_CAP_PROP_OPENNI_REGISTRATION_ON = 104, 
# 230
CV_CAP_PROP_OPENNI_APPROX_FRAME_SYNC, 
# 231
CV_CAP_PROP_OPENNI_MAX_BUFFER_SIZE, 
# 232
CV_CAP_PROP_OPENNI_CIRCLE_BUFFER, 
# 233
CV_CAP_PROP_OPENNI_MAX_TIME_DURATION, 
# 235
CV_CAP_PROP_OPENNI_GENERATOR_PRESENT, 
# 236
CV_CAP_PROP_OPENNI2_SYNC, 
# 237
CV_CAP_PROP_OPENNI2_MIRROR, 
# 239
CV_CAP_OPENNI_IMAGE_GENERATOR_PRESENT = 1073741933, 
# 240
CV_CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE = 1073741924, 
# 241
CV_CAP_OPENNI_DEPTH_GENERATOR_PRESENT = (-2147483539), 
# 242
CV_CAP_OPENNI_DEPTH_GENERATOR_BASELINE = (-2147483546), 
# 243
CV_CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH, 
# 244
CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION, 
# 245
CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON = (-2147483544), 
# 246
CV_CAP_OPENNI_IR_GENERATOR_PRESENT = 536871021, 
# 249
CV_CAP_GSTREAMER_QUEUE_LENGTH = 200, 
# 252
CV_CAP_PROP_PVAPI_MULTICASTIP = 300, 
# 253
CV_CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE, 
# 254
CV_CAP_PROP_PVAPI_DECIMATIONHORIZONTAL, 
# 255
CV_CAP_PROP_PVAPI_DECIMATIONVERTICAL, 
# 256
CV_CAP_PROP_PVAPI_BINNINGX, 
# 257
CV_CAP_PROP_PVAPI_BINNINGY, 
# 258
CV_CAP_PROP_PVAPI_PIXELFORMAT, 
# 261
CV_CAP_PROP_XI_DOWNSAMPLING = 400, 
# 262
CV_CAP_PROP_XI_DATA_FORMAT, 
# 263
CV_CAP_PROP_XI_OFFSET_X, 
# 264
CV_CAP_PROP_XI_OFFSET_Y, 
# 265
CV_CAP_PROP_XI_TRG_SOURCE, 
# 266
CV_CAP_PROP_XI_TRG_SOFTWARE, 
# 267
CV_CAP_PROP_XI_GPI_SELECTOR, 
# 268
CV_CAP_PROP_XI_GPI_MODE, 
# 269
CV_CAP_PROP_XI_GPI_LEVEL, 
# 270
CV_CAP_PROP_XI_GPO_SELECTOR, 
# 271
CV_CAP_PROP_XI_GPO_MODE, 
# 272
CV_CAP_PROP_XI_LED_SELECTOR, 
# 273
CV_CAP_PROP_XI_LED_MODE, 
# 274
CV_CAP_PROP_XI_MANUAL_WB, 
# 275
CV_CAP_PROP_XI_AUTO_WB, 
# 276
CV_CAP_PROP_XI_AEAG, 
# 277
CV_CAP_PROP_XI_EXP_PRIORITY, 
# 278
CV_CAP_PROP_XI_AE_MAX_LIMIT, 
# 279
CV_CAP_PROP_XI_AG_MAX_LIMIT, 
# 280
CV_CAP_PROP_XI_AEAG_LEVEL, 
# 281
CV_CAP_PROP_XI_TIMEOUT, 
# 282
CV_CAP_PROP_XI_EXPOSURE, 
# 283
CV_CAP_PROP_XI_EXPOSURE_BURST_COUNT, 
# 284
CV_CAP_PROP_XI_GAIN_SELECTOR, 
# 285
CV_CAP_PROP_XI_GAIN, 
# 286
CV_CAP_PROP_XI_DOWNSAMPLING_TYPE = 426, 
# 287
CV_CAP_PROP_XI_BINNING_SELECTOR, 
# 288
CV_CAP_PROP_XI_BINNING_VERTICAL, 
# 289
CV_CAP_PROP_XI_BINNING_HORIZONTAL, 
# 290
CV_CAP_PROP_XI_BINNING_PATTERN, 
# 291
CV_CAP_PROP_XI_DECIMATION_SELECTOR, 
# 292
CV_CAP_PROP_XI_DECIMATION_VERTICAL, 
# 293
CV_CAP_PROP_XI_DECIMATION_HORIZONTAL, 
# 294
CV_CAP_PROP_XI_DECIMATION_PATTERN, 
# 295
CV_CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR = 587, 
# 296
CV_CAP_PROP_XI_TEST_PATTERN, 
# 297
CV_CAP_PROP_XI_IMAGE_DATA_FORMAT = 435, 
# 298
CV_CAP_PROP_XI_SHUTTER_TYPE, 
# 299
CV_CAP_PROP_XI_SENSOR_TAPS, 
# 300
CV_CAP_PROP_XI_AEAG_ROI_OFFSET_X = 439, 
# 301
CV_CAP_PROP_XI_AEAG_ROI_OFFSET_Y, 
# 302
CV_CAP_PROP_XI_AEAG_ROI_WIDTH, 
# 303
CV_CAP_PROP_XI_AEAG_ROI_HEIGHT, 
# 304
CV_CAP_PROP_XI_BPC = 445, 
# 305
CV_CAP_PROP_XI_WB_KR = 448, 
# 306
CV_CAP_PROP_XI_WB_KG, 
# 307
CV_CAP_PROP_XI_WB_KB, 
# 308
CV_CAP_PROP_XI_WIDTH, 
# 309
CV_CAP_PROP_XI_HEIGHT, 
# 310
CV_CAP_PROP_XI_REGION_SELECTOR = 589, 
# 311
CV_CAP_PROP_XI_REGION_MODE = 595, 
# 312
CV_CAP_PROP_XI_LIMIT_BANDWIDTH = 459, 
# 313
CV_CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH, 
# 314
CV_CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH, 
# 315
CV_CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH, 
# 316
CV_CAP_PROP_XI_OUTPUT_DATA_PACKING, 
# 317
CV_CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE, 
# 318
CV_CAP_PROP_XI_IS_COOLED, 
# 319
CV_CAP_PROP_XI_COOLING, 
# 320
CV_CAP_PROP_XI_TARGET_TEMP, 
# 321
CV_CAP_PROP_XI_CHIP_TEMP, 
# 322
CV_CAP_PROP_XI_HOUS_TEMP, 
# 323
CV_CAP_PROP_XI_HOUS_BACK_SIDE_TEMP = 590, 
# 324
CV_CAP_PROP_XI_SENSOR_BOARD_TEMP = 596, 
# 325
CV_CAP_PROP_XI_CMS = 470, 
# 326
CV_CAP_PROP_XI_APPLY_CMS, 
# 327
CV_CAP_PROP_XI_IMAGE_IS_COLOR = 474, 
# 328
CV_CAP_PROP_XI_COLOR_FILTER_ARRAY, 
# 329
CV_CAP_PROP_XI_GAMMAY, 
# 330
CV_CAP_PROP_XI_GAMMAC, 
# 331
CV_CAP_PROP_XI_SHARPNESS, 
# 332
CV_CAP_PROP_XI_CC_MATRIX_00, 
# 333
CV_CAP_PROP_XI_CC_MATRIX_01, 
# 334
CV_CAP_PROP_XI_CC_MATRIX_02, 
# 335
CV_CAP_PROP_XI_CC_MATRIX_03, 
# 336
CV_CAP_PROP_XI_CC_MATRIX_10, 
# 337
CV_CAP_PROP_XI_CC_MATRIX_11, 
# 338
CV_CAP_PROP_XI_CC_MATRIX_12, 
# 339
CV_CAP_PROP_XI_CC_MATRIX_13, 
# 340
CV_CAP_PROP_XI_CC_MATRIX_20, 
# 341
CV_CAP_PROP_XI_CC_MATRIX_21, 
# 342
CV_CAP_PROP_XI_CC_MATRIX_22, 
# 343
CV_CAP_PROP_XI_CC_MATRIX_23, 
# 344
CV_CAP_PROP_XI_CC_MATRIX_30, 
# 345
CV_CAP_PROP_XI_CC_MATRIX_31, 
# 346
CV_CAP_PROP_XI_CC_MATRIX_32, 
# 347
CV_CAP_PROP_XI_CC_MATRIX_33, 
# 348
CV_CAP_PROP_XI_DEFAULT_CC_MATRIX, 
# 349
CV_CAP_PROP_XI_TRG_SELECTOR = 498, 
# 350
CV_CAP_PROP_XI_ACQ_FRAME_BURST_COUNT, 
# 351
CV_CAP_PROP_XI_DEBOUNCE_EN = 507, 
# 352
CV_CAP_PROP_XI_DEBOUNCE_T0, 
# 353
CV_CAP_PROP_XI_DEBOUNCE_T1, 
# 354
CV_CAP_PROP_XI_DEBOUNCE_POL, 
# 355
CV_CAP_PROP_XI_LENS_MODE, 
# 356
CV_CAP_PROP_XI_LENS_APERTURE_VALUE, 
# 357
CV_CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE, 
# 358
CV_CAP_PROP_XI_LENS_FOCUS_MOVE, 
# 359
CV_CAP_PROP_XI_LENS_FOCUS_DISTANCE, 
# 360
CV_CAP_PROP_XI_LENS_FOCAL_LENGTH, 
# 361
CV_CAP_PROP_XI_LENS_FEATURE_SELECTOR, 
# 362
CV_CAP_PROP_XI_LENS_FEATURE, 
# 363
CV_CAP_PROP_XI_DEVICE_MODEL_ID = 521, 
# 364
CV_CAP_PROP_XI_DEVICE_SN, 
# 365
CV_CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA = 529, 
# 366
CV_CAP_PROP_XI_IMAGE_PAYLOAD_SIZE, 
# 367
CV_CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT, 
# 368
CV_CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ, 
# 369
CV_CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX, 
# 370
CV_CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT, 
# 371
CV_CAP_PROP_XI_FRAMERATE, 
# 372
CV_CAP_PROP_XI_COUNTER_SELECTOR, 
# 373
CV_CAP_PROP_XI_COUNTER_VALUE, 
# 374
CV_CAP_PROP_XI_ACQ_TIMING_MODE, 
# 375
CV_CAP_PROP_XI_AVAILABLE_BANDWIDTH, 
# 376
CV_CAP_PROP_XI_BUFFER_POLICY, 
# 377
CV_CAP_PROP_XI_LUT_EN, 
# 378
CV_CAP_PROP_XI_LUT_INDEX, 
# 379
CV_CAP_PROP_XI_LUT_VALUE, 
# 380
CV_CAP_PROP_XI_TRG_DELAY, 
# 381
CV_CAP_PROP_XI_TS_RST_MODE, 
# 382
CV_CAP_PROP_XI_TS_RST_SOURCE, 
# 383
CV_CAP_PROP_XI_IS_DEVICE_EXIST, 
# 384
CV_CAP_PROP_XI_ACQ_BUFFER_SIZE, 
# 385
CV_CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT, 
# 386
CV_CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE, 
# 387
CV_CAP_PROP_XI_BUFFERS_QUEUE_SIZE, 
# 388
CV_CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT, 
# 389
CV_CAP_PROP_XI_RECENT_FRAME, 
# 390
CV_CAP_PROP_XI_DEVICE_RESET, 
# 391
CV_CAP_PROP_XI_COLUMN_FPN_CORRECTION, 
# 392
CV_CAP_PROP_XI_ROW_FPN_CORRECTION = 591, 
# 393
CV_CAP_PROP_XI_SENSOR_MODE = 558, 
# 394
CV_CAP_PROP_XI_HDR, 
# 395
CV_CAP_PROP_XI_HDR_KNEEPOINT_COUNT, 
# 396
CV_CAP_PROP_XI_HDR_T1, 
# 397
CV_CAP_PROP_XI_HDR_T2, 
# 398
CV_CAP_PROP_XI_KNEEPOINT1, 
# 399
CV_CAP_PROP_XI_KNEEPOINT2, 
# 400
CV_CAP_PROP_XI_IMAGE_BLACK_LEVEL, 
# 401
CV_CAP_PROP_XI_HW_REVISION = 571, 
# 402
CV_CAP_PROP_XI_DEBUG_LEVEL, 
# 403
CV_CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION, 
# 404
CV_CAP_PROP_XI_FFS_FILE_ID = 594, 
# 405
CV_CAP_PROP_XI_FFS_FILE_SIZE = 580, 
# 406
CV_CAP_PROP_XI_FREE_FFS_SIZE, 
# 407
CV_CAP_PROP_XI_USED_FFS_SIZE, 
# 408
CV_CAP_PROP_XI_FFS_ACCESS_KEY, 
# 409
CV_CAP_PROP_XI_SENSOR_FEATURE_SELECTOR = 585, 
# 410
CV_CAP_PROP_XI_SENSOR_FEATURE_VALUE, 
# 414
CV_CAP_PROP_ANDROID_FLASH_MODE = 8001, 
# 415
CV_CAP_PROP_ANDROID_FOCUS_MODE, 
# 416
CV_CAP_PROP_ANDROID_WHITE_BALANCE, 
# 417
CV_CAP_PROP_ANDROID_ANTIBANDING, 
# 418
CV_CAP_PROP_ANDROID_FOCAL_LENGTH, 
# 419
CV_CAP_PROP_ANDROID_FOCUS_DISTANCE_NEAR, 
# 420
CV_CAP_PROP_ANDROID_FOCUS_DISTANCE_OPTIMAL, 
# 421
CV_CAP_PROP_ANDROID_FOCUS_DISTANCE_FAR, 
# 422
CV_CAP_PROP_ANDROID_EXPOSE_LOCK, 
# 423
CV_CAP_PROP_ANDROID_WHITEBALANCE_LOCK, 
# 426
CV_CAP_PROP_IOS_DEVICE_FOCUS = 9001, 
# 427
CV_CAP_PROP_IOS_DEVICE_EXPOSURE, 
# 428
CV_CAP_PROP_IOS_DEVICE_FLASH, 
# 429
CV_CAP_PROP_IOS_DEVICE_WHITEBALANCE, 
# 430
CV_CAP_PROP_IOS_DEVICE_TORCH, 
# 434
CV_CAP_PROP_GIGA_FRAME_OFFSET_X = 10001, 
# 435
CV_CAP_PROP_GIGA_FRAME_OFFSET_Y, 
# 436
CV_CAP_PROP_GIGA_FRAME_WIDTH_MAX, 
# 437
CV_CAP_PROP_GIGA_FRAME_HEIGH_MAX, 
# 438
CV_CAP_PROP_GIGA_FRAME_SENS_WIDTH, 
# 439
CV_CAP_PROP_GIGA_FRAME_SENS_HEIGH, 
# 441
CV_CAP_PROP_INTELPERC_PROFILE_COUNT = 11001, 
# 442
CV_CAP_PROP_INTELPERC_PROFILE_IDX, 
# 443
CV_CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE, 
# 444
CV_CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE, 
# 445
CV_CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD, 
# 446
CV_CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ, 
# 447
CV_CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT, 
# 450
CV_CAP_INTELPERC_DEPTH_GENERATOR = 536870912, 
# 451
CV_CAP_INTELPERC_IMAGE_GENERATOR = 268435456, 
# 452
CV_CAP_INTELPERC_GENERATORS_MASK = 805306368
# 453
}; 
# 458
enum { 
# 459
CV_CAP_MODE_BGR, 
# 460
CV_CAP_MODE_RGB, 
# 461
CV_CAP_MODE_GRAY, 
# 462
CV_CAP_MODE_YUYV
# 463
}; 
# 466
enum { 
# 468
CV_CAP_OPENNI_DEPTH_MAP, 
# 469
CV_CAP_OPENNI_POINT_CLOUD_MAP, 
# 470
CV_CAP_OPENNI_DISPARITY_MAP, 
# 471
CV_CAP_OPENNI_DISPARITY_MAP_32F, 
# 472
CV_CAP_OPENNI_VALID_DEPTH_MASK, 
# 475
CV_CAP_OPENNI_BGR_IMAGE, 
# 476
CV_CAP_OPENNI_GRAY_IMAGE, 
# 479
CV_CAP_OPENNI_IR_IMAGE
# 480
}; 
# 484
enum { 
# 485
CV_CAP_OPENNI_VGA_30HZ, 
# 486
CV_CAP_OPENNI_SXGA_15HZ, 
# 487
CV_CAP_OPENNI_SXGA_30HZ, 
# 488
CV_CAP_OPENNI_QVGA_30HZ, 
# 489
CV_CAP_OPENNI_QVGA_60HZ
# 490
}; 
# 493
enum { 
# 494
CV_CAP_INTELPERC_DEPTH_MAP, 
# 495
CV_CAP_INTELPERC_UVDEPTH_MAP, 
# 496
CV_CAP_INTELPERC_IR_MAP, 
# 497
CV_CAP_INTELPERC_IMAGE
# 498
}; 
# 504
enum { 
# 505
CV_CAP_PROP_GPHOTO2_PREVIEW = 17001, 
# 506
CV_CAP_PROP_GPHOTO2_WIDGET_ENUMERATE, 
# 507
CV_CAP_PROP_GPHOTO2_RELOAD_CONFIG, 
# 508
CV_CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE, 
# 509
CV_CAP_PROP_GPHOTO2_COLLECT_MSGS, 
# 510
CV_CAP_PROP_GPHOTO2_FLUSH_MSGS, 
# 511
CV_CAP_PROP_SPEED, 
# 512
CV_CAP_PROP_APERTURE, 
# 513
CV_CAP_PROP_EXPOSUREPROGRAM, 
# 514
CV_CAP_PROP_VIEWFINDER
# 515
}; 
# 519
__attribute((visibility("default"))) double cvGetCaptureProperty(CvCapture * capture, int property_id); 
# 522
__attribute((visibility("default"))) int cvSetCaptureProperty(CvCapture * capture, int property_id, double value); 
# 528
__attribute((visibility("default"))) int cvGetCaptureDomain(CvCapture * capture); 
# 534
typedef CvVideoWriter CvVideoWriter; 
# 547 "/usr/include/opencv2/videoio/videoio_c.h" 3
static inline int CV_FOURCC(char c1, char c2, char c3, char c4) 
# 548
{ 
# 549
return (((c1 & 255) + ((c2 & 255) << 8)) + ((c3 & 255) << 16)) + ((c4 & 255) << 24); 
# 550
} 
# 559 "/usr/include/opencv2/videoio/videoio_c.h" 3
__attribute((visibility("default"))) CvVideoWriter *cvCreateVideoWriter(const char * filename, int fourcc, double fps, CvSize frame_size, int is_color = 1); 
# 565
__attribute((visibility("default"))) int cvWriteFrame(CvVideoWriter * writer, const IplImage * image); 
# 569
__attribute((visibility("default"))) void cvReleaseVideoWriter(CvVideoWriter ** writer); 
# 584 "/usr/include/opencv2/videoio/videoio_c.h" 3
}
# 55 "/usr/include/opencv2/highgui/highgui_c.h" 3
extern "C" {
# 68 "/usr/include/opencv2/highgui/highgui_c.h" 3
enum { CV_FONT_LIGHT = 25, 
# 69
CV_FONT_NORMAL = 50, 
# 70
CV_FONT_DEMIBOLD = 63, 
# 71
CV_FONT_BOLD = 75, 
# 72
CV_FONT_BLACK = 87
# 73
}; 
# 75
enum { CV_STYLE_NORMAL, 
# 76
CV_STYLE_ITALIC, 
# 77
CV_STYLE_OBLIQUE
# 78
}; 
# 83
__attribute((visibility("default"))) CvFont cvFontQt(const char * nameFont, int pointSize = -1, CvScalar color = cvScalarAll(0), int weight = CV_FONT_NORMAL, int style = CV_STYLE_NORMAL, int spacing = 0); 
# 85
__attribute((visibility("default"))) void cvAddText(const CvArr * img, const char * text, CvPoint org, CvFont * arg2); 
# 87
__attribute((visibility("default"))) void cvDisplayOverlay(const char * name, const char * text, int delayms = 0); 
# 88
__attribute((visibility("default"))) void cvDisplayStatusBar(const char * name, const char * text, int delayms = 0); 
# 90
__attribute((visibility("default"))) void cvSaveWindowParameters(const char * name); 
# 91
__attribute((visibility("default"))) void cvLoadWindowParameters(const char * name); 
# 92
__attribute((visibility("default"))) int cvStartLoop(int (* pt2Func)(int argc, char * argv[]), int argc, char * argv[]); 
# 93
__attribute((visibility("default"))) void cvStopLoop(); 
# 95
typedef void (*CvButtonCallback)(int state, void * userdata); 
# 96
enum { CV_PUSH_BUTTON, CV_CHECKBOX, CV_RADIOBOX}; 
# 97
__attribute((visibility("default"))) int cvCreateButton(const char * button_name = 0, CvButtonCallback on_change = 0, void * userdata = 0, int button_type = CV_PUSH_BUTTON, int initial_button_state = 0); 
# 102
__attribute((visibility("default"))) int cvInitSystem(int argc, char ** argv); 
# 104
__attribute((visibility("default"))) int cvStartWindowThread(); 
# 108
enum { 
# 110
CV_WND_PROP_FULLSCREEN, 
# 111
CV_WND_PROP_AUTOSIZE, 
# 112
CV_WND_PROP_ASPECTRATIO, 
# 113
CV_WND_PROP_OPENGL, 
# 114
CV_WND_PROP_VISIBLE, 
# 117
CV_WINDOW_NORMAL = 0, 
# 118
CV_WINDOW_AUTOSIZE, 
# 119
CV_WINDOW_OPENGL = 4096, 
# 122
CV_GUI_EXPANDED = 0, 
# 123
CV_GUI_NORMAL = 16, 
# 126
CV_WINDOW_FULLSCREEN = 1, 
# 127
CV_WINDOW_FREERATIO = 256, 
# 128
CV_WINDOW_KEEPRATIO = 0
# 129
}; 
# 132
__attribute((visibility("default"))) int cvNamedWindow(const char * name, int flags = CV_WINDOW_AUTOSIZE); 
# 135
__attribute((visibility("default"))) void cvSetWindowProperty(const char * name, int prop_id, double prop_value); 
# 136
__attribute((visibility("default"))) double cvGetWindowProperty(const char * name, int prop_id); 
# 139
__attribute((visibility("default"))) void cvShowImage(const char * name, const CvArr * image); 
# 142
__attribute((visibility("default"))) void cvResizeWindow(const char * name, int width, int height); 
# 143
__attribute((visibility("default"))) void cvMoveWindow(const char * name, int x, int y); 
# 147
__attribute((visibility("default"))) void cvDestroyWindow(const char * name); 
# 149
__attribute((visibility("default"))) void cvDestroyAllWindows(); 
# 152
__attribute((visibility("default"))) void *cvGetWindowHandle(const char * name); 
# 155
__attribute((visibility("default"))) const char *cvGetWindowName(void * window_handle); 
# 158
typedef void (*CvTrackbarCallback)(int pos); 
# 161
__attribute((visibility("default"))) int cvCreateTrackbar(const char * trackbar_name, const char * window_name, int * value, int count, CvTrackbarCallback on_change = 0); 
# 164
typedef void (*CvTrackbarCallback2)(int pos, void * userdata); 
# 166
__attribute((visibility("default"))) int cvCreateTrackbar2(const char * trackbar_name, const char * window_name, int * value, int count, CvTrackbarCallback2 on_change, void * userdata = 0); 
# 171
__attribute((visibility("default"))) int cvGetTrackbarPos(const char * trackbar_name, const char * window_name); 
# 172
__attribute((visibility("default"))) void cvSetTrackbarPos(const char * trackbar_name, const char * window_name, int pos); 
# 173
__attribute((visibility("default"))) void cvSetTrackbarMax(const char * trackbar_name, const char * window_name, int maxval); 
# 174
__attribute((visibility("default"))) void cvSetTrackbarMin(const char * trackbar_name, const char * window_name, int minval); 
# 177
enum { 
# 178
CV_EVENT_MOUSEMOVE, 
# 179
CV_EVENT_LBUTTONDOWN, 
# 180
CV_EVENT_RBUTTONDOWN, 
# 181
CV_EVENT_MBUTTONDOWN, 
# 182
CV_EVENT_LBUTTONUP, 
# 183
CV_EVENT_RBUTTONUP, 
# 184
CV_EVENT_MBUTTONUP, 
# 185
CV_EVENT_LBUTTONDBLCLK, 
# 186
CV_EVENT_RBUTTONDBLCLK, 
# 187
CV_EVENT_MBUTTONDBLCLK, 
# 188
CV_EVENT_MOUSEWHEEL, 
# 189
CV_EVENT_MOUSEHWHEEL
# 190
}; 
# 193
enum { 
# 194
CV_EVENT_FLAG_LBUTTON = 1, 
# 195
CV_EVENT_FLAG_RBUTTON, 
# 196
CV_EVENT_FLAG_MBUTTON = 4, 
# 197
CV_EVENT_FLAG_CTRLKEY = 8, 
# 198
CV_EVENT_FLAG_SHIFTKEY = 16, 
# 199
CV_EVENT_FLAG_ALTKEY = 32
# 200
}; 
# 205
typedef void (*CvMouseCallback)(int event, int x, int y, int flags, void * param); 
# 208
__attribute((visibility("default"))) void cvSetMouseCallback(const char * window_name, CvMouseCallback on_mouse, void * param = 0); 
# 212
__attribute((visibility("default"))) int cvWaitKey(int delay = 0); 
# 216
typedef void (*CvOpenGlDrawCallback)(void * userdata); 
# 217
__attribute((visibility("default"))) void cvSetOpenGlDrawCallback(const char * window_name, CvOpenGlDrawCallback callback, void * userdata = 0); 
# 219
__attribute((visibility("default"))) void cvSetOpenGlContext(const char * window_name); 
# 220
__attribute((visibility("default"))) void cvUpdateWindow(const char * window_name); 
# 254 "/usr/include/opencv2/highgui/highgui_c.h" 3
}
# 224 "/usr/include/opencv2/imgproc.hpp" 3
namespace cv { 
# 235 "/usr/include/opencv2/imgproc.hpp" 3
enum MorphTypes { 
# 236
MORPH_ERODE, 
# 237
MORPH_DILATE, 
# 238
MORPH_OPEN, 
# 240
MORPH_CLOSE, 
# 242
MORPH_GRADIENT, 
# 244
MORPH_TOPHAT, 
# 246
MORPH_BLACKHAT, 
# 248
MORPH_HITMISS
# 250
}; 
# 253
enum MorphShapes { 
# 254
MORPH_RECT, 
# 255
MORPH_CROSS, 
# 257
MORPH_ELLIPSE
# 259
}; 
# 267
enum InterpolationFlags { 
# 269
INTER_NEAREST, 
# 271
INTER_LINEAR, 
# 273
INTER_CUBIC, 
# 277
INTER_AREA, 
# 279
INTER_LANCZOS4, 
# 281
INTER_MAX = 7, 
# 284
WARP_FILL_OUTLIERS, 
# 291
WARP_INVERSE_MAP = 16
# 292
}; 
# 294
enum InterpolationMasks { 
# 295
INTER_BITS = 5, 
# 296
INTER_BITS2 = 10, 
# 297
INTER_TAB_SIZE = 32, 
# 298
INTER_TAB_SIZE2 = 1024
# 299
}; 
# 308 "/usr/include/opencv2/imgproc.hpp" 3
enum DistanceTypes { 
# 309
DIST_USER = (-1), 
# 310
DIST_L1 = 1, 
# 311
DIST_L2, 
# 312
DIST_C, 
# 313
DIST_L12, 
# 314
DIST_FAIR, 
# 315
DIST_WELSCH, 
# 316
DIST_HUBER
# 317
}; 
# 320
enum DistanceTransformMasks { 
# 321
DIST_MASK_3 = 3, 
# 322
DIST_MASK_5 = 5, 
# 323
DIST_MASK_PRECISE = 0
# 324
}; 
# 328
enum ThresholdTypes { 
# 329
THRESH_BINARY, 
# 330
THRESH_BINARY_INV, 
# 331
THRESH_TRUNC, 
# 332
THRESH_TOZERO, 
# 333
THRESH_TOZERO_INV, 
# 334
THRESH_MASK = 7, 
# 335
THRESH_OTSU, 
# 336
THRESH_TRIANGLE = 16
# 337
}; 
# 341
enum AdaptiveThresholdTypes { 
# 344
ADAPTIVE_THRESH_MEAN_C, 
# 349
ADAPTIVE_THRESH_GAUSSIAN_C
# 350
}; 
# 353
enum UndistortTypes { 
# 354
PROJ_SPHERICAL_ORTHO, 
# 355
PROJ_SPHERICAL_EQRECT
# 356
}; 
# 359
enum GrabCutClasses { 
# 360
GC_BGD, 
# 361
GC_FGD, 
# 362
GC_PR_BGD, 
# 363
GC_PR_FGD
# 364
}; 
# 367
enum GrabCutModes { 
# 370
GC_INIT_WITH_RECT, 
# 374
GC_INIT_WITH_MASK, 
# 376
GC_EVAL
# 377
}; 
# 380
enum DistanceTransformLabelTypes { 
# 383
DIST_LABEL_CCOMP, 
# 385
DIST_LABEL_PIXEL
# 386
}; 
# 389
enum FloodFillFlags { 
# 392
FLOODFILL_FIXED_RANGE = 65536, 
# 396
FLOODFILL_MASK_ONLY = 131072
# 397
}; 
# 405
enum ConnectedComponentsTypes { 
# 406
CC_STAT_LEFT, 
# 408
CC_STAT_TOP, 
# 410
CC_STAT_WIDTH, 
# 411
CC_STAT_HEIGHT, 
# 412
CC_STAT_AREA, 
# 413
CC_STAT_MAX
# 414
}; 
# 417
enum ConnectedComponentsAlgorithmsTypes { 
# 418
CCL_WU, 
# 419
CCL_DEFAULT = (-1), 
# 420
CCL_GRANA = 1
# 421
}; 
# 424
enum RetrievalModes { 
# 427
RETR_EXTERNAL, 
# 429
RETR_LIST, 
# 434
RETR_CCOMP, 
# 436
RETR_TREE, 
# 437
RETR_FLOODFILL
# 438
}; 
# 441
enum ContourApproximationModes { 
# 445
CHAIN_APPROX_NONE = 1, 
# 448
CHAIN_APPROX_SIMPLE, 
# 450
CHAIN_APPROX_TC89_L1, 
# 452
CHAIN_APPROX_TC89_KCOS
# 453
}; 
# 463 "/usr/include/opencv2/imgproc.hpp" 3
enum ShapeMatchModes { 
# 464
CONTOURS_MATCH_I1 = 1, 
# 465
CONTOURS_MATCH_I2, 
# 466
CONTOURS_MATCH_I3
# 467
}; 
# 472
enum HoughModes { 
# 478
HOUGH_STANDARD, 
# 483
HOUGH_PROBABILISTIC, 
# 486
HOUGH_MULTI_SCALE, 
# 487
HOUGH_GRADIENT
# 488
}; 
# 492
enum LineSegmentDetectorModes { 
# 493
LSD_REFINE_NONE, 
# 494
LSD_REFINE_STD, 
# 495
LSD_REFINE_ADV
# 497
}; 
# 502
enum HistCompMethods { 
# 508
HISTCMP_CORREL, 
# 511
HISTCMP_CHISQR, 
# 514
HISTCMP_INTERSECT, 
# 518
HISTCMP_BHATTACHARYYA, 
# 519
HISTCMP_HELLINGER = 3, 
# 523
HISTCMP_CHISQR_ALT, 
# 526
HISTCMP_KL_DIV
# 527
}; 
# 533
enum ColorConversionCodes { 
# 534
COLOR_BGR2BGRA, 
# 535
COLOR_RGB2RGBA = 0, 
# 537
COLOR_BGRA2BGR, 
# 538
COLOR_RGBA2RGB = 1, 
# 540
COLOR_BGR2RGBA, 
# 541
COLOR_RGB2BGRA = 2, 
# 543
COLOR_RGBA2BGR, 
# 544
COLOR_BGRA2RGB = 3, 
# 546
COLOR_BGR2RGB, 
# 547
COLOR_RGB2BGR = 4, 
# 549
COLOR_BGRA2RGBA, 
# 550
COLOR_RGBA2BGRA = 5, 
# 552
COLOR_BGR2GRAY, 
# 553
COLOR_RGB2GRAY, 
# 554
COLOR_GRAY2BGR, 
# 555
COLOR_GRAY2RGB = 8, 
# 556
COLOR_GRAY2BGRA, 
# 557
COLOR_GRAY2RGBA = 9, 
# 558
COLOR_BGRA2GRAY, 
# 559
COLOR_RGBA2GRAY, 
# 561
COLOR_BGR2BGR565, 
# 562
COLOR_RGB2BGR565, 
# 563
COLOR_BGR5652BGR, 
# 564
COLOR_BGR5652RGB, 
# 565
COLOR_BGRA2BGR565, 
# 566
COLOR_RGBA2BGR565, 
# 567
COLOR_BGR5652BGRA, 
# 568
COLOR_BGR5652RGBA, 
# 570
COLOR_GRAY2BGR565, 
# 571
COLOR_BGR5652GRAY, 
# 573
COLOR_BGR2BGR555, 
# 574
COLOR_RGB2BGR555, 
# 575
COLOR_BGR5552BGR, 
# 576
COLOR_BGR5552RGB, 
# 577
COLOR_BGRA2BGR555, 
# 578
COLOR_RGBA2BGR555, 
# 579
COLOR_BGR5552BGRA, 
# 580
COLOR_BGR5552RGBA, 
# 582
COLOR_GRAY2BGR555, 
# 583
COLOR_BGR5552GRAY, 
# 585
COLOR_BGR2XYZ, 
# 586
COLOR_RGB2XYZ, 
# 587
COLOR_XYZ2BGR, 
# 588
COLOR_XYZ2RGB, 
# 590
COLOR_BGR2YCrCb, 
# 591
COLOR_RGB2YCrCb, 
# 592
COLOR_YCrCb2BGR, 
# 593
COLOR_YCrCb2RGB, 
# 595
COLOR_BGR2HSV, 
# 596
COLOR_RGB2HSV, 
# 598
COLOR_BGR2Lab = 44, 
# 599
COLOR_RGB2Lab, 
# 601
COLOR_BGR2Luv = 50, 
# 602
COLOR_RGB2Luv, 
# 603
COLOR_BGR2HLS, 
# 604
COLOR_RGB2HLS, 
# 606
COLOR_HSV2BGR, 
# 607
COLOR_HSV2RGB, 
# 609
COLOR_Lab2BGR, 
# 610
COLOR_Lab2RGB, 
# 611
COLOR_Luv2BGR, 
# 612
COLOR_Luv2RGB, 
# 613
COLOR_HLS2BGR, 
# 614
COLOR_HLS2RGB, 
# 616
COLOR_BGR2HSV_FULL = 66, 
# 617
COLOR_RGB2HSV_FULL, 
# 618
COLOR_BGR2HLS_FULL, 
# 619
COLOR_RGB2HLS_FULL, 
# 621
COLOR_HSV2BGR_FULL, 
# 622
COLOR_HSV2RGB_FULL, 
# 623
COLOR_HLS2BGR_FULL, 
# 624
COLOR_HLS2RGB_FULL, 
# 626
COLOR_LBGR2Lab, 
# 627
COLOR_LRGB2Lab, 
# 628
COLOR_LBGR2Luv, 
# 629
COLOR_LRGB2Luv, 
# 631
COLOR_Lab2LBGR, 
# 632
COLOR_Lab2LRGB, 
# 633
COLOR_Luv2LBGR, 
# 634
COLOR_Luv2LRGB, 
# 636
COLOR_BGR2YUV, 
# 637
COLOR_RGB2YUV, 
# 638
COLOR_YUV2BGR, 
# 639
COLOR_YUV2RGB, 
# 642
COLOR_YUV2RGB_NV12 = 90, 
# 643
COLOR_YUV2BGR_NV12, 
# 644
COLOR_YUV2RGB_NV21, 
# 645
COLOR_YUV2BGR_NV21, 
# 646
COLOR_YUV420sp2RGB = 92, 
# 647
COLOR_YUV420sp2BGR, 
# 649
COLOR_YUV2RGBA_NV12, 
# 650
COLOR_YUV2BGRA_NV12, 
# 651
COLOR_YUV2RGBA_NV21, 
# 652
COLOR_YUV2BGRA_NV21, 
# 653
COLOR_YUV420sp2RGBA = 96, 
# 654
COLOR_YUV420sp2BGRA, 
# 656
COLOR_YUV2RGB_YV12, 
# 657
COLOR_YUV2BGR_YV12, 
# 658
COLOR_YUV2RGB_IYUV, 
# 659
COLOR_YUV2BGR_IYUV, 
# 660
COLOR_YUV2RGB_I420 = 100, 
# 661
COLOR_YUV2BGR_I420, 
# 662
COLOR_YUV420p2RGB = 98, 
# 663
COLOR_YUV420p2BGR, 
# 665
COLOR_YUV2RGBA_YV12 = 102, 
# 666
COLOR_YUV2BGRA_YV12, 
# 667
COLOR_YUV2RGBA_IYUV, 
# 668
COLOR_YUV2BGRA_IYUV, 
# 669
COLOR_YUV2RGBA_I420 = 104, 
# 670
COLOR_YUV2BGRA_I420, 
# 671
COLOR_YUV420p2RGBA = 102, 
# 672
COLOR_YUV420p2BGRA, 
# 674
COLOR_YUV2GRAY_420 = 106, 
# 675
COLOR_YUV2GRAY_NV21 = 106, 
# 676
COLOR_YUV2GRAY_NV12 = 106, 
# 677
COLOR_YUV2GRAY_YV12 = 106, 
# 678
COLOR_YUV2GRAY_IYUV = 106, 
# 679
COLOR_YUV2GRAY_I420 = 106, 
# 680
COLOR_YUV420sp2GRAY = 106, 
# 681
COLOR_YUV420p2GRAY = 106, 
# 684
COLOR_YUV2RGB_UYVY, 
# 685
COLOR_YUV2BGR_UYVY, 
# 688
COLOR_YUV2RGB_Y422 = 107, 
# 689
COLOR_YUV2BGR_Y422, 
# 690
COLOR_YUV2RGB_UYNV = 107, 
# 691
COLOR_YUV2BGR_UYNV, 
# 693
COLOR_YUV2RGBA_UYVY = 111, 
# 694
COLOR_YUV2BGRA_UYVY, 
# 697
COLOR_YUV2RGBA_Y422 = 111, 
# 698
COLOR_YUV2BGRA_Y422, 
# 699
COLOR_YUV2RGBA_UYNV = 111, 
# 700
COLOR_YUV2BGRA_UYNV, 
# 702
COLOR_YUV2RGB_YUY2 = 115, 
# 703
COLOR_YUV2BGR_YUY2, 
# 704
COLOR_YUV2RGB_YVYU, 
# 705
COLOR_YUV2BGR_YVYU, 
# 706
COLOR_YUV2RGB_YUYV = 115, 
# 707
COLOR_YUV2BGR_YUYV, 
# 708
COLOR_YUV2RGB_YUNV = 115, 
# 709
COLOR_YUV2BGR_YUNV, 
# 711
COLOR_YUV2RGBA_YUY2 = 119, 
# 712
COLOR_YUV2BGRA_YUY2, 
# 713
COLOR_YUV2RGBA_YVYU, 
# 714
COLOR_YUV2BGRA_YVYU, 
# 715
COLOR_YUV2RGBA_YUYV = 119, 
# 716
COLOR_YUV2BGRA_YUYV, 
# 717
COLOR_YUV2RGBA_YUNV = 119, 
# 718
COLOR_YUV2BGRA_YUNV, 
# 720
COLOR_YUV2GRAY_UYVY = 123, 
# 721
COLOR_YUV2GRAY_YUY2, 
# 723
COLOR_YUV2GRAY_Y422 = 123, 
# 724
COLOR_YUV2GRAY_UYNV = 123, 
# 725
COLOR_YUV2GRAY_YVYU, 
# 726
COLOR_YUV2GRAY_YUYV = 124, 
# 727
COLOR_YUV2GRAY_YUNV = 124, 
# 730
COLOR_RGBA2mRGBA, 
# 731
COLOR_mRGBA2RGBA, 
# 734
COLOR_RGB2YUV_I420, 
# 735
COLOR_BGR2YUV_I420, 
# 736
COLOR_RGB2YUV_IYUV = 127, 
# 737
COLOR_BGR2YUV_IYUV, 
# 739
COLOR_RGBA2YUV_I420, 
# 740
COLOR_BGRA2YUV_I420, 
# 741
COLOR_RGBA2YUV_IYUV = 129, 
# 742
COLOR_BGRA2YUV_IYUV, 
# 743
COLOR_RGB2YUV_YV12, 
# 744
COLOR_BGR2YUV_YV12, 
# 745
COLOR_RGBA2YUV_YV12, 
# 746
COLOR_BGRA2YUV_YV12, 
# 749
COLOR_BayerBG2BGR = 46, 
# 750
COLOR_BayerGB2BGR, 
# 751
COLOR_BayerRG2BGR, 
# 752
COLOR_BayerGR2BGR, 
# 754
COLOR_BayerBG2RGB = 48, 
# 755
COLOR_BayerGB2RGB, 
# 756
COLOR_BayerRG2RGB = 46, 
# 757
COLOR_BayerGR2RGB, 
# 759
COLOR_BayerBG2GRAY = 86, 
# 760
COLOR_BayerGB2GRAY, 
# 761
COLOR_BayerRG2GRAY, 
# 762
COLOR_BayerGR2GRAY, 
# 765
COLOR_BayerBG2BGR_VNG = 62, 
# 766
COLOR_BayerGB2BGR_VNG, 
# 767
COLOR_BayerRG2BGR_VNG, 
# 768
COLOR_BayerGR2BGR_VNG, 
# 770
COLOR_BayerBG2RGB_VNG = 64, 
# 771
COLOR_BayerGB2RGB_VNG, 
# 772
COLOR_BayerRG2RGB_VNG = 62, 
# 773
COLOR_BayerGR2RGB_VNG, 
# 776
COLOR_BayerBG2BGR_EA = 135, 
# 777
COLOR_BayerGB2BGR_EA, 
# 778
COLOR_BayerRG2BGR_EA, 
# 779
COLOR_BayerGR2BGR_EA, 
# 781
COLOR_BayerBG2RGB_EA = 137, 
# 782
COLOR_BayerGB2RGB_EA, 
# 783
COLOR_BayerRG2RGB_EA = 135, 
# 784
COLOR_BayerGR2RGB_EA, 
# 787
COLOR_BayerBG2BGRA = 139, 
# 788
COLOR_BayerGB2BGRA, 
# 789
COLOR_BayerRG2BGRA, 
# 790
COLOR_BayerGR2BGRA, 
# 792
COLOR_BayerBG2RGBA = 141, 
# 793
COLOR_BayerGB2RGBA, 
# 794
COLOR_BayerRG2RGBA = 139, 
# 795
COLOR_BayerGR2RGBA, 
# 797
COLOR_COLORCVT_MAX = 143
# 798
}; 
# 803
enum RectanglesIntersectTypes { 
# 804
INTERSECT_NONE, 
# 805
INTERSECT_PARTIAL, 
# 806
INTERSECT_FULL
# 807
}; 
# 810
class __attribute((visibility("default"))) GeneralizedHough : public Algorithm { 
# 814
public: virtual void setTemplate(InputArray templ, Point templCenter = Point(-1, -1)) = 0; 
# 815
virtual void setTemplate(InputArray edges, InputArray dx, InputArray dy, Point templCenter = Point(-1, -1)) = 0; 
# 818
virtual void detect(InputArray image, OutputArray positions, OutputArray votes = noArray()) = 0; 
# 819
virtual void detect(InputArray edges, InputArray dx, InputArray dy, OutputArray positions, OutputArray votes = noArray()) = 0; 
# 822
virtual void setCannyLowThresh(int cannyLowThresh) = 0; 
# 823
virtual int getCannyLowThresh() const = 0; 
# 826
virtual void setCannyHighThresh(int cannyHighThresh) = 0; 
# 827
virtual int getCannyHighThresh() const = 0; 
# 830
virtual void setMinDist(double minDist) = 0; 
# 831
virtual double getMinDist() const = 0; 
# 834
virtual void setDp(double dp) = 0; 
# 835
virtual double getDp() const = 0; 
# 838
virtual void setMaxBufferSize(int maxBufferSize) = 0; 
# 839
virtual int getMaxBufferSize() const = 0; 
# 840
}; 
# 844
class __attribute((visibility("default"))) GeneralizedHoughBallard : public GeneralizedHough { 
# 848
public: virtual void setLevels(int levels) = 0; 
# 849
virtual int getLevels() const = 0; 
# 852
virtual void setVotesThreshold(int votesThreshold) = 0; 
# 853
virtual int getVotesThreshold() const = 0; 
# 854
}; 
# 858
class __attribute((visibility("default"))) GeneralizedHoughGuil : public GeneralizedHough { 
# 862
public: virtual void setXi(double xi) = 0; 
# 863
virtual double getXi() const = 0; 
# 866
virtual void setLevels(int levels) = 0; 
# 867
virtual int getLevels() const = 0; 
# 870
virtual void setAngleEpsilon(double angleEpsilon) = 0; 
# 871
virtual double getAngleEpsilon() const = 0; 
# 874
virtual void setMinAngle(double minAngle) = 0; 
# 875
virtual double getMinAngle() const = 0; 
# 878
virtual void setMaxAngle(double maxAngle) = 0; 
# 879
virtual double getMaxAngle() const = 0; 
# 882
virtual void setAngleStep(double angleStep) = 0; 
# 883
virtual double getAngleStep() const = 0; 
# 886
virtual void setAngleThresh(int angleThresh) = 0; 
# 887
virtual int getAngleThresh() const = 0; 
# 890
virtual void setMinScale(double minScale) = 0; 
# 891
virtual double getMinScale() const = 0; 
# 894
virtual void setMaxScale(double maxScale) = 0; 
# 895
virtual double getMaxScale() const = 0; 
# 898
virtual void setScaleStep(double scaleStep) = 0; 
# 899
virtual double getScaleStep() const = 0; 
# 902
virtual void setScaleThresh(int scaleThresh) = 0; 
# 903
virtual int getScaleThresh() const = 0; 
# 906
virtual void setPosThresh(int posThresh) = 0; 
# 907
virtual int getPosThresh() const = 0; 
# 908
}; 
# 911
class __attribute((visibility("default"))) CLAHE : public Algorithm { 
# 914
public: virtual void apply(InputArray src, OutputArray dst) = 0; 
# 916
virtual void setClipLimit(double clipLimit) = 0; 
# 917
virtual double getClipLimit() const = 0; 
# 919
virtual void setTilesGridSize(Size tileGridSize) = 0; 
# 920
virtual Size getTilesGridSize() const = 0; 
# 922
virtual void collectGarbage() = 0; 
# 923
}; 
# 929
class __attribute((visibility("default"))) Subdiv2D { 
# 933
public: enum { PTLOC_ERROR = (-2), 
# 934
PTLOC_OUTSIDE_RECT, 
# 935
PTLOC_INSIDE = 0, 
# 936
PTLOC_VERTEX, 
# 937
PTLOC_ON_EDGE
# 938
}; 
# 941
enum { NEXT_AROUND_ORG, 
# 942
NEXT_AROUND_DST = 34, 
# 943
PREV_AROUND_ORG = 17, 
# 944
PREV_AROUND_DST = 51, 
# 945
NEXT_AROUND_LEFT = 19, 
# 946
NEXT_AROUND_RIGHT = 49, 
# 947
PREV_AROUND_LEFT = 32, 
# 948
PREV_AROUND_RIGHT = 2
# 949
}; 
# 954
Subdiv2D(); 
# 964 "/usr/include/opencv2/imgproc.hpp" 3
Subdiv2D(Rect rect); 
# 971
void initDelaunay(Rect rect); 
# 983 "/usr/include/opencv2/imgproc.hpp" 3
int insert(Point2f pt); 
# 992 "/usr/include/opencv2/imgproc.hpp" 3
void insert(const std::vector< Point_< float> >  & ptvec); 
# 1014 "/usr/include/opencv2/imgproc.hpp" 3
int locate(Point2f pt, int & edge, int & vertex); 
# 1028 "/usr/include/opencv2/imgproc.hpp" 3
int findNearest(Point2f pt, Point2f * nearestPt = 0); 
# 1037 "/usr/include/opencv2/imgproc.hpp" 3
void getEdgeList(std::vector< Vec< float, 4> >  & edgeList) const; 
# 1045
void getLeadingEdgeList(std::vector< int>  & leadingEdgeList) const; 
# 1054 "/usr/include/opencv2/imgproc.hpp" 3
void getTriangleList(std::vector< Vec< float, 6> >  & triangleList) const; 
# 1063 "/usr/include/opencv2/imgproc.hpp" 3
void getVoronoiFacetList(const std::vector< int>  & idx, std::vector< std::vector< Point_< float> > >  & facetList, std::vector< Point_< float> >  & facetCenters); 
# 1073 "/usr/include/opencv2/imgproc.hpp" 3
Point2f getVertex(int vertex, int * firstEdge = 0) const; 
# 1093 "/usr/include/opencv2/imgproc.hpp" 3
int getEdge(int edge, int nextEdgeType) const; 
# 1102 "/usr/include/opencv2/imgproc.hpp" 3
int nextEdge(int edge) const; 
# 1116 "/usr/include/opencv2/imgproc.hpp" 3
int rotateEdge(int edge, int rotate) const; 
# 1117
int symEdge(int edge) const; 
# 1126 "/usr/include/opencv2/imgproc.hpp" 3
int edgeOrg(int edge, Point2f * orgpt = 0) const; 
# 1135 "/usr/include/opencv2/imgproc.hpp" 3
int edgeDst(int edge, Point2f * dstpt = 0) const; 
# 1138
protected: int newEdge(); 
# 1139
void deleteEdge(int edge); 
# 1140
int newPoint(Point2f pt, bool isvirtual, int firstEdge = 0); 
# 1141
void deletePoint(int vtx); 
# 1142
void setEdgePoints(int edge, int orgPt, int dstPt); 
# 1143
void splice(int edgeA, int edgeB); 
# 1144
int connectEdges(int edgeA, int edgeB); 
# 1145
void swapEdges(int edge); 
# 1146
int isRightOf(Point2f pt, int edge) const; 
# 1147
void calcVoronoi(); 
# 1148
void clearVoronoi(); 
# 1149
void checkSubdiv() const; 
# 1151
struct __attribute((visibility("default"))) Vertex { 
# 1153
Vertex(); 
# 1154
Vertex(Point2f pt, bool _isvirtual, int _firstEdge = 0); 
# 1155
bool isvirtual() const; 
# 1156
bool isfree() const; 
# 1158
int firstEdge; 
# 1159
int type; 
# 1160
Point2f pt; 
# 1161
}; 
# 1163
struct __attribute((visibility("default"))) QuadEdge { 
# 1165
QuadEdge(); 
# 1166
QuadEdge(int edgeidx); 
# 1167
bool isfree() const; 
# 1169
int next[4]; 
# 1170
int pt[4]; 
# 1171
}; 
# 1174
std::vector< Vertex>  vtx; 
# 1176
std::vector< QuadEdge>  qedges; 
# 1177
int freeQEdge; 
# 1178
int freePoint; 
# 1179
bool validGeometry; 
# 1181
int recentEdge; 
# 1183
Point2f topLeft; 
# 1185
Point2f bottomRight; 
# 1186
}; 
# 1202 "/usr/include/opencv2/imgproc.hpp" 3
class __attribute((visibility("default"))) LineSegmentDetector : public Algorithm { 
# 1226 "/usr/include/opencv2/imgproc.hpp" 3
public: virtual void detect(InputArray _image, OutputArray _lines, OutputArray width = noArray(), OutputArray prec = noArray(), OutputArray nfa = noArray()) = 0; 
# 1235
virtual void drawSegments(InputOutputArray _image, InputArray lines) = 0; 
# 1245 "/usr/include/opencv2/imgproc.hpp" 3
virtual int compareSegments(const Size & size, InputArray lines1, InputArray lines2, InputOutputArray _image = noArray()) = 0; 
# 1247
virtual ~LineSegmentDetector() { } 
# 1248
}; 
# 1265 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Ptr< LineSegmentDetector>  createLineSegmentDetector(int _refine = LSD_REFINE_STD, double _scale = (0.8000000000000000444), double _sigma_scale = (0.5999999999999999778), double _quant = (2.0), double _ang_th = (22.5), double _log_eps = 0, double _density_th = (0.6999999999999999556), int _n_bins = 1024); 
# 1293 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Mat getGaussianKernel(int ksize, double sigma, int ktype = 6); 
# 1313 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize = false, int ktype = 5); 
# 1330 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi = (3.141592653589793116) * (0.5), int ktype = 6); 
# 1334
static inline Scalar morphologyDefaultBorderValue() { return Scalar::all((double)(1.797693134862315708e+308L)); } 
# 1349 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Mat getStructuringElement(int shape, Size ksize, Point anchor = Point(-1, -1)); 
# 1370 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void medianBlur(InputArray src, OutputArray dst, int ksize); 
# 1392 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY = 0, int borderType = BORDER_DEFAULT); 
# 1424 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType = BORDER_DEFAULT); 
# 1452 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor = Point(-1, -1), bool normalize = true, int borderType = BORDER_DEFAULT); 
# 1475 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void sqrBoxFilter(InputArray _src, OutputArray _dst, int ddepth, Size ksize, Point anchor = Point(-1, -1), bool normalize = true, int borderType = BORDER_DEFAULT); 
# 1498 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void blur(InputArray src, OutputArray dst, Size ksize, Point anchor = Point(-1, -1), int borderType = BORDER_DEFAULT); 
# 1532 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor = Point(-1, -1), double delta = 0, int borderType = BORDER_DEFAULT); 
# 1553 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor = Point(-1, -1), double delta = 0, int borderType = BORDER_DEFAULT); 
# 1605 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT); 
# 1628 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void spatialGradient(InputArray src, OutputArray dx, OutputArray dy, int ksize = 3, int borderType = BORDER_DEFAULT); 
# 1654 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT); 
# 1685 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize = 1, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT); 
# 1717 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void Canny(InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize = 3, bool L2gradient = false); 
# 1729 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void Canny(InputArray dx, InputArray dy, OutputArray edges, double threshold1, double threshold2, bool L2gradient = false); 
# 1747 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void cornerMinEigenVal(InputArray src, OutputArray dst, int blockSize, int ksize = 3, int borderType = BORDER_DEFAULT); 
# 1770 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void cornerHarris(InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType = BORDER_DEFAULT); 
# 1800 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType = BORDER_DEFAULT); 
# 1827 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void preCornerDetect(InputArray src, OutputArray dst, int ksize, int borderType = BORDER_DEFAULT); 
# 1870 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void cornerSubPix(InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria); 
# 1918 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void goodFeaturesToTrack(InputArray image, OutputArray corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask = noArray(), int blockSize = 3, bool useHarrisDetector = false, double k = (0.04000000000000000083)); 
# 1923
__attribute((visibility("default"))) void goodFeaturesToTrack(InputArray image, OutputArray corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask, int blockSize, int gradientSize, bool useHarrisDetector = false, double k = (0.04000000000000000083)); 
# 1958 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void HoughLines(InputArray image, OutputArray lines, double rho, double theta, int threshold, double srn = 0, double stn = 0, double min_theta = 0, double max_theta = (3.141592653589793116)); 
# 2042 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void HoughLinesP(InputArray image, OutputArray lines, double rho, double theta, int threshold, double minLineLength = 0, double maxLineGap = 0); 
# 2117 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void HoughCircles(InputArray image, OutputArray circles, int method, double dp, double minDist, double param1 = 100, double param2 = 100, int minRadius = 0, int maxRadius = 0); 
# 2155 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor = Point(-1, -1), int iterations = 1, int borderType = BORDER_CONSTANT, const Scalar & borderValue = morphologyDefaultBorderValue()); 
# 2186 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor = Point(-1, -1), int iterations = 1, int borderType = BORDER_CONSTANT, const Scalar & borderValue = morphologyDefaultBorderValue()); 
# 2215 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor = Point(-1, -1), int iterations = 1, int borderType = BORDER_CONSTANT, const Scalar & borderValue = morphologyDefaultBorderValue()); 
# 2260 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void resize(InputArray src, OutputArray dst, Size dsize, double fx = 0, double fy = 0, int interpolation = INTER_LINEAR); 
# 2288 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags = INTER_LINEAR, int borderMode = BORDER_CONSTANT, const Scalar & borderValue = Scalar()); 
# 2319 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags = INTER_LINEAR, int borderMode = BORDER_CONSTANT, const Scalar & borderValue = Scalar()); 
# 2357 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode = BORDER_CONSTANT, const Scalar & borderValue = Scalar()); 
# 2392 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation = false); 
# 2415 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Mat getRotationMatrix2D(Point2f center, double angle, double scale); 
# 2418
__attribute((visibility("default"))) Mat getPerspectiveTransform(const Point2f  src[], const Point2f  dst[]); 
# 2435 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Mat getAffineTransform(const Point2f  src[], const Point2f  dst[]); 
# 2448 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void invertAffineTransform(InputArray M, OutputArray iM); 
# 2465 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Mat getPerspectiveTransform(InputArray src, InputArray dst); 
# 2467
__attribute((visibility("default"))) Mat getAffineTransform(InputArray src, InputArray dst); 
# 2490 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void getRectSubPix(InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType = -1); 
# 2530 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void logPolar(InputArray src, OutputArray dst, Point2f center, double M, int flags); 
# 2569 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void linearPolar(InputArray src, OutputArray dst, Point2f center, double maxRadius, int flags); 
# 2578
__attribute((visibility("default"))) void integral(InputArray src, OutputArray sum, int sdepth = -1); 
# 2581
__attribute((visibility("default"))) void integral(InputArray src, OutputArray sum, OutputArray sqsum, int sdepth = -1, int sqdepth = -1); 
# 2618 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void integral(InputArray src, OutputArray sum, OutputArray sqsum, OutputArray tilted, int sdepth = -1, int sqdepth = -1); 
# 2644 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void accumulate(InputArray src, InputOutputArray dst, InputArray mask = noArray()); 
# 2663 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void accumulateSquare(InputArray src, InputOutputArray dst, InputArray mask = noArray()); 
# 2682 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void accumulateProduct(InputArray src1, InputArray src2, InputOutputArray dst, InputArray mask = noArray()); 
# 2703 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void accumulateWeighted(InputArray src, InputOutputArray dst, double alpha, InputArray mask = noArray()); 
# 2741 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Point2d phaseCorrelate(InputArray src1, InputArray src2, InputArray window = noArray(), double * response = 0); 
# 2759 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void createHanningWindow(OutputArray dst, Size winSize, int type); 
# 2791 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type); 
# 2819 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void adaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C); 
# 2850 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void pyrDown(InputArray src, OutputArray dst, const Size & dstsize = Size(), int borderType = BORDER_DEFAULT); 
# 2870 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void pyrUp(InputArray src, OutputArray dst, const Size & dstsize = Size(), int borderType = BORDER_DEFAULT); 
# 2884 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void buildPyramid(InputArray src, OutputArrayOfArrays dst, int maxlevel, int borderType = BORDER_DEFAULT); 
# 2921 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix = noArray()); 
# 2988 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2); 
# 2993
__attribute((visibility("default"))) float initWideAngleProjMap(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, int destImageWidth, int m1type, OutputArray map1, OutputArray map2, int projType = PROJ_SPHERICAL_EQRECT, double alpha = 0); 
# 3020 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Mat getDefaultNewCameraMatrix(InputArray cameraMatrix, Size imgsize = Size(), bool centerPrincipalPoint = false); 
# 3063 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R = noArray(), InputArray P = noArray()); 
# 3070
__attribute((visibility("default"))) void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray P, TermCriteria criteria); 
# 3172 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void calcHist(const Mat * images, int nimages, const int * channels, InputArray mask, OutputArray hist, int dims, const int * histSize, const float ** ranges, bool uniform = true, bool accumulate = false); 
# 3181
__attribute((visibility("default"))) void calcHist(const Mat * images, int nimages, const int * channels, InputArray mask, SparseMat & hist, int dims, const int * histSize, const float ** ranges, bool uniform = true, bool accumulate = false); 
# 3188
__attribute((visibility("default"))) void calcHist(InputArrayOfArrays images, const std::vector< int>  & channels, InputArray mask, OutputArray hist, const std::vector< int>  & histSize, const std::vector< float>  & ranges, bool accumulate = false); 
# 3234 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void calcBackProject(const Mat * images, int nimages, const int * channels, InputArray hist, OutputArray backProject, const float ** ranges, double scale = 1, bool uniform = true); 
# 3240
__attribute((visibility("default"))) void calcBackProject(const Mat * images, int nimages, const int * channels, const SparseMat & hist, OutputArray backProject, const float ** ranges, double scale = 1, bool uniform = true); 
# 3246
__attribute((visibility("default"))) void calcBackProject(InputArrayOfArrays images, const std::vector< int>  & channels, InputArray hist, OutputArray dst, const std::vector< float>  & ranges, double scale); 
# 3266 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) double compareHist(InputArray H1, InputArray H2, int method); 
# 3269
__attribute((visibility("default"))) double compareHist(const SparseMat & H1, const SparseMat & H2, int method); 
# 3286 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void equalizeHist(InputArray src, OutputArray dst); 
# 3322 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) float EMD(InputArray signature1, InputArray signature2, int distType, InputArray cost = noArray(), float * lowerBound = 0, OutputArray flow = noArray()); 
# 3326
__attribute((visibility("default"))) float wrapperEMD(InputArray signature1, InputArray signature2, int distType, InputArray cost = noArray(), Ptr< float>  lowerBound = Ptr< float> (), OutputArray flow = noArray()); 
# 3362 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void watershed(InputArray image, InputOutputArray markers); 
# 3403 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void pyrMeanShiftFiltering(InputArray src, OutputArray dst, double sp, double sr, int maxLevel = 1, TermCriteria termcrit = TermCriteria((TermCriteria::MAX_ITER) + (TermCriteria::EPS), 5, 1)); 
# 3435 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void grabCut(InputArray img, InputOutputArray mask, Rect rect, InputOutputArray bgdModel, InputOutputArray fgdModel, int iterCount, int mode = GC_EVAL); 
# 3497 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void distanceTransform(InputArray src, OutputArray dst, OutputArray labels, int distanceType, int maskSize, int labelType = DIST_LABEL_CCOMP); 
# 3512 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void distanceTransform(InputArray src, OutputArray dst, int distanceType, int maskSize, int dstType = 5); 
# 3523 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) int floodFill(InputOutputArray image, Point seedPoint, Scalar newVal, Rect * rect = 0, Scalar loDiff = Scalar(), Scalar upDiff = Scalar(), int flags = 4); 
# 3598 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) int floodFill(InputOutputArray image, InputOutputArray mask, Point seedPoint, Scalar newVal, Rect * rect = 0, Scalar loDiff = Scalar(), Scalar upDiff = Scalar(), int flags = 4); 
# 3644 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void cvtColor(InputArray src, OutputArray dst, int code, int dstCn = 0); 
# 3649
__attribute((visibility("default"))) void demosaicing(InputArray _src, OutputArray _dst, int code, int dcn = 0); 
# 3670 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Moments moments(InputArray array, bool binaryImage = false); 
# 3691 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void HuMoments(const Moments & moments, double  hu[7]); 
# 3694
__attribute((visibility("default"))) void HuMoments(const Moments & m, OutputArray hu); 
# 3702
enum TemplateMatchModes { 
# 3703
TM_SQDIFF, 
# 3704
TM_SQDIFF_NORMED, 
# 3705
TM_CCORR, 
# 3706
TM_CCORR_NORMED, 
# 3707
TM_CCOEFF, 
# 3710
TM_CCOEFF_NORMED
# 3711
}; 
# 3739 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method, InputArray mask = noArray()); 
# 3764 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) int connectedComponents(InputArray image, OutputArray labels, int connectivity, int ltype, int ccltype); 
# 3775 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) int connectedComponents(InputArray image, OutputArray labels, int connectivity = 8, int ltype = 4); 
# 3801 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) int connectedComponentsWithStats(InputArray image, OutputArray labels, OutputArray stats, OutputArray centroids, int connectivity, int ltype, int ccltype); 
# 3816 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) int connectedComponentsWithStats(InputArray image, OutputArray labels, OutputArray stats, OutputArray centroids, int connectivity = 8, int ltype = 4); 
# 3846 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset = Point()); 
# 3851
__attribute((visibility("default"))) void findContours(InputOutputArray image, OutputArrayOfArrays contours, int mode, int method, Point offset = Point()); 
# 3867 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void approxPolyDP(InputArray curve, OutputArray approxCurve, double epsilon, bool closed); 
# 3878 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) double arcLength(InputArray curve, bool closed); 
# 3886
__attribute((visibility("default"))) Rect boundingRect(InputArray points); 
# 3918 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) double contourArea(InputArray contour, bool oriented = false); 
# 3928 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) RotatedRect minAreaRect(InputArray points); 
# 3941 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void boxPoints(RotatedRect box, OutputArray points); 
# 3951 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void minEnclosingCircle(InputArray points, Point2f & center, float & radius); 
# 3976 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) double minEnclosingTriangle(InputArray points, OutputArray triangle); 
# 3987 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) double matchShapes(InputArray contour1, InputArray contour2, int method, double parameter); 
# 4016 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void convexHull(InputArray points, OutputArray hull, bool clockwise = false, bool returnPoints = true); 
# 4036 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void convexityDefects(InputArray contour, InputArray convexhull, OutputArray convexityDefects); 
# 4045 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) bool isContourConvex(InputArray contour); 
# 4048
__attribute((visibility("default"))) float intersectConvexConvex(InputArray _p1, InputArray _p2, OutputArray _p12, bool handleNested = true); 
# 4065 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) RotatedRect fitEllipse(InputArray points); 
# 4102 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) RotatedRect fitEllipseAMS(InputArray points); 
# 4147 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) RotatedRect fitEllipseDirect(InputArray points); 
# 4183 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void fitLine(InputArray points, OutputArray line, int distType, double param, double reps, double aeps); 
# 4202 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) double pointPolygonTest(InputArray contour, Point2f pt, bool measureDist); 
# 4219 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) int rotatedRectangleIntersection(const RotatedRect & rect1, const RotatedRect & rect2, OutputArray intersectingRegion); 
# 4223
__attribute((visibility("default"))) Ptr< CLAHE>  createCLAHE(double clipLimit = (40.0), Size tileGridSize = Size(8, 8)); 
# 4227
__attribute((visibility("default"))) Ptr< GeneralizedHoughBallard>  createGeneralizedHoughBallard(); 
# 4231
__attribute((visibility("default"))) Ptr< GeneralizedHoughGuil>  createGeneralizedHoughGuil(); 
# 4240 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void blendLinear(InputArray src1, InputArray src2, InputArray weights1, InputArray weights2, OutputArray dst); 
# 4246
enum ColormapTypes { 
# 4248
COLORMAP_AUTUMN, 
# 4249
COLORMAP_BONE, 
# 4250
COLORMAP_JET, 
# 4251
COLORMAP_WINTER, 
# 4252
COLORMAP_RAINBOW, 
# 4253
COLORMAP_OCEAN, 
# 4254
COLORMAP_SUMMER, 
# 4255
COLORMAP_SPRING, 
# 4256
COLORMAP_COOL, 
# 4257
COLORMAP_HSV, 
# 4258
COLORMAP_PINK, 
# 4259
COLORMAP_HOT, 
# 4260
COLORMAP_PARULA
# 4261
}; 
# 4272 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void applyColorMap(InputArray src, OutputArray dst, int colormap); 
# 4280
__attribute((visibility("default"))) void applyColorMap(InputArray src, OutputArray dst, InputArray userColor); 
# 4302 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void line(InputOutputArray img, Point pt1, Point pt2, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4318 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void arrowedLine(InputOutputArray img, Point pt1, Point pt2, const Scalar & color, int thickness = 1, int line_type = 8, int shift = 0, double tipLength = (0.1000000000000000056)); 
# 4335 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void rectangle(InputOutputArray img, Point pt1, Point pt2, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4344
__attribute((visibility("default"))) void rectangle(Mat & img, Rect rec, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4363 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void circle(InputOutputArray img, Point center, int radius, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4392 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4406 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void ellipse(InputOutputArray img, const RotatedRect & box, const Scalar & color, int thickness = 1, int lineType = LINE_8); 
# 4414
enum MarkerTypes { 
# 4416
MARKER_CROSS, 
# 4417
MARKER_TILTED_CROSS, 
# 4418
MARKER_STAR, 
# 4419
MARKER_DIAMOND, 
# 4420
MARKER_SQUARE, 
# 4421
MARKER_TRIANGLE_UP, 
# 4422
MARKER_TRIANGLE_DOWN
# 4423
}; 
# 4438 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void drawMarker(Mat & img, Point position, const Scalar & color, int markerType = MARKER_CROSS, int markerSize = 20, int thickness = 1, int line_type = 8); 
# 4447
__attribute((visibility("default"))) void fillConvexPoly(Mat & img, const Point * pts, int npts, const Scalar & color, int lineType = LINE_8, int shift = 0); 
# 4464 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void fillConvexPoly(InputOutputArray img, InputArray points, const Scalar & color, int lineType = LINE_8, int shift = 0); 
# 4469
__attribute((visibility("default"))) void fillPoly(Mat & img, const Point ** pts, const int * npts, int ncontours, const Scalar & color, int lineType = LINE_8, int shift = 0, Point offset = Point()); 
# 4490 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void fillPoly(InputOutputArray img, InputArrayOfArrays pts, const Scalar & color, int lineType = LINE_8, int shift = 0, Point offset = Point()); 
# 4495
__attribute((visibility("default"))) void polylines(Mat & img, const Point *const * pts, const int * npts, int ncontours, bool isClosed, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4512 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void polylines(InputOutputArray img, InputArrayOfArrays pts, bool isClosed, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4588 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar & color, int thickness = 1, int lineType = LINE_8, InputArray hierarchy = noArray(), int maxLevel = 2147483647, Point offset = Point()); 
# 4603 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) bool clipLine(Size imgSize, Point & pt1, Point & pt2); 
# 4610
__attribute((visibility("default"))) bool clipLine(Size2l imgSize, Point2l & pt1, Point2l & pt2); 
# 4617
__attribute((visibility("default"))) bool clipLine(Rect imgRect, Point & pt1, Point & pt2); 
# 4633 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, std::vector< Point_< int> >  & pts); 
# 4647 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void ellipse2Poly(Point2d center, Size2d axes, int angle, int arcStart, int arcEnd, int delta, std::vector< Point_< double> >  & pts); 
# 4668 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) void putText(InputOutputArray img, const String & text, Point org, int fontFace, double fontScale, Scalar color, int thickness = 1, int lineType = LINE_8, bool bottomLeftOrigin = false); 
# 4718 "/usr/include/opencv2/imgproc.hpp" 3
__attribute((visibility("default"))) Size getTextSize(const String & text, int fontFace, double fontScale, int thickness, int * baseLine); 
# 4754 "/usr/include/opencv2/imgproc.hpp" 3
class __attribute((visibility("default"))) LineIterator { 
# 4766 "/usr/include/opencv2/imgproc.hpp" 3
public: LineIterator(const Mat & img, Point pt1, Point pt2, int connectivity = 8, bool leftToRight = false); 
# 4770
inline uchar *operator*(); 
# 4773
inline LineIterator &operator++(); 
# 4776
inline LineIterator operator++(int); 
# 4779
inline Point pos() const; 
# 4781
uchar *ptr; 
# 4782
const uchar *ptr0; 
# 4783
int step, elemSize; 
# 4784
int err, count; 
# 4785
int minusDelta, plusDelta; 
# 4786
int minusStep, plusStep; 
# 4787
}; 
# 4794
inline uchar *LineIterator::operator*() 
# 4795
{ 
# 4796
return ptr; 
# 4797
} 
# 4800
inline LineIterator &LineIterator::operator++() 
# 4801
{ 
# 4802
int mask = ((err) < 0) ? -1 : 0; 
# 4803
(err) += ((minusDelta) + ((plusDelta) & mask)); 
# 4804
(ptr) += ((minusStep) + ((plusStep) & mask)); 
# 4805
return *this; 
# 4806
} 
# 4809
inline LineIterator LineIterator::operator++(int) 
# 4810
{ 
# 4811
LineIterator it = *this; 
# 4812
(++(*this)); 
# 4813
return it; 
# 4814
} 
# 4817
inline Point LineIterator::pos() const 
# 4818
{ 
# 4819
Point p; 
# 4820
(p.y) = ((int)(((ptr) - (ptr0)) / (step))); 
# 4821
(p.x) = ((int)((((ptr) - (ptr0)) - ((p.y) * (step))) / (elemSize))); 
# 4822
return p; 
# 4823
} 
# 4831
}
# 71 "/usr/include/opencv2/ml.hpp" 3
namespace cv { 
# 74
namespace ml { 
# 81
enum VariableTypes { 
# 83
VAR_NUMERICAL, 
# 84
VAR_ORDERED = 0, 
# 85
VAR_CATEGORICAL
# 86
}; 
# 89
enum ErrorTypes { 
# 91
TEST_ERROR, 
# 92
TRAIN_ERROR
# 93
}; 
# 96
enum SampleTypes { 
# 98
ROW_SAMPLE, 
# 99
COL_SAMPLE
# 100
}; 
# 107
class __attribute((visibility("default"))) ParamGrid { 
# 111
public: ParamGrid(); 
# 113
ParamGrid(double _minVal, double _maxVal, double _logStep); 
# 115
double minVal; 
# 116
double maxVal; 
# 125 "/usr/include/opencv2/ml.hpp" 3
double logStep; 
# 133
static Ptr< ParamGrid>  create(double minVal = (0.0), double maxVal = (0.0), double logstep = (1.0)); 
# 134
}; 
# 145 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) TrainData { 
# 148
public: static float missingValue() { return (3.402823466e+38F); } 
# 149
virtual ~TrainData(); 
# 151
virtual int getLayout() const = 0; 
# 152
virtual int getNTrainSamples() const = 0; 
# 153
virtual int getNTestSamples() const = 0; 
# 154
virtual int getNSamples() const = 0; 
# 155
virtual int getNVars() const = 0; 
# 156
virtual int getNAllVars() const = 0; 
# 158
virtual void getSample(InputArray varIdx, int sidx, float * buf) const = 0; 
# 159
virtual Mat getSamples() const = 0; 
# 160
virtual Mat getMissing() const = 0; 
# 174 "/usr/include/opencv2/ml.hpp" 3
virtual Mat getTrainSamples(int layout = ROW_SAMPLE, bool compressSamples = true, bool compressVars = true) const = 0; 
# 183
virtual Mat getTrainResponses() const = 0; 
# 191
virtual Mat getTrainNormCatResponses() const = 0; 
# 192
virtual Mat getTestResponses() const = 0; 
# 193
virtual Mat getTestNormCatResponses() const = 0; 
# 194
virtual Mat getResponses() const = 0; 
# 195
virtual Mat getNormCatResponses() const = 0; 
# 196
virtual Mat getSampleWeights() const = 0; 
# 197
virtual Mat getTrainSampleWeights() const = 0; 
# 198
virtual Mat getTestSampleWeights() const = 0; 
# 199
virtual Mat getVarIdx() const = 0; 
# 200
virtual Mat getVarType() const = 0; 
# 201
Mat getVarSymbolFlags() const; 
# 202
virtual int getResponseType() const = 0; 
# 203
virtual Mat getTrainSampleIdx() const = 0; 
# 204
virtual Mat getTestSampleIdx() const = 0; 
# 205
virtual void getValues(int vi, InputArray sidx, float * values) const = 0; 
# 206
virtual void getNormCatValues(int vi, InputArray sidx, int * values) const = 0; 
# 207
virtual Mat getDefaultSubstValues() const = 0; 
# 209
virtual int getCatCount(int vi) const = 0; 
# 215
virtual Mat getClassLabels() const = 0; 
# 217
virtual Mat getCatOfs() const = 0; 
# 218
virtual Mat getCatMap() const = 0; 
# 223
virtual void setTrainTestSplit(int count, bool shuffle = true) = 0; 
# 233 "/usr/include/opencv2/ml.hpp" 3
virtual void setTrainTestSplitRatio(double ratio, bool shuffle = true) = 0; 
# 234
virtual void shuffleTrainTest() = 0; 
# 237
Mat getTestSamples() const; 
# 240
void getNames(std::vector< String>  & names) const; 
# 242
static Mat getSubVector(const Mat & vec, const Mat & idx); 
# 273 "/usr/include/opencv2/ml.hpp" 3
static Ptr< TrainData>  loadFromCSV(const String & filename, int headerLineCount, int responseStartIdx = -1, int responseEndIdx = -1, const String & varTypeSpec = String(), char delimiter = ',', char missch = '\?'); 
# 300 "/usr/include/opencv2/ml.hpp" 3
static Ptr< TrainData>  create(InputArray samples, int layout, InputArray responses, InputArray varIdx = noArray(), InputArray sampleIdx = noArray(), InputArray sampleWeights = noArray(), InputArray varType = noArray()); 
# 303
}; 
# 307
class __attribute((visibility("default"))) StatModel : public Algorithm { 
# 311
public: enum Flags { 
# 312
UPDATE_MODEL = 1, 
# 313
RAW_OUTPUT = 1, 
# 314
COMPRESSED_INPUT, 
# 315
PREPROCESSED_INPUT = 4
# 316
}; 
# 319
virtual int getVarCount() const = 0; 
# 321
virtual bool empty() const; 
# 324
virtual bool isTrained() const = 0; 
# 326
virtual bool isClassifier() const = 0; 
# 335 "/usr/include/opencv2/ml.hpp" 3
virtual bool train(const Ptr< TrainData>  & trainData, int flags = 0); 
# 343
virtual bool train(InputArray samples, int layout, InputArray responses); 
# 358 "/usr/include/opencv2/ml.hpp" 3
virtual float calcError(const Ptr< TrainData>  & data, bool test, OutputArray resp) const; 
# 366
virtual float predict(InputArray samples, OutputArray results = noArray(), int flags = 0) const = 0; 
# 372
template< class _Tp> static Ptr< _Tp>  train(const Ptr< TrainData>  &data, int flags = 0) 
# 373
{ 
# 374
Ptr< _Tp>  model = _Tp::create(); 
# 375
return ((!(model.empty())) && (model->train(data, flags))) ? model : Ptr< _Tp> (); 
# 376
} 
# 377
}; 
# 387 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) NormalBayesClassifier : public StatModel { 
# 398 "/usr/include/opencv2/ml.hpp" 3
public: virtual float predictProb(InputArray inputs, OutputArray outputs, OutputArray outputProbs, int flags = 0) const = 0; 
# 403
static Ptr< NormalBayesClassifier>  create(); 
# 414 "/usr/include/opencv2/ml.hpp" 3
static Ptr< NormalBayesClassifier>  load(const String & filepath, const String & nodeName = String()); 
# 415
}; 
# 425 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) KNearest : public StatModel { 
# 431
public: virtual int getDefaultK() const = 0; 
# 433
virtual void setDefaultK(int val) = 0; 
# 437
virtual bool getIsClassifier() const = 0; 
# 439
virtual void setIsClassifier(bool val) = 0; 
# 443
virtual int getEmax() const = 0; 
# 445
virtual void setEmax(int val) = 0; 
# 449
virtual int getAlgorithmType() const = 0; 
# 451
virtual void setAlgorithmType(int val) = 0; 
# 479 "/usr/include/opencv2/ml.hpp" 3
virtual float findNearest(InputArray samples, int k, OutputArray results, OutputArray neighborResponses = noArray(), OutputArray dist = noArray()) const = 0; 
# 486
enum Types { 
# 488
BRUTE_FORCE = 1, 
# 489
KDTREE
# 490
}; 
# 496
static Ptr< KNearest>  create(); 
# 497
}; 
# 507 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) SVM : public StatModel { 
# 511
public: class __attribute((visibility("default"))) Kernel : public Algorithm { 
# 514
public: virtual int getType() const = 0; 
# 515
virtual void calc(int vcount, int n, const float * vecs, const float * another, float * results) = 0; 
# 516
}; 
# 521
virtual int getType() const = 0; 
# 523
virtual void setType(int val) = 0; 
# 528
virtual double getGamma() const = 0; 
# 530
virtual void setGamma(double val) = 0; 
# 535
virtual double getCoef0() const = 0; 
# 537
virtual void setCoef0(double val) = 0; 
# 542
virtual double getDegree() const = 0; 
# 544
virtual void setDegree(double val) = 0; 
# 549
virtual double getC() const = 0; 
# 551
virtual void setC(double val) = 0; 
# 556
virtual double getNu() const = 0; 
# 558
virtual void setNu(double val) = 0; 
# 563
virtual double getP() const = 0; 
# 565
virtual void setP(double val) = 0; 
# 573
virtual Mat getClassWeights() const = 0; 
# 575
virtual void setClassWeights(const Mat & val) = 0; 
# 582
virtual TermCriteria getTermCriteria() const = 0; 
# 584
virtual void setTermCriteria(const TermCriteria & val) = 0; 
# 588
virtual int getKernelType() const = 0; 
# 592
virtual void setKernel(int kernelType) = 0; 
# 596
virtual void setCustomKernel(const Ptr< Kernel>  & _kernel) = 0; 
# 599
enum Types { 
# 602
C_SVC = 100, 
# 606
NU_SVC, 
# 610
ONE_CLASS, 
# 614
EPS_SVR, 
# 617
NU_SVR
# 618
}; 
# 628 "/usr/include/opencv2/ml.hpp" 3
enum KernelTypes { 
# 630
CUSTOM = (-1), 
# 633
LINEAR = 0, 
# 636
POLY, 
# 639
RBF, 
# 641
SIGMOID, 
# 644
CHI2, 
# 646
INTER
# 647
}; 
# 650
enum ParamTypes { 
# 651
C, 
# 652
GAMMA, 
# 653
P, 
# 654
NU, 
# 655
COEF, 
# 656
DEGREE
# 657
}; 
# 693 "/usr/include/opencv2/ml.hpp" 3
virtual bool trainAuto(const Ptr< TrainData>  & data, int kFold = 10, ParamGrid Cgrid = getDefaultGrid(C), ParamGrid gammaGrid = getDefaultGrid(GAMMA), ParamGrid pGrid = getDefaultGrid(P), ParamGrid nuGrid = getDefaultGrid(NU), ParamGrid coeffGrid = getDefaultGrid(COEF), ParamGrid degreeGrid = getDefaultGrid(DEGREE), bool balanced = false) = 0; 
# 730 "/usr/include/opencv2/ml.hpp" 3
bool trainAuto(InputArray samples, int layout, InputArray responses, int kFold = 10, Ptr< ParamGrid>  Cgrid = SVM::getDefaultGridPtr(SVM::C), Ptr< ParamGrid>  gammaGrid = SVM::getDefaultGridPtr(SVM::GAMMA), Ptr< ParamGrid>  pGrid = SVM::getDefaultGridPtr(SVM::P), Ptr< ParamGrid>  nuGrid = SVM::getDefaultGridPtr(SVM::NU), Ptr< ParamGrid>  coeffGrid = SVM::getDefaultGridPtr(SVM::COEF), Ptr< ParamGrid>  degreeGrid = SVM::getDefaultGridPtr(SVM::DEGREE), bool balanced = false); 
# 747
virtual Mat getSupportVectors() const = 0; 
# 755
Mat getUncompressedSupportVectors() const; 
# 772 "/usr/include/opencv2/ml.hpp" 3
virtual double getDecisionFunction(int i, OutputArray alpha, OutputArray svidx) const = 0; 
# 782 "/usr/include/opencv2/ml.hpp" 3
static ParamGrid getDefaultGrid(int param_id); 
# 792 "/usr/include/opencv2/ml.hpp" 3
static Ptr< ParamGrid>  getDefaultGridPtr(int param_id); 
# 797
static Ptr< SVM>  create(); 
# 806 "/usr/include/opencv2/ml.hpp" 3
static Ptr< SVM>  load(const String & filepath); 
# 807
}; 
# 817 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) EM : public StatModel { 
# 821
public: enum Types { 
# 828
COV_MAT_SPHERICAL, 
# 832
COV_MAT_DIAGONAL, 
# 837
COV_MAT_GENERIC, 
# 838
COV_MAT_DEFAULT = 1
# 839
}; 
# 842
enum { DEFAULT_NCLUSTERS = 5, DEFAULT_MAX_ITERS = 100}; 
# 845
enum { START_E_STEP = 1, START_M_STEP, START_AUTO_STEP = 0}; 
# 852
virtual int getClustersNumber() const = 0; 
# 854
virtual void setClustersNumber(int val) = 0; 
# 859
virtual int getCovarianceMatrixType() const = 0; 
# 861
virtual void setCovarianceMatrixType(int val) = 0; 
# 868
virtual TermCriteria getTermCriteria() const = 0; 
# 870
virtual void setTermCriteria(const TermCriteria & val) = 0; 
# 876
virtual Mat getWeights() const = 0; 
# 882
virtual Mat getMeans() const = 0; 
# 888
virtual void getCovs(std::vector< Mat>  & covs) const = 0; 
# 897 "/usr/include/opencv2/ml.hpp" 3
virtual float predict(InputArray samples, OutputArray results = noArray(), int flags = 0) const = 0; 
# 911 "/usr/include/opencv2/ml.hpp" 3
virtual Vec2d predict2(InputArray sample, OutputArray probs) const = 0; 
# 941 "/usr/include/opencv2/ml.hpp" 3
virtual bool trainEM(InputArray samples, OutputArray logLikelihoods = noArray(), OutputArray labels = noArray(), OutputArray probs = noArray()) = 0; 
# 973 "/usr/include/opencv2/ml.hpp" 3
virtual bool trainE(InputArray samples, InputArray means0, InputArray covs0 = noArray(), InputArray weights0 = noArray(), OutputArray logLikelihoods = noArray(), OutputArray labels = noArray(), OutputArray probs = noArray()) = 0; 
# 998 "/usr/include/opencv2/ml.hpp" 3
virtual bool trainM(InputArray samples, InputArray probs0, OutputArray logLikelihoods = noArray(), OutputArray labels = noArray(), OutputArray probs = noArray()) = 0; 
# 1007
static Ptr< EM>  create(); 
# 1018 "/usr/include/opencv2/ml.hpp" 3
static Ptr< EM>  load(const String & filepath, const String & nodeName = String()); 
# 1019
}; 
# 1034 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) DTrees : public StatModel { 
# 1038
public: enum Flags { PREDICT_AUTO, PREDICT_SUM = 256, PREDICT_MAX_VOTE = 512, PREDICT_MASK = 768}; 
# 1052 "/usr/include/opencv2/ml.hpp" 3
virtual int getMaxCategories() const = 0; 
# 1054
virtual void setMaxCategories(int val) = 0; 
# 1062
virtual int getMaxDepth() const = 0; 
# 1064
virtual void setMaxDepth(int val) = 0; 
# 1070
virtual int getMinSampleCount() const = 0; 
# 1072
virtual void setMinSampleCount(int val) = 0; 
# 1078
virtual int getCVFolds() const = 0; 
# 1080
virtual void setCVFolds(int val) = 0; 
# 1087
virtual bool getUseSurrogates() const = 0; 
# 1089
virtual void setUseSurrogates(bool val) = 0; 
# 1095
virtual bool getUse1SERule() const = 0; 
# 1097
virtual void setUse1SERule(bool val) = 0; 
# 1103
virtual bool getTruncatePrunedTree() const = 0; 
# 1105
virtual void setTruncatePrunedTree(bool val) = 0; 
# 1112
virtual float getRegressionAccuracy() const = 0; 
# 1114
virtual void setRegressionAccuracy(float val) = 0; 
# 1132 "/usr/include/opencv2/ml.hpp" 3
virtual Mat getPriors() const = 0; 
# 1134
virtual void setPriors(const Mat & val) = 0; 
# 1138
class __attribute((visibility("default"))) Node { 
# 1141
public: Node(); 
# 1142
double value; 
# 1144
int classIdx; 
# 1146
int parent; 
# 1147
int left; 
# 1148
int right; 
# 1149
int defaultDir; 
# 1151
int split; 
# 1152
}; 
# 1156
class __attribute((visibility("default"))) Split { 
# 1159
public: Split(); 
# 1160
int varIdx; 
# 1161
bool inversed; 
# 1163
float quality; 
# 1164
int next; 
# 1165
float c; 
# 1172
int subsetOfs; 
# 1179
}; 
# 1183
virtual const std::vector< int>  &getRoots() const = 0; 
# 1188
virtual const std::vector< Node>  &getNodes() const = 0; 
# 1193
virtual const std::vector< Split>  &getSplits() const = 0; 
# 1198
virtual const std::vector< int>  &getSubsets() const = 0; 
# 1206
static Ptr< DTrees>  create(); 
# 1217 "/usr/include/opencv2/ml.hpp" 3
static Ptr< DTrees>  load(const String & filepath, const String & nodeName = String()); 
# 1218
}; 
# 1228 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) RTrees : public DTrees { 
# 1235
public: virtual bool getCalculateVarImportance() const = 0; 
# 1237
virtual void setCalculateVarImportance(bool val) = 0; 
# 1244
virtual int getActiveVarCount() const = 0; 
# 1246
virtual void setActiveVarCount(int val) = 0; 
# 1256 "/usr/include/opencv2/ml.hpp" 3
virtual TermCriteria getTermCriteria() const = 0; 
# 1258
virtual void setTermCriteria(const TermCriteria & val) = 0; 
# 1265
virtual Mat getVarImportance() const = 0; 
# 1276 "/usr/include/opencv2/ml.hpp" 3
void getVotes(InputArray samples, OutputArray results, int flags) const; 
# 1282
static Ptr< RTrees>  create(); 
# 1293 "/usr/include/opencv2/ml.hpp" 3
static Ptr< RTrees>  load(const String & filepath, const String & nodeName = String()); 
# 1294
}; 
# 1304 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) Boost : public DTrees { 
# 1310
public: virtual int getBoostType() const = 0; 
# 1312
virtual void setBoostType(int val) = 0; 
# 1317
virtual int getWeakCount() const = 0; 
# 1319
virtual void setWeakCount(int val) = 0; 
# 1325
virtual double getWeightTrimRate() const = 0; 
# 1327
virtual void setWeightTrimRate(double val) = 0; 
# 1331
enum Types { 
# 1332
DISCRETE, 
# 1333
REAL, 
# 1335
LOGIT, 
# 1336
GENTLE
# 1338
}; 
# 1342
static Ptr< Boost>  create(); 
# 1353 "/usr/include/opencv2/ml.hpp" 3
static Ptr< Boost>  load(const String & filepath, const String & nodeName = String()); 
# 1354
}; 
# 1403 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) ANN_MLP : public StatModel { 
# 1407
public: enum TrainingMethods { 
# 1408
BACKPROP, 
# 1409
RPROP
# 1410
}; 
# 1417
virtual void setTrainMethod(int method, double param1 = 0, double param2 = 0) = 0; 
# 1420
virtual int getTrainMethod() const = 0; 
# 1428
virtual void setActivationFunction(int type, double param1 = 0, double param2 = 0) = 0; 
# 1434
virtual void setLayerSizes(InputArray _layer_sizes) = 0; 
# 1440
virtual Mat getLayerSizes() const = 0; 
# 1447
virtual TermCriteria getTermCriteria() const = 0; 
# 1449
virtual void setTermCriteria(TermCriteria val) = 0; 
# 1454
virtual double getBackpropWeightScale() const = 0; 
# 1456
virtual void setBackpropWeightScale(double val) = 0; 
# 1463
virtual double getBackpropMomentumScale() const = 0; 
# 1465
virtual void setBackpropMomentumScale(double val) = 0; 
# 1470
virtual double getRpropDW0() const = 0; 
# 1472
virtual void setRpropDW0(double val) = 0; 
# 1477
virtual double getRpropDWPlus() const = 0; 
# 1479
virtual void setRpropDWPlus(double val) = 0; 
# 1484
virtual double getRpropDWMinus() const = 0; 
# 1486
virtual void setRpropDWMinus(double val) = 0; 
# 1491
virtual double getRpropDWMin() const = 0; 
# 1493
virtual void setRpropDWMin(double val) = 0; 
# 1498
virtual double getRpropDWMax() const = 0; 
# 1500
virtual void setRpropDWMax(double val) = 0; 
# 1503
enum ActivationFunctions { 
# 1505
IDENTITY, 
# 1511
SIGMOID_SYM, 
# 1513
GAUSSIAN
# 1514
}; 
# 1517
enum TrainFlags { 
# 1520
UPDATE_WEIGHTS = 1, 
# 1526
NO_INPUT_SCALE, 
# 1530
NO_OUTPUT_SCALE = 4
# 1531
}; 
# 1533
virtual Mat getWeights(int layerIdx) const = 0; 
# 1540
static Ptr< ANN_MLP>  create(); 
# 1549 "/usr/include/opencv2/ml.hpp" 3
static Ptr< ANN_MLP>  load(const String & filepath); 
# 1551
}; 
# 1561 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) LogisticRegression : public StatModel { 
# 1567
public: virtual double getLearningRate() const = 0; 
# 1569
virtual void setLearningRate(double val) = 0; 
# 1573
virtual int getIterations() const = 0; 
# 1575
virtual void setIterations(int val) = 0; 
# 1579
virtual int getRegularization() const = 0; 
# 1581
virtual void setRegularization(int val) = 0; 
# 1585
virtual int getTrainMethod() const = 0; 
# 1587
virtual void setTrainMethod(int val) = 0; 
# 1593
virtual int getMiniBatchSize() const = 0; 
# 1595
virtual void setMiniBatchSize(int val) = 0; 
# 1599
virtual TermCriteria getTermCriteria() const = 0; 
# 1601
virtual void setTermCriteria(TermCriteria val) = 0; 
# 1604
enum RegKinds { 
# 1605
REG_DISABLE = (-1), 
# 1606
REG_L1 = 0, 
# 1607
REG_L2
# 1608
}; 
# 1611
enum Methods { 
# 1612
BATCH, 
# 1613
MINI_BATCH
# 1614
}; 
# 1623 "/usr/include/opencv2/ml.hpp" 3
virtual float predict(InputArray samples, OutputArray results = noArray(), int flags = 0) const = 0; 
# 1630
virtual Mat get_learnt_thetas() const = 0; 
# 1636
static Ptr< LogisticRegression>  create(); 
# 1647 "/usr/include/opencv2/ml.hpp" 3
static Ptr< LogisticRegression>  load(const String & filepath, const String & nodeName = String()); 
# 1648
}; 
# 1728 "/usr/include/opencv2/ml.hpp" 3
class __attribute((visibility("default"))) SVMSGD : public StatModel { 
# 1734
public: enum SvmsgdType { 
# 1736
SGD, 
# 1737
ASGD
# 1738
}; 
# 1741
enum MarginType { 
# 1743
SOFT_MARGIN, 
# 1744
HARD_MARGIN
# 1745
}; 
# 1750
virtual Mat getWeights() = 0; 
# 1755
virtual float getShift() = 0; 
# 1761
static Ptr< SVMSGD>  create(); 
# 1772 "/usr/include/opencv2/ml.hpp" 3
static Ptr< SVMSGD>  load(const String & filepath, const String & nodeName = String()); 
# 1778
virtual void setOptimalParameters(int svmsgdType = SVMSGD::ASGD, int marginType = SVMSGD::SOFT_MARGIN) = 0; 
# 1782
virtual int getSvmsgdType() const = 0; 
# 1784
virtual void setSvmsgdType(int svmsgdType) = 0; 
# 1788
virtual int getMarginType() const = 0; 
# 1790
virtual void setMarginType(int marginType) = 0; 
# 1794
virtual float getMarginRegularization() const = 0; 
# 1796
virtual void setMarginRegularization(float marginRegularization) = 0; 
# 1800
virtual float getInitialStepSize() const = 0; 
# 1802
virtual void setInitialStepSize(float InitialStepSize) = 0; 
# 1806
virtual float getStepDecreasingPower() const = 0; 
# 1808
virtual void setStepDecreasingPower(float stepDecreasingPower) = 0; 
# 1814
virtual TermCriteria getTermCriteria() const = 0; 
# 1816
virtual void setTermCriteria(const TermCriteria & val) = 0; 
# 1817
}; 
# 1831 "/usr/include/opencv2/ml.hpp" 3
__attribute((visibility("default"))) void randMVNormal(InputArray mean, InputArray cov, int nsamples, OutputArray samples); 
# 1834
__attribute((visibility("default"))) void createConcentricSpheresTestSet(int nsamples, int nfeatures, int nclasses, OutputArray samples, OutputArray responses); 
# 1839
}
# 1840
}
# 109 "/usr/include/opencv2/objdetect.hpp" 3
typedef struct CvHaarClassifierCascade CvHaarClassifierCascade; 
# 111
namespace cv { 
# 121 "/usr/include/opencv2/objdetect.hpp" 3
class __attribute((visibility("default"))) SimilarRects { 
# 124
public: SimilarRects(double _eps) : eps(_eps) { } 
# 125
bool operator()(const Rect &r1, const Rect &r2) const 
# 126
{ 
# 127
double delta = ((eps) * ((std::min)(r1.width, r2.width) + (std::min)(r1.height, r2.height))) * (0.5); 
# 128
return ((std::abs((r1.x) - (r2.x))) <= delta) && ((std::abs((r1.y) - (r2.y))) <= delta) && ((std::abs((((r1.x) + (r1.width)) - (r2.x)) - (r2.width))) <= delta) && ((std::abs((((r1.y) + (r1.height)) - (r2.y)) - (r2.height))) <= delta); 
# 132
} 
# 133
double eps; 
# 134
}; 
# 151 "/usr/include/opencv2/objdetect.hpp" 3
__attribute((visibility("default"))) void groupRectangles(std::vector< Rect_< int> >  & rectList, int groupThreshold, double eps = (0.2000000000000000111)); 
# 153
__attribute((visibility("default"))) void groupRectangles(std::vector< Rect_< int> >  & rectList, std::vector< int>  & weights, int groupThreshold, double eps = (0.2000000000000000111)); 
# 156
__attribute((visibility("default"))) void groupRectangles(std::vector< Rect_< int> >  & rectList, int groupThreshold, double eps, std::vector< int>  * weights, std::vector< double>  * levelWeights); 
# 159
__attribute((visibility("default"))) void groupRectangles(std::vector< Rect_< int> >  & rectList, std::vector< int>  & rejectLevels, std::vector< double>  & levelWeights, int groupThreshold, double eps = (0.2000000000000000111)); 
# 162
__attribute((visibility("default"))) void groupRectangles_meanshift(std::vector< Rect_< int> >  & rectList, std::vector< double>  & foundWeights, std::vector< double>  & foundScales, double detectThreshold = (0.0), Size winDetSize = Size(64, 128)); 
# 166
template<> __attribute((visibility("default"))) void DefaultDeleter< CvHaarClassifierCascade> ::operator()(CvHaarClassifierCascade * obj) const; 
# 168
enum { CASCADE_DO_CANNY_PRUNING = 1, 
# 169
CASCADE_SCALE_IMAGE, 
# 170
CASCADE_FIND_BIGGEST_OBJECT = 4, 
# 171
CASCADE_DO_ROUGH_SEARCH = 8
# 172
}; 
# 174
class __attribute((visibility("default"))) BaseCascadeClassifier : public Algorithm { 
# 177
public: virtual ~BaseCascadeClassifier(); 
# 178
virtual bool empty() const = 0; 
# 179
virtual bool load(const String & filename) = 0; 
# 180
virtual void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize) = 0; 
# 186
virtual void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, std::vector< int>  & numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize) = 0; 
# 193
virtual void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, std::vector< int>  & rejectLevels, std::vector< double>  & levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize, bool outputRejectLevels) = 0; 
# 202
virtual bool isOldFormatCascade() const = 0; 
# 203
virtual Size getOriginalWindowSize() const = 0; 
# 204
virtual int getFeatureType() const = 0; 
# 205
virtual void *getOldCascade() = 0; 
# 207
class __attribute((visibility("default"))) MaskGenerator { 
# 210
public: virtual ~MaskGenerator() { } 
# 211
virtual Mat generateMask(const Mat & src) = 0; 
# 212
virtual void initializeMask(const Mat &) { } 
# 213
}; 
# 214
virtual void setMaskGenerator(const Ptr< MaskGenerator>  & maskGenerator) = 0; 
# 215
virtual Ptr< MaskGenerator>  getMaskGenerator() = 0; 
# 216
}; 
# 224
class __attribute((visibility("default"))) CascadeClassifier { 
# 227
public: CascadeClassifier(); 
# 232
CascadeClassifier(const String & filename); 
# 233
~CascadeClassifier(); 
# 236
bool empty() const; 
# 243
bool load(const String & filename); 
# 248
bool read(const FileNode & node); 
# 270 "/usr/include/opencv2/objdetect.hpp" 3
void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, double scaleFactor = (1.100000000000000089), int minNeighbors = 3, int flags = 0, Size minSize = Size(), Size maxSize = Size()); 
# 292 "/usr/include/opencv2/objdetect.hpp" 3
void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, std::vector< int>  & numDetections, double scaleFactor = (1.100000000000000089), int minNeighbors = 3, int flags = 0, Size minSize = Size(), Size maxSize = Size()); 
# 317 "/usr/include/opencv2/objdetect.hpp" 3
void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, std::vector< int>  & rejectLevels, std::vector< double>  & levelWeights, double scaleFactor = (1.100000000000000089), int minNeighbors = 3, int flags = 0, Size minSize = Size(), Size maxSize = Size(), bool outputRejectLevels = false); 
# 327
bool isOldFormatCascade() const; 
# 328
Size getOriginalWindowSize() const; 
# 329
int getFeatureType() const; 
# 330
void *getOldCascade(); 
# 332
static bool convert(const String & oldcascade, const String & newcascade); 
# 334
void setMaskGenerator(const Ptr< BaseCascadeClassifier::MaskGenerator>  & maskGenerator); 
# 335
Ptr< BaseCascadeClassifier::MaskGenerator>  getMaskGenerator(); 
# 337
Ptr< BaseCascadeClassifier>  cc; 
# 338
}; 
# 340
__attribute((visibility("default"))) Ptr< BaseCascadeClassifier::MaskGenerator>  createFaceDetectionMaskGenerator(); 
# 345
struct DetectionROI { 
# 348
double scale; 
# 350
std::vector< Point_< int> >  locations; 
# 352
std::vector< double>  confidences; 
# 353
}; 
# 372 "/usr/include/opencv2/objdetect.hpp" 3
struct __attribute((visibility("default"))) HOGDescriptor { 
# 375
enum { L2Hys
# 376
}; 
# 377
enum { DEFAULT_NLEVELS = 64
# 378
}; 
# 383
HOGDescriptor() : winSize(64, 128), blockSize(16, 16), blockStride(8, 8), cellSize(8, 8), nbins(9), derivAperture(1), winSigma((-1)), histogramNormType((HOGDescriptor::L2Hys)), L2HysThreshold((0.2000000000000000111)), gammaCorrection(true), free_coef((-(1.0F))), nlevels((HOGDescriptor::DEFAULT_NLEVELS)), signedGradient(false) 
# 387
{ } 
# 403 "/usr/include/opencv2/objdetect.hpp" 3
HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size 
# 404
_cellSize, int _nbins, int _derivAperture = 1, double _winSigma = -1, int 
# 405
_histogramNormType = HOGDescriptor::L2Hys, double 
# 406
_L2HysThreshold = (0.2000000000000000111), bool _gammaCorrection = false, int 
# 407
_nlevels = HOGDescriptor::DEFAULT_NLEVELS, bool _signedGradient = false) : winSize(_winSize), blockSize(_blockSize), blockStride(_blockStride), cellSize(_cellSize), nbins(_nbins), derivAperture(_derivAperture), winSigma(_winSigma), histogramNormType(_histogramNormType), L2HysThreshold(_L2HysThreshold), gammaCorrection(_gammaCorrection), free_coef((-(1.0F))), nlevels(_nlevels), signedGradient(_signedGradient) 
# 412
{ } 
# 417
HOGDescriptor(const String &filename) 
# 418
{ 
# 419
this->load(filename); 
# 420
} 
# 425
HOGDescriptor(const HOGDescriptor &d) 
# 426
{ 
# 427
d.copyTo(*this); 
# 428
} 
# 432
virtual ~HOGDescriptor() { } 
# 436
size_t getDescriptorSize() const; 
# 440
bool checkDetectorSize() const; 
# 444
double getWinSigma() const; 
# 451
virtual void setSVMDetector(InputArray _svmdetector); 
# 456
virtual bool read(FileNode & fn); 
# 462
virtual void write(FileStorage & fs, const String & objname) const; 
# 468
virtual bool load(const String & filename, const String & objname = String()); 
# 474
virtual void save(const String & filename, const String & objname = String()) const; 
# 479
virtual void copyTo(HOGDescriptor & c) const; 
# 490 "/usr/include/opencv2/objdetect.hpp" 3
virtual void compute(InputArray img, std::vector< float>  & descriptors, Size winStride = Size(), Size padding = Size(), const std::vector< Point_< int> >  & locations = std::vector< Point_< int> > ()) const; 
# 506 "/usr/include/opencv2/objdetect.hpp" 3
virtual void detect(const Mat & img, std::vector< Point_< int> >  & foundLocations, std::vector< double>  & weights, double hitThreshold = 0, Size winStride = Size(), Size padding = Size(), const std::vector< Point_< int> >  & searchLocations = std::vector< Point_< int> > ()) const; 
# 522 "/usr/include/opencv2/objdetect.hpp" 3
virtual void detect(const Mat & img, std::vector< Point_< int> >  & foundLocations, double hitThreshold = 0, Size winStride = Size(), Size padding = Size(), const std::vector< Point_< int> >  & searchLocations = std::vector< Point_< int> > ()) const; 
# 541 "/usr/include/opencv2/objdetect.hpp" 3
virtual void detectMultiScale(InputArray img, std::vector< Rect_< int> >  & foundLocations, std::vector< double>  & foundWeights, double hitThreshold = 0, Size winStride = Size(), Size padding = Size(), double scale = (1.050000000000000044), double finalThreshold = (2.0), bool useMeanshiftGrouping = false) const; 
# 559 "/usr/include/opencv2/objdetect.hpp" 3
virtual void detectMultiScale(InputArray img, std::vector< Rect_< int> >  & foundLocations, double hitThreshold = 0, Size winStride = Size(), Size padding = Size(), double scale = (1.050000000000000044), double finalThreshold = (2.0), bool useMeanshiftGrouping = false) const; 
# 571 "/usr/include/opencv2/objdetect.hpp" 3
virtual void computeGradient(const Mat & img, Mat & grad, Mat & angleOfs, Size paddingTL = Size(), Size paddingBR = Size()) const; 
# 576
static std::vector< float>  getDefaultPeopleDetector(); 
# 582
static std::vector< float>  getDaimlerPeopleDetector(); 
# 585
Size winSize; 
# 588
Size blockSize; 
# 591
Size blockStride; 
# 594
Size cellSize; 
# 597
int nbins; 
# 600
int derivAperture; 
# 603
double winSigma; 
# 606
int histogramNormType; 
# 609
double L2HysThreshold; 
# 612
bool gammaCorrection; 
# 615
std::vector< float>  svmDetector; 
# 618
UMat oclSvmDetector; 
# 621
float free_coef; 
# 624
int nlevels; 
# 627
bool signedGradient; 
# 640 "/usr/include/opencv2/objdetect.hpp" 3
virtual void detectROI(const Mat & img, const std::vector< Point_< int> >  & locations, std::vector< Point_< int> >  & foundLocations, std::vector< double>  & confidences, double hitThreshold = 0, Size winStride = Size(), Size padding = Size()) const; 
# 653 "/usr/include/opencv2/objdetect.hpp" 3
virtual void detectMultiScaleROI(const Mat & img, std::vector< Rect_< int> >  & foundLocations, std::vector< DetectionROI>  & locations, double hitThreshold = 0, int groupThreshold = 0) const; 
# 662
void readALTModel(String modelfile); 
# 670
void groupRectangles(std::vector< Rect_< int> >  & rectList, std::vector< double>  & weights, int groupThreshold, double eps) const; 
# 671
}; 
# 675
}
# 55 "/usr/include/opencv2/objdetect/detection_based_tracker.hpp" 3
namespace cv { 
# 61
class __attribute((visibility("default"))) DetectionBasedTracker { 
# 64
public: struct __attribute((visibility("default"))) Parameters { 
# 66
int maxTrackLifetime; 
# 67
int minDetectionPeriod; 
# 69
Parameters(); 
# 70
}; 
# 72
class IDetector { 
# 75
public: IDetector() : minObjSize(96, 96), maxObjSize(2147483647, 2147483647), minNeighbours(2), scaleFactor((1.100000024F)) 
# 80
{ } 
# 82
virtual void detect(const Mat & image, std::vector< Rect_< int> >  & objects) = 0; 
# 84
void setMinObjectSize(const Size &min) 
# 85
{ 
# 86
((minObjSize) = min); 
# 87
} 
# 88
void setMaxObjectSize(const Size &max) 
# 89
{ 
# 90
((maxObjSize) = max); 
# 91
} 
# 92
Size getMinObjectSize() const 
# 93
{ 
# 94
return minObjSize; 
# 95
} 
# 96
Size getMaxObjectSize() const 
# 97
{ 
# 98
return maxObjSize; 
# 99
} 
# 100
float getScaleFactor() 
# 101
{ 
# 102
return scaleFactor; 
# 103
} 
# 104
void setScaleFactor(float value) 
# 105
{ 
# 106
(scaleFactor) = value; 
# 107
} 
# 108
int getMinNeighbours() 
# 109
{ 
# 110
return minNeighbours; 
# 111
} 
# 112
void setMinNeighbours(int value) 
# 113
{ 
# 114
(minNeighbours) = value; 
# 115
} 
# 116
virtual ~IDetector() { } 
# 119
protected: Size minObjSize; 
# 120
Size maxObjSize; 
# 121
int minNeighbours; 
# 122
float scaleFactor; 
# 123
}; 
# 125
DetectionBasedTracker(Ptr< IDetector>  mainDetector, Ptr< IDetector>  trackingDetector, const Parameters & params); 
# 126
virtual ~DetectionBasedTracker(); 
# 128
virtual bool run(); 
# 129
virtual void stop(); 
# 130
virtual void resetTracking(); 
# 132
virtual void process(const Mat & imageGray); 
# 134
bool setParameters(const Parameters & params); 
# 135
const Parameters &getParameters() const; 
# 138
typedef std::pair< Rect_< int> , int>  Object; 
# 139
virtual void getObjects(std::vector< Rect_< int> >  & result) const; 
# 140
virtual void getObjects(std::vector< std::pair< Rect_< int> , int> >  & result) const; 
# 142
enum ObjectStatus { 
# 144
DETECTED_NOT_SHOWN_YET, 
# 145
DETECTED, 
# 146
DETECTED_TEMPORARY_LOST, 
# 147
WRONG_OBJECT
# 148
}; 
# 149
struct ExtObject { 
# 151
int id; 
# 152
Rect location; 
# 153
ObjectStatus status; 
# 154
ExtObject(int _id, Rect _location, ObjectStatus _status) : id(_id), location(_location), status(_status) 
# 156
{ 
# 157
} 
# 158
}; 
# 159
virtual void getObjects(std::vector< ExtObject>  & result) const; 
# 162
virtual int addObject(const Rect & location); 
# 165
protected: class SeparateDetectionWork; 
# 166
Ptr< SeparateDetectionWork>  separateDetectionWork; 
# 167
friend void *workcycleObjectDetectorFunction(void * p); 
# 169
struct InnerParameters { 
# 171
int numLastPositionsToTrack; 
# 172
int numStepsToWaitBeforeFirstShow; 
# 173
int numStepsToTrackWithoutDetectingIfObjectHasNotBeenShown; 
# 174
int numStepsToShowWithoutDetecting; 
# 176
float coeffTrackingWindowSize; 
# 177
float coeffObjectSizeToTrack; 
# 178
float coeffObjectSpeedUsingInPrediction; 
# 180
InnerParameters(); 
# 181
}; 
# 182
Parameters parameters; 
# 183
InnerParameters innerParameters; 
# 185
struct TrackedObject { 
# 187
typedef std::vector< Rect_< int> >  PositionsVector; 
# 189
PositionsVector lastPositions; 
# 191
int numDetectedFrames; 
# 192
int numFramesNotDetected; 
# 193
int id; 
# 195
TrackedObject(const Rect &rect) : numDetectedFrames(1), numFramesNotDetected(0) 
# 196
{ 
# 197
(lastPositions).push_back(rect); 
# 198
(id) = getNextId(); 
# 199
} 
# 201
static int getNextId() 
# 202
{ 
# 203
static int _id = 0; 
# 204
return _id++; 
# 205
} 
# 206
}; 
# 208
int numTrackedSteps; 
# 209
std::vector< TrackedObject>  trackedObjects; 
# 211
std::vector< float>  weightsPositionsSmoothing; 
# 212
std::vector< float>  weightsSizesSmoothing; 
# 214
Ptr< IDetector>  cascadeForTracking; 
# 216
void updateTrackedObjects(const std::vector< Rect_< int> >  & detectedObjects); 
# 217
Rect calcTrackedObjectPositionToShow(int i) const; 
# 218
Rect calcTrackedObjectPositionToShow(int i, ObjectStatus & status) const; 
# 219
void detectInRegion(const Mat & img, const Rect & r, std::vector< Rect_< int> >  & detectedObjectsInRegions); 
# 220
}; 
# 224
}
# 66 "/usr/include/c++/5/bits/stl_deque.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 89 "/usr/include/c++/5/bits/stl_deque.h" 3
constexpr size_t __deque_buf_size(size_t __size) 
# 90
{ return (__size < (512)) ? (size_t)((512) / __size) : ((size_t)1); 
# 91
} 
# 105 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _Tp, class _Ref, class _Ptr> 
# 106
struct _Deque_iterator { 
# 116
private: 
# 115
template< class _Up> using __ptr_to = typename pointer_traits< _Ptr> ::template rebind< _Up> ; 
# 117
template< class _CvTp> using __iter = std::_Deque_iterator< _Tp, _CvTp &, __ptr_to< _CvTp> > ; 
# 120
public: typedef __iter< _Tp>  iterator; 
# 121
typedef __iter< const _Tp>  const_iterator; 
# 122
typedef __ptr_to< _Tp>  _Elt_pointer; 
# 123
typedef __ptr_to< __ptr_to< _Tp> >  _Map_pointer; 
# 126
static size_t _S_buffer_size() noexcept 
# 127
{ return __deque_buf_size(sizeof(_Tp)); } 
# 129
typedef random_access_iterator_tag iterator_category; 
# 130
typedef _Tp value_type; 
# 131
typedef _Ptr pointer; 
# 132
typedef _Ref reference; 
# 133
typedef size_t size_type; 
# 134
typedef ptrdiff_t difference_type; 
# 135
typedef _Deque_iterator _Self; 
# 137
_Elt_pointer _M_cur; 
# 138
_Elt_pointer _M_first; 
# 139
_Elt_pointer _M_last; 
# 140
_Map_pointer _M_node; 
# 142
_Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept : _M_cur(__x), _M_first(*__y), _M_last((*__y) + (_S_buffer_size)()), _M_node(__y) 
# 144
{ } 
# 146
_Deque_iterator() noexcept : _M_cur(), _M_first(), _M_last(), _M_node() 
# 147
{ } 
# 149
_Deque_iterator(const iterator &__x) noexcept : _M_cur((__x._M_cur)), _M_first((__x._M_first)), _M_last((__x._M_last)), _M_node((__x._M_node)) 
# 151
{ } 
# 154
iterator _M_const_cast() const noexcept 
# 155
{ return iterator(_M_cur, _M_node); } 
# 158
reference operator*() const noexcept 
# 159
{ return *(_M_cur); } 
# 162
pointer operator->() const noexcept 
# 163
{ return _M_cur; } 
# 166
_Self &operator++() noexcept 
# 167
{ 
# 168
++(_M_cur); 
# 169
if ((_M_cur) == (_M_last)) 
# 170
{ 
# 171
_M_set_node((_M_node) + 1); 
# 172
(_M_cur) = (_M_first); 
# 173
}  
# 174
return *this; 
# 175
} 
# 178
_Self operator++(int) noexcept 
# 179
{ 
# 180
_Self __tmp = *this; 
# 181
++(*this); 
# 182
return __tmp; 
# 183
} 
# 186
_Self &operator--() noexcept 
# 187
{ 
# 188
if ((_M_cur) == (_M_first)) 
# 189
{ 
# 190
_M_set_node((_M_node) - 1); 
# 191
(_M_cur) = (_M_last); 
# 192
}  
# 193
--(_M_cur); 
# 194
return *this; 
# 195
} 
# 198
_Self operator--(int) noexcept 
# 199
{ 
# 200
_Self __tmp = *this; 
# 201
--(*this); 
# 202
return __tmp; 
# 203
} 
# 206
_Self &operator+=(difference_type __n) noexcept 
# 207
{ 
# 208
const difference_type __offset = __n + ((_M_cur) - (_M_first)); 
# 209
if ((__offset >= (0)) && (__offset < ((difference_type)(_S_buffer_size)()))) { 
# 210
(_M_cur) += __n; } else 
# 212
{ 
# 213
const difference_type __node_offset = (__offset > (0)) ? __offset / ((difference_type)(_S_buffer_size)()) : ((-((difference_type)(((-__offset) - (1)) / (_S_buffer_size)()))) - (1)); 
# 217
_M_set_node((_M_node) + __node_offset); 
# 218
(_M_cur) = ((_M_first) + (__offset - (__node_offset * ((difference_type)(_S_buffer_size)())))); 
# 220
}  
# 221
return *this; 
# 222
} 
# 225
_Self operator+(difference_type __n) const noexcept 
# 226
{ 
# 227
_Self __tmp = *this; 
# 228
return __tmp += __n; 
# 229
} 
# 232
_Self &operator-=(difference_type __n) noexcept 
# 233
{ return (*this) += (-__n); } 
# 236
_Self operator-(difference_type __n) const noexcept 
# 237
{ 
# 238
_Self __tmp = *this; 
# 239
return __tmp -= __n; 
# 240
} 
# 243
reference operator[](difference_type __n) const noexcept 
# 244
{ return *((*this) + __n); } 
# 252
void _M_set_node(_Map_pointer __new_node) noexcept 
# 253
{ 
# 254
(_M_node) = __new_node; 
# 255
(_M_first) = (*__new_node); 
# 256
(_M_last) = ((_M_first) + ((difference_type)(_S_buffer_size)())); 
# 257
} 
# 258
}; 
# 263
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 265
operator==(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 266
__y) noexcept 
# 267
{ return (__x._M_cur) == (__y._M_cur); } 
# 269
template< class _Tp, class _RefL, class _PtrL, class 
# 270
_RefR, class _PtrR> inline bool 
# 272
operator==(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 273
__y) noexcept 
# 274
{ return (__x._M_cur) == (__y._M_cur); } 
# 276
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 278
operator!=(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 279
__y) noexcept 
# 280
{ return !(__x == __y); } 
# 282
template< class _Tp, class _RefL, class _PtrL, class 
# 283
_RefR, class _PtrR> inline bool 
# 285
operator!=(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 286
__y) noexcept 
# 287
{ return !(__x == __y); } 
# 289
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 291
operator<(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 292
__y) noexcept 
# 293
{ return ((__x._M_node) == (__y._M_node)) ? (__x._M_cur) < (__y._M_cur) : ((__x._M_node) < (__y._M_node)); 
# 294
} 
# 296
template< class _Tp, class _RefL, class _PtrL, class 
# 297
_RefR, class _PtrR> inline bool 
# 299
operator<(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 300
__y) noexcept 
# 301
{ return ((__x._M_node) == (__y._M_node)) ? (__x._M_cur) < (__y._M_cur) : ((__x._M_node) < (__y._M_node)); 
# 302
} 
# 304
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 306
operator>(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 307
__y) noexcept 
# 308
{ return __y < __x; } 
# 310
template< class _Tp, class _RefL, class _PtrL, class 
# 311
_RefR, class _PtrR> inline bool 
# 313
operator>(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 314
__y) noexcept 
# 315
{ return __y < __x; } 
# 317
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 319
operator<=(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 320
__y) noexcept 
# 321
{ return !(__y < __x); } 
# 323
template< class _Tp, class _RefL, class _PtrL, class 
# 324
_RefR, class _PtrR> inline bool 
# 326
operator<=(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 327
__y) noexcept 
# 328
{ return !(__y < __x); } 
# 330
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 332
operator>=(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 333
__y) noexcept 
# 334
{ return !(__x < __y); } 
# 336
template< class _Tp, class _RefL, class _PtrL, class 
# 337
_RefR, class _PtrR> inline bool 
# 339
operator>=(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 340
__y) noexcept 
# 341
{ return !(__x < __y); } 
# 347
template< class _Tp, class _Ref, class _Ptr> inline typename _Deque_iterator< _Tp, _Ref, _Ptr> ::difference_type 
# 349
operator-(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 350
__y) noexcept 
# 351
{ 
# 352
return ((((typename _Deque_iterator< _Tp, _Ref, _Ptr> ::difference_type)_Deque_iterator< _Tp, _Ref, _Ptr> ::_S_buffer_size()) * (((__x._M_node) - (__y._M_node)) - 1)) + ((__x._M_cur) - (__x._M_first))) + ((__y._M_last) - (__y._M_cur)); 
# 356
} 
# 358
template< class _Tp, class _RefL, class _PtrL, class 
# 359
_RefR, class _PtrR> inline typename _Deque_iterator< _Tp, _RefL, _PtrL> ::difference_type 
# 361
operator-(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 362
__y) noexcept 
# 363
{ 
# 364
return ((((typename _Deque_iterator< _Tp, _RefL, _PtrL> ::difference_type)_Deque_iterator< _Tp, _RefL, _PtrL> ::_S_buffer_size()) * (((__x._M_node) - (__y._M_node)) - 1)) + ((__x._M_cur) - (__x._M_first))) + ((__y._M_last) - (__y._M_cur)); 
# 368
} 
# 370
template< class _Tp, class _Ref, class _Ptr> inline _Deque_iterator< _Tp, _Ref, _Ptr>  
# 372
operator+(ptrdiff_t __n, const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x) noexcept 
# 374
{ return __x + __n; } 
# 376
template< class _Tp> void fill(const _Deque_iterator< _Tp, _Tp &, _Tp *>  &, const _Deque_iterator< _Tp, _Tp &, _Tp *>  &, const _Tp &); 
# 381
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  copy(_Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, _Tp &, _Tp *> ); 
# 387
template< class _Tp> inline _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 389
copy(_Deque_iterator< _Tp, _Tp &, _Tp *>  __first, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 390
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 391
__result) 
# 392
{ return std::copy(((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__first)), ((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__last)), __result); 
# 394
} 
# 396
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  copy_backward(_Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, _Tp &, _Tp *> ); 
# 402
template< class _Tp> inline _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 404
copy_backward(_Deque_iterator< _Tp, _Tp &, _Tp *>  __first, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 405
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 406
__result) 
# 407
{ return std::copy_backward(((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__first)), ((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__last)), __result); 
# 411
} 
# 414
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  move(_Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, _Tp &, _Tp *> ); 
# 420
template< class _Tp> inline _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 422
move(_Deque_iterator< _Tp, _Tp &, _Tp *>  __first, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 423
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 424
__result) 
# 425
{ return std::move(((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__first)), ((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__last)), __result); 
# 427
} 
# 429
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  move_backward(_Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, _Tp &, _Tp *> ); 
# 435
template< class _Tp> inline _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 437
move_backward(_Deque_iterator< _Tp, _Tp &, _Tp *>  __first, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 438
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 439
__result) 
# 440
{ return std::move_backward(((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__first)), ((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__last)), __result); 
# 444
} 
# 457 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _Tp, class _Alloc> 
# 458
class _Deque_base { 
# 462
protected: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other _Tp_alloc_type; 
# 463
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other>  _Alloc_traits; 
# 469
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::pointer _Ptr; 
# 470
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::const_pointer _Ptr_const; 
# 474
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::template rebind< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::pointer> ::other _Map_alloc_type; 
# 475
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::template rebind< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::pointer> ::other>  _Map_alloc_traits; 
# 478
public: typedef _Alloc allocator_type; 
# 479
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::size_type size_type; 
# 482
allocator_type get_allocator() const noexcept 
# 483
{ return (allocator_type)this->_M_get_Tp_allocator(); } 
# 485
typedef _Deque_iterator< _Tp, _Tp &, typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::pointer>  iterator; 
# 486
typedef _Deque_iterator< _Tp, const _Tp &, typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::const_pointer>  const_iterator; 
# 488
_Deque_base() : _M_impl() 
# 490
{ _M_initialize_map(0); } 
# 492
_Deque_base(size_t __num_elements) : _M_impl() 
# 494
{ _M_initialize_map(__num_elements); } 
# 496
_Deque_base(const allocator_type &__a, size_t __num_elements) : _M_impl(__a) 
# 498
{ _M_initialize_map(__num_elements); } 
# 500
_Deque_base(const allocator_type &__a) : _M_impl(__a) 
# 502
{ } 
# 505
_Deque_base(_Deque_base &&__x, false_type) : _M_impl((__x._M_move_impl())) 
# 507
{ } 
# 509
_Deque_base(_Deque_base &&__x, true_type) : _M_impl(std::move((__x._M_get_Tp_allocator()))) 
# 511
{ 
# 512
_M_initialize_map(0); 
# 513
if ((__x._M_impl)._M_map) { 
# 514
((this->_M_impl)._M_swap_data((__x._M_impl))); }  
# 515
} 
# 517
_Deque_base(_Deque_base &&__x) : _Deque_base(std::move(__x), __gnu_cxx::__allocator_always_compares_equal< _Alloc> {}) 
# 520
{ } 
# 522
_Deque_base(_Deque_base &&__x, const allocator_type &__a, size_type __n) : _M_impl(__a) 
# 524
{ 
# 525
if ((__x.get_allocator()) == __a) 
# 526
{ 
# 527
if ((__x._M_impl)._M_map) 
# 528
{ 
# 529
_M_initialize_map(0); 
# 530
((this->_M_impl)._M_swap_data((__x._M_impl))); 
# 531
}  
# 532
} else 
# 534
{ 
# 535
_M_initialize_map(__n); 
# 536
}  
# 537
} 
# 540
~_Deque_base() noexcept; 
# 543
protected: typedef typename _Deque_iterator< _Tp, _Tp &, typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::pointer> ::_Map_pointer _Map_pointer; 
# 548
struct _Deque_impl : public _Tp_alloc_type { 
# 551
typename ::std::_Deque_base< _Tp, _Alloc> ::_Map_pointer _M_map; 
# 552
::std::size_t _M_map_size; 
# 553
typename ::std::_Deque_base< _Tp, _Alloc> ::iterator _M_start; 
# 554
typename ::std::_Deque_base< _Tp, _Alloc> ::iterator _M_finish; 
# 556
_Deque_impl() : ::std::_Deque_base< _Tp, _Alloc> ::_Tp_alloc_type(), _M_map(), _M_map_size((0)), _M_start(), _M_finish() 
# 559
{ } 
# 561
_Deque_impl(const typename ::std::_Deque_base< _Tp, _Alloc> ::_Tp_alloc_type &__a) noexcept : ::std::_Deque_base< _Tp, _Alloc> ::_Tp_alloc_type(__a), _M_map(), _M_map_size((0)), _M_start(), _M_finish() 
# 564
{ } 
# 567
_Deque_impl(_Deque_impl &&) = default;
# 569
_Deque_impl(typename ::std::_Deque_base< _Tp, _Alloc> ::_Tp_alloc_type &&__a) noexcept : ::std::_Deque_base< _Tp, _Alloc> ::_Tp_alloc_type(::std::move(__a)), _M_map(), _M_map_size((0)), _M_start(), _M_finish() 
# 572
{ } 
# 575
void _M_swap_data(_Deque_impl &__x) noexcept 
# 576
{ 
# 577
using ::std::swap;
# 578
swap(this->_M_start, (__x._M_start)); 
# 579
swap(this->_M_finish, (__x._M_finish)); 
# 580
swap(this->_M_map, (__x._M_map)); 
# 581
swap(this->_M_map_size, (__x._M_map_size)); 
# 582
} 
# 583
}; 
# 586
_Tp_alloc_type &_M_get_Tp_allocator() noexcept 
# 587
{ return *(static_cast< _Tp_alloc_type *>(&(this->_M_impl))); } 
# 590
const _Tp_alloc_type &_M_get_Tp_allocator() const noexcept 
# 591
{ return *(static_cast< const _Tp_alloc_type *>(&(this->_M_impl))); } 
# 594
_Map_alloc_type _M_get_map_allocator() const noexcept 
# 595
{ return (_Map_alloc_type)this->_M_get_Tp_allocator(); } 
# 598
_Ptr _M_allocate_node() 
# 599
{ 
# 600
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other>  _Traits; 
# 601
return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp))); 
# 602
} 
# 605
void _M_deallocate_node(_Ptr __p) noexcept 
# 606
{ 
# 607
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other>  _Traits; 
# 608
_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp))); 
# 609
} 
# 612
_Map_pointer _M_allocate_map(size_t __n) 
# 613
{ 
# 614
_Map_alloc_type __map_alloc = _M_get_map_allocator(); 
# 615
return _Map_alloc_traits::allocate(__map_alloc, __n); 
# 616
} 
# 619
void _M_deallocate_map(_Map_pointer __p, size_t __n) noexcept 
# 620
{ 
# 621
_Map_alloc_type __map_alloc = _M_get_map_allocator(); 
# 622
_Map_alloc_traits::deallocate(__map_alloc, __p, __n); 
# 623
} 
# 626
void _M_initialize_map(size_t); 
# 627
void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish); 
# 628
void _M_destroy_nodes(_Map_pointer __nstart, _Map_pointer __nfinish) noexcept; 
# 630
enum { _S_initial_map_size = 8}; 
# 632
_Deque_impl _M_impl; 
# 637
private: _Deque_impl _M_move_impl() 
# 638
{ 
# 639
if (!((_M_impl)._M_map)) { 
# 640
return std::move(_M_impl); }  
# 643
_Tp_alloc_type __alloc{this->_M_get_Tp_allocator()}; 
# 645
_Tp_alloc_type __sink __attribute((__unused__)){std::move(__alloc)}; 
# 647
_Deque_base __empty{__alloc}; 
# 648
(__empty._M_initialize_map(0)); 
# 650
_Deque_impl __ret{std::move(this->_M_get_Tp_allocator())}; 
# 651
((_M_impl)._M_swap_data(__ret)); 
# 652
((_M_impl)._M_swap_data((__empty._M_impl))); 
# 653
return __ret; 
# 654
} 
# 656
}; 
# 658
template< class _Tp, class _Alloc> 
# 660
_Deque_base< _Tp, _Alloc> ::~_Deque_base() noexcept 
# 661
{ 
# 662
if ((this->_M_impl)._M_map) 
# 663
{ 
# 664
_M_destroy_nodes((((this->_M_impl)._M_start)._M_node), (((this->_M_impl)._M_finish)._M_node) + 1); 
# 666
_M_deallocate_map(((this->_M_impl)._M_map), ((this->_M_impl)._M_map_size)); 
# 667
}  
# 668
} 
# 678 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _Tp, class _Alloc> void 
# 681
_Deque_base< _Tp, _Alloc> ::_M_initialize_map(size_t __num_elements) 
# 682
{ 
# 683
const size_t __num_nodes = (__num_elements / __deque_buf_size(sizeof(_Tp))) + (1); 
# 686
((this->_M_impl)._M_map_size) = std::max((size_t)(_S_initial_map_size), (size_t)(__num_nodes + (2))); 
# 688
((this->_M_impl)._M_map) = _M_allocate_map(((this->_M_impl)._M_map_size)); 
# 695
_Map_pointer __nstart = ((this->_M_impl)._M_map) + ((((this->_M_impl)._M_map_size) - __num_nodes) / 2); 
# 697
_Map_pointer __nfinish = __nstart + __num_nodes; 
# 699
try 
# 700
{ _M_create_nodes(__nstart, __nfinish); } 
# 701
catch (...) 
# 702
{ 
# 703
_M_deallocate_map(((this->_M_impl)._M_map), ((this->_M_impl)._M_map_size)); 
# 704
((this->_M_impl)._M_map) = _Map_pointer(); 
# 705
((this->_M_impl)._M_map_size) = 0; 
# 706
throw; 
# 707
}  
# 709
(((this->_M_impl)._M_start)._M_set_node(__nstart)); 
# 710
(((this->_M_impl)._M_finish)._M_set_node(__nfinish - 1)); 
# 711
(((this->_M_impl)._M_start)._M_cur) = (((_M_impl)._M_start)._M_first); 
# 712
(((this->_M_impl)._M_finish)._M_cur) = ((((this->_M_impl)._M_finish)._M_first) + (__num_elements % __deque_buf_size(sizeof(_Tp)))); 
# 715
} 
# 717
template< class _Tp, class _Alloc> void 
# 720
_Deque_base< _Tp, _Alloc> ::_M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish) 
# 721
{ 
# 722
_Map_pointer __cur; 
# 723
try 
# 724
{ 
# 725
for (__cur = __nstart; __cur < __nfinish; ++__cur) { 
# 726
(*__cur) = this->_M_allocate_node(); }  
# 727
} 
# 728
catch (...) 
# 729
{ 
# 730
_M_destroy_nodes(__nstart, __cur); 
# 731
throw; 
# 732
}  
# 733
} 
# 735
template< class _Tp, class _Alloc> void 
# 738
_Deque_base< _Tp, _Alloc> ::_M_destroy_nodes(_Map_pointer __nstart, _Map_pointer 
# 739
__nfinish) noexcept 
# 740
{ 
# 741
for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n) { 
# 742
_M_deallocate_node(*__n); }  
# 743
} 
# 829 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _Tp, class _Alloc = allocator< _Tp> > 
# 830
class deque : protected _Deque_base< _Tp, _Alloc>  { 
# 833
typedef typename _Alloc::value_type _Alloc_value_type; 
# 837
typedef ::std::_Deque_base< _Tp, _Alloc>  _Base; 
# 838
typedef typename ::std::_Deque_base< _Tp, _Alloc> ::_Tp_alloc_type _Tp_alloc_type; 
# 839
typedef typename ::std::_Deque_base< _Tp, _Alloc> ::_Alloc_traits _Alloc_traits; 
# 840
typedef typename ::std::_Deque_base< _Tp, _Alloc> ::_Map_pointer _Map_pointer; 
# 843
public: typedef _Tp value_type; 
# 844
typedef typename ::std::_Deque_base< _Tp, _Alloc> ::_Alloc_traits::pointer pointer; 
# 845
typedef typename ::std::_Deque_base< _Tp, _Alloc> ::_Alloc_traits::const_pointer const_pointer; 
# 846
typedef typename ::std::_Deque_base< _Tp, _Alloc> ::_Alloc_traits::reference reference; 
# 847
typedef typename ::std::_Deque_base< _Tp, _Alloc> ::_Alloc_traits::const_reference const_reference; 
# 848
typedef typename ::std::_Deque_base< _Tp, _Alloc> ::iterator iterator; 
# 849
typedef typename ::std::_Deque_base< _Tp, _Alloc> ::const_iterator const_iterator; 
# 850
typedef ::std::reverse_iterator< typename ::std::_Deque_base< _Tp, _Alloc> ::const_iterator>  const_reverse_iterator; 
# 851
typedef ::std::reverse_iterator< typename ::std::_Deque_base< _Tp, _Alloc> ::iterator>  reverse_iterator; 
# 852
typedef ::std::size_t size_type; 
# 853
typedef ::std::ptrdiff_t difference_type; 
# 854
typedef _Alloc allocator_type; 
# 857
protected: static ::std::size_t _S_buffer_size() noexcept 
# 858
{ return __deque_buf_size(sizeof(_Tp)); } 
# 861
using ::std::_Deque_base< _Tp, _Alloc> ::_M_initialize_map;
# 862
using ::std::_Deque_base< _Tp, _Alloc> ::_M_create_nodes;
# 863
using ::std::_Deque_base< _Tp, _Alloc> ::_M_destroy_nodes;
# 864
using ::std::_Deque_base< _Tp, _Alloc> ::_M_allocate_node;
# 865
using ::std::_Deque_base< _Tp, _Alloc> ::_M_deallocate_node;
# 866
using ::std::_Deque_base< _Tp, _Alloc> ::_M_allocate_map;
# 867
using ::std::_Deque_base< _Tp, _Alloc> ::_M_deallocate_map;
# 868
using ::std::_Deque_base< _Tp, _Alloc> ::_M_get_Tp_allocator;
# 874
using ::std::_Deque_base< _Tp, _Alloc> ::_M_impl;
# 883
public: deque() : _Base() { } 
# 890
explicit deque(const allocator_type &__a) : _Base(__a, 0) 
# 891
{ } 
# 902 "/usr/include/c++/5/bits/stl_deque.h" 3
explicit deque(size_type __n, const allocator_type &__a = allocator_type()) : _Base(__a, __n) 
# 904
{ _M_default_initialize(); } 
# 914 "/usr/include/c++/5/bits/stl_deque.h" 3
deque(size_type __n, const value_type &__value, const allocator_type &
# 915
__a = allocator_type()) : _Base(__a, __n) 
# 917
{ _M_fill_initialize(__value); } 
# 941 "/usr/include/c++/5/bits/stl_deque.h" 3
deque(const deque &__x) : _Base(_Alloc_traits::_S_select_on_copy((__x._M_get_Tp_allocator())), (__x.size())) 
# 944
{ ::std::__uninitialized_copy_a((__x.begin()), (__x.end()), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 946
} 
# 956 "/usr/include/c++/5/bits/stl_deque.h" 3
deque(deque &&__x) : _Base(::std::move(__x)) 
# 957
{ } 
# 960
deque(const deque &__x, const allocator_type &__a) : _Base(__a, (__x.size())) 
# 962
{ ::std::__uninitialized_copy_a((__x.begin()), (__x.end()), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 964
} 
# 967
deque(deque &&__x, const allocator_type &__a) : _Base(::std::move(__x), __a, (__x.size())) 
# 969
{ 
# 970
if ((__x.get_allocator()) != __a) 
# 971
{ 
# 972
::std::__uninitialized_move_a((__x.begin()), (__x.end()), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 975
(__x.clear()); 
# 976
}  
# 977
} 
# 990 "/usr/include/c++/5/bits/stl_deque.h" 3
deque(initializer_list< _Tp>  __l, const allocator_type &
# 991
__a = allocator_type()) : _Base(__a) 
# 993
{ 
# 994
_M_range_initialize((__l.begin()), (__l.end()), ::std::random_access_iterator_tag()); 
# 996
} 
# 1015 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _InputIterator, class 
# 1016
 = ::std::_RequireInputIter< _InputIterator> > 
# 1017
deque(_InputIterator __first, _InputIterator __last, const allocator_type &
# 1018
__a = allocator_type()) : _Base(__a) 
# 1020
{ _M_initialize_dispatch(__first, __last, ::std::__false_type()); } 
# 1038 "/usr/include/c++/5/bits/stl_deque.h" 3
~deque() 
# 1039
{ _M_destroy_data(this->begin(), this->end(), _M_get_Tp_allocator()); } 
# 1049 "/usr/include/c++/5/bits/stl_deque.h" 3
deque &operator=(const deque & __x); 
# 1061 "/usr/include/c++/5/bits/stl_deque.h" 3
deque &operator=(deque &&__x) noexcept(_Alloc_traits::_S_always_equal()) 
# 1062
{ 
# 1063
constexpr bool __always_equal = (_Alloc_traits::_S_always_equal()); 
# 1064
_M_move_assign1(::std::move(__x), integral_constant< bool, __always_equal> ()); 
# 1066
return *this; 
# 1067
} 
# 1081 "/usr/include/c++/5/bits/stl_deque.h" 3
deque &operator=(initializer_list< _Tp>  __l) 
# 1082
{ 
# 1083
(this->assign((__l.begin()), (__l.end()))); 
# 1084
return *this; 
# 1085
} 
# 1099 "/usr/include/c++/5/bits/stl_deque.h" 3
void assign(size_type __n, const value_type &__val) 
# 1100
{ _M_fill_assign(__n, __val); } 
# 1115 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _InputIterator, class 
# 1116
 = ::std::_RequireInputIter< _InputIterator> > void 
# 1118
assign(_InputIterator __first, _InputIterator __last) 
# 1119
{ _M_assign_dispatch(__first, __last, ::std::__false_type()); } 
# 1143 "/usr/include/c++/5/bits/stl_deque.h" 3
void assign(initializer_list< _Tp>  __l) 
# 1144
{ (this->assign((__l.begin()), (__l.end()))); } 
# 1149
allocator_type get_allocator() const noexcept 
# 1150
{ return _Base::get_allocator(); } 
# 1158
iterator begin() noexcept 
# 1159
{ return (this->_M_impl)._M_start; } 
# 1166
const_iterator begin() const noexcept 
# 1167
{ return (this->_M_impl)._M_start; } 
# 1175
iterator end() noexcept 
# 1176
{ return (this->_M_impl)._M_finish; } 
# 1184
const_iterator end() const noexcept 
# 1185
{ return (this->_M_impl)._M_finish; } 
# 1193
reverse_iterator rbegin() noexcept 
# 1194
{ return ((reverse_iterator)(((this->_M_impl)._M_finish))); } 
# 1202
const_reverse_iterator rbegin() const noexcept 
# 1203
{ return ((const_reverse_iterator)(((this->_M_impl)._M_finish))); } 
# 1211
reverse_iterator rend() noexcept 
# 1212
{ return ((reverse_iterator)(((this->_M_impl)._M_start))); } 
# 1220
const_reverse_iterator rend() const noexcept 
# 1221
{ return ((const_reverse_iterator)(((this->_M_impl)._M_start))); } 
# 1229
const_iterator cbegin() const noexcept 
# 1230
{ return (this->_M_impl)._M_start; } 
# 1238
const_iterator cend() const noexcept 
# 1239
{ return (this->_M_impl)._M_finish; } 
# 1247
const_reverse_iterator crbegin() const noexcept 
# 1248
{ return ((const_reverse_iterator)(((this->_M_impl)._M_finish))); } 
# 1256
const_reverse_iterator crend() const noexcept 
# 1257
{ return ((const_reverse_iterator)(((this->_M_impl)._M_start))); } 
# 1263
size_type size() const noexcept 
# 1264
{ return ((this->_M_impl)._M_finish) - ((this->_M_impl)._M_start); } 
# 1268
size_type max_size() const noexcept 
# 1269
{ return _Alloc_traits::max_size(_M_get_Tp_allocator()); } 
# 1282 "/usr/include/c++/5/bits/stl_deque.h" 3
void resize(size_type __new_size) 
# 1283
{ 
# 1284
const size_type __len = size(); 
# 1285
if (__new_size > __len) { 
# 1286
_M_default_append(__new_size - __len); } else { 
# 1287
if (__new_size < __len) { 
# 1288
_M_erase_at_end(((this->_M_impl)._M_start) + ((difference_type)__new_size)); }  }  
# 1290
} 
# 1304 "/usr/include/c++/5/bits/stl_deque.h" 3
void resize(size_type __new_size, const value_type &__x) 
# 1305
{ 
# 1306
const size_type __len = size(); 
# 1307
if (__new_size > __len) { 
# 1308
insert(((this->_M_impl)._M_finish), __new_size - __len, __x); } else { 
# 1309
if (__new_size < __len) { 
# 1310
_M_erase_at_end(((this->_M_impl)._M_start) + ((difference_type)__new_size)); }  }  
# 1312
} 
# 1340 "/usr/include/c++/5/bits/stl_deque.h" 3
void shrink_to_fit() noexcept 
# 1341
{ _M_shrink_to_fit(); } 
# 1349
bool empty() const noexcept 
# 1350
{ return ((this->_M_impl)._M_finish) == ((this->_M_impl)._M_start); } 
# 1365 "/usr/include/c++/5/bits/stl_deque.h" 3
reference operator[](size_type __n) noexcept 
# 1366
{ return ((this->_M_impl)._M_start)[(difference_type)__n]; } 
# 1380 "/usr/include/c++/5/bits/stl_deque.h" 3
const_reference operator[](size_type __n) const noexcept 
# 1381
{ return ((this->_M_impl)._M_start)[(difference_type)__n]; } 
# 1386
protected: void _M_range_check(size_type __n) const 
# 1387
{ 
# 1388
if (__n >= this->size()) { 
# 1389
__throw_out_of_range_fmt("deque::_M_range_check: __n (which is %zu)>= this->size() (which is %zu)", __n, this->size()); }  
# 1393
} 
# 1408 "/usr/include/c++/5/bits/stl_deque.h" 3
public: reference at(size_type __n) 
# 1409
{ 
# 1410
_M_range_check(__n); 
# 1411
return (*this)[__n]; 
# 1412
} 
# 1426 "/usr/include/c++/5/bits/stl_deque.h" 3
const_reference at(size_type __n) const 
# 1427
{ 
# 1428
_M_range_check(__n); 
# 1429
return (*this)[__n]; 
# 1430
} 
# 1437
reference front() noexcept 
# 1438
{ return *this->begin(); } 
# 1445
const_reference front() const noexcept 
# 1446
{ return *this->begin(); } 
# 1453
reference back() noexcept 
# 1454
{ 
# 1455
iterator __tmp = this->end(); 
# 1456
--__tmp; 
# 1457
return *__tmp; 
# 1458
} 
# 1465
const_reference back() const noexcept 
# 1466
{ 
# 1467
const_iterator __tmp = this->end(); 
# 1468
--__tmp; 
# 1469
return *__tmp; 
# 1470
} 
# 1483 "/usr/include/c++/5/bits/stl_deque.h" 3
void push_front(const value_type &__x) 
# 1484
{ 
# 1485
if ((((this->_M_impl)._M_start)._M_cur) != (((this->_M_impl)._M_start)._M_first)) 
# 1486
{ 
# 1487
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_start)._M_cur) - 1, __x); 
# 1490
--(((this->_M_impl)._M_start)._M_cur); 
# 1491
} else { 
# 1493
_M_push_front_aux(__x); }  
# 1494
} 
# 1498
void push_front(value_type &&__x) 
# 1499
{ emplace_front(::std::move(__x)); } 
# 1501
template< class ..._Args> void emplace_front(_Args && ...__args); 
# 1516 "/usr/include/c++/5/bits/stl_deque.h" 3
void push_back(const value_type &__x) 
# 1517
{ 
# 1518
if ((((this->_M_impl)._M_finish)._M_cur) != ((((this->_M_impl)._M_finish)._M_last) - 1)) 
# 1520
{ 
# 1521
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_finish)._M_cur), __x); 
# 1523
++(((this->_M_impl)._M_finish)._M_cur); 
# 1524
} else { 
# 1526
_M_push_back_aux(__x); }  
# 1527
} 
# 1531
void push_back(value_type &&__x) 
# 1532
{ emplace_back(::std::move(__x)); } 
# 1534
template< class ..._Args> void emplace_back(_Args && ...__args); 
# 1548 "/usr/include/c++/5/bits/stl_deque.h" 3
void pop_front() noexcept 
# 1549
{ 
# 1550
if ((((this->_M_impl)._M_start)._M_cur) != ((((this->_M_impl)._M_start)._M_last) - 1)) 
# 1552
{ 
# 1553
_Alloc_traits::destroy((this->_M_impl), (((this->_M_impl)._M_start)._M_cur)); 
# 1555
++(((this->_M_impl)._M_start)._M_cur); 
# 1556
} else { 
# 1558
_M_pop_front_aux(); }  
# 1559
} 
# 1570 "/usr/include/c++/5/bits/stl_deque.h" 3
void pop_back() noexcept 
# 1571
{ 
# 1572
if ((((this->_M_impl)._M_finish)._M_cur) != (((this->_M_impl)._M_finish)._M_first)) 
# 1574
{ 
# 1575
--(((this->_M_impl)._M_finish)._M_cur); 
# 1576
_Alloc_traits::destroy((this->_M_impl), (((this->_M_impl)._M_finish)._M_cur)); 
# 1578
} else { 
# 1580
_M_pop_back_aux(); }  
# 1581
} 
# 1593 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class ..._Args> iterator emplace(const_iterator __position, _Args && ...__args); 
# 1607 "/usr/include/c++/5/bits/stl_deque.h" 3
iterator insert(const_iterator __position, const value_type & __x); 
# 1633 "/usr/include/c++/5/bits/stl_deque.h" 3
iterator insert(const_iterator __position, value_type &&__x) 
# 1634
{ return emplace(__position, ::std::move(__x)); } 
# 1646 "/usr/include/c++/5/bits/stl_deque.h" 3
iterator insert(const_iterator __p, initializer_list< _Tp>  __l) 
# 1647
{ return (this->insert(__p, (__l.begin()), (__l.end()))); } 
# 1662 "/usr/include/c++/5/bits/stl_deque.h" 3
iterator insert(const_iterator __position, size_type __n, const value_type &__x) 
# 1663
{ 
# 1664
difference_type __offset = __position - cbegin(); 
# 1665
_M_fill_insert((__position._M_const_cast()), __n, __x); 
# 1666
return this->begin() + __offset; 
# 1667
} 
# 1695 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _InputIterator, class 
# 1696
 = ::std::_RequireInputIter< _InputIterator> > iterator 
# 1698
insert(const_iterator __position, _InputIterator __first, _InputIterator 
# 1699
__last) 
# 1700
{ 
# 1701
difference_type __offset = __position - cbegin(); 
# 1702
_M_insert_dispatch((__position._M_const_cast()), __first, __last, ::std::__false_type()); 
# 1704
return this->begin() + __offset; 
# 1705
} 
# 1743 "/usr/include/c++/5/bits/stl_deque.h" 3
iterator erase(const_iterator __position) 
# 1747
{ return _M_erase((__position._M_const_cast())); } 
# 1767 "/usr/include/c++/5/bits/stl_deque.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 1771
{ return _M_erase((__first._M_const_cast()), (__last._M_const_cast())); } 
# 1783 "/usr/include/c++/5/bits/stl_deque.h" 3
void swap(deque &__x) noexcept(_Alloc_traits::_S_nothrow_swap()) 
# 1787
{ 
# 1788
(_M_impl._M_swap_data)((__x._M_impl)); 
# 1789
_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(), (__x._M_get_Tp_allocator())); 
# 1791
} 
# 1800
void clear() noexcept 
# 1801
{ _M_erase_at_end(this->begin()); } 
# 1812
protected: 
# 1810
template< class _Integer> void 
# 1812
_M_initialize_dispatch(_Integer __n, _Integer __x, ::std::__true_type) 
# 1813
{ 
# 1814
_M_initialize_map(static_cast< size_type>(__n)); 
# 1815
_M_fill_initialize(__x); 
# 1816
} 
# 1819
template< class _InputIterator> void 
# 1821
_M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1823
{ 
# 1825
typedef typename iterator_traits< _InputIterator> ::iterator_category _IterCategory; 
# 1826
_M_range_initialize(__first, __last, _IterCategory()); 
# 1827
} 
# 1841 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _InputIterator> void _M_range_initialize(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag); 
# 1847
template< class _ForwardIterator> void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag); 
# 1864 "/usr/include/c++/5/bits/stl_deque.h" 3
void _M_fill_initialize(const value_type & __value); 
# 1869
void _M_default_initialize(); 
# 1879 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _Integer> void 
# 1881
_M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type) 
# 1882
{ _M_fill_assign(__n, __val); } 
# 1885
template< class _InputIterator> void 
# 1887
_M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1889
{ 
# 1891
typedef typename iterator_traits< _InputIterator> ::iterator_category _IterCategory; 
# 1892
_M_assign_aux(__first, __last, _IterCategory()); 
# 1893
} 
# 1896
template< class _InputIterator> void _M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag); 
# 1902
template< class _ForwardIterator> void 
# 1904
_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag) 
# 1906
{ 
# 1907
const size_type __len = ::std::distance(__first, __last); 
# 1908
if (__len > size()) 
# 1909
{ 
# 1910
_ForwardIterator __mid = __first; 
# 1911
::std::advance(__mid, size()); 
# 1912
::std::copy(__first, __mid, this->begin()); 
# 1913
insert(this->end(), __mid, __last); 
# 1914
} else { 
# 1916
_M_erase_at_end(::std::copy(__first, __last, this->begin())); }  
# 1917
} 
# 1922
void _M_fill_assign(size_type __n, const value_type &__val) 
# 1923
{ 
# 1924
if (__n > size()) 
# 1925
{ 
# 1926
::std::fill(this->begin(), this->end(), __val); 
# 1927
insert(this->end(), __n - size(), __val); 
# 1928
} else 
# 1930
{ 
# 1931
_M_erase_at_end(this->begin() + ((difference_type)__n)); 
# 1932
::std::fill(this->begin(), this->end(), __val); 
# 1933
}  
# 1934
} 
# 1943 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class ..._Args> void _M_push_back_aux(_Args && ...__args); 
# 1946
template< class ..._Args> void _M_push_front_aux(_Args && ...__args); 
# 1950
void _M_pop_back_aux(); 
# 1952
void _M_pop_front_aux(); 
# 1962 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _Integer> void 
# 1964
_M_insert_dispatch(iterator __pos, _Integer 
# 1965
__n, _Integer __x, ::std::__true_type) 
# 1966
{ _M_fill_insert(__pos, __n, __x); } 
# 1969
template< class _InputIterator> void 
# 1971
_M_insert_dispatch(iterator __pos, _InputIterator 
# 1972
__first, _InputIterator __last, ::std::__false_type) 
# 1974
{ 
# 1976
typedef typename iterator_traits< _InputIterator> ::iterator_category _IterCategory; 
# 1977
_M_range_insert_aux(__pos, __first, __last, _IterCategory()); 
# 1978
} 
# 1981
template< class _InputIterator> void _M_range_insert_aux(iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag); 
# 1987
template< class _ForwardIterator> void _M_range_insert_aux(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag); 
# 1996
void _M_fill_insert(iterator __pos, size_type __n, const value_type & __x); 
# 2003
template< class ..._Args> iterator _M_insert_aux(iterator __pos, _Args && ...__args); 
# 2010
void _M_insert_aux(iterator __pos, size_type __n, const value_type & __x); 
# 2013
template< class _ForwardIterator> void _M_insert_aux(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, size_type __n); 
# 2023
void _M_destroy_data_aux(iterator __first, iterator __last); 
# 2027
template< class _Alloc1> void 
# 2029
_M_destroy_data(iterator __first, iterator __last, const _Alloc1 &) 
# 2030
{ _M_destroy_data_aux(__first, __last); } 
# 2033
void _M_destroy_data(iterator __first, iterator __last, const allocator< _Tp>  &) 
# 2035
{ 
# 2036
if (!__has_trivial_destructor(value_type)) { 
# 2037
_M_destroy_data_aux(__first, __last); }  
# 2038
} 
# 2042
void _M_erase_at_begin(iterator __pos) 
# 2043
{ 
# 2044
_M_destroy_data(this->begin(), __pos, _M_get_Tp_allocator()); 
# 2045
_M_destroy_nodes((((this->_M_impl)._M_start)._M_node), (__pos._M_node)); 
# 2046
((this->_M_impl)._M_start) = __pos; 
# 2047
} 
# 2052
void _M_erase_at_end(iterator __pos) 
# 2053
{ 
# 2054
_M_destroy_data(__pos, this->end(), _M_get_Tp_allocator()); 
# 2055
_M_destroy_nodes((__pos._M_node) + 1, (((this->_M_impl)._M_finish)._M_node) + 1); 
# 2057
((this->_M_impl)._M_finish) = __pos; 
# 2058
} 
# 2061
iterator _M_erase(iterator __pos); 
# 2064
iterator _M_erase(iterator __first, iterator __last); 
# 2069
void _M_default_append(size_type __n); 
# 2072
bool _M_shrink_to_fit(); 
# 2078
iterator _M_reserve_elements_at_front(size_type __n) 
# 2079
{ 
# 2080
const size_type __vacancies = (((this->_M_impl)._M_start)._M_cur) - (((this->_M_impl)._M_start)._M_first); 
# 2082
if (__n > __vacancies) { 
# 2083
_M_new_elements_at_front(__n - __vacancies); }  
# 2084
return ((this->_M_impl)._M_start) - ((difference_type)__n); 
# 2085
} 
# 2088
iterator _M_reserve_elements_at_back(size_type __n) 
# 2089
{ 
# 2090
const size_type __vacancies = ((((this->_M_impl)._M_finish)._M_last) - (((this->_M_impl)._M_finish)._M_cur)) - 1; 
# 2092
if (__n > __vacancies) { 
# 2093
_M_new_elements_at_back(__n - __vacancies); }  
# 2094
return ((this->_M_impl)._M_finish) + ((difference_type)__n); 
# 2095
} 
# 2098
void _M_new_elements_at_front(size_type __new_elements); 
# 2101
void _M_new_elements_at_back(size_type __new_elements); 
# 2114 "/usr/include/c++/5/bits/stl_deque.h" 3
void _M_reserve_map_at_back(size_type __nodes_to_add = 1) 
# 2115
{ 
# 2116
if ((__nodes_to_add + (1)) > (((this->_M_impl)._M_map_size) - ((((this->_M_impl)._M_finish)._M_node) - ((this->_M_impl)._M_map)))) { 
# 2118
_M_reallocate_map(__nodes_to_add, false); }  
# 2119
} 
# 2122
void _M_reserve_map_at_front(size_type __nodes_to_add = 1) 
# 2123
{ 
# 2124
if (__nodes_to_add > ((size_type)((((this->_M_impl)._M_start)._M_node) - ((this->_M_impl)._M_map)))) { 
# 2126
_M_reallocate_map(__nodes_to_add, true); }  
# 2127
} 
# 2130
void _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front); 
# 2137
void _M_move_assign1(deque &&__x, ::std::true_type) noexcept 
# 2138
{ 
# 2139
((this->_M_impl)._M_swap_data((__x._M_impl))); 
# 2140
(__x.clear()); 
# 2141
::std::__alloc_on_move(_M_get_Tp_allocator(), (__x._M_get_Tp_allocator())); 
# 2142
} 
# 2145
void _M_move_assign1(deque &&__x, ::std::false_type) 
# 2146
{ 
# 2147
constexpr bool __move_storage = (_Alloc_traits::_S_propagate_on_move_assign()); 
# 2149
_M_move_assign2(::std::move(__x), integral_constant< bool, __move_storage> ()); 
# 2151
} 
# 2155
template< class ..._Args> void 
# 2157
_M_replace_map(_Args &&...__args) 
# 2158
{ 
# 2160
deque __newobj(::std::forward< _Args> (__args)...); 
# 2162
clear(); 
# 2163
_M_deallocate_node(*(this->begin()._M_node)); 
# 2164
_M_deallocate_map(((this->_M_impl)._M_map), ((this->_M_impl)._M_map_size)); 
# 2165
((this->_M_impl)._M_map) = nullptr; 
# 2166
((this->_M_impl)._M_map_size) = 0; 
# 2168
((this->_M_impl)._M_swap_data((__newobj._M_impl))); 
# 2169
} 
# 2173
void _M_move_assign2(deque &&__x, ::std::true_type) 
# 2174
{ 
# 2176
auto __alloc = (__x._M_get_Tp_allocator()); 
# 2179
_M_replace_map(::std::move(__x)); 
# 2181
_M_get_Tp_allocator() = ::std::move(__alloc); 
# 2182
} 
# 2187
void _M_move_assign2(deque &&__x, ::std::false_type) 
# 2188
{ 
# 2189
if ((__x._M_get_Tp_allocator()) == (this->_M_get_Tp_allocator())) 
# 2190
{ 
# 2193
_M_replace_map(::std::move(__x), (__x.get_allocator())); 
# 2194
} else 
# 2196
{ 
# 2199
(this->assign(::std::__make_move_if_noexcept_iterator((__x.begin())), ::std::__make_move_if_noexcept_iterator((__x.end())))); 
# 2201
(__x.clear()); 
# 2202
}  
# 2203
} 
# 2205
}; 
# 2218 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _Tp, class _Alloc> inline bool 
# 2220
operator==(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2221
__y) 
# 2222
{ return ((__x.size()) == (__y.size())) && std::equal((__x.begin()), (__x.end()), (__y.begin())); 
# 2223
} 
# 2236 "/usr/include/c++/5/bits/stl_deque.h" 3
template< class _Tp, class _Alloc> inline bool 
# 2238
operator<(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2239
__y) 
# 2240
{ return std::lexicographical_compare((__x.begin()), (__x.end()), (__y.begin()), (__y.end())); 
# 2241
} 
# 2244
template< class _Tp, class _Alloc> inline bool 
# 2246
operator!=(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2247
__y) 
# 2248
{ return !(__x == __y); } 
# 2251
template< class _Tp, class _Alloc> inline bool 
# 2253
operator>(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2254
__y) 
# 2255
{ return __y < __x; } 
# 2258
template< class _Tp, class _Alloc> inline bool 
# 2260
operator<=(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2261
__y) 
# 2262
{ return !(__y < __x); } 
# 2265
template< class _Tp, class _Alloc> inline bool 
# 2267
operator>=(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2268
__y) 
# 2269
{ return !(__x < __y); } 
# 2272
template< class _Tp, class _Alloc> inline void 
# 2274
swap(deque< _Tp, _Alloc>  &__x, deque< _Tp, _Alloc>  &__y) 
# 2275
{ (__x.swap(__y)); } 
# 2280
}
# 59 "/usr/include/c++/5/bits/deque.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 64
template< class _Tp, class _Alloc> void 
# 67
deque< _Tp, _Alloc> ::_M_default_initialize() 
# 68
{ 
# 69
_Map_pointer __cur; 
# 70
try 
# 71
{ 
# 72
for (__cur = (((this->_M_impl)._M_start)._M_node); __cur < (((this->_M_impl)._M_finish)._M_node); ++__cur) { 
# 75
::std::__uninitialized_default_a(*__cur, (*__cur) + (_S_buffer_size)(), _M_get_Tp_allocator()); }  
# 77
::std::__uninitialized_default_a((((this->_M_impl)._M_finish)._M_first), (((this->_M_impl)._M_finish)._M_cur), _M_get_Tp_allocator()); 
# 80
} 
# 81
catch (...) 
# 82
{ 
# 83
::std::_Destroy(((this->_M_impl)._M_start), iterator(*__cur, __cur), _M_get_Tp_allocator()); 
# 85
throw; 
# 86
}  
# 87
} 
# 90
template< class _Tp, class _Alloc> deque< _Tp, _Alloc>  &
# 93
deque< _Tp, _Alloc> ::operator=(const deque &__x) 
# 94
{ 
# 95
if ((&__x) != this) 
# 96
{ 
# 98
if (_Alloc_traits::_S_propagate_on_copy_assign()) 
# 99
{ 
# 100
if ((!_Alloc_traits::_S_always_equal()) && (_M_get_Tp_allocator() != (__x._M_get_Tp_allocator()))) 
# 102
{ 
# 105
_M_replace_map(__x, (__x.get_allocator())); 
# 106
::std::__alloc_on_copy(_M_get_Tp_allocator(), (__x._M_get_Tp_allocator())); 
# 108
return *this; 
# 109
}  
# 110
::std::__alloc_on_copy(_M_get_Tp_allocator(), (__x._M_get_Tp_allocator())); 
# 112
}  
# 114
const size_type __len = size(); 
# 115
if (__len >= (__x.size())) { 
# 116
_M_erase_at_end(::std::copy((__x.begin()), (__x.end()), ((this->_M_impl)._M_start))); } else 
# 119
{ 
# 120
const_iterator __mid = (__x.begin()) + ((difference_type)__len); 
# 121
::std::copy((__x.begin()), __mid, ((this->_M_impl)._M_start)); 
# 122
insert(((this->_M_impl)._M_finish), __mid, (__x.end())); 
# 123
}  
# 124
}  
# 125
return *this; 
# 126
} 
# 129
template< class _Tp, class _Alloc> 
# 130
template< class ..._Args> void 
# 133
deque< _Tp, _Alloc> ::emplace_front(_Args &&...__args) 
# 134
{ 
# 135
if ((((this->_M_impl)._M_start)._M_cur) != (((this->_M_impl)._M_start)._M_first)) 
# 136
{ 
# 137
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_start)._M_cur) - 1, ::std::forward< _Args> (__args)...); 
# 140
--(((this->_M_impl)._M_start)._M_cur); 
# 141
} else { 
# 143
_M_push_front_aux(::std::forward< _Args> (__args)...); }  
# 144
} 
# 146
template< class _Tp, class _Alloc> 
# 147
template< class ..._Args> void 
# 150
deque< _Tp, _Alloc> ::emplace_back(_Args &&...__args) 
# 151
{ 
# 152
if ((((this->_M_impl)._M_finish)._M_cur) != ((((this->_M_impl)._M_finish)._M_last) - 1)) 
# 154
{ 
# 155
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_finish)._M_cur), ::std::forward< _Args> (__args)...); 
# 158
++(((this->_M_impl)._M_finish)._M_cur); 
# 159
} else { 
# 161
_M_push_back_aux(::std::forward< _Args> (__args)...); }  
# 162
} 
# 166
template< class _Tp, class _Alloc> 
# 167
template< class ..._Args> typename deque< _Tp, _Alloc> ::iterator 
# 170
deque< _Tp, _Alloc> ::emplace(const_iterator __position, _Args &&...__args) 
# 171
{ 
# 172
if ((__position._M_cur) == (((this->_M_impl)._M_start)._M_cur)) 
# 173
{ 
# 174
emplace_front(::std::forward< _Args> (__args)...); 
# 175
return (this->_M_impl)._M_start; 
# 176
} else { 
# 177
if ((__position._M_cur) == (((this->_M_impl)._M_finish)._M_cur)) 
# 178
{ 
# 179
emplace_back(::std::forward< _Args> (__args)...); 
# 180
iterator __tmp = (((this->_M_impl)._M_finish)); 
# 181
--__tmp; 
# 182
return __tmp; 
# 183
} else { 
# 185
return _M_insert_aux((__position._M_const_cast()), ::std::forward< _Args> (__args)...); }  }  
# 187
} 
# 190
template< class _Tp, class _Alloc> typename deque< _Tp, _Alloc> ::iterator 
# 194
deque< _Tp, _Alloc> ::insert(const_iterator __position, const value_type &__x) 
# 198
{ 
# 199
if ((__position._M_cur) == (((this->_M_impl)._M_start)._M_cur)) 
# 200
{ 
# 201
push_front(__x); 
# 202
return (this->_M_impl)._M_start; 
# 203
} else { 
# 204
if ((__position._M_cur) == (((this->_M_impl)._M_finish)._M_cur)) 
# 205
{ 
# 206
push_back(__x); 
# 207
iterator __tmp = (((this->_M_impl)._M_finish)); 
# 208
--__tmp; 
# 209
return __tmp; 
# 210
} else { 
# 212
return _M_insert_aux((__position._M_const_cast()), __x); }  }  
# 213
} 
# 215
template< class _Tp, class _Alloc> typename deque< _Tp, _Alloc> ::iterator 
# 218
deque< _Tp, _Alloc> ::_M_erase(iterator __position) 
# 219
{ 
# 220
iterator __next = __position; 
# 221
++__next; 
# 222
const difference_type __index = __position - this->begin(); 
# 223
if ((static_cast< size_type>(__index)) < (size() >> 1)) 
# 224
{ 
# 225
if (__position != this->begin()) { 
# 226
::std::move_backward(this->begin(), __position, __next); }  
# 227
pop_front(); 
# 228
} else 
# 230
{ 
# 231
if (__next != this->end()) { 
# 232
::std::move(__next, this->end(), __position); }  
# 233
pop_back(); 
# 234
}  
# 235
return this->begin() + __index; 
# 236
} 
# 238
template< class _Tp, class _Alloc> typename deque< _Tp, _Alloc> ::iterator 
# 241
deque< _Tp, _Alloc> ::_M_erase(iterator __first, iterator __last) 
# 242
{ 
# 243
if (__first == __last) { 
# 244
return __first; } else { 
# 245
if ((__first == this->begin()) && (__last == this->end())) 
# 246
{ 
# 247
clear(); 
# 248
return this->end(); 
# 249
} else 
# 251
{ 
# 252
const difference_type __n = __last - __first; 
# 253
const difference_type __elems_before = __first - this->begin(); 
# 254
if ((static_cast< size_type>(__elems_before)) <= ((size() - __n) / 2)) 
# 255
{ 
# 256
if (__first != this->begin()) { 
# 257
::std::move_backward(this->begin(), __first, __last); }  
# 258
_M_erase_at_begin(this->begin() + __n); 
# 259
} else 
# 261
{ 
# 262
if (__last != this->end()) { 
# 263
::std::move(__last, this->end(), __first); }  
# 264
_M_erase_at_end(this->end() - __n); 
# 265
}  
# 266
return this->begin() + __elems_before; 
# 267
}  }  
# 268
} 
# 270
template< class _Tp, class _Alloc> 
# 271
template< class _InputIterator> void 
# 274
deque< _Tp, _Alloc> ::_M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag) 
# 276
{ 
# 277
iterator __cur = this->begin(); 
# 278
for (; (__first != __last) && (__cur != this->end()); (++__cur), (++__first)) { 
# 279
(*__cur) = (*__first); }  
# 280
if (__first == __last) { 
# 281
_M_erase_at_end(__cur); } else { 
# 283
insert(this->end(), __first, __last); }  
# 284
} 
# 286
template< class _Tp, class _Alloc> void 
# 289
deque< _Tp, _Alloc> ::_M_fill_insert(iterator __pos, size_type __n, const value_type &__x) 
# 290
{ 
# 291
if ((__pos._M_cur) == (((this->_M_impl)._M_start)._M_cur)) 
# 292
{ 
# 293
iterator __new_start = _M_reserve_elements_at_front(__n); 
# 294
try 
# 295
{ 
# 296
::std::__uninitialized_fill_a(__new_start, ((this->_M_impl)._M_start), __x, _M_get_Tp_allocator()); 
# 298
((this->_M_impl)._M_start) = __new_start; 
# 299
} 
# 300
catch (...) 
# 301
{ 
# 302
_M_destroy_nodes((__new_start._M_node), (((this->_M_impl)._M_start)._M_node)); 
# 304
throw; 
# 305
}  
# 306
} else { 
# 307
if ((__pos._M_cur) == (((this->_M_impl)._M_finish)._M_cur)) 
# 308
{ 
# 309
iterator __new_finish = _M_reserve_elements_at_back(__n); 
# 310
try 
# 311
{ 
# 312
::std::__uninitialized_fill_a(((this->_M_impl)._M_finish), __new_finish, __x, _M_get_Tp_allocator()); 
# 315
((this->_M_impl)._M_finish) = __new_finish; 
# 316
} 
# 317
catch (...) 
# 318
{ 
# 319
_M_destroy_nodes((((this->_M_impl)._M_finish)._M_node) + 1, (__new_finish._M_node) + 1); 
# 321
throw; 
# 322
}  
# 323
} else { 
# 325
_M_insert_aux(__pos, __n, __x); }  }  
# 326
} 
# 329
template< class _Tp, class _Alloc> void 
# 332
deque< _Tp, _Alloc> ::_M_default_append(size_type __n) 
# 333
{ 
# 334
if (__n) 
# 335
{ 
# 336
iterator __new_finish = _M_reserve_elements_at_back(__n); 
# 337
try 
# 338
{ 
# 339
::std::__uninitialized_default_a(((this->_M_impl)._M_finish), __new_finish, _M_get_Tp_allocator()); 
# 342
((this->_M_impl)._M_finish) = __new_finish; 
# 343
} 
# 344
catch (...) 
# 345
{ 
# 346
_M_destroy_nodes((((this->_M_impl)._M_finish)._M_node) + 1, (__new_finish._M_node) + 1); 
# 348
throw; 
# 349
}  
# 350
}  
# 351
} 
# 353
template< class _Tp, class _Alloc> bool 
# 356
deque< _Tp, _Alloc> ::_M_shrink_to_fit() 
# 357
{ 
# 358
const difference_type __front_capacity = (((this->_M_impl)._M_start)._M_cur) - (((this->_M_impl)._M_start)._M_first); 
# 360
if (__front_capacity == (0)) { 
# 361
return false; }  
# 363
const difference_type __back_capacity = (((this->_M_impl)._M_finish)._M_last) - (((this->_M_impl)._M_finish)._M_cur); 
# 365
if ((__front_capacity + __back_capacity) < (_S_buffer_size)()) { 
# 366
return false; }  
# 368
return std::__shrink_to_fit_aux< deque> ::_S_do_it(*this); 
# 369
} 
# 372
template< class _Tp, class _Alloc> void 
# 375
deque< _Tp, _Alloc> ::_M_fill_initialize(const value_type &__value) 
# 376
{ 
# 377
_Map_pointer __cur; 
# 378
try 
# 379
{ 
# 380
for (__cur = (((this->_M_impl)._M_start)._M_node); __cur < (((this->_M_impl)._M_finish)._M_node); ++__cur) { 
# 383
::std::__uninitialized_fill_a(*__cur, (*__cur) + (_S_buffer_size)(), __value, _M_get_Tp_allocator()); }  
# 385
::std::__uninitialized_fill_a((((this->_M_impl)._M_finish)._M_first), (((this->_M_impl)._M_finish)._M_cur), __value, _M_get_Tp_allocator()); 
# 388
} 
# 389
catch (...) 
# 390
{ 
# 391
::std::_Destroy(((this->_M_impl)._M_start), iterator(*__cur, __cur), _M_get_Tp_allocator()); 
# 393
throw; 
# 394
}  
# 395
} 
# 397
template< class _Tp, class _Alloc> 
# 398
template< class _InputIterator> void 
# 401
deque< _Tp, _Alloc> ::_M_range_initialize(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag) 
# 403
{ 
# 404
(this->_M_initialize_map(0)); 
# 405
try 
# 406
{ 
# 407
for (; __first != __last; ++__first) { 
# 409
emplace_back(*__first); }  
# 413
} 
# 414
catch (...) 
# 415
{ 
# 416
clear(); 
# 417
throw; 
# 418
}  
# 419
} 
# 421
template< class _Tp, class _Alloc> 
# 422
template< class _ForwardIterator> void 
# 425
deque< _Tp, _Alloc> ::_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag) 
# 427
{ 
# 428
const size_type __n = ::std::distance(__first, __last); 
# 429
(this->_M_initialize_map(__n)); 
# 431
_Map_pointer __cur_node; 
# 432
try 
# 433
{ 
# 434
for (__cur_node = (((this->_M_impl)._M_start)._M_node); __cur_node < (((this->_M_impl)._M_finish)._M_node); ++__cur_node) 
# 437
{ 
# 438
_ForwardIterator __mid = __first; 
# 439
::std::advance(__mid, (_S_buffer_size)()); 
# 440
::std::__uninitialized_copy_a(__first, __mid, *__cur_node, _M_get_Tp_allocator()); 
# 442
__first = __mid; 
# 443
}  
# 444
::std::__uninitialized_copy_a(__first, __last, (((this->_M_impl)._M_finish)._M_first), _M_get_Tp_allocator()); 
# 447
} 
# 448
catch (...) 
# 449
{ 
# 450
::std::_Destroy(((this->_M_impl)._M_start), iterator(*__cur_node, __cur_node), _M_get_Tp_allocator()); 
# 453
throw; 
# 454
}  
# 455
} 
# 458
template< class _Tp, class _Alloc> 
# 460
template< class ..._Args> void 
# 463
deque< _Tp, _Alloc> ::_M_push_back_aux(_Args &&...__args) 
# 469
{ 
# 470
_M_reserve_map_at_back(); 
# 471
(*((((this->_M_impl)._M_finish)._M_node) + 1)) = (this->_M_allocate_node()); 
# 472
try 
# 473
{ 
# 475
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_finish)._M_cur), ::std::forward< _Args> (__args)...); 
# 481
(((this->_M_impl)._M_finish)._M_set_node((((this->_M_impl)._M_finish)._M_node) + 1)); 
# 483
(((this->_M_impl)._M_finish)._M_cur) = (((this->_M_impl)._M_finish)._M_first); 
# 484
} 
# 485
catch (...) 
# 486
{ 
# 487
_M_deallocate_node(*((((this->_M_impl)._M_finish)._M_node) + 1)); 
# 488
throw; 
# 489
}  
# 490
} 
# 493
template< class _Tp, class _Alloc> 
# 495
template< class ..._Args> void 
# 498
deque< _Tp, _Alloc> ::_M_push_front_aux(_Args &&...__args) 
# 504
{ 
# 505
_M_reserve_map_at_front(); 
# 506
(*((((this->_M_impl)._M_start)._M_node) - 1)) = (this->_M_allocate_node()); 
# 507
try 
# 508
{ 
# 509
(((this->_M_impl)._M_start)._M_set_node((((this->_M_impl)._M_start)._M_node) - 1)); 
# 511
(((this->_M_impl)._M_start)._M_cur) = ((((this->_M_impl)._M_start)._M_last) - 1); 
# 513
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_start)._M_cur), ::std::forward< _Args> (__args)...); 
# 519
} 
# 520
catch (...) 
# 521
{ 
# 522
++((this->_M_impl)._M_start); 
# 523
_M_deallocate_node(*((((this->_M_impl)._M_start)._M_node) - 1)); 
# 524
throw; 
# 525
}  
# 526
} 
# 529
template< class _Tp, class _Alloc> void 
# 531
deque< _Tp, _Alloc> ::_M_pop_back_aux() 
# 532
{ 
# 533
_M_deallocate_node((((this->_M_impl)._M_finish)._M_first)); 
# 534
(((this->_M_impl)._M_finish)._M_set_node((((this->_M_impl)._M_finish)._M_node) - 1)); 
# 535
(((this->_M_impl)._M_finish)._M_cur) = ((((this->_M_impl)._M_finish)._M_last) - 1); 
# 536
_Alloc_traits::destroy(_M_get_Tp_allocator(), (((this->_M_impl)._M_finish)._M_cur)); 
# 538
} 
# 545
template< class _Tp, class _Alloc> void 
# 547
deque< _Tp, _Alloc> ::_M_pop_front_aux() 
# 548
{ 
# 549
_Alloc_traits::destroy(_M_get_Tp_allocator(), (((this->_M_impl)._M_start)._M_cur)); 
# 551
_M_deallocate_node((((this->_M_impl)._M_start)._M_first)); 
# 552
(((this->_M_impl)._M_start)._M_set_node((((this->_M_impl)._M_start)._M_node) + 1)); 
# 553
(((this->_M_impl)._M_start)._M_cur) = (((this->_M_impl)._M_start)._M_first); 
# 554
} 
# 556
template< class _Tp, class _Alloc> 
# 557
template< class _InputIterator> void 
# 560
deque< _Tp, _Alloc> ::_M_range_insert_aux(iterator __pos, _InputIterator 
# 561
__first, _InputIterator __last, ::std::input_iterator_tag) 
# 563
{ ::std::copy(__first, __last, ::std::inserter(*this, __pos)); } 
# 565
template< class _Tp, class _Alloc> 
# 566
template< class _ForwardIterator> void 
# 569
deque< _Tp, _Alloc> ::_M_range_insert_aux(iterator __pos, _ForwardIterator 
# 570
__first, _ForwardIterator __last, ::std::forward_iterator_tag) 
# 572
{ 
# 573
const size_type __n = ::std::distance(__first, __last); 
# 574
if ((__pos._M_cur) == (((this->_M_impl)._M_start)._M_cur)) 
# 575
{ 
# 576
iterator __new_start = _M_reserve_elements_at_front(__n); 
# 577
try 
# 578
{ 
# 579
::std::__uninitialized_copy_a(__first, __last, __new_start, _M_get_Tp_allocator()); 
# 581
((this->_M_impl)._M_start) = __new_start; 
# 582
} 
# 583
catch (...) 
# 584
{ 
# 585
_M_destroy_nodes((__new_start._M_node), (((this->_M_impl)._M_start)._M_node)); 
# 587
throw; 
# 588
}  
# 589
} else { 
# 590
if ((__pos._M_cur) == (((this->_M_impl)._M_finish)._M_cur)) 
# 591
{ 
# 592
iterator __new_finish = _M_reserve_elements_at_back(__n); 
# 593
try 
# 594
{ 
# 595
::std::__uninitialized_copy_a(__first, __last, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 598
((this->_M_impl)._M_finish) = __new_finish; 
# 599
} 
# 600
catch (...) 
# 601
{ 
# 602
_M_destroy_nodes((((this->_M_impl)._M_finish)._M_node) + 1, (__new_finish._M_node) + 1); 
# 604
throw; 
# 605
}  
# 606
} else { 
# 608
_M_insert_aux(__pos, __first, __last, __n); }  }  
# 609
} 
# 611
template< class _Tp, class _Alloc> 
# 613
template< class ..._Args> typename deque< _Tp, _Alloc> ::iterator 
# 616
deque< _Tp, _Alloc> ::_M_insert_aux(iterator __pos, _Args &&...__args) 
# 617
{ 
# 618
value_type __x_copy(::std::forward< _Args> (__args)...); 
# 626
difference_type __index = __pos - ((this->_M_impl)._M_start); 
# 627
if ((static_cast< size_type>(__index)) < (size() / 2)) 
# 628
{ 
# 629
push_front(::std::move(this->front())); 
# 630
iterator __front1 = (((this->_M_impl)._M_start)); 
# 631
++__front1; 
# 632
iterator __front2 = __front1; 
# 633
++__front2; 
# 634
__pos = (((this->_M_impl)._M_start) + __index); 
# 635
iterator __pos1 = __pos; 
# 636
++__pos1; 
# 637
::std::move(__front2, __pos1, __front1); 
# 638
} else 
# 640
{ 
# 641
push_back(::std::move(this->back())); 
# 642
iterator __back1 = (((this->_M_impl)._M_finish)); 
# 643
--__back1; 
# 644
iterator __back2 = __back1; 
# 645
--__back2; 
# 646
__pos = (((this->_M_impl)._M_start) + __index); 
# 647
::std::move_backward(__pos, __back2, __back1); 
# 648
}  
# 649
(*__pos) = ::std::move(__x_copy); 
# 650
return __pos; 
# 651
} 
# 653
template< class _Tp, class _Alloc> void 
# 656
deque< _Tp, _Alloc> ::_M_insert_aux(iterator __pos, size_type __n, const value_type &__x) 
# 657
{ 
# 658
const difference_type __elems_before = __pos - ((this->_M_impl)._M_start); 
# 659
const size_type __length = this->size(); 
# 660
value_type __x_copy = __x; 
# 661
if (__elems_before < ((difference_type)(__length / (2)))) 
# 662
{ 
# 663
iterator __new_start = _M_reserve_elements_at_front(__n); 
# 664
iterator __old_start = (((this->_M_impl)._M_start)); 
# 665
__pos = (((this->_M_impl)._M_start) + __elems_before); 
# 666
try 
# 667
{ 
# 668
if (__elems_before >= ((difference_type)__n)) 
# 669
{ 
# 670
iterator __start_n = ((this->_M_impl)._M_start) + ((difference_type)__n); 
# 672
::std::__uninitialized_move_a(((this->_M_impl)._M_start), __start_n, __new_start, _M_get_Tp_allocator()); 
# 675
((this->_M_impl)._M_start) = __new_start; 
# 676
::std::move(__start_n, __pos, __old_start); 
# 677
::std::fill(__pos - ((difference_type)__n), __pos, __x_copy); 
# 678
} else 
# 680
{ 
# 681
::std::__uninitialized_move_fill(((this->_M_impl)._M_start), __pos, __new_start, ((this->_M_impl)._M_start), __x_copy, _M_get_Tp_allocator()); 
# 686
((this->_M_impl)._M_start) = __new_start; 
# 687
::std::fill(__old_start, __pos, __x_copy); 
# 688
}  
# 689
} 
# 690
catch (...) 
# 691
{ 
# 692
_M_destroy_nodes((__new_start._M_node), (((this->_M_impl)._M_start)._M_node)); 
# 694
throw; 
# 695
}  
# 696
} else 
# 698
{ 
# 699
iterator __new_finish = _M_reserve_elements_at_back(__n); 
# 700
iterator __old_finish = (((this->_M_impl)._M_finish)); 
# 701
const difference_type __elems_after = (((difference_type)__length) - __elems_before); 
# 703
__pos = (((this->_M_impl)._M_finish) - __elems_after); 
# 704
try 
# 705
{ 
# 706
if (__elems_after > ((difference_type)__n)) 
# 707
{ 
# 708
iterator __finish_n = ((this->_M_impl)._M_finish) - ((difference_type)__n); 
# 710
::std::__uninitialized_move_a(__finish_n, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 714
((this->_M_impl)._M_finish) = __new_finish; 
# 715
::std::move_backward(__pos, __finish_n, __old_finish); 
# 716
::std::fill(__pos, __pos + ((difference_type)__n), __x_copy); 
# 717
} else 
# 719
{ 
# 720
::std::__uninitialized_fill_move(((this->_M_impl)._M_finish), __pos + ((difference_type)__n), __x_copy, __pos, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 725
((this->_M_impl)._M_finish) = __new_finish; 
# 726
::std::fill(__pos, __old_finish, __x_copy); 
# 727
}  
# 728
} 
# 729
catch (...) 
# 730
{ 
# 731
_M_destroy_nodes((((this->_M_impl)._M_finish)._M_node) + 1, (__new_finish._M_node) + 1); 
# 733
throw; 
# 734
}  
# 735
}  
# 736
} 
# 738
template< class _Tp, class _Alloc> 
# 739
template< class _ForwardIterator> void 
# 742
deque< _Tp, _Alloc> ::_M_insert_aux(iterator __pos, _ForwardIterator 
# 743
__first, _ForwardIterator __last, size_type 
# 744
__n) 
# 745
{ 
# 746
const difference_type __elemsbefore = __pos - ((this->_M_impl)._M_start); 
# 747
const size_type __length = size(); 
# 748
if ((static_cast< size_type>(__elemsbefore)) < (__length / (2))) 
# 749
{ 
# 750
iterator __new_start = _M_reserve_elements_at_front(__n); 
# 751
iterator __old_start = (((this->_M_impl)._M_start)); 
# 752
__pos = (((this->_M_impl)._M_start) + __elemsbefore); 
# 753
try 
# 754
{ 
# 755
if (__elemsbefore >= ((difference_type)__n)) 
# 756
{ 
# 757
iterator __start_n = ((this->_M_impl)._M_start) + ((difference_type)__n); 
# 759
::std::__uninitialized_move_a(((this->_M_impl)._M_start), __start_n, __new_start, _M_get_Tp_allocator()); 
# 762
((this->_M_impl)._M_start) = __new_start; 
# 763
::std::move(__start_n, __pos, __old_start); 
# 764
::std::copy(__first, __last, __pos - ((difference_type)__n)); 
# 765
} else 
# 767
{ 
# 768
_ForwardIterator __mid = __first; 
# 769
::std::advance(__mid, ((difference_type)__n) - __elemsbefore); 
# 770
::std::__uninitialized_move_copy(((this->_M_impl)._M_start), __pos, __first, __mid, __new_start, _M_get_Tp_allocator()); 
# 774
((this->_M_impl)._M_start) = __new_start; 
# 775
::std::copy(__mid, __last, __old_start); 
# 776
}  
# 777
} 
# 778
catch (...) 
# 779
{ 
# 780
_M_destroy_nodes((__new_start._M_node), (((this->_M_impl)._M_start)._M_node)); 
# 782
throw; 
# 783
}  
# 784
} else 
# 786
{ 
# 787
iterator __new_finish = _M_reserve_elements_at_back(__n); 
# 788
iterator __old_finish = (((this->_M_impl)._M_finish)); 
# 789
const difference_type __elemsafter = (((difference_type)__length) - __elemsbefore); 
# 791
__pos = (((this->_M_impl)._M_finish) - __elemsafter); 
# 792
try 
# 793
{ 
# 794
if (__elemsafter > ((difference_type)__n)) 
# 795
{ 
# 796
iterator __finish_n = ((this->_M_impl)._M_finish) - ((difference_type)__n); 
# 798
::std::__uninitialized_move_a(__finish_n, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 802
((this->_M_impl)._M_finish) = __new_finish; 
# 803
::std::move_backward(__pos, __finish_n, __old_finish); 
# 804
::std::copy(__first, __last, __pos); 
# 805
} else 
# 807
{ 
# 808
_ForwardIterator __mid = __first; 
# 809
::std::advance(__mid, __elemsafter); 
# 810
::std::__uninitialized_copy_move(__mid, __last, __pos, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 814
((this->_M_impl)._M_finish) = __new_finish; 
# 815
::std::copy(__first, __mid, __pos); 
# 816
}  
# 817
} 
# 818
catch (...) 
# 819
{ 
# 820
_M_destroy_nodes((((this->_M_impl)._M_finish)._M_node) + 1, (__new_finish._M_node) + 1); 
# 822
throw; 
# 823
}  
# 824
}  
# 825
} 
# 827
template< class _Tp, class _Alloc> void 
# 830
deque< _Tp, _Alloc> ::_M_destroy_data_aux(iterator __first, iterator __last) 
# 831
{ 
# 832
for (_Map_pointer __node = (__first._M_node) + 1; __node < (__last._M_node); ++__node) { 
# 834
::std::_Destroy(*__node, (*__node) + (_S_buffer_size)(), _M_get_Tp_allocator()); }  
# 837
if ((__first._M_node) != (__last._M_node)) 
# 838
{ 
# 839
::std::_Destroy((__first._M_cur), (__first._M_last), _M_get_Tp_allocator()); 
# 841
::std::_Destroy((__last._M_first), (__last._M_cur), _M_get_Tp_allocator()); 
# 843
} else { 
# 845
::std::_Destroy((__first._M_cur), (__last._M_cur), _M_get_Tp_allocator()); }  
# 847
} 
# 849
template< class _Tp, class _Alloc> void 
# 852
deque< _Tp, _Alloc> ::_M_new_elements_at_front(size_type __new_elems) 
# 853
{ 
# 854
if ((this->max_size() - this->size()) < __new_elems) { 
# 855
__throw_length_error("deque::_M_new_elements_at_front"); }  
# 857
const size_type __new_nodes = ((__new_elems + (_S_buffer_size)()) - (1)) / (_S_buffer_size)(); 
# 859
_M_reserve_map_at_front(__new_nodes); 
# 860
size_type __i; 
# 861
try 
# 862
{ 
# 863
for (__i = (1); __i <= __new_nodes; ++__i) { 
# 864
(*((((this->_M_impl)._M_start)._M_node) - __i)) = (this->_M_allocate_node()); }  
# 865
} 
# 866
catch (...) 
# 867
{ 
# 868
for (size_type __j = (1); __j < __i; ++__j) { 
# 869
_M_deallocate_node(*((((this->_M_impl)._M_start)._M_node) - __j)); }  
# 870
throw; 
# 871
}  
# 872
} 
# 874
template< class _Tp, class _Alloc> void 
# 877
deque< _Tp, _Alloc> ::_M_new_elements_at_back(size_type __new_elems) 
# 878
{ 
# 879
if ((this->max_size() - this->size()) < __new_elems) { 
# 880
__throw_length_error("deque::_M_new_elements_at_back"); }  
# 882
const size_type __new_nodes = ((__new_elems + (_S_buffer_size)()) - (1)) / (_S_buffer_size)(); 
# 884
_M_reserve_map_at_back(__new_nodes); 
# 885
size_type __i; 
# 886
try 
# 887
{ 
# 888
for (__i = (1); __i <= __new_nodes; ++__i) { 
# 889
(*((((this->_M_impl)._M_finish)._M_node) + __i)) = (this->_M_allocate_node()); }  
# 890
} 
# 891
catch (...) 
# 892
{ 
# 893
for (size_type __j = (1); __j < __i; ++__j) { 
# 894
_M_deallocate_node(*((((this->_M_impl)._M_finish)._M_node) + __j)); }  
# 895
throw; 
# 896
}  
# 897
} 
# 899
template< class _Tp, class _Alloc> void 
# 902
deque< _Tp, _Alloc> ::_M_reallocate_map(size_type __nodes_to_add, bool __add_at_front) 
# 903
{ 
# 904
const size_type __old_num_nodes = ((((this->_M_impl)._M_finish)._M_node) - (((this->_M_impl)._M_start)._M_node)) + 1; 
# 906
const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add; 
# 908
_Map_pointer __new_nstart; 
# 909
if (((this->_M_impl)._M_map_size) > ((2) * __new_num_nodes)) 
# 910
{ 
# 911
__new_nstart = ((((this->_M_impl)._M_map) + ((((this->_M_impl)._M_map_size) - __new_num_nodes) / 2)) + (__add_at_front ? __nodes_to_add : (0))); 
# 914
if (__new_nstart < (((this->_M_impl)._M_start)._M_node)) { 
# 915
::std::copy((((this->_M_impl)._M_start)._M_node), (((this->_M_impl)._M_finish)._M_node) + 1, __new_nstart); } else { 
# 919
::std::copy_backward((((this->_M_impl)._M_start)._M_node), (((this->_M_impl)._M_finish)._M_node) + 1, __new_nstart + __old_num_nodes); }  
# 922
} else 
# 924
{ 
# 925
size_type __new_map_size = (((this->_M_impl)._M_map_size) + ::std::max(((this->_M_impl)._M_map_size), __nodes_to_add)) + 2; 
# 929
_Map_pointer __new_map = (this->_M_allocate_map(__new_map_size)); 
# 930
__new_nstart = ((__new_map + ((__new_map_size - __new_num_nodes) / (2))) + (__add_at_front ? __nodes_to_add : (0))); 
# 932
::std::copy((((this->_M_impl)._M_start)._M_node), (((this->_M_impl)._M_finish)._M_node) + 1, __new_nstart); 
# 935
_M_deallocate_map(((this->_M_impl)._M_map), ((this->_M_impl)._M_map_size)); 
# 937
((this->_M_impl)._M_map) = __new_map; 
# 938
((this->_M_impl)._M_map_size) = __new_map_size; 
# 939
}  
# 941
(((this->_M_impl)._M_start)._M_set_node(__new_nstart)); 
# 942
(((this->_M_impl)._M_finish)._M_set_node((__new_nstart + __old_num_nodes) - 1)); 
# 943
} 
# 947
template< class _Tp> void 
# 949
fill(const _Deque_iterator< _Tp, _Tp &, _Tp *>  &__first, const _Deque_iterator< _Tp, _Tp &, _Tp *>  &
# 950
__last, const _Tp &__value) 
# 951
{ 
# 952
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self _Self; 
# 954
for (typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self::_Map_pointer __node = (__first._M_node) + 1; __node < (__last._M_node); ++__node) { 
# 956
std::fill(*__node, (*__node) + _Self::_S_buffer_size(), __value); }  
# 958
if ((__first._M_node) != (__last._M_node)) 
# 959
{ 
# 960
std::fill((__first._M_cur), (__first._M_last), __value); 
# 961
std::fill((__last._M_first), (__last._M_cur), __value); 
# 962
} else { 
# 964
std::fill((__first._M_cur), (__last._M_cur), __value); }  
# 965
} 
# 967
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 969
copy(_Deque_iterator< _Tp, const _Tp &, const _Tp *>  __first, _Deque_iterator< _Tp, const _Tp &, const _Tp *>  
# 970
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 971
__result) 
# 972
{ 
# 973
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self _Self; 
# 974
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self::difference_type difference_type; 
# 976
difference_type __len = __last - __first; 
# 977
while (__len > 0) 
# 978
{ 
# 979
const difference_type __clen = std::min(__len, std::min((__first._M_last) - (__first._M_cur), (__result._M_last) - (__result._M_cur))); 
# 982
std::copy((__first._M_cur), (__first._M_cur) + __clen, (__result._M_cur)); 
# 983
__first += __clen; 
# 984
__result += __clen; 
# 985
__len -= __clen; 
# 986
}  
# 987
return __result; 
# 988
} 
# 990
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 992
copy_backward(_Deque_iterator< _Tp, const _Tp &, const _Tp *>  __first, _Deque_iterator< _Tp, const _Tp &, const _Tp *>  
# 993
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 994
__result) 
# 995
{ 
# 996
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self _Self; 
# 997
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self::difference_type difference_type; 
# 999
difference_type __len = __last - __first; 
# 1000
while (__len > 0) 
# 1001
{ 
# 1002
difference_type __llen = (__last._M_cur) - (__last._M_first); 
# 1003
_Tp *__lend = ((__last._M_cur)); 
# 1005
difference_type __rlen = (__result._M_cur) - (__result._M_first); 
# 1006
_Tp *__rend = ((__result._M_cur)); 
# 1008
if (!__llen) 
# 1009
{ 
# 1010
__llen = _Self::_S_buffer_size(); 
# 1011
__lend = ((*((__last._M_node) - 1)) + __llen); 
# 1012
}  
# 1013
if (!__rlen) 
# 1014
{ 
# 1015
__rlen = _Self::_S_buffer_size(); 
# 1016
__rend = ((*((__result._M_node) - 1)) + __rlen); 
# 1017
}  
# 1019
const difference_type __clen = std::min(__len, std::min(__llen, __rlen)); 
# 1021
std::copy_backward(__lend - __clen, __lend, __rend); 
# 1022
__last -= __clen; 
# 1023
__result -= __clen; 
# 1024
__len -= __clen; 
# 1025
}  
# 1026
return __result; 
# 1027
} 
# 1030
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 1032
move(_Deque_iterator< _Tp, const _Tp &, const _Tp *>  __first, _Deque_iterator< _Tp, const _Tp &, const _Tp *>  
# 1033
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 1034
__result) 
# 1035
{ 
# 1036
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self _Self; 
# 1037
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self::difference_type difference_type; 
# 1039
difference_type __len = __last - __first; 
# 1040
while (__len > 0) 
# 1041
{ 
# 1042
const difference_type __clen = std::min(__len, std::min((__first._M_last) - (__first._M_cur), (__result._M_last) - (__result._M_cur))); 
# 1045
std::move((__first._M_cur), (__first._M_cur) + __clen, (__result._M_cur)); 
# 1046
__first += __clen; 
# 1047
__result += __clen; 
# 1048
__len -= __clen; 
# 1049
}  
# 1050
return __result; 
# 1051
} 
# 1053
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 1055
move_backward(_Deque_iterator< _Tp, const _Tp &, const _Tp *>  __first, _Deque_iterator< _Tp, const _Tp &, const _Tp *>  
# 1056
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 1057
__result) 
# 1058
{ 
# 1059
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self _Self; 
# 1060
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self::difference_type difference_type; 
# 1062
difference_type __len = __last - __first; 
# 1063
while (__len > 0) 
# 1064
{ 
# 1065
difference_type __llen = (__last._M_cur) - (__last._M_first); 
# 1066
_Tp *__lend = ((__last._M_cur)); 
# 1068
difference_type __rlen = (__result._M_cur) - (__result._M_first); 
# 1069
_Tp *__rend = ((__result._M_cur)); 
# 1071
if (!__llen) 
# 1072
{ 
# 1073
__llen = _Self::_S_buffer_size(); 
# 1074
__lend = ((*((__last._M_node) - 1)) + __llen); 
# 1075
}  
# 1076
if (!__rlen) 
# 1077
{ 
# 1078
__rlen = _Self::_S_buffer_size(); 
# 1079
__rend = ((*((__result._M_node) - 1)) + __rlen); 
# 1080
}  
# 1082
const difference_type __clen = std::min(__len, std::min(__llen, __rlen)); 
# 1084
std::move_backward(__lend - __clen, __lend, __rend); 
# 1085
__last -= __clen; 
# 1086
__result -= __clen; 
# 1087
__len -= __clen; 
# 1088
}  
# 1089
return __result; 
# 1090
} 
# 1094
}
# 53 "/usr/include/opencv2/objdetect/objdetect_c.h" 3
extern "C" {
# 82 "/usr/include/opencv2/objdetect/objdetect_c.h" 3
typedef 
# 74
struct CvHaarFeature { 
# 76
int tilted; 
# 78
struct { 
# 79
CvRect r; 
# 80
float weight; 
# 81
} rect[3]; 
# 82
} CvHaarFeature; 
# 92
typedef 
# 84
struct CvHaarClassifier { 
# 86
int count; 
# 87
CvHaarFeature *haar_feature; 
# 88
float *threshold; 
# 89
int *left; 
# 90
int *right; 
# 91
float *alpha; 
# 92
} CvHaarClassifier; 
# 103
typedef 
# 94
struct CvHaarStageClassifier { 
# 96
int count; 
# 97
float threshold; 
# 98
CvHaarClassifier *classifier; 
# 100
int next; 
# 101
int child; 
# 102
int parent; 
# 103
} CvHaarStageClassifier; 
# 105
typedef struct CvHidHaarClassifierCascade CvHidHaarClassifierCascade; 
# 116
typedef 
# 107
struct CvHaarClassifierCascade { 
# 109
int flags; 
# 110
int count; 
# 111
CvSize orig_window_size; 
# 112
CvSize real_window_size; 
# 113
double scale; 
# 114
CvHaarStageClassifier *stage_classifier; 
# 115
CvHidHaarClassifierCascade *hid_cascade; 
# 116
} CvHaarClassifierCascade; 
# 122
typedef 
# 118
struct CvAvgComp { 
# 120
CvRect rect; 
# 121
int neighbors; 
# 122
} CvAvgComp; 
# 126
__attribute((visibility("default"))) CvHaarClassifierCascade *cvLoadHaarClassifierCascade(const char * directory, CvSize orig_window_size); 
# 129
__attribute((visibility("default"))) void cvReleaseHaarClassifierCascade(CvHaarClassifierCascade ** cascade); 
# 136
__attribute((visibility("default"))) CvSeq *cvHaarDetectObjects(const CvArr * image, CvHaarClassifierCascade * cascade, CvMemStorage * storage, double scale_factor = (1.100000000000000089), int min_neighbors = 3, int flags = 0, CvSize min_size = cvSize(0, 0), CvSize max_size = cvSize(0, 0)); 
# 143
__attribute((visibility("default"))) void cvSetImagesForHaarClassifierCascade(CvHaarClassifierCascade * cascade, const CvArr * sum, const CvArr * sqsum, const CvArr * tilted_sum, double scale); 
# 148
__attribute((visibility("default"))) int cvRunHaarClassifierCascade(const CvHaarClassifierCascade * cascade, CvPoint pt, int start_stage = 0); 
# 154
}
# 156
__attribute((visibility("default"))) CvSeq *cvHaarDetectObjectsForROC(const CvArr * image, CvHaarClassifierCascade * cascade, CvMemStorage * storage, std::vector< int>  & rejectLevels, std::vector< double>  & levelWeightds, double scale_factor = (1.100000000000000089), int min_neighbors = 3, int flags = 0, CvSize min_size = cvSize(0, 0), CvSize max_size = cvSize(0, 0), bool outputRejectLevels = false); 
# 64 "/usr/include/opencv2/photo.hpp" 3
namespace cv { 
# 72
enum { 
# 73
INPAINT_NS, 
# 74
INPAINT_TELEA
# 75
}; 
# 78
enum { 
# 79
NORMAL_CLONE = 1, 
# 80
MIXED_CLONE, 
# 81
MONOCHROME_TRANSFER
# 82
}; 
# 85
enum { 
# 86
RECURS_FILTER = 1, 
# 87
NORMCONV_FILTER
# 88
}; 
# 112 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void inpaint(InputArray src, InputArray inpaintMask, OutputArray dst, double inpaintRadius, int flags); 
# 138 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void fastNlMeansDenoising(InputArray src, OutputArray dst, float h = 3, int templateWindowSize = 7, int searchWindowSize = 21); 
# 165 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void fastNlMeansDenoising(InputArray src, OutputArray dst, const std::vector< float>  & h, int templateWindowSize = 7, int searchWindowSize = 21, int normType = NORM_L2); 
# 188 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void fastNlMeansDenoisingColored(InputArray src, OutputArray dst, float h = 3, float hColor = 3, int templateWindowSize = 7, int searchWindowSize = 21); 
# 215 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void fastNlMeansDenoisingMulti(InputArrayOfArrays srcImgs, OutputArray dst, int imgToDenoiseIndex, int temporalWindowSize, float h = 3, int templateWindowSize = 7, int searchWindowSize = 21); 
# 244 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void fastNlMeansDenoisingMulti(InputArrayOfArrays srcImgs, OutputArray dst, int imgToDenoiseIndex, int temporalWindowSize, const std::vector< float>  & h, int templateWindowSize = 7, int searchWindowSize = 21, int normType = NORM_L2); 
# 273 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void fastNlMeansDenoisingColoredMulti(InputArrayOfArrays srcImgs, OutputArray dst, int imgToDenoiseIndex, int temporalWindowSize, float h = 3, float hColor = 3, int templateWindowSize = 7, int searchWindowSize = 21); 
# 315 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void denoise_TVL1(const std::vector< Mat>  & observations, Mat & result, double lambda = (1.0), int niters = 30); 
# 322
enum { LDR_SIZE = 256}; 
# 326
class __attribute((visibility("default"))) Tonemap : public Algorithm { 
# 334
public: virtual void process(InputArray src, OutputArray dst) = 0; 
# 336
virtual float getGamma() const = 0; 
# 337
virtual void setGamma(float gamma) = 0; 
# 338
}; 
# 346
__attribute((visibility("default"))) Ptr< Tonemap>  createTonemap(float gamma = (1.0F)); 
# 358 "/usr/include/opencv2/photo.hpp" 3
class __attribute((visibility("default"))) TonemapDrago : public Tonemap { 
# 362
public: virtual float getSaturation() const = 0; 
# 363
virtual void setSaturation(float saturation) = 0; 
# 365
virtual float getBias() const = 0; 
# 366
virtual void setBias(float bias) = 0; 
# 367
}; 
# 377 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) Ptr< TonemapDrago>  createTonemapDrago(float gamma = (1.0F), float saturation = (1.0F), float bias = (0.8500000238F)); 
# 388 "/usr/include/opencv2/photo.hpp" 3
class __attribute((visibility("default"))) TonemapDurand : public Tonemap { 
# 392
public: virtual float getSaturation() const = 0; 
# 393
virtual void setSaturation(float saturation) = 0; 
# 395
virtual float getContrast() const = 0; 
# 396
virtual void setContrast(float contrast) = 0; 
# 398
virtual float getSigmaSpace() const = 0; 
# 399
virtual void setSigmaSpace(float sigma_space) = 0; 
# 401
virtual float getSigmaColor() const = 0; 
# 402
virtual void setSigmaColor(float sigma_color) = 0; 
# 403
}; 
# 414 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) Ptr< TonemapDurand>  
# 415
createTonemapDurand(float gamma = (1.0F), float contrast = (4.0F), float saturation = (1.0F), float sigma_space = (2.0F), float sigma_color = (2.0F)); 
# 424 "/usr/include/opencv2/photo.hpp" 3
class __attribute((visibility("default"))) TonemapReinhard : public Tonemap { 
# 427
public: virtual float getIntensity() const = 0; 
# 428
virtual void setIntensity(float intensity) = 0; 
# 430
virtual float getLightAdaptation() const = 0; 
# 431
virtual void setLightAdaptation(float light_adapt) = 0; 
# 433
virtual float getColorAdaptation() const = 0; 
# 434
virtual void setColorAdaptation(float color_adapt) = 0; 
# 435
}; 
# 446 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) Ptr< TonemapReinhard>  
# 447
createTonemapReinhard(float gamma = (1.0F), float intensity = (0.0F), float light_adapt = (1.0F), float color_adapt = (0.0F)); 
# 455
class __attribute((visibility("default"))) TonemapMantiuk : public Tonemap { 
# 458
public: virtual float getScale() const = 0; 
# 459
virtual void setScale(float scale) = 0; 
# 461
virtual float getSaturation() const = 0; 
# 462
virtual void setSaturation(float saturation) = 0; 
# 463
}; 
# 472 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) Ptr< TonemapMantiuk>  
# 473
createTonemapMantiuk(float gamma = (1.0F), float scale = (0.6999999881F), float saturation = (1.0F)); 
# 477
class __attribute((visibility("default"))) AlignExposures : public Algorithm { 
# 488 "/usr/include/opencv2/photo.hpp" 3
public: virtual void process(InputArrayOfArrays src, std::vector< Mat>  & dst, InputArray times, InputArray response) = 0; 
# 490
}; 
# 501 "/usr/include/opencv2/photo.hpp" 3
class __attribute((visibility("default"))) AlignMTB : public AlignExposures { 
# 504
public: virtual void process(InputArrayOfArrays src, std::vector< Mat>  & dst, InputArray times, InputArray response) = 0; 
# 512
virtual void process(InputArrayOfArrays src, std::vector< Mat>  & dst) = 0; 
# 520
virtual Point calculateShift(InputArray img0, InputArray img1) = 0; 
# 527
virtual void shiftMat(InputArray src, OutputArray dst, const Point shift) = 0; 
# 534
virtual void computeBitmaps(InputArray img, OutputArray tb, OutputArray eb) = 0; 
# 536
virtual int getMaxBits() const = 0; 
# 537
virtual void setMaxBits(int max_bits) = 0; 
# 539
virtual int getExcludeRange() const = 0; 
# 540
virtual void setExcludeRange(int exclude_range) = 0; 
# 542
virtual bool getCut() const = 0; 
# 543
virtual void setCut(bool value) = 0; 
# 544
}; 
# 554 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) Ptr< AlignMTB>  createAlignMTB(int max_bits = 6, int exclude_range = 4, bool cut = true); 
# 558
class __attribute((visibility("default"))) CalibrateCRF : public Algorithm { 
# 567
public: virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times) = 0; 
# 568
}; 
# 576
class __attribute((visibility("default"))) CalibrateDebevec : public CalibrateCRF { 
# 579
public: virtual float getLambda() const = 0; 
# 580
virtual void setLambda(float lambda) = 0; 
# 582
virtual int getSamples() const = 0; 
# 583
virtual void setSamples(int samples) = 0; 
# 585
virtual bool getRandom() const = 0; 
# 586
virtual void setRandom(bool random) = 0; 
# 587
}; 
# 597 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) Ptr< CalibrateDebevec>  createCalibrateDebevec(int samples = 70, float lambda = (10.0F), bool random = false); 
# 604
class __attribute((visibility("default"))) CalibrateRobertson : public CalibrateCRF { 
# 607
public: virtual int getMaxIter() const = 0; 
# 608
virtual void setMaxIter(int max_iter) = 0; 
# 610
virtual float getThreshold() const = 0; 
# 611
virtual void setThreshold(float threshold) = 0; 
# 613
virtual Mat getRadiance() const = 0; 
# 614
}; 
# 621
__attribute((visibility("default"))) Ptr< CalibrateRobertson>  createCalibrateRobertson(int max_iter = 30, float threshold = (0.009999999776F)); 
# 625
class __attribute((visibility("default"))) MergeExposures : public Algorithm { 
# 636 "/usr/include/opencv2/photo.hpp" 3
public: virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times, InputArray response) = 0; 
# 638
}; 
# 645
class __attribute((visibility("default"))) MergeDebevec : public MergeExposures { 
# 648
public: virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times, InputArray response) = 0; 
# 650
virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times) = 0; 
# 651
}; 
# 655
__attribute((visibility("default"))) Ptr< MergeDebevec>  createMergeDebevec(); 
# 668 "/usr/include/opencv2/photo.hpp" 3
class __attribute((visibility("default"))) MergeMertens : public MergeExposures { 
# 671
public: virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times, InputArray response) = 0; 
# 678
virtual void process(InputArrayOfArrays src, OutputArray dst) = 0; 
# 680
virtual float getContrastWeight() const = 0; 
# 681
virtual void setContrastWeight(float contrast_weiht) = 0; 
# 683
virtual float getSaturationWeight() const = 0; 
# 684
virtual void setSaturationWeight(float saturation_weight) = 0; 
# 686
virtual float getExposureWeight() const = 0; 
# 687
virtual void setExposureWeight(float exposure_weight) = 0; 
# 688
}; 
# 696
__attribute((visibility("default"))) Ptr< MergeMertens>  
# 697
createMergeMertens(float contrast_weight = (1.0F), float saturation_weight = (1.0F), float exposure_weight = (0.0F)); 
# 704
class __attribute((visibility("default"))) MergeRobertson : public MergeExposures { 
# 707
public: virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times, InputArray response) = 0; 
# 709
virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times) = 0; 
# 710
}; 
# 714
__attribute((visibility("default"))) Ptr< MergeRobertson>  createMergeRobertson(); 
# 728 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void decolor(InputArray src, OutputArray grayscale, OutputArray color_boost); 
# 757 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void seamlessClone(InputArray src, InputArray dst, InputArray mask, Point p, OutputArray blend, int flags); 
# 772 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void colorChange(InputArray src, InputArray mask, OutputArray dst, float red_mul = (1.0F), float green_mul = (1.0F), float blue_mul = (1.0F)); 
# 786 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void illuminationChange(InputArray src, InputArray mask, OutputArray dst, float alpha = (0.200000003F), float beta = (0.400000006F)); 
# 806 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void textureFlattening(InputArray src, InputArray mask, OutputArray dst, float low_threshold = 30, float high_threshold = 45, int kernel_size = 3); 
# 826 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void edgePreservingFilter(InputArray src, OutputArray dst, int flags = 1, float sigma_s = 60, float sigma_r = (0.400000006F)); 
# 836 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void detailEnhance(InputArray src, OutputArray dst, float sigma_s = 10, float sigma_r = (0.150000006F)); 
# 851 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void pencilSketch(InputArray src, OutputArray dst1, OutputArray dst2, float sigma_s = 60, float sigma_r = (0.0700000003F), float shade_factor = (0.01999999955F)); 
# 863 "/usr/include/opencv2/photo.hpp" 3
__attribute((visibility("default"))) void stylization(InputArray src, OutputArray dst, float sigma_s = 60, float sigma_r = (0.4499999881F)); 
# 870
}
# 49 "/usr/include/opencv2/photo/photo_c.h" 3
extern "C" {
# 57
enum InpaintingModes { 
# 59
CV_INPAINT_NS, 
# 60
CV_INPAINT_TELEA
# 61
}; 
# 65
__attribute((visibility("default"))) void cvInpaint(const CvArr * src, const CvArr * inpaint_mask, CvArr * dst, double inpaintRange, int flags); 
# 71
}
# 48 "/usr/include/opencv2/shape/emdL1.hpp" 3
namespace cv { 
# 66 "/usr/include/opencv2/shape/emdL1.hpp" 3
__attribute((visibility("default"))) float EMDL1(InputArray signature1, InputArray signature2); 
# 70
}
# 50 "/usr/include/opencv2/shape/shape_transformer.hpp" 3
namespace cv { 
# 58
class __attribute((visibility("default"))) ShapeTransformer : public Algorithm { 
# 67
public: virtual void estimateTransformation(InputArray transformingShape, InputArray targetShape, std::vector< DMatch>  & matches) = 0; 
# 75
virtual float applyTransformation(InputArray input, OutputArray output = noArray()) = 0; 
# 85 "/usr/include/opencv2/shape/shape_transformer.hpp" 3
virtual void warpImage(InputArray transformingImage, OutputArray output, int flags = INTER_LINEAR, int borderMode = BORDER_CONSTANT, const Scalar & borderValue = Scalar()) const = 0; 
# 88
}; 
# 98 "/usr/include/opencv2/shape/shape_transformer.hpp" 3
class __attribute((visibility("default"))) ThinPlateSplineShapeTransformer : public ShapeTransformer { 
# 106
public: virtual void setRegularizationParameter(double beta) = 0; 
# 107
virtual double getRegularizationParameter() const = 0; 
# 108
}; 
# 111
__attribute((visibility("default"))) Ptr< ThinPlateSplineShapeTransformer>  
# 112
createThinPlateSplineShapeTransformer(double regularizationParameter = 0); 
# 119
class __attribute((visibility("default"))) AffineTransformer : public ShapeTransformer { 
# 122
public: virtual void setFullAffine(bool fullAffine) = 0; 
# 123
virtual bool getFullAffine() const = 0; 
# 124
}; 
# 127
__attribute((visibility("default"))) Ptr< AffineTransformer>  createAffineTransformer(bool fullAffine); 
# 131
}
# 49 "/usr/include/opencv2/shape/hist_cost.hpp" 3
namespace cv { 
# 57
class __attribute((visibility("default"))) HistogramCostExtractor : public Algorithm { 
# 60
public: virtual void buildCostMatrix(InputArray descriptors1, InputArray descriptors2, OutputArray costMatrix) = 0; 
# 62
virtual void setNDummies(int nDummies) = 0; 
# 63
virtual int getNDummies() const = 0; 
# 65
virtual void setDefaultCost(float defaultCost) = 0; 
# 66
virtual float getDefaultCost() const = 0; 
# 67
}; 
# 71
class __attribute((visibility("default"))) NormHistogramCostExtractor : public HistogramCostExtractor { 
# 74
public: virtual void setNormFlag(int flag) = 0; 
# 75
virtual int getNormFlag() const = 0; 
# 76
}; 
# 78
__attribute((visibility("default"))) Ptr< HistogramCostExtractor>  
# 79
createNormHistogramCostExtractor(int flag = DIST_L2, int nDummies = 25, float defaultCost = (0.200000003F)); 
# 83
class __attribute((visibility("default"))) EMDHistogramCostExtractor : public HistogramCostExtractor { 
# 86
public: virtual void setNormFlag(int flag) = 0; 
# 87
virtual int getNormFlag() const = 0; 
# 88
}; 
# 90
__attribute((visibility("default"))) Ptr< HistogramCostExtractor>  
# 91
createEMDHistogramCostExtractor(int flag = DIST_L2, int nDummies = 25, float defaultCost = (0.200000003F)); 
# 95
class __attribute((visibility("default"))) ChiHistogramCostExtractor : public HistogramCostExtractor { 
# 96
}; 
# 98
__attribute((visibility("default"))) Ptr< HistogramCostExtractor>  createChiHistogramCostExtractor(int nDummies = 25, float defaultCost = (0.200000003F)); 
# 102
class __attribute((visibility("default"))) EMDL1HistogramCostExtractor : public HistogramCostExtractor { 
# 103
}; 
# 105
__attribute((visibility("default"))) Ptr< HistogramCostExtractor>  
# 106
createEMDL1HistogramCostExtractor(int nDummies = 25, float defaultCost = (0.200000003F)); 
# 110
}
# 50 "/usr/include/opencv2/shape/shape_distance.hpp" 3
namespace cv { 
# 61 "/usr/include/opencv2/shape/shape_distance.hpp" 3
class __attribute((visibility("default"))) ShapeDistanceExtractor : public Algorithm { 
# 69
public: virtual float computeDistance(InputArray contour1, InputArray contour2) = 0; 
# 70
}; 
# 81 "/usr/include/opencv2/shape/shape_distance.hpp" 3
class __attribute((visibility("default"))) ShapeContextDistanceExtractor : public ShapeDistanceExtractor { 
# 89
public: virtual void setAngularBins(int nAngularBins) = 0; 
# 90
virtual int getAngularBins() const = 0; 
# 97
virtual void setRadialBins(int nRadialBins) = 0; 
# 98
virtual int getRadialBins() const = 0; 
# 104
virtual void setInnerRadius(float innerRadius) = 0; 
# 105
virtual float getInnerRadius() const = 0; 
# 111
virtual void setOuterRadius(float outerRadius) = 0; 
# 112
virtual float getOuterRadius() const = 0; 
# 114
virtual void setRotationInvariant(bool rotationInvariant) = 0; 
# 115
virtual bool getRotationInvariant() const = 0; 
# 124 "/usr/include/opencv2/shape/shape_distance.hpp" 3
virtual void setShapeContextWeight(float shapeContextWeight) = 0; 
# 125
virtual float getShapeContextWeight() const = 0; 
# 136 "/usr/include/opencv2/shape/shape_distance.hpp" 3
virtual void setImageAppearanceWeight(float imageAppearanceWeight) = 0; 
# 137
virtual float getImageAppearanceWeight() const = 0; 
# 146 "/usr/include/opencv2/shape/shape_distance.hpp" 3
virtual void setBendingEnergyWeight(float bendingEnergyWeight) = 0; 
# 147
virtual float getBendingEnergyWeight() const = 0; 
# 155
virtual void setImages(InputArray image1, InputArray image2) = 0; 
# 156
virtual void getImages(OutputArray image1, OutputArray image2) const = 0; 
# 158
virtual void setIterations(int iterations) = 0; 
# 159
virtual int getIterations() const = 0; 
# 166
virtual void setCostExtractor(Ptr< HistogramCostExtractor>  comparer) = 0; 
# 167
virtual Ptr< HistogramCostExtractor>  getCostExtractor() const = 0; 
# 173
virtual void setStdDev(float sigma) = 0; 
# 174
virtual float getStdDev() const = 0; 
# 181
virtual void setTransformAlgorithm(Ptr< ShapeTransformer>  transformer) = 0; 
# 182
virtual Ptr< ShapeTransformer>  getTransformAlgorithm() const = 0; 
# 183
}; 
# 186
__attribute((visibility("default"))) Ptr< ShapeContextDistanceExtractor>  
# 187
createShapeContextDistanceExtractor(int nAngularBins = 12, int nRadialBins = 4, float innerRadius = (0.200000003F), float outerRadius = 2, int iterations = 3, const Ptr< HistogramCostExtractor>  & comparer = createChiHistogramCostExtractor(), const Ptr< ShapeTransformer>  & transformer = createThinPlateSplineShapeTransformer()); 
# 200 "/usr/include/opencv2/shape/shape_distance.hpp" 3
class __attribute((visibility("default"))) HausdorffDistanceExtractor : public ShapeDistanceExtractor { 
# 208
public: virtual void setDistanceFlag(int distanceFlag) = 0; 
# 209
virtual int getDistanceFlag() const = 0; 
# 217
virtual void setRankProportion(float rankProportion) = 0; 
# 218
virtual float getRankProportion() const = 0; 
# 219
}; 
# 222
__attribute((visibility("default"))) Ptr< HausdorffDistanceExtractor>  createHausdorffDistanceExtractor(int distanceFlag = cv::NORM_L2, float rankProp = (0.6000000238F)); 
# 226
}
# 62 "/usr/include/opencv2/core/cuda_types.hpp" 3
namespace cv { 
# 64
namespace cuda { 
# 70
template< class T> struct DevPtr { 
# 72
typedef T elem_type; 
# 73
typedef int index_type; 
# 75
enum { elem_size = sizeof(elem_type)}; 
# 77
T *data; 
# 79 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 79 "/usr/include/opencv2/core/cuda_types.hpp" 3
DevPtr() : data((0)) { } 
# 80 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 80 "/usr/include/opencv2/core/cuda_types.hpp" 3
DevPtr(T *data_) : data(data_) { } 
# 82 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) size_t 
# 82 "/usr/include/opencv2/core/cuda_types.hpp" 3
elemSize() const { return elem_size; } 
# 83 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 83 "/usr/include/opencv2/core/cuda_types.hpp" 3
operator T *() { return data; } 
# 84 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 84 "/usr/include/opencv2/core/cuda_types.hpp" 3
operator const T *() const { return data; } 
# 85
}; 
# 87
template< class T> struct PtrSz : public DevPtr< T>  { 
# 89 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 89 "/usr/include/opencv2/core/cuda_types.hpp" 3
PtrSz() : size((0)) { } 
# 90 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 90 "/usr/include/opencv2/core/cuda_types.hpp" 3
PtrSz(T *data_, ::size_t size_) : ::cv::cuda::DevPtr< T> (data_), size(size_) { } 
# 92
::size_t size; 
# 93
}; 
# 95
template< class T> struct PtrStep : public DevPtr< T>  { 
# 97 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 97 "/usr/include/opencv2/core/cuda_types.hpp" 3
PtrStep() : step((0)) { } 
# 98 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 98 "/usr/include/opencv2/core/cuda_types.hpp" 3
PtrStep(T *data_, ::size_t step_) : ::cv::cuda::DevPtr< T> (data_), step(step_) { } 
# 100
::size_t step; 
# 102 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) T *
# 102 "/usr/include/opencv2/core/cuda_types.hpp" 3
ptr(int y = 0) { return (T *)(((char *)DevPtr< T> ::data) + (y * (step))); } 
# 103 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) const T *
# 103 "/usr/include/opencv2/core/cuda_types.hpp" 3
ptr(int y = 0) const { return (const T *)(((const char *)DevPtr< T> ::data) + (y * (step))); } 
# 105 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) T &
# 105 "/usr/include/opencv2/core/cuda_types.hpp" 3
operator()(int y, int x) { return ptr(y)[x]; } 
# 106 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) const T &
# 106 "/usr/include/opencv2/core/cuda_types.hpp" 3
operator()(int y, int x) const { return ptr(y)[x]; } 
# 107
}; 
# 109
template< class T> struct PtrStepSz : public PtrStep< T>  { 
# 111 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 111 "/usr/include/opencv2/core/cuda_types.hpp" 3
PtrStepSz() : cols(0), rows(0) { } 
# 112 "/usr/include/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 112 "/usr/include/opencv2/core/cuda_types.hpp" 3
PtrStepSz(int rows_, int cols_, T *data_, ::size_t step_) : ::cv::cuda::PtrStep< T> (data_, step_), cols(cols_), rows(rows_) 
# 113
{ } 
# 115
template< class U> explicit 
# 116
PtrStepSz(const ::cv::cuda::PtrStepSz< U>  &d) : ::cv::cuda::PtrStep< T> ((T *)(d.data), (d.step)), cols(((d.cols))), rows(((d.rows))) { } 
# 118
int cols; 
# 119
int rows; 
# 120
}; 
# 122
typedef PtrStepSz< unsigned char>  PtrStepSzb; 
# 123
typedef PtrStepSz< float>  PtrStepSzf; 
# 124
typedef PtrStepSz< int>  PtrStepSzi; 
# 126
typedef PtrStep< unsigned char>  PtrStepb; 
# 127
typedef PtrStep< float>  PtrStepf; 
# 128
typedef PtrStep< int>  PtrStepi; 
# 130
}
# 131
}
# 65 "/usr/include/opencv2/core/cuda.hpp" 3
namespace cv { namespace cuda { 
# 96 "/usr/include/opencv2/core/cuda.hpp" 3
class __attribute((visibility("default"))) GpuMat { 
# 99
public: class __attribute((visibility("default"))) Allocator { 
# 102
public: virtual ~Allocator() { } 
# 105
virtual bool allocate(GpuMat * mat, int rows, int cols, size_t elemSize) = 0; 
# 106
virtual void free(GpuMat * mat) = 0; 
# 107
}; 
# 110
static Allocator *defaultAllocator(); 
# 111
static void setDefaultAllocator(Allocator * allocator); 
# 114
inline explicit GpuMat(Allocator * allocator = defaultAllocator()); 
# 117
inline GpuMat(int rows, int cols, int type, Allocator * allocator = defaultAllocator()); 
# 118
inline GpuMat(Size size, int type, Allocator * allocator = defaultAllocator()); 
# 121
inline GpuMat(int rows, int cols, int type, Scalar s, Allocator * allocator = defaultAllocator()); 
# 122
inline GpuMat(Size size, int type, Scalar s, Allocator * allocator = defaultAllocator()); 
# 125
inline GpuMat(const GpuMat & m); 
# 128
GpuMat(int rows, int cols, int type, void * data, size_t step = Mat::AUTO_STEP); 
# 129
GpuMat(Size size, int type, void * data, size_t step = Mat::AUTO_STEP); 
# 132
GpuMat(const GpuMat & m, Range rowRange, Range colRange); 
# 133
GpuMat(const GpuMat & m, Rect roi); 
# 136
inline explicit GpuMat(InputArray arr, Allocator * allocator = defaultAllocator()); 
# 139
inline ~GpuMat(); 
# 142
inline GpuMat &operator=(const GpuMat & m); 
# 145
void create(int rows, int cols, int type); 
# 146
inline void create(Size size, int type); 
# 149
void release(); 
# 152
inline void swap(GpuMat & mat); 
# 155
void upload(InputArray arr); 
# 158
void upload(InputArray arr, Stream & stream); 
# 161
void download(OutputArray dst) const; 
# 164
void download(OutputArray dst, Stream & stream) const; 
# 167
inline GpuMat clone() const; 
# 170
void copyTo(OutputArray dst) const; 
# 173
void copyTo(OutputArray dst, Stream & stream) const; 
# 176
inline void copyTo(OutputArray dst, InputArray mask) const; 
# 179
void copyTo(OutputArray dst, InputArray mask, Stream & stream) const; 
# 182
inline GpuMat &setTo(Scalar s); 
# 185
GpuMat &setTo(Scalar s, Stream & stream); 
# 188
inline GpuMat &setTo(Scalar s, InputArray mask); 
# 191
GpuMat &setTo(Scalar s, InputArray mask, Stream & stream); 
# 194
inline void convertTo(OutputArray dst, int rtype) const; 
# 197
void convertTo(OutputArray dst, int rtype, Stream & stream) const; 
# 200
inline void convertTo(OutputArray dst, int rtype, double alpha, double beta = (0.0)) const; 
# 203
inline void convertTo(OutputArray dst, int rtype, double alpha, Stream & stream) const; 
# 206
void convertTo(OutputArray dst, int rtype, double alpha, double beta, Stream & stream) const; 
# 208
inline void assignTo(GpuMat & m, int type = -1) const; 
# 211
inline uchar *ptr(int y = 0); 
# 212
inline const uchar *ptr(int y = 0) const; 
# 215
template< class _Tp> inline _Tp *ptr(int y = 0); 
# 216
template< class _Tp> inline const _Tp *ptr(int y = 0) const; 
# 218
template< class _Tp> inline operator PtrStepSz< _Tp> () const; 
# 219
template< class _Tp> inline operator PtrStep< _Tp> () const; 
# 222
inline GpuMat row(int y) const; 
# 225
inline GpuMat col(int x) const; 
# 228
inline GpuMat rowRange(int startrow, int endrow) const; 
# 229
inline GpuMat rowRange(Range r) const; 
# 232
inline GpuMat colRange(int startcol, int endcol) const; 
# 233
inline GpuMat colRange(Range r) const; 
# 236
inline GpuMat operator()(Range rowRange, Range colRange) const; 
# 237
inline GpuMat operator()(Rect roi) const; 
# 241
GpuMat reshape(int cn, int rows = 0) const; 
# 244
void locateROI(Size & wholeSize, Point & ofs) const; 
# 247
GpuMat &adjustROI(int dtop, int dbottom, int dleft, int dright); 
# 251
inline bool isContinuous() const; 
# 254
inline size_t elemSize() const; 
# 257
inline size_t elemSize1() const; 
# 260
inline int type() const; 
# 263
inline int depth() const; 
# 266
inline int channels() const; 
# 269
inline size_t step1() const; 
# 272
inline Size size() const; 
# 275
inline bool empty() const; 
# 283
int flags; 
# 286
int rows, cols; 
# 289
size_t step; 
# 292
uchar *data; 
# 296
int *refcount; 
# 299
uchar *datastart; 
# 300
const uchar *dataend; 
# 303
Allocator *allocator; 
# 304
}; 
# 317 "/usr/include/opencv2/core/cuda.hpp" 3
__attribute((visibility("default"))) void createContinuous(int rows, int cols, int type, OutputArray arr); 
# 328 "/usr/include/opencv2/core/cuda.hpp" 3
__attribute((visibility("default"))) void ensureSizeIsEnough(int rows, int cols, int type, OutputArray arr); 
# 338 "/usr/include/opencv2/core/cuda.hpp" 3
class __attribute((visibility("default"))) BufferPool { 
# 343
public: explicit BufferPool(Stream & stream); 
# 346
GpuMat getBuffer(int rows, int cols, int type); 
# 349
GpuMat getBuffer(Size size, int type) { return this->getBuffer(size.height, size.width, type); } 
# 352
Ptr< GpuMat::Allocator>  getAllocator() const { return allocator_; } 
# 355
private: Ptr< GpuMat::Allocator>  allocator_; 
# 356
}; 
# 359
__attribute((visibility("default"))) void setBufferPoolUsage(bool on); 
# 360
__attribute((visibility("default"))) void setBufferPoolConfig(int deviceId, size_t stackSize, int stackCount); 
# 381 "/usr/include/opencv2/core/cuda.hpp" 3
class __attribute((visibility("default"))) HostMem { 
# 384
public: enum AllocType { PAGE_LOCKED = 1, SHARED, WRITE_COMBINED = 4}; 
# 386
static MatAllocator *getAllocator(AllocType alloc_type = PAGE_LOCKED); 
# 388
inline explicit HostMem(AllocType alloc_type = PAGE_LOCKED); 
# 390
inline HostMem(const HostMem & m); 
# 392
inline HostMem(int rows, int cols, int type, AllocType alloc_type = PAGE_LOCKED); 
# 393
inline HostMem(Size size, int type, AllocType alloc_type = PAGE_LOCKED); 
# 396
inline explicit HostMem(InputArray arr, AllocType alloc_type = PAGE_LOCKED); 
# 398
inline ~HostMem(); 
# 400
inline HostMem &operator=(const HostMem & m); 
# 403
inline void swap(HostMem & b); 
# 406
inline HostMem clone() const; 
# 409
void create(int rows, int cols, int type); 
# 410
inline void create(Size size, int type); 
# 414
HostMem reshape(int cn, int rows = 0) const; 
# 417
void release(); 
# 420
inline Mat createMatHeader() const; 
# 429 "/usr/include/opencv2/core/cuda.hpp" 3
GpuMat createGpuMatHeader() const; 
# 432
inline bool isContinuous() const; 
# 433
inline size_t elemSize() const; 
# 434
inline size_t elemSize1() const; 
# 435
inline int type() const; 
# 436
inline int depth() const; 
# 437
inline int channels() const; 
# 438
inline size_t step1() const; 
# 439
inline Size size() const; 
# 440
inline bool empty() const; 
# 443
int flags; 
# 444
int rows, cols; 
# 445
size_t step; 
# 447
uchar *data; 
# 448
int *refcount; 
# 450
uchar *datastart; 
# 451
const uchar *dataend; 
# 453
AllocType alloc_type; 
# 454
}; 
# 460
__attribute((visibility("default"))) void registerPageLocked(Mat & m); 
# 466
__attribute((visibility("default"))) void unregisterPageLocked(Mat & m); 
# 499 "/usr/include/opencv2/core/cuda.hpp" 3
class __attribute((visibility("default"))) Stream { 
# 501
typedef void (Stream::*bool_type)(void) const; 
# 502
void this_type_does_not_support_comparisons() const { } 
# 505
public: typedef void (*StreamCallback)(int status, void * userData); 
# 508
Stream(); 
# 511
Stream(const Ptr< GpuMat::Allocator>  & allocator); 
# 515
bool queryIfComplete() const; 
# 519
void waitForCompletion(); 
# 523
void waitEvent(const Event & event); 
# 533 "/usr/include/opencv2/core/cuda.hpp" 3
void enqueueHostCallback(StreamCallback callback, void * userData); 
# 536
static Stream &Null(); 
# 539
operator bool_type() const; 
# 541
class Impl; 
# 544
private: Ptr< Impl>  impl_; 
# 545
inline Stream(const Ptr< Impl>  & impl); 
# 547
friend struct StreamAccessor; 
# 548
friend class BufferPool; 
# 549
friend class DefaultDeviceInitializer; 
# 550
}; 
# 552
class __attribute((visibility("default"))) Event { 
# 555
public: enum CreateFlags { 
# 557
DEFAULT, 
# 558
BLOCKING_SYNC, 
# 559
DISABLE_TIMING, 
# 560
INTERPROCESS = 4
# 561
}; 
# 563
explicit Event(CreateFlags flags = DEFAULT); 
# 566
void record(Stream & stream = Stream::Null()); 
# 569
bool queryIfComplete() const; 
# 572
void waitForCompletion(); 
# 575
static float elapsedTime(const Event & start, const Event & end); 
# 577
class Impl; 
# 580
private: Ptr< Impl>  impl_; 
# 581
inline Event(const Ptr< Impl>  & impl); 
# 583
friend struct EventAccessor; 
# 584
}; 
# 601 "/usr/include/opencv2/core/cuda.hpp" 3
__attribute((visibility("default"))) int getCudaEnabledDeviceCount(); 
# 609
__attribute((visibility("default"))) void setDevice(int device); 
# 613
__attribute((visibility("default"))) int getDevice(); 
# 620
__attribute((visibility("default"))) void resetDevice(); 
# 624
enum FeatureSet { 
# 626
FEATURE_SET_COMPUTE_10 = 10, 
# 627
FEATURE_SET_COMPUTE_11, 
# 628
FEATURE_SET_COMPUTE_12, 
# 629
FEATURE_SET_COMPUTE_13, 
# 630
FEATURE_SET_COMPUTE_20 = 20, 
# 631
FEATURE_SET_COMPUTE_21, 
# 632
FEATURE_SET_COMPUTE_30 = 30, 
# 633
FEATURE_SET_COMPUTE_32 = 32, 
# 634
FEATURE_SET_COMPUTE_35 = 35, 
# 635
FEATURE_SET_COMPUTE_50 = 50, 
# 637
GLOBAL_ATOMICS = 11, 
# 638
SHARED_ATOMICS, 
# 639
NATIVE_DOUBLE, 
# 640
WARP_SHUFFLE_FUNCTIONS = 30, 
# 641
DYNAMIC_PARALLELISM = 35
# 642
}; 
# 645
__attribute((visibility("default"))) bool deviceSupports(FeatureSet feature_set); 
# 653
class __attribute((visibility("default"))) TargetArchs { 
# 660
public: static bool builtWith(FeatureSet feature_set); 
# 668
static inline bool has(int major, int minor); 
# 669
static bool hasPtx(int major, int minor); 
# 670
static bool hasBin(int major, int minor); 
# 672
static bool hasEqualOrLessPtx(int major, int minor); 
# 673
static inline bool hasEqualOrGreater(int major, int minor); 
# 674
static bool hasEqualOrGreaterPtx(int major, int minor); 
# 675
static bool hasEqualOrGreaterBin(int major, int minor); 
# 676
}; 
# 680
class __attribute((visibility("default"))) DeviceInfo { 
# 684
public: inline DeviceInfo(); 
# 693 "/usr/include/opencv2/core/cuda.hpp" 3
inline DeviceInfo(int device_id); 
# 697
inline int deviceID() const; 
# 700
const char *name() const; 
# 703
size_t totalGlobalMem() const; 
# 706
size_t sharedMemPerBlock() const; 
# 709
int regsPerBlock() const; 
# 712
int warpSize() const; 
# 715
size_t memPitch() const; 
# 718
int maxThreadsPerBlock() const; 
# 721
Vec3i maxThreadsDim() const; 
# 724
Vec3i maxGridSize() const; 
# 727
int clockRate() const; 
# 730
size_t totalConstMem() const; 
# 733
int majorVersion() const; 
# 736
int minorVersion() const; 
# 739
size_t textureAlignment() const; 
# 742
size_t texturePitchAlignment() const; 
# 745
int multiProcessorCount() const; 
# 748
bool kernelExecTimeoutEnabled() const; 
# 751
bool integrated() const; 
# 754
bool canMapHostMemory() const; 
# 756
enum ComputeMode { 
# 758
ComputeModeDefault, 
# 759
ComputeModeExclusive, 
# 760
ComputeModeProhibited, 
# 761
ComputeModeExclusiveProcess
# 762
}; 
# 765
ComputeMode computeMode() const; 
# 768
int maxTexture1D() const; 
# 771
int maxTexture1DMipmap() const; 
# 774
int maxTexture1DLinear() const; 
# 777
Vec2i maxTexture2D() const; 
# 780
Vec2i maxTexture2DMipmap() const; 
# 783
Vec3i maxTexture2DLinear() const; 
# 786
Vec2i maxTexture2DGather() const; 
# 789
Vec3i maxTexture3D() const; 
# 792
int maxTextureCubemap() const; 
# 795
Vec2i maxTexture1DLayered() const; 
# 798
Vec3i maxTexture2DLayered() const; 
# 801
Vec2i maxTextureCubemapLayered() const; 
# 804
int maxSurface1D() const; 
# 807
Vec2i maxSurface2D() const; 
# 810
Vec3i maxSurface3D() const; 
# 813
Vec2i maxSurface1DLayered() const; 
# 816
Vec3i maxSurface2DLayered() const; 
# 819
int maxSurfaceCubemap() const; 
# 822
Vec2i maxSurfaceCubemapLayered() const; 
# 825
size_t surfaceAlignment() const; 
# 828
bool concurrentKernels() const; 
# 831
bool ECCEnabled() const; 
# 834
int pciBusID() const; 
# 837
int pciDeviceID() const; 
# 840
int pciDomainID() const; 
# 843
bool tccDriver() const; 
# 846
int asyncEngineCount() const; 
# 849
bool unifiedAddressing() const; 
# 852
int memoryClockRate() const; 
# 855
int memoryBusWidth() const; 
# 858
int l2CacheSize() const; 
# 861
int maxThreadsPerMultiProcessor() const; 
# 864
void queryMemory(size_t & totalMemory, size_t & freeMemory) const; 
# 865
inline size_t freeMemory() const; 
# 866
inline size_t totalMemory() const; 
# 874
inline bool supports(FeatureSet feature_set) const; 
# 881
bool isCompatible() const; 
# 884
private: int device_id_; 
# 885
}; 
# 887
__attribute((visibility("default"))) void printCudaDeviceInfo(int device); 
# 888
__attribute((visibility("default"))) void printShortCudaDeviceInfo(int device); 
# 897 "/usr/include/opencv2/core/cuda.hpp" 3
__attribute((visibility("default"))) void convertFp16(InputArray _src, OutputArray _dst, Stream & stream = Stream::Null()); 
# 901
}}
# 51 "/usr/include/opencv2/core/cuda.inl.hpp" 3
namespace cv { namespace cuda { 
# 58
inline GpuMat::GpuMat(Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 60
{ } 
# 63
inline GpuMat::GpuMat(int rows_, int cols_, int type_, Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 65
{ 
# 66
if ((rows_ > 0) && (cols_ > 0)) { 
# 67
this->create(rows_, cols_, type_); }  
# 68
} 
# 71
inline GpuMat::GpuMat(Size size_, int type_, Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 73
{ 
# 74
if (((size_.height) > 0) && ((size_.width) > 0)) { 
# 75
this->create(size_.height, size_.width, type_); }  
# 76
} 
# 79
inline GpuMat::GpuMat(int rows_, int cols_, int type_, Scalar s_, Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 81
{ 
# 82
if ((rows_ > 0) && (cols_ > 0)) 
# 83
{ 
# 84
this->create(rows_, cols_, type_); 
# 85
this->setTo(s_); 
# 86
}  
# 87
} 
# 90
inline GpuMat::GpuMat(Size size_, int type_, Scalar s_, Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 92
{ 
# 93
if (((size_.height) > 0) && ((size_.width) > 0)) 
# 94
{ 
# 95
this->create(size_.height, size_.width, type_); 
# 96
this->setTo(s_); 
# 97
}  
# 98
} 
# 101
inline GpuMat::GpuMat(const GpuMat &m) : flags(m.flags), rows(m.rows), cols(m.cols), step(m.step), data(m.data), refcount(m.refcount), datastart(m.datastart), dataend(m.dataend), allocator(m.allocator) 
# 103
{ 
# 104
if (refcount) { 
# 105
(int)__atomic_fetch_add((unsigned *)(refcount), (unsigned)1, 4); }  
# 106
} 
# 109
inline GpuMat::GpuMat(InputArray arr, Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 111
{ 
# 112
this->upload(arr); 
# 113
} 
# 116
inline GpuMat::~GpuMat() 
# 117
{ 
# 118
this->release(); 
# 119
} 
# 122
inline GpuMat &GpuMat::operator=(const GpuMat &m) 
# 123
{ 
# 124
if (this != (&m)) 
# 125
{ 
# 126
GpuMat temp(m); 
# 127
this->swap(temp); 
# 128
}  
# 130
return *this; 
# 131
} 
# 134
inline void GpuMat::create(Size size_, int type_) 
# 135
{ 
# 136
this->create(size_.height, size_.width, type_); 
# 137
} 
# 140
inline void GpuMat::swap(GpuMat &b) 
# 141
{ 
# 142
std::swap(flags, b.flags); 
# 143
std::swap(rows, b.rows); 
# 144
std::swap(cols, b.cols); 
# 145
std::swap(step, b.step); 
# 146
std::swap(data, b.data); 
# 147
std::swap(datastart, b.datastart); 
# 148
std::swap(dataend, b.dataend); 
# 149
std::swap(refcount, b.refcount); 
# 150
std::swap(allocator, b.allocator); 
# 151
} 
# 154
inline GpuMat GpuMat::clone() const 
# 155
{ 
# 156
GpuMat m; 
# 157
this->copyTo(m); 
# 158
return m; 
# 159
} 
# 162
inline void GpuMat::copyTo(OutputArray dst, InputArray mask) const 
# 163
{ 
# 164
this->copyTo(dst, mask, Stream::Null()); 
# 165
} 
# 168
inline GpuMat &GpuMat::setTo(Scalar s) 
# 169
{ 
# 170
return this->setTo(s, Stream::Null()); 
# 171
} 
# 174
inline GpuMat &GpuMat::setTo(Scalar s, InputArray mask) 
# 175
{ 
# 176
return this->setTo(s, mask, Stream::Null()); 
# 177
} 
# 180
inline void GpuMat::convertTo(OutputArray dst, int rtype) const 
# 181
{ 
# 182
this->convertTo(dst, rtype, Stream::Null()); 
# 183
} 
# 186
inline void GpuMat::convertTo(OutputArray dst, int rtype, double alpha, double beta) const 
# 187
{ 
# 188
this->convertTo(dst, rtype, alpha, beta, Stream::Null()); 
# 189
} 
# 192
inline void GpuMat::convertTo(OutputArray dst, int rtype, double alpha, Stream &stream) const 
# 193
{ 
# 194
this->convertTo(dst, rtype, alpha, (0.0), stream); 
# 195
} 
# 198
inline void GpuMat::assignTo(GpuMat &m, int _type) const 
# 199
{ 
# 200
if (_type < 0) { 
# 201
(m = (*this)); } else { 
# 203
this->convertTo(m, _type); }  
# 204
} 
# 207
inline uchar *GpuMat::ptr(int y) 
# 208
{ 
# 209
; 
# 210
return (data) + ((step) * y); 
# 211
} 
# 214
inline const uchar *GpuMat::ptr(int y) const 
# 215
{ 
# 216
; 
# 217
return (data) + ((step) * y); 
# 218
} 
# 220
template< class _Tp> inline _Tp *
# 221
GpuMat::ptr(int y) 
# 222
{ 
# 223
return (_Tp *)this->ptr(y); 
# 224
} 
# 226
template< class _Tp> inline const _Tp *
# 227
GpuMat::ptr(int y) const 
# 228
{ 
# 229
return (const _Tp *)this->ptr(y); 
# 230
} 
# 232
template< class T> inline 
# 233
GpuMat::operator PtrStepSz< T> () const 
# 234
{ 
# 235
return PtrStepSz< T> (rows, cols, (T *)(data), step); 
# 236
} 
# 238
template< class T> inline 
# 239
GpuMat::operator PtrStep< T> () const 
# 240
{ 
# 241
return PtrStep< T> ((T *)(data), step); 
# 242
} 
# 245
inline GpuMat GpuMat::row(int y) const 
# 246
{ 
# 247
return GpuMat(*this, Range(y, y + 1), Range::all()); 
# 248
} 
# 251
inline GpuMat GpuMat::col(int x) const 
# 252
{ 
# 253
return GpuMat(*this, Range::all(), Range(x, x + 1)); 
# 254
} 
# 257
inline GpuMat GpuMat::rowRange(int startrow, int endrow) const 
# 258
{ 
# 259
return GpuMat(*this, Range(startrow, endrow), Range::all()); 
# 260
} 
# 263
inline GpuMat GpuMat::rowRange(Range r) const 
# 264
{ 
# 265
return GpuMat(*this, r, Range::all()); 
# 266
} 
# 269
inline GpuMat GpuMat::colRange(int startcol, int endcol) const 
# 270
{ 
# 271
return GpuMat(*this, Range::all(), Range(startcol, endcol)); 
# 272
} 
# 275
inline GpuMat GpuMat::colRange(Range r) const 
# 276
{ 
# 277
return GpuMat(*this, Range::all(), r); 
# 278
} 
# 281
inline GpuMat GpuMat::operator()(Range rowRange_, Range colRange_) const 
# 282
{ 
# 283
return GpuMat(*this, rowRange_, colRange_); 
# 284
} 
# 287
inline GpuMat GpuMat::operator()(Rect roi) const 
# 288
{ 
# 289
return GpuMat(*this, roi); 
# 290
} 
# 293
inline bool GpuMat::isContinuous() const 
# 294
{ 
# 295
return ((flags) & (Mat::CONTINUOUS_FLAG)) != 0; 
# 296
} 
# 299
inline size_t GpuMat::elemSize() const 
# 300
{ 
# 301
return ((((flags) & ((512 - 1) << 3)) >> 3) + 1) << ((((((sizeof(size_t) / (4)) + (1)) * (16384)) | (14928)) >> (((flags) & ((1 << 3) - 1)) * 2)) & (3)); 
# 302
} 
# 305
inline size_t GpuMat::elemSize1() const 
# 306
{ 
# 307
return (((sizeof(size_t) << 28) | (138682897)) >> (((flags) & ((1 << 3) - 1)) * 4)) & (15); 
# 308
} 
# 311
inline int GpuMat::type() const 
# 312
{ 
# 313
return (flags) & (((1 << 3) * 512) - 1); 
# 314
} 
# 317
inline int GpuMat::depth() const 
# 318
{ 
# 319
return (flags) & ((1 << 3) - 1); 
# 320
} 
# 323
inline int GpuMat::channels() const 
# 324
{ 
# 325
return (((flags) & ((512 - 1) << 3)) >> 3) + 1; 
# 326
} 
# 329
inline size_t GpuMat::step1() const 
# 330
{ 
# 331
return (step) / this->elemSize1(); 
# 332
} 
# 335
inline Size GpuMat::size() const 
# 336
{ 
# 337
return Size(cols, rows); 
# 338
} 
# 341
inline bool GpuMat::empty() const 
# 342
{ 
# 343
return (data) == (0); 
# 344
} 
# 347
static inline GpuMat createContinuous(int rows, int cols, int type) 
# 348
{ 
# 349
GpuMat m; 
# 350
createContinuous(rows, cols, type, m); 
# 351
return m; 
# 352
} 
# 355
static inline void createContinuous(Size size, int type, OutputArray arr) 
# 356
{ 
# 357
createContinuous(size.height, size.width, type, arr); 
# 358
} 
# 361
static inline GpuMat createContinuous(Size size, int type) 
# 362
{ 
# 363
GpuMat m; 
# 364
createContinuous(size, type, m); 
# 365
return m; 
# 366
} 
# 369
static inline void ensureSizeIsEnough(Size size, int type, OutputArray arr) 
# 370
{ 
# 371
ensureSizeIsEnough(size.height, size.width, type, arr); 
# 372
} 
# 375
static inline void swap(GpuMat &a, GpuMat &b) 
# 376
{ 
# 377
a.swap(b); 
# 378
} 
# 385
inline HostMem::HostMem(AllocType alloc_type_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), alloc_type(alloc_type_) 
# 387
{ 
# 388
} 
# 391
inline HostMem::HostMem(const HostMem &m) : flags(m.flags), rows(m.rows), cols(m.cols), step(m.step), data(m.data), refcount(m.refcount), datastart(m.datastart), dataend(m.dataend), alloc_type(m.alloc_type) 
# 393
{ 
# 394
if (refcount) { 
# 395
(int)__atomic_fetch_add((unsigned *)(refcount), (unsigned)1, 4); }  
# 396
} 
# 399
inline HostMem::HostMem(int rows_, int cols_, int type_, AllocType alloc_type_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), alloc_type(alloc_type_) 
# 401
{ 
# 402
if ((rows_ > 0) && (cols_ > 0)) { 
# 403
this->create(rows_, cols_, type_); }  
# 404
} 
# 407
inline HostMem::HostMem(Size size_, int type_, AllocType alloc_type_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), alloc_type(alloc_type_) 
# 409
{ 
# 410
if (((size_.height) > 0) && ((size_.width) > 0)) { 
# 411
this->create(size_.height, size_.width, type_); }  
# 412
} 
# 415
inline HostMem::HostMem(InputArray arr, AllocType alloc_type_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), alloc_type(alloc_type_) 
# 417
{ 
# 418
(arr.getMat()).copyTo(*this); 
# 419
} 
# 422
inline HostMem::~HostMem() 
# 423
{ 
# 424
this->release(); 
# 425
} 
# 428
inline HostMem &HostMem::operator=(const HostMem &m) 
# 429
{ 
# 430
if (this != (&m)) 
# 431
{ 
# 432
HostMem temp(m); 
# 433
this->swap(temp); 
# 434
}  
# 436
return *this; 
# 437
} 
# 440
inline void HostMem::swap(HostMem &b) 
# 441
{ 
# 442
std::swap(flags, b.flags); 
# 443
std::swap(rows, b.rows); 
# 444
std::swap(cols, b.cols); 
# 445
std::swap(step, b.step); 
# 446
std::swap(data, b.data); 
# 447
std::swap(datastart, b.datastart); 
# 448
std::swap(dataend, b.dataend); 
# 449
std::swap(refcount, b.refcount); 
# 450
std::swap(alloc_type, b.alloc_type); 
# 451
} 
# 454
inline HostMem HostMem::clone() const 
# 455
{ 
# 456
HostMem m(this->size(), this->type(), alloc_type); 
# 457
(this->createMatHeader()).copyTo(m); 
# 458
return m; 
# 459
} 
# 462
inline void HostMem::create(Size size_, int type_) 
# 463
{ 
# 464
this->create(size_.height, size_.width, type_); 
# 465
} 
# 468
inline Mat HostMem::createMatHeader() const 
# 469
{ 
# 470
return Mat(this->size(), this->type(), data, step); 
# 471
} 
# 474
inline bool HostMem::isContinuous() const 
# 475
{ 
# 476
return ((flags) & (Mat::CONTINUOUS_FLAG)) != 0; 
# 477
} 
# 480
inline size_t HostMem::elemSize() const 
# 481
{ 
# 482
return ((((flags) & ((512 - 1) << 3)) >> 3) + 1) << ((((((sizeof(size_t) / (4)) + (1)) * (16384)) | (14928)) >> (((flags) & ((1 << 3) - 1)) * 2)) & (3)); 
# 483
} 
# 486
inline size_t HostMem::elemSize1() const 
# 487
{ 
# 488
return (((sizeof(size_t) << 28) | (138682897)) >> (((flags) & ((1 << 3) - 1)) * 4)) & (15); 
# 489
} 
# 492
inline int HostMem::type() const 
# 493
{ 
# 494
return (flags) & (((1 << 3) * 512) - 1); 
# 495
} 
# 498
inline int HostMem::depth() const 
# 499
{ 
# 500
return (flags) & ((1 << 3) - 1); 
# 501
} 
# 504
inline int HostMem::channels() const 
# 505
{ 
# 506
return (((flags) & ((512 - 1) << 3)) >> 3) + 1; 
# 507
} 
# 510
inline size_t HostMem::step1() const 
# 511
{ 
# 512
return (step) / this->elemSize1(); 
# 513
} 
# 516
inline Size HostMem::size() const 
# 517
{ 
# 518
return Size(cols, rows); 
# 519
} 
# 522
inline bool HostMem::empty() const 
# 523
{ 
# 524
return (data) == (0); 
# 525
} 
# 528
static inline void swap(HostMem &a, HostMem &b) 
# 529
{ 
# 530
a.swap(b); 
# 531
} 
# 538
inline Stream::Stream(const Ptr< Impl>  &impl) : impl_(impl) 
# 540
{ 
# 541
} 
# 548
inline Event::Event(const Ptr< Impl>  &impl) : impl_(impl) 
# 550
{ 
# 551
} 
# 558
inline bool TargetArchs::has(int major, int minor) 
# 559
{ 
# 560
return hasPtx(major, minor) || hasBin(major, minor); 
# 561
} 
# 564
inline bool TargetArchs::hasEqualOrGreater(int major, int minor) 
# 565
{ 
# 566
return hasEqualOrGreaterPtx(major, minor) || hasEqualOrGreaterBin(major, minor); 
# 567
} 
# 570
inline DeviceInfo::DeviceInfo() 
# 571
{ 
# 572
(device_id_) = getDevice(); 
# 573
} 
# 576
inline DeviceInfo::DeviceInfo(int device_id) 
# 577
{ 
# 578
if (!(!((device_id >= 0) && (device_id < getCudaEnabledDeviceCount())))) { ; } else { cv::error(cv::Error::StsAssert, "device_id >= 0 && device_id < getCudaEnabledDeviceCount()", __func__, "/usr/include/opencv2/core/cuda.inl.hpp", 578); }  
# 579
(device_id_) = device_id; 
# 580
} 
# 583
inline int DeviceInfo::deviceID() const 
# 584
{ 
# 585
return device_id_; 
# 586
} 
# 589
inline size_t DeviceInfo::freeMemory() const 
# 590
{ 
# 591
size_t _totalMemory = (0), _freeMemory = (0); 
# 592
this->queryMemory(_totalMemory, _freeMemory); 
# 593
return _freeMemory; 
# 594
} 
# 597
inline size_t DeviceInfo::totalMemory() const 
# 598
{ 
# 599
size_t _totalMemory = (0), _freeMemory = (0); 
# 600
this->queryMemory(_totalMemory, _freeMemory); 
# 601
return _totalMemory; 
# 602
} 
# 605
inline bool DeviceInfo::supports(FeatureSet feature_set) const 
# 606
{ 
# 607
int version = (this->majorVersion() * 10) + this->minorVersion(); 
# 608
return version >= feature_set; 
# 609
} 
# 612
}}
# 618
namespace cv { 
# 621
inline Mat::Mat(const cuda::GpuMat &m) : flags(0), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)) 
# 623
{ 
# 624
m.download(*this); 
# 625
} 
# 627
}
# 51 "/usr/include/opencv2/stitching/detail/warpers.hpp" 3
namespace cv { 
# 52
namespace detail { 
# 59
class __attribute((visibility("default"))) RotationWarper { 
# 62
public: virtual ~RotationWarper() { } 
# 71 "/usr/include/opencv2/stitching/detail/warpers.hpp" 3
virtual Point2f warpPoint(const Point2f & pt, InputArray K, InputArray R) = 0; 
# 82 "/usr/include/opencv2/stitching/detail/warpers.hpp" 3
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) = 0; 
# 94 "/usr/include/opencv2/stitching/detail/warpers.hpp" 3
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst) = 0; 
# 107 "/usr/include/opencv2/stitching/detail/warpers.hpp" 3
virtual void warpBackward(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, Size dst_size, OutputArray dst) = 0; 
# 116
virtual Rect warpRoi(Size src_size, InputArray K, InputArray R) = 0; 
# 118
virtual float getScale() const { return (1.0F); } 
# 119
virtual void setScale(float) { } 
# 120
}; 
# 124
struct __attribute((visibility("default"))) ProjectorBase { 
# 126
void setCameraParams(InputArray K = Mat::eye(3, 3, 5), InputArray R = Mat::eye(3, 3, 5), InputArray T = Mat::zeros(3, 1, 5)); 
# 130
float scale; 
# 131
float k[9]; 
# 132
float rinv[9]; 
# 133
float r_kinv[9]; 
# 134
float k_rinv[9]; 
# 135
float t[3]; 
# 136
}; 
# 140
template< class P> 
# 141
class __attribute((visibility("default"))) RotationWarperBase : public RotationWarper { 
# 144
public: virtual Point2f warpPoint(const Point2f & pt, InputArray K, InputArray R); 
# 146
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap); 
# 148
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst); 
# 151
virtual void warpBackward(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, Size dst_size, OutputArray dst); 
# 154
virtual Rect warpRoi(Size src_size, InputArray K, InputArray R); 
# 156
virtual float getScale() const { return (projector_).scale; } 
# 157
virtual void setScale(float val) { ((projector_).scale) = val; } 
# 162
protected: virtual void detectResultRoi(Size src_size, Point & dst_tl, Point & dst_br); 
# 166
void detectResultRoiByBorder(Size src_size, Point & dst_tl, Point & dst_br); 
# 168
P projector_; 
# 169
}; 
# 172
struct __attribute((visibility("default"))) PlaneProjector : public ProjectorBase { 
# 174
inline void mapForward(float x, float y, float & u, float & v); 
# 175
inline void mapBackward(float u, float v, float & x, float & y); 
# 176
}; 
# 180
class __attribute((visibility("default"))) PlaneWarper : public RotationWarperBase< PlaneProjector>  { 
# 187
public: PlaneWarper(float scale = (1.0F)) { ((projector_).scale) = scale; } 
# 189
virtual Point2f warpPoint(const Point2f & pt, InputArray K, InputArray R); 
# 190
Point2f warpPoint(const Point2f & pt, InputArray K, InputArray R, InputArray T); 
# 192
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, InputArray T, OutputArray xmap, OutputArray ymap); 
# 193
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap); 
# 195
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst); 
# 197
virtual Point warp(InputArray src, InputArray K, InputArray R, InputArray T, int interp_mode, int border_mode, OutputArray dst); 
# 200
virtual Rect warpRoi(Size src_size, InputArray K, InputArray R); 
# 201
Rect warpRoi(Size src_size, InputArray K, InputArray R, InputArray T); 
# 204
protected: virtual void detectResultRoi(Size src_size, Point & dst_tl, Point & dst_br); 
# 205
}; 
# 213
class __attribute((visibility("default"))) AffineWarper : public PlaneWarper { 
# 220
public: AffineWarper(float scale = (1.0F)) : PlaneWarper(scale) { } 
# 222
virtual Point2f warpPoint(const Point2f & pt, InputArray K, InputArray R); 
# 223
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap); 
# 224
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst); 
# 226
virtual Rect warpRoi(Size src_size, InputArray K, InputArray R); 
# 232
protected: void getRTfromHomogeneous(InputArray H, Mat & R, Mat & T); 
# 233
}; 
# 236
struct __attribute((visibility("default"))) SphericalProjector : public ProjectorBase { 
# 238
inline void mapForward(float x, float y, float & u, float & v); 
# 239
inline void mapBackward(float u, float v, float & x, float & y); 
# 240
}; 
# 249 "/usr/include/opencv2/stitching/detail/warpers.hpp" 3
class __attribute((visibility("default"))) SphericalWarper : public RotationWarperBase< SphericalProjector>  { 
# 257
public: SphericalWarper(float scale) { ((projector_).scale) = scale; } 
# 259
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap); 
# 260
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst); 
# 262
protected: virtual void detectResultRoi(Size src_size, Point & dst_tl, Point & dst_br); 
# 263
}; 
# 266
struct __attribute((visibility("default"))) CylindricalProjector : public ProjectorBase { 
# 268
inline void mapForward(float x, float y, float & u, float & v); 
# 269
inline void mapBackward(float u, float v, float & x, float & y); 
# 270
}; 
# 275
class __attribute((visibility("default"))) CylindricalWarper : public RotationWarperBase< CylindricalProjector>  { 
# 282
public: CylindricalWarper(float scale) { ((projector_).scale) = scale; } 
# 284
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap); 
# 285
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst); 
# 287
protected: virtual void detectResultRoi(Size src_size, Point &dst_tl, Point &dst_br) 
# 288
{ 
# 289
this->RotationWarperBase< CylindricalProjector> ::detectResultRoiByBorder(src_size, dst_tl, dst_br); 
# 290
} 
# 291
}; 
# 294
struct __attribute((visibility("default"))) FisheyeProjector : public ProjectorBase { 
# 296
inline void mapForward(float x, float y, float & u, float & v); 
# 297
inline void mapBackward(float u, float v, float & x, float & y); 
# 298
}; 
# 301
class __attribute((visibility("default"))) FisheyeWarper : public RotationWarperBase< FisheyeProjector>  { 
# 304
public: FisheyeWarper(float scale) { ((projector_).scale) = scale; } 
# 305
}; 
# 308
struct __attribute((visibility("default"))) StereographicProjector : public ProjectorBase { 
# 310
inline void mapForward(float x, float y, float & u, float & v); 
# 311
inline void mapBackward(float u, float v, float & x, float & y); 
# 312
}; 
# 315
class __attribute((visibility("default"))) StereographicWarper : public RotationWarperBase< StereographicProjector>  { 
# 318
public: StereographicWarper(float scale) { ((projector_).scale) = scale; } 
# 319
}; 
# 322
struct __attribute((visibility("default"))) CompressedRectilinearProjector : public ProjectorBase { 
# 324
float a, b; 
# 326
inline void mapForward(float x, float y, float & u, float & v); 
# 327
inline void mapBackward(float u, float v, float & x, float & y); 
# 328
}; 
# 331
class __attribute((visibility("default"))) CompressedRectilinearWarper : public RotationWarperBase< CompressedRectilinearProjector>  { 
# 334
public: CompressedRectilinearWarper(float scale, float A = 1, float B = 1) 
# 335
{ 
# 336
((projector_).a) = A; 
# 337
((projector_).b) = B; 
# 338
((projector_).scale) = scale; 
# 339
} 
# 340
}; 
# 343
struct __attribute((visibility("default"))) CompressedRectilinearPortraitProjector : public ProjectorBase { 
# 345
float a, b; 
# 347
inline void mapForward(float x, float y, float & u, float & v); 
# 348
inline void mapBackward(float u, float v, float & x, float & y); 
# 349
}; 
# 352
class __attribute((visibility("default"))) CompressedRectilinearPortraitWarper : public RotationWarperBase< CompressedRectilinearPortraitProjector>  { 
# 355
public: CompressedRectilinearPortraitWarper(float scale, float A = 1, float B = 1) 
# 356
{ 
# 357
((projector_).a) = A; 
# 358
((projector_).b) = B; 
# 359
((projector_).scale) = scale; 
# 360
} 
# 361
}; 
# 364
struct __attribute((visibility("default"))) PaniniProjector : public ProjectorBase { 
# 366
float a, b; 
# 368
inline void mapForward(float x, float y, float & u, float & v); 
# 369
inline void mapBackward(float u, float v, float & x, float & y); 
# 370
}; 
# 373
class __attribute((visibility("default"))) PaniniWarper : public RotationWarperBase< PaniniProjector>  { 
# 376
public: PaniniWarper(float scale, float A = 1, float B = 1) 
# 377
{ 
# 378
((projector_).a) = A; 
# 379
((projector_).b) = B; 
# 380
((projector_).scale) = scale; 
# 381
} 
# 382
}; 
# 385
struct __attribute((visibility("default"))) PaniniPortraitProjector : public ProjectorBase { 
# 387
float a, b; 
# 389
inline void mapForward(float x, float y, float & u, float & v); 
# 390
inline void mapBackward(float u, float v, float & x, float & y); 
# 391
}; 
# 394
class __attribute((visibility("default"))) PaniniPortraitWarper : public RotationWarperBase< PaniniPortraitProjector>  { 
# 397
public: PaniniPortraitWarper(float scale, float A = 1, float B = 1) 
# 398
{ 
# 399
((projector_).a) = A; 
# 400
((projector_).b) = B; 
# 401
((projector_).scale) = scale; 
# 402
} 
# 404
}; 
# 407
struct __attribute((visibility("default"))) MercatorProjector : public ProjectorBase { 
# 409
inline void mapForward(float x, float y, float & u, float & v); 
# 410
inline void mapBackward(float u, float v, float & x, float & y); 
# 411
}; 
# 414
class __attribute((visibility("default"))) MercatorWarper : public RotationWarperBase< MercatorProjector>  { 
# 417
public: MercatorWarper(float scale) { ((projector_).scale) = scale; } 
# 418
}; 
# 421
struct __attribute((visibility("default"))) TransverseMercatorProjector : public ProjectorBase { 
# 423
inline void mapForward(float x, float y, float & u, float & v); 
# 424
inline void mapBackward(float u, float v, float & x, float & y); 
# 425
}; 
# 428
class __attribute((visibility("default"))) TransverseMercatorWarper : public RotationWarperBase< TransverseMercatorProjector>  { 
# 431
public: TransverseMercatorWarper(float scale) { ((projector_).scale) = scale; } 
# 432
}; 
# 435
class __attribute((visibility("default"))) PlaneWarperGpu : public PlaneWarper { 
# 438
public: PlaneWarperGpu(float scale = (1.0F)) : PlaneWarper(scale) { } 
# 440
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) 
# 441
{ 
# 442
Rect result = this->buildMaps(src_size, K, R, d_xmap_, d_ymap_); 
# 443
(d_xmap_).download(xmap); 
# 444
(d_ymap_).download(ymap); 
# 445
return result; 
# 446
} 
# 448
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, InputArray T, OutputArray xmap, OutputArray ymap) 
# 449
{ 
# 450
Rect result = this->buildMaps(src_size, K, R, T, d_xmap_, d_ymap_); 
# 451
(d_xmap_).download(xmap); 
# 452
(d_ymap_).download(ymap); 
# 453
return result; 
# 454
} 
# 456
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray 
# 457
dst) 
# 458
{ 
# 459
(d_src_).upload(src); 
# 460
Point result = this->warp(d_src_, K, R, interp_mode, border_mode, d_dst_); 
# 461
(d_dst_).download(dst); 
# 462
return result; 
# 463
} 
# 465
virtual Point warp(InputArray src, InputArray K, InputArray R, InputArray T, int interp_mode, int border_mode, OutputArray 
# 466
dst) 
# 467
{ 
# 468
(d_src_).upload(src); 
# 469
Point result = this->warp(d_src_, K, R, T, interp_mode, border_mode, d_dst_); 
# 470
(d_dst_).download(dst); 
# 471
return result; 
# 472
} 
# 474
Rect buildMaps(Size src_size, InputArray K, InputArray R, cuda::GpuMat & xmap, cuda::GpuMat & ymap); 
# 476
Rect buildMaps(Size src_size, InputArray K, InputArray R, InputArray T, cuda::GpuMat & xmap, cuda::GpuMat & ymap); 
# 478
Point warp(const cuda::GpuMat & src, InputArray K, InputArray R, int interp_mode, int border_mode, cuda::GpuMat & dst); 
# 481
Point warp(const cuda::GpuMat & src, InputArray K, InputArray R, InputArray T, int interp_mode, int border_mode, cuda::GpuMat & dst); 
# 485
private: cuda::GpuMat d_xmap_, d_ymap_, d_src_, d_dst_; 
# 486
}; 
# 489
class __attribute((visibility("default"))) SphericalWarperGpu : public SphericalWarper { 
# 492
public: SphericalWarperGpu(float scale) : SphericalWarper(scale) { } 
# 494
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) 
# 495
{ 
# 496
Rect result = this->buildMaps(src_size, K, R, d_xmap_, d_ymap_); 
# 497
(d_xmap_).download(xmap); 
# 498
(d_ymap_).download(ymap); 
# 499
return result; 
# 500
} 
# 502
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray 
# 503
dst) 
# 504
{ 
# 505
(d_src_).upload(src); 
# 506
Point result = this->warp(d_src_, K, R, interp_mode, border_mode, d_dst_); 
# 507
(d_dst_).download(dst); 
# 508
return result; 
# 509
} 
# 511
Rect buildMaps(Size src_size, InputArray K, InputArray R, cuda::GpuMat & xmap, cuda::GpuMat & ymap); 
# 513
Point warp(const cuda::GpuMat & src, InputArray K, InputArray R, int interp_mode, int border_mode, cuda::GpuMat & dst); 
# 517
private: cuda::GpuMat d_xmap_, d_ymap_, d_src_, d_dst_; 
# 518
}; 
# 521
class __attribute((visibility("default"))) CylindricalWarperGpu : public CylindricalWarper { 
# 524
public: CylindricalWarperGpu(float scale) : CylindricalWarper(scale) { } 
# 526
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) 
# 527
{ 
# 528
Rect result = this->buildMaps(src_size, K, R, d_xmap_, d_ymap_); 
# 529
(d_xmap_).download(xmap); 
# 530
(d_ymap_).download(ymap); 
# 531
return result; 
# 532
} 
# 534
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray 
# 535
dst) 
# 536
{ 
# 537
(d_src_).upload(src); 
# 538
Point result = this->warp(d_src_, K, R, interp_mode, border_mode, d_dst_); 
# 539
(d_dst_).download(dst); 
# 540
return result; 
# 541
} 
# 543
Rect buildMaps(Size src_size, InputArray K, InputArray R, cuda::GpuMat & xmap, cuda::GpuMat & ymap); 
# 545
Point warp(const cuda::GpuMat & src, InputArray K, InputArray R, int interp_mode, int border_mode, cuda::GpuMat & dst); 
# 549
private: cuda::GpuMat d_xmap_, d_ymap_, d_src_, d_dst_; 
# 550
}; 
# 553
struct SphericalPortraitProjector : public ProjectorBase { 
# 555
inline void mapForward(float x, float y, float & u, float & v); 
# 556
inline void mapBackward(float u, float v, float & x, float & y); 
# 557
}; 
# 562
class __attribute((visibility("default"))) SphericalPortraitWarper : public RotationWarperBase< SphericalPortraitProjector>  { 
# 565
public: SphericalPortraitWarper(float scale) { ((projector_).scale) = scale; } 
# 568
protected: virtual void detectResultRoi(Size src_size, Point & dst_tl, Point & dst_br); 
# 569
}; 
# 571
struct CylindricalPortraitProjector : public ProjectorBase { 
# 573
inline void mapForward(float x, float y, float & u, float & v); 
# 574
inline void mapBackward(float u, float v, float & x, float & y); 
# 575
}; 
# 578
class __attribute((visibility("default"))) CylindricalPortraitWarper : public RotationWarperBase< CylindricalPortraitProjector>  { 
# 581
public: CylindricalPortraitWarper(float scale) { ((projector_).scale) = scale; } 
# 584
protected: virtual void detectResultRoi(Size src_size, Point &dst_tl, Point &dst_br) 
# 585
{ 
# 586
this->RotationWarperBase< CylindricalPortraitProjector> ::detectResultRoiByBorder(src_size, dst_tl, dst_br); 
# 587
} 
# 588
}; 
# 590
struct PlanePortraitProjector : public ProjectorBase { 
# 592
inline void mapForward(float x, float y, float & u, float & v); 
# 593
inline void mapBackward(float u, float v, float & x, float & y); 
# 594
}; 
# 597
class __attribute((visibility("default"))) PlanePortraitWarper : public RotationWarperBase< PlanePortraitProjector>  { 
# 600
public: PlanePortraitWarper(float scale) { ((projector_).scale) = scale; } 
# 603
protected: virtual void detectResultRoi(Size src_size, Point &dst_tl, Point &dst_br) 
# 604
{ 
# 605
this->RotationWarperBase< PlanePortraitProjector> ::detectResultRoiByBorder(src_size, dst_tl, dst_br); 
# 606
} 
# 607
}; 
# 611
}
# 612
}
# 52 "/usr/include/opencv2/stitching/detail/warpers_inl.hpp" 3
namespace cv { 
# 53
namespace detail { 
# 55
template< class P> Point2f 
# 56
RotationWarperBase< P> ::warpPoint(const Point2f &pt, InputArray K, InputArray R) 
# 57
{ 
# 58
((projector_).setCameraParams(K, R)); 
# 59
Point2f uv; 
# 60
((projector_).mapForward(pt.x, pt.y, uv.x, uv.y)); 
# 61
return uv; 
# 62
} 
# 65
template< class P> Rect 
# 66
RotationWarperBase< P> ::buildMaps(Size src_size, InputArray K, InputArray R, OutputArray _xmap, OutputArray _ymap) 
# 67
{ 
# 68
((projector_).setCameraParams(K, R)); 
# 70
Point dst_tl, dst_br; 
# 71
detectResultRoi(src_size, dst_tl, dst_br); 
# 73
_xmap.create(((dst_br.y) - (dst_tl.y)) + 1, ((dst_br.x) - (dst_tl.x)) + 1, 5); 
# 74
_ymap.create(((dst_br.y) - (dst_tl.y)) + 1, ((dst_br.x) - (dst_tl.x)) + 1, 5); 
# 76
Mat xmap = _xmap.getMat(), ymap = _ymap.getMat(); 
# 78
float x, y; 
# 79
for (int v = dst_tl.y; v <= (dst_br.y); ++v) 
# 80
{ 
# 81
for (int u = dst_tl.x; u <= (dst_br.x); ++u) 
# 82
{ 
# 83
((projector_).mapBackward(static_cast< float>(u), static_cast< float>(v), x, y)); 
# 84
xmap.template at< float> (v - (dst_tl.y), u - (dst_tl.x)) = x; 
# 85
ymap.template at< float> (v - (dst_tl.y), u - (dst_tl.x)) = y; 
# 86
}  
# 87
}  
# 89
return Rect(dst_tl, dst_br); 
# 90
} 
# 93
template< class P> Point 
# 94
RotationWarperBase< P> ::warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray 
# 95
dst) 
# 96
{ 
# 97
UMat xmap, ymap; 
# 98
Rect dst_roi = buildMaps(src.size(), K, R, xmap, ymap); 
# 100
dst.create((dst_roi.height) + 1, (dst_roi.width) + 1, src.type()); 
# 101
remap(src, dst, xmap, ymap, interp_mode, border_mode); 
# 103
return dst_roi.tl(); 
# 104
} 
# 107
template< class P> void 
# 108
RotationWarperBase< P> ::warpBackward(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, Size 
# 109
dst_size, OutputArray dst) 
# 110
{ 
# 111
((projector_).setCameraParams(K, R)); 
# 113
Point src_tl, src_br; 
# 114
detectResultRoi(dst_size, src_tl, src_br); 
# 116
Size size = src.size(); 
# 117
if (!(!(((((src_br.x) - (src_tl.x)) + 1) == (size.width)) && ((((src_br.y) - (src_tl.y)) + 1) == (size.height))))) { ; } else { cv::error(cv::Error::StsAssert, "src_br.x - src_tl.x + 1 == size.width && src_br.y - src_tl.y + 1 == size.height", __func__, "/usr/include/opencv2/stitching/detail/warpers_inl.hpp", 117); }  
# 119
Mat xmap(dst_size, 5); 
# 120
Mat ymap(dst_size, 5); 
# 122
float u, v; 
# 123
for (int y = 0; y < (dst_size.height); ++y) 
# 124
{ 
# 125
for (int x = 0; x < (dst_size.width); ++x) 
# 126
{ 
# 127
((projector_).mapForward(static_cast< float>(x), static_cast< float>(y), u, v)); 
# 128
xmap.template at< float> (y, x) = (u - (src_tl.x)); 
# 129
ymap.template at< float> (y, x) = (v - (src_tl.y)); 
# 130
}  
# 131
}  
# 133
dst.create(dst_size, src.type()); 
# 134
remap(src, dst, xmap, ymap, interp_mode, border_mode); 
# 135
} 
# 138
template< class P> Rect 
# 139
RotationWarperBase< P> ::warpRoi(Size src_size, InputArray K, InputArray R) 
# 140
{ 
# 141
((projector_).setCameraParams(K, R)); 
# 143
Point dst_tl, dst_br; 
# 144
detectResultRoi(src_size, dst_tl, dst_br); 
# 146
return Rect(dst_tl, Point((dst_br.x) + 1, (dst_br.y) + 1)); 
# 147
} 
# 150
template< class P> void 
# 151
RotationWarperBase< P> ::detectResultRoi(Size src_size, Point &dst_tl, Point &dst_br) 
# 152
{ 
# 153
float tl_uf = std::numeric_limits< float> ::max(); 
# 154
float tl_vf = std::numeric_limits< float> ::max(); 
# 155
float br_uf = -std::numeric_limits< float> ::max(); 
# 156
float br_vf = -std::numeric_limits< float> ::max(); 
# 158
float u, v; 
# 159
for (int y = 0; y < (src_size.height); ++y) 
# 160
{ 
# 161
for (int x = 0; x < (src_size.width); ++x) 
# 162
{ 
# 163
((projector_).mapForward(static_cast< float>(x), static_cast< float>(y), u, v)); 
# 164
tl_uf = (std::min)(tl_uf, u); tl_vf = (std::min)(tl_vf, v); 
# 165
br_uf = (std::max)(br_uf, u); br_vf = (std::max)(br_vf, v); 
# 166
}  
# 167
}  
# 169
(dst_tl.x) = (static_cast< int>(tl_uf)); 
# 170
(dst_tl.y) = (static_cast< int>(tl_vf)); 
# 171
(dst_br.x) = (static_cast< int>(br_uf)); 
# 172
(dst_br.y) = (static_cast< int>(br_vf)); 
# 173
} 
# 176
template< class P> void 
# 177
RotationWarperBase< P> ::detectResultRoiByBorder(Size src_size, Point &dst_tl, Point &dst_br) 
# 178
{ 
# 179
float tl_uf = std::numeric_limits< float> ::max(); 
# 180
float tl_vf = std::numeric_limits< float> ::max(); 
# 181
float br_uf = -std::numeric_limits< float> ::max(); 
# 182
float br_vf = -std::numeric_limits< float> ::max(); 
# 184
float u, v; 
# 185
for (float x = (0); x < (src_size.width); ++x) 
# 186
{ 
# 187
((projector_).mapForward(static_cast< float>(x), 0, u, v)); 
# 188
tl_uf = (std::min)(tl_uf, u); tl_vf = (std::min)(tl_vf, v); 
# 189
br_uf = (std::max)(br_uf, u); br_vf = (std::max)(br_vf, v); 
# 191
((projector_).mapForward(static_cast< float>(x), static_cast< float>((src_size.height) - 1), u, v)); 
# 192
tl_uf = (std::min)(tl_uf, u); tl_vf = (std::min)(tl_vf, v); 
# 193
br_uf = (std::max)(br_uf, u); br_vf = (std::max)(br_vf, v); 
# 194
}  
# 195
for (int y = 0; y < (src_size.height); ++y) 
# 196
{ 
# 197
((projector_).mapForward(0, static_cast< float>(y), u, v)); 
# 198
tl_uf = (std::min)(tl_uf, u); tl_vf = (std::min)(tl_vf, v); 
# 199
br_uf = (std::max)(br_uf, u); br_vf = (std::max)(br_vf, v); 
# 201
((projector_).mapForward(static_cast< float>((src_size.width) - 1), static_cast< float>(y), u, v)); 
# 202
tl_uf = (std::min)(tl_uf, u); tl_vf = (std::min)(tl_vf, v); 
# 203
br_uf = (std::max)(br_uf, u); br_vf = (std::max)(br_vf, v); 
# 204
}  
# 206
(dst_tl.x) = (static_cast< int>(tl_uf)); 
# 207
(dst_tl.y) = (static_cast< int>(tl_vf)); 
# 208
(dst_br.x) = (static_cast< int>(br_uf)); 
# 209
(dst_br.y) = (static_cast< int>(br_vf)); 
# 210
} 
# 214
inline void PlaneProjector::mapForward(float x, float y, float &u, float &v) 
# 215
{ 
# 216
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 217
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 218
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 220
x_ = (((t)[0]) + ((x_ / z_) * ((1) - ((t)[2])))); 
# 221
y_ = (((t)[1]) + ((y_ / z_) * ((1) - ((t)[2])))); 
# 223
u = ((scale) * x_); 
# 224
v = ((scale) * y_); 
# 225
} 
# 229
inline void PlaneProjector::mapBackward(float u, float v, float &x, float &y) 
# 230
{ 
# 231
u = ((u / (scale)) - ((t)[0])); 
# 232
v = ((v / (scale)) - ((t)[1])); 
# 234
float z; 
# 235
x = (((((k_rinv)[0]) * u) + (((k_rinv)[1]) * v)) + (((k_rinv)[2]) * ((1) - ((t)[2])))); 
# 236
y = (((((k_rinv)[3]) * u) + (((k_rinv)[4]) * v)) + (((k_rinv)[5]) * ((1) - ((t)[2])))); 
# 237
z = (((((k_rinv)[6]) * u) + (((k_rinv)[7]) * v)) + (((k_rinv)[8]) * ((1) - ((t)[2])))); 
# 239
x /= z; 
# 240
y /= z; 
# 241
} 
# 245
inline void SphericalProjector::mapForward(float x, float y, float &u, float &v) 
# 246
{ 
# 247
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 248
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 249
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 251
u = ((scale) * atan2f(x_, z_)); 
# 252
float w = y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_)); 
# 253
v = ((scale) * ((static_cast< float>((3.141592653589793116))) - acosf((w == w) ? w : (0)))); 
# 254
} 
# 258
inline void SphericalProjector::mapBackward(float u, float v, float &x, float &y) 
# 259
{ 
# 260
u /= (scale); 
# 261
v /= (scale); 
# 263
float sinv = sinf((static_cast< float>((3.141592653589793116))) - v); 
# 264
float x_ = sinv * sinf(u); 
# 265
float y_ = cosf((static_cast< float>((3.141592653589793116))) - v); 
# 266
float z_ = sinv * cosf(u); 
# 268
float z; 
# 269
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 270
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 271
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 273
if (z > (0)) { x /= z; y /= z; } else { 
# 274
x = (y = (-1)); }  
# 275
} 
# 279
inline void CylindricalProjector::mapForward(float x, float y, float &u, float &v) 
# 280
{ 
# 281
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 282
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 283
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 285
u = ((scale) * atan2f(x_, z_)); 
# 286
v = (((scale) * y_) / sqrtf((x_ * x_) + (z_ * z_))); 
# 287
} 
# 291
inline void CylindricalProjector::mapBackward(float u, float v, float &x, float &y) 
# 292
{ 
# 293
u /= (scale); 
# 294
v /= (scale); 
# 296
float x_ = sinf(u); 
# 297
float y_ = v; 
# 298
float z_ = cosf(u); 
# 300
float z; 
# 301
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 302
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 303
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 305
if (z > (0)) { x /= z; y /= z; } else { 
# 306
x = (y = (-1)); }  
# 307
} 
# 310
inline void FisheyeProjector::mapForward(float x, float y, float &u, float &v) 
# 311
{ 
# 312
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 313
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 314
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 316
float u_ = atan2f(x_, z_); 
# 317
float v_ = ((float)(3.141592653589793116)) - acosf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 319
u = (((scale) * v_) * cosf(u_)); 
# 320
v = (((scale) * v_) * sinf(u_)); 
# 321
} 
# 324
inline void FisheyeProjector::mapBackward(float u, float v, float &x, float &y) 
# 325
{ 
# 326
u /= (scale); 
# 327
v /= (scale); 
# 329
float u_ = atan2f(v, u); 
# 330
float v_ = sqrtf((u * u) + (v * v)); 
# 332
float sinv = sinf(((float)(3.141592653589793116)) - v_); 
# 333
float x_ = sinv * sinf(u_); 
# 334
float y_ = cosf(((float)(3.141592653589793116)) - v_); 
# 335
float z_ = sinv * cosf(u_); 
# 337
float z; 
# 338
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 339
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 340
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 342
if (z > (0)) { x /= z; y /= z; } else { 
# 343
x = (y = (-1)); }  
# 344
} 
# 347
inline void StereographicProjector::mapForward(float x, float y, float &u, float &v) 
# 348
{ 
# 349
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 350
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 351
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 353
float u_ = atan2f(x_, z_); 
# 354
float v_ = ((float)(3.141592653589793116)) - acosf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 356
float r = sinf(v_) / ((1) - cosf(v_)); 
# 358
u = (((scale) * r) * cos(u_)); 
# 359
v = (((scale) * r) * sin(u_)); 
# 360
} 
# 363
inline void StereographicProjector::mapBackward(float u, float v, float &x, float &y) 
# 364
{ 
# 365
u /= (scale); 
# 366
v /= (scale); 
# 368
float u_ = atan2f(v, u); 
# 369
float r = sqrtf((u * u) + (v * v)); 
# 370
float v_ = (2) * atanf((1.0F) / r); 
# 372
float sinv = sinf(((float)(3.141592653589793116)) - v_); 
# 373
float x_ = sinv * sinf(u_); 
# 374
float y_ = cosf(((float)(3.141592653589793116)) - v_); 
# 375
float z_ = sinv * cosf(u_); 
# 377
float z; 
# 378
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 379
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 380
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 382
if (z > (0)) { x /= z; y /= z; } else { 
# 383
x = (y = (-1)); }  
# 384
} 
# 387
inline void CompressedRectilinearProjector::mapForward(float x, float y, float &u, float &v) 
# 388
{ 
# 389
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 390
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 391
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 393
float u_ = atan2f(x_, z_); 
# 394
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 396
u = (((scale) * (a)) * tanf(u_ / (a))); 
# 397
v = ((((scale) * (b)) * tanf(v_)) / cosf(u_)); 
# 398
} 
# 401
inline void CompressedRectilinearProjector::mapBackward(float u, float v, float &x, float &y) 
# 402
{ 
# 403
u /= (scale); 
# 404
v /= (scale); 
# 406
float aatg = (a) * atanf(u / (a)); 
# 407
float u_ = aatg; 
# 408
float v_ = atanf((v * cosf(aatg)) / (b)); 
# 410
float cosv = cosf(v_); 
# 411
float x_ = cosv * sinf(u_); 
# 412
float y_ = sinf(v_); 
# 413
float z_ = cosv * cosf(u_); 
# 415
float z; 
# 416
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 417
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 418
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 420
if (z > (0)) { x /= z; y /= z; } else { 
# 421
x = (y = (-1)); }  
# 422
} 
# 425
inline void CompressedRectilinearPortraitProjector::mapForward(float x, float y, float &u, float &v) 
# 426
{ 
# 427
float y_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 428
float x_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 429
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 431
float u_ = atan2f(x_, z_); 
# 432
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 434
u = (((-(scale)) * (a)) * tanf(u_ / (a))); 
# 435
v = ((((scale) * (b)) * tanf(v_)) / cosf(u_)); 
# 436
} 
# 439
inline void CompressedRectilinearPortraitProjector::mapBackward(float u, float v, float &x, float &y) 
# 440
{ 
# 441
u /= (-(scale)); 
# 442
v /= (scale); 
# 444
float aatg = (a) * atanf(u / (a)); 
# 445
float u_ = aatg; 
# 446
float v_ = atanf((v * cosf(aatg)) / (b)); 
# 448
float cosv = cosf(v_); 
# 449
float y_ = cosv * sinf(u_); 
# 450
float x_ = sinf(v_); 
# 451
float z_ = cosv * cosf(u_); 
# 453
float z; 
# 454
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 455
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 456
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 458
if (z > (0)) { x /= z; y /= z; } else { 
# 459
x = (y = (-1)); }  
# 460
} 
# 463
inline void PaniniProjector::mapForward(float x, float y, float &u, float &v) 
# 464
{ 
# 465
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 466
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 467
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 469
float u_ = atan2f(x_, z_); 
# 470
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 472
float tg = (a) * tanf(u_ / (a)); 
# 473
u = ((scale) * tg); 
# 475
float sinu = sinf(u_); 
# 476
if ((fabs(sinu)) < (9.999999999999999547e-08)) { 
# 477
v = (((scale) * (b)) * tanf(v_)); } else { 
# 479
v = (((((scale) * (b)) * tg) * tanf(v_)) / sinu); }  
# 480
} 
# 483
inline void PaniniProjector::mapBackward(float u, float v, float &x, float &y) 
# 484
{ 
# 485
u /= (scale); 
# 486
v /= (scale); 
# 488
float lamda = (a) * atanf(u / (a)); 
# 489
float u_ = lamda; 
# 491
float v_; 
# 492
if ((fabs(lamda)) > (9.999999999999999547e-08)) { 
# 493
v_ = atanf((v * sinf(lamda)) / (((b) * (a)) * tanf(lamda / (a)))); } else { 
# 495
v_ = atanf(v / (b)); }  
# 497
float cosv = cosf(v_); 
# 498
float x_ = cosv * sinf(u_); 
# 499
float y_ = sinf(v_); 
# 500
float z_ = cosv * cosf(u_); 
# 502
float z; 
# 503
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 504
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 505
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 507
if (z > (0)) { x /= z; y /= z; } else { 
# 508
x = (y = (-1)); }  
# 509
} 
# 512
inline void PaniniPortraitProjector::mapForward(float x, float y, float &u, float &v) 
# 513
{ 
# 514
float y_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 515
float x_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 516
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 518
float u_ = atan2f(x_, z_); 
# 519
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 521
float tg = (a) * tanf(u_ / (a)); 
# 522
u = ((-(scale)) * tg); 
# 524
float sinu = sinf(u_); 
# 525
if ((fabs(sinu)) < (9.999999999999999547e-08)) { 
# 526
v = (((scale) * (b)) * tanf(v_)); } else { 
# 528
v = (((((scale) * (b)) * tg) * tanf(v_)) / sinu); }  
# 529
} 
# 532
inline void PaniniPortraitProjector::mapBackward(float u, float v, float &x, float &y) 
# 533
{ 
# 534
u /= (-(scale)); 
# 535
v /= (scale); 
# 537
float lamda = (a) * atanf(u / (a)); 
# 538
float u_ = lamda; 
# 540
float v_; 
# 541
if ((fabs(lamda)) > (9.999999999999999547e-08)) { 
# 542
v_ = atanf((v * sinf(lamda)) / (((b) * (a)) * tanf(lamda / (a)))); } else { 
# 544
v_ = atanf(v / (b)); }  
# 546
float cosv = cosf(v_); 
# 547
float y_ = cosv * sinf(u_); 
# 548
float x_ = sinf(v_); 
# 549
float z_ = cosv * cosf(u_); 
# 551
float z; 
# 552
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 553
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 554
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 556
if (z > (0)) { x /= z; y /= z; } else { 
# 557
x = (y = (-1)); }  
# 558
} 
# 561
inline void MercatorProjector::mapForward(float x, float y, float &u, float &v) 
# 562
{ 
# 563
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 564
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 565
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 567
float u_ = atan2f(x_, z_); 
# 568
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 570
u = ((scale) * u_); 
# 571
v = ((scale) * logf(tanf(((float)((3.141592653589793116) / (4))) + (v_ / (2))))); 
# 572
} 
# 575
inline void MercatorProjector::mapBackward(float u, float v, float &x, float &y) 
# 576
{ 
# 577
u /= (scale); 
# 578
v /= (scale); 
# 580
float v_ = atanf(sinhf(v)); 
# 581
float u_ = u; 
# 583
float cosv = cosf(v_); 
# 584
float x_ = cosv * sinf(u_); 
# 585
float y_ = sinf(v_); 
# 586
float z_ = cosv * cosf(u_); 
# 588
float z; 
# 589
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 590
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 591
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 593
if (z > (0)) { x /= z; y /= z; } else { 
# 594
x = (y = (-1)); }  
# 595
} 
# 598
inline void TransverseMercatorProjector::mapForward(float x, float y, float &u, float &v) 
# 599
{ 
# 600
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 601
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 602
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 604
float u_ = atan2f(x_, z_); 
# 605
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 607
float B = cosf(v_) * sinf(u_); 
# 609
u = (((scale) / (2)) * logf(((1) + B) / ((1) - B))); 
# 610
v = ((scale) * atan2f(tanf(v_), cosf(u_))); 
# 611
} 
# 614
inline void TransverseMercatorProjector::mapBackward(float u, float v, float &x, float &y) 
# 615
{ 
# 616
u /= (scale); 
# 617
v /= (scale); 
# 619
float v_ = asinf(sinf(v) / coshf(u)); 
# 620
float u_ = atan2f(sinhf(u), cos(v)); 
# 622
float cosv = cosf(v_); 
# 623
float x_ = cosv * sinf(u_); 
# 624
float y_ = sinf(v_); 
# 625
float z_ = cosv * cosf(u_); 
# 627
float z; 
# 628
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 629
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 630
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 632
if (z > (0)) { x /= z; y /= z; } else { 
# 633
x = (y = (-1)); }  
# 634
} 
# 637
inline void SphericalPortraitProjector::mapForward(float x, float y, float &u0, float &v0) 
# 638
{ 
# 639
float x0_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 640
float y0_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 641
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 643
float x_ = y0_; 
# 644
float y_ = x0_; 
# 645
float u, v; 
# 647
u = ((scale) * atan2f(x_, z_)); 
# 648
v = ((scale) * ((static_cast< float>((3.141592653589793116))) - acosf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))))); 
# 650
u0 = (-u); 
# 651
v0 = v; 
# 652
} 
# 656
inline void SphericalPortraitProjector::mapBackward(float u0, float v0, float &x, float &y) 
# 657
{ 
# 658
float u, v; 
# 659
u = (-u0); 
# 660
v = v0; 
# 662
u /= (scale); 
# 663
v /= (scale); 
# 665
float sinv = sinf((static_cast< float>((3.141592653589793116))) - v); 
# 666
float x0_ = sinv * sinf(u); 
# 667
float y0_ = cosf((static_cast< float>((3.141592653589793116))) - v); 
# 668
float z_ = sinv * cosf(u); 
# 670
float x_ = y0_; 
# 671
float y_ = x0_; 
# 673
float z; 
# 674
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 675
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 676
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 678
if (z > (0)) { x /= z; y /= z; } else { 
# 679
x = (y = (-1)); }  
# 680
} 
# 683
inline void CylindricalPortraitProjector::mapForward(float x, float y, float &u0, float &v0) 
# 684
{ 
# 685
float x0_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 686
float y0_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 687
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 689
float x_ = y0_; 
# 690
float y_ = x0_; 
# 691
float u, v; 
# 693
u = ((scale) * atan2f(x_, z_)); 
# 694
v = (((scale) * y_) / sqrtf((x_ * x_) + (z_ * z_))); 
# 696
u0 = (-u); 
# 697
v0 = v; 
# 698
} 
# 702
inline void CylindricalPortraitProjector::mapBackward(float u0, float v0, float &x, float &y) 
# 703
{ 
# 704
float u, v; 
# 705
u = (-u0); 
# 706
v = v0; 
# 708
u /= (scale); 
# 709
v /= (scale); 
# 711
float x0_ = sinf(u); 
# 712
float y0_ = v; 
# 713
float z_ = cosf(u); 
# 715
float x_ = y0_; 
# 716
float y_ = x0_; 
# 718
float z; 
# 719
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 720
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 721
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 723
if (z > (0)) { x /= z; y /= z; } else { 
# 724
x = (y = (-1)); }  
# 725
} 
# 728
inline void PlanePortraitProjector::mapForward(float x, float y, float &u0, float &v0) 
# 729
{ 
# 730
float x0_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 731
float y0_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 732
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 734
float x_ = y0_; 
# 735
float y_ = x0_; 
# 737
x_ = (((t)[0]) + ((x_ / z_) * ((1) - ((t)[2])))); 
# 738
y_ = (((t)[1]) + ((y_ / z_) * ((1) - ((t)[2])))); 
# 740
float u, v; 
# 741
u = ((scale) * x_); 
# 742
v = ((scale) * y_); 
# 744
u0 = (-u); 
# 745
v0 = v; 
# 746
} 
# 750
inline void PlanePortraitProjector::mapBackward(float u0, float v0, float &x, float &y) 
# 751
{ 
# 752
float u, v; 
# 753
u = (-u0); 
# 754
v = v0; 
# 756
u = ((u / (scale)) - ((t)[0])); 
# 757
v = ((v / (scale)) - ((t)[1])); 
# 759
float z; 
# 760
x = (((((k_rinv)[0]) * v) + (((k_rinv)[1]) * u)) + (((k_rinv)[2]) * ((1) - ((t)[2])))); 
# 761
y = (((((k_rinv)[3]) * v) + (((k_rinv)[4]) * u)) + (((k_rinv)[5]) * ((1) - ((t)[2])))); 
# 762
z = (((((k_rinv)[6]) * v) + (((k_rinv)[7]) * u)) + (((k_rinv)[8]) * ((1) - ((t)[2])))); 
# 764
x /= z; 
# 765
y /= z; 
# 766
} 
# 769
}
# 770
}
# 48 "/usr/include/opencv2/stitching/warpers.hpp" 3
namespace cv { 
# 55
class WarperCreator { 
# 58
public: virtual ~WarperCreator() { } 
# 59
virtual Ptr< detail::RotationWarper>  create(float scale) const = 0; 
# 60
}; 
# 65
class PlaneWarper : public WarperCreator { 
# 68
public: virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::PlaneWarper> (scale); } 
# 69
}; 
# 74
class AffineWarper : public WarperCreator { 
# 77
public: virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::AffineWarper> (scale); } 
# 78
}; 
# 83
class CylindricalWarper : public WarperCreator { 
# 86
public: virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::CylindricalWarper> (scale); } 
# 87
}; 
# 90
class SphericalWarper : public WarperCreator { 
# 93
public: virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::SphericalWarper> (scale); } 
# 94
}; 
# 96
class FisheyeWarper : public WarperCreator { 
# 99
public: virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::FisheyeWarper> (scale); } 
# 100
}; 
# 102
class StereographicWarper : public WarperCreator { 
# 105
public: virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::StereographicWarper> (scale); } 
# 106
}; 
# 108
class CompressedRectilinearWarper : public WarperCreator { 
# 110
float a, b; 
# 112
public: CompressedRectilinearWarper(float A = 1, float B = 1) 
# 113
{ 
# 114
(a) = A; (b) = B; 
# 115
} 
# 116
virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::CompressedRectilinearWarper> (scale, a, b); } 
# 117
}; 
# 119
class CompressedRectilinearPortraitWarper : public WarperCreator { 
# 121
float a, b; 
# 123
public: CompressedRectilinearPortraitWarper(float A = 1, float B = 1) 
# 124
{ 
# 125
(a) = A; (b) = B; 
# 126
} 
# 127
virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::CompressedRectilinearPortraitWarper> (scale, a, b); } 
# 128
}; 
# 130
class PaniniWarper : public WarperCreator { 
# 132
float a, b; 
# 134
public: PaniniWarper(float A = 1, float B = 1) 
# 135
{ 
# 136
(a) = A; (b) = B; 
# 137
} 
# 138
virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::PaniniWarper> (scale, a, b); } 
# 139
}; 
# 141
class PaniniPortraitWarper : public WarperCreator { 
# 143
float a, b; 
# 145
public: PaniniPortraitWarper(float A = 1, float B = 1) 
# 146
{ 
# 147
(a) = A; (b) = B; 
# 148
} 
# 149
virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::PaniniPortraitWarper> (scale, a, b); } 
# 150
}; 
# 152
class MercatorWarper : public WarperCreator { 
# 155
public: virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::MercatorWarper> (scale); } 
# 156
}; 
# 158
class TransverseMercatorWarper : public WarperCreator { 
# 161
public: virtual Ptr< detail::RotationWarper>  create(float scale) const { return makePtr< detail::TransverseMercatorWarper> (scale); } 
# 162
}; 
# 190 "/usr/include/opencv2/stitching/warpers.hpp" 3
}
# 55 "/usr/include/opencv2/stitching/detail/matchers.hpp" 3
namespace cv { 
# 56
namespace detail { 
# 62
struct __attribute((visibility("default"))) ImageFeatures { 
# 64
int img_idx; 
# 65
Size img_size; 
# 66
std::vector< KeyPoint>  keypoints; 
# 67
UMat descriptors; 
# 68
}; 
# 71
class __attribute((visibility("default"))) FeaturesFinder { 
# 74
public: virtual ~FeaturesFinder() { } 
# 76
void operator()(InputArray image, ImageFeatures & features); 
# 85 "/usr/include/opencv2/stitching/detail/matchers.hpp" 3
void operator()(InputArray image, ImageFeatures & features, const std::vector< Rect_< int> >  & rois); 
# 94 "/usr/include/opencv2/stitching/detail/matchers.hpp" 3
void operator()(InputArrayOfArrays images, std::vector< ImageFeatures>  & features, const std::vector< std::vector< Rect_< int> > >  & rois); 
# 97
void operator()(InputArrayOfArrays images, std::vector< ImageFeatures>  & features); 
# 99
virtual void collectGarbage() { } 
# 115
protected: virtual void find(InputArray image, ImageFeatures & features) = 0; 
# 119
bool isThreadSafe() const; 
# 120
}; 
# 126
class __attribute((visibility("default"))) SurfFeaturesFinder : public FeaturesFinder { 
# 129
public: SurfFeaturesFinder(double hess_thresh = (300.0), int num_octaves = 3, int num_layers = 4, int num_octaves_descr = 3, int num_layers_descr = 4); 
# 133
private: virtual void find(InputArray image, ImageFeatures & features); 
# 135
Ptr< Feature2D>  detector_; 
# 136
Ptr< Feature2D>  extractor_; 
# 137
Ptr< Feature2D>  surf; 
# 138
}; 
# 144
class __attribute((visibility("default"))) OrbFeaturesFinder : public FeaturesFinder { 
# 147
public: OrbFeaturesFinder(Size _grid_size = Size(3, 1), int nfeatures = 1500, float scaleFactor = (1.299999952F), int nlevels = 5); 
# 150
private: virtual void find(InputArray image, ImageFeatures & features); 
# 152
Ptr< ORB>  orb; 
# 153
Size grid_size; 
# 154
}; 
# 160
class __attribute((visibility("default"))) AKAZEFeaturesFinder : public FeaturesFinder { 
# 163
public: AKAZEFeaturesFinder(int descriptor_type = AKAZE::DESCRIPTOR_MLDB, int descriptor_size = 0, int descriptor_channels = 3, float threshold = (0.001000000047F), int nOctaves = 4, int nOctaveLayers = 4, int diffusivity = KAZE::DIFF_PM_G2); 
# 172
private: virtual void find(InputArray image, ImageFeatures & features); 
# 174
Ptr< AKAZE>  akaze; 
# 175
}; 
# 206 "/usr/include/opencv2/stitching/detail/matchers.hpp" 3
struct __attribute((visibility("default"))) MatchesInfo { 
# 208
MatchesInfo(); 
# 209
MatchesInfo(const MatchesInfo & other); 
# 210
MatchesInfo &operator=(const MatchesInfo & other); 
# 212
int src_img_idx, dst_img_idx; 
# 213
std::vector< DMatch>  matches; 
# 214
std::vector< unsigned char>  inliers_mask; 
# 215
int num_inliers; 
# 216
Mat H; 
# 217
double confidence; 
# 218
}; 
# 221
class __attribute((visibility("default"))) FeaturesMatcher { 
# 224
public: virtual ~FeaturesMatcher() { } 
# 231
void operator()(const ImageFeatures &features1, const ImageFeatures &features2, MatchesInfo &
# 232
matches_info) { this->match(features1, features2, matches_info); } 
# 244 "/usr/include/opencv2/stitching/detail/matchers.hpp" 3
void operator()(const std::vector< ImageFeatures>  & features, std::vector< MatchesInfo>  & pairwise_matches, const UMat & mask = UMat()); 
# 249
bool isThreadSafe() const { return is_thread_safe_; } 
# 253
virtual void collectGarbage() { } 
# 256
protected: FeaturesMatcher(bool is_thread_safe = false) : is_thread_safe_(is_thread_safe) { } 
# 265 "/usr/include/opencv2/stitching/detail/matchers.hpp" 3
virtual void match(const ImageFeatures & features1, const ImageFeatures & features2, MatchesInfo & matches_info) = 0; 
# 268
bool is_thread_safe_; 
# 269
}; 
# 276
class __attribute((visibility("default"))) BestOf2NearestMatcher : public FeaturesMatcher { 
# 288 "/usr/include/opencv2/stitching/detail/matchers.hpp" 3
public: BestOf2NearestMatcher(bool try_use_gpu = false, float match_conf = (0.3000000119F), int num_matches_thresh1 = 6, int num_matches_thresh2 = 6); 
# 291
virtual void collectGarbage(); 
# 294
protected: virtual void match(const ImageFeatures & features1, const ImageFeatures & features2, MatchesInfo & matches_info); 
# 296
int num_matches_thresh1_; 
# 297
int num_matches_thresh2_; 
# 298
Ptr< FeaturesMatcher>  impl_; 
# 299
}; 
# 301
class __attribute((visibility("default"))) BestOf2NearestRangeMatcher : public BestOf2NearestMatcher { 
# 304
public: BestOf2NearestRangeMatcher(int range_width = 5, bool try_use_gpu = false, float match_conf = (0.3000000119F), int num_matches_thresh1 = 6, int num_matches_thresh2 = 6); 
# 307
void operator()(const std::vector< ImageFeatures>  & features, std::vector< MatchesInfo>  & pairwise_matches, const UMat & mask = UMat()); 
# 312
protected: int range_width_; 
# 313
}; 
# 324 "/usr/include/opencv2/stitching/detail/matchers.hpp" 3
class __attribute((visibility("default"))) AffineBestOf2NearestMatcher : public BestOf2NearestMatcher { 
# 339 "/usr/include/opencv2/stitching/detail/matchers.hpp" 3
public: AffineBestOf2NearestMatcher(bool full_affine = false, bool try_use_gpu = false, float 
# 340
match_conf = (0.3000000119F), int num_matches_thresh1 = 6) : BestOf2NearestMatcher(try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh1), full_affine_(full_affine) 
# 342
{ } 
# 345
protected: virtual void match(const ImageFeatures & features1, const ImageFeatures & features2, MatchesInfo & matches_info); 
# 347
bool full_affine_; 
# 348
}; 
# 352
}
# 353
}
# 64 "/usr/include/c++/5/bits/stl_list.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 66
namespace __detail { 
# 77 "/usr/include/c++/5/bits/stl_list.h" 3
struct _List_node_base { 
# 79
_List_node_base *_M_next; 
# 80
_List_node_base *_M_prev; 
# 83
static void swap(_List_node_base & __x, _List_node_base & __y) noexcept; 
# 86
void _M_transfer(_List_node_base *const __first, _List_node_base *const __last) noexcept; 
# 90
void _M_reverse() noexcept; 
# 93
void _M_hook(_List_node_base *const __position) noexcept; 
# 96
void _M_unhook() noexcept; 
# 97
}; 
# 100
}
# 105
template< class _Tp> 
# 106
struct _List_node : public __detail::_List_node_base { 
# 109
_Tp _M_data; 
# 112
template< class ..._Args> 
# 113
_List_node(_Args &&...__args) : __detail::_List_node_base(), _M_data(std::forward< _Args> (__args)...) 
# 115
{ } 
# 117
}; 
# 124
template< class _Tp> 
# 125
struct _List_iterator { 
# 127
typedef _List_iterator _Self; 
# 128
typedef _List_node< _Tp>  _Node; 
# 130
typedef ptrdiff_t difference_type; 
# 131
typedef bidirectional_iterator_tag iterator_category; 
# 132
typedef _Tp value_type; 
# 133
typedef _Tp *pointer; 
# 134
typedef _Tp &reference; 
# 136
_List_iterator() noexcept : _M_node() 
# 137
{ } 
# 140
explicit _List_iterator(__detail::_List_node_base *__x) noexcept : _M_node(__x) 
# 141
{ } 
# 144
_Self _M_const_cast() const noexcept 
# 145
{ return *this; } 
# 149
reference operator*() const noexcept 
# 150
{ return (static_cast< _Node *>(_M_node))->_M_data; } 
# 153
pointer operator->() const noexcept 
# 154
{ return std::__addressof(((static_cast< _Node *>(_M_node))->_M_data)); } 
# 157
_Self &operator++() noexcept 
# 158
{ 
# 159
(_M_node) = ((_M_node)->_M_next); 
# 160
return *this; 
# 161
} 
# 164
_Self operator++(int) noexcept 
# 165
{ 
# 166
_Self __tmp = *this; 
# 167
(_M_node) = ((_M_node)->_M_next); 
# 168
return __tmp; 
# 169
} 
# 172
_Self &operator--() noexcept 
# 173
{ 
# 174
(_M_node) = ((_M_node)->_M_prev); 
# 175
return *this; 
# 176
} 
# 179
_Self operator--(int) noexcept 
# 180
{ 
# 181
_Self __tmp = *this; 
# 182
(_M_node) = ((_M_node)->_M_prev); 
# 183
return __tmp; 
# 184
} 
# 187
bool operator==(const _Self &__x) const noexcept 
# 188
{ return (_M_node) == (__x._M_node); } 
# 191
bool operator!=(const _Self &__x) const noexcept 
# 192
{ return (_M_node) != (__x._M_node); } 
# 195
__detail::_List_node_base *_M_node; 
# 196
}; 
# 203
template< class _Tp> 
# 204
struct _List_const_iterator { 
# 206
typedef _List_const_iterator _Self; 
# 207
typedef const _List_node< _Tp>  _Node; 
# 208
typedef _List_iterator< _Tp>  iterator; 
# 210
typedef ptrdiff_t difference_type; 
# 211
typedef bidirectional_iterator_tag iterator_category; 
# 212
typedef _Tp value_type; 
# 213
typedef const _Tp *pointer; 
# 214
typedef const _Tp &reference; 
# 216
_List_const_iterator() noexcept : _M_node() 
# 217
{ } 
# 220
explicit _List_const_iterator(const __detail::_List_node_base *__x) noexcept : _M_node(__x) 
# 222
{ } 
# 224
_List_const_iterator(const iterator &__x) noexcept : _M_node(((__x._M_node))) 
# 225
{ } 
# 228
iterator _M_const_cast() const noexcept 
# 229
{ return ((iterator)(const_cast< __detail::_List_node_base *>(_M_node))); } 
# 234
reference operator*() const noexcept 
# 235
{ return (static_cast< _Node *>(_M_node))->_M_data; } 
# 238
pointer operator->() const noexcept 
# 239
{ return std::__addressof(((static_cast< _Node *>(_M_node))->_M_data)); } 
# 242
_Self &operator++() noexcept 
# 243
{ 
# 244
(_M_node) = ((_M_node)->_M_next); 
# 245
return *this; 
# 246
} 
# 249
_Self operator++(int) noexcept 
# 250
{ 
# 251
_Self __tmp = *this; 
# 252
(_M_node) = ((_M_node)->_M_next); 
# 253
return __tmp; 
# 254
} 
# 257
_Self &operator--() noexcept 
# 258
{ 
# 259
(_M_node) = ((_M_node)->_M_prev); 
# 260
return *this; 
# 261
} 
# 264
_Self operator--(int) noexcept 
# 265
{ 
# 266
_Self __tmp = *this; 
# 267
(_M_node) = ((_M_node)->_M_prev); 
# 268
return __tmp; 
# 269
} 
# 272
bool operator==(const _Self &__x) const noexcept 
# 273
{ return (_M_node) == (__x._M_node); } 
# 276
bool operator!=(const _Self &__x) const noexcept 
# 277
{ return (_M_node) != (__x._M_node); } 
# 280
const __detail::_List_node_base *_M_node; 
# 281
}; 
# 283
template< class _Val> inline bool 
# 285
operator==(const _List_iterator< _Val>  &__x, const _List_const_iterator< _Val>  &
# 286
__y) noexcept 
# 287
{ return (__x._M_node) == (__y._M_node); } 
# 289
template< class _Val> inline bool 
# 291
operator!=(const _List_iterator< _Val>  &__x, const _List_const_iterator< _Val>  &
# 292
__y) noexcept 
# 293
{ return (__x._M_node) != (__y._M_node); } 
# 295
inline namespace __cxx11 { 
# 297
template< class _Tp, class _Alloc> 
# 298
class _List_base { 
# 315 "/usr/include/c++/5/bits/stl_list.h" 3
protected: typedef typename _Alloc::template rebind< _List_node< _Tp> > ::other _Node_alloc_type; 
# 317
typedef typename _Alloc::template rebind< _Tp> ::other _Tp_alloc_type; 
# 320
static size_t _S_distance(const __detail::_List_node_base *__first, const __detail::_List_node_base *
# 321
__last) 
# 322
{ 
# 323
size_t __n = (0); 
# 324
while (__first != __last) 
# 325
{ 
# 326
__first = (__first->_M_next); 
# 327
++__n; 
# 328
}  
# 329
return __n; 
# 330
} 
# 332
struct _List_impl : public _Node_alloc_type { 
# 336
::std::_List_node< unsigned long>  _M_node; 
# 341
_List_impl() : ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Node_alloc_type(), _M_node() 
# 343
{ } 
# 345
_List_impl(const typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Node_alloc_type &__a) noexcept : ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Node_alloc_type(__a), _M_node() 
# 347
{ } 
# 350
_List_impl(typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Node_alloc_type &&__a) noexcept : ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Node_alloc_type(::std::move(__a)), _M_node() 
# 352
{ } 
# 354
}; 
# 356
_List_impl _M_impl; 
# 359
size_t _M_get_size() const { return ((_M_impl)._M_node)._M_data; } 
# 361
void _M_set_size(size_t __n) { (((_M_impl)._M_node)._M_data) = __n; } 
# 363
void _M_inc_size(size_t __n) { (((_M_impl)._M_node)._M_data) += __n; } 
# 365
void _M_dec_size(size_t __n) { (((_M_impl)._M_node)._M_data) -= __n; } 
# 368
size_t _M_distance(const __detail::_List_node_base *__first, const __detail::_List_node_base *
# 369
__last) const 
# 370
{ return (_S_distance)(__first, __last); } 
# 373
size_t _M_node_count() const { return ((_M_impl)._M_node)._M_data; } 
# 391 "/usr/include/c++/5/bits/stl_list.h" 3
_List_node< _Tp>  *_M_get_node() 
# 392
{ return ((_M_impl)._Node_alloc_type::allocate(1)); } 
# 395
void _M_put_node(_List_node< _Tp>  *__p) noexcept 
# 396
{ ((_M_impl)._Node_alloc_type::deallocate(__p, 1)); } 
# 399
public: typedef _Alloc allocator_type; 
# 402
_Node_alloc_type &_M_get_Node_allocator() noexcept 
# 403
{ return *(static_cast< _Node_alloc_type *>(&(_M_impl))); } 
# 406
const _Node_alloc_type &_M_get_Node_allocator() const noexcept 
# 407
{ return *(static_cast< const _Node_alloc_type *>(&(_M_impl))); } 
# 410
_Tp_alloc_type _M_get_Tp_allocator() const noexcept 
# 411
{ return (_Tp_alloc_type)this->_M_get_Node_allocator(); } 
# 414
allocator_type get_allocator() const noexcept 
# 415
{ return (allocator_type)this->_M_get_Node_allocator(); } 
# 417
_List_base() : _M_impl() 
# 419
{ _M_init(); } 
# 421
_List_base(const _Node_alloc_type &__a) noexcept : _M_impl(__a) 
# 423
{ _M_init(); } 
# 426
_List_base(_List_base &&__x) noexcept : _M_impl(std::move((__x._M_get_Node_allocator()))) 
# 428
{ 
# 429
auto *const __xnode = std::__addressof(((__x._M_impl)._M_node)); 
# 430
if ((__xnode->_M_next) == __xnode) { 
# 431
_M_init(); } else 
# 433
{ 
# 434
auto *const __node = std::__addressof(((_M_impl)._M_node)); 
# 435
(__node->_M_next) = (__xnode->_M_next); 
# 436
(__node->_M_prev) = (__xnode->_M_prev); 
# 437
((__node->_M_next)->_M_prev) = (((__node->_M_prev)->_M_next) = __node); 
# 438
_M_set_size((__x._M_get_size())); 
# 439
(__x._M_init()); 
# 440
}  
# 441
} 
# 445
~_List_base() noexcept 
# 446
{ _M_clear(); } 
# 449
void _M_clear() noexcept; 
# 452
void _M_init() noexcept 
# 453
{ 
# 454
(((this->_M_impl)._M_node)._M_next) = (&((this->_M_impl)._M_node)); 
# 455
(((this->_M_impl)._M_node)._M_prev) = (&((this->_M_impl)._M_node)); 
# 456
_M_set_size(0); 
# 457
} 
# 458
}; 
# 506 "/usr/include/c++/5/bits/stl_list.h" 3
template< class _Tp, class _Alloc = allocator< _Tp> > 
# 507
class list : protected _List_base< _Tp, _Alloc>  { 
# 510
typedef typename _Alloc::value_type _Alloc_value_type; 
# 514
typedef ::std::__cxx11::_List_base< _Tp, _Alloc>  _Base; 
# 515
typedef typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Tp_alloc_type _Tp_alloc_type; 
# 516
typedef typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Node_alloc_type _Node_alloc_type; 
# 519
public: typedef _Tp value_type; 
# 520
typedef typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Tp_alloc_type::pointer pointer; 
# 521
typedef typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Tp_alloc_type::const_pointer const_pointer; 
# 522
typedef typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Tp_alloc_type::reference reference; 
# 523
typedef typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Tp_alloc_type::const_reference const_reference; 
# 524
typedef _List_iterator< _Tp>  iterator; 
# 525
typedef _List_const_iterator< _Tp>  const_iterator; 
# 526
typedef ::std::reverse_iterator< _List_const_iterator< _Tp> >  const_reverse_iterator; 
# 527
typedef ::std::reverse_iterator< _List_iterator< _Tp> >  reverse_iterator; 
# 528
typedef ::std::size_t size_type; 
# 529
typedef ::std::ptrdiff_t difference_type; 
# 530
typedef _Alloc allocator_type; 
# 535
protected: typedef _List_node< _Tp>  _Node; 
# 537
using ::std::__cxx11::_List_base< _Tp, _Alloc> ::_M_impl;
# 538
using ::std::__cxx11::_List_base< _Tp, _Alloc> ::_M_put_node;
# 539
using ::std::__cxx11::_List_base< _Tp, _Alloc> ::_M_get_node;
# 540
using ::std::__cxx11::_List_base< _Tp, _Alloc> ::_M_get_Tp_allocator;
# 541
using ::std::__cxx11::_List_base< _Tp, _Alloc> ::_M_get_Node_allocator;
# 567 "/usr/include/c++/5/bits/stl_list.h" 3
template< class ..._Args> _Node *
# 569
_M_create_node(_Args &&...__args) 
# 570
{ 
# 571
_Node *__p = (this->_M_get_node()); 
# 572
try 
# 573
{ 
# 574
(_M_get_Node_allocator().construct(__p, ::std::forward< _Args> (__args)...)); 
# 576
} 
# 577
catch (...) 
# 578
{ 
# 579
_M_put_node(__p); 
# 580
throw; 
# 581
}  
# 582
return __p; 
# 583
} 
# 593
public: list() noexcept(is_nothrow_default_constructible< typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Node_alloc_type> ::value) : _Base() 
# 597
{ } 
# 604
explicit list(const allocator_type &__a) noexcept : _Base((_Node_alloc_type)__a) 
# 605
{ } 
# 616 "/usr/include/c++/5/bits/stl_list.h" 3
explicit list(size_type __n) : _Base() 
# 618
{ _M_default_initialize(__n); } 
# 628 "/usr/include/c++/5/bits/stl_list.h" 3
list(size_type __n, const value_type &__value, const allocator_type &
# 629
__a = allocator_type()) : _Base((_Node_alloc_type)__a) 
# 631
{ _M_fill_initialize(__n, __value); } 
# 655 "/usr/include/c++/5/bits/stl_list.h" 3
list(const list &__x) : _Base((__x._M_get_Node_allocator())) 
# 657
{ _M_initialize_dispatch((__x.begin()), (__x.end()), ::std::__false_type()); } 
# 667 "/usr/include/c++/5/bits/stl_list.h" 3
list(list &&__x) noexcept : _Base(::std::move(__x)) 
# 668
{ } 
# 678 "/usr/include/c++/5/bits/stl_list.h" 3
list(initializer_list< _Tp>  __l, const allocator_type &
# 679
__a = allocator_type()) : _Base((_Node_alloc_type)__a) 
# 681
{ _M_initialize_dispatch((__l.begin()), (__l.end()), ::std::__false_type()); } 
# 695 "/usr/include/c++/5/bits/stl_list.h" 3
template< class _InputIterator, class 
# 696
 = ::std::_RequireInputIter< _InputIterator> > 
# 697
list(_InputIterator __first, _InputIterator __last, const allocator_type &
# 698
__a = allocator_type()) : _Base((_Node_alloc_type)__a) 
# 700
{ _M_initialize_dispatch(__first, __last, ::std::__false_type()); } 
# 729 "/usr/include/c++/5/bits/stl_list.h" 3
list &operator=(const list & __x); 
# 740 "/usr/include/c++/5/bits/stl_list.h" 3
list &operator=(list &&__x) 
# 741
{ 
# 744
this->clear(); 
# 745
this->swap(__x); 
# 746
return *this; 
# 747
} 
# 757 "/usr/include/c++/5/bits/stl_list.h" 3
list &operator=(initializer_list< _Tp>  __l) 
# 758
{ 
# 759
(this->assign((__l.begin()), (__l.end()))); 
# 760
return *this; 
# 761
} 
# 775 "/usr/include/c++/5/bits/stl_list.h" 3
void assign(size_type __n, const value_type &__val) 
# 776
{ _M_fill_assign(__n, __val); } 
# 791 "/usr/include/c++/5/bits/stl_list.h" 3
template< class _InputIterator, class 
# 792
 = ::std::_RequireInputIter< _InputIterator> > void 
# 794
assign(_InputIterator __first, _InputIterator __last) 
# 795
{ _M_assign_dispatch(__first, __last, ::std::__false_type()); } 
# 816 "/usr/include/c++/5/bits/stl_list.h" 3
void assign(initializer_list< _Tp>  __l) 
# 817
{ (this->assign((__l.begin()), (__l.end()))); } 
# 822
allocator_type get_allocator() const noexcept 
# 823
{ return _Base::get_allocator(); } 
# 831
iterator begin() noexcept 
# 832
{ return ((iterator)((((this->_M_impl)._M_node)._M_next))); } 
# 840
const_iterator begin() const noexcept 
# 841
{ return ((const_iterator)((((this->_M_impl)._M_node)._M_next))); } 
# 849
iterator end() noexcept 
# 850
{ return ((iterator)(&((this->_M_impl)._M_node))); } 
# 858
const_iterator end() const noexcept 
# 859
{ return ((const_iterator)(&((this->_M_impl)._M_node))); } 
# 867
reverse_iterator rbegin() noexcept 
# 868
{ return ((reverse_iterator)(this->end())); } 
# 876
const_reverse_iterator rbegin() const noexcept 
# 877
{ return ((const_reverse_iterator)(this->end())); } 
# 885
reverse_iterator rend() noexcept 
# 886
{ return ((reverse_iterator)(this->begin())); } 
# 894
const_reverse_iterator rend() const noexcept 
# 895
{ return ((const_reverse_iterator)(this->begin())); } 
# 904
const_iterator cbegin() const noexcept 
# 905
{ return ((const_iterator)((((this->_M_impl)._M_node)._M_next))); } 
# 913
const_iterator cend() const noexcept 
# 914
{ return ((const_iterator)(&((this->_M_impl)._M_node))); } 
# 922
const_reverse_iterator crbegin() const noexcept 
# 923
{ return ((const_reverse_iterator)(this->end())); } 
# 931
const_reverse_iterator crend() const noexcept 
# 932
{ return ((const_reverse_iterator)(this->begin())); } 
# 941
bool empty() const noexcept 
# 942
{ return (((this->_M_impl)._M_node)._M_next) == (&((this->_M_impl)._M_node)); } 
# 946
size_type size() const noexcept 
# 947
{ return (this->_M_node_count()); } 
# 951
size_type max_size() const noexcept 
# 952
{ return (_M_get_Node_allocator().max_size()); } 
# 965 "/usr/include/c++/5/bits/stl_list.h" 3
void resize(size_type __new_size); 
# 978 "/usr/include/c++/5/bits/stl_list.h" 3
void resize(size_type __new_size, const value_type & __x); 
# 1000 "/usr/include/c++/5/bits/stl_list.h" 3
reference front() noexcept 
# 1001
{ return *this->begin(); } 
# 1008
const_reference front() const noexcept 
# 1009
{ return *this->begin(); } 
# 1016
reference back() noexcept 
# 1017
{ 
# 1018
iterator __tmp = this->end(); 
# 1019
--__tmp; 
# 1020
return *__tmp; 
# 1021
} 
# 1028
const_reference back() const noexcept 
# 1029
{ 
# 1030
const_iterator __tmp = this->end(); 
# 1031
--__tmp; 
# 1032
return *__tmp; 
# 1033
} 
# 1047 "/usr/include/c++/5/bits/stl_list.h" 3
void push_front(const value_type &__x) 
# 1048
{ (this->_M_insert(this->begin(), __x)); } 
# 1052
void push_front(value_type &&__x) 
# 1053
{ (this->_M_insert(this->begin(), ::std::move(__x))); } 
# 1055
template< class ..._Args> void 
# 1057
emplace_front(_Args &&...__args) 
# 1058
{ (this->_M_insert(this->begin(), ::std::forward< _Args> (__args)...)); } 
# 1074 "/usr/include/c++/5/bits/stl_list.h" 3
void pop_front() noexcept 
# 1075
{ this->_M_erase(this->begin()); } 
# 1088 "/usr/include/c++/5/bits/stl_list.h" 3
void push_back(const value_type &__x) 
# 1089
{ (this->_M_insert(this->end(), __x)); } 
# 1093
void push_back(value_type &&__x) 
# 1094
{ (this->_M_insert(this->end(), ::std::move(__x))); } 
# 1096
template< class ..._Args> void 
# 1098
emplace_back(_Args &&...__args) 
# 1099
{ (this->_M_insert(this->end(), ::std::forward< _Args> (__args)...)); } 
# 1114 "/usr/include/c++/5/bits/stl_list.h" 3
void pop_back() noexcept 
# 1115
{ this->_M_erase(((((iterator)((((this->_M_impl)._M_node)._M_prev)))))); } 
# 1130 "/usr/include/c++/5/bits/stl_list.h" 3
template< class ..._Args> iterator emplace(const_iterator __position, _Args && ...__args); 
# 1146 "/usr/include/c++/5/bits/stl_list.h" 3
iterator insert(const_iterator __position, const value_type & __x); 
# 1176 "/usr/include/c++/5/bits/stl_list.h" 3
iterator insert(const_iterator __position, value_type &&__x) 
# 1177
{ return emplace(__position, ::std::move(__x)); } 
# 1195 "/usr/include/c++/5/bits/stl_list.h" 3
iterator insert(const_iterator __p, initializer_list< _Tp>  __l) 
# 1196
{ return (this->insert(__p, (__l.begin()), (__l.end()))); } 
# 1215 "/usr/include/c++/5/bits/stl_list.h" 3
iterator insert(const_iterator __position, size_type __n, const value_type & __x); 
# 1253 "/usr/include/c++/5/bits/stl_list.h" 3
template< class _InputIterator, class 
# 1254
 = ::std::_RequireInputIter< _InputIterator> > iterator 
# 1253
insert(const_iterator __position, _InputIterator __first, _InputIterator __last); 
# 1299 "/usr/include/c++/5/bits/stl_list.h" 3
iterator erase(const_iterator __position) noexcept; 
# 1324 "/usr/include/c++/5/bits/stl_list.h" 3
iterator erase(const_iterator __first, const_iterator __last) noexcept 
# 1328
{ 
# 1329
while (__first != __last) { 
# 1330
__first = erase(__first); }  
# 1331
return (__last._M_const_cast()); 
# 1332
} 
# 1344 "/usr/include/c++/5/bits/stl_list.h" 3
void swap(list &__x) 
# 1345
{ 
# 1346
__detail::_List_node_base::swap(((this->_M_impl)._M_node), ((__x._M_impl)._M_node)); 
# 1349
::std::size_t __xsize = (__x._M_get_size()); 
# 1350
(__x._M_set_size((this->_M_get_size()))); 
# 1351
(this->_M_set_size(__xsize)); 
# 1355
std::__alloc_swap< typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Node_alloc_type> ::_S_do_it(_M_get_Node_allocator(), (__x._M_get_Node_allocator())); 
# 1357
} 
# 1366
void clear() noexcept 
# 1367
{ 
# 1368
_Base::_M_clear(); 
# 1369
_Base::_M_init(); 
# 1370
} 
# 1386 "/usr/include/c++/5/bits/stl_list.h" 3
void splice(const_iterator __position, list &&__x) noexcept 
# 1390
{ 
# 1391
if (!(__x.empty())) 
# 1392
{ 
# 1393
_M_check_equal_allocators(__x); 
# 1395
this->_M_transfer((__position._M_const_cast()), (__x.begin()), (__x.end())); 
# 1398
(this->_M_inc_size((__x._M_get_size()))); 
# 1399
(__x._M_set_size(0)); 
# 1400
}  
# 1401
} 
# 1405
void splice(const_iterator __position, list &__x) noexcept 
# 1406
{ splice(__position, ::std::move(__x)); } 
# 1421 "/usr/include/c++/5/bits/stl_list.h" 3
void splice(const_iterator __position, list &&__x, const_iterator __i) noexcept 
# 1435 "/usr/include/c++/5/bits/stl_list.h" 3
{ 
# 1436
iterator __j = (__i._M_const_cast()); 
# 1437
++__j; 
# 1438
if ((__position == __i) || (__position == __j)) { 
# 1439
return; }  
# 1441
if (this != (&__x)) { 
# 1442
_M_check_equal_allocators(__x); }  
# 1444
this->_M_transfer((__position._M_const_cast()), (__i._M_const_cast()), __j); 
# 1447
(this->_M_inc_size(1)); 
# 1448
(__x._M_dec_size(1)); 
# 1449
} 
# 1463 "/usr/include/c++/5/bits/stl_list.h" 3
void splice(const_iterator __position, list &__x, const_iterator __i) noexcept 
# 1464
{ splice(__position, ::std::move(__x), __i); } 
# 1482 "/usr/include/c++/5/bits/stl_list.h" 3
void splice(const_iterator __position, list &&__x, const_iterator __first, const_iterator 
# 1483
__last) noexcept 
# 1501 "/usr/include/c++/5/bits/stl_list.h" 3
{ 
# 1502
if (__first != __last) 
# 1503
{ 
# 1504
if (this != (&__x)) { 
# 1505
_M_check_equal_allocators(__x); }  
# 1507
::std::size_t __n = (this->_M_distance((__first._M_node), (__last._M_node))); 
# 1508
(this->_M_inc_size(__n)); 
# 1509
(__x._M_dec_size(__n)); 
# 1511
this->_M_transfer((__position._M_const_cast()), (__first._M_const_cast()), (__last._M_const_cast())); 
# 1514
}  
# 1515
} 
# 1532 "/usr/include/c++/5/bits/stl_list.h" 3
void splice(const_iterator __position, list &__x, const_iterator __first, const_iterator 
# 1533
__last) noexcept 
# 1534
{ splice(__position, ::std::move(__x), __first, __last); } 
# 1549 "/usr/include/c++/5/bits/stl_list.h" 3
void remove(const _Tp & __value); 
# 1562 "/usr/include/c++/5/bits/stl_list.h" 3
template< class _Predicate> void remove_if(_Predicate); 
# 1577 "/usr/include/c++/5/bits/stl_list.h" 3
void unique(); 
# 1591 "/usr/include/c++/5/bits/stl_list.h" 3
template< class _BinaryPredicate> void unique(_BinaryPredicate); 
# 1606 "/usr/include/c++/5/bits/stl_list.h" 3
void merge(list && __x); 
# 1609
void merge(list &__x) 
# 1610
{ merge(::std::move(__x)); } 
# 1630 "/usr/include/c++/5/bits/stl_list.h" 3
template< class _StrictWeakOrdering> void merge(list && __x, _StrictWeakOrdering __comp); 
# 1634
template< class _StrictWeakOrdering> void 
# 1636
merge(list &__x, _StrictWeakOrdering __comp) 
# 1637
{ merge(::std::move(__x), __comp); } 
# 1650 "/usr/include/c++/5/bits/stl_list.h" 3
void reverse() noexcept 
# 1651
{ (((this->_M_impl)._M_node)._M_reverse()); } 
# 1660
void sort(); 
# 1668
template< class _StrictWeakOrdering> void sort(_StrictWeakOrdering); 
# 1681
protected: 
# 1679
template< class _Integer> void 
# 1681
_M_initialize_dispatch(_Integer __n, _Integer __x, ::std::__true_type) 
# 1682
{ _M_fill_initialize(static_cast< size_type>(__n), __x); } 
# 1685
template< class _InputIterator> void 
# 1687
_M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1689
{ 
# 1690
for (; __first != __last; ++__first) { 
# 1692
emplace_back(*__first); }  
# 1696
} 
# 1701
void _M_fill_initialize(size_type __n, const value_type &__x) 
# 1702
{ 
# 1703
for (; __n; --__n) { 
# 1704
push_back(__x); }  
# 1705
} 
# 1710
void _M_default_initialize(size_type __n) 
# 1711
{ 
# 1712
for (; __n; --__n) { 
# 1713
emplace_back(); }  
# 1714
} 
# 1718
void _M_default_append(size_type __n); 
# 1727 "/usr/include/c++/5/bits/stl_list.h" 3
template< class _Integer> void 
# 1729
_M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type) 
# 1730
{ _M_fill_assign(__n, __val); } 
# 1733
template< class _InputIterator> void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type); 
# 1741
void _M_fill_assign(size_type __n, const value_type & __val); 
# 1746
void _M_transfer(iterator __position, iterator __first, iterator __last) 
# 1747
{ ((__position._M_node)->_M_transfer((__first._M_node), (__last._M_node))); } 
# 1759 "/usr/include/c++/5/bits/stl_list.h" 3
template< class ..._Args> void 
# 1761
_M_insert(iterator __position, _Args &&...__args) 
# 1762
{ 
# 1763
_Node *__tmp = _M_create_node(::std::forward< _Args> (__args)...); 
# 1764
(__tmp->_M_hook((__position._M_node))); 
# 1765
(this->_M_inc_size(1)); 
# 1766
} 
# 1771
void _M_erase(iterator __position) noexcept 
# 1772
{ 
# 1773
(this->_M_dec_size(1)); 
# 1774
((__position._M_node)->_M_unhook()); 
# 1775
_Node *__n = static_cast< _Node *>(__position._M_node); 
# 1777
(_M_get_Node_allocator().destroy(__n)); 
# 1781
_M_put_node(__n); 
# 1782
} 
# 1786
void _M_check_equal_allocators(list &__x) noexcept 
# 1787
{ 
# 1788
if (std::__alloc_neq< typename ::std::__cxx11::_List_base< _Tp, _Alloc> ::_Node_alloc_type> ::_S_do_it(_M_get_Node_allocator(), (__x._M_get_Node_allocator()))) { 
# 1790
__builtin_abort(); }  
# 1791
} 
# 1792
}; 
# 1793
}
# 1805 "/usr/include/c++/5/bits/stl_list.h" 3
template< class _Tp, class _Alloc> inline bool 
# 1807
operator==(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 1808
{ 
# 1809
typedef typename __cxx11::list< _Tp, _Alloc> ::const_iterator const_iterator; 
# 1810
const_iterator __end1 = (__x.end()); 
# 1811
const_iterator __end2 = (__y.end()); 
# 1813
const_iterator __i1 = (__x.begin()); 
# 1814
const_iterator __i2 = (__y.begin()); 
# 1815
while ((__i1 != __end1) && (__i2 != __end2) && ((*__i1) == (*__i2))) 
# 1816
{ 
# 1817
++__i1; 
# 1818
++__i2; 
# 1819
}  
# 1820
return (__i1 == __end1) && (__i2 == __end2); 
# 1821
} 
# 1834 "/usr/include/c++/5/bits/stl_list.h" 3
template< class _Tp, class _Alloc> inline bool 
# 1836
operator<(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 1837
{ return std::lexicographical_compare((__x.begin()), (__x.end()), (__y.begin()), (__y.end())); 
# 1838
} 
# 1841
template< class _Tp, class _Alloc> inline bool 
# 1843
operator!=(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 1844
{ return !(__x == __y); } 
# 1847
template< class _Tp, class _Alloc> inline bool 
# 1849
operator>(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 1850
{ return __y < __x; } 
# 1853
template< class _Tp, class _Alloc> inline bool 
# 1855
operator<=(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 1856
{ return !(__y < __x); } 
# 1859
template< class _Tp, class _Alloc> inline bool 
# 1861
operator>=(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 1862
{ return !(__x < __y); } 
# 1865
template< class _Tp, class _Alloc> inline void 
# 1867
swap(__cxx11::list< _Tp, _Alloc>  &__x, __cxx11::list< _Tp, _Alloc>  &__y) 
# 1868
{ (__x.swap(__y)); } 
# 1871
}
# 59 "/usr/include/c++/5/bits/list.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 63
template< class _Tp, class _Alloc> void 
# 66
__cxx11::_List_base< _Tp, _Alloc> ::_M_clear() noexcept 
# 67
{ 
# 68
typedef _List_node< _Tp>  _Node; 
# 69
__detail::_List_node_base *__cur = ((((_M_impl)._M_node)._M_next)); 
# 70
while (__cur != (&((_M_impl)._M_node))) 
# 71
{ 
# 72
_Node *__tmp = static_cast< _Node *>(__cur); 
# 73
__cur = (__tmp->_M_next); 
# 75
(this->_M_get_Node_allocator().destroy(__tmp)); 
# 79
_M_put_node(__tmp); 
# 80
}  
# 81
} 
# 84
template< class _Tp, class _Alloc> 
# 85
template< class ..._Args> typename __cxx11::list< _Tp, _Alloc> ::iterator 
# 88
__cxx11::list< _Tp, _Alloc> ::emplace(const_iterator __position, _Args &&...__args) 
# 89
{ 
# 90
_Node *__tmp = _M_create_node(::std::forward< _Args> (__args)...); 
# 91
(__tmp->_M_hook(((__position._M_const_cast())._M_node))); 
# 92
(this->_M_inc_size(1)); 
# 93
return ((iterator)(__tmp)); 
# 94
} 
# 97
template< class _Tp, class _Alloc> typename __cxx11::list< _Tp, _Alloc> ::iterator 
# 101
__cxx11::list< _Tp, _Alloc> ::insert(const_iterator __position, const value_type &__x) 
# 105
{ 
# 106
_Node *__tmp = _M_create_node(__x); 
# 107
(__tmp->_M_hook(((__position._M_const_cast())._M_node))); 
# 108
(this->_M_inc_size(1)); 
# 109
return ((iterator)(__tmp)); 
# 110
} 
# 113
template< class _Tp, class _Alloc> typename __cxx11::list< _Tp, _Alloc> ::iterator 
# 116
__cxx11::list< _Tp, _Alloc> ::insert(const_iterator __position, size_type __n, const value_type &__x) 
# 117
{ 
# 118
if (__n) 
# 119
{ 
# 120
list __tmp(__n, __x, get_allocator()); 
# 121
iterator __it = (__tmp.begin()); 
# 122
splice(__position, __tmp); 
# 123
return __it; 
# 124
}  
# 125
return (__position._M_const_cast()); 
# 126
} 
# 128
template< class _Tp, class _Alloc> 
# 129
template< class _InputIterator, class > typename __cxx11::list< _Tp, _Alloc> ::iterator 
# 132
__cxx11::list< _Tp, _Alloc> ::insert(const_iterator __position, _InputIterator __first, _InputIterator 
# 133
__last) 
# 134
{ 
# 135
list __tmp(__first, __last, get_allocator()); 
# 136
if (!(__tmp.empty())) 
# 137
{ 
# 138
iterator __it = (__tmp.begin()); 
# 139
splice(__position, __tmp); 
# 140
return __it; 
# 141
}  
# 142
return (__position._M_const_cast()); 
# 143
} 
# 146
template< class _Tp, class _Alloc> typename __cxx11::list< _Tp, _Alloc> ::iterator 
# 150
__cxx11::list< _Tp, _Alloc> ::erase(const_iterator __position) noexcept 
# 154
{ 
# 155
iterator __ret = ((((iterator)(((__position._M_node)->_M_next))))); 
# 156
_M_erase((__position._M_const_cast())); 
# 157
return __ret; 
# 158
} 
# 161
template< class _Tp, class _Alloc> void 
# 164
__cxx11::list< _Tp, _Alloc> ::_M_default_append(size_type __n) 
# 165
{ 
# 166
size_type __i = (0); 
# 167
try 
# 168
{ 
# 169
for (; __i < __n; ++__i) { 
# 170
emplace_back(); }  
# 171
} 
# 172
catch (...) 
# 173
{ 
# 174
for (; __i; --__i) { 
# 175
pop_back(); }  
# 176
throw; 
# 177
}  
# 178
} 
# 180
template< class _Tp, class _Alloc> void 
# 183
__cxx11::list< _Tp, _Alloc> ::resize(size_type __new_size) 
# 184
{ 
# 185
iterator __i = this->begin(); 
# 186
size_type __len = (0); 
# 187
for (; (__i != this->end()) && (__len < __new_size); (++__i), (++__len)) { 
# 188
; }  
# 189
if (__len == __new_size) { 
# 190
erase(__i, this->end()); } else { 
# 192
_M_default_append(__new_size - __len); }  
# 193
} 
# 195
template< class _Tp, class _Alloc> void 
# 198
__cxx11::list< _Tp, _Alloc> ::resize(size_type __new_size, const value_type &__x) 
# 199
{ 
# 200
iterator __i = this->begin(); 
# 201
size_type __len = (0); 
# 202
for (; (__i != this->end()) && (__len < __new_size); (++__i), (++__len)) { 
# 203
; }  
# 204
if (__len == __new_size) { 
# 205
erase(__i, this->end()); } else { 
# 207
insert(this->end(), __new_size - __len, __x); }  
# 208
} 
# 226 "/usr/include/c++/5/bits/list.tcc" 3
template< class _Tp, class _Alloc> __cxx11::list< _Tp, _Alloc>  &
# 229
__cxx11::list< _Tp, _Alloc> ::operator=(const list &__x) 
# 230
{ 
# 231
if (this != (&__x)) 
# 232
{ 
# 233
iterator __first1 = this->begin(); 
# 234
iterator __last1 = this->end(); 
# 235
const_iterator __first2 = (__x.begin()); 
# 236
const_iterator __last2 = (__x.end()); 
# 237
for (; (__first1 != __last1) && (__first2 != __last2); (++__first1), (++__first2)) { 
# 239
(*__first1) = (*__first2); }  
# 240
if (__first2 == __last2) { 
# 241
erase(__first1, __last1); } else { 
# 243
insert(__last1, __first2, __last2); }  
# 244
}  
# 245
return *this; 
# 246
} 
# 248
template< class _Tp, class _Alloc> void 
# 251
__cxx11::list< _Tp, _Alloc> ::_M_fill_assign(size_type __n, const value_type &__val) 
# 252
{ 
# 253
iterator __i = this->begin(); 
# 254
for (; (__i != this->end()) && (__n > (0)); (++__i), (--__n)) { 
# 255
(*__i) = __val; }  
# 256
if (__n > (0)) { 
# 257
insert(this->end(), __n, __val); } else { 
# 259
erase(__i, this->end()); }  
# 260
} 
# 262
template< class _Tp, class _Alloc> 
# 263
template< class _InputIterator> void 
# 266
__cxx11::list< _Tp, _Alloc> ::_M_assign_dispatch(_InputIterator __first2, _InputIterator __last2, ::std::__false_type) 
# 268
{ 
# 269
iterator __first1 = this->begin(); 
# 270
iterator __last1 = this->end(); 
# 271
for (; (__first1 != __last1) && (__first2 != __last2); (++__first1), (++__first2)) { 
# 273
(*__first1) = (*__first2); }  
# 274
if (__first2 == __last2) { 
# 275
erase(__first1, __last1); } else { 
# 277
insert(__last1, __first2, __last2); }  
# 278
} 
# 280
template< class _Tp, class _Alloc> void 
# 283
__cxx11::list< _Tp, _Alloc> ::remove(const value_type &__value) 
# 284
{ 
# 285
iterator __first = this->begin(); 
# 286
iterator __last = this->end(); 
# 287
iterator __extra = __last; 
# 288
while (__first != __last) 
# 289
{ 
# 290
iterator __next = __first; 
# 291
++__next; 
# 292
if ((*__first) == __value) 
# 293
{ 
# 297
if (::std::__addressof(*__first) != ::std::__addressof(__value)) { 
# 298
_M_erase(__first); } else { 
# 300
__extra = __first; }  
# 301
}  
# 302
__first = __next; 
# 303
}  
# 304
if (__extra != __last) { 
# 305
_M_erase(__extra); }  
# 306
} 
# 308
template< class _Tp, class _Alloc> void 
# 311
__cxx11::list< _Tp, _Alloc> ::unique() 
# 312
{ 
# 313
iterator __first = this->begin(); 
# 314
iterator __last = this->end(); 
# 315
if (__first == __last) { 
# 316
return; }  
# 317
iterator __next = __first; 
# 318
while ((++__next) != __last) 
# 319
{ 
# 320
if ((*__first) == (*__next)) { 
# 321
_M_erase(__next); } else { 
# 323
__first = __next; }  
# 324
__next = __first; 
# 325
}  
# 326
} 
# 328
template< class _Tp, class _Alloc> void 
# 332
__cxx11::list< _Tp, _Alloc> ::merge(list &&__x) 
# 336
{ 
# 339
if (this != (&__x)) 
# 340
{ 
# 341
_M_check_equal_allocators(__x); 
# 343
iterator __first1 = this->begin(); 
# 344
iterator __last1 = this->end(); 
# 345
iterator __first2 = (__x.begin()); 
# 346
iterator __last2 = (__x.end()); 
# 347
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 348
if ((*__first2) < (*__first1)) 
# 349
{ 
# 350
iterator __next = __first2; 
# 351
_M_transfer(__first1, __first2, ++__next); 
# 352
__first2 = __next; 
# 353
} else { 
# 355
++__first1; }  }  
# 356
if (__first2 != __last2) { 
# 357
_M_transfer(__last1, __first2, __last2); }  
# 359
(this->_M_inc_size((__x._M_get_size()))); 
# 360
(__x._M_set_size(0)); 
# 361
}  
# 362
} 
# 364
template< class _Tp, class _Alloc> 
# 365
template< class _StrictWeakOrdering> void 
# 369
__cxx11::list< _Tp, _Alloc> ::merge(list &&__x, _StrictWeakOrdering __comp) 
# 373
{ 
# 376
if (this != (&__x)) 
# 377
{ 
# 378
_M_check_equal_allocators(__x); 
# 380
iterator __first1 = this->begin(); 
# 381
iterator __last1 = this->end(); 
# 382
iterator __first2 = (__x.begin()); 
# 383
iterator __last2 = (__x.end()); 
# 384
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 385
if (__comp(*__first2, *__first1)) 
# 386
{ 
# 387
iterator __next = __first2; 
# 388
_M_transfer(__first1, __first2, ++__next); 
# 389
__first2 = __next; 
# 390
} else { 
# 392
++__first1; }  }  
# 393
if (__first2 != __last2) { 
# 394
_M_transfer(__last1, __first2, __last2); }  
# 396
(this->_M_inc_size((__x._M_get_size()))); 
# 397
(__x._M_set_size(0)); 
# 398
}  
# 399
} 
# 401
template< class _Tp, class _Alloc> void 
# 404
__cxx11::list< _Tp, _Alloc> ::sort() 
# 405
{ 
# 407
if (((((this->_M_impl)._M_node)._M_next) != (&((this->_M_impl)._M_node))) && (((((this->_M_impl)._M_node)._M_next)->_M_next) != (&((this->_M_impl)._M_node)))) 
# 409
{ 
# 410
list __carry; 
# 411
list __tmp[64]; 
# 412
list *__fill = (&((__tmp)[0])); 
# 413
list *__counter; 
# 415
do 
# 416
{ 
# 417
(__carry.splice((__carry.begin()), *this, this->begin())); 
# 419
for (__counter = (&((__tmp)[0])); (__counter != __fill) && (!__counter->empty()); ++__counter) 
# 422
{ 
# 423
(__counter->merge(__carry)); 
# 424
(__carry.swap(*__counter)); 
# 425
}  
# 426
(__carry.swap(*__counter)); 
# 427
if (__counter == __fill) { 
# 428
++__fill; }  
# 429
} 
# 430
while (!empty()); 
# 432
for (__counter = (&((__tmp)[1])); __counter != __fill; ++__counter) { 
# 433
(__counter->merge(*(__counter - 1))); }  
# 434
swap(*(__fill - 1)); 
# 435
}  
# 436
} 
# 438
template< class _Tp, class _Alloc> 
# 439
template< class _Predicate> void 
# 442
__cxx11::list< _Tp, _Alloc> ::remove_if(_Predicate __pred) 
# 443
{ 
# 444
iterator __first = this->begin(); 
# 445
iterator __last = this->end(); 
# 446
while (__first != __last) 
# 447
{ 
# 448
iterator __next = __first; 
# 449
++__next; 
# 450
if (__pred(*__first)) { 
# 451
_M_erase(__first); }  
# 452
__first = __next; 
# 453
}  
# 454
} 
# 456
template< class _Tp, class _Alloc> 
# 457
template< class _BinaryPredicate> void 
# 460
__cxx11::list< _Tp, _Alloc> ::unique(_BinaryPredicate __binary_pred) 
# 461
{ 
# 462
iterator __first = this->begin(); 
# 463
iterator __last = this->end(); 
# 464
if (__first == __last) { 
# 465
return; }  
# 466
iterator __next = __first; 
# 467
while ((++__next) != __last) 
# 468
{ 
# 469
if (__binary_pred(*__first, *__next)) { 
# 470
_M_erase(__next); } else { 
# 472
__first = __next; }  
# 473
__next = __first; 
# 474
}  
# 475
} 
# 477
template< class _Tp, class _Alloc> 
# 478
template< class _StrictWeakOrdering> void 
# 481
__cxx11::list< _Tp, _Alloc> ::sort(_StrictWeakOrdering __comp) 
# 482
{ 
# 484
if (((((this->_M_impl)._M_node)._M_next) != (&((this->_M_impl)._M_node))) && (((((this->_M_impl)._M_node)._M_next)->_M_next) != (&((this->_M_impl)._M_node)))) 
# 486
{ 
# 487
list __carry; 
# 488
list __tmp[64]; 
# 489
list *__fill = (&((__tmp)[0])); 
# 490
list *__counter; 
# 492
do 
# 493
{ 
# 494
(__carry.splice((__carry.begin()), *this, this->begin())); 
# 496
for (__counter = (&((__tmp)[0])); (__counter != __fill) && (!__counter->empty()); ++__counter) 
# 499
{ 
# 500
(__counter->merge(__carry, __comp)); 
# 501
(__carry.swap(*__counter)); 
# 502
}  
# 503
(__carry.swap(*__counter)); 
# 504
if (__counter == __fill) { 
# 505
++__fill; }  
# 506
} 
# 507
while (!empty()); 
# 509
for (__counter = (&((__tmp)[1])); __counter != __fill; ++__counter) { 
# 510
(__counter->merge(*(__counter - 1), __comp)); }  
# 511
swap(*(__fill - 1)); 
# 512
}  
# 513
} 
# 516
}
# 49 "/usr/include/opencv2/stitching/detail/util.hpp" 3
namespace cv { 
# 50
namespace detail { 
# 55
class __attribute((visibility("default"))) DisjointSets { 
# 58
public: DisjointSets(int elem_count = 0) { this->createOneElemSets(elem_count); } 
# 60
void createOneElemSets(int elem_count); 
# 61
int findSetByElem(int elem); 
# 62
int mergeSets(int set1, int set2); 
# 64
std::vector< int>  parent; 
# 65
std::vector< int>  size; 
# 68
private: std::vector< int>  rank_; 
# 69
}; 
# 72
struct __attribute((visibility("default"))) GraphEdge { 
# 74
inline GraphEdge(int from, int to, float weight); 
# 75
bool operator<(const GraphEdge &other) const { return (weight) < (other.weight); } 
# 76
bool operator>(const GraphEdge &other) const { return (weight) > (other.weight); } 
# 78
int from, to; 
# 79
float weight; 
# 80
}; 
# 82
inline GraphEdge::GraphEdge(int _from, int _to, float _weight) : from(_from), to(_to), weight(_weight) { } 
# 85
class __attribute((visibility("default"))) Graph { 
# 88
public: Graph(int num_vertices = 0) { this->create(num_vertices); } 
# 89
void create(int num_vertices) { (edges_).assign(num_vertices, std::__cxx11::list< GraphEdge> ()); } 
# 90
int numVertices() const { return static_cast< int>((edges_).size()); } 
# 91
void addEdge(int from, int to, float weight); 
# 92
template< class B> B forEach(B body) const; 
# 93
template< class B> B walkBreadthFirst(int from, B body) const; 
# 96
private: std::vector< std::__cxx11::list< GraphEdge> >  edges_; 
# 97
}; 
# 103
__attribute((visibility("default"))) bool overlapRoi(Point tl1, Point tl2, Size sz1, Size sz2, Rect & roi); 
# 104
__attribute((visibility("default"))) Rect resultRoi(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images); 
# 105
__attribute((visibility("default"))) Rect resultRoi(const std::vector< Point_< int> >  & corners, const std::vector< Size_< int> >  & sizes); 
# 106
__attribute((visibility("default"))) Rect resultRoiIntersection(const std::vector< Point_< int> >  & corners, const std::vector< Size_< int> >  & sizes); 
# 107
__attribute((visibility("default"))) Point resultTl(const std::vector< Point_< int> >  & corners); 
# 110
__attribute((visibility("default"))) void selectRandomSubset(int count, int size, std::vector< int>  & subset); 
# 112
__attribute((visibility("default"))) int &stitchingLogLevel(); 
# 116
}
# 117
}
# 65 "/usr/include/c++/5/bits/stl_queue.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 95 "/usr/include/c++/5/bits/stl_queue.h" 3
template< class _Tp, class _Sequence = deque< _Tp> > 
# 96
class queue { 
# 99
typedef typename _Sequence::value_type _Sequence_value_type; 
# 105
template< class _Tp1, class _Seq1> friend bool operator==(const std::queue< _Tp1, _Seq1>  &, const std::queue< _Tp1, _Seq1>  &); 
# 109
template< class _Tp1, class _Seq1> friend bool operator<(const std::queue< _Tp1, _Seq1>  &, const std::queue< _Tp1, _Seq1>  &); 
# 114
public: typedef typename _Sequence::value_type value_type; 
# 115
typedef typename _Sequence::reference reference; 
# 116
typedef typename _Sequence::const_reference const_reference; 
# 117
typedef typename _Sequence::size_type size_type; 
# 118
typedef _Sequence container_type; 
# 129 "/usr/include/c++/5/bits/stl_queue.h" 3
protected: _Sequence c; 
# 141 "/usr/include/c++/5/bits/stl_queue.h" 3
public: explicit queue(const _Sequence &__c) : c(__c) 
# 142
{ } 
# 145
explicit queue(_Sequence &&__c = _Sequence()) : c(std::move(__c)) 
# 146
{ } 
# 153
bool empty() const 
# 154
{ return ((c).empty()); } 
# 158
size_type size() const 
# 159
{ return ((c).size()); } 
# 166
reference front() 
# 167
{ 
# 168
; 
# 169
return ((c).front()); 
# 170
} 
# 177
const_reference front() const 
# 178
{ 
# 179
; 
# 180
return ((c).front()); 
# 181
} 
# 188
reference back() 
# 189
{ 
# 190
; 
# 191
return ((c).back()); 
# 192
} 
# 199
const_reference back() const 
# 200
{ 
# 201
; 
# 202
return ((c).back()); 
# 203
} 
# 215 "/usr/include/c++/5/bits/stl_queue.h" 3
void push(const value_type &__x) 
# 216
{ ((c).push_back(__x)); } 
# 220
void push(value_type &&__x) 
# 221
{ ((c).push_back(std::move(__x))); } 
# 223
template< class ..._Args> void 
# 225
emplace(_Args &&...__args) 
# 226
{ ((c).emplace_back(std::forward< _Args> (__args)...)); } 
# 241 "/usr/include/c++/5/bits/stl_queue.h" 3
void pop() 
# 242
{ 
# 243
; 
# 244
((c).pop_front()); 
# 245
} 
# 249
void swap(queue &__q) noexcept(noexcept(swap(c, (__q.c)))) 
# 251
{ 
# 252
using std::swap;
# 253
swap(c, (__q.c)); 
# 254
} 
# 256
}; 
# 269 "/usr/include/c++/5/bits/stl_queue.h" 3
template< class _Tp, class _Seq> inline bool 
# 271
operator==(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 272
{ return (__x.c) == (__y.c); } 
# 287 "/usr/include/c++/5/bits/stl_queue.h" 3
template< class _Tp, class _Seq> inline bool 
# 289
operator<(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 290
{ return (__x.c) < (__y.c); } 
# 293
template< class _Tp, class _Seq> inline bool 
# 295
operator!=(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 296
{ return !(__x == __y); } 
# 299
template< class _Tp, class _Seq> inline bool 
# 301
operator>(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 302
{ return __y < __x; } 
# 305
template< class _Tp, class _Seq> inline bool 
# 307
operator<=(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 308
{ return !(__y < __x); } 
# 311
template< class _Tp, class _Seq> inline bool 
# 313
operator>=(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 314
{ return !(__x < __y); } 
# 317
template< class _Tp, class _Seq> inline void 
# 319
swap(queue< _Tp, _Seq>  &__x, queue< _Tp, _Seq>  &__y) noexcept(noexcept((__x.swap(__y)))) 
# 321
{ (__x.swap(__y)); } 
# 323
template< class _Tp, class _Seq, class _Alloc> 
# 324
struct uses_allocator< queue< _Tp, _Seq> , _Alloc>  : public uses_allocator< _Seq, _Alloc> ::type { 
# 325
}; 
# 368 "/usr/include/c++/5/bits/stl_queue.h" 3
template< class _Tp, class _Sequence = vector< _Tp> , class 
# 369
_Compare = less< typename _Sequence::value_type> > 
# 370
class priority_queue { 
# 373
typedef typename _Sequence::value_type _Sequence_value_type; 
# 382
public: typedef typename _Sequence::value_type value_type; 
# 383
typedef typename _Sequence::reference reference; 
# 384
typedef typename _Sequence::const_reference const_reference; 
# 385
typedef typename _Sequence::size_type size_type; 
# 386
typedef _Sequence container_type; 
# 390
protected: _Sequence c; 
# 391
_Compare comp; 
# 405 "/usr/include/c++/5/bits/stl_queue.h" 3
public: explicit priority_queue(const _Compare &__x, const _Sequence &
# 406
__s) : c(__s), comp(__x) 
# 408
{ std::make_heap(((c).begin()), ((c).end()), comp); } 
# 411
explicit priority_queue(const _Compare &__x = _Compare(), _Sequence &&
# 412
__s = _Sequence()) : c(std::move(__s)), comp(__x) 
# 414
{ std::make_heap(((c).begin()), ((c).end()), comp); } 
# 444 "/usr/include/c++/5/bits/stl_queue.h" 3
template< class _InputIterator> 
# 445
priority_queue(_InputIterator __first, _InputIterator __last, const _Compare &
# 446
__x, const _Sequence &
# 447
__s) : c(__s), comp(__x) 
# 449
{ 
# 450
; 
# 451
((c).insert(((c).end()), __first, __last)); 
# 452
std::make_heap(((c).begin()), ((c).end()), comp); 
# 453
} 
# 455
template< class _InputIterator> 
# 456
priority_queue(_InputIterator __first, _InputIterator __last, const _Compare &
# 457
__x = _Compare(), _Sequence &&
# 458
__s = _Sequence()) : c(std::move(__s)), comp(__x) 
# 460
{ 
# 461
; 
# 462
((c).insert(((c).end()), __first, __last)); 
# 463
std::make_heap(((c).begin()), ((c).end()), comp); 
# 464
} 
# 471
bool empty() const 
# 472
{ return ((c).empty()); } 
# 476
size_type size() const 
# 477
{ return ((c).size()); } 
# 484
const_reference top() const 
# 485
{ 
# 486
; 
# 487
return ((c).front()); 
# 488
} 
# 499 "/usr/include/c++/5/bits/stl_queue.h" 3
void push(const value_type &__x) 
# 500
{ 
# 501
((c).push_back(__x)); 
# 502
std::push_heap(((c).begin()), ((c).end()), comp); 
# 503
} 
# 507
void push(value_type &&__x) 
# 508
{ 
# 509
((c).push_back(std::move(__x))); 
# 510
std::push_heap(((c).begin()), ((c).end()), comp); 
# 511
} 
# 513
template< class ..._Args> void 
# 515
emplace(_Args &&...__args) 
# 516
{ 
# 517
((c).emplace_back(std::forward< _Args> (__args)...)); 
# 518
std::push_heap(((c).begin()), ((c).end()), comp); 
# 519
} 
# 534 "/usr/include/c++/5/bits/stl_queue.h" 3
void pop() 
# 535
{ 
# 536
; 
# 537
std::pop_heap(((c).begin()), ((c).end()), comp); 
# 538
((c).pop_back()); 
# 539
} 
# 543
void swap(priority_queue &__pq) noexcept(noexcept(swap(c, (__pq.c))) && noexcept(swap(comp, (__pq.comp)))) 
# 545
{ 
# 546
using std::swap;
# 547
swap(c, (__pq.c)); 
# 548
swap(comp, (__pq.comp)); 
# 549
} 
# 551
}; 
# 556
template< class _Tp, class _Sequence, class _Compare> inline void 
# 558
swap(priority_queue< _Tp, _Sequence, _Compare>  &__x, priority_queue< _Tp, _Sequence, _Compare>  &
# 559
__y) noexcept(noexcept((__x.swap(__y)))) 
# 561
{ (__x.swap(__y)); } 
# 563
template< class _Tp, class _Sequence, class _Compare, class 
# 564
_Alloc> 
# 565
struct uses_allocator< priority_queue< _Tp, _Sequence, _Compare> , _Alloc>  : public uses_allocator< _Sequence, _Alloc> ::type { 
# 566
}; 
# 570
}
# 52 "/usr/include/opencv2/stitching/detail/util_inl.hpp" 3
namespace cv { 
# 53
namespace detail { 
# 55
template< class B> B 
# 56
Graph::forEach(B body) const 
# 57
{ 
# 58
for (int i = 0; i < this->numVertices(); ++i) 
# 59
{ 
# 60
std::__cxx11::list< GraphEdge> ::const_iterator edge = (edges_)[i].begin(); 
# 61
for (; (edge != ((edges_)[i].end())); (++edge)) { 
# 62
body((*edge)); }  
# 63
}  
# 64
return body; 
# 65
} 
# 68
template< class B> B 
# 69
Graph::walkBreadthFirst(int from, B body) const 
# 70
{ 
# 71
std::vector< bool>  was(this->numVertices(), false); 
# 72
std::queue< int>  vertices; 
# 74
((was[from]) = (true)); 
# 75
vertices.push(from); 
# 77
while (!vertices.empty()) 
# 78
{ 
# 79
int vertex = vertices.front(); 
# 80
vertices.pop(); 
# 82
std::__cxx11::list< GraphEdge> ::const_iterator edge = (edges_)[vertex].begin(); 
# 83
for (; (edge != ((edges_)[vertex].end())); (++edge)) 
# 84
{ 
# 85
if (!was[edge->to]) 
# 86
{ 
# 87
body((*edge)); 
# 88
((was[edge->to]) = (true)); 
# 89
vertices.push(edge->to); 
# 90
}  
# 91
}  
# 92
}  
# 94
return body; 
# 95
} 
# 102
static inline float normL2(const Point3f &a) 
# 103
{ 
# 104
return (((a.x) * (a.x)) + ((a.y) * (a.y))) + ((a.z) * (a.z)); 
# 105
} 
# 109
static inline float normL2(const Point3f &a, const Point3f &b) 
# 110
{ 
# 111
return normL2((a - b)); 
# 112
} 
# 116
static inline double normL2sq(const Mat &r) 
# 117
{ 
# 118
return r.dot(r); 
# 119
} 
# 122
static inline int sqr(int x) { return x * x; } 
# 123
static inline float sqr(float x) { return x * x; } 
# 124
static inline double sqr(double x) { return x * x; } 
# 126
}
# 127
}
# 48 "/usr/include/opencv2/stitching/detail/camera.hpp" 3
namespace cv { 
# 49
namespace detail { 
# 58 "/usr/include/opencv2/stitching/detail/camera.hpp" 3
struct __attribute((visibility("default"))) CameraParams { 
# 60
CameraParams(); 
# 61
CameraParams(const CameraParams & other); 
# 62
CameraParams &operator=(const CameraParams & other); 
# 63
Mat K() const; 
# 65
double focal; 
# 66
double aspect; 
# 67
double ppx; 
# 68
double ppy; 
# 69
Mat R; 
# 70
Mat t; 
# 71
}; 
# 75
}
# 76
}
# 51 "/usr/include/opencv2/stitching/detail/motion_estimators.hpp" 3
namespace cv { 
# 52
namespace detail { 
# 65 "/usr/include/opencv2/stitching/detail/motion_estimators.hpp" 3
class __attribute((visibility("default"))) Estimator { 
# 68
public: virtual ~Estimator() { } 
# 77 "/usr/include/opencv2/stitching/detail/motion_estimators.hpp" 3
bool operator()(const std::vector< ImageFeatures>  &features, const std::vector< MatchesInfo>  &
# 78
pairwise_matches, std::vector< CameraParams>  &
# 79
cameras) 
# 80
{ return this->estimate(features, pairwise_matches, cameras); } 
# 91 "/usr/include/opencv2/stitching/detail/motion_estimators.hpp" 3
protected: virtual bool estimate(const std::vector< ImageFeatures>  & features, const std::vector< MatchesInfo>  & pairwise_matches, std::vector< CameraParams>  & cameras) = 0; 
# 94
}; 
# 98
class __attribute((visibility("default"))) HomographyBasedEstimator : public Estimator { 
# 101
public: HomographyBasedEstimator(bool is_focals_estimated = false) : is_focals_estimated_(is_focals_estimated) 
# 102
{ } 
# 105
private: virtual bool estimate(const std::vector< ImageFeatures>  & features, const std::vector< MatchesInfo>  & pairwise_matches, std::vector< CameraParams>  & cameras); 
# 109
bool is_focals_estimated_; 
# 110
}; 
# 119 "/usr/include/opencv2/stitching/detail/motion_estimators.hpp" 3
class __attribute((visibility("default"))) AffineBasedEstimator : public Estimator { 
# 122
virtual bool estimate(const std::vector< ImageFeatures>  & features, const std::vector< MatchesInfo>  & pairwise_matches, std::vector< CameraParams>  & cameras); 
# 125
}; 
# 129
class __attribute((visibility("default"))) BundleAdjusterBase : public Estimator { 
# 132
public: const Mat refinementMask() const { return (refinement_mask_).clone(); } 
# 133
void setRefinementMask(const Mat &mask) 
# 134
{ 
# 135
if (!(!((mask.type() == 0) && ((((mask.size)()) == Size(3, 3)))))) { ; } else { cv::error(cv::Error::StsAssert, "mask.type() == 0 && mask.size() == Size(3, 3)", __func__, "/usr/include/opencv2/stitching/detail/motion_estimators.hpp", 135); }  
# 136
((refinement_mask_) = (mask.clone())); 
# 137
} 
# 139
double confThresh() const { return conf_thresh_; } 
# 140
void setConfThresh(double conf_thresh) { (conf_thresh_) = conf_thresh; } 
# 142
TermCriteria termCriteria() { return term_criteria_; } 
# 143
void setTermCriteria(const TermCriteria &term_criteria) { (term_criteria_) = term_criteria; } 
# 151
protected: BundleAdjusterBase(int num_params_per_cam, int num_errs_per_measurement) : num_images_(0), total_num_matches_(0), num_params_per_cam_(num_params_per_cam), num_errs_per_measurement_(num_errs_per_measurement), features_((0)), pairwise_matches_((0)), conf_thresh_((0)) 
# 156
{ 
# 157
this->setRefinementMask((Mat::ones(3, 3, 0))); 
# 158
this->setConfThresh((1.0)); 
# 159
this->setTermCriteria(TermCriteria((TermCriteria::EPS) + (TermCriteria::COUNT), 1000, (double)(2.220446049250313081e-16L))); 
# 160
} 
# 163
virtual bool estimate(const std::vector< ImageFeatures>  & features, const std::vector< MatchesInfo>  & pairwise_matches, std::vector< CameraParams>  & cameras); 
# 171
virtual void setUpInitialCameraParams(const std::vector< CameraParams>  & cameras) = 0; 
# 176
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  & cameras) const = 0; 
# 181
virtual void calcError(Mat & err) = 0; 
# 187
virtual void calcJacobian(Mat & jac) = 0; 
# 190
Mat refinement_mask_; 
# 192
int num_images_; 
# 193
int total_num_matches_; 
# 195
int num_params_per_cam_; 
# 196
int num_errs_per_measurement_; 
# 198
const ImageFeatures *features_; 
# 199
const MatchesInfo *pairwise_matches_; 
# 202
double conf_thresh_; 
# 205
TermCriteria term_criteria_; 
# 208
Mat cam_params_; 
# 211
std::vector< std::pair< int, int> >  edges_; 
# 212
}; 
# 217
class __attribute((visibility("default"))) NoBundleAdjuster : public BundleAdjusterBase { 
# 220
public: NoBundleAdjuster() : BundleAdjusterBase(0, 0) { } 
# 223
private: virtual bool estimate(const std::vector< ImageFeatures>  &, const std::vector< MatchesInfo>  &, std::vector< CameraParams>  &) 
# 225
{ 
# 226
return true; 
# 227
} 
# 228
virtual void setUpInitialCameraParams(const std::vector< CameraParams>  &) { } 
# 229
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  &) const { } 
# 230
virtual void calcError(Mat &) { } 
# 231
virtual void calcJacobian(Mat &) { } 
# 232
}; 
# 241 "/usr/include/opencv2/stitching/detail/motion_estimators.hpp" 3
class __attribute((visibility("default"))) BundleAdjusterReproj : public BundleAdjusterBase { 
# 244
public: BundleAdjusterReproj() : BundleAdjusterBase(7, 2) { } 
# 247
private: virtual void setUpInitialCameraParams(const std::vector< CameraParams>  & cameras); 
# 248
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  & cameras) const; 
# 249
virtual void calcError(Mat & err); 
# 250
virtual void calcJacobian(Mat & jac); 
# 252
Mat err1_, err2_; 
# 253
}; 
# 261
class __attribute((visibility("default"))) BundleAdjusterRay : public BundleAdjusterBase { 
# 264
public: BundleAdjusterRay() : BundleAdjusterBase(4, 3) { } 
# 267
private: virtual void setUpInitialCameraParams(const std::vector< CameraParams>  & cameras); 
# 268
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  & cameras) const; 
# 269
virtual void calcError(Mat & err); 
# 270
virtual void calcJacobian(Mat & jac); 
# 272
Mat err1_, err2_; 
# 273
}; 
# 285 "/usr/include/opencv2/stitching/detail/motion_estimators.hpp" 3
class __attribute((visibility("default"))) BundleAdjusterAffine : public BundleAdjusterBase { 
# 288
public: BundleAdjusterAffine() : BundleAdjusterBase(6, 2) { } 
# 291
private: virtual void setUpInitialCameraParams(const std::vector< CameraParams>  & cameras); 
# 292
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  & cameras) const; 
# 293
virtual void calcError(Mat & err); 
# 294
virtual void calcJacobian(Mat & jac); 
# 296
Mat err1_, err2_; 
# 297
}; 
# 309 "/usr/include/opencv2/stitching/detail/motion_estimators.hpp" 3
class __attribute((visibility("default"))) BundleAdjusterAffinePartial : public BundleAdjusterBase { 
# 312
public: BundleAdjusterAffinePartial() : BundleAdjusterBase(4, 2) { } 
# 315
private: virtual void setUpInitialCameraParams(const std::vector< CameraParams>  & cameras); 
# 316
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  & cameras) const; 
# 317
virtual void calcError(Mat & err); 
# 318
virtual void calcJacobian(Mat & jac); 
# 320
Mat err1_, err2_; 
# 321
}; 
# 324
enum WaveCorrectKind { 
# 326
WAVE_CORRECT_HORIZ, 
# 327
WAVE_CORRECT_VERT
# 328
}; 
# 335
__attribute((visibility("default"))) void waveCorrect(std::vector< Mat>  & rmats, WaveCorrectKind kind); 
# 342
__attribute((visibility("default"))) String matchesGraphAsString(std::vector< String>  & pathes, std::vector< MatchesInfo>  & pairwise_matches, float conf_threshold); 
# 345
__attribute((visibility("default"))) std::vector< int>  leaveBiggestComponent(std::vector< ImageFeatures>  & features, std::vector< MatchesInfo>  & pairwise_matches, float conf_threshold); 
# 350
__attribute((visibility("default"))) void findMaxSpanningTree(int num_images, const std::vector< MatchesInfo>  & pairwise_matches, Graph & span_tree, std::vector< int>  & centers); 
# 356
}
# 357
}
# 52 "/usr/include/opencv2/stitching/detail/exposure_compensate.hpp" 3
namespace cv { 
# 53
namespace detail { 
# 60
class __attribute((visibility("default"))) ExposureCompensator { 
# 63
public: virtual ~ExposureCompensator() { } 
# 65
enum { NO, GAIN, GAIN_BLOCKS}; 
# 66
static Ptr< ExposureCompensator>  createDefault(int type); 
# 74
void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< UMat>  & masks); 
# 77
virtual void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< std::pair< UMat, unsigned char> >  & masks) = 0; 
# 86
virtual void apply(int index, Point corner, InputOutputArray image, InputArray mask) = 0; 
# 87
}; 
# 91
class __attribute((visibility("default"))) NoExposureCompensator : public ExposureCompensator { 
# 94
public: virtual void feed(const std::vector< Point_< int> >  &, const std::vector< UMat>  &, const std::vector< std::pair< UMat, unsigned char> >  &) 
# 95
{ } 
# 96
virtual void apply(int, Point, InputOutputArray, InputArray) { } 
# 97
}; 
# 102
class __attribute((visibility("default"))) GainCompensator : public ExposureCompensator { 
# 105
public: virtual void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< std::pair< UMat, unsigned char> >  & masks); 
# 107
virtual void apply(int index, Point corner, InputOutputArray image, InputArray mask); 
# 108
std::vector< double>  gains() const; 
# 111
private: Mat_< double>  gains_; 
# 112
}; 
# 117
class __attribute((visibility("default"))) BlocksGainCompensator : public ExposureCompensator { 
# 120
public: BlocksGainCompensator(int bl_width = 32, int bl_height = 32) : bl_width_(bl_width), bl_height_(bl_height) 
# 121
{ } 
# 122
virtual void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< std::pair< UMat, unsigned char> >  & masks); 
# 124
virtual void apply(int index, Point corner, InputOutputArray image, InputArray mask); 
# 127
private: int bl_width_, bl_height_; 
# 128
std::vector< UMat>  gain_maps_; 
# 129
}; 
# 133
}
# 134
}
# 50 "/usr/include/opencv2/stitching/detail/seam_finders.hpp" 3
namespace cv { 
# 51
namespace detail { 
# 58
class __attribute((visibility("default"))) SeamFinder { 
# 61
public: virtual ~SeamFinder() { } 
# 68
virtual void find(const std::vector< UMat>  & src, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks) = 0; 
# 70
}; 
# 74
class __attribute((visibility("default"))) NoSeamFinder : public SeamFinder { 
# 77
public: virtual void find(const std::vector< UMat>  &, const std::vector< Point_< int> >  &, std::vector< UMat>  &) { } 
# 78
}; 
# 82
class __attribute((visibility("default"))) PairwiseSeamFinder : public SeamFinder { 
# 85
public: virtual void find(const std::vector< UMat>  & src, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks); 
# 89
protected: void run(); 
# 96
virtual void findInPair(size_t first, size_t second, Rect roi) = 0; 
# 98
std::vector< UMat>  images_; 
# 99
std::vector< Size_< int> >  sizes_; 
# 100
std::vector< Point_< int> >  corners_; 
# 101
std::vector< UMat>  masks_; 
# 102
}; 
# 106
class __attribute((visibility("default"))) VoronoiSeamFinder : public PairwiseSeamFinder { 
# 109
public: virtual void find(const std::vector< UMat>  & src, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks); 
# 111
virtual void find(const std::vector< Size_< int> >  & size, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks); 
# 114
private: virtual void findInPair(size_t first, size_t second, Rect roi); 
# 115
}; 
# 118
class __attribute((visibility("default"))) DpSeamFinder : public SeamFinder { 
# 121
public: enum CostFunction { COLOR, COLOR_GRAD}; 
# 123
DpSeamFinder(CostFunction costFunc = COLOR); 
# 125
CostFunction costFunction() const { return costFunc_; } 
# 126
void setCostFunction(CostFunction val) { (costFunc_) = val; } 
# 128
virtual void find(const std::vector< UMat>  & src, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks); 
# 132
private: enum ComponentState { 
# 134
FIRST = 1, SECOND, INTERS = 4, 
# 135
INTERS_FIRST, 
# 136
INTERS_SECOND
# 137
}; 
# 139
class ImagePairLess { 
# 142
public: ImagePairLess(const std::vector< Mat>  &images, const std::vector< Point_< int> >  &corners) : src_(&images[0]), corners_(&corners[0]) 
# 143
{ } 
# 145
bool operator()(const std::pair< unsigned long, unsigned long>  &l, const std::pair< unsigned long, unsigned long>  &r) const 
# 146
{ 
# 147
Point c1 = (((corners_)[l.first]) + Point((((src_)[l.first]).cols) / 2, (((src_)[l.first]).rows) / 2)); 
# 148
Point c2 = (((corners_)[l.second]) + Point((((src_)[l.second]).cols) / 2, (((src_)[l.second]).rows) / 2)); 
# 149
int d1 = ((c1 - c2)).dot((c1 - c2)); 
# 151
(c1 = ((((corners_)[r.first]) + Point((((src_)[r.first]).cols) / 2, (((src_)[r.first]).rows) / 2)))); 
# 152
(c2 = ((((corners_)[r.second]) + Point((((src_)[r.second]).cols) / 2, (((src_)[r.second]).rows) / 2)))); 
# 153
int d2 = ((c1 - c2)).dot((c1 - c2)); 
# 155
return d1 < d2; 
# 156
} 
# 159
private: const Mat *src_; 
# 160
const Point *corners_; 
# 161
}; 
# 163
class ClosePoints { 
# 166
public: ClosePoints(int minDist) : minDist_(minDist) { } 
# 168
bool operator()(const Point &p1, const Point &p2) const 
# 169
{ 
# 170
int dist2 = (((p1.x) - (p2.x)) * ((p1.x) - (p2.x))) + (((p1.y) - (p2.y)) * ((p1.y) - (p2.y))); 
# 171
return dist2 < ((minDist_) * (minDist_)); 
# 172
} 
# 175
private: int minDist_; 
# 176
}; 
# 178
void process(const Mat & image1, const Mat & image2, Point tl1, Point tl2, Mat & mask1, Mat & mask2); 
# 181
void findComponents(); 
# 183
void findEdges(); 
# 185
void resolveConflicts(const Mat & image1, const Mat & image2, Point tl1, Point tl2, Mat & mask1, Mat & mask2); 
# 188
void computeGradients(const Mat & image1, const Mat & image2); 
# 190
bool hasOnlyOneNeighbor(int comp); 
# 192
bool closeToContour(int y, int x, const Mat_< unsigned char>  & contourMask); 
# 194
bool getSeamTips(int comp1, int comp2, Point & p1, Point & p2); 
# 196
void computeCosts(const Mat & image1, const Mat & image2, Point tl1, Point tl2, int comp, Mat_< float>  & costV, Mat_< float>  & costH); 
# 200
bool estimateSeam(const Mat & image1, const Mat & image2, Point tl1, Point tl2, int comp, Point p1, Point p2, std::vector< Point_< int> >  & seam, bool & isHorizontal); 
# 204
void updateLabelsUsingSeam(int comp1, int comp2, const std::vector< Point_< int> >  & seam, bool isHorizontalSeam); 
# 207
CostFunction costFunc_; 
# 210
Point unionTl_, unionBr_; 
# 211
Size unionSize_; 
# 212
Mat_< unsigned char>  mask1_, mask2_; 
# 213
Mat_< unsigned char>  contour1mask_, contour2mask_; 
# 214
Mat_< float>  gradx1_, grady1_; 
# 215
Mat_< float>  gradx2_, grady2_; 
# 218
int ncomps_; 
# 219
Mat_< int>  labels_; 
# 220
std::vector< ComponentState>  states_; 
# 221
std::vector< Point_< int> >  tls_, brs_; 
# 222
std::vector< std::vector< Point_< int> > >  contours_; 
# 223
std::set< std::pair< int, int> >  edges_; 
# 224
}; 
# 228
class __attribute((visibility("default"))) GraphCutSeamFinderBase { 
# 231
public: enum CostType { COST_COLOR, COST_COLOR_GRAD}; 
# 232
}; 
# 236
class __attribute((visibility("default"))) GraphCutSeamFinder : public GraphCutSeamFinderBase, public SeamFinder { 
# 239
public: GraphCutSeamFinder(int cost_type = COST_COLOR_GRAD, float terminal_cost = (10000.0F), float bad_region_penalty = (1000.0F)); 
# 242
virtual ~GraphCutSeamFinder(); 
# 244
virtual void find(const std::vector< UMat>  & src, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks); 
# 249
private: class Impl; 
# 250
Ptr< PairwiseSeamFinder>  impl_; 
# 251
}; 
# 282 "/usr/include/opencv2/stitching/detail/seam_finders.hpp" 3
}
# 283
}
# 52 "/usr/include/opencv2/stitching/detail/blenders.hpp" 3
namespace cv { 
# 53
namespace detail { 
# 62 "/usr/include/opencv2/stitching/detail/blenders.hpp" 3
class __attribute((visibility("default"))) Blender { 
# 65
public: virtual ~Blender() { } 
# 67
enum { NO, FEATHER, MULTI_BAND}; 
# 68
static Ptr< Blender>  createDefault(int type, bool try_gpu = false); 
# 75
void prepare(const std::vector< Point_< int> >  & corners, const std::vector< Size_< int> >  & sizes); 
# 77
virtual void prepare(Rect dst_roi); 
# 84
virtual void feed(InputArray img, InputArray mask, Point tl); 
# 90
virtual void blend(InputOutputArray dst, InputOutputArray dst_mask); 
# 93
protected: UMat dst_, dst_mask_; 
# 94
Rect dst_roi_; 
# 95
}; 
# 99
class __attribute((visibility("default"))) FeatherBlender : public Blender { 
# 102
public: inline FeatherBlender(float sharpness = (0.01999999955F)); 
# 104
float sharpness() const { return sharpness_; } 
# 105
void setSharpness(float val) { (sharpness_) = val; } 
# 107
virtual void prepare(Rect dst_roi); 
# 108
virtual void feed(InputArray img, InputArray mask, Point tl); 
# 109
virtual void blend(InputOutputArray dst, InputOutputArray dst_mask); 
# 113
Rect createWeightMaps(const std::vector< UMat>  & masks, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & weight_maps); 
# 117
private: float sharpness_; 
# 118
UMat weight_map_; 
# 119
UMat dst_weight_map_; 
# 120
}; 
# 122
inline FeatherBlender::FeatherBlender(float _sharpness) { this->setSharpness(_sharpness); } 
# 126
class __attribute((visibility("default"))) MultiBandBlender : public Blender { 
# 129
public: MultiBandBlender(int try_gpu = false, int num_bands = 5, int weight_type = 5); 
# 131
int numBands() const { return actual_num_bands_; } 
# 132
void setNumBands(int val) { (actual_num_bands_) = val; } 
# 134
virtual void prepare(Rect dst_roi); 
# 135
virtual void feed(InputArray img, InputArray mask, Point tl); 
# 136
virtual void blend(InputOutputArray dst, InputOutputArray dst_mask); 
# 139
private: int actual_num_bands_, num_bands_; 
# 140
std::vector< UMat>  dst_pyr_laplace_; 
# 141
std::vector< UMat>  dst_band_weights_; 
# 142
Rect dst_roi_final_; 
# 143
bool can_use_gpu_; 
# 144
int weight_type_; 
# 149
}; 
# 155
__attribute((visibility("default"))) void normalizeUsingWeightMap(InputArray weight, InputOutputArray src); 
# 157
__attribute((visibility("default"))) void createWeightMap(InputArray mask, float sharpness, InputOutputArray weight); 
# 159
__attribute((visibility("default"))) void createLaplacePyr(InputArray img, int num_levels, std::vector< UMat>  & pyr); 
# 160
__attribute((visibility("default"))) void createLaplacePyrGpu(InputArray img, int num_levels, std::vector< UMat>  & pyr); 
# 163
__attribute((visibility("default"))) void restoreImageFromLaplacePyr(std::vector< UMat>  & pyr); 
# 164
__attribute((visibility("default"))) void restoreImageFromLaplacePyrGpu(std::vector< UMat>  & pyr); 
# 168
}
# 169
}
# 107 "/usr/include/opencv2/stitching.hpp" 3
namespace cv { 
# 124 "/usr/include/opencv2/stitching.hpp" 3
class __attribute((visibility("default"))) Stitcher { 
# 127
public: enum { ORIG_RESOL = (-1)}; 
# 128
enum Status { 
# 130
OK, 
# 131
ERR_NEED_MORE_IMGS, 
# 132
ERR_HOMOGRAPHY_EST_FAIL, 
# 133
ERR_CAMERA_PARAMS_ADJUST_FAIL
# 134
}; 
# 135
enum Mode { 
# 142
PANORAMA, 
# 148
SCANS
# 150
}; 
# 158
static Stitcher createDefault(bool try_use_gpu = false); 
# 167 "/usr/include/opencv2/stitching.hpp" 3
static Ptr< Stitcher>  create(Mode mode = PANORAMA, bool try_use_gpu = false); 
# 169
double registrationResol() const { return registr_resol_; } 
# 170
void setRegistrationResol(double resol_mpx) { (registr_resol_) = resol_mpx; } 
# 172
double seamEstimationResol() const { return seam_est_resol_; } 
# 173
void setSeamEstimationResol(double resol_mpx) { (seam_est_resol_) = resol_mpx; } 
# 175
double compositingResol() const { return compose_resol_; } 
# 176
void setCompositingResol(double resol_mpx) { (compose_resol_) = resol_mpx; } 
# 178
double panoConfidenceThresh() const { return conf_thresh_; } 
# 179
void setPanoConfidenceThresh(double conf_thresh) { (conf_thresh_) = conf_thresh; } 
# 181
bool waveCorrection() const { return do_wave_correct_; } 
# 182
void setWaveCorrection(bool flag) { (do_wave_correct_) = flag; } 
# 184
detail::WaveCorrectKind waveCorrectKind() const { return wave_correct_kind_; } 
# 185
void setWaveCorrectKind(detail::WaveCorrectKind kind) { (wave_correct_kind_) = kind; } 
# 187
Ptr< detail::FeaturesFinder>  featuresFinder() { return features_finder_; } 
# 188
const Ptr< detail::FeaturesFinder>  featuresFinder() const { return features_finder_; } 
# 189
void setFeaturesFinder(Ptr< detail::FeaturesFinder>  features_finder) 
# 190
{ ((features_finder_) = features_finder); } 
# 192
Ptr< detail::FeaturesMatcher>  featuresMatcher() { return features_matcher_; } 
# 193
const Ptr< detail::FeaturesMatcher>  featuresMatcher() const { return features_matcher_; } 
# 194
void setFeaturesMatcher(Ptr< detail::FeaturesMatcher>  features_matcher) 
# 195
{ ((features_matcher_) = features_matcher); } 
# 197
const UMat &matchingMask() const { return matching_mask_; } 
# 198
void setMatchingMask(const UMat &mask) 
# 199
{ 
# 200
if (!(!((mask.type() == 0) && ((mask.cols) == (mask.rows))))) { ; } else { cv::error(cv::Error::StsAssert, "mask.type() == 0 && mask.cols == mask.rows", __func__, "/usr/include/opencv2/stitching.hpp", 200); }  
# 201
((matching_mask_) = (mask.clone())); 
# 202
} 
# 204
Ptr< detail::BundleAdjusterBase>  bundleAdjuster() { return bundle_adjuster_; } 
# 205
const Ptr< detail::BundleAdjusterBase>  bundleAdjuster() const { return bundle_adjuster_; } 
# 206
void setBundleAdjuster(Ptr< detail::BundleAdjusterBase>  bundle_adjuster) 
# 207
{ ((bundle_adjuster_) = bundle_adjuster); } 
# 216 "/usr/include/opencv2/stitching.hpp" 3
Ptr< WarperCreator>  warper() { return warper_; } 
# 217
const Ptr< WarperCreator>  warper() const { return warper_; } 
# 218
void setWarper(Ptr< WarperCreator>  creator) { ((warper_) = creator); } 
# 220
Ptr< detail::ExposureCompensator>  exposureCompensator() { return exposure_comp_; } 
# 221
const Ptr< detail::ExposureCompensator>  exposureCompensator() const { return exposure_comp_; } 
# 222
void setExposureCompensator(Ptr< detail::ExposureCompensator>  exposure_comp) 
# 223
{ ((exposure_comp_) = exposure_comp); } 
# 225
Ptr< detail::SeamFinder>  seamFinder() { return seam_finder_; } 
# 226
const Ptr< detail::SeamFinder>  seamFinder() const { return seam_finder_; } 
# 227
void setSeamFinder(Ptr< detail::SeamFinder>  seam_finder) { ((seam_finder_) = seam_finder); } 
# 229
Ptr< detail::Blender>  blender() { return blender_; } 
# 230
const Ptr< detail::Blender>  blender() const { return blender_; } 
# 231
void setBlender(Ptr< detail::Blender>  b) { ((blender_) = b); } 
# 234
Status estimateTransform(InputArrayOfArrays images); 
# 244 "/usr/include/opencv2/stitching.hpp" 3
Status estimateTransform(InputArrayOfArrays images, const std::vector< std::vector< Rect_< int> > >  & rois); 
# 247
Status composePanorama(OutputArray pano); 
# 259 "/usr/include/opencv2/stitching.hpp" 3
Status composePanorama(InputArrayOfArrays images, OutputArray pano); 
# 262
Status stitch(InputArrayOfArrays images, OutputArray pano); 
# 270
Status stitch(InputArrayOfArrays images, const std::vector< std::vector< Rect_< int> > >  & rois, OutputArray pano); 
# 272
std::vector< int>  component() const { return indices_; } 
# 273
std::vector< detail::CameraParams>  cameras() const { return cameras_; } 
# 274
double workScale() const { return work_scale_; } 
# 279
private: Status matchImages(); 
# 280
Status estimateCameraParams(); 
# 282
double registr_resol_; 
# 283
double seam_est_resol_; 
# 284
double compose_resol_; 
# 285
double conf_thresh_; 
# 286
Ptr< detail::FeaturesFinder>  features_finder_; 
# 287
Ptr< detail::FeaturesMatcher>  features_matcher_; 
# 288
UMat matching_mask_; 
# 289
Ptr< detail::BundleAdjusterBase>  bundle_adjuster_; 
# 293
bool do_wave_correct_; 
# 294
detail::WaveCorrectKind wave_correct_kind_; 
# 295
Ptr< WarperCreator>  warper_; 
# 296
Ptr< detail::ExposureCompensator>  exposure_comp_; 
# 297
Ptr< detail::SeamFinder>  seam_finder_; 
# 298
Ptr< detail::Blender>  blender_; 
# 300
std::vector< UMat>  imgs_; 
# 301
std::vector< std::vector< Rect_< int> > >  rois_; 
# 302
std::vector< Size_< int> >  full_img_sizes_; 
# 303
std::vector< detail::ImageFeatures>  features_; 
# 304
std::vector< detail::MatchesInfo>  pairwise_matches_; 
# 305
std::vector< UMat>  seam_est_imgs_; 
# 306
std::vector< int>  indices_; 
# 307
std::vector< detail::CameraParams>  cameras_; 
# 308
double work_scale_; 
# 309
double seam_scale_; 
# 310
double seam_work_aspect_; 
# 311
double warped_image_scale_; 
# 312
}; 
# 314
__attribute((visibility("default"))) Ptr< Stitcher>  createStitcher(bool try_use_gpu = false); 
# 318
}
# 48 "/usr/include/opencv2/superres/optical_flow.hpp" 3
namespace cv { 
# 50
namespace superres { 
# 56
class __attribute((visibility("default"))) DenseOpticalFlowExt : public Algorithm { 
# 59
public: virtual void calc(InputArray frame0, InputArray frame1, OutputArray flow1, OutputArray flow2 = noArray()) = 0; 
# 60
virtual void collectGarbage() = 0; 
# 61
}; 
# 64
class __attribute((visibility("default"))) FarnebackOpticalFlow : virtual public DenseOpticalFlowExt { 
# 68
public: virtual double getPyrScale() const = 0; 
# 70
virtual void setPyrScale(double val) = 0; 
# 72
virtual int getLevelsNumber() const = 0; 
# 74
virtual void setLevelsNumber(int val) = 0; 
# 76
virtual int getWindowSize() const = 0; 
# 78
virtual void setWindowSize(int val) = 0; 
# 80
virtual int getIterations() const = 0; 
# 82
virtual void setIterations(int val) = 0; 
# 84
virtual int getPolyN() const = 0; 
# 86
virtual void setPolyN(int val) = 0; 
# 88
virtual double getPolySigma() const = 0; 
# 90
virtual void setPolySigma(double val) = 0; 
# 92
virtual int getFlags() const = 0; 
# 94
virtual void setFlags(int val) = 0; 
# 95
}; 
# 96
__attribute((visibility("default"))) Ptr< FarnebackOpticalFlow>  createOptFlow_Farneback(); 
# 97
__attribute((visibility("default"))) Ptr< FarnebackOpticalFlow>  createOptFlow_Farneback_CUDA(); 
# 103
class __attribute((visibility("default"))) DualTVL1OpticalFlow : virtual public DenseOpticalFlowExt { 
# 107
public: virtual double getTau() const = 0; 
# 109
virtual void setTau(double val) = 0; 
# 111
virtual double getLambda() const = 0; 
# 113
virtual void setLambda(double val) = 0; 
# 115
virtual double getTheta() const = 0; 
# 117
virtual void setTheta(double val) = 0; 
# 119
virtual int getScalesNumber() const = 0; 
# 121
virtual void setScalesNumber(int val) = 0; 
# 123
virtual int getWarpingsNumber() const = 0; 
# 125
virtual void setWarpingsNumber(int val) = 0; 
# 127
virtual double getEpsilon() const = 0; 
# 129
virtual void setEpsilon(double val) = 0; 
# 131
virtual int getIterations() const = 0; 
# 133
virtual void setIterations(int val) = 0; 
# 135
virtual bool getUseInitialFlow() const = 0; 
# 137
virtual void setUseInitialFlow(bool val) = 0; 
# 138
}; 
# 139
__attribute((visibility("default"))) Ptr< DualTVL1OpticalFlow>  createOptFlow_DualTVL1(); 
# 140
__attribute((visibility("default"))) Ptr< DualTVL1OpticalFlow>  createOptFlow_DualTVL1_CUDA(); 
# 143
class __attribute((visibility("default"))) BroxOpticalFlow : virtual public DenseOpticalFlowExt { 
# 148
public: virtual double getAlpha() const = 0; 
# 150
virtual void setAlpha(double val) = 0; 
# 153
virtual double getGamma() const = 0; 
# 155
virtual void setGamma(double val) = 0; 
# 158
virtual double getScaleFactor() const = 0; 
# 160
virtual void setScaleFactor(double val) = 0; 
# 163
virtual int getInnerIterations() const = 0; 
# 165
virtual void setInnerIterations(int val) = 0; 
# 168
virtual int getOuterIterations() const = 0; 
# 170
virtual void setOuterIterations(int val) = 0; 
# 173
virtual int getSolverIterations() const = 0; 
# 175
virtual void setSolverIterations(int val) = 0; 
# 176
}; 
# 177
__attribute((visibility("default"))) Ptr< BroxOpticalFlow>  createOptFlow_Brox_CUDA(); 
# 180
class PyrLKOpticalFlow : virtual public DenseOpticalFlowExt { 
# 184
public: virtual int getWindowSize() const = 0; 
# 186
virtual void setWindowSize(int val) = 0; 
# 188
virtual int getMaxLevel() const = 0; 
# 190
virtual void setMaxLevel(int val) = 0; 
# 192
virtual int getIterations() const = 0; 
# 194
virtual void setIterations(int val) = 0; 
# 195
}; 
# 196
__attribute((visibility("default"))) Ptr< PyrLKOpticalFlow>  createOptFlow_PyrLK_CUDA(); 
# 200
}
# 201
}
# 58 "/usr/include/opencv2/superres.hpp" 3
namespace cv { 
# 60
namespace superres { 
# 66
class __attribute((visibility("default"))) FrameSource { 
# 69
public: virtual ~FrameSource(); 
# 71
virtual void nextFrame(OutputArray frame) = 0; 
# 72
virtual void reset() = 0; 
# 73
}; 
# 75
__attribute((visibility("default"))) Ptr< FrameSource>  createFrameSource_Empty(); 
# 77
__attribute((visibility("default"))) Ptr< FrameSource>  createFrameSource_Video(const String & fileName); 
# 78
__attribute((visibility("default"))) Ptr< FrameSource>  createFrameSource_Video_CUDA(const String & fileName); 
# 80
__attribute((visibility("default"))) Ptr< FrameSource>  createFrameSource_Camera(int deviceId = 0); 
# 87
class __attribute((visibility("default"))) SuperResolution : public Algorithm, public FrameSource { 
# 94
public: void setInput(const Ptr< FrameSource>  & frameSource); 
# 100
virtual void nextFrame(OutputArray frame); 
# 101
virtual void reset(); 
# 105
virtual void collectGarbage(); 
# 109
virtual int getScale() const = 0; 
# 111
virtual void setScale(int val) = 0; 
# 115
virtual int getIterations() const = 0; 
# 117
virtual void setIterations(int val) = 0; 
# 121
virtual double getTau() const = 0; 
# 123
virtual void setTau(double val) = 0; 
# 127
virtual double getLabmda() const = 0; 
# 129
virtual void setLabmda(double val) = 0; 
# 133
virtual double getAlpha() const = 0; 
# 135
virtual void setAlpha(double val) = 0; 
# 139
virtual int getKernelSize() const = 0; 
# 141
virtual void setKernelSize(int val) = 0; 
# 145
virtual int getBlurKernelSize() const = 0; 
# 147
virtual void setBlurKernelSize(int val) = 0; 
# 151
virtual double getBlurSigma() const = 0; 
# 153
virtual void setBlurSigma(double val) = 0; 
# 157
virtual int getTemporalAreaRadius() const = 0; 
# 159
virtual void setTemporalAreaRadius(int val) = 0; 
# 163
virtual Ptr< DenseOpticalFlowExt>  getOpticalFlow() const = 0; 
# 165
virtual void setOpticalFlow(const Ptr< DenseOpticalFlowExt>  & val) = 0; 
# 168
protected: SuperResolution(); 
# 170
virtual void initImpl(Ptr< FrameSource>  & frameSource) = 0; 
# 171
virtual void processImpl(Ptr< FrameSource>  & frameSource, OutputArray output) = 0; 
# 173
bool isUmat_; 
# 176
private: Ptr< FrameSource>  frameSource_; 
# 177
bool firstCall_; 
# 178
}; 
# 199 "/usr/include/opencv2/superres.hpp" 3
__attribute((visibility("default"))) Ptr< SuperResolution>  createSuperResolution_BTVL1(); 
# 200
__attribute((visibility("default"))) Ptr< SuperResolution>  createSuperResolution_BTVL1_CUDA(); 
# 204
}
# 205
}
# 50 "/usr/include/opencv2/video/tracking.hpp" 3
namespace cv { 
# 56
enum { OPTFLOW_USE_INITIAL_FLOW = 4, 
# 57
OPTFLOW_LK_GET_MIN_EIGENVALS = 8, 
# 58
OPTFLOW_FARNEBACK_GAUSSIAN = 256
# 59
}; 
# 79 "/usr/include/opencv2/video/tracking.hpp" 3
__attribute((visibility("default"))) RotatedRect CamShift(InputArray probImage, Rect & window, TermCriteria criteria); 
# 103 "/usr/include/opencv2/video/tracking.hpp" 3
__attribute((visibility("default"))) int meanShift(InputArray probImage, Rect & window, TermCriteria criteria); 
# 120 "/usr/include/opencv2/video/tracking.hpp" 3
__attribute((visibility("default"))) int buildOpticalFlowPyramid(InputArray img, OutputArrayOfArrays pyramid, Size winSize, int maxLevel, bool withDerivatives = true, int pyrBorder = BORDER_REFLECT_101, int derivBorder = BORDER_CONSTANT, bool tryReuseInputImage = true); 
# 176 "/usr/include/opencv2/video/tracking.hpp" 3
__attribute((visibility("default"))) void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize = Size(21, 21), int maxLevel = 3, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (0.01000000000000000021)), int flags = 0, double minEigThreshold = (0.0001000000000000000048)); 
# 221 "/usr/include/opencv2/video/tracking.hpp" 3
__attribute((visibility("default"))) void calcOpticalFlowFarneback(InputArray prev, InputArray next, InputOutputArray flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags); 
# 253 "/usr/include/opencv2/video/tracking.hpp" 3
__attribute((visibility("default"))) Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine); 
# 257
enum { 
# 258
MOTION_TRANSLATION, 
# 259
MOTION_EUCLIDEAN, 
# 260
MOTION_AFFINE, 
# 261
MOTION_HOMOGRAPHY
# 262
}; 
# 318 "/usr/include/opencv2/video/tracking.hpp" 3
__attribute((visibility("default"))) double findTransformECC(InputArray templateImage, InputArray inputImage, InputOutputArray warpMatrix, int motionType = MOTION_AFFINE, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 50, (0.001000000000000000021)), InputArray inputMask = noArray()); 
# 334 "/usr/include/opencv2/video/tracking.hpp" 3
class __attribute((visibility("default"))) KalmanFilter { 
# 337
public: KalmanFilter(); 
# 344
KalmanFilter(int dynamParams, int measureParams, int controlParams = 0, int type = 5); 
# 353 "/usr/include/opencv2/video/tracking.hpp" 3
void init(int dynamParams, int measureParams, int controlParams = 0, int type = 5); 
# 359
const Mat &predict(const Mat & control = Mat()); 
# 365
const Mat &correct(const Mat & measurement); 
# 367
Mat statePre; 
# 368
Mat statePost; 
# 369
Mat transitionMatrix; 
# 370
Mat controlMatrix; 
# 371
Mat measurementMatrix; 
# 372
Mat processNoiseCov; 
# 373
Mat measurementNoiseCov; 
# 374
Mat errorCovPre; 
# 375
Mat gain; 
# 376
Mat errorCovPost; 
# 379
Mat temp1; 
# 380
Mat temp2; 
# 381
Mat temp3; 
# 382
Mat temp4; 
# 383
Mat temp5; 
# 384
}; 
# 387
class __attribute((visibility("default"))) DenseOpticalFlow : public Algorithm { 
# 396
public: virtual void calc(InputArray I0, InputArray I1, InputOutputArray flow) = 0; 
# 399
virtual void collectGarbage() = 0; 
# 400
}; 
# 404
class __attribute((visibility("default"))) SparseOpticalFlow : public Algorithm { 
# 417 "/usr/include/opencv2/video/tracking.hpp" 3
public: virtual void calc(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err = cv::noArray()) = 0; 
# 421
}; 
# 465 "/usr/include/opencv2/video/tracking.hpp" 3
class __attribute((visibility("default"))) DualTVL1OpticalFlow : public DenseOpticalFlow { 
# 470
public: virtual double getTau() const = 0; 
# 472
virtual void setTau(double val) = 0; 
# 475
virtual double getLambda() const = 0; 
# 477
virtual void setLambda(double val) = 0; 
# 480
virtual double getTheta() const = 0; 
# 482
virtual void setTheta(double val) = 0; 
# 485
virtual double getGamma() const = 0; 
# 487
virtual void setGamma(double val) = 0; 
# 490
virtual int getScalesNumber() const = 0; 
# 492
virtual void setScalesNumber(int val) = 0; 
# 495
virtual int getWarpingsNumber() const = 0; 
# 497
virtual void setWarpingsNumber(int val) = 0; 
# 500
virtual double getEpsilon() const = 0; 
# 502
virtual void setEpsilon(double val) = 0; 
# 505
virtual int getInnerIterations() const = 0; 
# 507
virtual void setInnerIterations(int val) = 0; 
# 510
virtual int getOuterIterations() const = 0; 
# 512
virtual void setOuterIterations(int val) = 0; 
# 515
virtual bool getUseInitialFlow() const = 0; 
# 517
virtual void setUseInitialFlow(bool val) = 0; 
# 520
virtual double getScaleStep() const = 0; 
# 522
virtual void setScaleStep(double val) = 0; 
# 525
virtual int getMedianFiltering() const = 0; 
# 527
virtual void setMedianFiltering(int val) = 0; 
# 530
static Ptr< DualTVL1OpticalFlow>  create(double tau = (0.25), double lambda = (0.1499999999999999944), double theta = (0.2999999999999999889), int nscales = 5, int warps = 5, double epsilon = (0.01000000000000000021), int innnerIterations = 30, int outerIterations = 10, double scaleStep = (0.8000000000000000444), double gamma = (0.0), int medianFiltering = 5, bool useInitialFlow = false); 
# 543
}; 
# 547
__attribute((visibility("default"))) Ptr< DualTVL1OpticalFlow>  createOptFlow_DualTVL1(); 
# 551
class __attribute((visibility("default"))) FarnebackOpticalFlow : public DenseOpticalFlow { 
# 554
public: virtual int getNumLevels() const = 0; 
# 555
virtual void setNumLevels(int numLevels) = 0; 
# 557
virtual double getPyrScale() const = 0; 
# 558
virtual void setPyrScale(double pyrScale) = 0; 
# 560
virtual bool getFastPyramids() const = 0; 
# 561
virtual void setFastPyramids(bool fastPyramids) = 0; 
# 563
virtual int getWinSize() const = 0; 
# 564
virtual void setWinSize(int winSize) = 0; 
# 566
virtual int getNumIters() const = 0; 
# 567
virtual void setNumIters(int numIters) = 0; 
# 569
virtual int getPolyN() const = 0; 
# 570
virtual void setPolyN(int polyN) = 0; 
# 572
virtual double getPolySigma() const = 0; 
# 573
virtual void setPolySigma(double polySigma) = 0; 
# 575
virtual int getFlags() const = 0; 
# 576
virtual void setFlags(int flags) = 0; 
# 578
static Ptr< FarnebackOpticalFlow>  create(int numLevels = 5, double pyrScale = (0.5), bool fastPyramids = false, int winSize = 13, int numIters = 10, int polyN = 5, double polySigma = (1.100000000000000089), int flags = 0); 
# 587
}; 
# 598 "/usr/include/opencv2/video/tracking.hpp" 3
class __attribute((visibility("default"))) SparsePyrLKOpticalFlow : public SparseOpticalFlow { 
# 601
public: virtual Size getWinSize() const = 0; 
# 602
virtual void setWinSize(Size winSize) = 0; 
# 604
virtual int getMaxLevel() const = 0; 
# 605
virtual void setMaxLevel(int maxLevel) = 0; 
# 607
virtual TermCriteria getTermCriteria() const = 0; 
# 608
virtual void setTermCriteria(TermCriteria & crit) = 0; 
# 610
virtual int getFlags() const = 0; 
# 611
virtual void setFlags(int flags) = 0; 
# 613
virtual double getMinEigThreshold() const = 0; 
# 614
virtual void setMinEigThreshold(double minEigThreshold) = 0; 
# 616
static Ptr< SparsePyrLKOpticalFlow>  create(Size winSize = Size(21, 21), int maxLevel = 3, TermCriteria crit = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (0.01000000000000000021)), int flags = 0, double minEigThreshold = (0.0001000000000000000048)); 
# 622
}; 
# 626
}
# 49 "/usr/include/opencv2/video/background_segm.hpp" 3
namespace cv { 
# 60 "/usr/include/opencv2/video/background_segm.hpp" 3
class __attribute((visibility("default"))) BackgroundSubtractor : public Algorithm { 
# 72 "/usr/include/opencv2/video/background_segm.hpp" 3
public: virtual void apply(InputArray image, OutputArray fgmask, double learningRate = -1) = 0; 
# 81 "/usr/include/opencv2/video/background_segm.hpp" 3
virtual void getBackgroundImage(OutputArray backgroundImage) const = 0; 
# 82
}; 
# 90
class __attribute((visibility("default"))) BackgroundSubtractorMOG2 : public BackgroundSubtractor { 
# 95
public: virtual int getHistory() const = 0; 
# 98
virtual void setHistory(int history) = 0; 
# 102
virtual int getNMixtures() const = 0; 
# 107
virtual void setNMixtures(int nmixtures) = 0; 
# 115
virtual double getBackgroundRatio() const = 0; 
# 118
virtual void setBackgroundRatio(double ratio) = 0; 
# 125
virtual double getVarThreshold() const = 0; 
# 128
virtual void setVarThreshold(double varThreshold) = 0; 
# 138 "/usr/include/opencv2/video/background_segm.hpp" 3
virtual double getVarThresholdGen() const = 0; 
# 141
virtual void setVarThresholdGen(double varThresholdGen) = 0; 
# 145
virtual double getVarInit() const = 0; 
# 148
virtual void setVarInit(double varInit) = 0; 
# 150
virtual double getVarMin() const = 0; 
# 151
virtual void setVarMin(double varMin) = 0; 
# 153
virtual double getVarMax() const = 0; 
# 154
virtual void setVarMax(double varMax) = 0; 
# 162
virtual double getComplexityReductionThreshold() const = 0; 
# 165
virtual void setComplexityReductionThreshold(double ct) = 0; 
# 172
virtual bool getDetectShadows() const = 0; 
# 175
virtual void setDetectShadows(bool detectShadows) = 0; 
# 182
virtual int getShadowValue() const = 0; 
# 185
virtual void setShadowValue(int value) = 0; 
# 194 "/usr/include/opencv2/video/background_segm.hpp" 3
virtual double getShadowThreshold() const = 0; 
# 197
virtual void setShadowThreshold(double threshold) = 0; 
# 208 "/usr/include/opencv2/video/background_segm.hpp" 3
virtual void apply(InputArray image, OutputArray fgmask, double learningRate = -1) = 0; 
# 209
}; 
# 220 "/usr/include/opencv2/video/background_segm.hpp" 3
__attribute((visibility("default"))) Ptr< BackgroundSubtractorMOG2>  
# 221
createBackgroundSubtractorMOG2(int history = 500, double varThreshold = 16, bool detectShadows = true); 
# 229
class __attribute((visibility("default"))) BackgroundSubtractorKNN : public BackgroundSubtractor { 
# 234
public: virtual int getHistory() const = 0; 
# 237
virtual void setHistory(int history) = 0; 
# 241
virtual int getNSamples() const = 0; 
# 246
virtual void setNSamples(int _nN) = 0; 
# 253
virtual double getDist2Threshold() const = 0; 
# 256
virtual void setDist2Threshold(double _dist2Threshold) = 0; 
# 263
virtual int getkNNSamples() const = 0; 
# 266
virtual void setkNNSamples(int _nkNN) = 0; 
# 273
virtual bool getDetectShadows() const = 0; 
# 276
virtual void setDetectShadows(bool detectShadows) = 0; 
# 283
virtual int getShadowValue() const = 0; 
# 286
virtual void setShadowValue(int value) = 0; 
# 295 "/usr/include/opencv2/video/background_segm.hpp" 3
virtual double getShadowThreshold() const = 0; 
# 298
virtual void setShadowThreshold(double threshold) = 0; 
# 299
}; 
# 309 "/usr/include/opencv2/video/background_segm.hpp" 3
__attribute((visibility("default"))) Ptr< BackgroundSubtractorKNN>  
# 310
createBackgroundSubtractorKNN(int history = 500, double dist2Threshold = (400.0), bool detectShadows = true); 
# 315
}
# 50 "/usr/include/opencv2/video/tracking_c.h" 3
extern "C" {
# 73 "/usr/include/opencv2/video/tracking_c.h" 3
__attribute((visibility("default"))) void cvCalcOpticalFlowPyrLK(const CvArr * prev, const CvArr * curr, CvArr * prev_pyr, CvArr * curr_pyr, const CvPoint2D32f * prev_features, CvPoint2D32f * curr_features, int count, CvSize win_size, int level, char * status, float * track_error, CvTermCriteria criteria, int flags); 
# 88
__attribute((visibility("default"))) void cvCalcAffineFlowPyrLK(const CvArr * prev, const CvArr * curr, CvArr * prev_pyr, CvArr * curr_pyr, const CvPoint2D32f * prev_features, CvPoint2D32f * curr_features, float * matrices, int count, CvSize win_size, int level, char * status, float * track_error, CvTermCriteria criteria, int flags); 
# 98
__attribute((visibility("default"))) int cvEstimateRigidTransform(const CvArr * A, const CvArr * B, CvMat * M, int full_affine); 
# 102
__attribute((visibility("default"))) void cvCalcOpticalFlowFarneback(const CvArr * prev, const CvArr * next, CvArr * flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags); 
# 120 "/usr/include/opencv2/video/tracking_c.h" 3
__attribute((visibility("default"))) void cvUpdateMotionHistory(const CvArr * silhouette, CvArr * mhi, double timestamp, double duration); 
# 125
__attribute((visibility("default"))) void cvCalcMotionGradient(const CvArr * mhi, CvArr * mask, CvArr * orientation, double delta1, double delta2, int aperture_size = 3); 
# 132
__attribute((visibility("default"))) double cvCalcGlobalOrientation(const CvArr * orientation, const CvArr * mask, const CvArr * mhi, double timestamp, double duration); 
# 138
__attribute((visibility("default"))) CvSeq *cvSegmentMotion(const CvArr * mhi, CvArr * seg_mask, CvMemStorage * storage, double timestamp, double seg_thresh); 
# 148
__attribute((visibility("default"))) int cvCamShift(const CvArr * prob_image, CvRect window, CvTermCriteria criteria, CvConnectedComp * comp, CvBox2D * box = 0); 
# 154
__attribute((visibility("default"))) int cvMeanShift(const CvArr * prob_image, CvRect window, CvTermCriteria criteria, CvConnectedComp * comp); 
# 205
typedef 
# 163
struct CvKalman { 
# 165
int MP; 
# 166
int DP; 
# 167
int CP; 
# 171
float *PosterState; 
# 172
float *PriorState; 
# 173
float *DynamMatr; 
# 174
float *MeasurementMatr; 
# 175
float *MNCovariance; 
# 176
float *PNCovariance; 
# 177
float *KalmGainMatr; 
# 178
float *PriorErrorCovariance; 
# 179
float *PosterErrorCovariance; 
# 180
float *Temp1; 
# 181
float *Temp2; 
# 184
CvMat *state_pre; 
# 186
CvMat *state_post; 
# 188
CvMat *transition_matrix; 
# 189
CvMat *control_matrix; 
# 191
CvMat *measurement_matrix; 
# 192
CvMat *process_noise_cov; 
# 193
CvMat *measurement_noise_cov; 
# 194
CvMat *error_cov_pre; 
# 196
CvMat *gain; 
# 198
CvMat *error_cov_post; 
# 200
CvMat *temp1; 
# 201
CvMat *temp2; 
# 202
CvMat *temp3; 
# 203
CvMat *temp4; 
# 204
CvMat *temp5; 
# 205
} CvKalman; 
# 208
__attribute((visibility("default"))) CvKalman *cvCreateKalman(int dynam_params, int measure_params, int control_params = 0); 
# 212
__attribute((visibility("default"))) void cvReleaseKalman(CvKalman ** kalman); 
# 215
__attribute((visibility("default"))) const CvMat *cvKalmanPredict(CvKalman * kalman, const CvMat * control = 0); 
# 220
__attribute((visibility("default"))) const CvMat *cvKalmanCorrect(CvKalman * kalman, const CvMat * measurement); 
# 228
}
# 38 "/usr/include/aarch64-linux-gnu/c++/5/bits/c++io.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 42
typedef __gthread_mutex_t __c_lock; 
# 45
typedef FILE __c_file; 
# 48
}
# 44 "/usr/include/aarch64-linux-gnu/c++/5/bits/basic_file.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 49
template< class _CharT> class __basic_file; 
# 54
template<> class __basic_file< char>  { 
# 57
__c_file *_M_cfile; 
# 60
bool _M_cfile_created; 
# 63
public: __basic_file(__c_lock * __lock = 0) throw(); 
# 66
__basic_file(std::__basic_file< char>  &&__rv, __c_lock *__lock = 0) noexcept : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created) 
# 68
{ 
# 69
(__rv._M_cfile) = (nullptr); 
# 70
(__rv._M_cfile_created) = false; 
# 71
} 
# 73
std::__basic_file< char>  &operator=(const std::__basic_file< char>  &) = delete;
# 74
std::__basic_file< char>  &operator=(std::__basic_file< char>  &&) = delete;
# 77
void swap(std::__basic_file< char>  &__f) noexcept 
# 78
{ 
# 79
std::swap(_M_cfile, __f._M_cfile); 
# 80
std::swap(_M_cfile_created, __f._M_cfile_created); 
# 81
} 
# 85
std::__basic_file< char>  *open(const char * __name, ios_base::openmode __mode, int __prot = 436); 
# 88
std::__basic_file< char>  *sys_open(__c_file * __file, ios_base::openmode); 
# 91
std::__basic_file< char>  *sys_open(int __fd, ios_base::openmode __mode) throw(); 
# 94
std::__basic_file< char>  *close(); 
# 96
__attribute((__pure__)) bool 
# 97
is_open() const throw(); 
# 99
__attribute((__pure__)) int 
# 100
fd() throw(); 
# 102
__attribute((__pure__)) __c_file *
# 103
file() throw(); 
# 105
~__basic_file(); 
# 108
streamsize xsputn(const char * __s, streamsize __n); 
# 111
streamsize xsputn_2(const char * __s1, streamsize __n1, const char * __s2, streamsize __n2); 
# 115
streamsize xsgetn(char * __s, streamsize __n); 
# 118
streamoff seekoff(streamoff __off, ios_base::seekdir __way) throw(); 
# 121
int sync(); 
# 124
streamsize showmanyc(); 
# 125
}; 
# 128
}
# 47 "/usr/include/c++/5/fstream" 3
namespace std __attribute((__visibility__("default"))) { 
# 71 "/usr/include/c++/5/fstream" 3
template< class _CharT, class _Traits> 
# 72
class basic_filebuf : public basic_streambuf< _CharT, _Traits>  { 
# 75
template< class _Tp> using __chk_state = __and_< is_copy_assignable< _Tp> , is_copy_constructible< _Tp> , is_default_constructible< _Tp> > ; 
# 80
static_assert((__chk_state< typename _Traits::state_type> ::value), "state_type must be CopyAssignable, CopyConstructible and DefaultConstructible");
# 84
static_assert((is_same< typename _Traits::pos_type, fpos< typename _Traits::state_type> > ::value), "pos_type must be fpos<state_type>");
# 90
public: typedef _CharT char_type; 
# 91
typedef _Traits traits_type; 
# 92
typedef typename _Traits::int_type int_type; 
# 93
typedef typename _Traits::pos_type pos_type; 
# 94
typedef typename _Traits::off_type off_type; 
# 96
typedef ::std::basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 97
typedef basic_filebuf __filebuf_type; 
# 98
typedef ::std::__basic_file< char>  __file_type; 
# 99
typedef typename _Traits::state_type __state_type; 
# 100
typedef codecvt< _CharT, char, typename _Traits::state_type>  __codecvt_type; 
# 102
friend class ios_base; 
# 107
protected: ::std::__c_lock _M_lock; 
# 110
__file_type _M_file; 
# 113
::std::ios_base::openmode _M_mode; 
# 116
__state_type _M_state_beg; 
# 121
__state_type _M_state_cur; 
# 125
__state_type _M_state_last; 
# 128
char_type *_M_buf; 
# 135
::std::size_t _M_buf_size; 
# 138
bool _M_buf_allocated; 
# 147 "/usr/include/c++/5/fstream" 3
bool _M_reading; 
# 148
bool _M_writing; 
# 156
char_type _M_pback; 
# 157
char_type *_M_pback_cur_save; 
# 158
char_type *_M_pback_end_save; 
# 159
bool _M_pback_init; 
# 163
const __codecvt_type *_M_codecvt; 
# 170
char *_M_ext_buf; 
# 175
::std::streamsize _M_ext_buf_size; 
# 182
const char *_M_ext_next; 
# 183
char *_M_ext_end; 
# 191
void _M_create_pback() 
# 192
{ 
# 193
if (!(_M_pback_init)) 
# 194
{ 
# 195
(_M_pback_cur_save) = (this->gptr()); 
# 196
(_M_pback_end_save) = (this->egptr()); 
# 197
(this->setg(&(_M_pback), &(_M_pback), (&(_M_pback)) + 1)); 
# 198
(_M_pback_init) = true; 
# 199
}  
# 200
} 
# 208
void _M_destroy_pback() throw() 
# 209
{ 
# 210
if (_M_pback_init) 
# 211
{ 
# 213
(_M_pback_cur_save) += ((this->gptr()) != (this->eback())); 
# 214
(this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save)); 
# 215
(_M_pback_init) = false; 
# 216
}  
# 217
} 
# 227
public: basic_filebuf(); 
# 230
basic_filebuf(const basic_filebuf &) = delete;
# 231
basic_filebuf(basic_filebuf &&); 
# 238
virtual ~basic_filebuf() 
# 239
{ this->close(); } 
# 242
basic_filebuf &operator=(const basic_filebuf &) = delete;
# 243
basic_filebuf &operator=(basic_filebuf &&); 
# 244
void swap(basic_filebuf &); 
# 252
bool is_open() const throw() 
# 253
{ return (_M_file).is_open(); } 
# 297 "/usr/include/c++/5/fstream" 3
__filebuf_type *open(const char * __s, ::std::ios_base::openmode __mode); 
# 307 "/usr/include/c++/5/fstream" 3
__filebuf_type *open(const ::std::__cxx11::string &__s, ::std::ios_base::openmode __mode) 
# 308
{ return this->open(__s.c_str(), __mode); } 
# 324 "/usr/include/c++/5/fstream" 3
__filebuf_type *close(); 
# 328
protected: void _M_allocate_internal_buffer(); 
# 331
void _M_destroy_internal_buffer() throw(); 
# 335
virtual ::std::streamsize showmanyc(); 
# 343
virtual int_type underflow(); 
# 346
virtual int_type pbackfail(int_type __c = _Traits::eof()); 
# 356 "/usr/include/c++/5/fstream" 3
virtual int_type overflow(int_type __c = _Traits::eof()); 
# 361
bool _M_convert_to_external(char_type *, ::std::streamsize); 
# 376 "/usr/include/c++/5/fstream" 3
virtual __streambuf_type *setbuf(char_type * __s, ::std::streamsize __n); 
# 379
virtual pos_type seekoff(off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode = (::std::ios_base::in | ::std::ios_base::out)); 
# 383
virtual pos_type seekpos(pos_type __pos, ::std::ios_base::openmode __mode = (::std::ios_base::in | ::std::ios_base::out)); 
# 388
pos_type _M_seek(off_type __off, ::std::ios_base::seekdir __way, __state_type __state); 
# 391
int _M_get_ext_pos(__state_type & __state); 
# 394
virtual int sync(); 
# 397
virtual void imbue(const ::std::locale & __loc); 
# 400
virtual ::std::streamsize xsgetn(char_type * __s, ::std::streamsize __n); 
# 403
virtual ::std::streamsize xsputn(const char_type * __s, ::std::streamsize __n); 
# 407
bool _M_terminate_output(); 
# 422 "/usr/include/c++/5/fstream" 3
void _M_set_buffer(::std::streamsize __off) 
# 423
{ 
# 424
const bool __testin = ((_M_mode) & ::std::ios_base::in); 
# 425
const bool __testout = (((_M_mode) & ::std::ios_base::out)) || (((_M_mode) & ::std::ios_base::app)); 
# 428
if (__testin && (__off > (0))) { 
# 429
(this->setg(_M_buf, _M_buf, (_M_buf) + __off)); } else { 
# 431
(this->setg(_M_buf, _M_buf, _M_buf)); }  
# 433
if (__testout && (__off == (0)) && ((_M_buf_size) > (1))) { 
# 434
(this->setp(_M_buf, ((_M_buf) + (_M_buf_size)) - 1)); } else { 
# 436
(this->setp(0, 0)); }  
# 437
} 
# 438
}; 
# 454 "/usr/include/c++/5/fstream" 3
template< class _CharT, class _Traits> 
# 455
class basic_ifstream : public basic_istream< _CharT, _Traits>  { 
# 459
public: typedef _CharT char_type; 
# 460
typedef _Traits traits_type; 
# 461
typedef typename _Traits::int_type int_type; 
# 462
typedef typename _Traits::pos_type pos_type; 
# 463
typedef typename _Traits::off_type off_type; 
# 466
typedef basic_filebuf< _CharT, _Traits>  __filebuf_type; 
# 467
typedef ::std::basic_istream< _CharT, _Traits>  __istream_type; 
# 470
private: __filebuf_type _M_filebuf; 
# 481 "/usr/include/c++/5/fstream" 3
public: basic_ifstream() : __istream_type(), _M_filebuf() 
# 482
{ (this->init(&(_M_filebuf))); } 
# 495 "/usr/include/c++/5/fstream" 3
explicit basic_ifstream(const char *__s, ::std::ios_base::openmode __mode = ios_base::in) : __istream_type(), _M_filebuf() 
# 497
{ 
# 498
(this->init(&(_M_filebuf))); 
# 499
(this->open(__s, __mode)); 
# 500
} 
# 511 "/usr/include/c++/5/fstream" 3
explicit basic_ifstream(const ::std::__cxx11::string &__s, ::std::ios_base::openmode 
# 512
__mode = ios_base::in) : __istream_type(), _M_filebuf() 
# 514
{ 
# 515
(this->init(&(_M_filebuf))); 
# 516
(this->open(__s, __mode)); 
# 517
} 
# 519
basic_ifstream(const basic_ifstream &) = delete;
# 521
basic_ifstream(basic_ifstream &&__rhs) : __istream_type(::std::move(__rhs)), _M_filebuf(::std::move((__rhs._M_filebuf))) 
# 524
{ __istream_type::set_rdbuf(&(_M_filebuf)); } 
# 533 "/usr/include/c++/5/fstream" 3
~basic_ifstream() 
# 534
{ } 
# 540
basic_ifstream &operator=(const basic_ifstream &) = delete;
# 543
basic_ifstream &operator=(basic_ifstream &&__rhs) 
# 544
{ 
# 545
::std::basic_istream< _CharT, _Traits> ::operator=(::std::move(__rhs)); 
# 546
(_M_filebuf) = ::std::move((__rhs._M_filebuf)); 
# 547
return *this; 
# 548
} 
# 551
void swap(basic_ifstream &__rhs) 
# 552
{ 
# 553
__istream_type::swap(__rhs); 
# 554
((_M_filebuf).swap((__rhs._M_filebuf))); 
# 555
} 
# 566 "/usr/include/c++/5/fstream" 3
__filebuf_type *rdbuf() const 
# 567
{ return const_cast< __filebuf_type *>(&(_M_filebuf)); } 
# 574
bool is_open() 
# 575
{ return ((_M_filebuf).is_open()); } 
# 580
bool is_open() const 
# 581
{ return ((_M_filebuf).is_open()); } 
# 595 "/usr/include/c++/5/fstream" 3
void open(const char *__s, ::std::ios_base::openmode __mode = ios_base::in) 
# 596
{ 
# 597
if (!((_M_filebuf).open(__s, (__mode | ::std::ios_base::in)))) { 
# 598
(this->setstate(ios_base::failbit)); } else { 
# 602
(this->clear()); }  
# 603
} 
# 615 "/usr/include/c++/5/fstream" 3
void open(const ::std::__cxx11::string &__s, ::std::ios_base::openmode __mode = ios_base::in) 
# 616
{ 
# 617
if (!((_M_filebuf).open(__s, (__mode | ::std::ios_base::in)))) { 
# 618
(this->setstate(ios_base::failbit)); } else { 
# 622
(this->clear()); }  
# 623
} 
# 633 "/usr/include/c++/5/fstream" 3
void close() 
# 634
{ 
# 635
if (!((_M_filebuf).close())) { 
# 636
(this->setstate(ios_base::failbit)); }  
# 637
} 
# 638
}; 
# 655 "/usr/include/c++/5/fstream" 3
template< class _CharT, class _Traits> 
# 656
class basic_ofstream : public basic_ostream< _CharT, _Traits>  { 
# 660
public: typedef _CharT char_type; 
# 661
typedef _Traits traits_type; 
# 662
typedef typename _Traits::int_type int_type; 
# 663
typedef typename _Traits::pos_type pos_type; 
# 664
typedef typename _Traits::off_type off_type; 
# 667
typedef basic_filebuf< _CharT, _Traits>  __filebuf_type; 
# 668
typedef ::std::basic_ostream< _CharT, _Traits>  __ostream_type; 
# 671
private: __filebuf_type _M_filebuf; 
# 682 "/usr/include/c++/5/fstream" 3
public: basic_ofstream() : __ostream_type(), _M_filebuf() 
# 683
{ (this->init(&(_M_filebuf))); } 
# 697 "/usr/include/c++/5/fstream" 3
explicit basic_ofstream(const char *__s, ::std::ios_base::openmode 
# 698
__mode = (::std::ios_base::out | ::std::ios_base::trunc)) : __ostream_type(), _M_filebuf() 
# 700
{ 
# 701
(this->init(&(_M_filebuf))); 
# 702
(this->open(__s, __mode)); 
# 703
} 
# 715 "/usr/include/c++/5/fstream" 3
explicit basic_ofstream(const ::std::__cxx11::string &__s, ::std::ios_base::openmode 
# 716
__mode = (::std::ios_base::out | ::std::ios_base::trunc)) : __ostream_type(), _M_filebuf() 
# 718
{ 
# 719
(this->init(&(_M_filebuf))); 
# 720
(this->open(__s, __mode)); 
# 721
} 
# 723
basic_ofstream(const basic_ofstream &) = delete;
# 725
basic_ofstream(basic_ofstream &&__rhs) : __ostream_type(::std::move(__rhs)), _M_filebuf(::std::move((__rhs._M_filebuf))) 
# 728
{ __ostream_type::set_rdbuf(&(_M_filebuf)); } 
# 737 "/usr/include/c++/5/fstream" 3
~basic_ofstream() 
# 738
{ } 
# 744
basic_ofstream &operator=(const basic_ofstream &) = delete;
# 747
basic_ofstream &operator=(basic_ofstream &&__rhs) 
# 748
{ 
# 749
::std::basic_ostream< _CharT, _Traits> ::operator=(::std::move(__rhs)); 
# 750
(_M_filebuf) = ::std::move((__rhs._M_filebuf)); 
# 751
return *this; 
# 752
} 
# 755
void swap(basic_ofstream &__rhs) 
# 756
{ 
# 757
__ostream_type::swap(__rhs); 
# 758
((_M_filebuf).swap((__rhs._M_filebuf))); 
# 759
} 
# 770 "/usr/include/c++/5/fstream" 3
__filebuf_type *rdbuf() const 
# 771
{ return const_cast< __filebuf_type *>(&(_M_filebuf)); } 
# 778
bool is_open() 
# 779
{ return ((_M_filebuf).is_open()); } 
# 784
bool is_open() const 
# 785
{ return ((_M_filebuf).is_open()); } 
# 799 "/usr/include/c++/5/fstream" 3
void open(const char *__s, ::std::ios_base::openmode 
# 800
__mode = (::std::ios_base::out | ::std::ios_base::trunc)) 
# 801
{ 
# 802
if (!((_M_filebuf).open(__s, (__mode | ::std::ios_base::out)))) { 
# 803
(this->setstate(ios_base::failbit)); } else { 
# 807
(this->clear()); }  
# 808
} 
# 820 "/usr/include/c++/5/fstream" 3
void open(const ::std::__cxx11::string &__s, ::std::ios_base::openmode 
# 821
__mode = (::std::ios_base::out | ::std::ios_base::trunc)) 
# 822
{ 
# 823
if (!((_M_filebuf).open(__s, (__mode | ::std::ios_base::out)))) { 
# 824
(this->setstate(ios_base::failbit)); } else { 
# 828
(this->clear()); }  
# 829
} 
# 839 "/usr/include/c++/5/fstream" 3
void close() 
# 840
{ 
# 841
if (!((_M_filebuf).close())) { 
# 842
(this->setstate(ios_base::failbit)); }  
# 843
} 
# 844
}; 
# 861 "/usr/include/c++/5/fstream" 3
template< class _CharT, class _Traits> 
# 862
class basic_fstream : public basic_iostream< _CharT, _Traits>  { 
# 866
public: typedef _CharT char_type; 
# 867
typedef _Traits traits_type; 
# 868
typedef typename _Traits::int_type int_type; 
# 869
typedef typename _Traits::pos_type pos_type; 
# 870
typedef typename _Traits::off_type off_type; 
# 873
typedef basic_filebuf< _CharT, _Traits>  __filebuf_type; 
# 874
typedef ::std::basic_ios< _CharT, _Traits>  __ios_type; 
# 875
typedef ::std::basic_iostream< _CharT, _Traits>  __iostream_type; 
# 878
private: __filebuf_type _M_filebuf; 
# 889 "/usr/include/c++/5/fstream" 3
public: basic_fstream() : __iostream_type(), _M_filebuf() 
# 891
{ (this->init(&(_M_filebuf))); } 
# 902 "/usr/include/c++/5/fstream" 3
explicit basic_fstream(const char *__s, ::std::ios_base::openmode 
# 903
__mode = (::std::ios_base::in | ::std::ios_base::out)) : __iostream_type(0), _M_filebuf() 
# 905
{ 
# 906
(this->init(&(_M_filebuf))); 
# 907
(this->open(__s, __mode)); 
# 908
} 
# 917
explicit basic_fstream(const ::std::__cxx11::string &__s, ::std::ios_base::openmode 
# 918
__mode = (::std::ios_base::in | ::std::ios_base::out)) : __iostream_type(0), _M_filebuf() 
# 920
{ 
# 921
(this->init(&(_M_filebuf))); 
# 922
(this->open(__s, __mode)); 
# 923
} 
# 925
basic_fstream(const basic_fstream &) = delete;
# 927
basic_fstream(basic_fstream &&__rhs) : __iostream_type(::std::move(__rhs)), _M_filebuf(::std::move((__rhs._M_filebuf))) 
# 930
{ __iostream_type::set_rdbuf(&(_M_filebuf)); } 
# 939 "/usr/include/c++/5/fstream" 3
~basic_fstream() 
# 940
{ } 
# 946
basic_fstream &operator=(const basic_fstream &) = delete;
# 949
basic_fstream &operator=(basic_fstream &&__rhs) 
# 950
{ 
# 951
::std::basic_iostream< _CharT, _Traits> ::operator=(::std::move(__rhs)); 
# 952
(_M_filebuf) = ::std::move((__rhs._M_filebuf)); 
# 953
return *this; 
# 954
} 
# 957
void swap(basic_fstream &__rhs) 
# 958
{ 
# 959
__iostream_type::swap(__rhs); 
# 960
((_M_filebuf).swap((__rhs._M_filebuf))); 
# 961
} 
# 972 "/usr/include/c++/5/fstream" 3
__filebuf_type *rdbuf() const 
# 973
{ return const_cast< __filebuf_type *>(&(_M_filebuf)); } 
# 980
bool is_open() 
# 981
{ return ((_M_filebuf).is_open()); } 
# 986
bool is_open() const 
# 987
{ return ((_M_filebuf).is_open()); } 
# 1001 "/usr/include/c++/5/fstream" 3
void open(const char *__s, ::std::ios_base::openmode 
# 1002
__mode = (::std::ios_base::in | ::std::ios_base::out)) 
# 1003
{ 
# 1004
if (!((_M_filebuf).open(__s, __mode))) { 
# 1005
(this->setstate(ios_base::failbit)); } else { 
# 1009
(this->clear()); }  
# 1010
} 
# 1022 "/usr/include/c++/5/fstream" 3
void open(const ::std::__cxx11::string &__s, ::std::ios_base::openmode 
# 1023
__mode = (::std::ios_base::in | ::std::ios_base::out)) 
# 1024
{ 
# 1025
if (!((_M_filebuf).open(__s, __mode))) { 
# 1026
(this->setstate(ios_base::failbit)); } else { 
# 1030
(this->clear()); }  
# 1031
} 
# 1041 "/usr/include/c++/5/fstream" 3
void close() 
# 1042
{ 
# 1043
if (!((_M_filebuf).close())) { 
# 1044
(this->setstate(ios_base::failbit)); }  
# 1045
} 
# 1046
}; 
# 1050
template< class _CharT, class _Traits> inline void 
# 1052
swap(basic_filebuf< _CharT, _Traits>  &__x, basic_filebuf< _CharT, _Traits>  &
# 1053
__y) 
# 1054
{ (__x.swap(__y)); } 
# 1057
template< class _CharT, class _Traits> inline void 
# 1059
swap(basic_ifstream< _CharT, _Traits>  &__x, basic_ifstream< _CharT, _Traits>  &
# 1060
__y) 
# 1061
{ (__x.swap(__y)); } 
# 1064
template< class _CharT, class _Traits> inline void 
# 1066
swap(basic_ofstream< _CharT, _Traits>  &__x, basic_ofstream< _CharT, _Traits>  &
# 1067
__y) 
# 1068
{ (__x.swap(__y)); } 
# 1071
template< class _CharT, class _Traits> inline void 
# 1073
swap(basic_fstream< _CharT, _Traits>  &__x, basic_fstream< _CharT, _Traits>  &
# 1074
__y) 
# 1075
{ (__x.swap(__y)); } 
# 1079
}
# 42 "/usr/include/c++/5/bits/fstream.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 46
template< class _CharT, class _Traits> void 
# 49
basic_filebuf< _CharT, _Traits> ::_M_allocate_internal_buffer() 
# 50
{ 
# 53
if ((!(_M_buf_allocated)) && (!(_M_buf))) 
# 54
{ 
# 55
(_M_buf) = (new char_type [_M_buf_size]); 
# 56
(_M_buf_allocated) = true; 
# 57
}  
# 58
} 
# 60
template< class _CharT, class _Traits> void 
# 63
basic_filebuf< _CharT, _Traits> ::_M_destroy_internal_buffer() throw() 
# 64
{ 
# 65
if (_M_buf_allocated) 
# 66
{ 
# 67
delete [] (_M_buf); 
# 68
(_M_buf) = 0; 
# 69
(_M_buf_allocated) = false; 
# 70
}  
# 71
delete [] (_M_ext_buf); 
# 72
(_M_ext_buf) = (0); 
# 73
(_M_ext_buf_size) = (0); 
# 74
(_M_ext_next) = (0); 
# 75
(_M_ext_end) = (0); 
# 76
} 
# 78
template< class _CharT, class _Traits> 
# 80
basic_filebuf< _CharT, _Traits> ::basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&(_M_lock)), _M_mode(((::std::ios_base::openmode)0)), _M_state_beg(), _M_state_cur(), _M_state_last(), _M_buf((0)), _M_buf_size((8192)), _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(), _M_pback_cur_save((0)), _M_pback_end_save((0)), _M_pback_init(false), _M_codecvt((0)), _M_ext_buf((0)), _M_ext_buf_size((0)), _M_ext_next((0)), _M_ext_end((0)) 
# 87
{ 
# 88
if (has_facet< __codecvt_type> ((this->_M_buf_locale))) { 
# 89
(_M_codecvt) = (&use_facet< __codecvt_type> ((this->_M_buf_locale))); }  
# 90
} 
# 93
template< class _CharT, class _Traits> 
# 95
basic_filebuf< _CharT, _Traits> ::basic_filebuf(basic_filebuf &&__rhs) : __streambuf_type(__rhs), _M_lock(), _M_file(::std::move((__rhs._M_file)), &(_M_lock)), _M_mode(::std::__exchange((__rhs._M_mode), (::std::ios_base::openmode)0)), _M_state_beg(::std::move((__rhs._M_state_beg))), _M_state_cur(::std::move((__rhs._M_state_cur))), _M_state_last(::std::move((__rhs._M_state_last))), _M_buf(::std::__exchange((__rhs._M_buf), nullptr)), _M_buf_size(::std::__exchange((__rhs._M_buf_size), 1)), _M_buf_allocated(::std::__exchange((__rhs._M_buf_allocated), false)), _M_reading(::std::__exchange((__rhs._M_reading), false)), _M_writing(::std::__exchange((__rhs._M_writing), false)), _M_pback((__rhs._M_pback)), _M_pback_cur_save(::std::__exchange((__rhs._M_pback_cur_save), nullptr)), _M_pback_end_save(::std::__exchange((__rhs._M_pback_end_save), nullptr)), _M_pback_init(::std::__exchange((__rhs._M_pback_init), false)), _M_codecvt(((__rhs._M_codecvt))), _M_ext_buf(::std::__exchange((__rhs._M_ext_buf), nullptr)), _M_ext_buf_size(::std::__exchange((__rhs._M_ext_buf_size), 0)), _M_ext_next(::std::__exchange((__rhs._M_ext_next), nullptr)), _M_ext_end(::std::__exchange((__rhs._M_ext_end), nullptr)) 
# 116
{ 
# 117
(__rhs._M_set_buffer(-1)); 
# 118
(__rhs._M_state_last) = ((__rhs._M_state_cur) = (__rhs._M_state_beg)); 
# 119
} 
# 121
template< class _CharT, class _Traits> basic_filebuf< _CharT, _Traits>  &
# 124
basic_filebuf< _CharT, _Traits> ::operator=(basic_filebuf &&__rhs) 
# 125
{ 
# 126
this->close(); 
# 127
::std::basic_streambuf< _CharT, _Traits> ::operator=(__rhs); 
# 128
(_M_file).swap((__rhs._M_file)); 
# 129
(_M_mode) = ::std::__exchange((__rhs._M_mode), (::std::ios_base::openmode)0); 
# 130
(_M_state_beg) = ::std::move((__rhs._M_state_beg)); 
# 131
(_M_state_cur) = ::std::move((__rhs._M_state_cur)); 
# 132
(_M_state_last) = ::std::move((__rhs._M_state_last)); 
# 133
(_M_buf) = ::std::__exchange((__rhs._M_buf), nullptr); 
# 134
(_M_buf_size) = ::std::__exchange((__rhs._M_buf_size), 1); 
# 135
(_M_buf_allocated) = ::std::__exchange((__rhs._M_buf_allocated), false); 
# 136
(_M_ext_buf) = ::std::__exchange((__rhs._M_ext_buf), nullptr); 
# 137
(_M_ext_buf_size) = ::std::__exchange((__rhs._M_ext_buf_size), 0); 
# 138
(_M_ext_next) = ::std::__exchange((__rhs._M_ext_next), nullptr); 
# 139
(_M_ext_end) = ::std::__exchange((__rhs._M_ext_end), nullptr); 
# 140
(_M_reading) = ::std::__exchange((__rhs._M_reading), false); 
# 141
(_M_writing) = ::std::__exchange((__rhs._M_writing), false); 
# 142
(_M_pback_cur_save) = ::std::__exchange((__rhs._M_pback_cur_save), nullptr); 
# 143
(_M_pback_end_save) = ::std::__exchange((__rhs._M_pback_end_save), nullptr); 
# 144
(_M_pback_init) = ::std::__exchange((__rhs._M_pback_init), false); 
# 145
(__rhs._M_set_buffer(-1)); 
# 146
(__rhs._M_state_last) = ((__rhs._M_state_cur) = (__rhs._M_state_beg)); 
# 147
return *this; 
# 148
} 
# 150
template< class _CharT, class _Traits> void 
# 153
basic_filebuf< _CharT, _Traits> ::swap(basic_filebuf &__rhs) 
# 154
{ 
# 155
__streambuf_type::swap(__rhs); 
# 156
(_M_file).swap((__rhs._M_file)); 
# 157
::std::swap(_M_mode, (__rhs._M_mode)); 
# 158
::std::swap(_M_state_beg, (__rhs._M_state_beg)); 
# 159
::std::swap(_M_state_cur, (__rhs._M_state_cur)); 
# 160
::std::swap(_M_state_last, (__rhs._M_state_last)); 
# 161
::std::swap(_M_buf, (__rhs._M_buf)); 
# 162
::std::swap(_M_buf_size, (__rhs._M_buf_size)); 
# 163
::std::swap(_M_buf_allocated, (__rhs._M_buf_allocated)); 
# 164
::std::swap(_M_ext_buf, (__rhs._M_ext_buf)); 
# 165
::std::swap(_M_ext_buf_size, (__rhs._M_ext_buf_size)); 
# 166
::std::swap(_M_ext_next, (__rhs._M_ext_next)); 
# 167
::std::swap(_M_ext_end, (__rhs._M_ext_end)); 
# 168
::std::swap(_M_reading, (__rhs._M_reading)); 
# 169
::std::swap(_M_writing, (__rhs._M_writing)); 
# 170
::std::swap(_M_pback_cur_save, (__rhs._M_pback_cur_save)); 
# 171
::std::swap(_M_pback_end_save, (__rhs._M_pback_end_save)); 
# 172
::std::swap(_M_pback_init, (__rhs._M_pback_init)); 
# 173
} 
# 176
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::__filebuf_type *
# 179
basic_filebuf< _CharT, _Traits> ::open(const char *__s, ::std::ios_base::openmode __mode) 
# 180
{ 
# 181
__filebuf_type *__ret = (0); 
# 182
if (!this->is_open()) 
# 183
{ 
# 184
(_M_file).open(__s, __mode); 
# 185
if (this->is_open()) 
# 186
{ 
# 187
_M_allocate_internal_buffer(); 
# 188
(_M_mode) = __mode; 
# 191
(_M_reading) = false; 
# 192
(_M_writing) = false; 
# 193
_M_set_buffer(-1); 
# 196
(_M_state_last) = ((_M_state_cur) = (_M_state_beg)); 
# 199
if (((__mode & ::std::ios_base::ate)) && (this->seekoff(0, ::std::ios_base::end, __mode) == ((pos_type)((off_type)(-1))))) { 
# 202
this->close(); } else { 
# 204
__ret = this; }  
# 205
}  
# 206
}  
# 207
return __ret; 
# 208
} 
# 210
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::__filebuf_type *
# 213
basic_filebuf< _CharT, _Traits> ::close() 
# 214
{ 
# 215
if (!this->is_open()) { 
# 216
return 0; }  
# 218
bool __testfail = false; 
# 219
{ 
# 221
struct __close_sentry { 
# 223
basic_filebuf *__fb; 
# 224
__close_sentry(basic_filebuf *__fbi) : __fb(__fbi) { } 
# 225
~__close_sentry() 
# 226
{ 
# 227
((__fb)->_M_mode) = ((::std::ios_base::openmode)0); 
# 228
((__fb)->_M_pback_init) = false; 
# 229
(__fb)->_M_destroy_internal_buffer(); 
# 230
((__fb)->_M_reading) = false; 
# 231
((__fb)->_M_writing) = false; 
# 232
(__fb)->_M_set_buffer(-1); 
# 233
((__fb)->_M_state_last) = (((__fb)->_M_state_cur) = ((__fb)->_M_state_beg)); 
# 234
} 
# 235
} __cs(this); 
# 237
try 
# 238
{ 
# 239
if (!_M_terminate_output()) { 
# 240
__testfail = true; }  
# 241
} 
# 242
catch (::__cxxabiv1::__forced_unwind &) 
# 243
{ 
# 244
(_M_file).close(); 
# 245
throw; 
# 246
} 
# 247
catch (...) 
# 248
{ __testfail = true; }  
# 249
} 
# 251
if (!((_M_file).close())) { 
# 252
__testfail = true; }  
# 254
if (__testfail) { 
# 255
return 0; } else { 
# 257
return this; }  
# 258
} 
# 260
template< class _CharT, class _Traits> streamsize 
# 263
basic_filebuf< _CharT, _Traits> ::showmanyc() 
# 264
{ 
# 265
::std::streamsize __ret = (-1); 
# 266
const bool __testin = ((_M_mode) & ::std::ios_base::in); 
# 267
if (__testin && this->is_open()) 
# 268
{ 
# 271
__ret = ((this->egptr()) - (this->gptr())); 
# 279
if ((__check_facet(_M_codecvt).encoding()) >= 0) { 
# 281
__ret += ((_M_file).showmanyc() / ((_M_codecvt)->max_length())); }  
# 282
}  
# 283
return __ret; 
# 284
} 
# 286
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::int_type 
# 289
basic_filebuf< _CharT, _Traits> ::underflow() 
# 290
{ 
# 291
int_type __ret = traits_type::eof(); 
# 292
const bool __testin = ((_M_mode) & ::std::ios_base::in); 
# 293
if (__testin) 
# 294
{ 
# 295
if (_M_writing) 
# 296
{ 
# 297
if (overflow() == traits_type::eof()) { 
# 298
return __ret; }  
# 299
_M_set_buffer(-1); 
# 300
(_M_writing) = false; 
# 301
}  
# 305
_M_destroy_pback(); 
# 307
if ((this->gptr()) < (this->egptr())) { 
# 308
return traits_type::to_int_type(*(this->gptr())); }  
# 311
const ::std::size_t __buflen = ((_M_buf_size) > (1)) ? (_M_buf_size) - (1) : (1); 
# 314
bool __got_eof = false; 
# 316
::std::streamsize __ilen = (0); 
# 317
::std::codecvt_base::result __r = codecvt_base::ok; 
# 318
if ((__check_facet(_M_codecvt).always_noconv())) 
# 319
{ 
# 320
__ilen = (_M_file).xsgetn(reinterpret_cast< char *>((this->eback())), __buflen); 
# 322
if (__ilen == (0)) { 
# 323
__got_eof = true; }  
# 324
} else 
# 326
{ 
# 329
const int __enc = ((_M_codecvt)->encoding()); 
# 330
::std::streamsize __blen; 
# 331
::std::streamsize __rlen; 
# 332
if (__enc > 0) { 
# 333
__blen = (__rlen = (__buflen * __enc)); } else 
# 335
{ 
# 336
__blen = ((__buflen + ((_M_codecvt)->max_length())) - 1); 
# 337
__rlen = __buflen; 
# 338
}  
# 339
const ::std::streamsize __remainder = (_M_ext_end) - (_M_ext_next); 
# 340
__rlen = ((__rlen > __remainder) ? __rlen - __remainder : (0)); 
# 344
if ((_M_reading) && ((this->egptr()) == (this->eback())) && __remainder) { 
# 345
__rlen = (0); }  
# 349
if ((_M_ext_buf_size) < __blen) 
# 350
{ 
# 351
char *__buf = new char [__blen]; 
# 352
if (__remainder) { 
# 353
__builtin_memcpy(__buf, _M_ext_next, __remainder); }  
# 355
delete [] (_M_ext_buf); 
# 356
(_M_ext_buf) = __buf; 
# 357
(_M_ext_buf_size) = __blen; 
# 358
} else { 
# 359
if (__remainder) { 
# 360
__builtin_memmove(_M_ext_buf, _M_ext_next, __remainder); }  }  
# 362
(_M_ext_next) = (_M_ext_buf); 
# 363
(_M_ext_end) = ((_M_ext_buf) + __remainder); 
# 364
(_M_state_last) = (_M_state_cur); 
# 366
do 
# 367
{ 
# 368
if (__rlen > (0)) 
# 369
{ 
# 373
if ((((_M_ext_end) - (_M_ext_buf)) + __rlen) > (_M_ext_buf_size)) 
# 374
{ 
# 375
__throw_ios_failure("basic_filebuf::underflow codecvt::max_length() is not valid"); 
# 378
}  
# 379
::std::streamsize __elen = (_M_file).xsgetn(_M_ext_end, __rlen); 
# 380
if (__elen == (0)) { 
# 381
__got_eof = true; } else { 
# 382
if (__elen == (-1)) { 
# 383
break; }  }  
# 384
(_M_ext_end) += __elen; 
# 385
}  
# 387
char_type *__iend = (this->eback()); 
# 388
if ((_M_ext_next) < (_M_ext_end)) { 
# 389
__r = ((_M_codecvt)->in(_M_state_cur, _M_ext_next, _M_ext_end, _M_ext_next, (this->eback()), (this->eback()) + __buflen, __iend)); }  
# 393
if (__r == (codecvt_base::noconv)) 
# 394
{ 
# 395
::std::size_t __avail = (_M_ext_end) - (_M_ext_buf); 
# 396
__ilen = (std::min(__avail, __buflen)); 
# 397
traits_type::copy((this->eback()), reinterpret_cast< char_type *>(_M_ext_buf), __ilen); 
# 400
(_M_ext_next) = ((_M_ext_buf) + __ilen); 
# 401
} else { 
# 403
__ilen = (__iend - (this->eback())); }  
# 408
if (__r == (codecvt_base::error)) { 
# 409
break; }  
# 411
__rlen = (1); 
# 412
} 
# 413
while ((__ilen == (0)) && (!__got_eof)); 
# 414
}  
# 416
if (__ilen > (0)) 
# 417
{ 
# 418
_M_set_buffer(__ilen); 
# 419
(_M_reading) = true; 
# 420
__ret = traits_type::to_int_type(*(this->gptr())); 
# 421
} else { 
# 422
if (__got_eof) 
# 423
{ 
# 427
_M_set_buffer(-1); 
# 428
(_M_reading) = false; 
# 431
if (__r == (codecvt_base::partial)) { 
# 432
__throw_ios_failure("basic_filebuf::underflow incomplete character in file"); }  
# 434
} else { 
# 435
if (__r == (codecvt_base::error)) { 
# 436
__throw_ios_failure("basic_filebuf::underflow invalid byte sequence in file"); } else { 
# 439
__throw_ios_failure("basic_filebuf::underflow error reading the file"); }  }  }  
# 441
}  
# 442
return __ret; 
# 443
} 
# 445
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::int_type 
# 448
basic_filebuf< _CharT, _Traits> ::pbackfail(int_type __i) 
# 449
{ 
# 450
int_type __ret = traits_type::eof(); 
# 451
const bool __testin = ((_M_mode) & ::std::ios_base::in); 
# 452
if (__testin) 
# 453
{ 
# 454
if (_M_writing) 
# 455
{ 
# 456
if (overflow() == traits_type::eof()) { 
# 457
return __ret; }  
# 458
_M_set_buffer(-1); 
# 459
(_M_writing) = false; 
# 460
}  
# 463
const bool __testpb = _M_pback_init; 
# 464
const bool __testeof = traits_type::eq_int_type(__i, __ret); 
# 465
int_type __tmp; 
# 466
if ((this->eback()) < (this->gptr())) 
# 467
{ 
# 468
(this->gbump(-1)); 
# 469
__tmp = traits_type::to_int_type(*(this->gptr())); 
# 470
} else { 
# 471
if (this->seekoff(-1, ::std::ios_base::cur) != ((pos_type)((off_type)(-1)))) 
# 472
{ 
# 473
__tmp = this->underflow(); 
# 474
if (traits_type::eq_int_type(__tmp, __ret)) { 
# 475
return __ret; }  
# 476
} else 
# 478
{ 
# 484
return __ret; 
# 485
}  }  
# 489
if ((!__testeof) && traits_type::eq_int_type(__i, __tmp)) { 
# 490
__ret = __i; } else { 
# 491
if (__testeof) { 
# 492
__ret = traits_type::not_eof(__i); } else { 
# 493
if (!__testpb) 
# 494
{ 
# 495
_M_create_pback(); 
# 496
(_M_reading) = true; 
# 497
(*(this->gptr())) = traits_type::to_char_type(__i); 
# 498
__ret = __i; 
# 499
}  }  }  
# 500
}  
# 501
return __ret; 
# 502
} 
# 504
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::int_type 
# 507
basic_filebuf< _CharT, _Traits> ::overflow(int_type __c) 
# 508
{ 
# 509
int_type __ret = traits_type::eof(); 
# 510
const bool __testeof = traits_type::eq_int_type(__c, __ret); 
# 511
const bool __testout = (((_M_mode) & ::std::ios_base::out)) || (((_M_mode) & ::std::ios_base::app)); 
# 513
if (__testout) 
# 514
{ 
# 515
if (_M_reading) 
# 516
{ 
# 517
_M_destroy_pback(); 
# 518
const int __gptr_off = _M_get_ext_pos(_M_state_last); 
# 519
if (_M_seek(__gptr_off, ios_base::cur, _M_state_last) == ((pos_type)((off_type)(-1)))) { 
# 521
return __ret; }  
# 522
}  
# 523
if ((this->pbase()) < (this->pptr())) 
# 524
{ 
# 526
if (!__testeof) 
# 527
{ 
# 528
(*(this->pptr())) = traits_type::to_char_type(__c); 
# 529
(this->pbump(1)); 
# 530
}  
# 534
if (_M_convert_to_external((this->pbase()), (this->pptr()) - (this->pbase()))) 
# 536
{ 
# 537
_M_set_buffer(0); 
# 538
__ret = traits_type::not_eof(__c); 
# 539
}  
# 540
} else { 
# 541
if ((_M_buf_size) > (1)) 
# 542
{ 
# 546
_M_set_buffer(0); 
# 547
(_M_writing) = true; 
# 548
if (!__testeof) 
# 549
{ 
# 550
(*(this->pptr())) = traits_type::to_char_type(__c); 
# 551
(this->pbump(1)); 
# 552
}  
# 553
__ret = traits_type::not_eof(__c); 
# 554
} else 
# 556
{ 
# 558
char_type __conv = traits_type::to_char_type(__c); 
# 559
if (__testeof || _M_convert_to_external(&__conv, 1)) 
# 560
{ 
# 561
(_M_writing) = true; 
# 562
__ret = traits_type::not_eof(__c); 
# 563
}  
# 564
}  }  
# 565
}  
# 566
return __ret; 
# 567
} 
# 569
template< class _CharT, class _Traits> bool 
# 572
basic_filebuf< _CharT, _Traits> ::_M_convert_to_external(_CharT *__ibuf, ::std::streamsize __ilen) 
# 573
{ 
# 575
::std::streamsize __elen; 
# 576
::std::streamsize __plen; 
# 577
if ((__check_facet(_M_codecvt).always_noconv())) 
# 578
{ 
# 579
__elen = (_M_file).xsputn(reinterpret_cast< char *>(__ibuf), __ilen); 
# 580
__plen = __ilen; 
# 581
} else 
# 583
{ 
# 586
::std::streamsize __blen = __ilen * ((_M_codecvt)->max_length()); 
# 587
char *__buf = static_cast< char *>(__builtin_alloca(__blen)); 
# 589
char *__bend; 
# 590
const char_type *__iend; 
# 591
::std::codecvt_base::result __r; 
# 592
__r = ((_M_codecvt)->out(_M_state_cur, __ibuf, __ibuf + __ilen, __iend, __buf, __buf + __blen, __bend)); 
# 595
if ((__r == (codecvt_base::ok)) || (__r == (codecvt_base::partial))) { 
# 596
__blen = (__bend - __buf); } else { 
# 597
if (__r == (codecvt_base::noconv)) 
# 598
{ 
# 600
__buf = (reinterpret_cast< char *>(__ibuf)); 
# 601
__blen = __ilen; 
# 602
} else { 
# 604
__throw_ios_failure("basic_filebuf::_M_convert_to_external conversion error"); }  }  
# 607
__elen = (_M_file).xsputn(__buf, __blen); 
# 608
__plen = __blen; 
# 611
if ((__r == (codecvt_base::partial)) && (__elen == __plen)) 
# 612
{ 
# 613
const char_type *__iresume = __iend; 
# 614
::std::streamsize __rlen = (this->pptr()) - __iend; 
# 615
__r = ((_M_codecvt)->out(_M_state_cur, __iresume, __iresume + __rlen, __iend, __buf, __buf + __blen, __bend)); 
# 618
if (__r != (codecvt_base::error)) 
# 619
{ 
# 620
__rlen = (__bend - __buf); 
# 621
__elen = (_M_file).xsputn(__buf, __rlen); 
# 622
__plen = __rlen; 
# 623
} else { 
# 625
__throw_ios_failure("basic_filebuf::_M_convert_to_external conversion error"); }  
# 627
}  
# 628
}  
# 629
return __elen == __plen; 
# 630
} 
# 632
template< class _CharT, class _Traits> streamsize 
# 635
basic_filebuf< _CharT, _Traits> ::xsgetn(_CharT *__s, ::std::streamsize __n) 
# 636
{ 
# 638
::std::streamsize __ret = (0); 
# 639
if (_M_pback_init) 
# 640
{ 
# 641
if ((__n > (0)) && ((this->gptr()) == (this->eback()))) 
# 642
{ 
# 643
(*(__s++)) = (*(this->gptr())); 
# 644
(this->gbump(1)); 
# 645
__ret = (1); 
# 646
--__n; 
# 647
}  
# 648
_M_destroy_pback(); 
# 649
} else { 
# 650
if (_M_writing) 
# 651
{ 
# 652
if (overflow() == traits_type::eof()) { 
# 653
return __ret; }  
# 654
_M_set_buffer(-1); 
# 655
(_M_writing) = false; 
# 656
}  }  
# 661
const bool __testin = ((_M_mode) & ::std::ios_base::in); 
# 662
const ::std::streamsize __buflen = ((_M_buf_size) > (1)) ? (_M_buf_size) - (1) : (1); 
# 664
if ((__n > __buflen) && (__check_facet(_M_codecvt).always_noconv()) && __testin) 
# 666
{ 
# 668
const ::std::streamsize __avail = (this->egptr()) - (this->gptr()); 
# 669
if (__avail != (0)) 
# 670
{ 
# 671
traits_type::copy(__s, (this->gptr()), __avail); 
# 672
__s += __avail; 
# 673
(this->setg((this->eback()), (this->gptr()) + __avail, (this->egptr()))); 
# 675
__ret += __avail; 
# 676
__n -= __avail; 
# 677
}  
# 681
::std::streamsize __len; 
# 682
for (; ;) 
# 683
{ 
# 684
__len = (_M_file).xsgetn(reinterpret_cast< char *>(__s), __n); 
# 686
if (__len == (-1)) { 
# 687
__throw_ios_failure("basic_filebuf::xsgetn error reading the file"); }  
# 689
if (__len == (0)) { 
# 690
break; }  
# 692
__n -= __len; 
# 693
__ret += __len; 
# 694
if (__n == (0)) { 
# 695
break; }  
# 697
__s += __len; 
# 698
}  
# 700
if (__n == (0)) 
# 701
{ 
# 702
_M_set_buffer(0); 
# 703
(_M_reading) = true; 
# 704
} else { 
# 705
if (__len == (0)) 
# 706
{ 
# 710
_M_set_buffer(-1); 
# 711
(_M_reading) = false; 
# 712
}  }  
# 713
} else { 
# 715
__ret += __streambuf_type::xsgetn(__s, __n); }  
# 717
return __ret; 
# 718
} 
# 720
template< class _CharT, class _Traits> streamsize 
# 723
basic_filebuf< _CharT, _Traits> ::xsputn(const _CharT *__s, ::std::streamsize __n) 
# 724
{ 
# 725
::std::streamsize __ret = (0); 
# 729
const bool __testout = (((_M_mode) & ::std::ios_base::out)) || (((_M_mode) & ::std::ios_base::app)); 
# 731
if ((__check_facet(_M_codecvt).always_noconv()) && __testout && (!(_M_reading))) 
# 733
{ 
# 735
const ::std::streamsize __chunk = (1UL << 10); 
# 736
::std::streamsize __bufavail = (this->epptr()) - (this->pptr()); 
# 739
if ((!(_M_writing)) && ((_M_buf_size) > (1))) { 
# 740
__bufavail = ((_M_buf_size) - (1)); }  
# 742
const ::std::streamsize __limit = std::min(__chunk, __bufavail); 
# 743
if (__n >= __limit) 
# 744
{ 
# 745
const ::std::streamsize __buffill = (this->pptr()) - (this->pbase()); 
# 746
const char *__buf = reinterpret_cast< const char *>((this->pbase())); 
# 747
__ret = (_M_file).xsputn_2(__buf, __buffill, reinterpret_cast< const char *>(__s), __n); 
# 750
if (__ret == (__buffill + __n)) 
# 751
{ 
# 752
_M_set_buffer(0); 
# 753
(_M_writing) = true; 
# 754
}  
# 755
if (__ret > __buffill) { 
# 756
__ret -= __buffill; } else { 
# 758
__ret = (0); }  
# 759
} else { 
# 761
__ret = __streambuf_type::xsputn(__s, __n); }  
# 762
} else { 
# 764
__ret = __streambuf_type::xsputn(__s, __n); }  
# 765
return __ret; 
# 766
} 
# 768
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::__streambuf_type *
# 771
basic_filebuf< _CharT, _Traits> ::setbuf(char_type *__s, ::std::streamsize __n) 
# 772
{ 
# 773
if (!this->is_open()) 
# 774
{ 
# 775
if ((__s == 0) && (__n == (0))) { 
# 776
(_M_buf_size) = (1); } else { 
# 777
if (__s && (__n > (0))) 
# 778
{ 
# 787 "/usr/include/c++/5/bits/fstream.tcc" 3
(_M_buf) = __s; 
# 788
(_M_buf_size) = __n; 
# 789
}  }  
# 790
}  
# 791
return this; 
# 792
} 
# 797
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::pos_type 
# 800
basic_filebuf< _CharT, _Traits> ::seekoff(off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode) 
# 801
{ 
# 802
int __width = 0; 
# 803
if (_M_codecvt) { 
# 804
__width = ((_M_codecvt)->encoding()); }  
# 805
if (__width < 0) { 
# 806
__width = 0; }  
# 808
pos_type __ret = ((pos_type)((off_type)(-1))); 
# 809
const bool __testfail = (__off != 0) && (__width <= 0); 
# 810
if (this->is_open() && (!__testfail)) 
# 811
{ 
# 816
bool __no_movement = (__way == ::std::ios_base::cur) && (__off == 0) && ((!(_M_writing)) || ((_M_codecvt)->always_noconv())); 
# 820
if (!__no_movement) { 
# 821
_M_destroy_pback(); }  
# 828
__state_type __state = _M_state_beg; 
# 829
off_type __computed_off = __off * __width; 
# 830
if ((_M_reading) && (__way == ::std::ios_base::cur)) 
# 831
{ 
# 832
__state = (_M_state_last); 
# 833
__computed_off += _M_get_ext_pos(__state); 
# 834
}  
# 835
if (!__no_movement) { 
# 836
__ret = _M_seek(__computed_off, __way, __state); } else 
# 838
{ 
# 839
if (_M_writing) { 
# 840
__computed_off = ((this->pptr()) - (this->pbase())); }  
# 842
off_type __file_off = (_M_file).seekoff(0, ::std::ios_base::cur); 
# 843
if (__file_off != ((off_type)(-1))) 
# 844
{ 
# 845
__ret = (__file_off + __computed_off); 
# 846
(__ret.state(__state)); 
# 847
}  
# 848
}  
# 849
}  
# 850
return __ret; 
# 851
} 
# 857
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::pos_type 
# 860
basic_filebuf< _CharT, _Traits> ::seekpos(pos_type __pos, ::std::ios_base::openmode) 
# 861
{ 
# 862
pos_type __ret = ((pos_type)((off_type)(-1))); 
# 863
if (this->is_open()) 
# 864
{ 
# 866
_M_destroy_pback(); 
# 867
__ret = _M_seek((off_type)__pos, ios_base::beg, (__pos.state())); 
# 868
}  
# 869
return __ret; 
# 870
} 
# 872
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::pos_type 
# 875
basic_filebuf< _CharT, _Traits> ::_M_seek(off_type __off, ::std::ios_base::seekdir __way, __state_type __state) 
# 876
{ 
# 877
pos_type __ret = ((pos_type)((off_type)(-1))); 
# 878
if (_M_terminate_output()) 
# 879
{ 
# 880
off_type __file_off = (_M_file).seekoff(__off, __way); 
# 881
if (__file_off != ((off_type)(-1))) 
# 882
{ 
# 883
(_M_reading) = false; 
# 884
(_M_writing) = false; 
# 885
(_M_ext_next) = ((_M_ext_end) = (_M_ext_buf)); 
# 886
_M_set_buffer(-1); 
# 887
(_M_state_cur) = __state; 
# 888
__ret = __file_off; 
# 889
(__ret.state(_M_state_cur)); 
# 890
}  
# 891
}  
# 892
return __ret; 
# 893
} 
# 898
template< class _CharT, class _Traits> int 
# 900
basic_filebuf< _CharT, _Traits> ::_M_get_ext_pos(__state_type &__state) 
# 901
{ 
# 902
if (((_M_codecvt)->always_noconv())) { 
# 903
return (this->gptr()) - (this->egptr()); } else 
# 905
{ 
# 909
const int __gptr_off = ((_M_codecvt)->length(__state, _M_ext_buf, _M_ext_next, (this->gptr()) - (this->eback()))); 
# 912
return ((_M_ext_buf) + __gptr_off) - (_M_ext_end); 
# 913
}  
# 914
} 
# 916
template< class _CharT, class _Traits> bool 
# 919
basic_filebuf< _CharT, _Traits> ::_M_terminate_output() 
# 920
{ 
# 922
bool __testvalid = true; 
# 923
if ((this->pbase()) < (this->pptr())) 
# 924
{ 
# 925
const int_type __tmp = this->overflow(); 
# 926
if (traits_type::eq_int_type(__tmp, traits_type::eof())) { 
# 927
__testvalid = false; }  
# 928
}  
# 931
if ((_M_writing) && (!(__check_facet(_M_codecvt).always_noconv())) && __testvalid) 
# 933
{ 
# 937
const ::std::size_t __blen = (128); 
# 938
char __buf[__blen]; 
# 939
::std::codecvt_base::result __r; 
# 940
::std::streamsize __ilen = (0); 
# 942
do 
# 943
{ 
# 944
char *__next; 
# 945
__r = ((_M_codecvt)->unshift(_M_state_cur, __buf, (__buf) + __blen, __next)); 
# 947
if (__r == (codecvt_base::error)) { 
# 948
__testvalid = false; } else { 
# 949
if ((__r == (codecvt_base::ok)) || (__r == (codecvt_base::partial))) 
# 951
{ 
# 952
__ilen = (__next - (__buf)); 
# 953
if (__ilen > (0)) 
# 954
{ 
# 955
const ::std::streamsize __elen = (_M_file).xsputn(__buf, __ilen); 
# 956
if (__elen != __ilen) { 
# 957
__testvalid = false; }  
# 958
}  
# 959
}  }  
# 960
} 
# 961
while ((__r == (codecvt_base::partial)) && (__ilen > (0)) && __testvalid); 
# 963
if (__testvalid) 
# 964
{ 
# 969
const int_type __tmp = this->overflow(); 
# 970
if (traits_type::eq_int_type(__tmp, traits_type::eof())) { 
# 971
__testvalid = false; }  
# 972
}  
# 973
}  
# 974
return __testvalid; 
# 975
} 
# 977
template< class _CharT, class _Traits> int 
# 980
basic_filebuf< _CharT, _Traits> ::sync() 
# 981
{ 
# 984
int __ret = 0; 
# 985
if ((this->pbase()) < (this->pptr())) 
# 986
{ 
# 987
const int_type __tmp = this->overflow(); 
# 988
if (traits_type::eq_int_type(__tmp, traits_type::eof())) { 
# 989
__ret = (-1); }  
# 990
}  
# 991
return __ret; 
# 992
} 
# 994
template< class _CharT, class _Traits> void 
# 997
basic_filebuf< _CharT, _Traits> ::imbue(const ::std::locale &__loc) 
# 998
{ 
# 999
bool __testvalid = true; 
# 1001
const __codecvt_type *_M_codecvt_tmp = (0); 
# 1002
if (__builtin_expect(has_facet< __codecvt_type> (__loc), true)) { 
# 1003
_M_codecvt_tmp = (&use_facet< __codecvt_type> (__loc)); }  
# 1005
if (this->is_open()) 
# 1006
{ 
# 1008
if (((_M_reading) || (_M_writing)) && ((__check_facet(_M_codecvt).encoding()) == (-1))) { 
# 1010
__testvalid = false; } else 
# 1012
{ 
# 1013
if (_M_reading) 
# 1014
{ 
# 1015
if ((__check_facet(_M_codecvt).always_noconv())) 
# 1016
{ 
# 1017
if (_M_codecvt_tmp && (!(__check_facet(_M_codecvt_tmp).always_noconv()))) { 
# 1019
__testvalid = (this->seekoff(0, ::std::ios_base::cur, _M_mode) != ((pos_type)((off_type)(-1)))); }  
# 1021
} else 
# 1023
{ 
# 1025
(_M_ext_next) = ((_M_ext_buf) + ((_M_codecvt)->length(_M_state_last, _M_ext_buf, _M_ext_next, (this->gptr()) - (this->eback())))); 
# 1029
const ::std::streamsize __remainder = (_M_ext_end) - (_M_ext_next); 
# 1030
if (__remainder) { 
# 1031
__builtin_memmove(_M_ext_buf, _M_ext_next, __remainder); }  
# 1033
(_M_ext_next) = (_M_ext_buf); 
# 1034
(_M_ext_end) = ((_M_ext_buf) + __remainder); 
# 1035
_M_set_buffer(-1); 
# 1036
(_M_state_last) = ((_M_state_cur) = (_M_state_beg)); 
# 1037
}  
# 1038
} else { 
# 1039
if ((_M_writing) && (__testvalid = _M_terminate_output())) { 
# 1040
_M_set_buffer(-1); }  }  
# 1041
}  
# 1042
}  
# 1044
if (__testvalid) { 
# 1045
(_M_codecvt) = _M_codecvt_tmp; } else { 
# 1047
(_M_codecvt) = 0; }  
# 1048
} 
# 1053
extern template class basic_filebuf< char, char_traits< char> > ;
# 1054
extern template class basic_ifstream< char, char_traits< char> > ;
# 1055
extern template class basic_ofstream< char, char_traits< char> > ;
# 1056
extern template class basic_fstream< char, char_traits< char> > ;
# 1059
extern template class basic_filebuf< wchar_t, char_traits< wchar_t> > ;
# 1060
extern template class basic_ifstream< wchar_t, char_traits< wchar_t> > ;
# 1061
extern template class basic_ofstream< wchar_t, char_traits< wchar_t> > ;
# 1062
extern template class basic_fstream< wchar_t, char_traits< wchar_t> > ;
# 1067
}
# 53 "/usr/include/opencv2/videostab/optical_flow.hpp" 3
namespace cv { 
# 55
namespace videostab { 
# 61
class __attribute((visibility("default"))) ISparseOptFlowEstimator { 
# 64
public: virtual ~ISparseOptFlowEstimator() { } 
# 65
virtual void run(InputArray frame0, InputArray frame1, InputArray points0, InputOutputArray points1, OutputArray status, OutputArray errors) = 0; 
# 68
}; 
# 70
class __attribute((visibility("default"))) IDenseOptFlowEstimator { 
# 73
public: virtual ~IDenseOptFlowEstimator() { } 
# 74
virtual void run(InputArray frame0, InputArray frame1, InputOutputArray flowX, InputOutputArray flowY, OutputArray errors) = 0; 
# 77
}; 
# 79
class __attribute((visibility("default"))) PyrLkOptFlowEstimatorBase { 
# 82
public: PyrLkOptFlowEstimatorBase() { this->setWinSize(Size(21, 21)); this->setMaxLevel(3); } 
# 84
virtual void setWinSize(Size val) { ((winSize_) = val); } 
# 85
virtual Size winSize() const { return winSize_; } 
# 87
virtual void setMaxLevel(int val) { (maxLevel_) = val; } 
# 88
virtual int maxLevel() const { return maxLevel_; } 
# 89
virtual ~PyrLkOptFlowEstimatorBase() { } 
# 92
protected: Size winSize_; 
# 93
int maxLevel_; 
# 94
}; 
# 96
class __attribute((visibility("default"))) SparsePyrLkOptFlowEstimator : public PyrLkOptFlowEstimatorBase, public ISparseOptFlowEstimator { 
# 100
public: virtual void run(InputArray frame0, InputArray frame1, InputArray points0, InputOutputArray points1, OutputArray status, OutputArray errors); 
# 103
}; 
# 147 "/usr/include/opencv2/videostab/optical_flow.hpp" 3
}
# 148
}
# 49 "/usr/include/opencv2/videostab/motion_core.hpp" 3
namespace cv { 
# 51
namespace videostab { 
# 59
enum MotionModel { 
# 61
MM_TRANSLATION, 
# 62
MM_TRANSLATION_AND_SCALE, 
# 63
MM_ROTATION, 
# 64
MM_RIGID, 
# 65
MM_SIMILARITY, 
# 66
MM_AFFINE, 
# 67
MM_HOMOGRAPHY, 
# 68
MM_UNKNOWN
# 69
}; 
# 73
struct __attribute((visibility("default"))) RansacParams { 
# 75
int size; 
# 76
float thresh; 
# 77
float eps; 
# 78
float prob; 
# 80
RansacParams() : size(0), thresh((0)), eps((0)), prob((0)) { } 
# 87
inline RansacParams(int size, float thresh, float eps, float prob); 
# 92
int niters() const 
# 93
{ 
# 94
return static_cast< int>(std::ceil((std::log((1) - (prob))) / std::log((1) - std::pow((1) - (eps), size)))); 
# 96
} 
# 102
static RansacParams default2dMotion(MotionModel model) 
# 103
{ 
# 104
if (!(!(model < (MM_UNKNOWN)))) { ; } else { cv::error(cv::Error::StsAssert, "model < MM_UNKNOWN", __func__, "/usr/include/opencv2/videostab/motion_core.hpp", 104); }  
# 105
if (model == (MM_TRANSLATION)) { 
# 106
return RansacParams(1, (0.5F), (0.5F), (0.9900000095F)); }  
# 107
if (model == (MM_TRANSLATION_AND_SCALE)) { 
# 108
return RansacParams(2, (0.5F), (0.5F), (0.9900000095F)); }  
# 109
if (model == (MM_ROTATION)) { 
# 110
return RansacParams(1, (0.5F), (0.5F), (0.9900000095F)); }  
# 111
if (model == (MM_RIGID)) { 
# 112
return RansacParams(2, (0.5F), (0.5F), (0.9900000095F)); }  
# 113
if (model == (MM_SIMILARITY)) { 
# 114
return RansacParams(2, (0.5F), (0.5F), (0.9900000095F)); }  
# 115
if (model == (MM_AFFINE)) { 
# 116
return RansacParams(3, (0.5F), (0.5F), (0.9900000095F)); }  
# 117
return RansacParams(4, (0.5F), (0.5F), (0.9900000095F)); 
# 118
} 
# 119
}; 
# 121
inline RansacParams::RansacParams(int _size, float _thresh, float _eps, float _prob) : size(_size), thresh(_thresh), eps(_eps), prob(_prob) 
# 122
{ } 
# 126
}
# 127
}
# 50 "/usr/include/opencv2/videostab/outlier_rejection.hpp" 3
namespace cv { 
# 52
namespace videostab { 
# 58
class __attribute((visibility("default"))) IOutlierRejector { 
# 61
public: virtual ~IOutlierRejector() { } 
# 63
virtual void process(Size frameSize, InputArray points0, InputArray points1, OutputArray mask) = 0; 
# 65
}; 
# 67
class __attribute((visibility("default"))) NullOutlierRejector : public IOutlierRejector { 
# 70
public: virtual void process(Size frameSize, InputArray points0, InputArray points1, OutputArray mask); 
# 72
}; 
# 74
class __attribute((visibility("default"))) TranslationBasedLocalOutlierRejector : public IOutlierRejector { 
# 77
public: TranslationBasedLocalOutlierRejector(); 
# 79
void setCellSize(Size val) { ((cellSize_) = val); } 
# 80
Size cellSize() const { return cellSize_; } 
# 82
void setRansacParams(RansacParams val) { (ransacParams_) = val; } 
# 83
RansacParams ransacParams() const { return ransacParams_; } 
# 85
virtual void process(Size frameSize, InputArray points0, InputArray points1, OutputArray mask); 
# 89
private: Size cellSize_; 
# 90
RansacParams ransacParams_; 
# 92
typedef std::vector< int>  Cell; 
# 93
std::vector< std::vector< int> >  grid_; 
# 94
}; 
# 98
}
# 99
}
# 59 "/usr/include/opencv2/videostab/global_motion.hpp" 3
namespace cv { 
# 61
namespace videostab { 
# 77 "/usr/include/opencv2/videostab/global_motion.hpp" 3
__attribute((visibility("default"))) Mat estimateGlobalMotionLeastSquares(InputOutputArray points0, InputOutputArray points1, int model = MM_AFFINE, float * rmse = 0); 
# 90 "/usr/include/opencv2/videostab/global_motion.hpp" 3
__attribute((visibility("default"))) Mat estimateGlobalMotionRansac(InputArray points0, InputArray points1, int model = MM_AFFINE, const RansacParams & params = RansacParams::default2dMotion(MM_AFFINE), float * rmse = 0, int * ninliers = 0); 
# 97
class __attribute((visibility("default"))) MotionEstimatorBase { 
# 100
public: virtual ~MotionEstimatorBase() { } 
# 106
virtual void setMotionModel(MotionModel val) { (motionModel_) = val; } 
# 111
virtual MotionModel motionModel() const { return motionModel_; } 
# 120 "/usr/include/opencv2/videostab/global_motion.hpp" 3
virtual Mat estimate(InputArray points0, InputArray points1, bool * ok = 0) = 0; 
# 123
protected: MotionEstimatorBase(MotionModel model) { this->setMotionModel(model); } 
# 126
private: MotionModel motionModel_; 
# 127
}; 
# 131
class __attribute((visibility("default"))) MotionEstimatorRansacL2 : public MotionEstimatorBase { 
# 134
public: MotionEstimatorRansacL2(MotionModel model = MM_AFFINE); 
# 136
void setRansacParams(const RansacParams &val) { (ransacParams_) = val; } 
# 137
RansacParams ransacParams() const { return ransacParams_; } 
# 139
void setMinInlierRatio(float val) { (minInlierRatio_) = val; } 
# 140
float minInlierRatio() const { return minInlierRatio_; } 
# 142
virtual Mat estimate(InputArray points0, InputArray points1, bool * ok = 0); 
# 145
private: RansacParams ransacParams_; 
# 146
float minInlierRatio_; 
# 147
}; 
# 153
class __attribute((visibility("default"))) MotionEstimatorL1 : public MotionEstimatorBase { 
# 156
public: MotionEstimatorL1(MotionModel model = MM_AFFINE); 
# 158
virtual Mat estimate(InputArray points0, InputArray points1, bool * ok = 0); 
# 161
private: std::vector< double>  obj_, collb_, colub_; 
# 162
std::vector< double>  elems_, rowlb_, rowub_; 
# 163
std::vector< int>  rows_, cols_; 
# 165
void set(int row, int col, double coef) 
# 166
{ 
# 167
(rows_).push_back(row); 
# 168
(cols_).push_back(col); 
# 169
(elems_).push_back(coef); 
# 170
} 
# 171
}; 
# 175
class __attribute((visibility("default"))) ImageMotionEstimatorBase { 
# 178
public: virtual ~ImageMotionEstimatorBase() { } 
# 180
virtual void setMotionModel(MotionModel val) { (motionModel_) = val; } 
# 181
virtual MotionModel motionModel() const { return motionModel_; } 
# 183
virtual Mat estimate(const Mat & frame0, const Mat & frame1, bool * ok = 0) = 0; 
# 186
protected: ImageMotionEstimatorBase(MotionModel model) { this->setMotionModel(model); } 
# 189
private: MotionModel motionModel_; 
# 190
}; 
# 192
class __attribute((visibility("default"))) FromFileMotionReader : public ImageMotionEstimatorBase { 
# 195
public: FromFileMotionReader(const String & path); 
# 197
virtual Mat estimate(const Mat & frame0, const Mat & frame1, bool * ok = 0); 
# 200
private: std::ifstream file_; 
# 201
}; 
# 203
class __attribute((visibility("default"))) ToFileMotionWriter : public ImageMotionEstimatorBase { 
# 206
public: ToFileMotionWriter(const String & path, Ptr< ImageMotionEstimatorBase>  estimator); 
# 208
virtual void setMotionModel(MotionModel val) { (motionEstimator_)->setMotionModel(val); } 
# 209
virtual MotionModel motionModel() const { return (motionEstimator_)->motionModel(); } 
# 211
virtual Mat estimate(const Mat & frame0, const Mat & frame1, bool * ok = 0); 
# 214
private: std::ofstream file_; 
# 215
Ptr< ImageMotionEstimatorBase>  motionEstimator_; 
# 216
}; 
# 221
class __attribute((visibility("default"))) KeypointBasedMotionEstimator : public ImageMotionEstimatorBase { 
# 224
public: KeypointBasedMotionEstimator(Ptr< MotionEstimatorBase>  estimator); 
# 226
virtual void setMotionModel(MotionModel val) { (motionEstimator_)->setMotionModel(val); } 
# 227
virtual MotionModel motionModel() const { return (motionEstimator_)->motionModel(); } 
# 229
void setDetector(Ptr< Feature2D>  val) { ((detector_) = val); } 
# 230
Ptr< Feature2D>  detector() const { return detector_; } 
# 232
void setOpticalFlowEstimator(Ptr< ISparseOptFlowEstimator>  val) { ((optFlowEstimator_) = val); } 
# 233
Ptr< ISparseOptFlowEstimator>  opticalFlowEstimator() const { return optFlowEstimator_; } 
# 235
void setOutlierRejector(Ptr< IOutlierRejector>  val) { ((outlierRejector_) = val); } 
# 236
Ptr< IOutlierRejector>  outlierRejector() const { return outlierRejector_; } 
# 238
virtual Mat estimate(const Mat & frame0, const Mat & frame1, bool * ok = 0); 
# 239
Mat estimate(InputArray frame0, InputArray frame1, bool * ok = 0); 
# 242
private: Ptr< MotionEstimatorBase>  motionEstimator_; 
# 243
Ptr< Feature2D>  detector_; 
# 244
Ptr< ISparseOptFlowEstimator>  optFlowEstimator_; 
# 245
Ptr< IOutlierRejector>  outlierRejector_; 
# 247
std::vector< unsigned char>  status_; 
# 248
std::vector< KeyPoint>  keypointsPrev_; 
# 249
std::vector< Point_< float> >  pointsPrev_, points_; 
# 250
std::vector< Point_< float> >  pointsPrevGood_, pointsGood_; 
# 251
}; 
# 293 "/usr/include/opencv2/videostab/global_motion.hpp" 3
__attribute((visibility("default"))) Mat getMotion(int from, int to, const std::vector< Mat>  & motions); 
# 297
}
# 298
}
# 51 "/usr/include/opencv2/videostab/motion_stabilizing.hpp" 3
namespace cv { 
# 53
namespace videostab { 
# 59
class __attribute((visibility("default"))) IMotionStabilizer { 
# 62
public: virtual ~IMotionStabilizer() { } 
# 65
virtual void stabilize(int size, const std::vector< Mat>  & motions, std::pair< int, int>  range, Mat * stabilizationMotions) = 0; 
# 68
}; 
# 70
class __attribute((visibility("default"))) MotionStabilizationPipeline : public IMotionStabilizer { 
# 73
public: void pushBack(Ptr< IMotionStabilizer>  stabilizer) { (stabilizers_).push_back(stabilizer); } 
# 74
bool empty() const { return (stabilizers_).empty(); } 
# 76
virtual void stabilize(int size, const std::vector< Mat>  & motions, std::pair< int, int>  range, Mat * stabilizationMotions); 
# 81
private: std::vector< Ptr< IMotionStabilizer> >  stabilizers_; 
# 82
}; 
# 84
class __attribute((visibility("default"))) MotionFilterBase : public IMotionStabilizer { 
# 87
public: virtual ~MotionFilterBase() { } 
# 89
virtual Mat stabilize(int idx, const std::vector< Mat>  & motions, std::pair< int, int>  range) = 0; 
# 92
virtual void stabilize(int size, const std::vector< Mat>  & motions, std::pair< int, int>  range, Mat * stabilizationMotions); 
# 95
}; 
# 97
class __attribute((visibility("default"))) GaussianMotionFilter : public MotionFilterBase { 
# 100
public: inline GaussianMotionFilter(int radius = 15, float stdev = -(1.0F)); 
# 102
void setParams(int radius, float stdev = -(1.0F)); 
# 103
int radius() const { return radius_; } 
# 104
float stdev() const { return stdev_; } 
# 106
virtual Mat stabilize(int idx, const std::vector< Mat>  & motions, std::pair< int, int>  range); 
# 110
private: int radius_; 
# 111
float stdev_; 
# 112
std::vector< float>  weight_; 
# 113
}; 
# 115
inline GaussianMotionFilter::GaussianMotionFilter(int _radius, float _stdev) { this->setParams(_radius, _stdev); } 
# 117
class __attribute((visibility("default"))) LpMotionStabilizer : public IMotionStabilizer { 
# 120
public: LpMotionStabilizer(MotionModel model = MM_SIMILARITY); 
# 122
void setMotionModel(MotionModel val) { (model_) = val; } 
# 123
MotionModel motionModel() const { return model_; } 
# 125
void setFrameSize(Size val) { ((frameSize_) = val); } 
# 126
Size frameSize() const { return frameSize_; } 
# 128
void setTrimRatio(float val) { (trimRatio_) = val; } 
# 129
float trimRatio() const { return trimRatio_; } 
# 131
void setWeight1(float val) { (w1_) = val; } 
# 132
float weight1() const { return w1_; } 
# 134
void setWeight2(float val) { (w2_) = val; } 
# 135
float weight2() const { return w2_; } 
# 137
void setWeight3(float val) { (w3_) = val; } 
# 138
float weight3() const { return w3_; } 
# 140
void setWeight4(float val) { (w4_) = val; } 
# 141
float weight4() const { return w4_; } 
# 143
virtual void stabilize(int size, const std::vector< Mat>  & motions, std::pair< int, int>  range, Mat * stabilizationMotions); 
# 148
private: MotionModel model_; 
# 149
Size frameSize_; 
# 150
float trimRatio_; 
# 151
float w1_, w2_, w3_, w4_; 
# 153
std::vector< double>  obj_, collb_, colub_; 
# 154
std::vector< int>  rows_, cols_; 
# 155
std::vector< double>  elems_, rowlb_, rowub_; 
# 157
void set(int row, int col, double coef) 
# 158
{ 
# 159
(rows_).push_back(row); 
# 160
(cols_).push_back(col); 
# 161
(elems_).push_back(coef); 
# 162
} 
# 163
}; 
# 165
__attribute((visibility("default"))) Mat ensureInclusionConstraint(const Mat & M, Size size, float trimRatio); 
# 167
__attribute((visibility("default"))) float estimateOptimalTrimRatio(const Mat & M, Size size); 
# 171
}
# 172
}
# 49 "/usr/include/opencv2/videostab/frame_source.hpp" 3
namespace cv { 
# 51
namespace videostab { 
# 57
class __attribute((visibility("default"))) IFrameSource { 
# 60
public: virtual ~IFrameSource() { } 
# 61
virtual void reset() = 0; 
# 62
virtual Mat nextFrame() = 0; 
# 63
}; 
# 65
class __attribute((visibility("default"))) NullFrameSource : public IFrameSource { 
# 68
public: virtual void reset() { } 
# 69
virtual Mat nextFrame() { return Mat(); } 
# 70
}; 
# 72
class __attribute((visibility("default"))) VideoFileSource : public IFrameSource { 
# 75
public: VideoFileSource(const String & path, bool volatileFrame = false); 
# 77
virtual void reset(); 
# 78
virtual Mat nextFrame(); 
# 80
int width(); 
# 81
int height(); 
# 82
int count(); 
# 83
double fps(); 
# 86
private: Ptr< IFrameSource>  impl; 
# 87
}; 
# 91
}
# 92
}
# 48 "/usr/include/opencv2/videostab/log.hpp" 3
namespace cv { 
# 50
namespace videostab { 
# 56
class __attribute((visibility("default"))) ILog { 
# 59
public: virtual ~ILog() { } 
# 60
virtual void print(const char * format, ...) = 0; 
# 61
}; 
# 63
class __attribute((visibility("default"))) NullLog : public ILog { 
# 66
public: virtual void print(const char *, ...) { } 
# 67
}; 
# 69
class __attribute((visibility("default"))) LogToStdout : public ILog { 
# 72
public: virtual void print(const char * format, ...); 
# 73
}; 
# 77
}
# 78
}
# 51 "/usr/include/opencv2/videostab/fast_marching.hpp" 3
namespace cv { 
# 53
namespace videostab { 
# 63 "/usr/include/opencv2/videostab/fast_marching.hpp" 3
class __attribute((visibility("default"))) FastMarchingMethod { 
# 66
public: FastMarchingMethod() : inf_((1000000.0F)), size_(0) { } 
# 75 "/usr/include/opencv2/videostab/fast_marching.hpp" 3
template< class Inpaint> Inpaint run(const Mat & mask, Inpaint inpaint); 
# 81
Mat distanceMap() const { return dist_; } 
# 84
private: enum { INSIDE, BAND, KNOWN = 255}; 
# 86
struct DXY { 
# 88
float dist; 
# 89
int x, y; 
# 91
DXY() : dist((0)), x(0), y(0) { } 
# 92
DXY(float _dist, int _x, int _y) : dist(_dist), x(_x), y(_y) { } 
# 93
bool operator<(const DXY &dxy) const { return (dist) < (dxy.dist); } 
# 94
}; 
# 96
float solve(int x1, int y1, int x2, int y2) const; 
# 97
int &indexOf(const DXY &dxy) { return (index_)(dxy.y, dxy.x); } 
# 99
void heapUp(int idx); 
# 100
void heapDown(int idx); 
# 101
void heapAdd(const DXY & dxy); 
# 102
void heapRemoveMin(); 
# 104
float inf_; 
# 106
Mat_< unsigned char>  flag_; 
# 107
Mat_< float>  dist_; 
# 109
Mat_< int>  index_; 
# 110
std::vector< DXY>  narrowBand_; 
# 111
int size_; 
# 112
}; 
# 116
}
# 117
}
# 48 "/usr/include/opencv2/videostab/fast_marching_inl.hpp" 3
namespace cv { 
# 50
namespace videostab { 
# 53
template< class Inpaint> Inpaint 
# 54
FastMarchingMethod::run(const Mat &mask, Inpaint inpaint) 
# 55
{ 
# 56
using namespace cv;
# 58
if (!(!(mask.type() == 0))) { ; } else { cv::error(cv::Error::StsAssert, "mask.type() == 0", __func__, "/usr/include/opencv2/videostab/fast_marching_inl.hpp", 58); }  
# 60
static const int lut[4][2] = {{(-1), 0}, {0, (-1)}, {1, 0}, {0, 1}}; 
# 62
mask.copyTo(flag_); 
# 63
(flag_).create((mask.size)()); 
# 64
(dist_).create((mask.size)()); 
# 65
(index_).create((mask.size)()); 
# 66
(narrowBand_).clear(); 
# 67
(size_) = 0; 
# 70
for (int y = 0; y < ((flag_).rows); ++y) 
# 71
{ 
# 72
for (int x = 0; x < ((flag_).cols); ++x) 
# 73
{ 
# 74
if (((flag_)(y, x)) == (KNOWN)) { 
# 75
(dist_)(y, x) = (0.0F); } else 
# 77
{ 
# 78
int n = 0; 
# 79
int nunknown = 0; 
# 81
for (int i = 0; i < 4; ++i) 
# 82
{ 
# 83
int xn = x + (((lut)[i])[0]); 
# 84
int yn = y + (((lut)[i])[1]); 
# 86
if ((xn >= 0) && (xn < ((flag_).cols)) && (yn >= 0) && (yn < ((flag_).rows))) 
# 87
{ 
# 88
n++; 
# 89
if (((flag_)(yn, xn)) != (KNOWN)) { 
# 90
nunknown++; }  
# 91
}  
# 92
}  
# 94
if ((n > 0) && (nunknown == n)) 
# 95
{ 
# 96
(dist_)(y, x) = (inf_); 
# 97
(flag_)(y, x) = (INSIDE); 
# 98
} else 
# 100
{ 
# 101
(dist_)(y, x) = (0.0F); 
# 102
(flag_)(y, x) = (BAND); 
# 103
inpaint(x, y); 
# 105
(narrowBand_).push_back(DXY((0.0F), x, y)); 
# 106
(index_)(y, x) = ((size_)++); 
# 107
}  
# 108
}  
# 109
}  
# 110
}  
# 113
for (int i = ((size_) / 2) - 1; i >= 0; --i) { 
# 114
this->heapDown(i); }  
# 117
while ((size_) > 0) 
# 118
{ 
# 119
int x = (narrowBand_)[0].x; 
# 120
int y = (narrowBand_)[0].y; 
# 121
this->heapRemoveMin(); 
# 123
(flag_)(y, x) = (KNOWN); 
# 124
for (int n = 0; n < 4; ++n) 
# 125
{ 
# 126
int xn = x + (((lut)[n])[0]); 
# 127
int yn = y + (((lut)[n])[1]); 
# 129
if ((xn >= 0) && (xn < ((flag_).cols)) && (yn >= 0) && (yn < ((flag_).rows)) && (((flag_)(yn, xn)) != (KNOWN))) 
# 130
{ 
# 131
(dist_)(yn, xn) = std::min(std::min(this->solve(xn - 1, yn, xn, yn - 1), this->solve(xn + 1, yn, xn, yn - 1)), std::min(this->solve(xn - 1, yn, xn, yn + 1), this->solve(xn + 1, yn, xn, yn + 1))); 
# 134
if (((flag_)(yn, xn)) == (INSIDE)) 
# 135
{ 
# 136
(flag_)(yn, xn) = (BAND); 
# 137
inpaint(xn, yn); 
# 138
this->heapAdd(DXY((dist_)(yn, xn), xn, yn)); 
# 139
} else 
# 141
{ 
# 142
int i = (index_)(yn, xn); 
# 143
if ((dist_)(yn, xn) < ((narrowBand_)[i].dist)) 
# 144
{ 
# 145
((narrowBand_)[i].dist) = (dist_)(yn, xn); 
# 146
this->heapUp(i); 
# 147
}  
# 154
}  
# 155
}  
# 156
}  
# 157
}  
# 159
return inpaint; 
# 160
} 
# 162
}
# 163
}
# 53 "/usr/include/opencv2/videostab/inpainting.hpp" 3
namespace cv { 
# 55
namespace videostab { 
# 61
class __attribute((visibility("default"))) InpainterBase { 
# 64
public: InpainterBase() : radius_(0), motionModel_(MM_UNKNOWN), frames_((0)), motions_((0)), stabilizedFrames_((0)), stabilizationMotions_((0)) 
# 66
{ } 
# 68
virtual ~InpainterBase() { } 
# 70
virtual void setRadius(int val) { (radius_) = val; } 
# 71
virtual int radius() const { return radius_; } 
# 73
virtual void setMotionModel(MotionModel val) { (motionModel_) = val; } 
# 74
virtual MotionModel motionModel() const { return motionModel_; } 
# 76
virtual void inpaint(int idx, Mat & frame, Mat & mask) = 0; 
# 81
virtual void setFrames(const std::vector< Mat>  &val) { (frames_) = (&val); } 
# 82
virtual const std::vector< Mat>  &frames() const { return *(frames_); } 
# 84
virtual void setMotions(const std::vector< Mat>  &val) { (motions_) = (&val); } 
# 85
virtual const std::vector< Mat>  &motions() const { return *(motions_); } 
# 87
virtual void setStabilizedFrames(const std::vector< Mat>  &val) { (stabilizedFrames_) = (&val); } 
# 88
virtual const std::vector< Mat>  &stabilizedFrames() const { return *(stabilizedFrames_); } 
# 90
virtual void setStabilizationMotions(const std::vector< Mat>  &val) { (stabilizationMotions_) = (&val); } 
# 91
virtual const std::vector< Mat>  &stabilizationMotions() const { return *(stabilizationMotions_); } 
# 94
protected: int radius_; 
# 95
MotionModel motionModel_; 
# 96
const std::vector< Mat>  *frames_; 
# 97
const std::vector< Mat>  *motions_; 
# 98
const std::vector< Mat>  *stabilizedFrames_; 
# 99
const std::vector< Mat>  *stabilizationMotions_; 
# 100
}; 
# 102
class __attribute((visibility("default"))) NullInpainter : public InpainterBase { 
# 105
public: virtual void inpaint(int, Mat &, Mat &) { } 
# 106
}; 
# 108
class __attribute((visibility("default"))) InpaintingPipeline : public InpainterBase { 
# 111
public: void pushBack(Ptr< InpainterBase>  inpainter) { (inpainters_).push_back(inpainter); } 
# 112
bool empty() const { return (inpainters_).empty(); } 
# 114
virtual void setRadius(int val); 
# 115
virtual void setMotionModel(MotionModel val); 
# 116
virtual void setFrames(const std::vector< Mat>  & val); 
# 117
virtual void setMotions(const std::vector< Mat>  & val); 
# 118
virtual void setStabilizedFrames(const std::vector< Mat>  & val); 
# 119
virtual void setStabilizationMotions(const std::vector< Mat>  & val); 
# 121
virtual void inpaint(int idx, Mat & frame, Mat & mask); 
# 124
private: std::vector< Ptr< InpainterBase> >  inpainters_; 
# 125
}; 
# 127
class __attribute((visibility("default"))) ConsistentMosaicInpainter : public InpainterBase { 
# 130
public: ConsistentMosaicInpainter(); 
# 132
void setStdevThresh(float val) { (stdevThresh_) = val; } 
# 133
float stdevThresh() const { return stdevThresh_; } 
# 135
virtual void inpaint(int idx, Mat & frame, Mat & mask); 
# 138
private: float stdevThresh_; 
# 139
}; 
# 141
class __attribute((visibility("default"))) MotionInpainter : public InpainterBase { 
# 144
public: MotionInpainter(); 
# 146
void setOptFlowEstimator(Ptr< IDenseOptFlowEstimator>  val) { ((optFlowEstimator_) = val); } 
# 147
Ptr< IDenseOptFlowEstimator>  optFlowEstimator() const { return optFlowEstimator_; } 
# 149
void setFlowErrorThreshold(float val) { (flowErrorThreshold_) = val; } 
# 150
float flowErrorThreshold() const { return flowErrorThreshold_; } 
# 152
void setDistThreshold(float val) { (distThresh_) = val; } 
# 153
float distThresh() const { return distThresh_; } 
# 155
void setBorderMode(int val) { (borderMode_) = val; } 
# 156
int borderMode() const { return borderMode_; } 
# 158
virtual void inpaint(int idx, Mat & frame, Mat & mask); 
# 161
private: FastMarchingMethod fmm_; 
# 162
Ptr< IDenseOptFlowEstimator>  optFlowEstimator_; 
# 163
float flowErrorThreshold_; 
# 164
float distThresh_; 
# 165
int borderMode_; 
# 167
Mat frame1_, transformedFrame1_; 
# 168
Mat_< unsigned char>  grayFrame_, transformedGrayFrame1_; 
# 169
Mat_< unsigned char>  mask1_, transformedMask1_; 
# 170
Mat_< float>  flowX_, flowY_, flowErrors_; 
# 171
Mat_< unsigned char>  flowMask_; 
# 172
}; 
# 174
class __attribute((visibility("default"))) ColorAverageInpainter : public InpainterBase { 
# 177
public: virtual void inpaint(int idx, Mat & frame, Mat & mask); 
# 180
private: FastMarchingMethod fmm_; 
# 181
}; 
# 183
class __attribute((visibility("default"))) ColorInpainter : public InpainterBase { 
# 186
public: inline ColorInpainter(int method = INPAINT_TELEA, double radius = (2.0)); 
# 188
virtual void inpaint(int idx, Mat & frame, Mat & mask); 
# 191
private: int method_; 
# 192
double radius_; 
# 193
Mat invMask_; 
# 194
}; 
# 196
inline ColorInpainter::ColorInpainter(int _method, double _radius) : method_(_method), radius_(_radius) 
# 197
{ } 
# 199
__attribute((visibility("default"))) void calcFlowMask(const Mat & flowX, const Mat & flowY, const Mat & errors, float maxError, const Mat & mask0, const Mat & mask1, Mat & flowMask); 
# 203
__attribute((visibility("default"))) void completeFrameAccordingToFlow(const Mat & flowMask, const Mat & flowX, const Mat & flowY, const Mat & frame1, const Mat & mask1, float distThresh, Mat & frame0, Mat & mask0); 
# 209
}
# 210
}
# 49 "/usr/include/opencv2/videostab/deblurring.hpp" 3
namespace cv { 
# 51
namespace videostab { 
# 57
__attribute((visibility("default"))) float calcBlurriness(const Mat & frame); 
# 59
class __attribute((visibility("default"))) DeblurerBase { 
# 62
public: DeblurerBase() : radius_(0), frames_((0)), motions_((0)), blurrinessRates_((0)) { } 
# 64
virtual ~DeblurerBase() { } 
# 66
virtual void setRadius(int val) { (radius_) = val; } 
# 67
virtual int radius() const { return radius_; } 
# 69
virtual void deblur(int idx, Mat & frame) = 0; 
# 74
virtual void setFrames(const std::vector< Mat>  &val) { (frames_) = (&val); } 
# 75
virtual const std::vector< Mat>  &frames() const { return *(frames_); } 
# 77
virtual void setMotions(const std::vector< Mat>  &val) { (motions_) = (&val); } 
# 78
virtual const std::vector< Mat>  &motions() const { return *(motions_); } 
# 80
virtual void setBlurrinessRates(const std::vector< float>  &val) { (blurrinessRates_) = (&val); } 
# 81
virtual const std::vector< float>  &blurrinessRates() const { return *(blurrinessRates_); } 
# 84
protected: int radius_; 
# 85
const std::vector< Mat>  *frames_; 
# 86
const std::vector< Mat>  *motions_; 
# 87
const std::vector< float>  *blurrinessRates_; 
# 88
}; 
# 90
class __attribute((visibility("default"))) NullDeblurer : public DeblurerBase { 
# 93
public: virtual void deblur(int, Mat &) { } 
# 94
}; 
# 96
class __attribute((visibility("default"))) WeightingDeblurer : public DeblurerBase { 
# 99
public: WeightingDeblurer(); 
# 101
void setSensitivity(float val) { (sensitivity_) = val; } 
# 102
float sensitivity() const { return sensitivity_; } 
# 104
virtual void deblur(int idx, Mat & frame); 
# 107
private: float sensitivity_; 
# 108
Mat_< float>  bSum_, gSum_, rSum_, wSum_; 
# 109
}; 
# 113
}
# 114
}
# 52 "/usr/include/opencv2/videostab/wobble_suppression.hpp" 3
namespace cv { 
# 54
namespace videostab { 
# 60
class __attribute((visibility("default"))) WobbleSuppressorBase { 
# 63
public: WobbleSuppressorBase(); 
# 65
virtual ~WobbleSuppressorBase() { } 
# 67
void setMotionEstimator(Ptr< ImageMotionEstimatorBase>  val) { ((motionEstimator_) = val); } 
# 68
Ptr< ImageMotionEstimatorBase>  motionEstimator() const { return motionEstimator_; } 
# 70
virtual void suppress(int idx, const Mat & frame, Mat & result) = 0; 
# 75
virtual void setFrameCount(int val) { (frameCount_) = val; } 
# 76
virtual int frameCount() const { return frameCount_; } 
# 78
virtual void setMotions(const std::vector< Mat>  &val) { (motions_) = (&val); } 
# 79
virtual const std::vector< Mat>  &motions() const { return *(motions_); } 
# 81
virtual void setMotions2(const std::vector< Mat>  &val) { (motions2_) = (&val); } 
# 82
virtual const std::vector< Mat>  &motions2() const { return *(motions2_); } 
# 84
virtual void setStabilizationMotions(const std::vector< Mat>  &val) { (stabilizationMotions_) = (&val); } 
# 85
virtual const std::vector< Mat>  &stabilizationMotions() const { return *(stabilizationMotions_); } 
# 88
protected: Ptr< ImageMotionEstimatorBase>  motionEstimator_; 
# 89
int frameCount_; 
# 90
const std::vector< Mat>  *motions_; 
# 91
const std::vector< Mat>  *motions2_; 
# 92
const std::vector< Mat>  *stabilizationMotions_; 
# 93
}; 
# 95
class __attribute((visibility("default"))) NullWobbleSuppressor : public WobbleSuppressorBase { 
# 98
public: virtual void suppress(int idx, const Mat & frame, Mat & result); 
# 99
}; 
# 101
class __attribute((visibility("default"))) MoreAccurateMotionWobbleSuppressorBase : public WobbleSuppressorBase { 
# 104
public: virtual void setPeriod(int val) { (period_) = val; } 
# 105
virtual int period() const { return period_; } 
# 108
protected: MoreAccurateMotionWobbleSuppressorBase() { this->setPeriod(30); } 
# 110
int period_; 
# 111
}; 
# 113
class __attribute((visibility("default"))) MoreAccurateMotionWobbleSuppressor : public MoreAccurateMotionWobbleSuppressorBase { 
# 116
public: virtual void suppress(int idx, const Mat & frame, Mat & result); 
# 119
private: Mat_< float>  mapx_, mapy_; 
# 120
}; 
# 137 "/usr/include/opencv2/videostab/wobble_suppression.hpp" 3
}
# 138
}
# 58 "/usr/include/opencv2/videostab/stabilizer.hpp" 3
namespace cv { 
# 60
namespace videostab { 
# 66
class __attribute((visibility("default"))) StabilizerBase { 
# 69
public: virtual ~StabilizerBase() { } 
# 71
void setLog(Ptr< ILog>  ilog) { ((log_) = ilog); } 
# 72
Ptr< ILog>  log() const { return log_; } 
# 74
void setRadius(int val) { (radius_) = val; } 
# 75
int radius() const { return radius_; } 
# 77
void setFrameSource(Ptr< IFrameSource>  val) { ((frameSource_) = val); } 
# 78
Ptr< IFrameSource>  frameSource() const { return frameSource_; } 
# 80
void setMotionEstimator(Ptr< ImageMotionEstimatorBase>  val) { ((motionEstimator_) = val); } 
# 81
Ptr< ImageMotionEstimatorBase>  motionEstimator() const { return motionEstimator_; } 
# 83
void setDeblurer(Ptr< DeblurerBase>  val) { ((deblurer_) = val); } 
# 84
Ptr< DeblurerBase>  deblurrer() const { return deblurer_; } 
# 86
void setTrimRatio(float val) { (trimRatio_) = val; } 
# 87
float trimRatio() const { return trimRatio_; } 
# 89
void setCorrectionForInclusion(bool val) { (doCorrectionForInclusion_) = val; } 
# 90
bool doCorrectionForInclusion() const { return doCorrectionForInclusion_; } 
# 92
void setBorderMode(int val) { (borderMode_) = val; } 
# 93
int borderMode() const { return borderMode_; } 
# 95
void setInpainter(Ptr< InpainterBase>  val) { ((inpainter_) = val); } 
# 96
Ptr< InpainterBase>  inpainter() const { return inpainter_; } 
# 99
protected: StabilizerBase(); 
# 101
void reset(); 
# 102
Mat nextStabilizedFrame(); 
# 103
bool doOneIteration(); 
# 104
virtual void setUp(const Mat & firstFrame); 
# 105
virtual Mat estimateMotion() = 0; 
# 106
virtual Mat estimateStabilizationMotion() = 0; 
# 107
void stabilizeFrame(); 
# 108
virtual Mat postProcessFrame(const Mat & frame); 
# 109
void logProcessingTime(); 
# 111
Ptr< ILog>  log_; 
# 112
Ptr< IFrameSource>  frameSource_; 
# 113
Ptr< ImageMotionEstimatorBase>  motionEstimator_; 
# 114
Ptr< DeblurerBase>  deblurer_; 
# 115
Ptr< InpainterBase>  inpainter_; 
# 116
int radius_; 
# 117
float trimRatio_; 
# 118
bool doCorrectionForInclusion_; 
# 119
int borderMode_; 
# 121
Size frameSize_; 
# 122
Mat frameMask_; 
# 123
int curPos_; 
# 124
int curStabilizedPos_; 
# 125
bool doDeblurring_; 
# 126
Mat preProcessedFrame_; 
# 127
bool doInpainting_; 
# 128
Mat inpaintingMask_; 
# 129
Mat finalFrame_; 
# 130
std::vector< Mat>  frames_; 
# 131
std::vector< Mat>  motions_; 
# 132
std::vector< float>  blurrinessRates_; 
# 133
std::vector< Mat>  stabilizedFrames_; 
# 134
std::vector< Mat>  stabilizedMasks_; 
# 135
std::vector< Mat>  stabilizationMotions_; 
# 136
clock_t processingStartTime_; 
# 137
}; 
# 139
class __attribute((visibility("default"))) OnePassStabilizer : public StabilizerBase, public IFrameSource { 
# 142
public: OnePassStabilizer(); 
# 144
void setMotionFilter(Ptr< MotionFilterBase>  val) { ((motionFilter_) = val); } 
# 145
Ptr< MotionFilterBase>  motionFilter() const { return motionFilter_; } 
# 147
virtual void reset(); 
# 148
virtual Mat nextFrame() { return this->nextStabilizedFrame(); } 
# 151
protected: virtual void setUp(const Mat & firstFrame); 
# 152
virtual Mat estimateMotion(); 
# 153
virtual Mat estimateStabilizationMotion(); 
# 154
virtual Mat postProcessFrame(const Mat & frame); 
# 156
Ptr< MotionFilterBase>  motionFilter_; 
# 157
}; 
# 159
class __attribute((visibility("default"))) TwoPassStabilizer : public StabilizerBase, public IFrameSource { 
# 162
public: TwoPassStabilizer(); 
# 164
void setMotionStabilizer(Ptr< IMotionStabilizer>  val) { ((motionStabilizer_) = val); } 
# 165
Ptr< IMotionStabilizer>  motionStabilizer() const { return motionStabilizer_; } 
# 167
void setWobbleSuppressor(Ptr< WobbleSuppressorBase>  val) { ((wobbleSuppressor_) = val); } 
# 168
Ptr< WobbleSuppressorBase>  wobbleSuppressor() const { return wobbleSuppressor_; } 
# 170
void setEstimateTrimRatio(bool val) { (mustEstTrimRatio_) = val; } 
# 171
bool mustEstimateTrimaRatio() const { return mustEstTrimRatio_; } 
# 173
virtual void reset(); 
# 174
virtual Mat nextFrame(); 
# 177
protected: void runPrePassIfNecessary(); 
# 179
virtual void setUp(const Mat & firstFrame); 
# 180
virtual Mat estimateMotion(); 
# 181
virtual Mat estimateStabilizationMotion(); 
# 182
virtual Mat postProcessFrame(const Mat & frame); 
# 184
Ptr< IMotionStabilizer>  motionStabilizer_; 
# 185
Ptr< WobbleSuppressorBase>  wobbleSuppressor_; 
# 186
bool mustEstTrimRatio_; 
# 188
int frameCount_; 
# 189
bool isPrePassDone_; 
# 190
bool doWobbleSuppression_; 
# 191
std::vector< Mat>  motions2_; 
# 192
Mat suppressedFrame_; 
# 193
}; 
# 197
}
# 198
}
# 49 "/usr/include/opencv2/videostab/ring_buffer.hpp" 3
namespace cv { 
# 51
namespace videostab { 
# 57
template< class T> inline T &at(int idx, std::vector< T>  &items) 
# 58
{ 
# 59
return items[cv::borderInterpolate(idx, static_cast< int>((items.size())), cv::BORDER_WRAP)]; 
# 60
} 
# 62
template< class T> inline const T &at(int idx, const std::vector< T>  &items) 
# 63
{ 
# 64
return items[cv::borderInterpolate(idx, static_cast< int>((items.size())), cv::BORDER_WRAP)]; 
# 65
} 
# 69
}
# 70
}
# 12 "/home/nvidia/checkerboard-detection/include/common.h"
typedef unsigned char byte; 
# 14
static const int offsets[9][2] = {{(-1), (-1)}, {0, (-1)}, {1, (-1)}, {(-1), 0}, {0, 0}, {1, 0}, {(-1), 1}, {0, 1}, {1, 1}}; 
# 26
static const int offsets7x7[49][2] = {{(-3), (-3)}, {(-2), (-3)}, {1, (-3)}, {0, (-3)}, {1, (-3)}, {2, (-3)}, {3, (-3)}, {(-3), (-2)}, {(-2), (-2)}, {1, (-2)}, {0, (-2)}, {1, (-2)}, {2, (-2)}, {3, (-2)}, {(-3), (-1)}, {(-2), (-1)}, {1, (-1)}, {0, (-1)}, {1, (-1)}, {2, (-1)}, {3, (-1)}, {(-3), 0}, {(-2), 0}, {1, 0}, {0, 0}, {1, 0}, {2, 0}, {3, 0}, {(-3), 1}, {(-2), 1}, {1, 1}, {0, 1}, {1, 1}, {2, 1}, {3, 1}, {(-3), 2}, {(-2), 2}, {1, 2}, {0, 2}, {1, 2}, {2, 2}, {3, 2}, {(-3), 3}, {(-2), 3}, {1, 3}, {0, 3}, {1, 3}, {2, 3}, {3, 3}}; 
# 85
struct byte3_t { 
# 86
byte3_t() { } 
# 87
byte3_t(byte x, byte y, byte z) { 
# 88
(this->x) = x; 
# 89
(this->y) = y; 
# 90
(this->z) = z; 
# 91
} 
# 93
byte x; 
# 94
byte y; 
# 95
byte z; 
# 96
}; 
# 98
struct int2_t { 
# 99
int2_t() { } 
# 100
int2_t(int x, int y) { 
# 101
(this->x) = x; 
# 102
(this->y) = y; 
# 103
} 
# 105
int x; 
# 106
int y; 
# 107
}; 
# 109
struct int3_t { 
# 110
int3_t() { } 
# 111
int3_t(int x, int y, int z) { 
# 112
(this->x) = x; 
# 113
(this->y) = y; 
# 114
(this->z) = z; 
# 115
} 
# 117
int x; 
# 118
int y; 
# 119
int z; 
# 120
}; 
# 122
struct float2_t { 
# 123
float2_t() { } 
# 124
float2_t(float x, float y) { 
# 125
(this->x) = x; 
# 126
(this->y) = y; 
# 127
} 
# 129
float x; 
# 130
float y; 
# 131
}; 
# 133
struct float3_t { 
# 134
float3_t() { } 
# 135
float3_t(float x, float y, float z) { 
# 136
(this->x) = x; 
# 137
(this->y) = y; 
# 138
(this->z) = z; 
# 139
} 
# 141
float x; 
# 142
float y; 
# 143
float z; 
# 144
}; 
# 146
struct float4_t { 
# 147
float4_t() { } 
# 148
float4_t(float x, float y, float z, float w) { 
# 149
(this->x) = x; 
# 150
(this->y) = y; 
# 151
(this->z) = z; 
# 152
(this->w) = w; 
# 153
} 
# 155
float x; 
# 156
float y; 
# 157
float z; 
# 158
float w; 
# 159
}; 
# 161
struct string3_t { 
# 162
string3_t() { } 
# 163
string3_t(std::__cxx11::string x, std::__cxx11::string y, std::__cxx11::string z) { 
# 164
((this->x) = x); 
# 165
((this->y) = y); 
# 166
((this->z) = z); 
# 167
} 
# 169
std::__cxx11::string x; 
# 170
std::__cxx11::string y; 
# 171
std::__cxx11::string z; 
# 172
}; 
# 174
struct string4_t { 
# 175
string4_t() { } 
# 176
string4_t(std::__cxx11::string x, std::__cxx11::string y, std::__cxx11::string z, std::__cxx11::string w) { 
# 177
((this->x) = x); 
# 178
((this->y) = y); 
# 179
((this->z) = z); 
# 180
((this->w) = w); 
# 181
} 
# 183
std::__cxx11::string x; 
# 184
std::__cxx11::string y; 
# 185
std::__cxx11::string z; 
# 186
std::__cxx11::string w; 
# 187
}; 
# 189
struct matrix4x4_t { 
# 190
matrix4x4_t() { 
# 191
((this->rows)[0]) = float4_t(1, 0, 0, 0); 
# 192
((this->rows)[1]) = float4_t(0, 1, 0, 0); 
# 193
((this->rows)[2]) = float4_t(0, 0, 1, 0); 
# 194
((this->rows)[3]) = float4_t(0, 0, 0, 1); 
# 195
} 
# 196
matrix4x4_t(float4_t row1, float4_t row2, float4_t row3, float4_t row4) { 
# 197
((this->rows)[0]) = row1; 
# 198
((this->rows)[1]) = row2; 
# 199
((this->rows)[2]) = row3; 
# 200
((this->rows)[3]) = row4; 
# 201
} 
# 203
float4_t rows[4]; 
# 204
}; 
# 206
struct CameraTransform { 
# 209
float x = (0); 
# 210
float y = (0); 
# 211
float z = (0); 
# 214
float qw = (1); 
# 215
float qx = (0); 
# 216
float qy = (0); 
# 217
float qz = (0); 
# 218
}; 
# 220
struct Intrinsics { 
# 221
Intrinsics() { } 
# 222
Intrinsics(std::__cxx11::string model, float2_t c, float2_t f, float k0, float k1, float 
# 223
k2, float k3, float k4) { 
# 224
((this->model) = model); 
# 225
(this->c) = c; 
# 226
(this->f) = f; 
# 227
(this->k0) = k0; 
# 228
(this->k1) = k1; 
# 229
(this->k2) = k2; 
# 230
(this->k3) = k3; 
# 231
(this->k4) = k4; 
# 232
} 
# 234
std::__cxx11::string model; 
# 235
float2_t c; 
# 236
float2_t f; 
# 238
float k0; 
# 239
float k1; 
# 240
float k2; 
# 241
float k3; 
# 242
float k4; 
# 243
}; 
# 245
inline float distance3_f(float x1, float y1, float z1, float x2, float y2, float 
# 246
z2) { 
# 248
float d = sqrtf((powf(x1 - x2, 2) + powf(y1 - y2, 2)) + powf(z1 - z2, 2)); 
# 249
return d; 
# 250
} 
# 7 "/home/nvidia/checkerboard-detection/include/checkerboard/cuda/getLines.h"
struct GetLinesParams { 
# 8
int2_t resolution; 
# 9
int cornerCount; 
# 10
int rows; 
# 11
int cols; 
# 12
int pixelDifference; 
# 13
}; 
# 15
void GetLines(GetLinesParams params, int * corners, int * linesCount, int * lines, int * linePoints, int * linePointCount, cudaStream_t & stream); 
# 3 "/home/nvidia/checkerboard-detection/src/checkerboard/cuda/getCheckerBoardLines.cu"
void GetLinesKernel(GetLinesParams params, int *corners, int *
# 4
linesCount, int *lines, int *linePoints, int *
# 5
linePointCount) ;
#if 0
# 5
{ 
# 7
int threadId = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
# 8
int threads = (params.cornerCount) * ((params.cornerCount) - 1); 
# 9
if (threadId > threads) { 
# 10
return; }  
# 12
const int maxSize = 40; 
# 14
int mod = (params.cornerCount) - 1; 
# 15
int cornerId = threadId / mod; 
# 16
int compareId = threadId % mod; 
# 18
int corner = corners[cornerId]; 
# 20
int compareIdReal; 
# 21
if (compareId < cornerId) { 
# 22
compareIdReal = compareId; } else { 
# 24
compareIdReal = (compareId + 1); }  
# 26
int compareCorner = corners[compareIdReal]; 
# 28
int maxSide, minSide; 
# 29
if ((params.rows) > (params.cols)) { 
# 30
maxSide = (params.rows); 
# 31
minSide = (params.cols); 
# 32
} else { 
# 33
maxSide = (params.cols); 
# 34
minSide = (params.rows); 
# 35
}  
# 38
int ux, vx, uy, vy; 
# 40
ux = (corner % ((params.resolution).x)); 
# 41
uy = (corner / ((params.resolution).x)); 
# 42
vx = (compareCorner % ((params.resolution).x)); 
# 43
vy = (compareCorner / ((params.resolution).x)); 
# 45
float denominator = powf(vx - ux, 2) + powf(vy - uy, 2); 
# 46
float diffX = vx - ux; 
# 47
float diffY = vy - uy; 
# 48
float rootDenominator = sqrtf(denominator); 
# 50
int points1[maxSize] = {}; 
# 51
bool lineFail = false; 
# 54
int px, py; 
# 55
int pxDiffFromLine; 
# 56
if (((params.resolution).x) < 1000) { 
# 57
pxDiffFromLine = 4; } else { 
# 59
pxDiffFromLine = 5; }  
# 60
int pointCount = 0; 
# 61
for (int i = 0; i < (params.cornerCount); i++) { { 
# 62
if ((corner == (corners[i])) || (compareCorner == (corners[i]))) { 
# 63
continue; }  
# 65
px = ((corners[i]) % ((params.resolution).x)); 
# 66
py = ((corners[i]) / ((params.resolution).x)); 
# 67
float t = ((-1) * ((diffX * (ux - px)) + (diffY * (uy - py)))) / denominator; 
# 69
if ((t < (0)) || (t > (1))) { 
# 70
continue; }  
# 72
float distance = fabsf((diffX * (uy - py)) - (diffY * (ux - px))) / rootDenominator; 
# 75
if (distance < pxDiffFromLine) { 
# 77
((points1)[pointCount]) = (corners[i]); 
# 79
++pointCount; 
# 80
}  
# 81
} }  
# 83
if (pointCount < (minSide - 2)) { 
# 84
return; }  
# 86
int sizeOfLine1 = pointCount; 
# 88
float distanceArr1[maxSize] = {}; 
# 89
int xArr1[maxSize] = {}; 
# 90
int yArr1[maxSize] = {}; 
# 92
int arrangePointCount1 = 0; 
# 93
for (int i = 0; i < sizeOfLine1; i++) { 
# 95
int x = ((points1)[i]) % ((params.resolution).x); 
# 96
int y = ((points1)[i]) / ((params.resolution).x); 
# 98
float dist = powf(ux - x, 2) + powf(uy - y, 2); 
# 100
((distanceArr1)[arrangePointCount1]) = dist; 
# 101
((xArr1)[arrangePointCount1]) = x; 
# 102
((yArr1)[arrangePointCount1]) = y; 
# 104
++arrangePointCount1; 
# 105
}  
# 106
((distanceArr1)[arrangePointCount1]) = (powf(ux - vx, 2) + powf(uy - vy, 2)); 
# 107
((xArr1)[arrangePointCount1]) = vx; 
# 108
((yArr1)[arrangePointCount1]) = vy; 
# 111
for (int i = 0; i < arrangePointCount1; i++) { 
# 112
for (int j = i + 1; j < arrangePointCount1; j++) { { 
# 114
if ((((distanceArr1)[i]) == (0)) || (((distanceArr1)[j]) == (0))) { 
# 115
continue; }  
# 117
if (((distanceArr1)[i]) > ((distanceArr1)[j])) { 
# 118
float a = (distanceArr1)[i]; 
# 119
((distanceArr1)[i]) = ((distanceArr1)[j]); 
# 120
((distanceArr1)[j]) = a; 
# 122
int ax = (xArr1)[i]; 
# 123
((xArr1)[i]) = ((xArr1)[j]); 
# 124
((xArr1)[j]) = ax; 
# 126
int ay = (yArr1)[i]; 
# 127
((yArr1)[i]) = ((yArr1)[j]); 
# 128
((yArr1)[j]) = ay; 
# 129
}  
# 130
} }  
# 131
}  
# 133
for (int i = 0; i < pointCount; i++) { 
# 134
float dist1; 
# 135
if (i == 0) { 
# 136
dist1 = (powf(((xArr1)[i]) - ux, 2) + powf(((yArr1)[i]) - uy, 2)); } else { 
# 138
dist1 = (powf(((xArr1)[i]) - ((xArr1)[i - 1]), 2) + powf(((yArr1)[i]) - ((yArr1)[i - 1]), 2)); }  
# 141
float dist2 = powf(((xArr1)[i + 1]) - ((xArr1)[i]), 2) + powf(((yArr1)[i + 1]) - ((yArr1)[i]), 2); 
# 144
float percentageDiff = fabsf(dist1 - dist2) / dist2; 
# 146
if (((100) * percentageDiff) > (60)) { 
# 148
lineFail = true; 
# 149
break; 
# 150
}  
# 151
}  
# 153
if (lineFail) { 
# 154
return; }  
# 158
bool horizontal = false; 
# 159
bool vertical = false; 
# 161
int point1[2] = {}; 
# 162
int point2[2] = {}; 
# 164
float yGradient = vy - uy; 
# 165
if (yGradient == (0)) { 
# 166
horizontal = true; }  
# 167
float xGradient = vx - ux; 
# 168
if (xGradient == (0)) { 
# 169
vertical = true; }  
# 171
if ((!horizontal) && (!vertical)) { 
# 174
float m = yGradient / xGradient; 
# 175
int b = uy - (m * ux); 
# 178
if ((b == 0) || ((b < (((params.resolution).y) - 1)) && (b > 0))) { 
# 179
((point1)[0]) = 0; 
# 180
((point1)[1]) = b; 
# 181
} else { 
# 184
if (b >= ((params.resolution).y)) { 
# 185
((point1)[0]) = ((((params.resolution).y) - b) / m); 
# 186
((point1)[1]) = (((params.resolution).y) - 1); 
# 187
} else { 
# 188
((point1)[0]) = ((-b) / m); 
# 189
((point1)[1]) = 0; 
# 190
}  
# 191
}  
# 194
int b2 = (((params.resolution).x) * m) + b; 
# 195
if ((b2 == 0) || ((b2 < (((params.resolution).y) - 1)) && (b2 > 0))) { 
# 196
((point2)[0]) = (((params.resolution).x) - 1); 
# 197
((point2)[1]) = b2; 
# 199
} else { 
# 201
if (b2 >= ((params.resolution).y)) { 
# 202
((point2)[0]) = ((((params.resolution).y) - b) / m); 
# 203
((point2)[1]) = (((params.resolution).y) - 1); 
# 204
} else { 
# 205
((point2)[0]) = ((-b) / m); 
# 206
((point2)[1]) = 0; 
# 207
}  
# 208
}  
# 210
} else { 
# 212
if (vertical) { 
# 213
((point1)[0]) = ux; 
# 214
((point1)[1]) = 0; 
# 215
((point2)[0]) = ux; 
# 216
((point2)[1]) = (((params.resolution).y) - 1); 
# 217
} else { if (horizontal) { 
# 218
((point1)[0]) = 0; 
# 219
((point1)[1]) = uy; 
# 220
((point2)[0]) = (((params.resolution).x) - 1); 
# 221
((point2)[1]) = uy; 
# 222
}  }  
# 223
}  
# 225
pxDiffFromLine = (params.pixelDifference); 
# 227
denominator = (powf(((point2)[0]) - ((point1)[0]), 2) + powf(((point2)[1]) - ((point1)[1]), 2)); 
# 228
diffX = (((point2)[0]) - ((point1)[0])); 
# 229
diffY = (((point2)[1]) - ((point1)[1])); 
# 230
rootDenominator = sqrtf(denominator); 
# 232
int points[maxSize] = {}; 
# 234
pointCount = 0; 
# 235
for (int i = 0; i < (params.cornerCount); i++) { { 
# 237
px = ((corners[i]) % ((params.resolution).x)); 
# 238
py = ((corners[i]) / ((params.resolution).x)); 
# 239
float t = ((-1) * ((diffX * (((point1)[0]) - px)) + (diffY * (((point1)[1]) - py)))) / denominator; 
# 242
if ((t < (0)) || (t > (1))) { 
# 243
continue; }  
# 245
float distance = fabsf((diffX * (((point1)[1]) - py)) - (diffY * (((point1)[0]) - px))) / rootDenominator; 
# 249
if (distance < pxDiffFromLine) { 
# 251
((points)[pointCount]) = (corners[i]); 
# 253
++pointCount; 
# 254
}  
# 256
if (pointCount == maxSize) { 
# 257
return; }  
# 258
} }  
# 260
int sizeOfLine = pointCount; 
# 262
float distanceArr[maxSize] = {}; 
# 263
int xArr[maxSize] = {}; 
# 264
int yArr[maxSize] = {}; 
# 266
int arrangePointCount = 0; 
# 267
for (int i = 0; i < sizeOfLine; i++) { 
# 269
int x = ((points)[i]) % ((params.resolution).x); 
# 270
int y = ((points)[i]) / ((params.resolution).x); 
# 272
float dist = powf(((point1)[0]) - x, 2) + powf(((point1)[1]) - y, 2); 
# 273
((distanceArr)[arrangePointCount]) = dist; 
# 274
((xArr)[arrangePointCount]) = x; 
# 275
((yArr)[arrangePointCount]) = y; 
# 277
++arrangePointCount; 
# 278
}  
# 281
for (int i = 0; i < arrangePointCount; i++) { 
# 282
for (int j = i + 1; j < arrangePointCount; j++) { { 
# 284
if ((((distanceArr)[i]) == (0)) || (((distanceArr)[j]) == (0))) { 
# 285
continue; }  
# 287
if (((distanceArr)[i]) > ((distanceArr)[j])) { 
# 288
float a = (distanceArr)[i]; 
# 289
((distanceArr)[i]) = ((distanceArr)[j]); 
# 290
((distanceArr)[j]) = a; 
# 292
int ax = (xArr)[i]; 
# 293
((xArr)[i]) = ((xArr)[j]); 
# 294
((xArr)[j]) = ax; 
# 296
int ay = (yArr)[i]; 
# 297
((yArr)[i]) = ((yArr)[j]); 
# 298
((yArr)[j]) = ay; 
# 299
}  
# 300
} }  
# 301
}  
# 303
int goodPointsSize = 2; 
# 304
int startIndex = 0; 
# 306
for (int i = 1; i < sizeOfLine; i++) { { 
# 307
bool badPercentageDiff = false; 
# 308
float dist1 = powf(((xArr)[i]) - ((xArr)[i - 1]), 2) + powf(((yArr)[i]) - ((yArr)[i - 1]), 2); 
# 311
float dist2 = powf(((xArr)[i + 1]) - ((xArr)[i]), 2) + powf(((yArr)[i + 1]) - ((yArr)[i]), 2); 
# 314
float percentageDiff = fabsf(dist1 - dist2) / dist2; 
# 316
if (((100) * percentageDiff) > (80)) { 
# 317
badPercentageDiff = true; }  
# 319
if (badPercentageDiff && (goodPointsSize < minSide)) { 
# 320
if (i == 1) { 
# 321
startIndex = i; 
# 322
continue; 
# 323
}  
# 324
startIndex = (i + 1); 
# 325
i++; 
# 326
goodPointsSize = 1; 
# 328
} else { if (badPercentageDiff && (goodPointsSize >= minSide)) { 
# 329
break; }  }  
# 331
++goodPointsSize; 
# 332
} }  
# 334
if (goodPointsSize >= minSide) { 
# 336
bool secondcase = false; 
# 337
if (((ux > 1235) && (ux < 1241) && (uy > 229) && (uy < 236)) || ((vx > 1235) && (vx < 1241) && (vy > 229) && (vy < 236))) { 
# 339
secondcase = true; }  
# 341
int index = atomicAdd(linesCount, 1); 
# 343
(lines[index * 2]) = ((((point1)[1]) * ((params.resolution).x)) + ((point1)[0])); 
# 344
(lines[(index * 2) + 1]) = ((((point2)[1]) * ((params.resolution).x)) + ((point2)[0])); 
# 345
(linePointCount[index]) = goodPointsSize; 
# 346
for (int j = 0; j < goodPointsSize; j++) { 
# 347
(linePoints[(index * maxSize) + j]) = ((((yArr)[j + startIndex]) * ((params.resolution).x)) + ((xArr)[j + startIndex])); 
# 349
}  
# 350
}  
# 351
} 
#endif
# 353 "/home/nvidia/checkerboard-detection/src/checkerboard/cuda/getCheckerBoardLines.cu"
void GetLines(GetLinesParams params, int *corners, int *linesCount, int *lines, int *
# 354
linePoints, int *linePointCount, cudaStream_t &stream) { 
# 356
int threads = (params.cornerCount) * ((params.cornerCount) - 1); 
# 357
int blocks = ceil(threads / (128.0F)); 
# 359
(cudaConfigureCall(blocks, (128.0F), 0, stream)) ? (void)0 : GetLinesKernel(params, corners, linesCount, lines, linePoints, linePointCount); 
# 362
cudaGetError("GetLines"); 
# 363
} 

# 1 "getCheckerBoardLines.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__28_getCheckerBoardLines_cpp1_ii_e6ca3c84
# 1 "getCheckerBoardLines.cudafe1.stub.c"
#include "getCheckerBoardLines.cudafe1.stub.c"
# 1 "getCheckerBoardLines.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
